Submodule jfaudiolib 61d3dc2..0e94055:
diff --git a/jfaudiolib/Makefile b/jfaudiolib/Makefile
index 2f0dda2..51895f9 100644
--- a/jfaudiolib/Makefile
+++ b/jfaudiolib/Makefile
@@ -1,17 +1,17 @@
 -include Makefile.user
 
-DXROOT ?= $(USERPROFILE)/sdks/directx/dx81
-
 ifeq (0,$(RELEASE))
  OPTLEVEL=-Og
 else
- OPTLEVEL=-O2
+ OPTLEVEL=-fomit-frame-pointer -O2
 endif
 
 CC?=gcc
 AR?=ar
-CFLAGS=-g $(OPTLEVEL) -Wall
+CFLAGS=-g $(OPTLEVEL) -W -Wall -Wno-unused-but-set-variable
 CPPFLAGS=-Iinclude -Isrc
+LDFLAGS=
+o=o
 
 SOURCES=src/drivers.c \
         src/fx_man.c \
@@ -29,11 +29,15 @@ SOURCES=src/drivers.c \
 include Makefile.shared
 
 ifeq (mingw32,$(findstring mingw32,$(machine)))
- CPPFLAGS+= -I$(DXROOT)/include -Ithird-party/mingw32/include
+ CPPFLAGS+= -Ithird-party/mingw32/include
  SOURCES+= src/driver_directsound.c src/driver_winmm.c
 
  CPPFLAGS+= -DHAVE_VORBIS
 else
+ ifeq (apple-darwin,$(findstring apple-darwin,$(machine)))
+  SOURCES+= src/driver_coreaudio.c
+  LDFLAGS+= -framework AudioToolbox -framework AudioUnit -framework Foundation
+ endif
  ifneq (0,$(JFAUDIOLIB_HAVE_SDL))
   CPPFLAGS+= -DHAVE_SDL=2 $(shell $(SDL2CONFIG) --cflags)
   ifeq (1,$(JFAUDIOLIB_USE_SDLMIXER))
@@ -58,6 +62,11 @@ endif
 
 OBJECTS=$(SOURCES:%.c=%.o)
 
+.PHONY: all
+all: $(JFAUDIOLIB) test
+
+include Makefile.deps
+
 $(JFAUDIOLIB): $(OBJECTS)
 	$(AR) cr $@ $^
 
@@ -65,7 +74,7 @@ $(OBJECTS): %.o: %.c
 	$(CC) -c $(CPPFLAGS) $(CFLAGS) $< -o $@
 
 test: src/test.o $(JFAUDIOLIB);
-	$(CC) $(CPPFLAGS) $(CFLAGS) $^ -o $@ $(JFAUDIOLIB_LDFLAGS) -lm
+	$(CC) $(CPPFLAGS) $(CFLAGS) $^ -o $@ $(LDFLAGS) $(JFAUDIOLIB_LDFLAGS) -lm
 
 .PHONY: clean
 clean:
diff --git a/jfaudiolib/Makefile.deps b/jfaudiolib/Makefile.deps
new file mode 100644
index 0000000..c58c140
--- /dev/null
+++ b/jfaudiolib/Makefile.deps
@@ -0,0 +1,19 @@
+src/asssys.$o: src/asssys.c src/asssys.h
+src/cd.$o: src/cd.c include/cd.h src/drivers.h include/sndcards.h src/midifuncs.h
+src/driver_alsa.$o: src/driver_alsa.c src/midifuncs.h src/driver_alsa.h
+src/driver_coreaudio.$o: src/driver_coreaudio.c src/asssys.h src/midifuncs.h src/driver_coreaudio.h
+src/driver_directsound.$o: src/driver_directsound.c src/asssys.h src/driver_directsound.h
+src/driver_fluidsynth.$o: src/driver_fluidsynth.c src/midifuncs.h src/driver_fluidsynth.h src/asssys.h
+src/driver_nosound.$o: src/driver_nosound.c src/midifuncs.h
+src/driver_sdl.$o: src/driver_sdl.c src/driver_sdl.h
+src/driver_winmm.$o: src/driver_winmm.c src/asssys.h src/assmisc.h src/midifuncs.h src/driver_winmm.h src/linklist.h
+src/drivers.$o: src/drivers.c src/drivers.h include/sndcards.h src/midifuncs.h src/driver_alsa.h src/driver_coreaudio.h src/driver_directsound.h src/driver_fluidsynth.h src/driver_nosound.h src/driver_sdl.h src/driver_winmm.h
+src/fx_man.$o: src/fx_man.c include/sndcards.h src/drivers.h src/midifuncs.h src/multivoc.h include/fx_man.h include/sndcards.h
+src/midi.$o: src/midi.c include/sndcards.h src/drivers.h src/midifuncs.h src/ll_man.h include/music.h include/sndcards.h src/_midi.h src/midi.h src/asssys.h
+src/mix.$o: src/mix.c src/_multivc.h
+src/mixst.$o: src/mixst.c src/_multivc.h
+src/multivoc.$o: src/multivoc.c src/linklist.h include/sndcards.h src/drivers.h src/midifuncs.h src/pitch.h src/multivoc.h src/_multivc.h
+src/music.$o: src/music.c include/sndcards.h src/drivers.h src/midifuncs.h include/music.h include/sndcards.h src/midi.h src/ll_man.h
+src/pitch.$o: src/pitch.c src/pitch.h
+src/vorbis.$o: src/vorbis.c
+src/test.$o: src/test.c include/fx_man.h include/music.h src/drivers.h src/asssys.h
diff --git a/jfaudiolib/Makefile.msvc b/jfaudiolib/Makefile.msvc
index 0860c40..f4ea5ca 100644
--- a/jfaudiolib/Makefile.msvc
+++ b/jfaudiolib/Makefile.msvc
@@ -1,6 +1,7 @@
 CC=cl
 CFLAGS=/MD /J /nologo /O2
 CPPFLAGS=/Iinclude /Isrc /Isrc\msvc
+o=obj
 
 SOURCES=src\drivers.c \
         src\fx_man.c \
@@ -19,6 +20,13 @@ SOURCES=src\drivers.c \
 
 !include Makefile.msvcshared
 
+!if "$(PLATFORM)" == ""
+PLATFORM=x86
+!endif
+!if "$(PLATFORM)" == "X86" || "$(PLATFORM)" == "x86"
+CFLAGS=$(CFLAGS) /arch:IA32
+!endif
+
 !if $(JFAUDIOLIB_HAVE_VORBIS)
 CPPFLAGS=$(CPPFLAGS) /DHAVE_VORBIS /Ithird-party\msvc\include
 JFAUDIOLIB_LINKFLAGS=$(JFAUDIOLIB_LINKFLAGS) /LIBPATH:$(MAKEDIR)\third-party\msvc\lib$(PLATFORM)
@@ -26,6 +34,10 @@ JFAUDIOLIB_LINKFLAGS=$(JFAUDIOLIB_LINKFLAGS) /LIBPATH:$(MAKEDIR)\third-party\msv
 
 OBJECTS=$(SOURCES:.c=.obj)
 
+all: $(JFAUDIOLIB) test.exe
+
+!include Makefile.deps
+
 $(JFAUDIOLIB): $(OBJECTS)
 	lib /out:$@ /nologo $**
 
@@ -36,4 +48,4 @@ test.exe: src\test.obj $(JFAUDIOLIB)
 	$(CC) /c $(CPPFLAGS) $(CFLAGS) /Fo$@ $<
 
 clean:
-	-del /q $(OBJECTS) $(JFAUDIOLIB) test.exe
+	-del /q $(OBJECTS) $(JFAUDIOLIB) src\test.obj test.exe
diff --git a/jfaudiolib/include/fx_man.h b/jfaudiolib/include/fx_man.h
index d0c8f10..60d6813 100644
--- a/jfaudiolib/include/fx_man.h
+++ b/jfaudiolib/include/fx_man.h
@@ -75,6 +75,7 @@ int FX_EndLooping( int handle );
 int FX_SetPan( int handle, int vol, int left, int right );
 int FX_SetPitch( int handle, int pitchoffset );
 int FX_SetFrequency( int handle, int frequency );
+int FX_GetFrequency( int handle, int *frequency );
 
 int FX_PlayVOC( char *ptr, unsigned int ptrlength, int pitchoffset, int vol, int left, int right,
        int priority, unsigned int callbackval );
diff --git a/jfaudiolib/include/sndcards.h b/jfaudiolib/include/sndcards.h
index 7e5652a..aa14c32 100644
--- a/jfaudiolib/include/sndcards.h
+++ b/jfaudiolib/include/sndcards.h
@@ -31,19 +31,19 @@ Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 #ifndef __SNDCARDS_H
 #define __SNDCARDS_H
 
-#define ASS_VERSION_STRING "JonoF 20090718"
+#define ASS_VERSION_STRING "JonoF 20210502"
 
 typedef enum
    {
    ASS_NoSound,
-   ASS_SDL,
    ASS_CoreAudio,
    ASS_DirectSound,
    ASS_WinMM,
-   ASS_FluidSynth,
+   ASS_FluidSynth,
    ASS_ALSA,
+   ASS_SDL,
    ASS_NumSoundCards,
-	ASS_AutoDetect = -2
+   ASS_AutoDetect = -2
    } soundcardnames;
 
 #endif
diff --git a/jfaudiolib/jfaudiolib.xcodeproj/project.pbxproj b/jfaudiolib/jfaudiolib.xcodeproj/project.pbxproj
index 0e51a6f..74f336e 100644
--- a/jfaudiolib/jfaudiolib.xcodeproj/project.pbxproj
+++ b/jfaudiolib/jfaudiolib.xcodeproj/project.pbxproj
@@ -10,6 +10,8 @@
 		AB0A488F1E43574900CC2214 /* libogg.a in Frameworks */ = {isa = PBXBuildFile; fileRef = AB0A488C1E43574900CC2214 /* libogg.a */; };
 		AB0A48901E43574900CC2214 /* libvorbis.a in Frameworks */ = {isa = PBXBuildFile; fileRef = AB0A488D1E43574900CC2214 /* libvorbis.a */; };
 		AB0A48911E43574900CC2214 /* libvorbisfile.a in Frameworks */ = {isa = PBXBuildFile; fileRef = AB0A488E1E43574900CC2214 /* libvorbisfile.a */; };
+		AB21362327531AA80033C569 /* assmisc.h in Headers */ = {isa = PBXBuildFile; fileRef = AB21362227531AA80033C569 /* assmisc.h */; };
+		AB21362B275378D90033C569 /* Foundation.framework in Frameworks */ = {isa = PBXBuildFile; fileRef = AB21362A275378D90033C569 /* Foundation.framework */; };
 		AB217B65172E645C00364868 /* driver_coreaudio.c in Sources */ = {isa = PBXBuildFile; fileRef = AB217B64172E645C00364868 /* driver_coreaudio.c */; };
 		AB217B67172E646A00364868 /* driver_coreaudio.h in Headers */ = {isa = PBXBuildFile; fileRef = AB217B66172E646A00364868 /* driver_coreaudio.h */; };
 		AB217B6D172E74BB00364868 /* AudioUnit.framework in Frameworks */ = {isa = PBXBuildFile; fileRef = AB217B6B172E669100364868 /* AudioUnit.framework */; };
@@ -59,6 +61,8 @@
 		AB0A488C1E43574900CC2214 /* libogg.a */ = {isa = PBXFileReference; lastKnownFileType = archive.ar; name = libogg.a; path = "third-party/osx/out/lib/libogg.a"; sourceTree = "<group>"; };
 		AB0A488D1E43574900CC2214 /* libvorbis.a */ = {isa = PBXFileReference; lastKnownFileType = archive.ar; name = libvorbis.a; path = "third-party/osx/out/lib/libvorbis.a"; sourceTree = "<group>"; };
 		AB0A488E1E43574900CC2214 /* libvorbisfile.a */ = {isa = PBXFileReference; lastKnownFileType = archive.ar; name = libvorbisfile.a; path = "third-party/osx/out/lib/libvorbisfile.a"; sourceTree = "<group>"; };
+		AB21362227531AA80033C569 /* assmisc.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = assmisc.h; sourceTree = "<group>"; };
+		AB21362A275378D90033C569 /* Foundation.framework */ = {isa = PBXFileReference; lastKnownFileType = wrapper.framework; name = Foundation.framework; path = System/Library/Frameworks/Foundation.framework; sourceTree = SDKROOT; };
 		AB217B64172E645C00364868 /* driver_coreaudio.c */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.c; path = driver_coreaudio.c; sourceTree = "<group>"; };
 		AB217B66172E646A00364868 /* driver_coreaudio.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = driver_coreaudio.h; sourceTree = "<group>"; };
 		AB217B6B172E669100364868 /* AudioUnit.framework */ = {isa = PBXFileReference; lastKnownFileType = wrapper.framework; name = AudioUnit.framework; path = System/Library/Frameworks/AudioUnit.framework; sourceTree = SDKROOT; };
@@ -113,6 +117,7 @@
 				AB32FA9A107712B700A9BAFF /* libjfaudiolib.a in Frameworks */,
 				AB217B6D172E74BB00364868 /* AudioUnit.framework in Frameworks */,
 				ABE4C94C172EA55A00B18CE9 /* AudioToolbox.framework in Frameworks */,
+				AB21362B275378D90033C569 /* Foundation.framework in Frameworks */,
 			);
 			runOnlyForDeploymentPostprocessing = 0;
 		};
@@ -143,6 +148,7 @@
 			children = (
 				ABFBB51E102EBD4100D48B58 /* _midi.h */,
 				AB2E9E4D1011E65900DD2F1F /* _multivc.h */,
+				AB21362227531AA80033C569 /* assmisc.h */,
 				AB32F97010762A7900A9BAFF /* asssys.c */,
 				AB32F97110762A7900A9BAFF /* asssys.h */,
 				ABBD3F17101FFBD900F32F37 /* cd.c */,
@@ -185,6 +191,7 @@
 		AB8C582E101B6B7900B42306 /* Frameworks */ = {
 			isa = PBXGroup;
 			children = (
+				AB21362A275378D90033C569 /* Foundation.framework */,
 				AB0A488C1E43574900CC2214 /* libogg.a */,
 				AB0A488D1E43574900CC2214 /* libvorbis.a */,
 				AB0A488E1E43574900CC2214 /* libvorbisfile.a */,
@@ -216,6 +223,7 @@
 				ABFBB525102EBD4100D48B58 /* midi.h in Headers */,
 				ABFBB526102EBD4100D48B58 /* midifuncs.h in Headers */,
 				AB32F97310762A7900A9BAFF /* asssys.h in Headers */,
+				AB21362327531AA80033C569 /* assmisc.h in Headers */,
 				AB217B67172E646A00364868 /* driver_coreaudio.h in Headers */,
 			);
 			runOnlyForDeploymentPostprocessing = 0;
@@ -268,10 +276,11 @@
 			};
 			buildConfigurationList = AB2E9E331011E60300DD2F1F /* Build configuration list for PBXProject "jfaudiolib" */;
 			compatibilityVersion = "Xcode 3.2";
-			developmentRegion = English;
+			developmentRegion = en;
 			hasScannedForEncodings = 0;
 			knownRegions = (
-				English,
+				Base,
+				en,
 			);
 			mainGroup = AB2E9E301011E60300DD2F1F;
 			productRefGroup = AB2E9E431011E61700DD2F1F /* Products */;
@@ -355,6 +364,11 @@
 				MACOSX_DEPLOYMENT_TARGET = 10.9;
 				ONLY_ACTIVE_ARCH = YES;
 				SKIP_INSTALL = YES;
+				WARNING_CFLAGS = (
+					"-W",
+					"-Wall",
+					"-Wno-unused-variable",
+				);
 			};
 			name = Debug;
 		};
@@ -371,6 +385,11 @@
 				HEADER_SEARCH_PATHS = "$(PROJECT_DIR)/third-party/osx/out/include/**";
 				MACOSX_DEPLOYMENT_TARGET = 10.9;
 				SKIP_INSTALL = YES;
+				WARNING_CFLAGS = (
+					"-W",
+					"-Wall",
+					"-Wno-unused-variable",
+				);
 			};
 			name = Release;
 		};
diff --git a/jfaudiolib/samples/test.mid b/jfaudiolib/samples/test.mid
new file mode 100644
index 0000000..c080b02
Binary files /dev/null and b/jfaudiolib/samples/test.mid differ
diff --git a/jfaudiolib/samples/test.ogg b/jfaudiolib/samples/test.ogg
new file mode 100644
index 0000000..8cafe68
Binary files /dev/null and b/jfaudiolib/samples/test.ogg differ
diff --git a/jfaudiolib/samples/test.wav b/jfaudiolib/samples/test.wav
new file mode 100644
index 0000000..35a22cc
Binary files /dev/null and b/jfaudiolib/samples/test.wav differ
diff --git a/jfaudiolib/src/_midi.h b/jfaudiolib/src/_midi.h
index 7b5fda6..f9272ae 100644
--- a/jfaudiolib/src/_midi.h
+++ b/jfaudiolib/src/_midi.h
@@ -32,7 +32,7 @@ Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 #define ___MIDI_H
 
 #define RELATIVE_BEAT( measure, beat, tick ) \
-   ( ( tick ) + ( ( beat ) << 9 ) + ( ( measure ) << 16 ) )
+   (unsigned)( ( tick ) + ( ( beat ) << 9 ) + ( ( measure ) << 16 ) )
 
 #define GENMIDI_DefaultVolume 100
 
diff --git a/jfaudiolib/src/assmisc.h b/jfaudiolib/src/assmisc.h
new file mode 100644
index 0000000..5addecc
--- /dev/null
+++ b/jfaudiolib/src/assmisc.h
@@ -0,0 +1,59 @@
+/*
+Copyright (C) 1994-1995 Apogee Software, Ltd.
+
+This program is free software; you can redistribute it and/or
+modify it under the terms of the GNU General Public License
+as published by the Free Software Foundation; either version 2
+of the License, or (at your option) any later version.
+
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+
+See the GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+
+*/
+
+#ifndef __ASSMISC_H
+#define __ASSMISC_H
+
+#ifdef __POWERPC__
+#define LITTLE16(s) SWAP16(s)
+#define LITTLE32(s) SWAP32(s)
+static inline unsigned short SWAP16(unsigned short s)
+{
+	return (s >> 8) | (s << 8);
+}
+static inline unsigned int SWAP32(unsigned int s)
+{
+	return (s >> 24) | (s << 24) | ((s&0xff00) << 8) | ((s & 0xff0000) >> 8);
+}
+#else
+#define LITTLE16(s) (s)
+#define LITTLE32(s) (s)
+#endif
+
+#ifdef _MSC_VER
+#define inline _inline
+#define alloca _alloca
+#endif
+
+#ifndef min
+#define min(x,y) ((x) < (y) ? (x) : (y))
+#endif
+#ifndef max
+#define max(x,y) ((x) > (y) ? (x) : (y))
+#endif
+
+#ifndef TRUE
+#define TRUE  ( 1 == 1 )
+#endif
+#ifndef FALSE
+#define FALSE ( !TRUE )
+#endif
+
+#endif
diff --git a/jfaudiolib/src/asssys.c b/jfaudiolib/src/asssys.c
index 2e54acb..a8b88ef 100644
--- a/jfaudiolib/src/asssys.c
+++ b/jfaudiolib/src/asssys.c
@@ -23,12 +23,27 @@
 #ifdef _WIN32
 # define WIN32_LEAN_AND_MEAN
 # include <windows.h>
+# include <stdarg.h>
+# include <stdio.h>
 #else
 # include <sys/types.h>
 # include <sys/time.h>
 # include <unistd.h>
+# include <stdarg.h>
+# include <stdio.h>
 #endif
 
+static void _ASS_MessageOutputString(const char *str)
+{
+#ifdef _WIN32
+    OutputDebugString(str);
+#else
+    fputs(str, stderr);
+#endif
+}
+
+void (*ASS_MessageOutputString)(const char *) = _ASS_MessageOutputString;
+
 void ASS_Sleep(int msec)
 {
 #ifdef _WIN32
@@ -41,3 +56,14 @@ void ASS_Sleep(int msec)
 	select(0, NULL, NULL, NULL, &tv);
 #endif
 }
+
+void ASS_Message(const char *fmt, ...)
+{
+    char text[256];
+    va_list va;
+
+    va_start(va, fmt);
+    vsnprintf(text, sizeof(text), fmt, va);
+    va_end(va);
+    ASS_MessageOutputString(text);
+}
diff --git a/jfaudiolib/src/asssys.h b/jfaudiolib/src/asssys.h
index 1099640..e8c961f 100644
--- a/jfaudiolib/src/asssys.h
+++ b/jfaudiolib/src/asssys.h
@@ -22,5 +22,6 @@
 #define __ASSSYS_H
 
 void ASS_Sleep(int msec);
+void ASS_Message(const char *fmt, ...);
 
 #endif
diff --git a/jfaudiolib/src/cd.c b/jfaudiolib/src/cd.c
index f8b7279..d92f238 100644
--- a/jfaudiolib/src/cd.c
+++ b/jfaudiolib/src/cd.c
@@ -20,6 +20,7 @@
 
 #include "cd.h"
 #include "drivers.h"
+#include "asssys.h"
 #include <assert.h>
 
 static int ErrorCode = CD_Ok;
@@ -56,38 +57,41 @@ const char * CD_ErrorString(int code)
 int CD_Init(int SoundCard)
 {
     int err;
+    int mincard, maxcard, card;
 
-	if (SoundCard == ASS_AutoDetect) {
-#if 0 //defined __APPLE__
-		SoundCard = ASS_CoreAudio;
-#elif defined _WIN32
-		SoundCard = ASS_WinMM;
-#elif defined HAVE_SDL
-		SoundCard = ASS_SDL;
-#else
-		SoundCard = ASS_NoSound;
-#endif
-	}
-	
-	if (SoundCard < 0 || SoundCard >= ASS_NumSoundCards) {
-		ErrorCode = CD_InvalidCard;
-		return CD_Error;
-	}
-	
-	if (SoundDriver_IsCDSupported(SoundCard) == 0) {
-		// unsupported cards fall back to no sound
-		SoundCard = ASS_NoSound;
-	}
-   
-    ASS_CDSoundDriver = SoundCard;
-
-    err = SoundDriver_CD_Init();
-    if (err != CD_Ok) {
-        ErrorCode = CD_DriverError;
+    if (SoundCard == ASS_AutoDetect) {
+        mincard = ASS_NoSound + 1;
+        maxcard = ASS_NumSoundCards - 1;
+    } else if (SoundCard < 0 || SoundCard >= ASS_NumSoundCards) {
+        ErrorCode = CD_InvalidCard;
         return CD_Error;
+    } else {
+        mincard = SoundCard;
+        maxcard = SoundCard;
     }
 
-    return CD_Ok;
+    for (card = mincard; card <= maxcard; card++) {
+        if (!SoundDriver_IsCDSupported(card)) {
+            continue;
+        } else if (SoundCard == ASS_AutoDetect) {
+            ASS_Message("CD_Init: trying %s\n", SoundDriver_GetName(card));
+        }
+
+        ASS_CDSoundDriver = card;
+        err = SoundDriver_CD_Init();
+        if (err == CD_Ok) {
+            return CD_Ok;
+        }
+    }
+
+    if (SoundCard == ASS_AutoDetect) {
+        // A failure to autodetect falls back to no sound.
+        ASS_CDSoundDriver = ASS_NoSound;
+        return CD_Ok;
+    }
+
+    ErrorCode = CD_DriverError;
+    return CD_Error;
 }
 
 int  CD_GetCurrentDriver(void)
diff --git a/jfaudiolib/src/driver_alsa.c b/jfaudiolib/src/driver_alsa.c
index 0c10a98..be791dd 100644
--- a/jfaudiolib/src/driver_alsa.c
+++ b/jfaudiolib/src/driver_alsa.c
@@ -24,8 +24,9 @@
 
 #include "midifuncs.h"
 #include "driver_alsa.h"
+#include "asssys.h"
 #include <pthread.h>
-#include <asoundlib.h>
+#include <alsa/asoundlib.h>
 #include <unistd.h>
 #include <math.h>
 
@@ -118,11 +119,11 @@ static inline void sequence_event(snd_seq_event_t * ev)
     snd_seq_ev_schedule_tick(ev, seq_queue, 0, threadTimer);
     result = snd_seq_event_output(seq, ev);
     if (result < 0) {
-        fprintf(stderr, "ALSA could not queue event: err %d\n", result);
+        ASS_Message("ALSADrv: could not queue event: err %d\n", result);
     } else {
         while ((result = snd_seq_drain_output(seq)) > 0) ;
         if (result < 0) {
-            fprintf(stderr, "ALSA could not drain output: err %d\n", result);
+            ASS_Message("ALSADrv: could not drain output: err %d\n", result);
         }
 
         snd_seq_sync_output_queue(seq);
@@ -194,7 +195,7 @@ static unsigned int get_tick(void)
     
     result = snd_seq_get_queue_status(seq, seq_queue, status);
     if (result < 0) {
-        fprintf(stderr, "ALSA snd_seq_get_queue_status err %d\n", result);
+        ASS_Message("ALSADrv: snd_seq_get_queue_status err %d\n", result);
         return 0;
     }
 
@@ -207,6 +208,8 @@ static void * threadProc(void * parm)
     int sleepAmount = 1000000 / THREAD_QUEUE_INTERVAL;
     unsigned int sequenceTime;
 
+    (void)parm;
+
     // prime the pump
     threadTimer = get_tick();
     threadQueueTimer = threadTimer + threadQueueTicks;
@@ -248,13 +251,15 @@ static void * threadProc(void * parm)
 int ALSADrv_MIDI_Init(midifuncs *funcs, const char *params)
 {
     int result;
+
+    (void)params;
     
     ALSADrv_MIDI_Shutdown();
     memset(funcs, 0, sizeof(midifuncs));
 
     result = snd_seq_open(&seq, "default", SND_SEQ_OPEN_DUPLEX, 0);
     if (result < 0) {
-        fprintf(stderr, "ALSA snd_seq_open err %d\n", result);
+        ASS_Message("ALSADrv: snd_seq_open err %d\n", result);
         ErrorCode = ALSAErr_SeqOpen;
         return ALSAErr_Error;
     }
@@ -264,7 +269,7 @@ int ALSADrv_MIDI_Init(midifuncs *funcs, const char *params)
                   SND_SEQ_PORT_TYPE_APPLICATION);
     if (seq_port < 0) {
         ALSADrv_MIDI_Shutdown();
-        fprintf(stderr, "ALSA snd_seq_create_simple_port err %d\n", seq_port);
+        ASS_Message("ALSADrv: snd_seq_create_simple_port err %d\n", seq_port);
         ErrorCode = ALSAErr_CreateSimplePort;
         return ALSAErr_Error;
     }
@@ -274,7 +279,7 @@ int ALSADrv_MIDI_Init(midifuncs *funcs, const char *params)
     seq_queue = snd_seq_alloc_queue(seq);
     if (seq_queue < 0) {
         ALSADrv_MIDI_Shutdown();
-        fprintf(stderr, "ALSA snd_seq_alloc_queue err %d\n", seq_queue);
+        ASS_Message("ALSADrv: snd_seq_alloc_queue err %d\n", seq_queue);
         ErrorCode = ALSAErr_AllocQueue;
         return ALSAErr_Error;
     }
@@ -282,7 +287,7 @@ int ALSADrv_MIDI_Init(midifuncs *funcs, const char *params)
     result = snd_seq_connect_to(seq, seq_port, 128, 0);
     if (result < 0) {
         ALSADrv_MIDI_Shutdown();
-        fprintf(stderr, "ALSA snd_seq_connect_to err %d\n", result);
+        ASS_Message("ALSADrv: snd_seq_connect_to err %d\n", result);
         ErrorCode = ALSAErr_ConnectTo;
         return ALSAErr_Error;
     }
@@ -326,7 +331,7 @@ int ALSADrv_MIDI_StartPlayback(void (*service)(void))
     ALSADrv_MIDI_QueueStart();
 
     if (pthread_create(&thread, NULL, threadProc, NULL)) {
-        fprintf(stderr, "ALSA pthread_create returned error\n");
+        ASS_Message("ALSADrv: pthread_create returned error\n");
 
         ALSADrv_MIDI_HaltPlayback();
         
@@ -349,7 +354,7 @@ void ALSADrv_MIDI_HaltPlayback(void)
     threadQuit = 1;
 
     if (pthread_join(thread, &ret)) {
-        fprintf(stderr, "ALSA pthread_join returned error\n");
+        ASS_Message("ALSADrv: pthread_join returned error\n");
     }
 
     ALSADrv_MIDI_QueueStop();
@@ -390,12 +395,12 @@ void ALSADrv_MIDI_QueueStart(void)
     if (!queueRunning) {
         result = snd_seq_start_queue(seq, seq_queue, NULL);
         if (result < 0) {
-            fprintf(stderr, "ALSA snd_seq_start_queue err %d\n", result);
+            ASS_Message("ALSADrv: snd_seq_start_queue err %d\n", result);
         }
 
         while ((result = snd_seq_drain_output(seq)) > 0);
         if (result < 0) {
-            fprintf(stderr, "ALSA could not drain output: err %d\n", result);
+            ASS_Message("ALSADrv: could not drain output: err %d\n", result);
         }
 
         snd_seq_sync_output_queue(seq);
@@ -411,12 +416,12 @@ void ALSADrv_MIDI_QueueStop(void)
     if (queueRunning) {
         result = snd_seq_stop_queue(seq, seq_queue, NULL);
         if (result < 0) {
-            fprintf(stderr, "ALSA snd_seq_stop_queue err %d\n", result);
+            ASS_Message("ALSADrv: snd_seq_stop_queue err %d\n", result);
         }
 
         while ((result = snd_seq_drop_output(seq)) > 0);
         if (result < 0) {
-            fprintf(stderr, "ALSA could not drop output: err %d\n", result);
+            ASS_Message("ALSADrv: could not drop output: err %d\n", result);
         }
 
         snd_seq_sync_output_queue(seq);
diff --git a/jfaudiolib/src/driver_coreaudio.c b/jfaudiolib/src/driver_coreaudio.c
index ca61f29..f299ebe 100644
--- a/jfaudiolib/src/driver_coreaudio.c
+++ b/jfaudiolib/src/driver_coreaudio.c
@@ -29,6 +29,7 @@
 #include <AudioUnit/AudioUnit.h>
 #include <AudioToolbox/AudioToolbox.h>
 #include <pthread.h>
+#include "asssys.h"
 #include "midifuncs.h"
 #include "driver_coreaudio.h"
 
@@ -40,7 +41,8 @@ enum {
     CAErr_AssembleAUGraph,
     CAErr_InitialiseAUGraph,
     CAErr_SetPCMFormat,
-    CAErr_Mutex
+    CAErr_Mutex,
+    CAErr_SetSoundBank
 };
 
 enum {
@@ -79,6 +81,7 @@ static unsigned int MidiFrameOffset = 0;
 #define MIDI_MONO_MODE_ON     0x7E
 #define MIDI_ALL_NOTES_OFF    0x7B
 
+static char soundBankName[PATH_MAX+1] = "";
 
 
 static OSStatus pcmService(
@@ -91,7 +94,9 @@ static OSStatus pcmService(
 {
     UInt32 remaining, len, bufn;
     char *ptr, *sptr;
-    
+
+    (void)inRefCon; (void)inActionFlags; (void)inTimeStamp; (void)inBusNumber; (void)inNumberFrames;
+
     if (MixCallBack == 0) return noErr;
 
     CoreAudioDrv_PCM_Lock();
@@ -141,9 +146,11 @@ static OSStatus midiService(
 {
     int secondsThisCall = (inNumberFrames << 16) / 44100;
 
-    if (MidiCallBack == 0) return;
+    (void)inRefCon; (void)inTimeStamp; (void)inBusNumber; (void)ioData;
+
+    if (MidiCallBack == 0) return noErr;
     
-    if (!(*ioActionFlags & kAudioUnitRenderAction_PreRender)) return;
+    if (!(*ioActionFlags & kAudioUnitRenderAction_PreRender)) return noErr;
     
     CoreAudioDrv_MIDI_Lock();
     while (MidiFrameOffset < inNumberFrames) {
@@ -211,7 +218,7 @@ const char *CoreAudioDrv_ErrorString( int ErrorNumber )
 
 #define check_result(fcall, errval) \
 if ((result = (fcall)) != noErr) {\
-    fprintf(stderr, "CoreAudioDrv: error %d at line %d:" #fcall "\n", (int)result, __LINE__);\
+    ASS_Message("CoreAudioDrv: error %d at line %d:" #fcall "\n", (int)result, __LINE__);\
     ErrorCode = errval;\
     return CAErr_Error;\
 }
@@ -322,7 +329,22 @@ static int initialise_graph(int subsystem)
                     0,
                     &pcmDesc,
                     sizeof(pcmDesc)), CAErr_SetPCMFormat);
-    
+
+    // Set a sound bank for the DLS synth
+    if (soundBankName[0]) {
+        CFURLRef url = CFURLCreateFromFileSystemRepresentation(NULL,
+                           (const UInt8 *)soundBankName, strlen(soundBankName), FALSE);
+        if (url) {
+            check_result(AudioUnitSetProperty(synthunit,
+                            kMusicDeviceProperty_SoundBankURL,
+                            kAudioUnitScope_Global,
+                            0,
+                            &url,
+                            sizeof(url)), CAErr_SetSoundBank);
+            CFRelease(url);
+        }
+    }
+
     // set the synth notify callback
     check_result(AudioUnitAddRenderNotify(synthunit, midiService, NULL), CAErr_InitialiseAUGraph);
 
@@ -369,11 +391,41 @@ static int uninitialise_graph(int subsystem)
     return CAErr_Ok;
 }    
 
+static void parse_params(const char *params)
+{
+    char *parseparams, *savepair = NULL;
+    char *parampair, *paramname, *paramvalue;
+    char *firstpair;
+    int setok;
+
+    if (!params || !params[0]) return;
+
+    parseparams = malloc(strlen(params) + 1);
+    strcpy(parseparams, params);
+    firstpair = parseparams;
+    while ((parampair = strtok_r(firstpair, " ", &savepair))) {
+        firstpair = NULL;
+        paramname = strtok_r(parampair, "=", &paramvalue);
+        if (!paramname) {
+            break;
+        }
+        if (strcmp(paramname, "soundbank") == 0 || strcmp(paramname, "soundfont") == 0) {
+            ASS_Message("CoreAudioDrv: using sound bank %s\n", paramvalue);
+            strcpy(soundBankName, paramvalue);
+            continue;
+        }
+    }
+
+    free(parseparams);
+}
+
 int CoreAudioDrv_PCM_Init(int * mixrate, int * numchannels, int * samplebits, void * initdata)
 {
     OSStatus result = noErr;
     AudioStreamBasicDescription pcmDesc;
-    
+
+    (void)initdata;
+
     result = initialise_graph(CASystem_pcm);
     if (result != CAErr_Ok) {
         return result;
@@ -547,6 +599,8 @@ int CoreAudioDrv_MIDI_Init(midifuncs *funcs, const char *params)
     
     memset(funcs, 0, sizeof(midifuncs));
 
+    parse_params(params);
+
     result = initialise_graph(CASystem_midi);
     if (result != CAErr_Ok) {
         return result;
diff --git a/jfaudiolib/src/driver_directsound.c b/jfaudiolib/src/driver_directsound.c
index 6c18b1e..352b638 100644
--- a/jfaudiolib/src/driver_directsound.c
+++ b/jfaudiolib/src/driver_directsound.c
@@ -28,8 +28,7 @@
 #include <mmsystem.h>
 #include <dsound.h>
 #include <stdlib.h>
-#include <stdio.h>
-
+#include "asssys.h"
 #include "driver_directsound.h"
 
 enum {
@@ -111,7 +110,7 @@ static void FillBuffer(int bufnum)
     DWORD remaining, remaining2;
     int retries = 1;
     
-    //fprintf(stderr, "DirectSound FillBuffer: filling %d\n", bufnum);
+    //ASS_Message("DirectSoundDrv: FillBuffer filling %d\n", bufnum);
 
     do {
         err = IDirectSoundBuffer_Lock(lpdsbsec,
@@ -131,7 +130,7 @@ static void FillBuffer(int bufnum)
                     continue;
                 }
             }
-            fprintf(stderr, "DirectSound FillBuffer: err %x\n", (unsigned int) err);
+            ASS_Message("DirectSoundDrv: FillBuffer err %x\n", (unsigned int) err);
             return;
         }
         break;
@@ -166,15 +165,15 @@ static DWORD WINAPI fillDataThread(LPVOID lpParameter)
                     FillBuffer(WAIT_OBJECT_0 + 1 - waitret);
                     ReleaseMutex(mutex);
                 } else {
-                    fprintf(stderr, "DirectSound fillDataThread: wfso err %d\n", (int) waitret2);
+                    ASS_Message("DirectSoundDrv: fillDataThread wfso err %d\n", (int) waitret2);
                 }
                 break;
             case WAIT_OBJECT_0+2:
-                fprintf(stderr, "DirectSound fillDataThread: exiting\n");
+                ASS_Message("DirectSoundDrv: fillDataThread exiting\n");
                 ExitThread(0);
                 break;
             default:
-                fprintf(stderr, "DirectSound fillDataThread: wfmo err %d\n", (int) waitret);
+                ASS_Message("DirectSoundDrv: fillDataThread wfmo err %d\n", (int) waitret);
                 break;
         }
 	} while (1);
@@ -272,7 +271,7 @@ const char *DirectSoundDrv_ErrorString( int ErrorNumber )
 static void TeardownDSound(HRESULT err)
 {
     if (FAILED(err)) {
-        fprintf(stderr, "Dying error: %x\n", (unsigned int) err);
+        ASS_Message("DirectSoundDrv: TeardownDSound error: %x\n", (unsigned int) err);
     }
 
     if (lpdsnotify)   IDirectSoundNotify_Release(lpdsnotify);
@@ -405,8 +404,6 @@ int DirectSoundDrv_PCM_Init(int * mixrate, int * numchannels, int * samplebits,
     
     Initialised = 1;
     
-    fprintf(stderr, "DirectSound Init: yay\n");
-    
 	return DSErr_Ok;
 }
 
@@ -482,7 +479,7 @@ void DirectSoundDrv_PCM_Lock(void)
     
     err = WaitForSingleObject(mutex, INFINITE);
     if (err != WAIT_OBJECT_0) {
-        fprintf(stderr, "DirectSound lock: wfso %d\n", (int) err);
+        ASS_Message("DirectSoundDrv: PCM_Lock wfso %d\n", (int) err);
     }
 }
 
diff --git a/jfaudiolib/src/driver_fluidsynth.c b/jfaudiolib/src/driver_fluidsynth.c
index 142576b..e5cf779 100644
--- a/jfaudiolib/src/driver_fluidsynth.c
+++ b/jfaudiolib/src/driver_fluidsynth.c
@@ -24,9 +24,9 @@
 
 #include "midifuncs.h"
 #include "driver_fluidsynth.h"
+#include "asssys.h"
 #include <fluidsynth.h>
 #include <string.h>
-#include <stdio.h>
 #include <stdlib.h>
 #include <pthread.h>
 #include <sys/select.h>
@@ -59,6 +59,8 @@ enum {
 static int ErrorCode = FSynthErr_Ok;
 static char soundFontName[PATH_MAX+1] = "";
 static const char *soundFontPaths[] = {
+    "./*.sf2",
+    "/usr/share/soundfonts/*.sf2",
     "/usr/share/sounds/sf2/*.sf2",
     NULL,
 };
@@ -152,13 +154,14 @@ static inline void sequence_event(void)
     //fluid_sequencer_send_now(fluidsequencer, fluidevent);
     result = fluid_sequencer_send_at(fluidsequencer, fluidevent, threadTimer, 1);
     if (result < 0) {
-        fprintf(stderr, "FluidSynthDrv: fluidsynth could not queue event\n");
+        ASS_Message("FluidSynthDrv: fluidsynth could not queue event\n");
     }
 }
 
 static int find_soundfont(void)
 {
-    int pathn, globi, found = 0;
+    int pathn, found = 0;
+    unsigned globi;
     glob_t globt;
 
     for (pathn = 0; !found && soundFontPaths[pathn]; pathn++) {
@@ -183,7 +186,7 @@ static int find_soundfont(void)
         }
     }
 
-    return !found;
+    return found;
 }
 
 static void apply_params(const char *params, fluid_settings_t *settings)
@@ -204,26 +207,30 @@ static void apply_params(const char *params, fluid_settings_t *settings)
         if (!paramname) {
             break;
         }
+        if (strcmp(paramname, "soundfont") == 0 || strcmp(paramname, "soundbank") == 0) {
+            strcpy(soundFontName, paramvalue);
+            continue;
+        }
 
         switch (fluid_settings_get_type(settings, paramname)) {
             case FLUID_NUM_TYPE:
-                fprintf(stderr, "FluidSynthDrv: setting '%s' to %f\n", paramname, atof(paramvalue));
+                ASS_Message("FluidSynthDrv: setting '%s' to %f\n", paramname, atof(paramvalue));
                 setok = fluid_settings_setnum(settings, paramname, atof(paramvalue));
                 break;
             case FLUID_INT_TYPE:
-                fprintf(stderr, "FluidSynthDrv: setting '%s' to %d\n", paramname, atoi(paramvalue));
+                ASS_Message("FluidSynthDrv: setting '%s' to %d\n", paramname, atoi(paramvalue));
                 setok = fluid_settings_setint(settings, paramname, atoi(paramvalue));
                 break;
             case FLUID_STR_TYPE:
-                fprintf(stderr, "FluidSynthDrv: setting '%s' to '%s'\n", paramname, paramvalue);
+                ASS_Message("FluidSynthDrv: setting '%s' to '%s'\n", paramname, paramvalue);
                 setok = fluid_settings_setstr(settings, paramname, paramvalue);
                 break;
             default:
                 setok = 0;
                 break;
         }
-        if (!setok) {
-            fprintf(stderr, "FluidSynthDrv: error setting '%s' to '%s'\n", paramname, paramvalue);
+        if (setok < 0) {
+            ASS_Message("FluidSynthDrv: error setting '%s' to '%s'\n", paramname, paramvalue);
         }
     }
 
@@ -232,6 +239,8 @@ static void apply_params(const char *params, fluid_settings_t *settings)
 
 static void Func_NoteOff( int channel, int key, int velocity )
 {
+    (void)velocity;
+
     fluid_event_noteoff(fluidevent, channel, key);
     sequence_event();
 }
@@ -244,7 +253,9 @@ static void Func_NoteOn( int channel, int key, int velocity )
 
 static void Func_PolyAftertouch( int channel, int key, int pressure )
 {
-    fprintf(stderr, "FluidSynthDrv: key %d channel %d aftertouch\n", key, channel);
+    (void)pressure;
+
+    ASS_Message("FluidSynthDrv: key %d channel %d aftertouch\n", key, channel);
 }
 
 static void Func_ControlChange( int channel, int number, int value )
@@ -261,7 +272,9 @@ static void Func_ProgramChange( int channel, int program )
 
 static void Func_ChannelAftertouch( int channel, int pressure )
 {
-    fprintf(stderr, "FluidSynthDrv: channel %d aftertouch\n", channel);
+    (void)pressure;
+
+    ASS_Message("FluidSynthDrv: channel %d aftertouch\n", channel);
 }
 
 static void Func_PitchBend( int channel, int lsb, int msb )
@@ -276,6 +289,8 @@ static void * threadProc(void * parm)
     int sleepAmount = 1000000 / THREAD_QUEUE_INTERVAL;
     unsigned int sequenceTime;
 
+    (void)parm;
+
     // prime the pump
     threadTimer = fluid_sequencer_get_tick(fluidsequencer);
     threadQueueTimer = threadTimer + threadQueueTicks;
@@ -321,11 +336,7 @@ int FluidSynthDrv_MIDI_Init(midifuncs *funcs, const char *params)
     FluidSynthDrv_MIDI_Shutdown();
     memset(funcs, 0, sizeof(midifuncs));
 
-    if (find_soundfont()) {
-        ErrorCode = FSynthErr_BadSoundFont;
-        return FSynthErr_Error;
-    }
-    fprintf(stderr, "FluidSynthDrv: using soundfont %s\n", soundFontName);
+    ASS_Message("FluidSynthDrv: using version %s, built with %s\n", fluid_version_str(), FLUIDSYNTH_VERSION);
 
     fluidsettings = new_fluid_settings();
     if (!fluidsettings) {
@@ -334,46 +345,55 @@ int FluidSynthDrv_MIDI_Init(midifuncs *funcs, const char *params)
     }
 
     apply_params(params, fluidsettings);
-        
+
+    if (soundFontName[0]) {
+        ASS_Message("FluidSynthDrv: using soundfont %s\n", soundFontName);
+    } else if (find_soundfont()) {
+        ASS_Message("FluidSynthDrv: using found soundfont %s\n", soundFontName);
+    } else {
+        fluid_settings_copystr(fluidsettings, "synth.default-soundfont", soundFontName,
+            sizeof(soundFontName));
+    }
+
     fluidsynth = new_fluid_synth(fluidsettings);
     if (!fluidsettings) {
         FluidSynthDrv_MIDI_Shutdown();
         ErrorCode = FSynthErr_NewFluidSynth;
         return FSynthErr_Error;
     }
-    
-    fluidaudiodriver = new_fluid_audio_driver(fluidsettings, fluidsynth);
-    if (!fluidsettings) {
+
+    result = fluid_synth_sfload(fluidsynth, soundFontName, 1);
+    if (result < 0) {
         FluidSynthDrv_MIDI_Shutdown();
-        ErrorCode = FSynthErr_NewFluidAudioDriver;
+        ErrorCode = FSynthErr_BadSoundFont;
         return FSynthErr_Error;
     }
-    
-    fluidsequencer = new_fluid_sequencer();
+
+    fluidsequencer = new_fluid_sequencer2(0);
     if (!fluidsettings) {
         FluidSynthDrv_MIDI_Shutdown();
         ErrorCode = FSynthErr_NewFluidSequencer;
         return FSynthErr_Error;
     }
 
-    fluidevent = new_fluid_event();
-    if (!fluidevent) {
+    synthseqid = fluid_sequencer_register_fluidsynth(fluidsequencer, fluidsynth);
+    if (synthseqid < 0) {
         FluidSynthDrv_MIDI_Shutdown();
-        ErrorCode = FSynthErr_NewFluidEvent;
+        ErrorCode = FSynthErr_RegisterFluidSynth;
         return FSynthErr_Error;
     }
 
-    synthseqid = fluid_sequencer_register_fluidsynth(fluidsequencer, fluidsynth);
-    if (synthseqid < 0) {
+    fluidaudiodriver = new_fluid_audio_driver(fluidsettings, fluidsynth);
+    if (!fluidsettings) {
         FluidSynthDrv_MIDI_Shutdown();
-        ErrorCode = FSynthErr_RegisterFluidSynth;
+        ErrorCode = FSynthErr_NewFluidAudioDriver;
         return FSynthErr_Error;
     }
 
-    result = fluid_synth_sfload(fluidsynth, soundFontName, 1);
-    if (result < 0) {
+    fluidevent = new_fluid_event();
+    if (!fluidevent) {
         FluidSynthDrv_MIDI_Shutdown();
-        ErrorCode = FSynthErr_BadSoundFont;
+        ErrorCode = FSynthErr_NewFluidEvent;
         return FSynthErr_Error;
     }
 
@@ -393,21 +413,24 @@ int FluidSynthDrv_MIDI_Init(midifuncs *funcs, const char *params)
 
 void FluidSynthDrv_MIDI_Shutdown(void)
 {
-    if (fluidevent) {
-        delete_fluid_event(fluidevent);
+    if (fluidaudiodriver) {
+        delete_fluid_audio_driver(fluidaudiodriver);
+    }
+    if (synthseqid >= 0) {
+        fluid_sequencer_unregister_client(fluidsequencer, synthseqid);
     }
     if (fluidsequencer) {
         delete_fluid_sequencer(fluidsequencer);
     }
-    if (fluidaudiodriver) {
-        delete_fluid_audio_driver(fluidaudiodriver);
-    }
     if (fluidsynth) {
         delete_fluid_synth(fluidsynth);
     }
     if (fluidsettings) {
         delete_fluid_settings(fluidsettings);
     }
+    if (fluidevent) {
+        delete_fluid_event(fluidevent);
+    }
     synthseqid = -1;
     fluidevent = 0;
     fluidsequencer = 0;
@@ -424,7 +447,7 @@ int FluidSynthDrv_MIDI_StartPlayback(void (*service)(void))
     threadQuit = 0;
 
     if (pthread_create(&thread, NULL, threadProc, NULL)) {
-        fprintf(stderr, "FluidSynthDrv: pthread_create returned error\n");
+        ASS_Message("FluidSynthDrv: pthread_create returned error\n");
         return FSynthErr_PlayThread;
     }
 
@@ -444,7 +467,7 @@ void FluidSynthDrv_MIDI_HaltPlayback(void)
     threadQuit = 1;
 
     if (pthread_join(thread, &ret)) {
-        fprintf(stderr, "FluidSynthDrv: pthread_join returned error\n");
+        ASS_Message("FluidSynthDrv: pthread_join returned error\n");
     }
 
     threadRunning = 0;
diff --git a/jfaudiolib/src/driver_nosound.c b/jfaudiolib/src/driver_nosound.c
index af2a0ec..984681a 100644
--- a/jfaudiolib/src/driver_nosound.c
+++ b/jfaudiolib/src/driver_nosound.c
@@ -32,11 +32,13 @@ int NoSoundDrv_GetError(void)
 
 const char *NoSoundDrv_ErrorString( int ErrorNumber )
 {
+	(void)ErrorNumber;
 	return "No sound, Ok.";
 }
 
 int NoSoundDrv_PCM_Init(int * mixrate, int * numchannels, int * samplebits, void * initdata)
 {
+	(void)mixrate; (void)numchannels; (void)samplebits; (void)initdata;
 	return 0;
 }
 
@@ -47,6 +49,7 @@ void NoSoundDrv_PCM_Shutdown(void)
 int NoSoundDrv_PCM_BeginPlayback(char *BufferStart, int BufferSize,
 						int NumDivisions, void ( *CallBackFunc )( void ) )
 {
+	(void)BufferStart; (void)BufferSize; (void)NumDivisions; (void)CallBackFunc;
 	return 0;
 }
 
@@ -74,6 +77,7 @@ void NoSoundDrv_CD_Shutdown(void)
 
 int NoSoundDrv_CD_Play(int track, int loop)
 {
+    (void)track; (void)loop;
     return 0;
 }
 
@@ -83,6 +87,7 @@ void NoSoundDrv_CD_Stop(void)
 
 void NoSoundDrv_CD_Pause(int pauseon)
 {
+    (void)pauseon;
 }
 
 int NoSoundDrv_CD_IsPlaying(void)
@@ -92,10 +97,12 @@ int NoSoundDrv_CD_IsPlaying(void)
 
 void NoSoundDrv_CD_SetVolume(int volume)
 {
+    (void)volume;
 }
 
 int NoSoundDrv_MIDI_Init(midifuncs *funcs, const char *params)
 {
+    (void)params;
     memset(funcs, 0, sizeof(midifuncs));
     return 0;
 }
@@ -106,6 +113,7 @@ void NoSoundDrv_MIDI_Shutdown(void)
 
 int  NoSoundDrv_MIDI_StartPlayback(void (*service)(void))
 {
+    (void)service;
     return 0;
 }
 
@@ -120,6 +128,7 @@ unsigned int NoSoundDrv_MIDI_GetTick(void)
 
 void NoSoundDrv_MIDI_SetTempo(int tempo, int division)
 {
+    (void)tempo; (void)division;
 }
 
 void NoSoundDrv_MIDI_Lock(void)
diff --git a/jfaudiolib/src/driver_sdl.c b/jfaudiolib/src/driver_sdl.c
index 1114db0..0bb9cde 100644
--- a/jfaudiolib/src/driver_sdl.c
+++ b/jfaudiolib/src/driver_sdl.c
@@ -31,6 +31,7 @@
 #else
 # include <SDL.h>
 #endif
+#include "asssys.h"
 #include "driver_sdl.h"
 
 enum {
@@ -51,7 +52,7 @@ static int ErrorCode = SDLErr_Ok;
 static int Initialised = 0;
 static int Playing = 0;
 static int StartedSDL = 0;      // SDL services in use (1 = sound, 2 = CDA)
-static int StartedSDLInit = 0;  // SDL services we initialised (0x80000000 means we used SDL_Init)
+static unsigned StartedSDLInit = 0;  // SDL services we initialised (0x80000000 means we used SDL_Init)
 
 #if (SDL_MAJOR_VERSION == 1)
 static SDL_CD *CDRom = 0;
@@ -73,6 +74,8 @@ static void fillData(void * userdata, Uint8 * ptr, int remaining)
     int len;
     char *sptr;
 
+    (void)userdata;
+
     while (remaining > 0) {
         if (MixBufferUsed == MixBufferSize) {
             MixCallBack();
@@ -164,25 +167,24 @@ const char *SDLDrv_ErrorString( int ErrorNumber )
 int SDLDrv_PCM_Init(int * mixrate, int * numchannels, int * samplebits, void * initdata)
 {
     Uint32 inited;
-    Uint32 err = 0;
+    int err = 0;
     SDL_AudioSpec spec, actual;
 
+    (void)initdata;
+
     if (Initialised) {
         SDLDrv_PCM_Shutdown();
     }
 
     inited = SDL_WasInit(SDL_INIT_EVERYTHING);
-    //fprintf(stderr, "inited = %x\n", inited);
 
     if (inited == 0) {
         // nothing was initialised
         err = SDL_Init(SDL_INIT_AUDIO);
         StartedSDLInit |= 0x80000000 + SDL_INIT_AUDIO;
-        //fprintf(stderr, "called SDL_Init\n");
     } else if (!(inited & SDL_INIT_AUDIO)) {
         err = SDL_InitSubSystem(SDL_INIT_AUDIO);
         StartedSDLInit |= SDL_INIT_AUDIO;
-        //fprintf(stderr, "called SDL_InitSubSystem\n");
     }
 
     if (err < 0) {
@@ -196,12 +198,12 @@ int SDLDrv_PCM_Init(int * mixrate, int * numchannels, int * samplebits, void * i
     {
         char drivername[256] = "(error)";
         SDL_AudioDriverName(drivername, sizeof(drivername));
-        fprintf(stderr, "SDL_AudioDriverName: %s\n", drivername);
+        ASS_Message("SDLDrv: audio driver: %s\n", drivername);
     }
     #else
     {
         const char * drivername = SDL_GetCurrentAudioDriver();
-        fprintf(stderr, "SDL_GetCurrentAudioDriver: %s\n", drivername ? drivername : "(error)");
+        ASS_Message("SDLDrv: audio driver: %s\n", drivername ? drivername : "(error)");
     }
     #endif
 
@@ -248,18 +250,18 @@ int SDLDrv_PCM_Init(int * mixrate, int * numchannels, int * samplebits, void * i
             case AUDIO_S16MSB: format = "AUDIO_S16MSB"; break;
             default: format = "?!"; break;
         }
-        fprintf(stderr, "SDL_OpenAudio: actual.format = %s\n", format);
+        ASS_Message("SDLDrv: audio format: %s\n", format);
         ErrorCode = SDLErr_OpenAudio;
         err = 1;
     }
     if (actual.channels == 1 || actual.channels == 2) {
         *numchannels = actual.channels;
     } else {
-        fprintf(stderr, "SDL_OpenAudio: actual.channels = %d\n", actual.channels);
+        ASS_Message("SDLDrv: audio channels: %d\n", actual.channels);
         ErrorCode = SDLErr_OpenAudio;
         err = 1;
     }
-    // fprintf(stderr, "SDL_OpenAudio: actual.samples = %d vs spec.samples = %d\n", actual.samples, spec.samples);
+    // ASS_Message("SDLDrv: actual samples = %d vs spec samples = %d\n", actual.samples, spec.samples);
 
     if (err) {
         SDL_CloseAudio();
@@ -405,7 +407,7 @@ int SDLDrv_CD_Init(void)
     
     StartedSDL |= SDL_INIT_CDROM;
     
-    fprintf(stderr, "SDL_CDNumDrives: %d\n", SDL_CDNumDrives());
+    ASS_Message("SDLDrv: num CD drives: %d\n", SDL_CDNumDrives());
     
     CDRom = SDL_CDOpen(0);
     if (!CDRom) {
@@ -413,9 +415,9 @@ int SDLDrv_CD_Init(void)
         return SDLErr_Error;
     }
     
-    fprintf(stderr, "SDL_CD: numtracks: %d\n", CDRom->numtracks);
+    ASS_Message("SDLDrv: num CD tracks: %d\n", CDRom->numtracks);
     for (i = 0; i < CDRom->numtracks; i++) {
-        fprintf(stderr, "SDL_CD: track %d - %s, %dsec\n",
+        ASS_Message("SDLDrv: CD track %d - %s, %dsec\n",
                 CDRom->track[i].id,
                 CDRom->track[i].type == SDL_AUDIO_TRACK ? "audio" : "data",
                 CDRom->track[i].length / CD_FPS
@@ -491,6 +493,8 @@ int SDLDrv_CD_Play(int track, int loop)
     
     return SDLErr_Ok;
 #else
+    (void)track; (void)loop;
+
     ErrorCode = SDLErr_CDNotSupported;
     return SDLErr_Error;
 #endif
@@ -529,6 +533,8 @@ void SDLDrv_CD_Pause(int pauseon)
     } else {
         SDL_CDResume(CDRom);
     }
+#else
+    (void)pauseon;
 #endif
 }
 
@@ -546,4 +552,5 @@ int SDLDrv_CD_IsPlaying(void)
 
 void SDLDrv_CD_SetVolume(int volume)
 {
+    (void)volume;
 }
diff --git a/jfaudiolib/src/driver_winmm.c b/jfaudiolib/src/driver_winmm.c
index b70bdc3..a2919d3 100644
--- a/jfaudiolib/src/driver_winmm.c
+++ b/jfaudiolib/src/driver_winmm.c
@@ -31,15 +31,12 @@
 #include <stdint.h>
 #include <stdarg.h>
 #include <assert.h>
-
+#include "asssys.h"
+#include "assmisc.h"
 #include "midifuncs.h"
 #include "driver_winmm.h"
 #include "linklist.h"
 
-#ifdef _MSC_VER
-#define inline _inline
-#endif
-
 enum {
    WinMMErr_Warning = -2,
    WinMMErr_Error   = -1,
@@ -256,7 +253,7 @@ int WinMMDrv_CD_Init(void)
     mciopenparms.lpstrDeviceType = "cdaudio";
     rv = mciSendCommand(0, MCI_OPEN, MCI_OPEN_TYPE, (DWORD_PTR) &mciopenparms);
     if (rv) {
-        fprintf(stderr, "WinMM CD_Init MCI_OPEN err %d\n", (int) rv);
+        ASS_Message("WinMMDrv: CD_Init MCI_OPEN err %d\n", (int) rv);
         ErrorCode = WinMMErr_CDMCIOpen;
         return WinMMErr_Error;
     }
@@ -266,7 +263,7 @@ int WinMMDrv_CD_Init(void)
     mcisetparms.dwTimeFormat = MCI_FORMAT_MSF;
     rv = mciSendCommand(cdDeviceID, MCI_SET, MCI_SET_TIME_FORMAT, (DWORD_PTR) &mcisetparms);
     if (rv) {
-        fprintf(stderr, "WinMM CD_Init MCI_SET err %d\n", (int) rv);
+        ASS_Message("WinMMDrv: CD_Init MCI_SET err %d\n", (int) rv);
         mciSendCommand(cdDeviceID, MCI_CLOSE, 0, 0);
         cdDeviceID = 0;
 
@@ -317,7 +314,7 @@ int WinMMDrv_CD_Play(int track, int loop)
     mcistatusparms.dwTrack = track;
     rv = mciSendCommand(cdDeviceID, MCI_STATUS, MCI_WAIT | MCI_TRACK | MCI_STATUS_ITEM, (DWORD_PTR) &mcistatusparms);
     if (rv) {
-        fprintf(stderr, "WinMM CD_Play MCI_STATUS position err %d\n", (int) rv);
+        ASS_Message("WinMMDrv: CD_Play MCI_STATUS position err %d\n", (int) rv);
         ErrorCode = WinMMErr_CDMCIPlay;
         return WinMMErr_Error;
     }
@@ -327,7 +324,7 @@ int WinMMDrv_CD_Play(int track, int loop)
     mcistatusparms.dwTrack = track;
     rv = mciSendCommand(cdDeviceID, MCI_STATUS, MCI_WAIT | MCI_TRACK | MCI_STATUS_ITEM, (DWORD_PTR) &mcistatusparms);
     if (rv) {
-        fprintf(stderr, "WinMM CD_Play MCI_STATUS length err %d\n", (int) rv);
+        ASS_Message("WinMMDrv: CD_Play MCI_STATUS length err %d\n", (int) rv);
         ErrorCode = WinMMErr_CDMCIPlay;
         return WinMMErr_Error;
     }
@@ -344,7 +341,7 @@ int WinMMDrv_CD_Play(int track, int loop)
     mciplayparms.dwCallback = (DWORD_PTR) notifyWindow;
     rv = mciSendCommand(cdDeviceID, MCI_PLAY, MCI_FROM | MCI_TO | MCI_NOTIFY, (DWORD_PTR) &mciplayparms);
     if (rv) {
-        fprintf(stderr, "WinMM CD_Play MCI_PLAY err %d\n", (int) rv);
+        ASS_Message("WinMMDrv: CD_Play MCI_PLAY err %d\n", (int) rv);
         ErrorCode = WinMMErr_CDMCIPlay;
         return WinMMErr_Error;
     }
@@ -367,7 +364,7 @@ void WinMMDrv_CD_Stop(void)
 
     rv = mciSendCommand(cdDeviceID, MCI_STOP, 0, (DWORD_PTR) &mcigenparms);
     if (rv) {
-        fprintf(stderr, "WinMM CD_Stop MCI_STOP err %d\n", (int) rv);
+        ASS_Message("WinMMDrv: CD_Stop MCI_STOP err %d\n", (int) rv);
     }
 }
 
@@ -389,7 +386,7 @@ void WinMMDrv_CD_Pause(int pauseon)
         mcistatusparms.dwItem = MCI_STATUS_POSITION;
         rv = mciSendCommand(cdDeviceID, MCI_STATUS, MCI_WAIT | MCI_STATUS_ITEM, (DWORD_PTR) &mcistatusparms);
         if (rv) {
-            fprintf(stderr, "WinMM CD_Pause MCI_STATUS err %d\n", (int) rv);
+            ASS_Message("WinMMDrv: CD_Pause MCI_STATUS err %d\n", (int) rv);
             return;
         }
 
@@ -397,7 +394,7 @@ void WinMMDrv_CD_Pause(int pauseon)
 
         rv = mciSendCommand(cdDeviceID, MCI_STOP, 0, (DWORD_PTR) &mcigenparms);
         if (rv) {
-            fprintf(stderr, "WinMM CD_Pause MCI_STOP err %d\n", (int) rv);
+            ASS_Message("WinMMDrv: CD_Pause MCI_STOP err %d\n", (int) rv);
         }
     } else {
         MCI_PLAY_PARMS mciplayparms;
@@ -408,7 +405,7 @@ void WinMMDrv_CD_Pause(int pauseon)
         mciplayparms.dwCallback = (DWORD_PTR) notifyWindow;
         rv = mciSendCommand(cdDeviceID, MCI_PLAY, MCI_FROM | MCI_TO | MCI_NOTIFY, (DWORD_PTR) &mciplayparms);
         if (rv) {
-            fprintf(stderr, "WinMM CD_Pause MCI_PLAY err %d\n", (int) rv);
+            ASS_Message("WinMMDrv: CD_Pause MCI_PLAY err %d\n", (int) rv);
             return;
         }
 
@@ -430,7 +427,7 @@ int WinMMDrv_CD_IsPlaying(void)
     mcistatusparms.dwItem = MCI_STATUS_MODE;
     rv = mciSendCommand(cdDeviceID, MCI_STATUS, MCI_WAIT | MCI_STATUS_ITEM, (DWORD_PTR) &mcistatusparms);
     if (rv) {
-        fprintf(stderr, "WinMM CD_IsPlaying MCI_STATUS err %d\n", (int) rv);
+        ASS_Message("WinMMDrv: CD_IsPlaying MCI_STATUS err %d\n", (int) rv);
         return 0;
     }
 
@@ -444,40 +441,35 @@ void WinMMDrv_CD_SetVolume(int volume)
 
 
 // will append "err nnn (ssss)\n" to the end of the string it emits
-static void midi_error(MMRESULT rv, const char * fmt, ...)
+static const char *mmsyserr_str(MMRESULT rv)
 {
-    va_list va;
-    const char * errtxt = "?";
-    
     switch (rv) {
-        case MMSYSERR_NOERROR: errtxt = "MMSYSERR_NOERROR"; break;
-        case MMSYSERR_BADDEVICEID: errtxt = "MMSYSERR_BADDEVICEID"; break;
-        case MMSYSERR_NOTENABLED: errtxt = "MMSYSERR_NOTENABLED"; break;
-        case MMSYSERR_ALLOCATED: errtxt = "MMSYSERR_ALLOCATED"; break;
-        case MMSYSERR_INVALHANDLE: errtxt = "MMSYSERR_INVALHANDLE"; break;
-        case MMSYSERR_NODRIVER: errtxt = "MMSYSERR_NODRIVER"; break;
-        case MMSYSERR_NOMEM: errtxt = "MMSYSERR_NOMEM"; break;
-        case MMSYSERR_NOTSUPPORTED: errtxt = "MMSYSERR_NOTSUPPORTED"; break;
-        case MMSYSERR_BADERRNUM: errtxt = "MMSYSERR_BADERRNUM"; break;
-        case MMSYSERR_INVALFLAG: errtxt = "MMSYSERR_INVALFLAG"; break;
-        case MMSYSERR_INVALPARAM: errtxt = "MMSYSERR_INVALPARAM"; break;
-        case MMSYSERR_HANDLEBUSY: errtxt = "MMSYSERR_HANDLEBUSY"; break;
-        case MMSYSERR_INVALIDALIAS: errtxt = "MMSYSERR_INVALIDALIAS"; break;
-        case MMSYSERR_BADDB: errtxt = "MMSYSERR_BADDB"; break;
-        case MMSYSERR_KEYNOTFOUND: errtxt = "MMSYSERR_KEYNOTFOUND"; break;
-        case MMSYSERR_READERROR: errtxt = "MMSYSERR_READERROR"; break;
-        case MMSYSERR_WRITEERROR: errtxt = "MMSYSERR_WRITEERROR"; break;
-        case MMSYSERR_DELETEERROR: errtxt = "MMSYSERR_DELETEERROR"; break;
-        case MMSYSERR_VALNOTFOUND: errtxt = "MMSYSERR_VALNOTFOUND"; break;
-        case MMSYSERR_NODRIVERCB: errtxt = "MMSYSERR_NODRIVERCB"; break;
-        default: break;
+        case MMSYSERR_NOERROR: return "MMSYSERR_NOERROR";
+        case MMSYSERR_BADDEVICEID: return "MMSYSERR_BADDEVICEID";
+        case MMSYSERR_NOTENABLED: return "MMSYSERR_NOTENABLED";
+        case MMSYSERR_ALLOCATED: return "MMSYSERR_ALLOCATED";
+        case MMSYSERR_INVALHANDLE: return "MMSYSERR_INVALHANDLE";
+        case MMSYSERR_NODRIVER: return "MMSYSERR_NODRIVER";
+        case MMSYSERR_NOMEM: return "MMSYSERR_NOMEM";
+        case MMSYSERR_NOTSUPPORTED: return "MMSYSERR_NOTSUPPORTED";
+        case MMSYSERR_BADERRNUM: return "MMSYSERR_BADERRNUM";
+        case MMSYSERR_INVALFLAG: return "MMSYSERR_INVALFLAG";
+        case MMSYSERR_INVALPARAM: return "MMSYSERR_INVALPARAM";
+        case MMSYSERR_HANDLEBUSY: return "MMSYSERR_HANDLEBUSY";
+        case MMSYSERR_INVALIDALIAS: return "MMSYSERR_INVALIDALIAS";
+        case MMSYSERR_BADDB: return "MMSYSERR_BADDB";
+        case MMSYSERR_KEYNOTFOUND: return "MMSYSERR_KEYNOTFOUND";
+        case MMSYSERR_READERROR: return "MMSYSERR_READERROR";
+        case MMSYSERR_WRITEERROR: return "MMSYSERR_WRITEERROR";
+        case MMSYSERR_DELETEERROR: return "MMSYSERR_DELETEERROR";
+        case MMSYSERR_VALNOTFOUND: return "MMSYSERR_VALNOTFOUND";
+        case MMSYSERR_NODRIVERCB: return "MMSYSERR_NODRIVERCB";
+        default: return "?";
     }
-    
-    va_start(va, fmt);
-    vfprintf(stderr, fmt, va);
-    va_end(va);
-    
-    fprintf(stderr, " err %d (%s)\n", (int)rv, errtxt);
+}
+#define midi_error(rv, fmt, ...) { \
+    ASS_Message(fmt, __VA_ARGS__); \
+    ASS_Message(" err %d (%s)\n", (int)(rv), mmsyserr_str(rv)); \
 }
 
 static void midi_dispose_buffer(MidiBuffer * node, const char * caller)
@@ -487,7 +479,7 @@ static void midi_dispose_buffer(MidiBuffer * node, const char * caller)
     if (node->prepared) {
         rv = midiOutUnprepareHeader( (HMIDIOUT) midiStream, &node->hdr, sizeof(MIDIHDR) );
         if (rv != MMSYSERR_NOERROR) {
-            midi_error(rv, "WinMM %s/midi_dispose_buffer midiOutUnprepareHeader", caller);
+            midi_error(rv, "WinMMDrv: %s/midi_dispose_buffer midiOutUnprepareHeader", caller);
         }
         node->prepared = FALSE;
     }
@@ -498,11 +490,11 @@ static void midi_dispose_buffer(MidiBuffer * node, const char * caller)
     
         // when playing, we keep the buffers
         LL_Add( (MidiBuffer*) &spareMidiBuffers, node, next, prev );
-        //fprintf(stderr, "WinMM %s/midi_dispose_buffer recycling buffer %p\n", caller, node);
+        //ASS_Message("WinMMDrv: %s/midi_dispose_buffer recycling buffer %p\n", caller, node);
     } else {
         // when not, we throw them away
         free(node);
-        //fprintf(stderr, "WinMM %s/midi_dispose_buffer freeing buffer %p\n", caller, node);
+        //ASS_Message("WinMMDrv: %s/midi_dispose_buffer freeing buffer %p\n", caller, node);
     }
 }
 
@@ -523,20 +515,20 @@ static void midi_free_buffers(void)
 {
     MidiBuffer *node, *next;
 
-    //fprintf(stderr, "waiting for active buffers to return\n");
+    //ASS_Message("WinMMDrv: waiting for active buffers to return\n");
     while (!LL_ListEmpty(&activeMidiBuffers, next, prev)) {
         // wait for Windows to finish with all the buffers queued
         midi_gc_buffers();
-        //fprintf(stderr, "waiting...\n");
+        //ASS_Message("WinMMDrv: waiting...\n");
         Sleep(10);
     }
-    //fprintf(stderr, "waiting over\n");
+    //ASS_Message("WinMMDrv: waiting over\n");
 
     for ( node = spareMidiBuffers.next; node != &spareMidiBuffers; node = next ) {
         next = node->next;
         LL_Remove( node, next, prev );
         free(node);
-        //fprintf(stderr, "WinMM midi_free_buffers freeing buffer %p\n", node);
+        //ASS_Message("WinMMDrv: midi_free_buffers freeing buffer %p\n", node);
     }
     
     assert(currentMidiBuffer == 0);
@@ -574,7 +566,7 @@ static void midi_flush_current_buffer(void)
         // we need to prepare the buffer
         rv = midiOutPrepareHeader( (HMIDIOUT) midiStream, &currentMidiBuffer->hdr, sizeof(MIDIHDR) );
         if (rv != MMSYSERR_NOERROR) {
-            midi_error(rv, "WinMM midi_flush_current_buffer midiOutPrepareHeader");
+            midi_error(rv, "WinMMDrv: midi_flush_current_buffer midiOutPrepareHeader");
             return;
         }
 
@@ -588,12 +580,12 @@ static void midi_flush_current_buffer(void)
 
         rv = midiStreamOut(midiStream, &currentMidiBuffer->hdr, sizeof(MIDIHDR));
         if (rv != MMSYSERR_NOERROR) {
-            midi_error(rv, "WinMM midi_flush_current_buffer midiStreamOut");
+            midi_error(rv, "WinMMDrv: midi_flush_current_buffer midiStreamOut");
             midi_dispose_buffer(currentMidiBuffer, "midi_flush_current_buffer");
             return;
         }
 
-        //fprintf(stderr, "WinMM midi_flush_current_buffer queued buffer %p\n", currentMidiBuffer);
+        //ASS_Message("WinMMDrv: midi_flush_current_buffer queued buffer %p\n", currentMidiBuffer);
     } else {
         // midi file not playing, so send immediately
         
@@ -603,16 +595,16 @@ static void midi_flush_current_buffer(void)
                 // busy-wait for Windows to be done with it
                 while (!(currentMidiBuffer->hdr.dwFlags & MHDR_DONE)) ;
                 
-                //fprintf(stderr, "WinMM midi_flush_current_buffer sent immediate long\n");
+                //ASS_Message("WinMMDrv: midi_flush_current_buffer sent immediate long\n");
             } else {
-                midi_error(rv, "WinMM midi_flush_current_buffer midiOutLongMsg");
+                midi_error(rv, "WinMMDrv: midi_flush_current_buffer midiOutLongMsg");
             }
         } else {
             rv = midiOutShortMsg( (HMIDIOUT) midiStream, evt->dwEvent );
             if (rv == MMSYSERR_NOERROR) {
-                //fprintf(stderr, "WinMM midi_flush_current_buffer sent immediate short\n");
+                //ASS_Message("WinMMDrv: midi_flush_current_buffer sent immediate short\n");
             } else {
-                midi_error(rv, "WinMM midi_flush_current_buffer midiOutShortMsg");
+                midi_error(rv, "WinMMDrv: midi_flush_current_buffer midiOutShortMsg");
             }
         }
 
@@ -701,7 +693,7 @@ static BOOL midi_get_buffer(int length, unsigned char ** data)
                 
                 currentMidiBuffer = node;
                 
-                //fprintf(stderr, "WinMM midi_get_buffer fetched buffer %p\n", node);
+                //ASS_Message("WinMMDrv: midi_get_buffer fetched buffer %p\n", node);
                 break;
             }
         }
@@ -735,7 +727,7 @@ static BOOL midi_get_buffer(int length, unsigned char ** data)
         
         currentMidiBuffer = node;
         
-        //fprintf(stderr, "WinMM midi_get_buffer allocated buffer %p\n", node);
+        //ASS_Message("WinMMDrv: midi_get_buffer allocated buffer %p\n", node);
     }
 
     midi_setup_event(length, data);
@@ -753,7 +745,7 @@ static inline void midi_sequence_event(void)
         return;
     }
     
-    //fprintf(stderr, "WinMM midi_sequence_event buffered\n");
+    //ASS_Message("WinMMDrv: midi_sequence_event buffered\n");
 
     // update the delta time counter
     midiLastEventTime = midiThreadTimer;
@@ -768,7 +760,7 @@ static void Func_NoteOff( int channel, int key, int velocity )
         data[1] = key;
         data[2] = velocity;
         midi_sequence_event();
-    } else fprintf(stderr, "WinMM Func_NoteOff error\n");
+    } else ASS_Message("WinMMDrv: note off error\n");
 }
 
 static void Func_NoteOn( int channel, int key, int velocity )
@@ -780,7 +772,7 @@ static void Func_NoteOn( int channel, int key, int velocity )
         data[1] = key;
         data[2] = velocity;
         midi_sequence_event();
-    } else fprintf(stderr, "WinMM Func_NoteOn error\n");
+    } else ASS_Message("WinMMDrv: note on error\n");
 }
 
 static void Func_PolyAftertouch( int channel, int key, int pressure )
@@ -792,7 +784,7 @@ static void Func_PolyAftertouch( int channel, int key, int pressure )
         data[1] = key;
         data[2] = pressure;
         midi_sequence_event();
-    } else fprintf(stderr, "WinMM Func_PolyAftertouch error\n");
+    } else ASS_Message("WinMMDrv: poly aftertouch error\n");
 }
 
 static void Func_ControlChange( int channel, int number, int value )
@@ -804,7 +796,7 @@ static void Func_ControlChange( int channel, int number, int value )
         data[1] = number;
         data[2] = value;
         midi_sequence_event();
-    } else fprintf(stderr, "WinMM Func_ControlChange error\n");
+    } else ASS_Message("WinMMDrv: control change error\n");
 }
 
 static void Func_ProgramChange( int channel, int program )
@@ -815,7 +807,7 @@ static void Func_ProgramChange( int channel, int program )
         data[0] = MIDI_PROGRAM_CHANGE | channel;
         data[1] = program;
         midi_sequence_event();
-    } else fprintf(stderr, "WinMM Func_ProgramChange error\n");
+    } else ASS_Message("WinMMDrv: program change error\n");
 }
 
 static void Func_ChannelAftertouch( int channel, int pressure )
@@ -826,7 +818,7 @@ static void Func_ChannelAftertouch( int channel, int pressure )
         data[0] = MIDI_AFTER_TOUCH | channel;
         data[1] = pressure;
         midi_sequence_event();
-    } else fprintf(stderr, "WinMM Func_ChannelAftertouch error\n");
+    } else ASS_Message("WinMMDrv: channel aftertouch error\n");
 }
 
 static void Func_PitchBend( int channel, int lsb, int msb )
@@ -838,7 +830,7 @@ static void Func_PitchBend( int channel, int lsb, int msb )
         data[1] = lsb;
         data[2] = msb;
         midi_sequence_event();
-    } else fprintf(stderr, "WinMM Func_PitchBend error\n");
+    } else ASS_Message("WinMMDrv: pitch bend error\n");
 }
 
 static void Func_SysEx( const unsigned char * data, int length )
@@ -848,7 +840,7 @@ static void Func_SysEx( const unsigned char * data, int length )
     if (midi_get_buffer(length, &wdata)) {
         memcpy(wdata, data, length);
         midi_sequence_event();
-    } else fprintf(stderr, "WinMM Func_SysEx error\n");
+    } else ASS_Message("WinMMDrv: sysex error\n");
 }
 
 int WinMMDrv_MIDI_Init(midifuncs * funcs, const char *params)
@@ -875,7 +867,7 @@ int WinMMDrv_MIDI_Init(midifuncs * funcs, const char *params)
         CloseHandle(midiMutex);
         midiMutex = 0;
 
-        midi_error(rv, "WinMM MIDI_Init midiStreamOpen");
+        midi_error(rv, "WinMMDrv: MIDI_Init midiStreamOpen");
         ErrorCode = WinMMErr_MIDIStreamOpen;
         return WinMMErr_Error;
     }
@@ -907,7 +899,7 @@ void WinMMDrv_MIDI_Shutdown(void)
     if (midiStream) {
         rv = midiStreamClose(midiStream);
         if (rv != MMSYSERR_NOERROR) {
-            midi_error(rv, "WinMM MIDI_Shutdown midiStreamClose");
+            midi_error(rv, "WinMMDrv: MIDI_Shutdown midiStreamClose");
         }
     }
 
@@ -930,7 +922,7 @@ static DWORD midi_get_tick(void)
 
     rv = midiStreamPosition(midiStream, &mmtime, sizeof(MMTIME));
     if (rv != MMSYSERR_NOERROR) {
-        midi_error(rv, "WinMM midi_get_tick midiStreamPosition");
+        midi_error(rv, "WinMMDrv: midi_get_tick midiStreamPosition");
         return 0;
     }
 
@@ -943,7 +935,7 @@ static DWORD WINAPI midiDataThread(LPVOID lpParameter)
     DWORD sequenceTime;
     DWORD sleepAmount = 100 / THREAD_QUEUE_INTERVAL;
     
-    fprintf(stderr, "WinMM midiDataThread: started\n");
+    ASS_Message("WinMMDrv: midiDataThread started\n");
 
     midiThreadTimer = midi_get_tick();
     midiLastEventTime = midiThreadTimer;
@@ -963,7 +955,7 @@ static DWORD WINAPI midiDataThread(LPVOID lpParameter)
     do {
         waitret = WaitForSingleObject(midiThreadQuitEvent, sleepAmount);
         if (waitret == WAIT_OBJECT_0) {
-            fprintf(stderr, "WinMM midiDataThread: exiting\n");
+            ASS_Message("WinMMDrv: midiDataThread exiting\n");
             break;
         } else if (waitret == WAIT_TIMEOUT) {
             // queue a tick
@@ -991,7 +983,7 @@ static DWORD WINAPI midiDataThread(LPVOID lpParameter)
             WinMMDrv_MIDI_Unlock();
 
         } else {
-            fprintf(stderr, "WinMM midiDataThread: wfmo err %d\n", (int) waitret);
+            ASS_Message("WinMMDrv: midiDataThread wfmo err %d\n", (int) waitret);
         }
     } while (1);
 
@@ -1042,7 +1034,7 @@ void WinMMDrv_MIDI_HaltPlayback(void)
         SetEvent(midiThreadQuitEvent);
 
         WaitForSingleObject(midiThread, INFINITE);
-        fprintf(stderr, "WinMM MIDI_HaltPlayback synched\n");
+        ASS_Message("WinMMDrv: MIDI_HaltPlayback synched\n");
 
         CloseHandle(midiThread);
     }
@@ -1052,12 +1044,12 @@ void WinMMDrv_MIDI_HaltPlayback(void)
     }
     
     if (midiStreamRunning) {
-        fprintf(stderr, "stopping stream\n");
+        ASS_Message("WinMMDrv: stopping stream\n");
         rv = midiStreamStop(midiStream);
         if (rv != MMSYSERR_NOERROR) {
-            midi_error(rv, "WinMM MIDI_HaltPlayback midiStreamStop");
+            midi_error(rv, "WinMMDrv: MIDI_HaltPlayback midiStreamStop");
         }
-        fprintf(stderr, "stream stopped\n");
+        ASS_Message("WinMMDrv: stream stopped\n");
     
         midiStreamRunning = FALSE;
     }
@@ -1075,7 +1067,7 @@ void WinMMDrv_MIDI_SetTempo(int tempo, int division)
     MIDIPROPTIMEDIV propTimediv;
     BOOL running = midiStreamRunning;
 
-    //fprintf(stderr, "MIDI_SetTempo %d/%d\n", tempo, division);
+    //ASS_Message("WinMMDrv: MIDI_SetTempo %d/%d\n", tempo, division);
 
     propTempo.cbStruct = sizeof(MIDIPROPTEMPO);
     propTempo.dwTempo = 60000000l / tempo;
@@ -1088,13 +1080,13 @@ void WinMMDrv_MIDI_SetTempo(int tempo, int division)
 
         rv = midiStreamProperty(midiStream, (LPBYTE) &propTimediv, MIDIPROP_SET | MIDIPROP_TIMEDIV);
         if (rv != MMSYSERR_NOERROR) {
-            midi_error(rv, "WinMM MIDI_SetTempo midiStreamProperty timediv");
+            midi_error(rv, "WinMMDrv: MIDI_SetTempo midiStreamProperty timediv");
         }
     }
 
     rv = midiStreamProperty(midiStream, (LPBYTE) &propTempo, MIDIPROP_SET | MIDIPROP_TEMPO);
     if (rv != MMSYSERR_NOERROR) {
-        midi_error(rv, "WinMM MIDI_SetTempo midiStreamProperty tempo");
+        midi_error(rv, "WinMMDrv: MIDI_SetTempo midiStreamProperty tempo");
     }
 
     if (midiLastDivision != division) {
@@ -1118,7 +1110,7 @@ void WinMMDrv_MIDI_Lock(void)
 
     err = WaitForSingleObject(midiMutex, INFINITE);
     if (err != WAIT_OBJECT_0) {
-        fprintf(stderr, "WinMM midiMutex lock: wfso %d\n", (int) err);
+        ASS_Message("WinMMDrv: midiMutex lock: wfso %d\n", (int) err);
     }
 }
 
diff --git a/jfaudiolib/src/drivers.c b/jfaudiolib/src/drivers.c
index cfcfd4c..9a4f549 100644
--- a/jfaudiolib/src/drivers.c
+++ b/jfaudiolib/src/drivers.c
@@ -25,6 +25,9 @@
 
 #include "drivers.h"
 
+//#define NO_COREAUDIO
+//#define NO_DIRECTSOUND
+
 #include "driver_nosound.h"
 
 #ifdef HAVE_SDL
@@ -112,31 +115,6 @@ static struct {
         NoSoundDrv_MIDI_SetTempo,
         NoSoundDrv_MIDI_Lock,
         NoSoundDrv_MIDI_Unlock,
-   },
-    
-    // Simple DirectMedia Layer
-    {
-        "SDL",
-    #ifdef HAVE_SDL
-        SDLDrv_GetError,
-        SDLDrv_ErrorString,
-        SDLDrv_PCM_Init,
-        SDLDrv_PCM_Shutdown,
-        SDLDrv_PCM_BeginPlayback,
-        SDLDrv_PCM_StopPlayback,
-        SDLDrv_PCM_Lock,
-        SDLDrv_PCM_Unlock,
-        SDLDrv_CD_Init,
-        SDLDrv_CD_Shutdown,
-        SDLDrv_CD_Play,
-        SDLDrv_CD_Stop,
-        SDLDrv_CD_Pause,
-        SDLDrv_CD_IsPlaying,
-        SDLDrv_CD_SetVolume,
-        UNSUPPORTED_MIDI,
-    #else
-        UNSUPPORTED_COMPLETELY,
-    #endif
     },
 
     // OS X CoreAudio
@@ -167,7 +145,7 @@ static struct {
     // Windows DirectSound
     {
         "DirectSound",
-    #ifdef _WIN32
+    #if defined _WIN32 && !defined NO_DIRECTSOUND
         DirectSoundDrv_GetError,
         DirectSoundDrv_ErrorString,
         DirectSoundDrv_PCM_Init,
@@ -254,6 +232,31 @@ static struct {
         UNSUPPORTED_COMPLETELY,
     #endif
     },
+
+    // Simple DirectMedia Layer
+    {
+        "SDL",
+    #ifdef HAVE_SDL
+        SDLDrv_GetError,
+        SDLDrv_ErrorString,
+        SDLDrv_PCM_Init,
+        SDLDrv_PCM_Shutdown,
+        SDLDrv_PCM_BeginPlayback,
+        SDLDrv_PCM_StopPlayback,
+        SDLDrv_PCM_Lock,
+        SDLDrv_PCM_Unlock,
+        SDLDrv_CD_Init,
+        SDLDrv_CD_Shutdown,
+        SDLDrv_CD_Play,
+        SDLDrv_CD_Stop,
+        SDLDrv_CD_Pause,
+        SDLDrv_CD_IsPlaying,
+        SDLDrv_CD_SetVolume,
+        UNSUPPORTED_MIDI,
+    #else
+        UNSUPPORTED_COMPLETELY,
+    #endif
+    },
 };
 
 
diff --git a/jfaudiolib/src/fx_man.c b/jfaudiolib/src/fx_man.c
index e5aedc1..00be010 100644
--- a/jfaudiolib/src/fx_man.c
+++ b/jfaudiolib/src/fx_man.c
@@ -28,16 +28,14 @@ Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
    (c) Copyright 1994 James R. Dose.  All Rights Reserved.
 **********************************************************************/
 
-#include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
 #include "sndcards.h"
 #include "drivers.h"
 #include "multivoc.h"
 #include "fx_man.h"
-
-#define TRUE  ( 1 == 1 )
-#define FALSE ( !TRUE )
+#include "asssys.h"
+#include "assmisc.h"
 
 int FX_ErrorCode = FX_Ok;
 int FX_Installed = FALSE;
@@ -116,51 +114,64 @@ int FX_Init
    )
 
    {
-   int status;
    int devicestatus;
+   int mincard, maxcard, card;
 
    if ( FX_Installed )
       {
       FX_Shutdown();
       }
-	
-	if (SoundCard == ASS_AutoDetect) {
-#if defined __APPLE__ && !defined NO_COREAUDIO
-		SoundCard = ASS_CoreAudio;
-#elif defined _WIN32
-		SoundCard = ASS_DirectSound;
-#elif defined HAVE_SDL
-		SoundCard = ASS_SDL;
-#else
-		SoundCard = ASS_NoSound;
-#endif
-	}
-	
-	if (SoundCard < 0 || SoundCard >= ASS_NumSoundCards) {
-		FX_SetErrorCode( FX_InvalidCard );
-		status = FX_Error;
-		return status;
-	}
-	
-	if (SoundDriver_IsPCMSupported(SoundCard) == 0) {
-		// unsupported cards fall back to no sound
-		SoundCard = ASS_NoSound;
-	}
-   
-   status = FX_Ok;
-	devicestatus = MV_Init( SoundCard, mixrate, numvoices, numchannels, samplebits, initdata );
-	if ( devicestatus != MV_Ok )
-		{
-		FX_SetErrorCode( FX_MultiVocError );
-		status = FX_Error;
-		}
 
-   if ( status == FX_Ok )
+   if (SoundCard == ASS_AutoDetect)
+      {
+      mincard = ASS_NoSound + 1;
+      maxcard = ASS_NumSoundCards - 1;
+      }
+   else if (SoundCard < 0 || SoundCard >= ASS_NumSoundCards)
       {
-      FX_Installed = TRUE;
+      FX_SetErrorCode( FX_InvalidCard );
+      return FX_Error;
+      }
+   else
+      {
+      mincard = SoundCard;
+      maxcard = SoundCard;
       }
 
-   return( status );
+   for (card = mincard; card <= maxcard; card++)
+      {
+      if (!SoundDriver_IsPCMSupported(card))
+         {
+         continue;
+         }
+      else if (SoundCard == ASS_AutoDetect)
+         {
+         ASS_Message("FX_Init: trying %s\n", SoundDriver_GetName(card));
+         }
+
+      devicestatus = MV_Init( card, mixrate, numvoices, numchannels, samplebits, initdata );
+      if (devicestatus == MV_Ok)
+         {
+         FX_Installed = TRUE;
+         return FX_Ok;
+         }
+      }
+
+   if (SoundCard == ASS_AutoDetect)
+      {
+      // A failure to autodetect falls back to no sound.
+      card = ASS_NoSound;
+
+      devicestatus = MV_Init( card, mixrate, numvoices, numchannels, samplebits, initdata );
+      if ( devicestatus == MV_Ok )
+         {
+         FX_Installed = TRUE;
+         return FX_Ok;
+         }
+      }
+
+   FX_SetErrorCode( FX_MultiVocError );
+   return FX_Error;
    }
 
 
@@ -502,6 +513,32 @@ int FX_SetFrequency
    }
 
 
+/*---------------------------------------------------------------------
+   Function: FX_GetFrequency
+
+   Gets the frequency of the voice associated with the specified handle.
+---------------------------------------------------------------------*/
+
+int FX_GetFrequency
+   (
+   int handle,
+   int *frequency
+   )
+
+   {
+   int status;
+
+   status = MV_GetFrequency( handle, frequency );
+   if ( status == MV_Error )
+      {
+      FX_SetErrorCode( FX_MultiVocError );
+      status = FX_Warning;
+      }
+
+   return( status );
+   }
+
+
 /*---------------------------------------------------------------------
    Function: FX_PlayVOC
 
@@ -992,6 +1029,8 @@ int FX_StartRecording
    {
    int status;
 
+	(void)MixRate; (void)function;
+
 	FX_SetErrorCode( FX_InvalidCard );
 	status = FX_Warning;
 
diff --git a/jfaudiolib/src/midi.c b/jfaudiolib/src/midi.c
index 9018143..037ee67 100644
--- a/jfaudiolib/src/midi.c
+++ b/jfaudiolib/src/midi.c
@@ -39,35 +39,7 @@ Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 #include "_midi.h"
 #include "midi.h"
 #include "asssys.h"
-
-#define TRUE  ( 1 == 1 )
-#define FALSE ( !TRUE )
-
-#ifdef __POWERPC__
-#define LITTLE16 SWAP16
-#define LITTLE32 SWAP32
-#else
-#define LITTLE16
-#define LITTLE32
-#endif
-
-#ifdef _MSC_VER
-#define inline _inline
-#define alloca _alloca
-#endif
-
-static inline unsigned short SWAP16(unsigned short s)
-{
-	return (s >> 8) | (s << 8);
-}
-
-static inline unsigned int SWAP32(unsigned int s)
-{
-	return (s >> 24) | (s << 24) | ((s&0xff00) << 8) | ((s & 0xff0000) >> 8);
-}
-
-#define min(x,y) ((x) < (y) ? (x) : (y))
-#define max(x,y) ((x) > (y) ? (x) : (y))
+#include "assmisc.h"
 
 int MUSIC_EMIDIPersonality = EMIDI_GeneralMIDI;
 
diff --git a/jfaudiolib/src/multivoc.c b/jfaudiolib/src/multivoc.c
index f40d33d..51004ff 100644
--- a/jfaudiolib/src/multivoc.c
+++ b/jfaudiolib/src/multivoc.c
@@ -39,33 +39,9 @@ Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 #include "drivers.h"
 #include "pitch.h"
 #include "multivoc.h"
+#include "assmisc.h"
 #include "_multivc.h"
 
-#ifdef __POWERPC__
-#define LITTLE16 SWAP16
-#define LITTLE32 SWAP32
-#else
-#define LITTLE16
-#define LITTLE32
-#endif
-
-#ifdef _MSC_VER
-#define inline _inline
-#endif
-
-static inline unsigned short SWAP16(unsigned short s)
-{
-	return (s >> 8) | (s << 8);
-}
-
-static inline unsigned int SWAP32(unsigned int s)
-{
-	return (s >> 24) | (s << 24) | ((s&0xff00) << 8) | ((s & 0xff0000) >> 8);
-}
-
-#define min(x,y) ((x) < (y) ? (x) : (y))
-#define max(x,y) ((x) > (y) ? (x) : (y))
-
 #define RoundFixed( fixedval, bits )            \
         (                                       \
           (                                     \
@@ -149,6 +125,8 @@ static int DisableInterrupts(void)
 
 static void RestoreInterrupts(int a)
 {
+	(void)a;
+
 	if (--lockdepth > 0) {
 		return;
 	}
@@ -1392,6 +1370,45 @@ int MV_SetFrequency
    }
 
 
+/*---------------------------------------------------------------------
+   Function: MV_GetFrequency
+
+   Gets the frequency for the voice associated with the specified handle.
+---------------------------------------------------------------------*/
+
+int MV_GetFrequency
+   (
+   int handle,
+   int *frequency
+   )
+
+   {
+   VoiceNode *voice;
+
+   if ( !MV_Installed )
+      {
+      MV_SetErrorCode( MV_NotInstalled );
+      return( MV_Error );
+      }
+
+   voice = MV_GetVoice( handle );
+   if ( voice == NULL )
+      {
+      MV_SetErrorCode( MV_VoiceNotFound );
+      return( MV_Error );
+      }
+
+    if ( voice->SamplingRate == 0 )
+      {
+      voice->GetSound( voice );
+      }
+
+   *frequency = voice->SamplingRate;
+
+   return( MV_Ok );
+   }
+
+
 /*---------------------------------------------------------------------
    Function: MV_GetVolumeTable
 
@@ -2013,6 +2030,8 @@ int MV_StartRecording
    )
 
    {
+	(void)MixRate; (void)function;
+
 	MV_SetErrorCode( MV_UnsupportedCard );
 	return( MV_Error );
    }
@@ -2355,6 +2374,8 @@ int MV_PlayLoopedWAV
    VoiceNode     *voice;
    int length;
 
+   (void)ptrlength; (void)loopend;
+
    if ( !MV_Installed )
       {
       MV_SetErrorCode( MV_NotInstalled );
@@ -2567,6 +2588,8 @@ int MV_PlayLoopedVOC
    VoiceNode   *voice;
    int          status;
 
+   (void)ptrlength;
+
    if ( !MV_Installed )
       {
       MV_SetErrorCode( MV_NotInstalled );
diff --git a/jfaudiolib/src/multivoc.h b/jfaudiolib/src/multivoc.h
index de7d8bf..5328aeb 100644
--- a/jfaudiolib/src/multivoc.h
+++ b/jfaudiolib/src/multivoc.h
@@ -63,6 +63,7 @@ int   MV_VoicesPlaying( void );
 int   MV_VoiceAvailable( int priority );
 int   MV_SetPitch( int handle, int pitchoffset );
 int   MV_SetFrequency( int handle, int frequency );
+int   MV_GetFrequency( int handle, int *frequency );
 int   MV_EndLooping( int handle );
 int   MV_SetPan( int handle, int vol, int left, int right );
 int   MV_Pan3D( int handle, int angle, int distance );
diff --git a/jfaudiolib/src/music.c b/jfaudiolib/src/music.c
index d2957cd..c57fb94 100644
--- a/jfaudiolib/src/music.c
+++ b/jfaudiolib/src/music.c
@@ -35,12 +35,8 @@ Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 #include "music.h"
 #include "midi.h"
 #include "ll_man.h"
-
-#define TRUE  ( 1 == 1 )
-#define FALSE ( !TRUE )
-
-#define min(x,y) ((x) < (y) ? (x) : (y))
-#define max(x,y) ((x) > (y) ? (x) : (y))
+#include "asssys.h"
+#include "assmisc.h"
 
 int MUSIC_ErrorCode = MUSIC_Ok;
 
@@ -118,49 +114,59 @@ int MUSIC_Init
    {
    int i;
    int status;
+   int mincard, maxcard, card;
 
    for( i = 0; i < 128; i++ )
       {
       MIDI_PatchMap[ i ] = i;
       }
 
-	if (SoundCard == ASS_AutoDetect) {
-#if defined __APPLE__ && !defined NO_COREAUDIO
-		SoundCard = ASS_CoreAudio;
-#elif defined _WIN32
-		SoundCard = ASS_WinMM;
-#elif defined HAVE_ALSA
-        SoundCard = ASS_ALSA;
-#elif defined HAVE_FLUIDSYNTH
-		SoundCard = ASS_FluidSynth;
-#else
-		SoundCard = ASS_NoSound;
-#endif
-	}
-
-	if (SoundCard < 0 || SoundCard >= ASS_NumSoundCards) {
-		MUSIC_ErrorCode = MUSIC_InvalidCard;
-		return MUSIC_Error;
-	}
-
-    if (!SoundDriver_IsMIDISupported(SoundCard))
+   if (SoundCard == ASS_AutoDetect)
+      {
+      mincard = ASS_NoSound + 1;
+      maxcard = ASS_NumSoundCards - 1;
+      }
+   else if (SoundCard < 0 || SoundCard >= ASS_NumSoundCards)
       {
       MUSIC_ErrorCode = MUSIC_InvalidCard;
       return MUSIC_Error;
       }
+   else
+      {
+      mincard = SoundCard;
+      maxcard = SoundCard;
+      }
 
-   ASS_MIDISoundDriver = SoundCard;
-
-   status = SoundDriver_MIDI_Init(&MUSIC_MidiFunctions, params);
-   if (status != MUSIC_Ok)
+   for (card = mincard; card <= maxcard; card++)
       {
-      MUSIC_ErrorCode = MUSIC_DriverError;
-      return MUSIC_Error;
+      if (!SoundDriver_IsMIDISupported(card))
+         {
+         continue;
+         }
+      else if (SoundCard == ASS_AutoDetect)
+         {
+         ASS_Message("MUSIC_Init: trying %s\n", SoundDriver_GetName(card));
+         }
+
+      ASS_MIDISoundDriver = card;
+      status = SoundDriver_MIDI_Init(&MUSIC_MidiFunctions, params);
+      if (status == MUSIC_Ok)
+         {
+         MIDI_SetMidiFuncs( &MUSIC_MidiFunctions );
+         return MUSIC_Ok;
+         }
       }
 
-   MIDI_SetMidiFuncs( &MUSIC_MidiFunctions );
+   if (SoundCard == ASS_AutoDetect)
+      {
+      // A failure to autodetect falls back to no sound.
+      ASS_MIDISoundDriver = ASS_NoSound;
+      MIDI_SetMidiFuncs( &MUSIC_MidiFunctions );
+      return MUSIC_Ok;
+      }
 
-   return MUSIC_Ok;
+   MUSIC_ErrorCode = MUSIC_DriverError;
+   return MUSIC_Error;
    }
 
 
@@ -216,6 +222,7 @@ void MUSIC_SetMaxFMMidiChannel
    )
 
    {
+   (void)channel;
    //AL_SetMaxMidiChannel( channel );
    }
 
@@ -395,6 +402,8 @@ int MUSIC_PlaySong
    {
    int status;
 
+   (void)length;
+
    MIDI_StopSong();
    status = MIDI_PlaySong( song, loopflag );
    if ( status != MIDI_Ok )
@@ -576,6 +585,7 @@ int MUSIC_FadeVolume
    )
 
    {
+   (void)tovolume; (void)milliseconds;
    /*int fromvolume;
 
    if ( ( MUSIC_SoundDevice == ProAudioSpectrum ) ||
@@ -681,5 +691,6 @@ void MUSIC_RegisterTimbreBank
    )
 
    {
+   (void)timbres;
    //AL_RegisterTimbreBank( timbres );
    }
diff --git a/jfaudiolib/src/test.c b/jfaudiolib/src/test.c
index fcecf9e..6c44f93 100644
--- a/jfaudiolib/src/test.c
+++ b/jfaudiolib/src/test.c
@@ -32,7 +32,7 @@ int main(int argc, char ** argv)
     int arg = 0;
     void * initdata = 0;
     const char * musicinit = 0;
-    const char * song = "test.ogg";
+    const char * song = "samples/test.wav";
 
     for (arg = 1; arg < argc; arg++) {
         if (argv[arg][0] == '-') {
@@ -125,6 +125,8 @@ void playsong(const char * song)
 
     fclose(fp);
 
+    printf("Playing %s\n", song);
+
     if (memcmp(data, "MThd", 4) == 0) {
         status = MUSIC_PlaySong(data, length, 0);
         if (status != MUSIC_Ok) {
diff --git a/jfaudiolib/src/vorbis.c b/jfaudiolib/src/vorbis.c
index ef35046..c1f0b00 100644
--- a/jfaudiolib/src/vorbis.c
+++ b/jfaudiolib/src/vorbis.c
@@ -31,7 +31,6 @@
 #endif
 
 #include <stdlib.h>
-#include <stdio.h>
 #include <string.h>
 #ifndef _WIN32
 # include <unistd.h>
@@ -40,10 +39,8 @@
 #include "pitch.h"
 #include "multivoc.h"
 #include "_multivc.h"
-
-#define min(x,y) ((x) < (y) ? (x) : (y))
-#define max(x,y) ((x) > (y) ? (x) : (y))
-
+#include "asssys.h"
+#include "assmisc.h"
 
 typedef struct {
    char * ptr;
@@ -109,6 +106,7 @@ static int seek_vorbis(void * datasource, ogg_int64_t offset, int whence)
 
 static int close_vorbis(void * datasource)
 {
+   (void)datasource;
    return 0;
 }
 
@@ -148,13 +146,13 @@ static playbackstatus MV_GetNextVorbisBlock
    bytesread = 0;
    do {
       bytes = ov_read(&vd->vf, vd->block + bytesread, sizeof(vd->block) - bytesread, 0, 2, 1, &bitstream);
-      //fprintf(stderr, "ov_read = %d\n", bytes);
+      //ASS_Message("ov_read = %d\n", bytes);
       if (bytes == OV_HOLE) continue;
       if (bytes == 0) {
          if (voice->LoopStart) {
             err = ov_pcm_seek_page(&vd->vf, 0);
             if (err != 0) {
-               fprintf(stderr, "MV_GetNextVorbisBlock ov_pcm_seek_page_lap: err %d\n", err);
+               ASS_Message("MV_GetNextVorbisBlock ov_pcm_seek_page_lap: err %d\n", err);
             } else {
                continue;
             }
@@ -162,13 +160,13 @@ static playbackstatus MV_GetNextVorbisBlock
            break;
          }
       } else if (bytes < 0) {
-         fprintf(stderr, "MV_GetNextVorbisBlock ov_read: err %d\n", bytes);
+         ASS_Message("MV_GetNextVorbisBlock ov_read: err %d\n", bytes);
          voice->Playing = FALSE;
          return NoMoreData;
       }
 
       bytesread += bytes;
-   } while (bytesread < sizeof(vd->block));
+   } while (bytesread < (int)sizeof(vd->block));
 
    if (bytesread == 0) {
       voice->Playing = FALSE;
@@ -317,7 +315,9 @@ int MV_PlayLoopedVorbis
    int          status;
    vorbis_data * vd = 0;
    vorbis_info * vi = 0;
-   
+
+   (void)loopend;
+
    if ( !MV_Installed )
    {
       MV_SetErrorCode( MV_NotInstalled );
@@ -338,7 +338,7 @@ int MV_PlayLoopedVorbis
    
    status = ov_open_callbacks((void *) vd, &vd->vf, 0, 0, vorbis_callbacks);
    if (status < 0) {
-      fprintf(stderr, "MV_PlayLoopedVorbis: err %d\n", status);
+      ASS_Message("MV_PlayLoopedVorbis: err %d\n", status);
       MV_SetErrorCode( MV_InvalidVorbisFile );
       return MV_Error;
    }
