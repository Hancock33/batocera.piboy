diff --git a/aclocal.m4 b/aclocal.m4
index 2ba926b490c..440c5319aa8 100644
--- a/aclocal.m4
+++ b/aclocal.m4
@@ -275,7 +275,8 @@ dnl
 dnl Usage: AC_REQUIRE([WINE_CONFIG_HELPERS])
 dnl
 AC_DEFUN([WINE_CONFIG_HELPERS],
-[AS_VAR_SET([wine_rules],["all:"])
+[AS_VAR_SET([wine_rules],["all:
+	@echo 'Wine build complete.'"])
 AC_SUBST(SUBDIRS,"")
 AC_SUBST(DISABLED_SUBDIRS,"")
 AC_SUBST(CONFIGURE_TARGETS,"")
@@ -302,15 +303,6 @@ wine_fn_config_makefile ()
           programs/*,*\ arm64ec\ *) AS_VAR_APPEND([arm64ec_DISABLED_SUBDIRS],[" $[1]"]) ;;
         esac ;;
     esac
-}
-
-wine_fn_config_symlink ()
-{
-    ac_links=$[@]
-    AS_VAR_APPEND([wine_rules],["
-$ac_links:
-	@./config.status \$[@]"])
-    for f in $ac_links; do AS_VAR_APPEND([CONFIGURE_TARGETS],[" $f"]); done
 }])
 
 dnl **** Define helper function to append a rule to a makefile command list ****
@@ -320,17 +312,6 @@ dnl
 AC_DEFUN([WINE_APPEND_RULE],[AC_REQUIRE([WINE_CONFIG_HELPERS])AS_VAR_APPEND([wine_rules],["
 $1"])])
 
-dnl **** Create symlinks from config.status ****
-dnl
-dnl Usage: WINE_CONFIG_SYMLINK(target,src,enable)
-dnl
-AC_DEFUN([WINE_CONFIG_SYMLINK],[AC_REQUIRE([WINE_CONFIG_HELPERS])dnl
-m4_ifval([$3],[if test $3; then
-])AC_CONFIG_LINKS([$1:$2])dnl
-wine_fn_config_symlink[ $1]m4_ifval([$3],[
-fi])[]dnl
-])])
-
 dnl **** Create a makefile from config.status ****
 dnl
 dnl Usage: WINE_CONFIG_MAKEFILE(file,enable,condition)
diff --git a/configure.ac b/configure.ac
index 012ad991159..86bb824b098 100644
--- a/configure.ac
+++ b/configure.ac
@@ -615,6 +615,7 @@ case $host_os in
     dnl Disable modules that can't be used on Windows
     enable_loader=${enable_loader:-no}
     enable_server=${enable_server:-no}
+    enable_wine=${enable_wine:-no}
     dnl Disable dependencies that are not useful on Windows
     with_x=${with_x:-no}
     with_pthread=${with_pthread:-no}
@@ -2091,12 +2092,7 @@ fi
 
 dnl **** Platform-specific checks ****
 
-case "$HOST_ARCH,$PE_ARCHS" in
-  x86_64,*i386*) wine_binary="wine" ;;
-  x86_64,*) wine_binary="wine64" ;;
-  *) wine_binary="wine" ;;
-esac
-AC_SUBST(WINELOADER_PROGRAMS,"$wine_binary")
+AC_SUBST(WINELOADER_PROGRAMS,"wine")
 
 case $host_os in
   linux*)
@@ -2109,8 +2105,7 @@ esac
 
 if test "$wine_use_preloader" = "yes"
 then
-  test "$wine_binary" = wine || WINE_IGNORE_FILE(loader/wine-preloader)
-  WINELOADER_PROGRAMS="$WINELOADER_PROGRAMS $wine_binary-preloader"
+  WINELOADER_PROGRAMS="$WINELOADER_PROGRAMS wine-preloader"
   AC_DEFINE(HAVE_WINE_PRELOADER, 1, [Define to 1 if the Wine preloader is being used.])
 fi
 
@@ -2448,9 +2443,6 @@ test "x$enable_silent_rules" = xyes && makedep_flags="$makedep_flags -S"
 wine_srcdir=
 test "$srcdir" = . || wine_srcdir="$srcdir/"
 
-WINE_CONFIG_SYMLINK(wine,tools/winewrapper)
-WINE_CONFIG_SYMLINK(wine64,tools/winewrapper,["$wine_binary" = wine64 -o -n "$with_wine64"])
-
 WINE_CONFIG_MAKEFILE(dlls/acledit)
 WINE_CONFIG_MAKEFILE(dlls/aclui)
 WINE_CONFIG_MAKEFILE(dlls/activeds.tlb)
@@ -3648,6 +3640,7 @@ WINE_CONFIG_MAKEFILE(server)
 WINE_CONFIG_MAKEFILE(tools,,[test "x$enable_tools" = xno])
 WINE_CONFIG_MAKEFILE(tools/sfnt2fon,,[test "x$enable_tools" = xno])
 WINE_CONFIG_MAKEFILE(tools/widl,,[test "x$enable_tools" = xno])
+WINE_CONFIG_MAKEFILE(tools/wine,,[test "x$enable_tools" = xno])
 WINE_CONFIG_MAKEFILE(tools/winebuild,,[test "x$enable_tools" = xno])
 WINE_CONFIG_MAKEFILE(tools/winedump,,[test "x$enable_tools" = xno])
 WINE_CONFIG_MAKEFILE(tools/winegcc,,[test "x$enable_tools" = xno])
@@ -3666,7 +3659,7 @@ WINE_IGNORE_FILE(config.log)
 WINE_IGNORE_FILE(config.status)
 WINE_IGNORE_FILE(include/config.h)
 WINE_IGNORE_FILE(include/stamp-h)
-test "$wine_binary" = wine || WINE_IGNORE_FILE(loader/wine)
+WINE_IGNORE_FILE(loader-wow64)
 
 if test "x$enable_tools" != xno
 then
@@ -3711,9 +3704,7 @@ AC_SUBST(SHELL,[/bin/sh])
 dnl Rules for re-running configure
 
 WINE_APPEND_RULE(
-[all: wine
-	@echo \"Wine build complete.\"
-Makefile: config.status
+[Makefile: config.status
 	@./config.status Makefile
 config.status: ${wine_srcdir}configure
 	@./config.status --recheck
@@ -3736,22 +3727,16 @@ dnl Rules for wineloader
 
 if test -n "$with_wine64"
 then
-    case "$with_wine64" in
-      /*) reldir="" ;;
-      *)  reldir="../" ;;
-    esac
     dnl Get rid of old symlinks
     rm -f fonts server 2>/dev/null
     WINE_APPEND_RULE(
-[all: loader/wine64 loader/wine64-preloader $with_wine64/loader/wine $with_wine64/loader/wine-preloader
-loader/wine64 loader/wine64-preloader:
-	rm -f \$[@] && \$(LN_S) $reldir$with_wine64/\$[@] \$[@]
-$with_wine64/loader/wine:
-	rm -f \$[@] && \$(LN_S) $ac_pwd/loader/wine \$[@]
-$with_wine64/loader/wine-preloader:
-	rm -f \$[@] && \$(LN_S) $ac_pwd/loader/wine-preloader \$[@]
+[all: loader-wow64 $with_wine64/loader-wow64
+loader-wow64:
+	rm -f \$[@] && \$(LN_S) $with_wine64/loader \$[@]
+$with_wine64/loader-wow64:
+	rm -f \$[@] && \$(LN_S) $ac_pwd/loader \$[@]
 clean::
-	rm -f loader/wine64 loader/wine64-preloader $with_wine64/loader/wine $with_wine64/loader/wine-preloader])
+	rm -f loader-wow64 $with_wine64/loader-wow64])
 else
     TOP_INSTALL_DEV="$TOP_INSTALL_DEV include"
     TOP_INSTALL_LIB="$TOP_INSTALL_LIB \
diff --git a/dlls/dbghelp/dbghelp_private.h b/dlls/dbghelp/dbghelp_private.h
index d16468dc07a..1249d02b666 100644
--- a/dlls/dbghelp/dbghelp_private.h
+++ b/dlls/dbghelp/dbghelp_private.h
@@ -822,7 +822,7 @@ extern void         module_reset_debug_info(struct module* module);
 extern BOOL         module_remove(struct process* pcs,
                                   struct module* module);
 extern void         module_set_module(struct module* module, const WCHAR* name);
-extern WCHAR*       get_wine_loader_name(struct process *pcs) __WINE_DEALLOC(HeapFree, 3) __WINE_MALLOC;
+extern const WCHAR *get_wine_loader_name(struct process *pcs);
 extern BOOL         module_is_wine_host(const WCHAR* module_name, const WCHAR* ext);
 extern BOOL         module_refresh_list(struct process *pcs);
 
diff --git a/dlls/dbghelp/elf_module.c b/dlls/dbghelp/elf_module.c
index a62a36f32f6..b1513c1ac8c 100644
--- a/dlls/dbghelp/elf_module.c
+++ b/dlls/dbghelp/elf_module.c
@@ -1830,15 +1830,11 @@ BOOL elf_read_wine_loader_dbg_info(struct process* pcs, ULONG_PTR addr)
 {
     struct elf_info     elf_info;
     BOOL ret = FALSE;
-    WCHAR* loader;
+    const WCHAR *loader;
 
     elf_info.flags = ELF_INFO_DEBUG_HEADER | ELF_INFO_MODULE;
     loader = get_wine_loader_name(pcs);
-    if (loader)
-    {
-        ret = elf_search_and_load_file(pcs, loader, addr, 0, &elf_info);
-        HeapFree(GetProcessHeap(), 0, loader);
-    }
+    if (loader) ret = elf_search_and_load_file(pcs, loader, addr, 0, &elf_info);
     if (!ret || !elf_info.dbg_hdr_addr) return FALSE;
     if (elf_info.dbg_hdr_addr != (ULONG_PTR)elf_info.dbg_hdr_addr)
     {
diff --git a/dlls/dbghelp/macho_module.c b/dlls/dbghelp/macho_module.c
index 2b1f35c4d78..152dd16284f 100644
--- a/dlls/dbghelp/macho_module.c
+++ b/dlls/dbghelp/macho_module.c
@@ -1949,12 +1949,8 @@ static BOOL macho_search_loader(struct process* pcs, struct macho_info* macho_in
 
     if (!ret)
     {
-        WCHAR* loader = get_wine_loader_name(pcs);
-        if (loader)
-        {
-            ret = macho_search_and_load_file(pcs, loader, 0, macho_info);
-            HeapFree(GetProcessHeap(), 0, loader);
-        }
+        const WCHAR *loader = get_wine_loader_name(pcs);
+        if (loader) ret = macho_search_and_load_file(pcs, loader, 0, macho_info);
     }
     return ret;
 }
diff --git a/dlls/dbghelp/module.c b/dlls/dbghelp/module.c
index 79a0de42a81..3f009b6b1ef 100644
--- a/dlls/dbghelp/module.c
+++ b/dlls/dbghelp/module.c
@@ -84,33 +84,8 @@ static const WCHAR* get_filename(const WCHAR* name, const WCHAR* endptr)
 static BOOL is_wine_loader(const WCHAR *module)
 {
     const WCHAR *filename = get_filename(module, NULL);
-    const char *ptr;
-    BOOL ret = FALSE;
-    WCHAR *buffer;
-    DWORD len;
-
-    if ((ptr = getenv("WINELOADER")))
-    {
-        ptr = file_nameA(ptr);
-        len = 2 + MultiByteToWideChar( CP_UNIXCP, 0, ptr, -1, NULL, 0 );
-        buffer = heap_alloc( len * sizeof(WCHAR) );
-        MultiByteToWideChar( CP_UNIXCP, 0, ptr, -1, buffer, len );
-    }
-    else
-    {
-        buffer = heap_alloc( sizeof(L"wine") + 2 * sizeof(WCHAR) );
-        lstrcpyW( buffer, L"wine" );
-    }
-
-    if (!wcscmp( filename, buffer ))
-        ret = TRUE;
-
-    lstrcatW( buffer, L"64" );
-    if (!wcscmp( filename, buffer ))
-        ret = TRUE;
 
-    heap_free( buffer );
-    return ret;
+    return !wcscmp( filename, L"wine" );
 }
 
 static void module_fill_module(const WCHAR* in, WCHAR* out, size_t size)
@@ -135,40 +110,9 @@ void module_set_module(struct module* module, const WCHAR* name)
     module_fill_module(name, module->modulename, ARRAY_SIZE(module->modulename));
 }
 
-/* Returned string must be freed by caller */
-WCHAR *get_wine_loader_name(struct process *pcs)
+const WCHAR *get_wine_loader_name(struct process *pcs)
 {
-    const WCHAR *name;
-    WCHAR* altname;
-    unsigned len;
-
-    name = process_getenv(pcs, L"WINELOADER");
-    if (!name) name = pcs->is_host_64bit ? L"wine64" : L"wine";
-    len = lstrlenW(name);
-
-    /* WINELOADER isn't properly updated in Wow64 process calling inside Windows env block
-     * (it's updated in ELF env block though)
-     * So do the adaptation ourselves.
-     */
-    altname = HeapAlloc(GetProcessHeap(), 0, (len + 2 + 1) * sizeof(WCHAR));
-    if (altname)
-    {
-        memcpy(altname, name, len * sizeof(WCHAR));
-        if (pcs->is_host_64bit && len >= 2 && memcmp(name + len - 2, L"64", 2 * sizeof(WCHAR)) != 0)
-        {
-            lstrcpyW(altname + len, L"64");
-            /* in multi-arch wow configuration, wine64 doesn't exist */
-            if (GetFileAttributesW(altname) == INVALID_FILE_ATTRIBUTES)
-                altname[len] = L'\0';
-        }
-        else if (!pcs->is_host_64bit && len >= 2 && !memcmp(name + len - 2, L"64", 2 * sizeof(WCHAR)))
-            altname[len - 2] = '\0';
-        else
-            altname[len] = '\0';
-    }
-
-    TRACE("returning %s\n", debugstr_w(altname));
-    return altname;
+    return process_getenv(pcs, L"WINELOADER");
 }
 
 static const char*      get_module_type(struct module* module)
diff --git a/dlls/ntdll/unix/env.c b/dlls/ntdll/unix/env.c
index 6d27e9caa02..112a8a1d94a 100644
--- a/dlls/ntdll/unix/env.c
+++ b/dlls/ntdll/unix/env.c
@@ -1105,7 +1105,6 @@ static void add_system_dll_path_var( WCHAR **env, SIZE_T *pos, SIZE_T *size )
 static void add_dynamic_environment( WCHAR **env, SIZE_T *pos, SIZE_T *size )
 {
     const char *overrides = getenv( "WINEDLLOVERRIDES" );
-    const char *wineloader = getenv( "WINELOADER" );
     const char *var;
     unsigned int i;
     char str[22];
@@ -1114,6 +1113,7 @@ static void add_dynamic_environment( WCHAR **env, SIZE_T *pos, SIZE_T *size )
     add_path_var( env, pos, size, "WINEHOMEDIR", home_dir );
     add_path_var( env, pos, size, "WINEBUILDDIR", build_dir );
     add_path_var( env, pos, size, "WINECONFIGDIR", config_dir );
+    add_path_var( env, pos, size, "WINELOADER", wineloader );
     for (i = 0; dll_paths[i]; i++)
     {
         snprintf( str, sizeof(str), "WINEDLLDIR%u", i );
@@ -1122,7 +1122,6 @@ static void add_dynamic_environment( WCHAR **env, SIZE_T *pos, SIZE_T *size )
     snprintf( str, sizeof(str), "WINEDLLDIR%u", i );
     append_envW( env, pos, size, str, NULL );
     add_system_dll_path_var( env, pos, size );
-    append_envA( env, pos, size, "WINELOADER", wineloader );
     append_envA( env, pos, size, "WINEUSERNAME", user_name );
     append_envA( env, pos, size, "WINEDLLOVERRIDES", overrides );
     if (unix_cp.CodePage != CP_UTF8)
@@ -1684,18 +1683,9 @@ static void run_wineboot( WCHAR *env, SIZE_T size )
 
     wine_server_fd_to_handle( 2, GENERIC_WRITE | SYNCHRONIZE, OBJ_INHERIT, &params.hStdError );
 
-    if (NtCurrentTeb64() && !NtCurrentTeb64()->TlsSlots[WOW64_TLS_FILESYSREDIR])
-    {
-        NtCurrentTeb64()->TlsSlots[WOW64_TLS_FILESYSREDIR] = TRUE;
-        status = NtCreateUserProcess( &process, &thread, PROCESS_ALL_ACCESS, THREAD_ALL_ACCESS,
-                                      NULL, NULL, 0, THREAD_CREATE_FLAGS_CREATE_SUSPENDED, &params,
-                                      &create_info, &ps_attr );
-        NtCurrentTeb64()->TlsSlots[WOW64_TLS_FILESYSREDIR] = FALSE;
-    }
-    else
-        status = NtCreateUserProcess( &process, &thread, PROCESS_ALL_ACCESS, THREAD_ALL_ACCESS,
-                                      NULL, NULL, 0, THREAD_CREATE_FLAGS_CREATE_SUSPENDED, &params,
-                                      &create_info, &ps_attr );
+    status = NtCreateUserProcess( &process, &thread, PROCESS_ALL_ACCESS, THREAD_ALL_ACCESS,
+                                  NULL, NULL, 0, THREAD_CREATE_FLAGS_CREATE_SUSPENDED, &params,
+                                  &create_info, &ps_attr );
     NtClose( params.hStdError );
 
     if (status)
@@ -1985,6 +1975,8 @@ static RTL_USER_PROCESS_PARAMETERS *build_initial_params( void **module )
     WCHAR *curdir = get_initial_directory();
     NTSTATUS status;
 
+    if (NtCurrentTeb64()) NtCurrentTeb64()->TlsSlots[WOW64_TLS_FILESYSREDIR] = TRUE;
+
     /* store the initial PATH value */
     path = get_env_var( env, env_pos, pathW, 4 );
     add_dynamic_environment( &env, &env_pos, &env_size );
@@ -2005,7 +1997,7 @@ static RTL_USER_PROCESS_PARAMETERS *build_initial_params( void **module )
     env[env_pos++] = 0;
 
     status = load_main_exe( NULL, main_argv[1], curdir, 0, &image, module );
-    if (!status)
+    if (NT_SUCCESS(status))
     {
         char *loader;
 
@@ -2026,7 +2018,11 @@ static RTL_USER_PROCESS_PARAMETERS *build_initial_params( void **module )
         load_start_exe( &image, module );
         prepend_argv( args, 2 );
     }
-    else rebuild_argv();
+    else
+    {
+        rebuild_argv();
+        if (NtCurrentTeb64()) NtCurrentTeb64()->TlsSlots[WOW64_TLS_FILESYSREDIR] = FALSE;
+    }
 
     main_wargv = build_wargv( get_dos_path( image ));
     cmdline = build_command_line( main_wargv );
diff --git a/dlls/ntdll/unix/loader.c b/dlls/ntdll/unix/loader.c
index 2b0037e39eb..b30ebe594af 100644
--- a/dlls/ntdll/unix/loader.c
+++ b/dlls/ntdll/unix/loader.c
@@ -98,18 +98,6 @@
 
 WINE_DEFAULT_DEBUG_CHANNEL(module);
 
-#ifdef __i386__
-static const char so_dir[] = "/i386-unix";
-#elif defined(__x86_64__)
-static const char so_dir[] = "/x86_64-unix";
-#elif defined(__arm__)
-static const char so_dir[] = "/arm-unix";
-#elif defined(__aarch64__)
-static const char so_dir[] = "/aarch64-unix";
-#else
-static const char so_dir[] = "";
-#endif
-
 void *pDbgUiRemoteBreakin = NULL;
 void *pKiRaiseUserExceptionDispatcher = NULL;
 void *pKiUserExceptionDispatcher = NULL;
@@ -155,13 +143,14 @@ static void fatal_error( const char *err, ... ) __attribute__((noreturn, format(
 static const char *bin_dir;
 static const char *dll_dir;
 static const char *ntdll_dir;
-static const char *wineloader;
+static const char *alt_build_dir;
 static SIZE_T dll_path_maxlen;
 
 const char *home_dir = NULL;
 const char *data_dir = NULL;
 const char *build_dir = NULL;
 const char *config_dir = NULL;
+const char *wineloader = NULL;
 const char **dll_paths = NULL;
 const char **system_dll_paths = NULL;
 const char *user_name = NULL;
@@ -356,10 +345,20 @@ static int build_path_and_exec( pid_t *pid, const char *dir, const char *name, c
 }
 
 
-static const char *get_pe_dir( WORD machine )
+static const char *get_so_dir( WORD machine )
 {
-    if (!machine) machine = current_machine;
+    switch (machine)
+    {
+    case IMAGE_FILE_MACHINE_I386:  return "/i386-unix";
+    case IMAGE_FILE_MACHINE_AMD64: return "/x86_64-unix";
+    case IMAGE_FILE_MACHINE_ARMNT: return "/arm-unix";
+    case IMAGE_FILE_MACHINE_ARM64: return "/aarch64-unix";
+    default: return "";
+    }
+}
 
+static const char *get_pe_dir( WORD machine )
+{
     switch(machine)
     {
     case IMAGE_FILE_MACHINE_I386:  return "/i386-windows";
@@ -370,6 +369,17 @@ static const char *get_pe_dir( WORD machine )
     }
 }
 
+static WORD get_alt_machine( WORD machine )
+{
+    switch (machine)
+    {
+    case IMAGE_FILE_MACHINE_I386:  return IMAGE_FILE_MACHINE_AMD64;
+    case IMAGE_FILE_MACHINE_AMD64: return IMAGE_FILE_MACHINE_I386;
+    case IMAGE_FILE_MACHINE_ARMNT: return IMAGE_FILE_MACHINE_ARM64;
+    case IMAGE_FILE_MACHINE_ARM64: return IMAGE_FILE_MACHINE_ARMNT;
+    default: return machine;
+    }
+}
 
 static void set_dll_path(void)
 {
@@ -501,46 +511,26 @@ static void set_config_dir(void)
     }
 }
 
-static void init_paths( char *argv[] )
+static void init_paths(void)
 {
     Dl_info info;
-    char *basename, *env;
-
-    if ((basename = strrchr( argv[0], '/' ))) basename++;
-    else basename = argv[0];
 
     if (!dladdr( init_paths, &info ) || !(ntdll_dir = realpath_dirname( info.dli_fname )))
         fatal_error( "cannot get path to ntdll.so\n" );
 
-    if (!(build_dir = remove_tail( ntdll_dir, "/dlls/ntdll" )))
+    if ((build_dir = remove_tail( ntdll_dir, "/dlls/ntdll" )))
     {
-        if (!(dll_dir = remove_tail( ntdll_dir, so_dir ))) dll_dir = ntdll_dir;
-#if (defined(__linux__) && !defined(__ANDROID__)) || defined(__FreeBSD_kernel__) || defined(__NetBSD__)
-        bin_dir = realpath_dirname( "/proc/self/exe" );
-#elif defined (__FreeBSD__) || defined(__DragonFly__)
-        {
-            static int pathname[] = { CTL_KERN, KERN_PROC, KERN_PROC_PATHNAME, -1 };
-            size_t path_size = PATH_MAX;
-            char *path = malloc( path_size );
-            if (path && !sysctl( pathname, ARRAY_SIZE(pathname), path, &path_size, NULL, 0 ))
-                bin_dir = realpath_dirname( path );
-            free( path );
-        }
-#endif
-        if (!bin_dir) bin_dir = build_relative_path( dll_dir, LIBDIR "/wine", BINDIR );
-        data_dir = build_relative_path( bin_dir, BINDIR, DATADIR "/wine" );
-        wineloader = build_path( bin_dir, basename );
+        wineloader = build_path( build_dir, "loader/wine" );
+        alt_build_dir = realpath_dirname( build_path( build_dir, "loader-wow64" ));
     }
     else
     {
-        char *dirname = build_path( build_dir, "loader" );
-        wineloader = build_path( dirname, basename );
-        free(dirname);
+        if (!(dll_dir = remove_tail( ntdll_dir, get_so_dir(current_machine) ))) dll_dir = ntdll_dir;
+        bin_dir = build_relative_path( dll_dir, LIBDIR "/wine", BINDIR );
+        data_dir = build_relative_path( dll_dir, LIBDIR "/wine", DATADIR "/wine" );
+        wineloader = build_path( ntdll_dir, "wine" );
     }
 
-    asprintf( &env, "WINELOADER=%s", wineloader );
-    putenv( env );
-
     set_dll_path();
     set_system_dll_path();
     set_home_dir();
@@ -553,42 +543,34 @@ static void init_paths( char *argv[] )
  */
 char *get_alternate_wineloader( WORD machine )
 {
+    const char *arch;
+    BOOL force_wow64 = (arch = getenv( "WINEARCH" )) && !strcmp( arch, "wow64" );
     char *ret = NULL;
 
-    if (machine == current_machine) return NULL;
-
-    /* try the 64-bit loader */
-    if (current_machine == IMAGE_FILE_MACHINE_I386 && machine == IMAGE_FILE_MACHINE_AMD64)
+    if (is_win64)
     {
-        size_t len = strlen(wineloader);
-
-        if (len <= 2 || strcmp( wineloader + len - 2, "64" ))
-        {
-            ret = malloc( len + 3 );
-            strcpy( ret, wineloader );
-            strcat( ret, "64" );
-        }
-        return ret;
+        if (force_wow64) return NULL;
+        if (machine != get_alt_machine( current_machine )) return NULL;
     }
+    else
+    {
+        if (!force_wow64 && machine == current_machine) return NULL;
+        machine = get_alt_machine( current_machine );
+    }
+
+    if (!build_dir)
+        asprintf( &ret, "%s%s/wine", dll_dir, get_so_dir( machine ));
+    else if (alt_build_dir)
+        asprintf( &ret, "%s/loader/wine", alt_build_dir );
 
-    return remove_tail( wineloader, "64" );
+    return ret;
 }
 
 
 static void preloader_exec( char **argv )
 {
 #ifdef HAVE_WINE_PRELOADER
-    static const char *preloader = "wine-preloader";
-    char *p;
-
-    if (!(p = strrchr( argv[1], '/' ))) p = argv[1];
-    else p++;
-
-    if (strlen(p) > 2 && !strcmp( p + strlen(p) - 2, "64" )) preloader = "wine64-preloader";
-    argv[0] = malloc( p - argv[1] + strlen(preloader) + 1 );
-    memcpy( argv[0], argv[1], p - argv[1] );
-    strcpy( argv[0] + (p - argv[1]), preloader );
-
+    asprintf( &argv[0], "%s-preloader", argv[1] );
 #ifdef __APPLE__
     {
         posix_spawnattr_t attr;
@@ -688,15 +670,11 @@ static int exec_wineserver( pid_t *pid, char **argv )
 {
     char *path;
 
+    if (!is_win64 && alt_build_dir)  /* look for 64-bit server */
+        return build_path_and_exec( pid, alt_build_dir, "server/wineserver", argv );
+
     if (build_dir)
-    {
-        if (!is_win64)  /* look for 64-bit server */
-        {
-            char *loader = realpath_dirname( build_path( build_dir, "loader/wine64" ));
-            if (loader && !build_path_and_exec( pid, loader, "../server/wineserver", argv )) return 0;
-        }
         return build_path_and_exec( pid, build_dir, "server/wineserver", argv );
-    }
 
     if (!build_path_and_exec( pid, bin_dir, "wineserver", argv )) return 0;
     if ((path = getenv( "WINESERVER" )) && !build_path_and_exec( pid, "", path, argv )) return 0;
@@ -1361,7 +1339,7 @@ static inline char *prepend( char *buffer, const char *str, size_t len )
 }
 
 static inline char *prepend_build_dir_path( char *ptr, const char *ext, const char *arch_dir,
-                                            const char *top_dir )
+                                            const char *top_dir, const char *build_dir )
 {
     char *name = ptr;
     unsigned int namelen = strlen(name), extlen = strlen(ext);
@@ -1475,6 +1453,8 @@ static NTSTATUS find_builtin_dll( UNICODE_STRING *nt_name, void **module, SIZE_T
     unsigned int len = nt_name->Length / sizeof(WCHAR);
     char *ptr = NULL, *file, *ext = NULL;
     const char *pe_dir = get_pe_dir( search_machine );
+    const char *so_dir = get_so_dir( current_machine );
+    const char *pe_build_dir = build_dir;
     OBJECT_ATTRIBUTES attr;
     NTSTATUS status = STATUS_DLL_NOT_FOUND;
     BOOL found_image = FALSE;
@@ -1486,7 +1466,12 @@ static NTSTATUS find_builtin_dll( UNICODE_STRING *nt_name, void **module, SIZE_T
     if (!len) return STATUS_DLL_NOT_FOUND;
     InitializeObjectAttributes( &attr, nt_name, 0, 0, NULL );
 
-    if (build_dir) maxlen = strlen(build_dir) + sizeof("/programs/") + len;
+    if (build_dir)
+    {
+        if (alt_build_dir && search_machine == get_alt_machine( current_machine ))
+            pe_build_dir = alt_build_dir;
+        maxlen = max( strlen(build_dir), strlen(pe_build_dir) ) + sizeof("/programs/") + len;
+    }
     maxlen = max( maxlen, dll_path_maxlen + 1 ) + len + sizeof("/aarch64-windows") + sizeof(".so");
 
     if (!(file = malloc( maxlen ))) return STATUS_NO_MEMORY;
@@ -1506,10 +1491,10 @@ static NTSTATUS find_builtin_dll( UNICODE_STRING *nt_name, void **module, SIZE_T
     {
         /* try as a dll */
         file[pos + len + 1] = 0;
-        ptr = prepend_build_dir_path( file + pos, ".dll", pe_dir, "/dlls" );
+        ptr = prepend_build_dir_path( file + pos, ".dll", pe_dir, "/dlls", pe_build_dir );
         status = open_builtin_pe_file( ptr, &attr, module, size_ptr, image_info,
                                        limit_low, limit_high, load_machine, prefer_native );
-        ptr = prepend_build_dir_path( file + pos, ".dll", "", "/dlls" );
+        ptr = prepend_build_dir_path( file + pos, ".dll", "", "/dlls", build_dir );
         if (status != STATUS_DLL_NOT_FOUND) goto done;
         if (try_so)
         {
@@ -1520,10 +1505,10 @@ static NTSTATUS find_builtin_dll( UNICODE_STRING *nt_name, void **module, SIZE_T
 
         /* now as a program */
         file[pos + len + 1] = 0;
-        ptr = prepend_build_dir_path( file + pos, ".exe", pe_dir, "/programs" );
+        ptr = prepend_build_dir_path( file + pos, ".exe", pe_dir, "/programs", pe_build_dir );
         status = open_builtin_pe_file( ptr, &attr, module, size_ptr, image_info,
                                        limit_low, limit_high, load_machine, prefer_native );
-        ptr = prepend_build_dir_path( file + pos, ".exe", "", "/programs" );
+        ptr = prepend_build_dir_path( file + pos, ".exe", "", "/programs", build_dir );
         if (status != STATUS_DLL_NOT_FOUND) goto done;
         if (try_so)
         {
@@ -2394,7 +2379,7 @@ static jstring wine_init_jni( JNIEnv *env, jobject obj, jobjectArray cmdline, jo
     main_argc = argc;
     main_argv = argv;
 
-    init_paths( argv );
+    init_paths();
     virtual_init();
     init_environment();
 
@@ -2553,6 +2538,35 @@ static int pre_exec(void)
 #endif
 
 
+static void reexec_loader( int argc, char *argv[], char *extra_arg )
+{
+    static char noexec[] = "WINELOADERNOEXEC=1";
+    WORD machine = current_machine;
+    char **new_argv;
+
+    /* have to exec if we have a preloader, or an argument, or if we are the initial wrapper */
+    if (!pre_exec() && !extra_arg && dlsym( RTLD_DEFAULT, "wine_main_preload_info" )) return;
+
+    if (extra_arg)
+    {
+        new_argv = malloc( (argc + 3) * sizeof(*argv) );
+        memcpy( new_argv + 3, argv + 1, argc * sizeof(*argv) );
+        new_argv[2] = extra_arg;
+    }
+    else
+    {
+        new_argv = malloc( (argc + 2) * sizeof(*argv) );
+        memcpy( new_argv + 2, argv + 1, argc * sizeof(*argv) );
+    }
+
+    /* default to 32-bit loader to support 32-bit prefixes */
+    if (machine == IMAGE_FILE_MACHINE_AMD64) machine = IMAGE_FILE_MACHINE_I386;
+
+    putenv( noexec );
+    loader_exec( new_argv, machine );
+    fatal_error( "could not exec the wine loader\n" );
+}
+
 /***********************************************************************
  *           check_command_line
  *
@@ -2560,11 +2574,37 @@ static int pre_exec(void)
  */
 static void check_command_line( int argc, char *argv[] )
 {
+    char *basename;
     static const char usage[] =
         "Usage: wine PROGRAM [ARGUMENTS...]   Run the specified program\n"
         "       wine --help                   Display this help and exit\n"
         "       wine --version                Output version information and exit";
 
+    if ((basename = strrchr( argv[0], '/' ))) basename++;
+    else basename = argv[0];
+
+    if (strcmp( basename, "wine" )) /* check if there's a builtin exe corresponding to the base name */
+    {
+        const char *pe_dir = get_pe_dir( current_machine );
+        char *exe;
+
+        if (build_dir)
+        {
+            asprintf( &exe, "%s/programs/%s%s/%s.exe", build_dir, basename, pe_dir, basename );
+            if (!access( exe, R_OK )) reexec_loader( argc, argv, basename );
+            free( exe );
+        }
+        else
+        {
+            for (int i = 0; dll_paths[i]; i++)
+            {
+                asprintf( &exe, "%s%s/%s.exe", dll_paths[i], pe_dir, basename );
+                if (!access( exe, R_OK )) reexec_loader( argc, argv, basename );
+                free( exe );
+            }
+        }
+    }
+
     if (argc <= 1)
     {
         fprintf( stderr, "%s\n", usage );
@@ -2580,6 +2620,8 @@ static void check_command_line( int argc, char *argv[] )
         printf( "%s\n", wine_build );
         exit(0);
     }
+
+    reexec_loader( argc, argv, NULL );
 }
 
 
@@ -2593,22 +2635,8 @@ DECLSPEC_EXPORT void __wine_main( int argc, char *argv[] )
     main_argc = argc;
     main_argv = argv;
 
-    init_paths( argv );
-
-    if (!getenv( "WINELOADERNOEXEC" ))  /* first time around */
-    {
-        check_command_line( argc, argv );
-        if (pre_exec())
-        {
-            static char noexec[] = "WINELOADERNOEXEC=1";
-            char **new_argv = malloc( (argc + 2) * sizeof(*argv) );
-
-            memcpy( new_argv + 1, argv, (argc + 1) * sizeof(*argv) );
-            putenv( noexec );
-            loader_exec( new_argv, current_machine );
-            fatal_error( "could not exec the wine loader\n" );
-        }
-    }
+    init_paths();
+    if (!getenv( "WINELOADERNOEXEC" ) || argc <= 1) check_command_line( argc, argv );
 
 #ifdef RLIMIT_NOFILE
     set_max_limit( RLIMIT_NOFILE );
diff --git a/dlls/ntdll/unix/server.c b/dlls/ntdll/unix/server.c
index ebdb52e79ca..53a7e19f77e 100644
--- a/dlls/ntdll/unix/server.c
+++ b/dlls/ntdll/unix/server.c
@@ -1635,8 +1635,8 @@ size_t server_init_process(void)
 
         if (is_win64 && arch && !strcmp( arch, "win32" ))
             fatal_error( "WINEARCH is set to 'win32' but this is not supported in wow64 mode.\n" );
-        if (arch && strcmp( arch, "win32" ) && strcmp( arch, "win64" ))
-            fatal_error( "WINEARCH set to invalid value '%s', it must be either win32 or win64.\n", arch );
+        if (arch && strcmp( arch, "win32" ) && strcmp( arch, "win64" ) && strcmp( arch, "wow64" ))
+            fatal_error( "WINEARCH set to invalid value '%s', it must be win32, win64, or wow64.\n", arch );
 
         fd_socket = server_connect();
     }
@@ -1728,8 +1728,8 @@ size_t server_init_process(void)
     {
         if (is_win64)
             fatal_error( "'%s' is a 32-bit installation, it cannot support 64-bit applications.\n", config_dir );
-        if (arch && !strcmp( arch, "win64" ))
-            fatal_error( "WINEARCH set to win64 but '%s' is a 32-bit installation.\n", config_dir );
+        if (arch && (!strcmp( arch, "win64" ) || !strcmp( arch, "wow64" )))
+            fatal_error( "WINEARCH set to %s but '%s' is a 32-bit installation.\n", arch, config_dir );
     }
 
     set_thread_id( NtCurrentTeb(), pid, tid );
diff --git a/dlls/ntdll/unix/unix_private.h b/dlls/ntdll/unix/unix_private.h
index 28b2f623052..3ec8bc69b99 100644
--- a/dlls/ntdll/unix/unix_private.h
+++ b/dlls/ntdll/unix/unix_private.h
@@ -167,6 +167,7 @@ extern const char *home_dir;
 extern const char *data_dir;
 extern const char *build_dir;
 extern const char *config_dir;
+extern const char *wineloader;
 extern const char *user_name;
 extern const char **dll_paths;
 extern const char **system_dll_paths;
diff --git a/loader/Makefile.in b/loader/Makefile.in
index 191ab81e1d2..a9ca82f3321 100644
--- a/loader/Makefile.in
+++ b/loader/Makefile.in
@@ -2,12 +2,8 @@ SOURCES = \
 	main.c \
 	preloader.c \
 	preloader_mac.c \
-	wine.de.UTF-8.man.in \
 	wine.desktop \
-	wine.fr.UTF-8.man.in \
 	wine.inf.in \
-	wine.man.in \
-	wine.pl.UTF-8.man.in \
 	wine_info.plist.in
 
 PROGRAMS = $(WINELOADER_PROGRAMS)
@@ -16,20 +12,10 @@ UNIX_CFLAGS = -fPIE
 
 preloader_EXTRADEFS = -fno-builtin
 
-main_EXTRADEFS = -DBINDIR=\"${bindir}\" -DLIBDIR=\"${libdir}\"
-
 wine_OBJS = main.o
 wine_DEPS = $(WINELOADER_DEPENDS)
 wine_LDFLAGS = $(WINELOADER_LDFLAGS) $(LDEXECFLAGS) $(PTHREAD_LIBS)
 
-wine64_OBJS = main.o
-wine64_DEPS = $(WINELOADER_DEPENDS)
-wine64_LDFLAGS = $(WINELOADER_LDFLAGS) $(LDEXECFLAGS) $(PTHREAD_LIBS)
-
 wine_preloader_OBJS = preloader.o preloader_mac.o
 wine_preloader_DEPS = $(WINELOADER_DEPENDS)
 wine_preloader_LDFLAGS = $(WINEPRELOADER_LDFLAGS)
-
-wine64_preloader_OBJS = preloader.o preloader_mac.o
-wine64_preloader_DEPS = $(WINELOADER_DEPENDS)
-wine64_preloader_LDFLAGS = $(WINEPRELOADER_LDFLAGS)
diff --git a/loader/main.c b/loader/main.c
index 2ba32ea5176..0bd675bcc75 100644
--- a/loader/main.c
+++ b/loader/main.c
@@ -124,44 +124,7 @@ static char *build_path( const char *dir, const char *name )
     return ret;
 }
 
-/* build a path with the relative dir from 'from' to 'dest' appended to base */
-static char *build_relative_path( const char *base, const char *from, const char *dest )
-{
-    const char *start;
-    char *ret;
-    unsigned int dotdots = 0;
-
-    for (;;)
-    {
-        while (*from == '/') from++;
-        while (*dest == '/') dest++;
-        start = dest;  /* save start of next path element */
-        if (!*from) break;
-
-        while (*from && *from != '/' && *from == *dest) { from++; dest++; }
-        if ((!*from || *from == '/') && (!*dest || *dest == '/')) continue;
-
-        do  /* count remaining elements in 'from' */
-        {
-            dotdots++;
-            while (*from && *from != '/') from++;
-            while (*from == '/') from++;
-        }
-        while (*from);
-        break;
-    }
-
-    ret = malloc( strlen(base) + 3 * dotdots + strlen(start) + 2 );
-    strcpy( ret, base );
-    while (dotdots--) strcat( ret, "/.." );
-
-    if (!start[0]) return ret;
-    strcat( ret, "/" );
-    strcat( ret, start );
-    return ret;
-}
-
-static const char *get_self_exe( char *argv0 )
+static const char *get_self_exe(void)
 {
 #if defined(__linux__) || defined(__FreeBSD_kernel__) || defined(__NetBSD__)
     return "/proc/self/exe";
@@ -173,77 +136,26 @@ static const char *get_self_exe( char *argv0 )
         return path;
     free( path );
 #endif
-
-    if (!strchr( argv0, '/' )) /* search in PATH */
-    {
-        char *p, *path = getenv( "PATH" );
-
-        if (!path || !(path = strdup(path))) return NULL;
-        for (p = strtok( path, ":" ); p; p = strtok( NULL, ":" ))
-        {
-            char *name = build_path( p, argv0 );
-            if (!access( name, X_OK ))
-            {
-                free( path );
-                return name;
-            }
-            free( name );
-        }
-        free( path );
-        return NULL;
-    }
-    return argv0;
-}
-
-static void *try_dlopen( const char *dir, const char *name )
-{
-    char *path = build_path( dir, name );
-    void *handle = dlopen( path, RTLD_NOW );
-    free( path );
-    return handle;
+    return NULL;
 }
 
-static void *load_ntdll( char *argv0 )
+static void *try_dlopen( const char *argv0 )
 {
-#ifdef __i386__
-#define SO_DIR "i386-unix/"
-#elif defined(__x86_64__)
-#define SO_DIR "x86_64-unix/"
-#elif defined(__arm__)
-#define SO_DIR "arm-unix/"
-#elif defined(__aarch64__)
-#define SO_DIR "aarch64-unix/"
-#else
-#define SO_DIR ""
-#endif
-    const char *self = get_self_exe( argv0 );
-    char *path, *p;
-    void *handle = NULL;
+    char *dir, *path, *p;
+    void *handle;
 
-    if (self && ((path = realpath_dirname( self ))))
-    {
-        if ((p = remove_tail( path, "/loader" )))
-            handle = try_dlopen( p, "dlls/ntdll/ntdll.so" );
-        else if ((p = build_relative_path( path, BINDIR, LIBDIR )))
-            handle = try_dlopen( p, "wine/" SO_DIR "ntdll.so" );
-        free( p );
-        free( path );
-    }
+    if (!argv0) return NULL;
+    if (!(dir = realpath_dirname( argv0 ))) return NULL;
 
-    if (!handle && (path = getenv( "WINEDLLPATH" )))
-    {
-        path = strdup( path );
-        for (p = strtok( path, ":" ); p; p = strtok( NULL, ":" ))
-        {
-            handle = try_dlopen( p, SO_DIR "ntdll.so" );
-            if (!handle) handle = try_dlopen( p, "ntdll.so" );
-            if (handle) break;
-        }
-        free( path );
-    }
-
-    if (!handle && !self) handle = try_dlopen( LIBDIR, "wine/" SO_DIR "ntdll.so" );
+    if ((p = remove_tail( dir, "/loader" )))
+        path = build_path( p, "dlls/ntdll/ntdll.so" );
+    else
+        path = build_path( dir, "ntdll.so" );
 
+    handle = dlopen( path, RTLD_NOW );
+    free( p );
+    free( dir );
+    free( path );
     return handle;
 }
 
@@ -257,7 +169,8 @@ int main( int argc, char *argv[] )
 
     init_reserved_areas();
 
-    if ((handle = load_ntdll( argv[0] )))
+    if ((handle = try_dlopen( get_self_exe() )) ||
+        (handle = try_dlopen( argv[0] )))
     {
         void (*init_func)(int, char **) = dlsym( handle, "__wine_main" );
         if (init_func) init_func( argc, argv );
diff --git a/tools/Makefile.in b/tools/Makefile.in
index 39dd237fa99..c79e56be475 100644
--- a/tools/Makefile.in
+++ b/tools/Makefile.in
@@ -5,8 +5,7 @@ PROGRAMS = \
 SOURCES = \
 	gdbinit.py.in \
 	make_xftmpl.c \
-	makedep.c \
-	wineapploader.in
+	makedep.c
 
 makedep_OBJS = makedep.o
 make_xftmpl_OBJS = make_xftmpl.o
diff --git a/tools/makedep.c b/tools/makedep.c
index 5847ba56869..08f9bfcd79a 100644
--- a/tools/makedep.c
+++ b/tools/makedep.c
@@ -2489,7 +2489,7 @@ static void output_symlink_rule( const char *src_name, const char *link_name, in
         dir[name - link_name] = 0;
     }
 
-    output( "\t%s", cmd_prefix( "LN" ));
+    output( "\t%s", create_dir ? "" : cmd_prefix( "LN" ));
     if (create_dir && dir && *dir) output( "%s -d %s && ", root_src_dir_path( "tools/install-sh" ), dir );
     output( "rm -f %s && ", link_name );
 
@@ -2571,10 +2571,6 @@ static void output_install_commands( struct makefile *make, struct strarray file
             output( "\t%s $(INSTALL_SCRIPT_FLAGS) %s %s\n",
                     install_sh, src_dir_path( make, file ), dest );
             break;
-        case 't':  /* script in tools dir */
-            output( "\t%s $(INSTALL_SCRIPT_FLAGS) %s %s\n",
-                    install_sh, tools_dir_path( make, files.str[i] ), dest );
-            break;
         case 'y':  /* symlink */
             output_symlink_rule( files.str[i], dest, 1 );
             break;
@@ -2612,9 +2608,6 @@ static void output_install_rules( struct makefile *make, enum install_rules rule
         case 's':  /* script */
             strarray_add_uniq( &targets, obj_dir_path( make, file ));
             break;
-        case 't':  /* script in tools dir */
-            strarray_add_uniq( &targets, tools_dir_path( make, file ));
-            break;
         }
     }
 
@@ -3764,7 +3757,7 @@ static void output_programs( struct makefile *make )
 
     for (i = 0; i < make->programs.count; i++)
     {
-        char *program_installed = NULL;
+        const char *install_dir;
         char *program = strmake( "%s%s", make->programs.str[i], exe_ext );
         struct strarray deps = get_local_dependencies( make, make->programs.str[i], make->in_files );
         struct strarray all_libs = get_expanded_file_local_var( make, make->programs.str[i], "LDFLAGS" );
@@ -3800,8 +3793,8 @@ static void output_programs( struct makefile *make )
         }
         strarray_addall( &make->all_targets[arch], symlinks );
 
-        add_install_rule( make, program, arch, program_installed ? program_installed : program,
-                          strmake( "p$(bindir)/%s", program ));
+        install_dir = !strcmp( make->obj_dir, "loader" ) ? arch_install_dirs[arch] : "$(bindir)/";
+        add_install_rule( make, program, arch, program, strmake( "p%s%s", install_dir, program ));
         for (j = 0; j < symlinks.count; j++)
             add_install_rule( make, symlinks.str[j], arch, program,
                               strmake( "y$(bindir)/%s%s", symlinks.str[j], exe_ext ));
@@ -4024,7 +4017,7 @@ static void output_sources( struct makefile *make )
         if (make->is_exe && !make->is_win16 && unix_lib_supported && strendswith( make->module, ".exe" ))
         {
             char *binary = replace_extension( make->module, ".exe", "" );
-            add_install_rule( make, binary, 0, "wineapploader", strmake( "t$(bindir)/%s", binary ));
+            add_install_rule( make, binary, 0, "wine", strmake( "y$(bindir)/%s", binary ));
         }
     }
     else if (make->testdll)
@@ -4415,6 +4408,13 @@ static void output_top_makefile( struct makefile *make )
             silent_rules ? " -S" : "" );
     strarray_add( &make->phony_targets, "depend" );
 
+    if (!strarray_exists( &disabled_dirs[0], "tools/wine" ))
+    {
+        output( "wine: %s\n", tools_path( make, "wine" ));
+        output( "\t%srm -f $@ && %s %s $@\n", cmd_prefix( "LN" ), ln_s, tools_path( make, "wine" ));
+        strarray_add( &make->all_targets[0], "wine" );
+    }
+
     for (i = 0; i < subdirs.count; i++) output_sources( submakes[i] );
     output_sources( make );
 
diff --git a/tools/wine/Makefile.in b/tools/wine/Makefile.in
new file mode 100644
index 00000000000..55489a3444a
--- /dev/null
+++ b/tools/wine/Makefile.in
@@ -0,0 +1,12 @@
+PROGRAMS = wine
+
+SOURCES = \
+	wine.c \
+	wine.de.UTF-8.man.in \
+	wine.fr.UTF-8.man.in \
+	wine.man.in \
+	wine.pl.UTF-8.man.in
+
+wine_EXTRADEFS = -DBINDIR="\"${bindir}\"" -DLIBDIR="\"${libdir}\""
+
+INSTALL_LIB = $(PROGRAMS)
diff --git a/tools/wine/wine.c b/tools/wine/wine.c
new file mode 100644
index 00000000000..32157dfd4bc
--- /dev/null
+++ b/tools/wine/wine.c
@@ -0,0 +1,67 @@
+/*
+ * Loader for Wine installed in the bin directory
+ *
+ * Copyright 2025 Alexandre Julliard
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#include "config.h"
+
+#include "../tools.h"
+
+#include <dlfcn.h>
+
+static const char *bindir;
+static const char *libdir;
+
+static void *load_ntdll(void)
+{
+    const char *arch_dir = get_arch_dir( get_default_target() );
+    struct strarray dllpath;
+    void *handle;
+    unsigned int i;
+
+    if (bindir && strendswith( bindir, "/tools/wine" ) &&
+        ((handle = dlopen( strmake( "%s/../../dlls/ntdll/ntdll.so", bindir ), RTLD_NOW ))))
+        return handle;
+
+    if ((handle = dlopen( strmake( "%s/wine%s/ntdll.so", libdir, arch_dir ), RTLD_NOW )))
+        return handle;
+
+    dllpath = strarray_frompath( getenv( "WINEDLLPATH" ));
+    for (i = 0; i < dllpath.count; i++)
+    {
+        if ((handle = dlopen( strmake( "%s%s/ntdll.so", dllpath.str[i], arch_dir ), RTLD_NOW )))
+            return handle;
+        if ((handle = dlopen( strmake( "%s/ntdll.so", dllpath.str[i] ), RTLD_NOW )))
+            return handle;
+    }
+    fprintf( stderr, "wine: could not load ntdll.so: %s\n", dlerror() );
+    exit(1);
+}
+
+int main( int argc, char *argv[] )
+{
+    void (*init_func)(int, char **);
+
+    bindir = get_bindir( argv[0] );
+    libdir = get_libdir( bindir );
+    init_func = dlsym( load_ntdll(), "__wine_main" );
+    if (init_func) init_func( argc, argv );
+
+    fprintf( stderr, "wine: __wine_main function not found in ntdll.so\n" );
+    exit(1);
+}
diff --git a/loader/wine.de.UTF-8.man.in b/tools/wine/wine.de.UTF-8.man.in
similarity index 97%
rename from loader/wine.de.UTF-8.man.in
rename to tools/wine/wine.de.UTF-8.man.in
index ea3786c69e0..b1d8d42cf92 100644
--- a/loader/wine.de.UTF-8.man.in
+++ b/tools/wine/wine.de.UTF-8.man.in
@@ -89,13 +89,6 @@ Gibt den Ort der
 .B wine
 in $PATH und anderen Orten nach wineserver.
 .TP
-.B WINELOADER
-Gibt den Ort der
-.B wine
--Anwendung an, die genutzt wird, um Windows-Programme zu laden. Wenn
-diese Variable nicht gesetzt ist, wird in $PATH und anderen Orten
-nach wine gesucht.
-.TP
 .B WINEDEBUG
 Wählt die Stufe der Debug-Meldungen aus. Die Variable hat das Format
 .RI [ Klasse ][+/-] Kanal [,[ Klasse2 ][+/-] Kanal2 ].
diff --git a/loader/wine.fr.UTF-8.man.in b/tools/wine/wine.fr.UTF-8.man.in
similarity index 97%
rename from loader/wine.fr.UTF-8.man.in
rename to tools/wine/wine.fr.UTF-8.man.in
index ef2e6a3008e..34722caa58e 100644
--- a/loader/wine.fr.UTF-8.man.in
+++ b/tools/wine/wine.fr.UTF-8.man.in
@@ -88,13 +88,6 @@ Si cette variable n'est pas définie, Wine essaiera de charger un
 fichier nommé « wineserver » dans le chemin système ou quelques autres
 emplacements potentiels.
 .TP
-.B WINELOADER
-Spécifie le chemin et le nom de l'exécutable
-.B wine
-à utiliser pour exécuter de nouveaux processus Windows. A défaut, Wine
-essaiera de charger un fichier nommé « wine » dans le chemin système
-ou quelques autres emplacements potentiels.
-.TP
 .B WINEDEBUG
 Active ou désactive les messages de débogage. La syntaxe est :
 .RI [ classe ][\fB+\fR|\fB-\fR] canal [,[ classe2 ][\fB+\fR|\fB-\fR] canal2 ]
diff --git a/loader/wine.man.in b/tools/wine/wine.man.in
similarity index 95%
rename from loader/wine.man.in
rename to tools/wine/wine.man.in
index f3de4217a93..ddc84e8345b 100644
--- a/loader/wine.man.in
+++ b/tools/wine/wine.man.in
@@ -88,13 +88,6 @@ Specifies the path and name of the
 binary. If not set, Wine will look for a file named "wineserver" in
 the path and in a few other likely locations.
 .TP
-.B WINELOADER
-Specifies the path and name of the
-.B wine
-binary to use to launch new Windows processes. If not set, Wine will
-look for a file named "wine" in the path and in a few other likely
-locations.
-.TP
 .B WINEDEBUG
 Turns debugging messages on or off. The syntax of the variable is
 of the form
@@ -210,17 +203,22 @@ registry key.
 .RE
 .TP
 .B WINEARCH
-Specifies the Windows architecture to support. It can be set either to
+Specifies the Windows architecture to support. It can be set to
 .B win32
-(support only 32-bit applications), or to
+(support only 32-bit applications), to
 .B win64
-(support both 64-bit applications and 32-bit ones in WoW64 mode).
+(support both 64-bit applications and 32-bit ones), or to
+.B wow64
+(support 64-bit applications and 32-bit ones, using a 64-bit host
+process in all cases).
 .br
 The architecture supported by a given Wine prefix is set at prefix
 creation time and cannot be changed afterwards. When running with an
 existing prefix, Wine will refuse to start if
 .B WINEARCH
-doesn't match the prefix architecture.
+doesn't match the prefix architecture. It is possible however to
+switch freely between \fBwin64\fR and \fBwow64\fR with an existing
+64-bit prefix.
 .TP
 .B WINE_D3D_CONFIG
 Specifies Direct3D configuration options. It can be used instead of
diff --git a/loader/wine.pl.UTF-8.man.in b/tools/wine/wine.pl.UTF-8.man.in
similarity index 97%
rename from loader/wine.pl.UTF-8.man.in
rename to tools/wine/wine.pl.UTF-8.man.in
index a66ae999190..712dd487d5c 100644
--- a/loader/wine.pl.UTF-8.man.in
+++ b/tools/wine/wine.pl.UTF-8.man.in
@@ -86,13 +86,6 @@ Określa ścieżkę i nazwę programu binarnego
 Jeżeli nie ustawione, Wine będzie szukał pliku o nazwie "wineserver" w
 podanej ścieżce i kilku innych miejscach prawdopodobnego występowania.
 .TP
-.B WINELOADER
-Określa ścieżkę i nazwę programu binarnego
-.B wine
-używanej do uruchamiania nowych procesów Windowsowych. Jeżeli
-nieustawione, Wine będzie szukał pliku o nazwie "wine" w podanej
-ścieżce i kilku innych miejscach prawdopodobnego występowania.
-.TP
 .B WINEDEBUG
 Włącza lub wyłącza wiadomości debuggera. Składnia zmiennej
 wygląda następująco
diff --git a/tools/wineapploader.in b/tools/wineapploader.in
deleted file mode 100755
index f48d5527a77..00000000000
--- a/tools/wineapploader.in
+++ /dev/null
@@ -1,64 +0,0 @@
-#!/bin/sh
-#
-# Wrapper script to start a Winelib application once it is installed
-#
-# Copyright (C) 2002 Alexandre Julliard
-#
-# This library is free software; you can redistribute it and/or
-# modify it under the terms of the GNU Lesser General Public
-# License as published by the Free Software Foundation; either
-# version 2.1 of the License, or (at your option) any later version.
-#
-# This library is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-# Lesser General Public License for more details.
-#
-# You should have received a copy of the GNU Lesser General Public
-# License along with this library; if not, write to the Free Software
-# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
-#
-
-# determine the app Winelib library name
-appname=`basename "$0" .exe`.exe
-
-# first try explicit WINELOADER
-if [ -x "$WINELOADER" ]; then exec "$WINELOADER" "$appname" "$@"; fi
-
-# now try the directory containing $0
-appdir=""
-case "$0" in
-  */*)
-    # $0 contains a path, use it
-    appdir=`dirname "$0"`
-    ;;
-  *)
-    # no directory in $0, search in PATH
-    saved_ifs=$IFS
-    IFS=:
-    for d in $PATH
-    do
-      IFS=$saved_ifs
-      if [ -x "$d/$0" ]; then appdir="$d"; break; fi
-    done
-    ;;
-esac
-if [ -x "$appdir/wine" ]; then exec "$appdir/wine" "$appname" "$@"; fi
-if [ -x "$appdir/wine64" ]; then exec "$appdir/wine64" "$appname" "$@"; fi
-
-# now look in PATH
-saved_ifs=$IFS
-IFS=:
-for d in $PATH
-do
-  IFS=$saved_ifs
-  if [ -x "$d/wine" ]; then exec "$d/wine" "$appname" "$@"; fi
-  if [ -x "$d/wine64" ]; then exec "$d/wine64" "$appname" "$@"; fi
-done
-
-# finally, the default bin directory
-if [ -x "@bindir@/wine" ]; then exec "@bindir@/wine" "$appname" "$@"; fi
-if [ -x "@bindir@/wine64" ]; then exec "@bindir@/wine64" "$appname" "$@"; fi
-
-echo "$0: the Wine loader is missing"
-exit 1
diff --git a/tools/winewrapper b/tools/winewrapper
deleted file mode 100755
index d6d1bc8f70a..00000000000
--- a/tools/winewrapper
+++ /dev/null
@@ -1,99 +0,0 @@
-#!/bin/sh
-#
-# Wrapper script to run Wine and Winelib apps from inside the source tree
-#
-# Copyright (C) 2002 Alexandre Julliard
-#
-# This library is free software; you can redistribute it and/or
-# modify it under the terms of the GNU Lesser General Public
-# License as published by the Free Software Foundation; either
-# version 2.1 of the License, or (at your option) any later version.
-#
-# This library is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-# Lesser General Public License for more details.
-#
-# You should have received a copy of the GNU Lesser General Public
-# License along with this library; if not, write to the Free Software
-# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
-#
-
-# first determine the directory that contains the app itself
-
-appdir=""
-name=$0
-
-case "$0" in
-  */*)
-    # $0 contains a path, use it
-    appdir=`dirname "$0"`
-    name=`basename "$0"`
-    ;;
-  *)
-    # no directory in $0, search in PATH
-    saved_ifs=$IFS
-    IFS=:
-    for d in $PATH
-    do
-      IFS=$saved_ifs
-      if [ -x "$d/$name" ]
-      then
-        appdir="$d"
-        break
-      fi
-    done
-    ;;
-esac
-
-# now find the top-level directory of the build tree
-
-if [ -x "$appdir/server/wineserver" ]
-then topdir="$appdir"
-elif [ -x "$appdir/../server/wineserver" ]
-then topdir="$appdir/.."
-elif [ -x "$appdir/../../server/wineserver" ]
-then topdir="$appdir/../.."
-elif [ -x "$appdir/../../../server/wineserver" ]
-then topdir="$appdir/../../.."
-else
-  echo "$name: could not locate the Wine build tree"
-  exit 1
-fi
-
-# setup the environment
-
-topdir=`cd "$topdir" && pwd`
-
-if [ "`uname -s`" = "Darwin" ]
-then
-  if [ -n "$DYLD_LIBRARY_PATH" ]
-  then
-    DYLD_LIBRARY_PATH="$topdir/dlls/ntdll:$topdir/dlls/win32u:$DYLD_LIBRARY_PATH"
-  else
-    DYLD_LIBRARY_PATH="$topdir/dlls/ntdll:$topdir/dlls/win32u"
-  fi
-  export DYLD_LIBRARY_PATH
-fi
-
-if [ -x "$topdir/loader/$name" ]
-then WINELOADER="$topdir/loader/$name"
-elif [ -x "$topdir/loader/wine" ]
-then WINELOADER="$topdir/loader/wine"
-elif [ -x "$topdir/loader/wine64" ]
-then WINELOADER="$topdir/loader/wine64"
-else
-  echo "$name: could not find the Wine loader in $topdir"
-  exit 1
-fi
-export WINELOADER
-
-# any local settings ?
-if [ -f "$topdir/.winewrapper" ]
-then
-    . $topdir/.winewrapper
-fi
-
-# and run the application
-
-exec "$WINELOADER" "$@"
