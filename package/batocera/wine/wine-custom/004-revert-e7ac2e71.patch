diff --git a/dlls/ntdll/loader.c b/dlls/ntdll/loader.c
index 33415b6dda8..5a582ca14bb 100644
--- a/dlls/ntdll/loader.c
+++ b/dlls/ntdll/loader.c
@@ -2120,8 +2120,7 @@ static NTSTATUS perform_relocations( void *module, IMAGE_NT_HEADERS *nt, SIZE_T
     const IMAGE_DATA_DIRECTORY *relocs;
     const IMAGE_SECTION_HEADER *sec;
     INT_PTR delta;
-    ULONG *protect_old, i;
-    NTSTATUS status = STATUS_SUCCESS;
+    ULONG protect_old[96], i;
 
     base = (char *)nt->OptionalHeader.ImageBase;
     if (module == base) return STATUS_SUCCESS;  /* nothing to do */
@@ -2146,9 +2145,8 @@ static NTSTATUS perform_relocations( void *module, IMAGE_NT_HEADERS *nt, SIZE_T
     if (!relocs->Size) return STATUS_SUCCESS;
     if (!relocs->VirtualAddress) return STATUS_CONFLICTING_ADDRESSES;
 
-    if (!(protect_old = RtlAllocateHeap( GetProcessHeap(), 0,
-                                         nt->FileHeader.NumberOfSections * sizeof(*protect_old ))))
-        return STATUS_NO_MEMORY;
+    if (nt->FileHeader.NumberOfSections > ARRAY_SIZE( protect_old ))
+        return STATUS_INVALID_IMAGE_FORMAT;
 
     sec = IMAGE_FIRST_SECTION( nt );
     for (i = 0; i < nt->FileHeader.NumberOfSections; i++)
@@ -2171,17 +2169,12 @@ static NTSTATUS perform_relocations( void *module, IMAGE_NT_HEADERS *nt, SIZE_T
         if (rel->VirtualAddress >= len)
         {
             WARN( "invalid address %p in relocation %p\n", get_rva( module, rel->VirtualAddress ), rel );
-            status = STATUS_ACCESS_VIOLATION;
-            goto done;
+            return STATUS_ACCESS_VIOLATION;
         }
         rel = LdrProcessRelocationBlock( get_rva( module, rel->VirtualAddress ),
                                          (rel->SizeOfBlock - sizeof(*rel)) / sizeof(USHORT),
                                          (USHORT *)(rel + 1), delta );
-        if (!rel)
-        {
-            status = STATUS_INVALID_IMAGE_FORMAT;
-            goto done;
-        }
+        if (!rel) return STATUS_INVALID_IMAGE_FORMAT;
     }
 
     for (i = 0; i < nt->FileHeader.NumberOfSections; i++)
@@ -2192,9 +2185,7 @@ static NTSTATUS perform_relocations( void *module, IMAGE_NT_HEADERS *nt, SIZE_T
                                 &size, protect_old[i], &protect_old[i] );
     }
 
-done:
-    RtlFreeHeap( GetProcessHeap(), 0, protect_old );
-    return status;
+    return STATUS_SUCCESS;
 }
 
 
@@ -2369,7 +2360,7 @@ static ULONG read_image_directory( HANDLE file, const SECTION_IMAGE_INFORMATION
     IMAGE_DOS_HEADER mz;
     IO_STATUS_BLOCK io;
     LARGE_INTEGER offset;
-    IMAGE_SECTION_HEADER *sec;
+    IMAGE_SECTION_HEADER sec[96];
     unsigned int i, count;
     DWORD va, size;
     union
@@ -2402,21 +2393,17 @@ static ULONG read_image_directory( HANDLE file, const SECTION_IMAGE_INFORMATION
     }
     if (!va) return 0;
     offset.QuadPart += offsetof( IMAGE_NT_HEADERS32, OptionalHeader ) + nt.nt32.FileHeader.SizeOfOptionalHeader;
-    count = nt.nt32.FileHeader.NumberOfSections;
-    if (!(sec = RtlAllocateHeap( GetProcessHeap(), 0, sizeof(*sec) * count ))) return 0;
-    if (NtReadFile( file, 0, NULL, NULL, &io, &sec, count * sizeof(*sec), &offset, NULL )) goto done;
-    if (io.Information != count * sizeof(*sec)) goto done;
+    count = min( 96, nt.nt32.FileHeader.NumberOfSections );
+    if (NtReadFile( file, 0, NULL, NULL, &io, &sec, count * sizeof(*sec), &offset, NULL )) return 0;
+    if (io.Information != count * sizeof(*sec)) return 0;
     for (i = 0; i < count; i++)
     {
         if (va < sec[i].VirtualAddress) continue;
         if (sec[i].Misc.VirtualSize && va - sec[i].VirtualAddress >= sec[i].Misc.VirtualSize) continue;
         offset.QuadPart = sec[i].PointerToRawData + va - sec[i].VirtualAddress;
-        if (NtReadFile( file, 0, NULL, NULL, &io, buffer, min( maxlen, size ), &offset, NULL )) goto done;
-        RtlFreeHeap( GetProcessHeap(), 0, sec );
+        if (NtReadFile( file, 0, NULL, NULL, &io, buffer, min( maxlen, size ), &offset, NULL )) return 0;
         return io.Information;
     }
-done:
-    RtlFreeHeap( GetProcessHeap(), 0, sec );
     return 0;
 }
 
diff --git a/dlls/ntdll/unix/virtual.c b/dlls/ntdll/unix/virtual.c
index 3e7751abc55..38dec4fc6a8 100644
--- a/dlls/ntdll/unix/virtual.c
+++ b/dlls/ntdll/unix/virtual.c
@@ -2744,7 +2744,8 @@ static NTSTATUS map_image_into_view( struct file_view *view, const WCHAR *filena
 {
     IMAGE_DOS_HEADER *dos;
     IMAGE_NT_HEADERS *nt;
-    IMAGE_SECTION_HEADER *sections, *sec;
+    IMAGE_SECTION_HEADER sections[96];
+    IMAGE_SECTION_HEADER *sec;
     IMAGE_DATA_DIRECTORY *imports, *dir;
     NTSTATUS status = STATUS_CONFLICTING_ADDRESSES;
     int i;
@@ -2769,12 +2770,11 @@ static NTSTATUS map_image_into_view( struct file_view *view, const WCHAR *filena
     header_end = ptr + ROUND_SIZE( 0, header_size );
     memset( ptr + header_size, 0, header_end - (ptr + header_size) );
     if ((char *)(nt + 1) > header_end) return status;
+    if (nt->FileHeader.NumberOfSections > ARRAY_SIZE( sections )) return status;
     sec = IMAGE_FIRST_SECTION( nt );
     if ((char *)(sec + nt->FileHeader.NumberOfSections) > header_end) return status;
     /* Some applications (e.g. the Steam version of Borderlands) map over the top of the section headers,
      * copying the headers into local memory is necessary to properly load such applications. */
-    if (!(sections = malloc( sizeof(*sections) * nt->FileHeader.NumberOfSections )))
-        return STATUS_NO_MEMORY;
     memcpy(sections, sec, sizeof(*sections) * nt->FileHeader.NumberOfSections);
     sec = sections;
     imports = get_data_dir( nt, total_size, IMAGE_DIRECTORY_ENTRY_IMPORT );
@@ -2788,22 +2788,21 @@ static NTSTATUS map_image_into_view( struct file_view *view, const WCHAR *filena
 
         total_size = min( total_size, ROUND_SIZE( 0, st.st_size ));
         if (map_file_into_view( view, fd, 0, total_size, 0, VPROT_COMMITTED | VPROT_READ | VPROT_WRITECOPY,
-                                removable ) != STATUS_SUCCESS) goto done;
+                                removable ) != STATUS_SUCCESS) return status;
 
         /* check that all sections are loaded at the right offset */
-        if (nt->OptionalHeader.FileAlignment != nt->OptionalHeader.SectionAlignment) goto done;
+        if (nt->OptionalHeader.FileAlignment != nt->OptionalHeader.SectionAlignment) return status;
         for (i = 0; i < nt->FileHeader.NumberOfSections; i++)
         {
             if (sec[i].VirtualAddress != sec[i].PointerToRawData)
-                goto done;  /* Windows refuses to load in that case too */
+                return status;  /* Windows refuses to load in that case too */
         }
 
         /* set the image protections */
         set_vprot( view, ptr, total_size, VPROT_COMMITTED | VPROT_READ | VPROT_WRITECOPY | VPROT_EXEC );
 
         /* no relocations are performed on non page-aligned binaries */
-        status = STATUS_SUCCESS;
-        goto done;
+        return STATUS_SUCCESS;
     }
 
 
@@ -2830,7 +2829,7 @@ static NTSTATUS map_image_into_view( struct file_view *view, const WCHAR *filena
         {
             WARN_(module)( "%s section %.8s too large (%x+%lx/%lx)\n",
                            debugstr_w(filename), sec->Name, (int)sec->VirtualAddress, map_size, total_size );
-            goto done;
+            return status;
         }
 
         if ((sec->Characteristics & IMAGE_SCN_MEM_SHARED) &&
@@ -2844,7 +2843,7 @@ static NTSTATUS map_image_into_view( struct file_view *view, const WCHAR *filena
                                     VPROT_COMMITTED | VPROT_READ | VPROT_WRITE, FALSE ) != STATUS_SUCCESS)
             {
                 ERR_(module)( "Could not map %s shared section %.8s\n", debugstr_w(filename), sec->Name );
-                goto done;
+                return status;
             }
 
             /* check if the import directory falls inside this section */
@@ -2883,7 +2882,7 @@ static NTSTATUS map_image_into_view( struct file_view *view, const WCHAR *filena
         {
             ERR_(module)( "Could not map %s section %.8s, file probably truncated\n",
                           debugstr_w(filename), sec->Name );
-            goto done;
+            return status;
         }
 
         if (file_size & page_mask)
@@ -2912,11 +2911,7 @@ static NTSTATUS map_image_into_view( struct file_view *view, const WCHAR *filena
             update_arm64ec_ranges( view, nt, dir, &image_info->entry_point );
     }
 #endif
-    if (machine && machine != nt->FileHeader.Machine)
-    {
-        status = STATUS_NOT_SUPPORTED;
-        goto done;
-    }
+    if (machine && machine != nt->FileHeader.Machine) return STATUS_NOT_SUPPORTED;
 
     /* relocate to dynamic base */
 
@@ -2967,11 +2962,7 @@ static NTSTATUS map_image_into_view( struct file_view *view, const WCHAR *filena
 #ifdef VALGRIND_LOAD_PDB_DEBUGINFO
     VALGRIND_LOAD_PDB_DEBUGINFO(fd, ptr, total_size, ptr - (char *)wine_server_get_ptr( image_info->base ));
 #endif
-    status = STATUS_SUCCESS;
-
-done:
-    free( sections );
-    return status;
+    return STATUS_SUCCESS;
 }
 
 
@@ -3603,7 +3594,7 @@ NTSTATUS virtual_relocate_module( void *module )
     IMAGE_BASE_RELOCATION *rel, *end;
     IMAGE_SECTION_HEADER *sec;
     ULONG total_size = ROUND_SIZE( 0, nt->OptionalHeader.SizeOfImage );
-    ULONG *protect_old, i;
+    ULONG protect_old[96], i;
     ULONG_PTR image_base;
     INT_PTR delta;
 
@@ -3626,9 +3617,6 @@ NTSTATUS virtual_relocate_module( void *module )
 
     if (!(relocs = get_data_dir( nt, total_size, IMAGE_DIRECTORY_ENTRY_BASERELOC ))) return STATUS_SUCCESS;
 
-    if (!(protect_old = malloc( nt->FileHeader.NumberOfSections * sizeof(*protect_old ))))
-        return STATUS_NO_MEMORY;
-
     sec = IMAGE_FIRST_SECTION( nt );
     for (i = 0; i < nt->FileHeader.NumberOfSections; i++)
     {
@@ -3650,7 +3638,6 @@ NTSTATUS virtual_relocate_module( void *module )
         SIZE_T size = sec[i].SizeOfRawData;
         NtProtectVirtualMemory( NtCurrentProcess(), &addr, &size, protect_old[i], &protect_old[i] );
     }
-    free( protect_old );
     return STATUS_SUCCESS;
 }
 
