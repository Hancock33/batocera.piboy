diff --git a/configure.ac b/configure.ac
index c93aab68305..898d1bafa14 100644
--- a/configure.ac
+++ b/configure.ac
@@ -3511,6 +3511,7 @@ WINE_CONFIG_MAKEFILE(po)
 WINE_CONFIG_MAKEFILE(programs/arp)
 WINE_CONFIG_MAKEFILE(programs/aspnet_regiis)
 WINE_CONFIG_MAKEFILE(programs/attrib)
+WINE_CONFIG_MAKEFILE(programs/belauncher)
 WINE_CONFIG_MAKEFILE(programs/cabarc)
 WINE_CONFIG_MAKEFILE(programs/cacls)
 WINE_CONFIG_MAKEFILE(programs/certutil)
diff --git a/dlls/kernel32/kernel32.spec b/dlls/kernel32/kernel32.spec
index 3bb49206c6b..e0b4920847c 100644
--- a/dlls/kernel32/kernel32.spec
+++ b/dlls/kernel32/kernel32.spec
@@ -622,7 +622,7 @@
 @ stdcall -import GetConsoleProcessList(ptr long)
 @ stdcall -import GetConsoleScreenBufferInfo(long ptr)
 @ stdcall -import GetConsoleScreenBufferInfoEx(long ptr)
-# @ stub GetConsoleSelectionInfo
+@ stdcall -import GetConsoleSelectionInfo(ptr)
 @ stdcall -import GetConsoleTitleA(ptr long)
 @ stdcall -import GetConsoleTitleW(ptr long)
 @ stdcall -import GetConsoleWindow()
diff --git a/dlls/kernelbase/console.c b/dlls/kernelbase/console.c
index ae9943f1fa0..15a5d894001 100644
--- a/dlls/kernelbase/console.c
+++ b/dlls/kernelbase/console.c
@@ -1067,6 +1067,14 @@ BOOL WINAPI DECLSPEC_HOTPATCH GetConsoleScreenBufferInfoEx( HANDLE handle,
 }
 
 
+BOOL WINAPI DECLSPEC_HOTPATCH GetConsoleSelectionInfo(CONSOLE_SELECTION_INFO *info)
+{
+    FIXME("stub (%p)\n", info);
+    info->dwFlags = CONSOLE_NO_SELECTION;
+    return TRUE;
+}
+
+
 /******************************************************************************
  *	GetConsoleTitleA   (kernelbase.@)
  */
diff --git a/dlls/kernelbase/kernelbase.spec b/dlls/kernelbase/kernelbase.spec
index 3dc846e7326..17d3ae5ac11 100644
--- a/dlls/kernelbase/kernelbase.spec
+++ b/dlls/kernelbase/kernelbase.spec
@@ -476,6 +476,7 @@
 @ stdcall GetConsoleProcessList(ptr long)
 @ stdcall GetConsoleScreenBufferInfo(long ptr)
 @ stdcall GetConsoleScreenBufferInfoEx(long ptr)
+@ stdcall GetConsoleSelectionInfo(ptr)
 @ stdcall GetConsoleTitleA(ptr long)
 @ stdcall GetConsoleTitleW(ptr long)
 @ stdcall GetConsoleWindow()
diff --git a/dlls/kernelbase/process.c b/dlls/kernelbase/process.c
index e1c28fc67ed..019e6c3b1b5 100644
--- a/dlls/kernelbase/process.c
+++ b/dlls/kernelbase/process.c
@@ -26,6 +26,7 @@
 #include "windef.h"
 #include "winbase.h"
 #include "winnls.h"
+#include "winver.h"
 #include "wincontypes.h"
 #include "winternl.h"
 
@@ -502,6 +503,93 @@ done:
     return ret;
 }
 
+static int battleye_launcher_redirect_hack(const WCHAR *app_name, WCHAR *new_name, DWORD new_name_len, WCHAR **cmd_line)
+{
+    static const WCHAR belauncherW[] = L"c:\\windows\\system32\\belauncher.exe";
+
+    WCHAR full_path[MAX_PATH];
+    WCHAR *p;
+    UINT size;
+    void *block;
+    DWORD *translation;
+    char buf[100];
+    char *product_name;
+    WCHAR *new_cmd_line;
+
+    if (!GetLongPathNameW( app_name, full_path, MAX_PATH )) lstrcpynW( full_path, app_name, MAX_PATH );
+    if (!GetFullPathNameW( full_path, MAX_PATH, full_path, NULL )) lstrcpynW( full_path, app_name, MAX_PATH );
+
+    /* We detect the BattlEye launcher executable through the product name property, as the executable name varies */
+    size = GetFileVersionInfoSizeExW(0, full_path, NULL);
+    if (!size)
+        return 0;
+
+    block = HeapAlloc( GetProcessHeap(), 0, size );
+
+    if (!GetFileVersionInfoExW(0, full_path, 0, size, block))
+    {
+        HeapFree( GetProcessHeap(), 0, block );
+        return 0;
+    }
+
+    if (!VerQueryValueA(block, "\\VarFileInfo\\Translation", (void **) &translation, &size) || size != 4)
+    {
+        HeapFree( GetProcessHeap(), 0, block );
+        return 0;
+    }
+
+    sprintf(buf, "\\StringFileInfo\\%08lx\\ProductName", MAKELONG(HIWORD(*translation), LOWORD(*translation)));
+
+    if (!VerQueryValueA(block, buf, (void **) &product_name, &size))
+    {
+        HeapFree( GetProcessHeap(), 0, block );
+        return 0;
+    }
+
+    if (strcmp(product_name, "BattlEye Launcher"))
+    {
+        HeapFree( GetProcessHeap(), 0, block);
+        return 0;
+    }
+
+    HeapFree( GetProcessHeap(), 0, block );
+
+    TRACE("Detected launch of a BattlEye Launcher, redirecting to Proton version.\n");
+
+    if (new_name_len < wcslen(belauncherW) + 1)
+    {
+        WARN("Game executable path doesn't fit in buffer.\n");
+        return 0;
+    }
+
+    wcscpy(new_name, belauncherW);
+
+    /* find and replace executable name in command line, and add BE argument */
+    p = *cmd_line;
+    if (p[0] == '\"')
+        p++;
+
+    if (!wcsncmp(p, app_name, wcslen(app_name)))
+    {
+        new_cmd_line = HeapAlloc( GetProcessHeap(), 0, ( wcslen(*cmd_line) + wcslen(belauncherW) + 1 - wcslen(app_name) ) * sizeof(WCHAR) );
+
+        wcscpy(new_cmd_line, *cmd_line);
+        p = new_cmd_line;
+        if (p[0] == '\"')
+            p++;
+
+        memmove( p + wcslen(belauncherW), p + wcslen(app_name), (wcslen(p) - wcslen(belauncherW)) * sizeof(WCHAR) );
+        memcpy( p, belauncherW, wcslen(belauncherW) * sizeof(WCHAR) );
+
+        TRACE("old command line %s.\n", debugstr_w(*cmd_line));
+        TRACE("new command line %s.\n", debugstr_w(new_cmd_line));
+
+        *cmd_line = new_cmd_line;
+    }
+
+    return 1;
+}
+
 /**********************************************************************
  *           CreateProcessInternalW   (kernelbase.@)
  */
@@ -543,6 +631,14 @@ BOOL WINAPI DECLSPEC_HOTPATCH CreateProcessInternalW( HANDLE token, const WCHAR
         app_name = name;
     }
 
+    p = tidy_cmdline;
+    if (battleye_launcher_redirect_hack( app_name, name, ARRAY_SIZE(name), &tidy_cmdline ))
+    {
+        app_name = name;
+        if (p != tidy_cmdline && p != cmd_line)
+            HeapFree( GetProcessHeap(), 0, p );
+    }
+
     /* Warn if unsupported features are used */
 
     if (flags & (IDLE_PRIORITY_CLASS | HIGH_PRIORITY_CLASS | REALTIME_PRIORITY_CLASS |
diff --git a/dlls/ntdll/unix/loader.c b/dlls/ntdll/unix/loader.c
index 14f7a551368..aea0e168b59 100644
--- a/dlls/ntdll/unix/loader.c
+++ b/dlls/ntdll/unix/loader.c
@@ -383,11 +383,14 @@ static WORD get_alt_machine( WORD machine )
 
 static void set_dll_path(void)
 {
-    char *p, *path = getenv( "WINEDLLPATH" );
+    char *p, *path = getenv( "WINEDLLPATH" ), *be_runtime = getenv( "PROTON_BATTLEYE_RUNTIME" );
     int i, count = 0;
 
     if (path) for (p = path, count = 1; *p; p++) if (*p == ':') count++;
 
+    if (be_runtime)
+        count += 2;
+
     dll_paths = malloc( (count + 2) * sizeof(*dll_paths) );
     count = 0;
 
@@ -400,6 +403,24 @@ static void set_dll_path(void)
         free( path );
     }
 
+    if (be_runtime)
+    {
+        const char lib32[] = "/v1/lib/wine/";
+        const char lib64[] = "/v1/lib64/wine/";
+
+        p = malloc( strlen(be_runtime) + strlen(lib32) + 1 );
+        strcpy(p, be_runtime);
+        strcat(p, lib32);
+
+        dll_paths[count++] = p;
+
+        p = malloc( strlen(be_runtime) + strlen(lib64) + 1 );
+        strcpy(p, be_runtime);
+        strcat(p, lib64);
+
+        dll_paths[count++] = p;
+    }
+
     for (i = 0; i < count; i++) dll_path_maxlen = max( dll_path_maxlen, strlen(dll_paths[i]) );
     dll_paths[count] = NULL;
 }
diff --git a/dlls/sechost/service.c b/dlls/sechost/service.c
index 474d977ac5e..aa358925eb5 100644
--- a/dlls/sechost/service.c
+++ b/dlls/sechost/service.c
@@ -312,6 +312,8 @@ SC_HANDLE WINAPI DECLSPEC_HOTPATCH OpenServiceW( SC_HANDLE manager, const WCHAR
     SC_RPC_HANDLE handle = NULL;
     DWORD err;
 
+    char str[64];
+
     TRACE( "%p %s %#lx\n", manager, debugstr_w(name), access );
 
     if (!manager)
@@ -320,6 +322,14 @@ SC_HANDLE WINAPI DECLSPEC_HOTPATCH OpenServiceW( SC_HANDLE manager, const WCHAR
         return NULL;
     }
 
+    /* HACK for ARK: Survivial Evolved checking the status of BEService to determine whether BE is enabled. */
+    if(GetEnvironmentVariableA("SteamGameId", str, sizeof(str)) && !strcmp(str, "346110") &&
+        !wcscmp(name, L"BEService"))
+    {
+        WARN("HACK: returning fake service handle for BEService.\n");
+        return (void *)0xdeadbeef;
+    }
+
     __TRY
     {
         err = svcctl_OpenServiceW( manager, name, access, &handle );
@@ -1107,6 +1117,8 @@ BOOL WINAPI DECLSPEC_HOTPATCH QueryServiceStatusEx( SC_HANDLE service, SC_STATUS
 {
     DWORD err;
 
+    char str[64];
+
     TRACE( "%p %d %p %ld %p\n", service, level, buffer, size, ret_size );
 
     if (level != SC_STATUS_PROCESS_INFO) return set_error( ERROR_INVALID_LEVEL );
@@ -1117,6 +1129,24 @@ BOOL WINAPI DECLSPEC_HOTPATCH QueryServiceStatusEx( SC_HANDLE service, SC_STATUS
         return set_error( ERROR_INSUFFICIENT_BUFFER );
     }
 
+    /* HACK for ARK: Survivial Evolved checking the status of BEService to determine whether BE is enabled. */
+    if(GetEnvironmentVariableA("SteamGameId", str, sizeof(str)) && !strcmp(str, "346110") &&
+        service == (void *)0xdeadbeef)
+    {
+        SERVICE_STATUS_PROCESS *status = (SERVICE_STATUS_PROCESS *)buffer;
+        WARN("HACK: returning fake data for BEService.\n");
+        status->dwServiceType = SERVICE_WIN32_OWN_PROCESS;
+        status->dwCurrentState = SERVICE_RUNNING;
+        status->dwControlsAccepted = SERVICE_ACCEPT_SHUTDOWN | SERVICE_ACCEPT_STOP;
+        status->dwWin32ExitCode = NO_ERROR;
+        status->dwServiceSpecificExitCode = 0;
+        status->dwCheckPoint = 0;
+        status->dwWaitHint = 0;
+        status->dwProcessId = 0xdeadbee0;
+        status->dwServiceFlags = 0;
+        return TRUE;
+    }
+
     __TRY
     {
         err = svcctl_QueryServiceStatusEx( service, level, buffer, size, ret_size );
diff --git a/programs/belauncher/Makefile.in b/programs/belauncher/Makefile.in
new file mode 100644
index 00000000000..927983f7423
--- /dev/null
+++ b/programs/belauncher/Makefile.in
@@ -0,0 +1,7 @@
+MODULE    = belauncher.exe
+IMPORTS   = shlwapi shcore
+
+EXTRADLLFLAGS = -mwindows -municode
+
+SOURCES = \
+        main.c \
diff --git a/programs/belauncher/main.c b/programs/belauncher/main.c
new file mode 100644
index 00000000000..213378fd108
--- /dev/null
+++ b/programs/belauncher/main.c
@@ -0,0 +1,182 @@
+#define WIN32_LEAN_AND_MEAN
+#include <windows.h>
+#include <io.h>
+#include <shlwapi.h>
+#include <shellapi.h>
+
+#include "wine/debug.h"
+
+WINE_DEFAULT_DEBUG_CHANNEL(belauncher);
+
+int WINAPI wWinMain(HINSTANCE hInst, HINSTANCE hPrevInst, LPWSTR cmdline, int cmdshow)
+{
+    char *configs, *config, *arch_32_exe = NULL, *arch_64_exe = NULL, *game_exe = NULL, *be_arg = NULL;
+    WCHAR path[MAX_PATH], *p, config_path[MAX_PATH], game_exeW[MAX_PATH], **argvW;
+    LARGE_INTEGER launcher_cfg_size;
+    unsigned char battleye_status;
+    int game_exe_len, arg_len, path_len;
+    PROCESS_INFORMATION pi;
+    HANDLE launcher_cfg;
+    LPWSTR launch_cmd;
+    STARTUPINFOW si = {0};
+    int i, argc;
+    DWORD size;
+    BOOL wow64;
+
+    battleye_status = 0x3; /* Starting */
+    _write(1, &battleye_status, 1);
+
+    *path = 0;
+    if ((size = GetEnvironmentVariableW(L"PROTON_ORIG_LAUNCHER_NAME", path, ARRAY_SIZE(path))) && size <= ARRAY_SIZE(path))
+    {
+        WINE_TRACE("PROTON_ORIG_LAUNCHER_NAME %s.\n", wine_dbgstr_w(path));
+
+        for (p = path + wcslen(path); p != path; --p)
+            if (*p == '\\') break;
+        if (*p == '\\')
+            ++p;
+        *p = 0;
+    }
+
+    wcscpy(config_path, path);
+    wcscat(config_path, L"Battleye\\BELauncher.ini");
+    launcher_cfg = CreateFileW(config_path, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
+    if (launcher_cfg == INVALID_HANDLE_VALUE)
+    {
+        *path = 0;
+        launcher_cfg = CreateFileW(L"Battleye\\BELauncher.ini", GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
+    }
+    if (launcher_cfg == INVALID_HANDLE_VALUE)
+    {
+        WINE_ERR("BELauncher.ini not found.\n");
+        goto start_failed;
+    }
+
+    if(!GetFileSizeEx(launcher_cfg, &launcher_cfg_size) || launcher_cfg_size.u.HighPart)
+    {
+        CloseHandle(launcher_cfg);
+        goto start_failed;
+    }
+
+    configs = HeapAlloc( GetProcessHeap(), 0, launcher_cfg_size.u.LowPart);
+
+    if (!ReadFile(launcher_cfg, configs, launcher_cfg_size.u.LowPart, &size, NULL) || size != launcher_cfg_size.u.LowPart)
+    {
+        CloseHandle(launcher_cfg);
+        HeapFree( GetProcessHeap(), 0, configs );
+        goto start_failed;
+    }
+
+    CloseHandle(launcher_cfg);
+
+    config = configs;
+    do
+    {
+        if (!strncmp(config, "32BitExe=", 9))
+            arch_32_exe = config + 9;
+
+        if (!strncmp(config, "64BitExe=", 9))
+            arch_64_exe = config + 9;
+
+        if (!strncmp(config, "BEArg=", 6))
+            be_arg = config + 6;
+    }
+    while ((config = strchr(config, '\n')) && *(config++));
+
+    *game_exeW = 0;
+    game_exe_len = 0;
+
+    if ((argvW = CommandLineToArgvW(cmdline, &argc)))
+    {
+        for (i = 0; i < argc; ++i)
+        {
+            if (!wcscmp(argvW[i], L"-exe") && i < argc - 1)
+            {
+                wcscpy(game_exeW, argvW[i + 1]);
+                game_exe_len = wcslen(game_exeW);
+                break;
+            }
+        }
+    }
+
+    if (!*game_exeW)
+    {
+        if (arch_64_exe && (sizeof(void *) == 8 || (IsWow64Process(GetCurrentProcess(), &wow64) && wow64)))
+            game_exe = arch_64_exe;
+        else if (arch_32_exe)
+            game_exe = arch_32_exe;
+        else
+        {
+            HeapFree( GetProcessHeap(), 0, configs );
+            WINE_ERR("Failed to find game executable name from BattlEye config.\n");
+            goto start_failed;
+        }
+
+        if (strchr(game_exe, '\r'))
+            *(strchr(game_exe, '\r')) = 0;
+        if (strchr(game_exe, '\n'))
+            *(strchr(game_exe, '\n')) = 0;
+        game_exe_len = MultiByteToWideChar(CP_ACP, 0, game_exe, -1, game_exeW, ARRAY_SIZE(game_exeW));
+        if (!game_exe_len)
+        {
+            WINE_ERR("Failed to convert game_exe %s.\n", wine_dbgstr_a(game_exe));
+            goto start_failed;
+        }
+        --game_exe_len;
+    }
+
+    if (!be_arg) arg_len = 0;
+    else
+    {
+        if (strchr(be_arg, '\r'))
+            *(strchr(be_arg, '\r')) = 0;
+        if (strchr(be_arg, '\n'))
+            *(strchr(be_arg, '\n')) = 0;
+        arg_len = MultiByteToWideChar(CP_ACP, 0, be_arg, -1, NULL, 0) - 1;
+    }
+
+    WINE_TRACE("Launching game executable %s for BattlEye.\n", game_exe);
+    battleye_status = 0x9; /* Launching Game */
+    _write(1, &battleye_status, 1);
+
+    if (PathIsRelativeW(game_exeW))
+        path_len = wcslen(path);
+    else
+        path_len = 0;
+
+    launch_cmd = HeapAlloc(GetProcessHeap(), 0, (path_len + game_exe_len + 1 + wcslen(cmdline) + 1 + arg_len + 1) * sizeof(WCHAR));
+
+    memcpy(launch_cmd, path, path_len * sizeof(*path));
+
+    memcpy(launch_cmd + path_len, game_exeW, game_exe_len * sizeof(*launch_cmd));
+    launch_cmd[path_len + game_exe_len] = ' ';
+
+    wcscpy(launch_cmd + path_len + game_exe_len + 1, cmdline);
+    launch_cmd[path_len + game_exe_len + 1 + wcslen(cmdline)] = ' ';
+
+    if (!MultiByteToWideChar(CP_ACP, 0, be_arg, -1, launch_cmd + path_len + game_exe_len + 1 + wcslen(cmdline) + 1, arg_len + 1))
+        launch_cmd[path_len + game_exe_len + 1 + wcslen(cmdline)] = 0;
+
+    WINE_TRACE("game_exe %s, cmdline %s.\n", wine_dbgstr_w(game_exeW), wine_dbgstr_w(cmdline));
+    WINE_TRACE("path %s, be_arg %s.\n", wine_dbgstr_w(path), wine_dbgstr_a(be_arg));
+    WINE_TRACE("launch_cmd %s.\n", wine_dbgstr_w(launch_cmd));
+
+    if (!CreateProcessW(NULL, launch_cmd, NULL, NULL, FALSE, CREATE_NEW_CONSOLE, NULL, NULL, &si, &pi))
+    {
+        WINE_ERR("CreateProcessW failed.\n");
+        battleye_status = 0xA; /* Launch Failed */
+        _write(1, &battleye_status, 1);
+        return GetLastError();
+    }
+    HeapFree( GetProcessHeap(), 0, launch_cmd );
+
+    WaitForSingleObject(pi.hProcess, INFINITE);
+    CloseHandle(pi.hProcess);
+    return 0;
+
+start_failed:
+    WINE_ERR("Failed.\n");
+    battleye_status = 0x4; /* Start Failed */
+    _write(1, &battleye_status, 1);
+    return 0;
+}
