diff --git a/Android.mk b/Android.mk
index 8a702066..a4e7615f 100644
--- a/Android.mk
+++ b/Android.mk
@@ -311,9 +311,9 @@ define gen_spvtools_build_version_inc
 $(call generate-file-dir,$(1)/dummy_filename)
 $(1)/build-version.inc: \
         $(LOCAL_PATH)/utils/update_build_version.py \
-        $(LOCAL_PATH)
+        $(LOCAL_PATH)/CHANGES
 		@$(HOST_PYTHON) $(LOCAL_PATH)/utils/update_build_version.py \
-		                $(LOCAL_PATH) $(1)/build-version.inc
+		                $(LOCAL_PATH)/CHANGES $(1)/build-version.inc
 		@echo "[$(TARGET_ARCH_ABI)] Generate       : build-version.inc <= CHANGES"
 $(LOCAL_PATH)/source/software_version.cpp: $(1)/build-version.inc
 endef
diff --git a/BUILD.bazel b/BUILD.bazel
index 71399b2f..255d4e74 100644
--- a/BUILD.bazel
+++ b/BUILD.bazel
@@ -104,11 +104,11 @@ py_binary(
 
 genrule(
     name = "build_version_inc",
+    srcs = ["CHANGES"],
     outs = ["build-version.inc"],
-    cmd = "SOURCE_DATE_EPOCH=0 $(location :update_build_version) $(RULEDIR) $(location build-version.inc)",
-    cmd_bat = "set SOURCE_DATE_EPOCH=0  && $(location :update_build_version) $(RULEDIR) $(location build-version.inc)",
+    cmd = "SOURCE_DATE_EPOCH=0 $(location :update_build_version) $(location CHANGES) $(location build-version.inc)",
+    cmd_bat = "set SOURCE_DATE_EPOCH=0  && $(location :update_build_version) $(location CHANGES) $(location build-version.inc)",
     exec_tools = [":update_build_version"],
-    local = True,
 )
 
 # Libraries
diff --git a/BUILD.gn b/BUILD.gn
index ee3743b8..862cd955 100644
--- a/BUILD.gn
+++ b/BUILD.gn
@@ -262,12 +262,12 @@ action("spvtools_generators_inc") {
 action("spvtools_build_version") {
   script = "utils/update_build_version.py"
 
-  repo_path = "."
+  changes_file = "CHANGES"
   inc_file = "${target_gen_dir}/build-version.inc"
 
   outputs = [ inc_file ]
   args = [
-    rebase_path(repo_path, root_build_dir),
+    rebase_path(changes_file, root_build_dir),
     rebase_path(inc_file, root_build_dir),
   ]
 }
diff --git a/source/CMakeLists.txt b/source/CMakeLists.txt
index b5924f51..acfa0c12 100644
--- a/source/CMakeLists.txt
+++ b/source/CMakeLists.txt
@@ -195,11 +195,14 @@ set(SPIRV_TOOLS_BUILD_VERSION_INC
   ${spirv-tools_BINARY_DIR}/build-version.inc)
 set(SPIRV_TOOLS_BUILD_VERSION_INC_GENERATOR
   ${spirv-tools_SOURCE_DIR}/utils/update_build_version.py)
+set(SPIRV_TOOLS_CHANGES_FILE
+  ${spirv-tools_SOURCE_DIR}/CHANGES)
 add_custom_command(OUTPUT ${SPIRV_TOOLS_BUILD_VERSION_INC}
    COMMAND ${PYTHON_EXECUTABLE}
            ${SPIRV_TOOLS_BUILD_VERSION_INC_GENERATOR}
-           ${spirv-tools_SOURCE_DIR} ${SPIRV_TOOLS_BUILD_VERSION_INC}
+           ${SPIRV_TOOLS_CHANGES_FILE} ${SPIRV_TOOLS_BUILD_VERSION_INC}
    DEPENDS ${SPIRV_TOOLS_BUILD_VERSION_INC_GENERATOR}
+           ${SPIRV_TOOLS_CHANGES_FILE}
    COMMENT "Update build-version.inc in the SPIRV-Tools build directory (if necessary).")
 # Convenience target for standalone generation of the build-version.inc file.
 # This is not required for any dependence chain.
diff --git a/utils/update_build_version.py b/utils/update_build_version.py
index 1ab98624..b1c7b214 100755
--- a/utils/update_build_version.py
+++ b/utils/update_build_version.py
@@ -17,13 +17,16 @@
 # Updates an output file with version info unless the new content is the same
 # as the existing content.
 #
-# Args: <repo-path> <output-file>
+# Args: <changes-file> <output-file>
 #
 # The output file will contain a line of text consisting of two C source syntax
 # string literals separated by a comma:
-#  - The software version deduced from the last release tag.
+#  - The software version deduced from the given CHANGES file.
 #  - A longer string with the project name, the software version number, and
-#    git commit information for this release.
+#    git commit information for the CHANGES file's directory.  The commit
+#    information is the output of "git describe" if that succeeds, or "git
+#    rev-parse HEAD" if that succeeds, or otherwise a message containing the
+#    phrase "unknown hash".
 # The string contents are escaped as necessary.
 
 import datetime
@@ -36,13 +39,6 @@ import logging
 import sys
 import time
 
-# Regex to match the SPIR-V version tag.
-# Example of matching tags:
-#  - v2020.1
-#  - v2020.1-dev
-#  - v2020.1.rc1
-VERSION_REGEX = re.compile(r'^v(\d+)\.(\d+)(-dev|rc\d+)?$')
-
 # Format of the output generated by this script. Example:
 # "v2023.1", "SPIRV-Tools v2023.1 0fc5526f2b01a0cc89192c10cf8bef77f1007a62, 2023-01-18T14:51:49"
 OUTPUT_FORMAT = '"{version_tag}", "SPIRV-Tools {version_tag} {description}"\n'
@@ -83,62 +79,34 @@ def command_output(cmd, directory):
         return False, None
     return p.returncode == 0, stdout
 
-def deduce_last_release(repo_path):
-    """Returns a software version number parsed from git tags."""
-
-    success, tag_list = command_output(['git', 'tag', '--sort=-v:refname'], repo_path)
-    if not success:
-      return False, None
-
-    latest_version_tag = None
-    for tag in tag_list.decode().splitlines():
-      if VERSION_REGEX.match(tag):
-        latest_version_tag = tag
-        break
-
-    if latest_version_tag is None:
-      logging.error("No tag matching version regex matching.")
-      return False, None
-    return True, latest_version_tag
-
-def get_last_release_tuple(repo_path):
-  success, version = deduce_last_release(repo_path)
-  if not success:
-    return False, None
+def deduce_software_version(changes_file):
+    """Returns a tuple (success, software version number) parsed from the
+    given CHANGES file.
 
-  m = VERSION_REGEX.match(version)
-  if len(m.groups()) != 3:
-    return False, None
-  return True, (int(m.groups()[0]), int(m.groups()[1]))
+    Success is set to True if the software version could be deduced.
+    Software version is undefined if success if False.
+    Function expects the CHANGES file to describes most recent versions first.
+    """
 
-def deduce_current_release(repo_path):
-  status, version_tuple = get_last_release_tuple(repo_path)
-  if not status:
+    # Match the first well-formed version-and-date line
+    # Allow trailing whitespace in the checked-out source code has
+    # unexpected carriage returns on a linefeed-only system such as
+    # Linux.
+    pattern = re.compile(r'^(v\d+\.\d+(-dev)?) \d\d\d\d-\d\d-\d\d\s*$')
+    with open(changes_file, mode='r') as f:
+        for line in f.readlines():
+            match = pattern.match(line)
+            if match:
+                return True, match.group(1)
     return False, None
 
-  last_release_tag = "v{}.{}-dev".format(*version_tuple)
-  success, tag_list = command_output(['git', 'tag', '--contains'], repo_path)
-  if success:
-    if last_release_tag in set(tag_list.decode().splitlines()):
-      return True, last_release_tag
-  else:
-    logging.warning("Could not check tags for commit. Assuming -dev version.")
 
-  now_year = datetime.datetime.now().year
-  if version_tuple[0] == now_year:
-    version_tuple =  (now_year, version_tuple[1] + 1)
-  else:
-    version_tuple = (now_year, 1)
-
-  return True, "v{}.{}-dev".format(*version_tuple)
-
-def get_description_for_head(repo_path):
+def describe(repo_path):
     """Returns a string describing the current Git HEAD version as descriptively
-    as possible, in order of priority:
-      - git describe output
-      - git rev-parse HEAD output
-      - "unknown-hash, <date>"
-    """
+    as possible.
+
+    Runs 'git describe', or alternately 'git rev-parse HEAD', in directory.  If
+    successful, returns the output; otherwise returns 'unknown hash, <date>'."""
 
     success, output = command_output(['git', 'describe'], repo_path)
     if not success:
@@ -162,13 +130,6 @@ def get_description_for_head(repo_path):
     iso_date = datetime.datetime.utcfromtimestamp(timestamp).isoformat()
     return "unknown hash, {}".format(iso_date)
 
-def is_folder_git_repo(path):
-  try:
-    success, _ = command_output(['git', 'branch'], path)
-  except NotADirectoryError as e:
-    return False
-  return success
-
 def main():
     FORMAT = '%(asctime)s %(message)s'
     logging.basicConfig(format="[%(asctime)s][%(levelname)-8s] %(message)s", datefmt="%H:%M:%S")
@@ -176,15 +137,16 @@ def main():
         logging.error("usage: {} <repo-path> <output-file>".format(sys.argv[0]))
         sys.exit(1)
 
-    repo_path = os.path.realpath(sys.argv[1])
+    changes_file_path = os.path.realpath(sys.argv[1])
     output_file_path = sys.argv[2]
 
-    success, version = deduce_current_release(repo_path)
+    success, version = deduce_software_version(changes_file_path)
     if not success:
-      logging.error("Could not deduce latest release version.")
+      logging.error("Could not deduce latest release version from {}.".format(changes_file_path))
       sys.exit(1)
 
-    description = get_description_for_head(repo_path)
+    repo_path = os.path.dirname(changes_file_path)
+    description = describe(repo_path)
     content = OUTPUT_FORMAT.format(version_tag=version, description=description)
 
     # Escape file content.
