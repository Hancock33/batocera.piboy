diff --git a/Utilities/Thread.cpp b/Utilities/Thread.cpp
index 2e890a4ec..82a18f477 100644
--- a/Utilities/Thread.cpp
+++ b/Utilities/Thread.cpp
@@ -2040,12 +2040,6 @@ DECLARE(thread_ctrl::g_native_core_layout) { native_core_arrangement::undefined
 
 void thread_base::start()
 {
-	m_sync.atomic_op([&](u32& v)
-	{
-		v &= ~static_cast<u32>(thread_state::mask);
-		v |= static_cast<u32>(thread_state::created);
-	});
-
 #ifdef _WIN32
 	m_thread = ::_beginthreadex(nullptr, 0, entry_point, this, CREATE_SUSPENDED, nullptr);
 	ensure(m_thread);
diff --git a/Utilities/Thread.h b/Utilities/Thread.h
index 576eac264..e8fba7338 100644
--- a/Utilities/Thread.h
+++ b/Utilities/Thread.h
@@ -5,7 +5,6 @@
 #include "util/shared_ptr.hpp"
 
 #include <string>
-#include <execution>
 
 #include "mutex.h"
 #include "lockless.h"
@@ -84,9 +83,9 @@ struct result_storage<Ctx, Args...>
 };
 
 template <typename T>
-concept NamedThreadName = requires (const T&)
+concept NamedThreadName = requires (const T& t)
 {
-	std::string(T::thread_name);
+	std::string(t.thread_name);
 };
 
 // Base class for task queue (linked list)
@@ -447,11 +446,6 @@ public:
 	}
 };
 
-namespace stx
-{
-	struct launch_retainer;
-}
-
 // Derived from the callable object Context, possibly a lambda
 template <class Context>
 class named_thread final : public Context, result_storage<Context>, thread_base
@@ -518,27 +512,17 @@ class named_thread final : public Context, result_storage<Context>, thread_base
 
 public:
 	// Forwarding constructor with default name (also potentially the default constructor)
-	template <typename... Args> requires (std::is_constructible_v<Context, Args&&...>) && (!(std::is_same_v<std::remove_cvref_t<Args>, stx::launch_retainer> || ...)) && (NamedThreadName<Context>)
-	named_thread(Args&&... args) noexcept
-		: Context(std::forward<Args>(args)...)
-		, thread(trampoline, std::string(Context::thread_name))
-	{
-		thread::start();
-	}
-
-	// Forwarding constructor with default name, does not automatically run the thread
 	template <typename... Args> requires (std::is_constructible_v<Context, Args&&...>) && (NamedThreadName<Context>)
-	named_thread(const stx::launch_retainer&, Args&&... args) noexcept
+	named_thread(Args&&... args)
 		: Context(std::forward<Args>(args)...)
 		, thread(trampoline, std::string(Context::thread_name))
 	{
-		// Create a stand-by thread context
-		m_sync |= static_cast<u32>(thread_state::finished);
+		thread::start();
 	}
 
 	// Normal forwarding constructor
-	template <typename... Args> requires (std::is_constructible_v<Context, Args&&...>) && (!NamedThreadName<Context>)
-	named_thread(std::string name, Args&&... args) noexcept
+	template <typename... Args> requires (std::is_constructible_v<Context, Args&&...>)
+	named_thread(std::string name, Args&&... args)
 		: Context(std::forward<Args>(args)...)
 		, thread(trampoline, std::move(name))
 	{
@@ -546,7 +530,7 @@ public:
 	}
 
 	// Lambda constructor, also the implicit deduction guide candidate
-	named_thread(std::string_view name, Context&& f) noexcept requires (!NamedThreadName<Context>)
+	named_thread(std::string_view name, Context&& f)
 		: Context(std::forward<Context>(f))
 		, thread(trampoline, std::string(name))
 	{
@@ -660,20 +644,12 @@ public:
 		return static_cast<thread_state>(thread::m_sync.load() & 3);
 	}
 
+	// Try to abort by assigning thread_state::aborting/finished
+	// Join thread by thread_state::finished
 	named_thread& operator=(thread_state s)
 	{
-		if (s == thread_state::created)
-		{
-			// Run thread
-			ensure(operator thread_state() == thread_state::finished);
-			thread::start();
-			return *this;
-		}
-
 		bool notify_sync = false;
 
-		// Try to abort by assigning thread_state::aborting/finished
-		// Join thread by thread_state::finished
 		if (s >= thread_state::aborting && thread::m_sync.fetch_op([](u32& v) { return !(v & 3) && (v |= 1); }).second)
 		{
 			notify_sync = true;
diff --git a/rpcs3/Emu/Cell/Modules/cellRec.cpp b/rpcs3/Emu/Cell/Modules/cellRec.cpp
index 8eca2d138..44739703f 100644
--- a/rpcs3/Emu/Cell/Modules/cellRec.cpp
+++ b/rpcs3/Emu/Cell/Modules/cellRec.cpp
@@ -1377,6 +1377,7 @@ error_code cellRecClose(s32 isDiscard)
 				cellRec.error("cellRecClose: Unexpected recording mode %s found while stopping video capture.", old_mode);
 			}
 
+			g_fxo->need<utils::video_provider>();
 			utils::video_provider& video_provider = g_fxo->get<utils::video_provider>();
 
 			if (!video_provider.set_video_sink(nullptr, recording_mode::cell))
@@ -1464,6 +1465,7 @@ error_code cellRecStart()
 		// Setup a video sink if it is needed
 		if (rec.param.use_internal_video() || rec.param.use_internal_audio())
 		{
+			g_fxo->need<utils::video_provider>();
 			utils::video_provider& video_provider = g_fxo->get<utils::video_provider>();
 
 			if (rec.sink && !video_provider.set_video_sink(rec.sink, recording_mode::cell))
diff --git a/rpcs3/Emu/Cell/lv2/sys_net/lv2_socket_p2ps.cpp b/rpcs3/Emu/Cell/lv2/sys_net/lv2_socket_p2ps.cpp
index f6ae0158a..c22ae4bdc 100644
--- a/rpcs3/Emu/Cell/lv2/sys_net/lv2_socket_p2ps.cpp
+++ b/rpcs3/Emu/Cell/lv2/sys_net/lv2_socket_p2ps.cpp
@@ -187,6 +187,11 @@ private:
 	std::unordered_map<s32, rtt_info> rtts; // (sock_id, rtt)
 };
 
+void initialize_tcp_timeout_monitor()
+{
+	g_fxo->need<named_thread<tcp_timeout_monitor>>();
+}
+
 u16 u2s_tcp_checksum(const le_t<u16>* buffer, usz size)
 {
 	u32 cksum = 0;
diff --git a/rpcs3/Emu/Cell/lv2/sys_net/lv2_socket_p2ps.h b/rpcs3/Emu/Cell/lv2/sys_net/lv2_socket_p2ps.h
index e06b16aa9..ec3c3b378 100644
--- a/rpcs3/Emu/Cell/lv2/sys_net/lv2_socket_p2ps.h
+++ b/rpcs3/Emu/Cell/lv2/sys_net/lv2_socket_p2ps.h
@@ -50,6 +50,7 @@ enum p2ps_tcp_flags : u8
 	CWR = (1 << 7),
 };
 
+void initialize_tcp_timeout_monitor();
 u16 u2s_tcp_checksum(const le_t<u16>* buffer, usz size);
 std::vector<u8> generate_u2s_packet(const p2ps_encapsulated_tcp& header, const u8* data, const u32 datasize);
 
diff --git a/rpcs3/Emu/Cell/lv2/sys_net/network_context.cpp b/rpcs3/Emu/Cell/lv2/sys_net/network_context.cpp
index 15b27b49b..0a5e01073 100644
--- a/rpcs3/Emu/Cell/lv2/sys_net/network_context.cpp
+++ b/rpcs3/Emu/Cell/lv2/sys_net/network_context.cpp
@@ -77,14 +77,16 @@ std::vector<signaling_message> get_sign_msgs()
 	return msgs;
 }
 
-namespace np
+void need_network()
 {
-	void init_np_handler_dependencies();
+	g_fxo->need<network_context>();
+	initialize_tcp_timeout_monitor();
 }
 
 network_thread::network_thread()
 {
-	np::init_np_handler_dependencies();
+	// Ensures IDM for lv2_socket is always valid when the thread is running
+	g_fxo->init<id_manager::id_map<lv2_socket>>();
 }
 
 void network_thread::bind_sce_np_port()
diff --git a/rpcs3/Emu/NP/np_handler.cpp b/rpcs3/Emu/NP/np_handler.cpp
index d0721cec4..601beba07 100644
--- a/rpcs3/Emu/NP/np_handler.cpp
+++ b/rpcs3/Emu/NP/np_handler.cpp
@@ -339,28 +339,6 @@ namespace np
 		return;
 	}
 
-	extern void init_np_handler_dependencies()
-	{
-		if (auto handler = g_fxo->try_get<named_thread<np_handler>>())
-		{
-			handler->init_np_handler_dependencies();
-		}
-	}
-
-	void np_handler::init_np_handler_dependencies()
-	{
-		if (is_psn_active && g_cfg.net.psn_status == np_psn_status::psn_rpcn && g_fxo->is_init<network_context>() && !m_inited_np_handler_dependencies)
-		{
-			m_inited_np_handler_dependencies = true;
-
-			auto& nc = g_fxo->get<network_context>();
-			nc.bind_sce_np_port();
-
-			std::lock_guard lock(mutex_rpcn);
-			rpcn = rpcn::rpcn_client::get_instance();
-		}
-	}
-
 	np_handler::np_handler()
 	{
 		g_fxo->need<named_thread<signaling_handler>>();
@@ -410,6 +388,16 @@ namespace np
 			if (g_cfg.net.upnp_enabled)
 				upnp.upnp_enable();
 		}
+
+		if (is_psn_active && g_cfg.net.psn_status == np_psn_status::psn_rpcn)
+		{
+			g_fxo->need<network_context>();
+			auto& nc = g_fxo->get<network_context>();
+			nc.bind_sce_np_port();
+
+			std::lock_guard lock(mutex_rpcn);
+			rpcn = rpcn::rpcn_client::get_instance();
+		}
 	}
 
 	np_handler::np_handler(utils::serial& ar)
diff --git a/rpcs3/Emu/NP/np_handler.h b/rpcs3/Emu/NP/np_handler.h
index e250b1de2..043f26bd8 100644
--- a/rpcs3/Emu/NP/np_handler.h
+++ b/rpcs3/Emu/NP/np_handler.h
@@ -76,7 +76,6 @@ namespace np
 		np_handler(utils::serial& ar);
 		void save(utils::serial& ar);
 
-		void init_np_handler_dependencies();
 		const std::array<u8, 6>& get_ether_addr() const;
 		const std::string& get_hostname() const;
 		u32 get_local_ip_addr() const;
@@ -306,8 +305,6 @@ namespace np
 		shared_mutex mutex_queue_basic_events;
 		std::queue<basic_event> queue_basic_events;
 
-		bool m_inited_np_handler_dependencies = false;
-
 	private:
 		bool is_connected  = false;
 		bool is_psn_active = false;
diff --git a/rpcs3/Emu/NP/signaling_handler.cpp b/rpcs3/Emu/NP/signaling_handler.cpp
index f161d2413..922ca024c 100644
--- a/rpcs3/Emu/NP/signaling_handler.cpp
+++ b/rpcs3/Emu/NP/signaling_handler.cpp
@@ -17,6 +17,7 @@
 
 LOG_CHANNEL(sign_log, "Signaling");
 
+void need_network();
 
 template <>
 void fmt_class_string<SignalingCommand>::format(std::string& out, u64 arg)
@@ -40,6 +41,7 @@ void fmt_class_string<SignalingCommand>::format(std::string& out, u64 arg)
 
 signaling_handler::signaling_handler()
 {
+	need_network();
 }
 
 /////////////////////////////
diff --git a/rpcs3/Emu/System.cpp b/rpcs3/Emu/System.cpp
index de006ee3e..f6a3fa5d2 100644
--- a/rpcs3/Emu/System.cpp
+++ b/rpcs3/Emu/System.cpp
@@ -2875,9 +2875,9 @@ void Emulator::Kill(bool allow_autoexit, bool savestate, savestate_stage* save_s
 
 	for (const auto& [type, data] : *g_fxo)
 	{
-		if (type.thread_op)
+		if (type.stop)
 		{
-			type.thread_op(data, thread_state::aborting);
+			type.stop(data, thread_state::aborting);
 		}
 	}
 
@@ -2928,9 +2928,9 @@ void Emulator::Kill(bool allow_autoexit, bool savestate, savestate_stage* save_s
 		// Join threads
 		for (const auto& [type, data] : *g_fxo)
 		{
-			if (type.thread_op)
+			if (type.stop)
 			{
-				type.thread_op(data, thread_state::finished);
+				type.stop(data, thread_state::finished);
 			}
 		}
 
diff --git a/rpcs3/Emu/VFS.cpp b/rpcs3/Emu/VFS.cpp
index d5952eeac..43ae1cdbc 100644
--- a/rpcs3/Emu/VFS.cpp
+++ b/rpcs3/Emu/VFS.cpp
@@ -144,10 +144,8 @@ bool vfs::unmount(std::string_view vpath)
 
 	vfs_log.notice("About to unmount '%s'", vpath);
 
-	if (!g_fxo->is_init<vfs_manager>())
-	{
-		return false;
-	}
+	// Workaround
+	g_fxo->need<vfs_manager>();
 
 	auto& table = g_fxo->get<vfs_manager>();
 
diff --git a/rpcs3/util/auto_typemap.hpp b/rpcs3/util/auto_typemap.hpp
index 58f5b7d25..fba32e74a 100644
--- a/rpcs3/util/auto_typemap.hpp
+++ b/rpcs3/util/auto_typemap.hpp
@@ -44,7 +44,6 @@ namespace stx
 			static void call_dtor(void* ptr) noexcept
 			{
 				std::launder(static_cast<T*>(ptr))->~T();
-				std::memset(ptr, 0xCC, sizeof(T)); // Set to trap values
 			}
 
 			template <typename T>
@@ -94,11 +93,9 @@ namespace stx
 			{
 				ensure(Size >= stx::typelist<typeinfo>().size());
 				ensure(Align >= stx::typelist<typeinfo>().align());
+				m_data[0] = 0;
 			}
 
-			// Set to trap values
-			std::memset(Size == 0 ? m_list : m_data, 0xCC, stx::typelist<typeinfo>().size());
-
 			for (const auto& type : stx::typelist<typeinfo>())
 			{
 				const u32 id = type.index();
diff --git a/rpcs3/util/fixed_typemap.hpp b/rpcs3/util/fixed_typemap.hpp
index 4df9c5789..5442c4175 100644
--- a/rpcs3/util/fixed_typemap.hpp
+++ b/rpcs3/util/fixed_typemap.hpp
@@ -15,8 +15,6 @@ extern thread_local std::string_view g_tls_serialize_name;
 
 namespace stx
 {
-	struct launch_retainer{};
-
 	// Simplified typemap with exactly one object of each used type, non-moveable. Initialized on init(). Destroyed on clear().
 	template <typename Tag /*Tag should be unique*/, u32 Size = 0, u32 Align = (Size ? 64 : __STDCPP_DEFAULT_NEW_ALIGNMENT__)>
 	class alignas(Align) manual_typemap
@@ -64,7 +62,7 @@ namespace stx
 		struct typeinfo
 		{
 			bool(*create)(uchar* ptr, manual_typemap&, utils::serial*, std::string_view) noexcept = nullptr;
-			void(*thread_op)(void* ptr, thread_state) noexcept = nullptr;
+			void(*stop)(void* ptr, thread_state) noexcept = nullptr;
 			void(*save)(void* ptr, utils::serial&) noexcept = nullptr;
 			void(*destroy)(void* ptr) noexcept = nullptr;
 			std::string_view name;
@@ -74,19 +72,13 @@ namespace stx
 			{
 				if (ar)
 				{
-					if constexpr (std::is_constructible_v<T, exact_t<manual_typemap&>, exact_t<utils::serial&>>)
+					if constexpr (std::is_constructible_v<T, manual_typemap&, exact_t<utils::serial&>>)
 					{
 						g_tls_serialize_name = name;
 						new (ptr) T(_this, exact_t<utils::serial&>(*ar));
 						return true;
 					}
 
-					if constexpr (std::is_constructible_v<T, exact_t<const launch_retainer&>, exact_t<utils::serial&>>)
-					{
-						new (ptr) T(exact_t<const launch_retainer&>(launch_retainer{}), exact_t<utils::serial&>(*ar));
-						return true;
-					}
-
 					if constexpr (std::is_constructible_v<T, exact_t<utils::serial&>>)
 					{
 						g_tls_serialize_name = name;
@@ -96,18 +88,12 @@ namespace stx
 				}
 
 				// Allow passing reference to "this"
-				if constexpr (std::is_constructible_v<T, exact_t<manual_typemap&>>)
+				if constexpr (std::is_constructible_v<T, manual_typemap&>)
 				{
 					new (ptr) T(_this);
 					return true;
 				}
 
-				if constexpr (std::is_constructible_v<T, exact_t<const launch_retainer&>>)
-				{
-					new (ptr) T(exact_t<const launch_retainer&>(launch_retainer{}));
-					return true;
-				}
-
 				// Call default constructor only if available
 				if constexpr (std::is_default_constructible_v<T>)
 				{
@@ -122,11 +108,10 @@ namespace stx
 			static void call_dtor(void* ptr) noexcept
 			{
 				std::launder(static_cast<T*>(ptr))->~T();
-				std::memset(ptr, 0xCC, sizeof(T)); // Set to trap values
 			}
 
 			template <typename T>
-			static void call_thread_op(void* ptr, thread_state state) noexcept
+			static void call_stop(void* ptr, thread_state state) noexcept
 			{
 				// Abort and/or join (expected thread_state::aborting or thread_state::finished)
 				*std::launder(static_cast<T*>(ptr)) = state;
@@ -149,7 +134,7 @@ namespace stx
 
 				if constexpr (std::is_assignable_v<T&, thread_state>)
 				{
-					r.thread_op = &call_thread_op<T>;
+					r.stop = &call_stop<T>;
 				}
 
 				if constexpr (!!(requires (T& a) { a.save(std::declval<stx::exact_t<utils::serial&>>()); }))
@@ -220,11 +205,9 @@ namespace stx
 			{
 				ensure(Size >= stx::typelist<typeinfo>().size());
 				ensure(Align >= stx::typelist<typeinfo>().align());
+				m_data[0] = 0;
 			}
 
-			// Set to trap values
-			std::memset(Size == 0 ? m_list : m_data, 0xCC, stx::typelist<typeinfo>().size());
-
 			*m_order++ = nullptr;
 			*m_info++ = nullptr;
 		}
@@ -250,8 +233,6 @@ namespace stx
 				return a.first < b.first;
 			});
 
-			const auto info_before = m_info;
-
 			for (pos = 0; pos < stx::typelist<typeinfo>().count(); pos++)
 			{
 				const auto& type = *order[pos].second;
@@ -279,15 +260,6 @@ namespace stx
 				}
 			}
 
-			// Launch threads
-			for (auto it = m_info; it != info_before; it--)
-			{
-				if (auto op = (*std::prev(it))->thread_op)
-				{
-					op(*std::prev(m_order, m_info - it + 1), thread_state{});
-				}
-			}
-
 			g_tls_serialize_name = {};
 		}
 
@@ -396,17 +368,15 @@ namespace stx
 		}
 
 		// Explicitly initialize object of type T possibly with dynamic type As and arguments
-		template <typename T, typename As = T, typename... Args> requires (std::is_constructible_v<std::decay_t<As>, Args&&...>)
+		template <typename T, typename As = T, typename... Args>
 		As* init(Args&&... args) noexcept
 		{
-			if (m_init[stx::typeindex<typeinfo, std::decay_t<T>, std::decay_t<As>>()])
+			if (std::exchange(m_init[stx::typeindex<typeinfo, std::decay_t<T>, std::decay_t<As>>()], true))
 			{
 				// Already exists, recreation is not supported (may be added later)
 				return nullptr;
 			}
 
-			m_init[stx::typeindex<typeinfo, std::decay_t<T>, std::decay_t<As>>()] = true;
-
 			As* obj = nullptr;
 
 			g_tls_serialize_name = get_name<T, As>();
@@ -473,7 +443,7 @@ namespace stx
 		{
 			if (is_init<T>())
 			{
-				[[likely]] return std::addressof(get<T>());
+				[[likely]] return &get<T>();
 			}
 
 			[[unlikely]] return nullptr;
diff --git a/rpcs3/util/types.hpp b/rpcs3/util/types.hpp
index 819496256..aa1fd5c4c 100644
--- a/rpcs3/util/types.hpp
+++ b/rpcs3/util/types.hpp
@@ -1185,21 +1185,13 @@ namespace stx
 	template <typename T>
 	struct exact_t
 	{
-		static_assert(std::is_reference_v<T> || std::is_convertible_v<T, const T&>);
-
 		T obj;
 
-		explicit exact_t(T&& _obj) : obj(std::forward<T>(_obj)) {}
-		exact_t& operator=(const exact_t&) = delete;
+		exact_t(T&& _obj) : obj(std::forward<T>(_obj)) {}
 
+		// TODO: More conversions
 		template <typename U> requires (std::is_same_v<U&, T>)
-		operator U&() const noexcept { return obj; };
-
-		template <typename U> requires (std::is_same_v<const U&, T>)
-		operator const U&() const noexcept { return obj; };
-
-		template <typename U> requires (std::is_same_v<U, T> && std::is_copy_constructible_v<T>)
-		operator U() const noexcept { return obj; };
+		operator U&() const { return obj; };
 	};
 }
 
