diff --git a/rpcs3/Emu/Cell/PPUAnalyser.cpp b/rpcs3/Emu/Cell/PPUAnalyser.cpp
index d3ba3e142..3ba3cab56 100644
--- a/rpcs3/Emu/Cell/PPUAnalyser.cpp
+++ b/rpcs3/Emu/Cell/PPUAnalyser.cpp
@@ -587,23 +587,6 @@ bool ppu_module::analyse(u32 lib_toc, u32 entry, const u32 sec_end, const std::b
 		return false;
 	};
 
-	auto can_trap_continue = [](ppu_opcode_t op, ppu_itype::type type)
-	{
-		if ((op.bo & 0x1c) == 0x1c || (op.bo & 0x7) == 0x7)
-		{
-			// All signed or unsigned <=>, must be true
-			return false;
-		}
-
-		if (op.simm16 == 0 && (type == ppu_itype::TWI || type == ppu_itype::TDI) && (op.bo & 0x5) == 0x5)
-		{
-			// Logically greater or equal to 0
-			return false;
-		}
-
-		return true;
-	};
-
 	// Register new function
 	auto add_func = [&](u32 addr, u32 toc, u32 caller) -> ppu_function&
 	{
@@ -1412,9 +1395,9 @@ bool ppu_module::analyse(u32 lib_toc, u32 entry, const u32 sec_end, const std::b
 					block.second = _ptr.addr() - block.first;
 					break;
 				}
-				else if (type & ppu_itype::trap && op.bo)
+				else if (type == ppu_itype::TW || type == ppu_itype::TWI || type == ppu_itype::TD || type == ppu_itype::TDI)
 				{
-					if (can_trap_continue(op, type))
+					if (op.bo != 31)
 					{
 						add_block(_ptr.addr());
 					}
@@ -1640,8 +1623,6 @@ bool ppu_module::analyse(u32 lib_toc, u32 entry, const u32 sec_end, const std::b
 		end = 0;
 	}
 
-	u32 per_instruction_bytes = 0;
-
 	for (auto&& [_, func] : as_rvalue(fmap))
 	{
 		if (func.attr & ppu_attr::no_size && entry)
@@ -1660,7 +1641,6 @@ bool ppu_module::analyse(u32 lib_toc, u32 entry, const u32 sec_end, const std::b
 				block.attr = ppu_attr::no_size;
 			}
 
-			per_instruction_bytes += utils::sub_saturate<u32>(lim, func.addr);
 			continue;
 		}
 
@@ -1741,8 +1721,11 @@ bool ppu_module::analyse(u32 lib_toc, u32 entry, const u32 sec_end, const std::b
 	u32 exp = start;
 	u32 lim = end;
 
-	// Start with full scan
-	block_queue.emplace_back(exp, lim);
+	// Start with full scan (disabled for PRX for now)
+	if (entry)
+	{
+		block_queue.emplace_back(exp, lim);
+	}
 
 	// Add entries from patches (on per-instruction basis)
 	for (u32 addr : applied)
@@ -1776,17 +1759,14 @@ bool ppu_module::analyse(u32 lib_toc, u32 entry, const u32 sec_end, const std::b
 		{
 			u32 i_pos = exp;
 
-			u32 block_edges[16];
-			u32 edge_count = 0;
-
 			bool is_good = true;
 			bool is_fallback = true;
 
 			for (; i_pos < lim; i_pos += 4)
 			{
-				const ppu_opcode_t op{get_ref<u32>(i_pos)};
+				const u32 opc = get_ref<u32>(i_pos);
 
-				switch (auto type = s_ppu_itype.decode(op.opcode))
+				switch (auto type = s_ppu_itype.decode(opc))
 				{
 				case ppu_itype::UNK:
 				case ppu_itype::ECIWX:
@@ -1796,58 +1776,28 @@ bool ppu_module::analyse(u32 lib_toc, u32 entry, const u32 sec_end, const std::b
 					is_good = false;
 					break;
 				}
-				case ppu_itype::TDI:
-				case ppu_itype::TWI:
-				{
-					if (op.bo && (op.ra == 1u || op.ra == 13u || op.ra == 2u))
-					{
-						// Non-user registers, checking them against a constant value makes no sense
-						is_good = false;
-						break;
-					}
-
-					[[fallthrough]];
-				}
 				case ppu_itype::TD:
+				case ppu_itype::TDI:
 				case ppu_itype::TW:
-				{
-					if (!op.bo)
-					{
-						continue;
-					}
-
-					if (!can_trap_continue(op, type))
-					{
-						is_fallback = false;
-					}
-
-					[[fallthrough]];
-				}
+				case ppu_itype::TWI:
 				case ppu_itype::B:
 				case ppu_itype::BC:
 				{
-					if (type == ppu_itype::B || (type == ppu_itype::BC && (op.bo & 0x14) == 0x14))
+					if (type == ppu_itype::B)
 					{
 						is_fallback = false;
 					}
 
 					if (type == ppu_itype::B || type == ppu_itype::BC)
 					{
-						if (type == ppu_itype::BC && (op.bo & 0x14) == 0x14 && op.bo & 0xB)
-						{
-							// Invalid form
-							is_good = false;
-							break;
-						}
-
-						if (entry == 0 && op.aa)
+						if (entry == 0 && ppu_opcode_t{opc}.aa)
 						{
 							// Ignore absolute branches in PIC (PRX)
 							is_good = false;
 							break;
 						}
 
-						const u32 target = (op.aa ? 0 : i_pos) + (type == ppu_itype::B ? +op.bt24 : +op.bt14);
+						const u32 target = (opc & 2 ? 0 : i_pos) + (type == ppu_itype::B ? +ppu_opcode_t{opc}.bt24 : +ppu_opcode_t{opc}.bt14);
 
 						if (target < segs[0].addr || target >= segs[0].addr + segs[0].size)
 						{
@@ -1856,45 +1806,6 @@ bool ppu_module::analyse(u32 lib_toc, u32 entry, const u32 sec_end, const std::b
 							break;
 						}
 
-						const ppu_opcode_t test_op{get_ref<u32>(target)};
-						const auto type0 = s_ppu_itype.decode(test_op.opcode);
-
-						if (type0 == ppu_itype::UNK)
-						{
-							is_good = false;
-							break;
-						}
-
-						// Test another instruction just in case (testing more is unlikely to improve results by much)
-
-						if (type0 == ppu_itype::SC || (type0 & ppu_itype::trap && !can_trap_continue(test_op, type0)))
-						{
-							// May not be followed by a valid instruction
-						}
-						else if (!(type0 & ppu_itype::branch))
-						{
-							if (target + 4 >= segs[0].addr + segs[0].size)
-							{
-								is_good = false;
-								break;
-							}
-
-							const auto type1 = s_ppu_itype.decode(get_ref<u32>(target + 4));
-
-							if (type1 == ppu_itype::UNK)
-							{
-								is_good = false;
-								break;
-							}
-						}
-						else if (u32 target0 = (test_op.aa ? 0 : target) + (type0 == ppu_itype::B ? +test_op.bt24 : +test_op.bt14);
-							(type0 == ppu_itype::B || type0 == ppu_itype::BC) && (target0 < segs[0].addr || target0 >= segs[0].addr + segs[0].size))
-						{
-							// Sanity check
-							is_good = false;
-							break;
-						}
-
 						if (target != i_pos && !fmap.contains(target))
 						{
 							if (block_set.count(target) == 0)
@@ -1912,44 +1823,27 @@ bool ppu_module::analyse(u32 lib_toc, u32 entry, const u32 sec_end, const std::b
 				case ppu_itype::BCLR:
 				case ppu_itype::SC:
 				{
-					if (type == ppu_itype::SC && op.opcode != ppu_instructions::SC(0) && op.opcode != ppu_instructions::SC(1))
+					if (type == ppu_itype::SC && opc != ppu_instructions::SC(0))
 					{
 						// Strict garbage filter
 						is_good = false;
 						break;
 					}
 
-					if (type == ppu_itype::BCCTR && op.opcode & 0xe000)
+					if (type == ppu_itype::BCCTR && opc & 0xe000)
 					{
 						// Garbage filter
 						is_good = false;
 						break;
 					}
 
-					if (type == ppu_itype::BCLR && op.opcode & 0xe000)
+					if (type == ppu_itype::BCLR && opc & 0xe000)
 					{
 						// Garbage filter
 						is_good = false;
 						break;
 					}
 
-					if (type == ppu_itype::BCCTR || type == ppu_itype::BCLR)
-					{
-						is_fallback = false;
-					}
-
-					if ((type & ppu_itype::branch && op.lk) || is_fallback)
-					{
-						// if farther instructions are valid: register all blocks
-						// Otherwise, register none (all or nothing)
-						if (edge_count < std::size(block_edges) && i_pos + 4 < lim)
-						{
-							block_edges[edge_count++] = i_pos + 4;
-							is_fallback = true; // Reset value
-							continue;
-						}
-					}
-
 					// Good block terminator found, add single block
 					break;
 				}
@@ -1980,23 +1874,17 @@ bool ppu_module::analyse(u32 lib_toc, u32 entry, const u32 sec_end, const std::b
 
 			if (is_good)
 			{
-				for (u32 it = 0, prev_addr = exp; it <= edge_count; it++)
-				{
-					const u32 block_end = it < edge_count ? block_edges[it] : i_pos;
-					const u32 block_begin = std::exchange(prev_addr, block_end);
+				auto& block = fmap[exp];
 
-					auto& block = fmap[block_begin];
+				if (!block.addr)
+				{
+					block.addr = exp;
+					block.size = i_pos - exp;
+					ppu_log.trace("Block __0x%x added (size=0x%x)", block.addr, block.size);
 
-					if (!block.addr)
+					if (get_limit(exp) == end)
 					{
-						block.addr = block_begin;
-						block.size = block_end - block_begin;
-						ppu_log.trace("Block __0x%x added (size=0x%x)", block.addr, block.size);
-
-						if (get_limit(block_begin) == end)
-						{
-							block.attr += ppu_attr::no_size;
-						}
+						block.attr += ppu_attr::no_size;
 					}
 				}
 			}
@@ -2019,8 +1907,9 @@ bool ppu_module::analyse(u32 lib_toc, u32 entry, const u32 sec_end, const std::b
 	// Convert map to vector (destructive)
 	for (auto&& [_, block] : as_rvalue(std::move(fmap)))
 	{
-		if (block.attr & ppu_attr::no_size && block.size > 4)
+		if (block.attr & ppu_attr::no_size && block.size > 4 && entry)
 		{
+			// Disabled for PRX for now
 			ppu_log.warning("Block 0x%x will be compiled on per-instruction basis (size=0x%x)", block.addr, block.size);
 
 			for (u32 addr = block.addr; addr < block.addr + block.size; addr += 4)
@@ -2032,19 +1921,12 @@ bool ppu_module::analyse(u32 lib_toc, u32 entry, const u32 sec_end, const std::b
 				i.attr = ppu_attr::no_size;
 			}
 
-			per_instruction_bytes += block.size;
 			continue;
 		}
 
 		funcs.emplace_back(std::move(block));
 	}
 
-	if (per_instruction_bytes)
-	{
-		const bool error = per_instruction_bytes >= 200 && per_instruction_bytes / 4 >= utils::aligned_div<u32>(funcs.size(), 128);
-		(error ? ppu_log.error : ppu_log.notice)("%d instructions will be compiled on per-instruction basis in total", per_instruction_bytes / 4);
-	}
-
 	ppu_log.notice("Block analysis: %zu blocks (%zu enqueued)", funcs.size(), block_queue.size());
 	return true;
 }
