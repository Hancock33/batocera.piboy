From c196f09833b447c0ec8816f921bde7116af46f05 Mon Sep 17 00:00:00 2001
From: Megamouse <studienricky89@googlemail.com>
Date: Sat, 22 May 2021 10:42:05 +0200
Subject: [PATCH] Qt6 port

---
 .ci/build-linux.sh                            |   5 -
 .ci/build-mac.sh                              |   7 +-
 .ci/install-freebsd.sh                        |   8 +-
 .ci/setup-windows.sh                          |  19 +-
 .cirrus.yml                                   |   8 +-
 3rdparty/qt5.cmake                            |  45 ----
 3rdparty/qt6.cmake                            |  45 ++++
 BUILDING.md                                   |  23 +-
 azure-pipelines.yml                           |   6 +-
 rpcs3/CMakeLists.txt                          |  30 +--
 rpcs3/Emu/Cell/Modules/cellCamera.cpp         |   1 -
 rpcs3/Emu/Io/camera_config.cpp                |   8 +-
 rpcs3/Emu/Io/camera_config.h                  |   2 -
 rpcs3/Emu/Io/camera_handler_base.h            |   3 +-
 rpcs3/Emu/RSX/display.h                       |   2 +-
 rpcs3/Input/basic_mouse_handler.cpp           |   5 +-
 rpcs3/Input/keyboard_pad_handler.cpp          |  11 +-
 rpcs3/main.cpp                                |   9 +-
 rpcs3/main_application.cpp                    |   2 +-
 rpcs3/rpcs3.vcxproj                           |  21 +-
 rpcs3/rpcs3.vcxproj.filters                   |   4 +-
 rpcs3/rpcs3qt/CMakeLists.txt                  |   4 +-
 rpcs3/rpcs3qt/camera_settings_dialog.cpp      | 167 +++++++--------
 rpcs3/rpcs3qt/camera_settings_dialog.h        |   4 +-
 rpcs3/rpcs3qt/camera_settings_dialog.ui       |   6 +-
 rpcs3/rpcs3qt/config_checker.cpp              |   6 +-
 rpcs3/rpcs3qt/custom_table_widget_item.cpp    |  28 +--
 rpcs3/rpcs3qt/gs_frame.h                      |   2 +-
 rpcs3/rpcs3qt/gui_application.cpp             |  15 +-
 rpcs3/rpcs3qt/gui_application.h               |   3 +
 rpcs3/rpcs3qt/main_window.cpp                 |  32 ++-
 rpcs3/rpcs3qt/main_window.h                   |   4 +-
 rpcs3/rpcs3qt/osk_dialog_frame.cpp            |   2 +-
 rpcs3/rpcs3qt/progress_indicator.cpp          |  18 +-
 rpcs3/rpcs3qt/progress_indicator.h            |   4 +-
 rpcs3/rpcs3qt/qt_camera_error_handler.cpp     |  60 +-----
 rpcs3/rpcs3qt/qt_camera_error_handler.h       |  12 +-
 rpcs3/rpcs3qt/qt_camera_handler.cpp           | 196 +++++++-----------
 rpcs3/rpcs3qt/qt_camera_handler.h             |  12 +-
 ...o_surface.cpp => qt_camera_video_sink.cpp} |  73 ++-----
 ...video_surface.h => qt_camera_video_sink.h} |  12 +-
 rpcs3/rpcs3qt/qt_music_error_handler.cpp      |  24 +--
 rpcs3/rpcs3qt/qt_music_error_handler.h        |   4 +-
 rpcs3/rpcs3qt/qt_music_handler.cpp            |  17 +-
 rpcs3/rpcs3qt/qt_utils.h                      |   2 +-
 rpcs3/rpcs3qt/register_editor_dialog.cpp      |   2 +-
 rpcs3/rpcs3qt/save_manager_dialog.cpp         |   1 -
 rpcs3/rpcs3qt/settings_dialog.cpp             |   8 +-
 rpcs3/rpcs3qt/trophy_manager_dialog.cpp       |   1 -
 rpcs3/rpcs3qt/user_manager_dialog.cpp         |   1 -
 50 files changed, 401 insertions(+), 583 deletions(-)
 delete mode 100644 3rdparty/qt5.cmake
 create mode 100644 3rdparty/qt6.cmake
 rename rpcs3/rpcs3qt/{qt_camera_video_surface.cpp => qt_camera_video_sink.cpp} (78%)
 rename rpcs3/rpcs3qt/{qt_camera_video_surface.h => qt_camera_video_sink.h} (66%)
 
diff --git a/.ci/build-linux.sh b/.ci/build-linux.sh
index 2728f2faa..a0e609efb 100755
--- a/.ci/build-linux.sh
+++ b/.ci/build-linux.sh
@@ -1,10 +1,5 @@
 #!/bin/sh -ex
 
-# Setup Qt variables
-export QT_BASE_DIR=/opt/qt"${QTVERMIN}"
-export PATH="$QT_BASE_DIR"/bin:"$PATH"
-export LD_LIBRARY_PATH="$QT_BASE_DIR"/lib/x86_64-linux-gnu:"$QT_BASE_DIR"/lib
-
 if [ -z "$CIRRUS_CI" ]; then
    cd rpcs3 || exit 1
 fi
diff --git a/.ci/build-mac.sh b/.ci/build-mac.sh
index eb8212d79..9a0916fac 100755
--- a/.ci/build-mac.sh
+++ b/.ci/build-mac.sh
@@ -28,13 +28,14 @@ git clone https://github.com/engnr/qt-downloader.git
 cd qt-downloader
 git checkout f52efee0f18668c6d6de2dec0234b8c4bc54c597
 "/opt/homebrew/bin/pipenv" run pip3 install py7zr requests semantic_version lxml
-"/opt/homebrew/bin/pipenv" run ./qt-downloader macos desktop 5.15.2 clang_64 --opensource
+mkdir -p "6.5.0/macos" ; ln -s "macos" "6.5.0/clang_64"
+"/opt/homebrew/bin/pipenv" run ./qt-downloader macos desktop "$QT_VER" clang_64 --opensource --addons qtmultimedia
 cd ..
 
-export Qt5_DIR="$WORKDIR/qt-downloader/5.15.2/clang_64/lib/cmake/Qt5"
+export Qt6_DIR="$WORKDIR/qt-downloader/$QT_VER/clang_64/lib/cmake/Qt$QT_VER_MAIN"
 export SDL2_DIR="$BREW_X64_PATH/opt/sdl2/lib/cmake/SDL2"
 
-export PATH="$BREW_X64_PATH/opt/llvm@16/bin:$WORKDIR/qt-downloader/5.15.2/clang_64/bin:$BREW_BIN:$BREW_SBIN:/usr/bin:/bin:/usr/sbin:/sbin:/opt/X11/bin:/Library/Apple/usr/bin:$PATH"
+export PATH="$BREW_X64_PATH/opt/llvm@16/bin:$WORKDIR/qt-downloader/$QT_VER/clang_64/bin:$BREW_BIN:$BREW_SBIN:/usr/bin:/bin:/usr/sbin:/sbin:/opt/X11/bin:/Library/Apple/usr/bin:$PATH"
 export LDFLAGS="-L$BREW_X64_PATH/lib -Wl,-rpath,$BREW_X64_PATH/lib"
 export CPPFLAGS="-I$BREW_X64_PATH/include -msse -msse2 -mcx16 -no-pie"
 export LIBRARY_PATH="$BREW_X64_PATH/lib"
diff --git a/.ci/install-freebsd.sh b/.ci/install-freebsd.sh
index 8f0efd306..10c75140b 100755
--- a/.ci/install-freebsd.sh
+++ b/.ci/install-freebsd.sh
@@ -2,7 +2,7 @@
 # NOTE: this script is run under root permissions
 # shellcheck shell=sh disable=SC2096
 
-# RPCS3 often needs recent Qt5 and Vulkan-Headers
+# RPCS3 often needs recent Qt and Vulkan-Headers
 #sed -i '' 's/quarterly/latest/' /etc/pkg/FreeBSD.conf
 
 export ASSUME_ALWAYS_YES=true
@@ -11,8 +11,8 @@ pkg info # debug
 # Prefer newer Clang than in base system (see also .ci/build-freebsd.sh)
 pkg install llvm16
 
-# Mandatory dependencies (qt5-dbus and qt5-gui are pulled via qt5-widgets)
-pkg install git ccache cmake ninja qt5-qmake qt5-buildtools qt5-widgets qt5-concurrent qt5-multimedia qt5-svg glew openal-soft ffmpeg
+# Mandatory dependencies (qt6-base and qt6-svg are pulled via qt6-multimedia)
+pkg install git ccache cmake ninja qt6-multimedia glew openal-soft ffmpeg
 
-# Optional dependencies (libevdev is pulled by qt5-gui)
+# Optional dependencies (libevdev is pulled by qt6-base)
 pkg install pkgconf alsa-lib pulseaudio sdl2 evdev-proto vulkan-headers vulkan-loader
diff --git a/.ci/setup-windows.sh b/.ci/setup-windows.sh
index 614ca9e98..0d7974f1f 100755
--- a/.ci/setup-windows.sh
+++ b/.ci/setup-windows.sh
@@ -11,25 +11,26 @@ PR_NUMBER="$SYSTEM_PULLREQUEST_PULLREQUESTID"
 QT_HOST="http://qt.mirror.constant.com/"
 QT_URL_VER=$(echo "$QT_VER" | sed "s/\.//g")
 QT_VER_MSVC_UP=$(echo "${QT_VER_MSVC}" | tr '[:lower:]' '[:upper:]')
-QT_PREFIX="online/qtsdkrepository/windows_x86/desktop/qt${QT_VER_MAIN}_${QT_URL_VER}/qt.qt${QT_VER_MAIN}.${QT_URL_VER}.win64_${QT_VER_MSVC}_64/${QT_VER}-0-${QT_DATE}"
-QT_SUFFIX="-Windows-Windows_10-${QT_VER_MSVC_UP}-Windows-Windows_10-X86_64.7z"
-QT_BASE_URL="${QT_HOST}${QT_PREFIX}qtbase${QT_SUFFIX}"
-QT_WINE_URL="${QT_HOST}${QT_PREFIX}qtwinextras${QT_SUFFIX}"
-QT_DECL_URL="${QT_HOST}${QT_PREFIX}qtdeclarative${QT_SUFFIX}"
-QT_TOOL_URL="${QT_HOST}${QT_PREFIX}qttools${QT_SUFFIX}"
-QT_MM_URL="${QT_HOST}${QT_PREFIX}qtmultimedia${QT_SUFFIX}"
-QT_SVG_URL="${QT_HOST}${QT_PREFIX}qtsvg${QT_SUFFIX}"
+QT_PREFIX="online/qtsdkrepository/windows_x86/desktop/qt${QT_VER_MAIN}_${QT_URL_VER}/qt.qt${QT_VER_MAIN}.${QT_URL_VER}."
+QT_PREFIX_2="win64_${QT_VER_MSVC}_64/${QT_VER}-0-${QT_DATE}"
+QT_SUFFIX="-Windows-Windows_10_22H2-${QT_VER_MSVC_UP}-Windows-Windows_10_22H2-X86_64.7z"
+QT_BASE_URL="${QT_HOST}${QT_PREFIX}${QT_PREFIX_2}qtbase${QT_SUFFIX}"
+QT_DECL_URL="${QT_HOST}${QT_PREFIX}${QT_PREFIX_2}qtdeclarative${QT_SUFFIX}"
+QT_TOOL_URL="${QT_HOST}${QT_PREFIX}${QT_PREFIX_2}qttools${QT_SUFFIX}"
+QT_MM_URL="${QT_HOST}${QT_PREFIX}addons.qtmultimedia.${QT_PREFIX_2}qtmultimedia${QT_SUFFIX}"
+QT_SVG_URL="${QT_HOST}${QT_PREFIX}${QT_PREFIX_2}qtsvg${QT_SUFFIX}"
+QT_5CMP_URL="${QT_HOST}${QT_PREFIX}qt5compat.${QT_PREFIX_2}qt5compat${QT_SUFFIX}"
 LLVMLIBS_URL='https://github.com/RPCS3/llvm-mirror/releases/download/custom-build-win-16.0.1/llvmlibs_mt.7z'
 GLSLANG_URL='https://github.com/RPCS3/glslang/releases/download/custom-build-win/glslanglibs_mt.7z'
 VULKAN_SDK_URL="https://www.dropbox.com/s/cs77c3iv5mbo0bt/VulkanSDK-${VULKAN_VER}-Installer.exe"
 
 DEP_URLS="         \
     $QT_BASE_URL   \
-    $QT_WINE_URL   \
     $QT_DECL_URL   \
     $QT_TOOL_URL   \
     $QT_MM_URL     \
     $QT_SVG_URL    \
+    $QT_5CMP_URL   \
     $LLVMLIBS_URL  \
     $GLSLANG_URL   \
     $VULKAN_SDK_URL"
diff --git a/.cirrus.yml b/.cirrus.yml
index 7fa2bf79f..79b578cc8 100644
--- a/.cirrus.yml
+++ b/.cirrus.yml
@@ -6,6 +6,8 @@ env:
   BUILD_SOURCEVERSION: $CIRRUS_CHANGE_IN_REPO
   BUILD_SOURCEBRANCHNAME: $CIRRUS_BRANCH
   RPCS3_TOKEN: ENCRYPTED[!a4c3850e29ab150692286a74bec29819d25971a7ec431b86de2a35f7ed90c5b2ab3c93469f9298e30924d843599110e9!]
+  QT_VER_MAIN: '6'
+  QT_VER: '6.5.0'
 
 windows_task:
   matrix:
@@ -17,11 +19,9 @@ windows_task:
   env:
     CIRRUS_SHELL: "bash"
     COMPILER: msvc
-    QT_VER_MAIN: '5'
     BUILD_ARTIFACTSTAGINGDIRECTORY: ${CIRRUS_WORKING_DIR}\artifacts\
-    QT_VER: '5.15.2'
     QT_VER_MSVC: 'msvc2019'
-    QT_DATE: '202011130602'
+    QT_DATE: '202303290841'
     QTDIR: C:\Qt\${QT_VER}\${QT_VER_MSVC}_64
     VULKAN_VER: '1.3.224.1'
     VULKAN_SDK_SHA: '2029e652e39ee6a6036cff3765da31e1e6c595fd2413d3cd111dfab7855621ea'
@@ -61,7 +61,7 @@ windows_task:
 
 linux_task:
   container:
-    image: rpcs3/rpcs3-ci-bionic:1.8
+    image: rpcs3/rpcs3-ci-focal:1.0
     cpu: 4
     memory: 16G
   env:
diff --git a/3rdparty/qt5.cmake b/3rdparty/qt5.cmake
deleted file mode 100644
index ed42399f9..000000000
--- a/3rdparty/qt5.cmake
+++ /dev/null
@@ -1,45 +0,0 @@
-add_library(3rdparty_qt5 INTERFACE)
-
-set(QT_MIN_VER 5.15.2)
-
-find_package(Qt5 ${QT_MIN_VER} CONFIG COMPONENTS Widgets Concurrent Multimedia MultimediaWidgets Svg)
-if(WIN32)
-	find_package(Qt5 ${QT_MIN_VER} COMPONENTS WinExtras REQUIRED)
-	target_link_libraries(3rdparty_qt5 INTERFACE Qt5::Widgets Qt5::WinExtras Qt5::Concurrent Qt5::Multimedia Qt5::MultimediaWidgets Qt5::Svg)
-else()
-	find_package(Qt5 ${QT_MIN_VER} COMPONENTS DBus Gui)
-	if(Qt5DBus_FOUND)
-		target_link_libraries(3rdparty_qt5 INTERFACE Qt5::Widgets Qt5::DBus Qt5::Concurrent Qt5::Multimedia Qt5::MultimediaWidgets Qt5::Svg)
-		target_compile_definitions(3rdparty_qt5 INTERFACE -DHAVE_QTDBUS)
-	else()
-		target_link_libraries(3rdparty_qt5 INTERFACE Qt5::Widgets Qt5::Concurrent Qt5::Multimedia Qt5::MultimediaWidgets Qt5::Svg)
-	endif()
-	target_include_directories(3rdparty_qt5 INTERFACE ${Qt5Gui_PRIVATE_INCLUDE_DIRS})
-endif()
-
-if(NOT Qt5Widgets_FOUND)
-	if(Qt5Widgets_VERSION VERSION_LESS ${QT_MIN_VER})
-		message("Minimum supported Qt5 version is ${QT_MIN_VER}! You have version ${Qt5Widgets_VERSION} installed, please upgrade!")
-		if(CMAKE_SYSTEM MATCHES "Linux")
-			message(FATAL_ERROR "Most distros do not provide an up-to-date version of Qt.
-If you're on Ubuntu or Linux Mint, there are PPAs you can use to install one of the latest qt5 versions.
-Find the correct ppa at https://launchpad.net/~beineri and follow the instructions.")
-		elseif(WIN32)
-			message(FATAL_ERROR "You can download the latest version of Qt5 here: https://www.qt.io/download-open-source/")
-		else()
-			message(FATAL_ERROR "Look online for instructions on installing an up-to-date Qt5 on ${CMAKE_SYSTEM}.")
-		endif()
-	endif()
-
-	message("CMake was unable to find Qt5!")
-	if(WIN32)
-		message(FATAL_ERROR "Make sure the QTDIR env variable has been set properly. (for example C:\\Qt\\${QT_MIN_VER}\\msvc2019_64\\)
-You can also try setting the Qt5_DIR preprocessor definiton.")
-	elseif(CMAKE_SYSTEM MATCHES "Linux")
-		message(FATAL_ERROR "Make sure to install your distro's qt5 package!")
-	else()
-		message(FATAL_ERROR "You need to have Qt5 installed, look online for instructions on installing Qt5 on ${CMAKE_SYSTEM}.")
-	endif()
-endif()
-
-add_library(3rdparty::qt5 ALIAS 3rdparty_qt5)
diff --git a/3rdparty/qt6.cmake b/3rdparty/qt6.cmake
new file mode 100644
index 000000000..d25c7a7be
--- /dev/null
+++ b/3rdparty/qt6.cmake
@@ -0,0 +1,45 @@
+add_library(3rdparty_qt6 INTERFACE)
+
+set(QT_MIN_VER 6.4.0)
+
+find_package(Qt6 ${QT_MIN_VER} CONFIG COMPONENTS Widgets Concurrent Multimedia MultimediaWidgets Svg SvgWidgets)
+if(WIN32)
+	find_package(Qt6 ${QT_MIN_VER} COMPONENTS WinExtras REQUIRED)
+	target_link_libraries(3rdparty_qt6 INTERFACE Qt6::Widgets Qt6::WinExtras Qt6::Concurrent Qt6::Multimedia Qt6::MultimediaWidgets Qt6::Svg Qt6::SvgWidgets)
+else()
+	find_package(Qt6 ${QT_MIN_VER} COMPONENTS DBus Gui)
+	if(Qt6DBus_FOUND)
+		target_link_libraries(3rdparty_qt6 INTERFACE Qt6::Widgets Qt6::DBus Qt6::Concurrent Qt6::Multimedia Qt6::MultimediaWidgets Qt6::Svg Qt6::SvgWidgets)
+		target_compile_definitions(3rdparty_qt6 INTERFACE -DHAVE_QTDBUS)
+	else()
+		target_link_libraries(3rdparty_qt6 INTERFACE Qt6::Widgets Qt6::Concurrent Qt6::Multimedia Qt6::MultimediaWidgets Qt6::Svg Qt6::SvgWidgets)
+	endif()
+	target_include_directories(3rdparty_qt6 INTERFACE ${Qt6Gui_PRIVATE_INCLUDE_DIRS})
+endif()
+
+if(Qt6Widgets_FOUND)
+	if(Qt6Widgets_VERSION VERSION_LESS ${QT_MIN_VER})
+		message("Minimum supported Qt version is ${QT_MIN_VER}! You have version ${Qt6Widgets_VERSION} installed, please upgrade!")
+		if(CMAKE_SYSTEM MATCHES "Linux")
+			message(FATAL_ERROR "Most distros do not provide an up-to-date version of Qt.
+If you're on Ubuntu or Linux Mint, there are PPAs you can use to install one of the latest qt6 versions.
+Find the correct ppa at https://launchpad.net/~beineri and follow the instructions.")
+		elseif(WIN32)
+			message(FATAL_ERROR "You can download the latest version of Qt6 here: https://www.qt.io/download-open-source/")
+		else()
+			message(FATAL_ERROR "Look online for instructions on installing an up-to-date Qt6 on ${CMAKE_SYSTEM}.")
+		endif()
+	endif()
+else()
+	message("CMake was unable to find Qt6!")
+	if(WIN32)
+		message(FATAL_ERROR "Make sure the QTDIR env variable has been set properly. (for example C:\\Qt\\${QT_MIN_VER}\\msvc2019_64\\)
+You can also try setting the Qt6_DIR preprocessor definiton.")
+	elseif(CMAKE_SYSTEM MATCHES "Linux")
+		message(FATAL_ERROR "Make sure to install your distro's qt6 package!")
+	else()
+		message(FATAL_ERROR "You need to have Qt6 installed, look online for instructions on installing Qt6 on ${CMAKE_SYSTEM}.")
+	endif()
+endif()
+
+add_library(3rdparty::qt6 ALIAS 3rdparty_qt6)
diff --git a/BUILDING.md b/BUILDING.md
index e141ed189..8371a5b34 100644
--- a/BUILDING.md
+++ b/BUILDING.md
@@ -9,11 +9,11 @@ Other instructions may be found [here](https://wiki.rpcs3.net/index.php?title=Bu
 
 * [CMake 3.16.9+](https://www.cmake.org/download/) (add to PATH)
 * [Python 3.6+](https://www.python.org/downloads/) (add to PATH)
-* [Qt 5.15.2](https://www.qt.io/download-qt-installer)
+* [Qt 6.5.0](https://www.qt.io/download-qt-installer)
 * [Visual Studio 2019](https://visualstudio.microsoft.com/thank-you-downloading-visual-studio/?sku=Community)
 * [Vulkan SDK 1.3.224+](https://vulkan.lunarg.com/sdk/home) (See "Install the SDK" [here](https://vulkan.lunarg.com/doc/sdk/latest/windows/getting_started.html))
 
-**Either add the** `QTDIR` **environment variable, e.g.** `<QtInstallFolder>\5.15.2\msvc2019_64\` **, or use the [Visual Studio Qt Plugin](https://marketplace.visualstudio.com/items?itemName=TheQtCompany.QtVisualStudioTools2019)**
+**Either add the** `QTDIR` **environment variable, e.g.** `<QtInstallFolder>\6.5.0\msvc2019_64\` **, or use the [Visual Studio Qt Plugin](https://marketplace.visualstudio.com/items?itemName=TheQtCompany.QtVisualStudioTools2019)**
 
 ### Linux
 
@@ -21,7 +21,7 @@ These are the essentials tools to build RPCS3 on Linux. Some of them can be inst
 
 * Clang 12+ or GCC 11+
 * [CMake 3.16.9+](https://www.cmake.org/download/)
-* [Qt 5.15.2](https://www.qt.io/download-qt-installer)
+* [Qt 6.5.0](https://www.qt.io/download-qt-installer)
 * [Vulkan SDK 1.3.224+](https://vulkan.lunarg.com/sdk/home) (See "Install the SDK" [here](https://vulkan.lunarg.com/doc/sdk/latest/linux/getting_started.html))
 * [SDL2](https://github.com/libsdl-org/SDL/releases) (for the FAudio backend)
 
@@ -29,7 +29,7 @@ These are the essentials tools to build RPCS3 on Linux. Some of them can be inst
 
 #### Arch Linux
 
-    sudo pacman -S glew openal cmake vulkan-validation-layers qt5-base qt5-declarative qt5-multimedia sdl2 sndio jack2 base-devel
+    sudo pacman -S glew openal cmake vulkan-validation-layers qt6-base qt6-declarative qt6-multimedia sdl2 sndio jack2 base-devel
 
 #### Debian & Ubuntu
 
@@ -38,14 +38,7 @@ These are the essentials tools to build RPCS3 on Linux. Some of them can be inst
 Ubuntu is usually horrendously out of date, and some packages need to be downloaded by hand. This part is for Qt, GCC, Vulkan, and CMake
 ##### Qt PPA
 
-Ubuntu usually does not have a new enough Qt package to suit rpcs3's needs. There is a PPA available to work around this. Run the following:
-```
-. /etc/os-release
-sudo add-apt-repository ppa:beineri/opt-qt-5.15.2-$UBUNTU_CODENAME
-sudo apt-get update
-sudo apt-get install qt515base qt515svg
-. /opt/qt515/bin/qt515-env.sh >/dev/null 2>&1
-```
+Ubuntu usually does not have a new enough Qt package to suit rpcs3's needs. There is currently no PPA available to work around this.
 
 ##### GCC 11.x installation
 
@@ -82,11 +75,11 @@ sudo apt-get install cmake
 
 #### Fedora
 
-    sudo dnf install alsa-lib-devel cmake glew glew-devel libatomic libevdev-devel libudev-devel openal-devel qt5-qtbase-devel qt5-qtbase-private-devel vulkan-devel pipewire-jack-audio-connection-kit-devel qt5-qtmultimedia-devel qt5-qtsvg-devel
+    sudo dnf install alsa-lib-devel cmake glew glew-devel libatomic libevdev-devel libudev-devel openal-devel qt6-qtbase-devel qt6-qtbase-private-devel vulkan-devel pipewire-jack-audio-connection-kit-devel qt6-qtmultimedia-devel qt6-qtsvg-devel
 
 #### OpenSUSE
 
-    sudo zypper install git cmake libasound2 libpulse-devel openal-soft-devel glew-devel zlib-devel libedit-devel vulkan-devel libudev-devel libqt5-qtbase-devel libqt5-qtmultimedia-devel libqt5-qtsvg-devel libQt5Gui-private-headers-devel libevdev-devel libsndio7_1 libjack-devel
+    sudo zypper install git cmake libasound2 libpulse-devel openal-soft-devel glew-devel zlib-devel libedit-devel vulkan-devel libudev-devel libqt6-qtbase-devel libqt6-qtmultimedia-devel libqt6-qtsvg-devel libQt6Gui-private-headers-devel libevdev-devel libsndio7_1 libjack-devel
 
 ## Setup the project
 
@@ -103,7 +96,7 @@ git submodule update --init
 #### Configuring the Qt plugin (if used)
 
 1) Go to `Extensions->Qt VS Tools->Qt Versions`.
-2) Add the path to your Qt installation with compiler e.g. `<QtInstallFolder>\5.15.2\msvc2019_64`, version will fill in automatically.
+2) Add the path to your Qt installation with compiler e.g. `<QtInstallFolder>\6.5.0\msvc2019_64`, version will fill in automatically.
 3) Go to `Extensions->Qt VS Tools->Options->Legacy Project Format`.
 4) Set `Build: Run pre-build setup` to `true`.
 
diff --git a/azure-pipelines.yml b/azure-pipelines.yml
index 67d18fe44..a064a2366 100644
--- a/azure-pipelines.yml
+++ b/azure-pipelines.yml
@@ -65,10 +65,10 @@ jobs:
 - job: Windows_Build
   variables:
     COMPILER: msvc
-    QT_VER_MAIN: '5'
-    QT_VER: '5.15.2'
+    QT_VER_MAIN: '6'
+    QT_VER: '6.5.0'
     QT_VER_MSVC: 'msvc2019'
-    QT_DATE: '202011130602'
+    QT_DATE: '202303290841'
     QTDIR: C:\Qt\$(QT_VER)\$(QT_VER_MSVC)_64
     VULKAN_VER: '1.3.224.1'
     VULKAN_SDK_SHA: '2029e652e39ee6a6036cff3765da31e1e6c595fd2413d3cd111dfab7855621ea'
diff --git a/rpcs3/CMakeLists.txt b/rpcs3/CMakeLists.txt
index e372c6650..95fdb7eb4 100644
--- a/rpcs3/CMakeLists.txt
+++ b/rpcs3/CMakeLists.txt
@@ -41,11 +41,11 @@ else()
     message("-- Using Custom RPCS3_SRC_DIR=${RPCS3_SRC_DIR}")
 endif()
 
-# Qt5
+# Qt6
 # finds Qt libraries and setups custom commands for MOC and UIC
 # Must be done here because generated MOC and UIC targets cant
 # be found otherwise
-include(${CMAKE_SOURCE_DIR}/3rdparty/qt5.cmake)
+include(${CMAKE_SOURCE_DIR}/3rdparty/qt6.cmake)
 
 # subdirectories
 add_subdirectory(Emu)
@@ -93,7 +93,7 @@ set_target_properties(rpcs3
         AUTOUIC ON)
 
 target_link_libraries(rpcs3 rpcs3_emu rpcs3_ui)
-target_link_libraries(rpcs3 3rdparty::discordRPC 3rdparty::qt5 3rdparty::hidapi 3rdparty::libusb 3rdparty::wolfssl 3rdparty::libcurl)
+target_link_libraries(rpcs3 3rdparty::discordRPC 3rdparty::qt6 3rdparty::hidapi 3rdparty::libusb 3rdparty::wolfssl 3rdparty::libcurl)
 target_link_libraries(rpcs3 ${ADDITIONAL_LIBS})
 
 # Win resource file
@@ -134,7 +134,7 @@ if(USE_PRECOMPILED_HEADERS)
     endif()
 endif()
 
-get_target_property(_qmake_executable Qt5::qmake IMPORTED_LOCATION)
+get_target_property(_qmake_executable Qt6::qmake IMPORTED_LOCATION)
 get_filename_component(_qt_bin_dir "${_qmake_executable}" DIRECTORY)
 find_program(MACDEPLOYQT_EXECUTABLE macdeployqt HINTS "${_qt_bin_dir}")
 
@@ -174,26 +174,26 @@ elseif(WIN32)
 
     # Qt installed from Qt installer has following hierarchy:
     # bin/ for release and debug dlls and windeployqt tools
-    # lib/cmake/Qt5/ for Qt5_Dir
+    # lib/cmake/Qt6/ for Qt6_Dir
     # Qt installed from vcpkg has following hierarchy:
     # bin/ for release dlls
     # debug/bin/ for debug dlls
-    # tools/qt5/bin/ for tools including windeployqt
-    # tools/qt5/debug/bin/ for tools with debug build including windeployqt
-    # share/cmake/Qt5/ for Qt5_Dir
+    # tools/qt6/bin/ for tools including windeployqt
+    # tools/qt6/debug/bin/ for tools with debug build including windeployqt
+    # share/cmake/Qt6/ for Qt6_Dir
 
-    # If Qt5 is installed from official Qt installer
-    list(APPEND _QT5_TOOLS_PATHS "${Qt5_DIR}/../../../bin/")
+    # If Qt6 is installed from official Qt installer
+    list(APPEND _QT6_TOOLS_PATHS "${Qt6_DIR}/../../../bin/")
 
-    # If Qt5 is installed from vcpkg
-    list(APPEND _QT5_TOOLS_PATHS "${Qt5_DIR}/../../../tools/qt5$<$<CONFIG:Debug>:/debug>/bin/")
+    # If Qt6 is installed from vcpkg
+    list(APPEND _QT6_TOOLS_PATHS "${Qt6_DIR}/../../../tools/qt6$<$<CONFIG:Debug>:/debug>/bin/")
 
     add_custom_command(TARGET rpcs3 POST_BUILD
-        COMMAND set PATH=${_QT5_TOOLS_PATHS}$<SEMICOLON>%PATH%
+        COMMAND set PATH=${_QT6_TOOLS_PATHS}$<SEMICOLON>%PATH%
         COMMAND "${CMAKE_COMMAND}" -E copy_directory "${CMAKE_SOURCE_DIR}/bin" "$<TARGET_FILE_DIR:rpcs3>"
-        # If Qt5 is installed from vcpkg, add binary path to PATH
+        # If Qt6 is installed from vcpkg, add binary path to PATH
         # otherwise windeployqt tool won't be able to locate necessary dlls
-        COMMAND set PATH=${Qt5_DIR}/../../../$<$<CONFIG:Debug>:debug/>bin/$<SEMICOLON>%PATH%
+        COMMAND set PATH=${Qt6_DIR}/../../../$<$<CONFIG:Debug>:debug/>bin/$<SEMICOLON>%PATH%
         COMMAND "${_WINDEPLOYQT}" --no-angle --no-compiler-runtime --no-opengl-sw --no-patchqt --no-translations --no-quick --plugindir "$<TARGET_FILE_DIR:rpcs3>/qt/plugins" $<$<CONFIG:Debug>:--debug> $<$<CONFIG:Release>:--release> "$<TARGET_FILE:rpcs3>")
 endif()
 
diff --git a/rpcs3/Emu/Cell/Modules/cellCamera.cpp b/rpcs3/Emu/Cell/Modules/cellCamera.cpp
index 7e6a631d4..76a59c11c 100644
--- a/rpcs3/Emu/Cell/Modules/cellCamera.cpp
+++ b/rpcs3/Emu/Cell/Modules/cellCamera.cpp
@@ -1891,7 +1891,6 @@ bool camera_context::on_handler_state(camera_handler_base::camera_handler_state
 {
 	switch (state)
 	{
-	case camera_handler_base::camera_handler_state::not_available:
 	case camera_handler_base::camera_handler_state::closed:
 	{
 		if (is_attached)
diff --git a/rpcs3/Emu/Io/camera_config.cpp b/rpcs3/Emu/Io/camera_config.cpp
index bcc19c578..dce03e8cd 100644
--- a/rpcs3/Emu/Io/camera_config.cpp
+++ b/rpcs3/Emu/Io/camera_config.cpp
@@ -67,7 +67,7 @@ void cfg_camera::set_camera_setting(const std::string& camera, const camera_sett
 
 std::string cfg_camera::camera_setting::to_string() const
 {
-	return fmt::format("%d,%d,%f,%f,%d,%d,%d", width, height, min_fps, max_fps, format, pixel_aspect_width, pixel_aspect_height);
+	return fmt::format("%d,%d,%f,%f,%d", width, height, min_fps, max_fps, format);
 }
 
 void cfg_camera::camera_setting::from_string(const std::string& text)
@@ -112,16 +112,12 @@ void cfg_camera::camera_setting::from_string(const std::string& text)
 		!to_integer(::at32(list, 1), height) ||
 		!to_double(::at32(list, 2), min_fps) ||
 		!to_double(::at32(list, 3), max_fps) ||
-		!to_integer(::at32(list, 4), format) ||
-		!to_integer(::at32(list, 5), pixel_aspect_width) ||
-		!to_integer(::at32(list, 6), pixel_aspect_height))
+		!to_integer(::at32(list, 4), format))
 	{
 		width = 0;
 		height = 0;
 		min_fps = 0;
 		max_fps = 0;
 		format = 0;
-		pixel_aspect_width = 0;
-		pixel_aspect_height = 0;
 	}
 }
diff --git a/rpcs3/Emu/Io/camera_config.h b/rpcs3/Emu/Io/camera_config.h
index ca737f120..07836a064 100644
--- a/rpcs3/Emu/Io/camera_config.h
+++ b/rpcs3/Emu/Io/camera_config.h
@@ -15,8 +15,6 @@ struct cfg_camera final : cfg::node
 		double min_fps = 0;
 		double max_fps = 0;
 		int format = 0;
-		int pixel_aspect_width = 0;
-		int pixel_aspect_height = 0;
 
 		static const u32 member_count = 7;
 
diff --git a/rpcs3/Emu/Io/camera_handler_base.h b/rpcs3/Emu/Io/camera_handler_base.h
index adcd2653f..1c0eb5588 100644
--- a/rpcs3/Emu/Io/camera_handler_base.h
+++ b/rpcs3/Emu/Io/camera_handler_base.h
@@ -8,7 +8,6 @@ class camera_handler_base
 public:
 	enum class camera_handler_state
 	{
-		not_available,
 		closed,
 		open,
 		running
@@ -33,7 +32,7 @@ public:
 
 protected:
 	std::mutex m_mutex;
-	atomic_t<camera_handler_state> m_state = camera_handler_state::not_available;
+	atomic_t<camera_handler_state> m_state = camera_handler_state::closed;
 	bool m_mirrored = false;
 	s32 m_format = 2; // CELL_CAMERA_RAW8
 	u32 m_bytesize = 0;
diff --git a/rpcs3/Emu/RSX/display.h b/rpcs3/Emu/RSX/display.h
index e6d5fa657..888127566 100644
--- a/rpcs3/Emu/RSX/display.h
+++ b/rpcs3/Emu/RSX/display.h
@@ -5,7 +5,7 @@
 #elif defined(__APPLE__)
 // nothing
 #elif defined(HAVE_X11)
-// Cannot include Xlib.h before Qt5
+// Cannot include Xlib.h before Qt
 // and we don't need all of Xlib anyway
 using Display = struct _XDisplay;
 using Window  = unsigned long;
diff --git a/rpcs3/Input/basic_mouse_handler.cpp b/rpcs3/Input/basic_mouse_handler.cpp
index ac1c061aa..9e0655224 100644
--- a/rpcs3/Input/basic_mouse_handler.cpp
+++ b/rpcs3/Input/basic_mouse_handler.cpp
@@ -128,6 +128,7 @@ void basic_mouse_handler::MouseMove(QMouseEvent* event)
 	{
 		// get the screen dimensions
 		const QSize screen = m_target->size();
+		const QPoint e_pos = event->pos();
 
 		if (m_target && m_target->isActive() && get_mouse_lock_state())
 		{
@@ -144,7 +145,7 @@ void basic_mouse_handler::MouseMove(QMouseEvent* event)
 			static QPoint p_real(p_center);
 
 			// get the delta of the mouse position to the screen center
-			const QPoint p_delta = event->pos() - p_center;
+			const QPoint p_delta = e_pos - p_center;
 
 			// update the current position without leaving the screen borders
 			p_real.setX(std::clamp(p_real.x() + p_delta.x(), 0, screen.width()));
@@ -155,7 +156,7 @@ void basic_mouse_handler::MouseMove(QMouseEvent* event)
 		}
 		else
 		{
-			MouseHandlerBase::Move(event->x(), event->y(), screen.width(), screen.height());
+			MouseHandlerBase::Move(e_pos.x(), e_pos.y(), screen.width(), screen.height());
 		}
 	}
 }
diff --git a/rpcs3/Input/keyboard_pad_handler.cpp b/rpcs3/Input/keyboard_pad_handler.cpp
index 57682654b..c720c48bf 100644
--- a/rpcs3/Input/keyboard_pad_handler.cpp
+++ b/rpcs3/Input/keyboard_pad_handler.cpp
@@ -441,12 +441,13 @@ void keyboard_pad_handler::mouseMoveEvent(QMouseEvent* event)
 	{
 		static int last_pos_x = 0;
 		static int last_pos_y = 0;
+		const QPoint e_pos = event->pos();
 
-		movement_x = event->x() - last_pos_x;
-		movement_y = event->y() - last_pos_y;
+		movement_x = e_pos.x() - last_pos_x;
+		movement_y = e_pos.y() - last_pos_y;
 
-		last_pos_x = event->x();
-		last_pos_y = event->y();
+		last_pos_x = e_pos.x();
+		last_pos_y = e_pos.y();
 	}
 	else if (m_target && m_target->isActive())
 	{
@@ -736,7 +737,7 @@ u32 keyboard_pad_handler::GetKeyCode(const QString& keyName)
 	u32 key_code = 0;
 
 	if (seq.count() == 1)
-		key_code = seq[0];
+		key_code = seq[0].key();
 	else
 		input_log.notice("GetKeyCode(%s): seq.count() = %d", sstr(keyName), seq.count());
 
diff --git a/rpcs3/main.cpp b/rpcs3/main.cpp
index ba699b07e..cfb8662b3 100644
--- a/rpcs3/main.cpp
+++ b/rpcs3/main.cpp
@@ -1,4 +1,4 @@
-// Qt5.10+ frontend implementation for rpcs3. Known to work on Windows, Linux, Mac
+// Qt6 frontend implementation for rpcs3. Known to work on Windows, Linux, Mac
 // by Sacha Refshauge, Megamouse and flash-fire
 
 #include <iostream>
@@ -351,9 +351,6 @@ QCoreApplication* create_application(int& argc, char* argv[])
 		use_high_dpi = "1" == qEnvironmentVariable("QT_ENABLE_HIGHDPI_SCALING", high_dpi_setting);
 	}
 
-	// AA_EnableHighDpiScaling has to be set before creating a QApplication
-	QApplication::setAttribute(use_high_dpi ? Qt::AA_EnableHighDpiScaling : Qt::AA_DisableHighDpiScaling);
-
 	if (use_high_dpi)
 	{
 		// Set QT_SCALE_FACTOR_ROUNDING_POLICY from environment. Defaults to cli argument, which defaults to PassThrough.
@@ -970,8 +967,6 @@ int main(int argc, char** argv)
 
 	if (gui_application* gui_app = qobject_cast<gui_application*>(app.data()))
 	{
-		gui_app->setAttribute(Qt::AA_UseHighDpiPixmaps);
-		gui_app->setAttribute(Qt::AA_DisableWindowContextHelpButton);
 		gui_app->setAttribute(Qt::AA_DontCheckOpenGLContextThreadAffinity);
 
 		gui_app->SetShowGui(!s_no_gui);
@@ -1053,7 +1048,7 @@ int main(int argc, char** argv)
 	bool got_timer_resolution = NtQueryTimerResolution(&min_res, &max_res, &orig_res) == 0;
 
 	// Set 0.5 msec timer resolution for best performance
-	// - As QT5 timers (QTimer) sets the timer resolution to 1 msec, override it here.
+	// - As QT timers (QTimer) sets the timer resolution to 1 msec, override it here.
 	if (parser.value(arg_timer).toStdString() == "1")
 	{
 		ULONG new_res;
diff --git a/rpcs3/main_application.cpp b/rpcs3/main_application.cpp
index de8eafc6c..32f2134ab 100644
--- a/rpcs3/main_application.cpp
+++ b/rpcs3/main_application.cpp
@@ -314,7 +314,7 @@ EmuCallbacks main_application::CreateCallbacks()
 					image = image.convertToFormat(QImage::Format::Format_RGBA8888);
 				}
 
-				std::memcpy(dst, image.constBits(), std::min(4 * target_width * target_height, image.height() * image.bytesPerLine()));
+				std::memcpy(dst, image.constBits(), std::min(target_width * target_height * 4LL, image.height() * image.bytesPerLine()));
 				success = true;
 				sys_log.notice("get_scaled_image scaled image: path='%s', width=%d, height=%d", path, width, height);
 			}
diff --git a/rpcs3/rpcs3.vcxproj b/rpcs3/rpcs3.vcxproj
index dd6818ca4..579561824 100644
--- a/rpcs3/rpcs3.vcxproj
+++ b/rpcs3/rpcs3.vcxproj
@@ -1,4 +1,4 @@
-<?xml version="1.0" encoding="utf-8"?>
+﻿<?xml version="1.0" encoding="utf-8"?>
 <Project DefaultTargets="Build" ToolsVersion="14.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
   <ItemGroup Label="ProjectConfigurations">
     <ProjectConfiguration Include="Release|x64">
@@ -71,8 +71,8 @@
   </PropertyGroup>
   <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
     <ClCompile>
-      <AdditionalIncludeDirectories>..\3rdparty\SoundTouch\soundtouch\include;..\3rdparty\cubeb\extra;..\3rdparty\cubeb\cubeb\include\;..\3rdparty\flatbuffers\include;..\3rdparty\wolfssl\wolfssl;..\3rdparty\curl\curl\include;..\3rdparty\rtmidi\rtmidi;..\3rdparty\libusb\libusb\libusb;$(VULKAN_SDK)\Include;..\3rdparty\libsdl-org\SDL\include;..\3rdparty\XAudio2Redist\include;$(QTDIR)\include;$(QTDIR)\include\QtWidgets;$(QTDIR)\include\QtGui;$(QTDIR)\include\QtANGLE;$(QTDIR)\include\QtCore;.\release;$(QTDIR)\mkspecs\win32-msvc2015;.\QTGeneratedFiles\$(ConfigurationName);.\QTGeneratedFiles;$(QTDIR)\include\QtWinExtras;$(QTDIR)\include\QtConcurrent;$(QTDIR)\include\QtMultimedia;$(QTDIR)\include\QtMultimediaWidgets;$(QTDIR)\include\QtSvg;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
-      <AdditionalOptions>-Zc:strictStrings -Zc:throwingNew- -w34100 -w34189 -w44996 -w44456 -w44457 -w44458 %(AdditionalOptions)</AdditionalOptions>
+      <AdditionalIncludeDirectories>..\3rdparty\SoundTouch\soundtouch\include;..\3rdparty\cubeb\extra;..\3rdparty\cubeb\cubeb\include\;..\3rdparty\flatbuffers\include;..\3rdparty\wolfssl\wolfssl;..\3rdparty\curl\curl\include;..\3rdparty\rtmidi\rtmidi;..\3rdparty\libusb\libusb\libusb;$(VULKAN_SDK)\Include;..\3rdparty\libsdl-org\SDL\include;..\3rdparty\XAudio2Redist\include;$(QTDIR)\include;$(QTDIR)\include\QtCore;$(QTDIR)\include\QtCore5Compat;$(QTDIR)\include\QtConcurrent;$(QTDIR)\include\QtGui;$(QTDIR)\include\QtSvg;$(QTDIR)\include\QtSvgWidgets;$(QTDIR)\include\QtWidgets;$(QTDIR)\include\QtMultimedia;$(QTDIR)\mkspecs\win32-msvc;.\release;.\QTGeneratedFiles\$(ConfigurationName);.\QTGeneratedFiles;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
+      <AdditionalOptions>/Zc:__cplusplus -Zc:strictStrings -Zc:throwingNew- -w34100 -w34189 -w44996 -w44456 -w44457 -w44458 %(AdditionalOptions)</AdditionalOptions>
       <AssemblerListingLocation>release\</AssemblerListingLocation>
       <BrowseInformation>false</BrowseInformation>
       <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
@@ -89,7 +89,7 @@
       <ExternalWarningLevel>TurnOffAllWarnings</ExternalWarningLevel>
     </ClCompile>
     <Link>
-      <AdditionalDependencies>DbgHelp.lib;Ole32.lib;gdi32.lib;..\hidapi.lib;..\libusb-1.0.lib;winmm.lib;miniupnpc_static.lib;rtmidi.lib;imm32.lib;ksuser.lib;version.lib;OpenAL32.lib;XAudio.lib;GLGSRender.lib;shlwapi.lib;VKGSRender.lib;vulkan-1.lib;wolfssl.lib;libcurl.lib;Wldap32.lib;glslang.lib;OSDependent.lib;OGLCompiler.lib;SPIRV.lib;MachineIndependent.lib;GenericCodeGen.lib;Advapi32.lib;user32.lib;zlib.lib;..\libpng16.lib;asmjit.lib;yaml-cpp.lib;discord-rpc.lib;emucore.lib;dxgi.lib;$(QTDIR)\lib\qtmain.lib;shell32.lib;$(QTDIR)\lib\Qt5Widgets.lib;$(QTDIR)\lib\Qt5Gui.lib;$(QTDIR)\lib\Qt5Core.lib;Qt5Core.lib;Qt5Gui.lib;Qt5Widgets.lib;Qt5WinExtras.lib;Qt5Concurrent.lib;7zlib.lib;SPIRV-Tools.lib;SPIRV-Tools-opt.lib;Qt5Multimedia.lib;Qt5MultimediaWidgets.lib;Qt5Svg.lib;libcubeb.lib;cubeb.lib;soundtouch.lib;Avrt.lib;SDL.lib;%(AdditionalDependencies)</AdditionalDependencies>
+      <AdditionalDependencies>DbgHelp.lib;Ole32.lib;gdi32.lib;..\hidapi.lib;..\libusb-1.0.lib;winmm.lib;miniupnpc_static.lib;rtmidi.lib;imm32.lib;ksuser.lib;version.lib;OpenAL32.lib;XAudio.lib;GLGSRender.lib;shlwapi.lib;VKGSRender.lib;vulkan-1.lib;wolfssl.lib;libcurl.lib;Wldap32.lib;glslang.lib;OSDependent.lib;OGLCompiler.lib;SPIRV.lib;MachineIndependent.lib;GenericCodeGen.lib;Advapi32.lib;user32.lib;zlib.lib;..\libpng16.lib;asmjit.lib;yaml-cpp.lib;discord-rpc.lib;emucore.lib;dxgi.lib;shell32.lib;Qt6Core.lib;Qt6Gui.lib;Qt6Widgets.lib;Qt6Concurrent.lib;Qt6Core5Compat.lib;Qt6Multimedia.lib;Qt6MultimediaWidgets.lib;Qt6Svg.lib;Qt6SvgWidgets.lib;7zlib.lib;SPIRV-Tools.lib;SPIRV-Tools-opt.lib;libcubeb.lib;cubeb.lib;soundtouch.lib;Avrt.lib;SDL.lib;%(AdditionalDependencies)</AdditionalDependencies>
       <AdditionalLibraryDirectories>..\3rdparty\OpenAL\libs\Win64;..\3rdparty\glslang\build\hlsl\Release;..\3rdparty\glslang\build\SPIRV\Release;..\3rdparty\glslang\build\OGLCompilersDLL\Release;..\3rdparty\glslang\build\glslang\OSDependent\Windows\Release;..\3rdparty\glslang\build\glslang\Release;..\3rdparty\SPIRV\build\source\Release;..\3rdparty\SPIRV\build\source\opt\Release;..\lib\$(CONFIGURATION)-$(PLATFORM);..\3rdparty\XAudio2Redist\libs;..\3rdparty\discord-rpc\lib;$(QTDIR)\lib;%(AdditionalLibraryDirectories);$(VULKAN_SDK)\Lib</AdditionalLibraryDirectories>
       <AdditionalOptions>"/MANIFESTDEPENDENCY:type='win32' name='Microsoft.Windows.Common-Controls' version='6.0.0.0' publicKeyToken='6595b64144ccf1df' language='*' processorArchitecture='*'" %(AdditionalOptions)</AdditionalOptions>
       <DataExecutionPrevention>true</DataExecutionPrevention>
@@ -102,6 +102,7 @@
       <SuppressStartupBanner>true</SuppressStartupBanner>
       <BaseAddress>0x10000</BaseAddress>
       <DelayLoadDLLs>xaudio2_9redist.dll</DelayLoadDLLs>
+      <EntryPointSymbol>mainCRTStartup</EntryPointSymbol>
     </Link>
     <Midl>
       <DefaultCharType>Unsigned</DefaultCharType>
@@ -113,7 +114,7 @@
     </ResourceCompile>
     <PostBuildEvent>
       <Command>
-        $(QTDIR)\bin\windeployqt --no-angle --no-opengl-sw --no-translations --no-quick --plugindir "$(TargetDir)qt\plugins" --release "$(TargetPath)"
+        $(QTDIR)\bin\windeployqt --no-opengl-sw --no-translations --no-quick --plugindir "$(TargetDir)qt\plugins" --release "$(TargetPath)"
       </Command>
     </PostBuildEvent>
     <PostBuildEvent>
@@ -123,7 +124,7 @@
   </ItemDefinitionGroup>
   <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
     <ClCompile>
-      <AdditionalIncludeDirectories>..\3rdparty\SoundTouch\soundtouch\include;..\3rdparty\cubeb\extra;..\3rdparty\cubeb\cubeb\include\;..\3rdparty\flatbuffers\include;..\3rdparty\wolfssl\wolfssl;..\3rdparty\curl\curl\include;..\3rdparty\rtmidi\rtmidi;..\3rdparty\libusb\libusb\libusb;$(VULKAN_SDK)\Include;..\3rdparty\XAudio2Redist\include;$(QTDIR)\include;$(QTDIR)\include\QtWidgets;$(QTDIR)\include\QtGui;$(QTDIR)\include\QtANGLE;$(QTDIR)\include\QtCore;.\debug;$(QTDIR)\mkspecs\win32-msvc2015;.\QTGeneratedFiles\$(ConfigurationName);.\QTGeneratedFiles;$(QTDIR)\include\QtWinExtras;$(QTDIR)\include\QtConcurrent;$(QTDIR)\include\QtMultimedia;$(QTDIR)\include\QtMultimediaWidgets;$(QTDIR)\include\QtSvg;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
+      <AdditionalIncludeDirectories>..\3rdparty\SoundTouch\soundtouch\include;..\3rdparty\cubeb\extra;..\3rdparty\cubeb\cubeb\include\;..\3rdparty\flatbuffers\include;..\3rdparty\wolfssl\wolfssl;..\3rdparty\curl\curl\include;..\3rdparty\rtmidi\rtmidi;..\3rdparty\libusb\libusb\libusb;$(VULKAN_SDK)\Include;..\3rdparty\XAudio2Redist\include;$(QTDIR)\include;$(QTDIR)\include\QtCore;$(QTDIR)\include\QtCore5Compat;$(QTDIR)\include\QtConcurrent;$(QTDIR)\include\QtGui;$(QTDIR)\include\QtSvg;$(QTDIR)\include\QtSvgWidgets;$(QTDIR)\include\QtWidgets;$(QTDIR)\include\QtMultimedia;$(QTDIR)\mkspecs\win32-msvc;.\debug;.\QTGeneratedFiles\$(ConfigurationName);.\QTGeneratedFiles;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
       <AdditionalOptions>-Zc:strictStrings -Zc:throwingNew- -w34100 -w34189 -w44996 -w44456 -w44457 -w44458 %(AdditionalOptions)</AdditionalOptions>
       <AssemblerListingLocation>debug\</AssemblerListingLocation>
       <BrowseInformation>false</BrowseInformation>
@@ -140,7 +141,7 @@
       <ProgramDataBaseFileName>$(IntDir)vc$(PlatformToolsetVersion).pdb</ProgramDataBaseFileName>
     </ClCompile>
     <Link>
-      <AdditionalDependencies>DbgHelp.lib;Ole32.lib;gdi32.lib;..\hidapi.lib;..\libusb-1.0.lib;winmm.lib;miniupnpc_static.lib;rtmidi.lib;ksuser.lib;OpenAL32.lib;XAudio.lib;GLGSRender.lib;shlwapi.lib;VKGSRender.lib;vulkan-1.lib;wolfssl.lib;libcurl.lib;Wldap32.lib;glslangd.lib;OSDependentd.lib;OGLCompilerd.lib;SPIRVd.lib;MachineIndependentd.lib;GenericCodeGend.lib;Advapi32.lib;user32.lib;zlib.lib;..\libpng16.lib;asmjit.lib;yaml-cpp.lib;discord-rpc.lib;emucore.lib;dxgi.lib;$(QTDIR)\lib\qtmaind.lib;shell32.lib;$(QTDIR)\lib\Qt5Widgetsd.lib;$(QTDIR)\lib\Qt5Guid.lib;$(QTDIR)\lib\Qt5Cored.lib;Qt5Cored.lib;Qt5Guid.lib;Qt5Widgetsd.lib;Qt5WinExtrasd.lib;Qt5Concurrentd.lib;7zlib.lib;SPIRV-Tools.lib;SPIRV-Tools-opt.lib;Qt5Multimediad.lib;Qt5MultimediaWidgetsd.lib;Qt5Svgd.lib;libcubeb.lib;cubeb.lib;soundtouch.lib;Avrt.lib;%(AdditionalDependencies)</AdditionalDependencies>
+      <AdditionalDependencies>DbgHelp.lib;Ole32.lib;gdi32.lib;..\hidapi.lib;..\libusb-1.0.lib;winmm.lib;miniupnpc_static.lib;rtmidi.lib;ksuser.lib;OpenAL32.lib;XAudio.lib;GLGSRender.lib;shlwapi.lib;VKGSRender.lib;vulkan-1.lib;wolfssl.lib;libcurl.lib;Wldap32.lib;glslangd.lib;OSDependentd.lib;OGLCompilerd.lib;SPIRVd.lib;MachineIndependentd.lib;GenericCodeGend.lib;Advapi32.lib;user32.lib;zlib.lib;..\libpng16.lib;asmjit.lib;yaml-cpp.lib;discord-rpc.lib;emucore.lib;dxgi.lib;shell32.lib;qtmaind.lib;Qt6Cored.lib;Qt6Guid.lib;Qt6Widgetsd.lib;Qt6Concurrentd.lib;Qt6Multimediad.lib;Qt6MultimediaWidgetsd.lib;Qt6Svgd.lib;Qt6SvgWidgetsd.lib;7zlib.lib;SPIRV-Tools.lib;SPIRV-Tools-opt.lib;libcubeb.lib;cubeb.lib;soundtouch.lib;Avrt.lib;%(AdditionalDependencies)</AdditionalDependencies>
       <AdditionalLibraryDirectories>..\3rdparty\OpenAL\libs\Win64;..\3rdparty\glslang\build\hlsl\Debug;..\3rdparty\glslang\build\SPIRV\Debug;..\3rdparty\glslang\build\OGLCompilersDLL\Debug;..\3rdparty\glslang\build\glslang\OSDependent\Windows\Debug;..\3rdparty\glslang\build\glslang\Debug;..\3rdparty\SPIRV\build\source\opt\Debug;..\3rdparty\XAudio2Redist\libs;..\3rdparty\discord-rpc\lib;..\lib\$(CONFIGURATION)-$(PLATFORM);$(QTDIR)\lib;%(AdditionalLibraryDirectories);$(VULKAN_SDK)\Lib</AdditionalLibraryDirectories>
       <AdditionalOptions>"/MANIFESTDEPENDENCY:type='win32' name='Microsoft.Windows.Common-Controls' version='6.0.0.0' publicKeyToken='6595b64144ccf1df' language='*' processorArchitecture='*'"  /VERBOSE %(AdditionalOptions)</AdditionalOptions>
       <DataExecutionPrevention>true</DataExecutionPrevention>
@@ -165,7 +166,7 @@
     </ResourceCompile>
     <PostBuildEvent>
       <Command>
-        $(QTDIR)\bin\windeployqt --no-angle --no-opengl-sw --no-translations --no-quick --plugindir "$(TargetDir)qt\plugins" --debug "$(TargetPath)"
+        $(QTDIR)\bin\windeployqt --no-opengl-sw --no-translations --no-quick --plugindir "$(TargetDir)qt\plugins" --debug "$(TargetPath)"
       </Command>
     </PostBuildEvent>
     <PostBuildEvent>
@@ -763,7 +764,7 @@
     <ClCompile Include="rpcs3qt\table_item_delegate.cpp" />
     <ClCompile Include="rpcs3qt\tooltips.cpp" />
     <ClCompile Include="rpcs3qt\update_manager.cpp" />
-    <ClCompile Include="rpcs3qt\qt_camera_video_surface.cpp" />
+    <ClCompile Include="rpcs3qt\qt_camera_video_sink.cpp" />
     <ClCompile Include="rpcs3qt\uuid.cpp" />
     <ClCompile Include="rpcs3qt\vfs_dialog_path_widget.cpp" />
     <ClCompile Include="rpcs3qt\vfs_dialog_usb_input.cpp" />
@@ -1482,7 +1483,7 @@
       <Outputs Condition="'$(Configuration)|$(Platform)'=='Release|x64'">.\QTGeneratedFiles\$(ConfigurationName)\moc_%(Filename).cpp</Outputs>
       <Command Condition="'$(Configuration)|$(Platform)'=='Release|x64'">"$(QTDIR)\bin\moc.exe"  "%(FullPath)" -o ".\QTGeneratedFiles\$(ConfigurationName)\moc_%(Filename).cpp"  -D_WINDOWS -DUNICODE -DWIN32 -DWIN64 -DWITH_DISCORD_RPC -DQT_NO_DEBUG -DQT_WIDGETS_LIB -DQT_GUI_LIB -DQT_CORE_LIB -DNDEBUG -DQT_WINEXTRAS_LIB -DQT_CONCURRENT_LIB -D%(PreprocessorDefinitions)  "-I.\..\3rdparty\wolfssl\wolfssl" "-I.\..\3rdparty\curl\curl\include" "-I.\..\3rdparty\libusb\libusb\libusb" "-I$(VULKAN_SDK)\Include" "-I.\..\3rdparty\XAudio2Redist\include" "-I$(QTDIR)\include" "-I$(QTDIR)\include\QtWidgets" "-I$(QTDIR)\include\QtGui" "-I$(QTDIR)\include\QtANGLE" "-I$(QTDIR)\include\QtCore" "-I.\release" "-I$(QTDIR)\mkspecs\win32-msvc2015" "-I.\QTGeneratedFiles\$(ConfigurationName)" "-I.\QTGeneratedFiles" "-I$(QTDIR)\include\QtWinExtras" "-I$(QTDIR)\include\QtConcurrent"</Command>
     </CustomBuild>
-    <ClInclude Include="rpcs3qt\qt_camera_video_surface.h" />
+    <ClInclude Include="rpcs3qt\qt_camera_video_sink.h" />
     <CustomBuild Include="rpcs3qt\vfs_dialog_usb_tab.h">
       <AdditionalInputs Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">$(QTDIR)\bin\moc.exe;%(FullPath)</AdditionalInputs>
       <Message Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">Moc%27ing %(Identity)...</Message>
diff --git a/rpcs3/rpcs3.vcxproj.filters b/rpcs3/rpcs3.vcxproj.filters
index 76d205b08..4de7e725a 100644
--- a/rpcs3/rpcs3.vcxproj.filters
+++ b/rpcs3/rpcs3.vcxproj.filters
@@ -807,7 +807,7 @@
     <ClCompile Include="rpcs3qt\qt_camera_handler.cpp">
       <Filter>Io\camera</Filter>
     </ClCompile>
-    <ClCompile Include="rpcs3qt\qt_camera_video_surface.cpp">
+    <ClCompile Include="rpcs3qt\qt_camera_video_sink.cpp">
       <Filter>Io\camera</Filter>
     </ClCompile>
     <ClCompile Include="rpcs3qt\qt_camera_error_handler.cpp">
@@ -1166,7 +1166,7 @@
     <ClInclude Include="QTGeneratedFiles\ui_patch_creator_dialog.h">
       <Filter>Generated Files</Filter>
     </ClInclude>
-    <ClInclude Include="rpcs3qt\qt_camera_video_surface.h">
+    <ClInclude Include="rpcs3qt\qt_camera_video_sink.h">
       <Filter>Io\camera</Filter>
     </ClInclude>
     <ClInclude Include="rpcs3qt\qt_camera_handler.h">
diff --git a/rpcs3/rpcs3qt/CMakeLists.txt b/rpcs3/rpcs3qt/CMakeLists.txt
index a505c92d6..e26752e19 100644
--- a/rpcs3/rpcs3qt/CMakeLists.txt
+++ b/rpcs3/rpcs3qt/CMakeLists.txt
@@ -68,7 +68,7 @@ set(SRC_FILES
     progress_indicator.cpp
     qt_camera_error_handler.cpp
     qt_camera_handler.cpp
-    qt_camera_video_surface.cpp
+    qt_camera_video_sink.cpp
     qt_music_error_handler.cpp
     qt_music_handler.cpp
     qt_utils.cpp
@@ -147,7 +147,7 @@ target_compile_definitions(rpcs3_ui PRIVATE WIN32_LEAN_AND_MEAN)
 
 target_link_libraries(rpcs3_ui
     PUBLIC
-        3rdparty::qt5 3rdparty::yaml-cpp
+        3rdparty::qt6 3rdparty::yaml-cpp
 
     PRIVATE
         rpcs3_emu
diff --git a/rpcs3/rpcs3qt/camera_settings_dialog.cpp b/rpcs3/rpcs3qt/camera_settings_dialog.cpp
index db2d4c6b2..89f72cef8 100644
--- a/rpcs3/rpcs3qt/camera_settings_dialog.cpp
+++ b/rpcs3/rpcs3qt/camera_settings_dialog.cpp
@@ -3,61 +3,56 @@
 #include "ui_camera_settings_dialog.h"
 #include "Emu/Io/camera_config.h"
 
-#include <QCameraInfo>
+#include <QCameraDevice>
+#include <QMediaDevices>
 #include <QMessageBox>
 #include <QPushButton>
 
 LOG_CHANNEL(camera_log, "Camera");
 
 template <>
-void fmt_class_string<QVideoFrame::PixelFormat>::format(std::string& out, u64 arg)
+void fmt_class_string<QVideoFrameFormat::PixelFormat>::format(std::string& out, u64 arg)
 {
-	format_enum(out, arg, [](QVideoFrame::PixelFormat value)
+	format_enum(out, arg, [](QVideoFrameFormat::PixelFormat value)
 	{
 		switch (value)
 		{
-		case QVideoFrame::Format_Invalid: return "Invalid";
-		case QVideoFrame::Format_ARGB32: return "ARGB32";
-		case QVideoFrame::Format_ARGB32_Premultiplied: return "ARGB32_Premultiplied";
-		case QVideoFrame::Format_RGB32: return "RGB32";
-		case QVideoFrame::Format_RGB24: return "RGB24";
-		case QVideoFrame::Format_RGB565: return "RGB565";
-		case QVideoFrame::Format_RGB555: return "RGB555";
-		case QVideoFrame::Format_ARGB8565_Premultiplied: return "ARGB8565_Premultiplied";
-		case QVideoFrame::Format_BGRA32: return "BGRA32";
-		case QVideoFrame::Format_BGRA32_Premultiplied: return "BGRA32_Premultiplied";
-		case QVideoFrame::Format_BGR32: return "BGR32";
-		case QVideoFrame::Format_BGR24: return "BGR24";
-		case QVideoFrame::Format_BGR565: return "BGR565";
-		case QVideoFrame::Format_BGR555: return "BGR555";
-		case QVideoFrame::Format_BGRA5658_Premultiplied: return "BGRA5658_Premultiplied";
-		case QVideoFrame::Format_AYUV444: return "AYUV444";
-		case QVideoFrame::Format_AYUV444_Premultiplied: return "AYUV444_Premultiplied";
-		case QVideoFrame::Format_YUV444: return "YUV444";
-		case QVideoFrame::Format_YUV420P: return "YUV420P";
-		case QVideoFrame::Format_YV12: return "YV12";
-		case QVideoFrame::Format_UYVY: return "UYVY";
-		case QVideoFrame::Format_YUYV: return "YUYV";
-		case QVideoFrame::Format_NV12: return "NV12";
-		case QVideoFrame::Format_NV21: return "NV21";
-		case QVideoFrame::Format_IMC1: return "IMC1";
-		case QVideoFrame::Format_IMC2: return "IMC2";
-		case QVideoFrame::Format_IMC3: return "IMC3";
-		case QVideoFrame::Format_IMC4: return "IMC4";
-		case QVideoFrame::Format_Y8: return "Y8";
-		case QVideoFrame::Format_Y16: return "Y16";
-		case QVideoFrame::Format_Jpeg: return "Jpeg";
-		case QVideoFrame::Format_CameraRaw: return "CameraRaw";
-		case QVideoFrame::Format_AdobeDng: return "AdobeDng";
-		case QVideoFrame::Format_ABGR32: return "ABGR32";
-		case QVideoFrame::Format_YUV422P: return "YUV422P";
-		case QVideoFrame::Format_User: return "User";
+		case QVideoFrameFormat::Format_ARGB8888: return "ARGB8888";
+		case QVideoFrameFormat::Format_ARGB8888_Premultiplied: return "ARGB8888_Premultiplied";
+		case QVideoFrameFormat::Format_XRGB8888: return "XRGB8888";
+		case QVideoFrameFormat::Format_BGRA8888: return "BGRA8888";
+		case QVideoFrameFormat::Format_BGRA8888_Premultiplied: return "BGRA8888_Premultiplied";
+		case QVideoFrameFormat::Format_BGRX8888: return "BGRX8888";
+		case QVideoFrameFormat::Format_ABGR8888: return "ABGR8888";
+		case QVideoFrameFormat::Format_XBGR8888: return "XBGR8888";
+		case QVideoFrameFormat::Format_RGBA8888: return "RGBA8888";
+		case QVideoFrameFormat::Format_RGBX8888: return "RGBX8888";
+		case QVideoFrameFormat::Format_AYUV: return "AYUV";
+		case QVideoFrameFormat::Format_AYUV_Premultiplied: return "AYUV_Premultiplied";
+		case QVideoFrameFormat::Format_YUV420P: return "YUV420P";
+		case QVideoFrameFormat::Format_YUV422P: return "YUV422P";
+		case QVideoFrameFormat::Format_YV12: return "YV12";
+		case QVideoFrameFormat::Format_UYVY: return "UYVY";
+		case QVideoFrameFormat::Format_YUYV: return "YUYV";
+		case QVideoFrameFormat::Format_NV12: return "NV12";
+		case QVideoFrameFormat::Format_NV21: return "NV21";
+		case QVideoFrameFormat::Format_IMC1: return "IMC1";
+		case QVideoFrameFormat::Format_IMC2: return "IMC2";
+		case QVideoFrameFormat::Format_IMC3: return "IMC3";
+		case QVideoFrameFormat::Format_IMC4: return "IMC4";
+		case QVideoFrameFormat::Format_Y8: return "Y8";
+		case QVideoFrameFormat::Format_Y16: return "Y16";
+		case QVideoFrameFormat::Format_P010: return "P010";
+		case QVideoFrameFormat::Format_P016: return "P016";
+		case QVideoFrameFormat::Format_SamplerExternalOES: return "SamplerExternalOES";
+		case QVideoFrameFormat::Format_Jpeg: return "Jpeg";
+		case QVideoFrameFormat::Format_SamplerRect: return "SamplerRect";
 		default: return unknown;
 		}
 	});
 }
 
-Q_DECLARE_METATYPE(QCameraInfo);
+Q_DECLARE_METATYPE(QCameraDevice);
 
 camera_settings_dialog::camera_settings_dialog(QWidget* parent)
 	: QDialog(parent)
@@ -67,7 +62,7 @@ camera_settings_dialog::camera_settings_dialog(QWidget* parent)
 
 	load_config();
 
-	for (const QCameraInfo& camera_info : QCameraInfo::availableCameras())
+	for (const QCameraDevice& camera_info : QMediaDevices::videoInputs())
 	{
 		if (camera_info.isNull()) continue;
 		ui->combo_camera->addItem(camera_info.description(), QVariant::fromValue(camera_info));
@@ -108,13 +103,13 @@ camera_settings_dialog::~camera_settings_dialog()
 
 void camera_settings_dialog::handle_camera_change(int index)
 {
-	if (index < 0 || !ui->combo_camera->itemData(index).canConvert<QCameraInfo>())
+	if (index < 0 || !ui->combo_camera->itemData(index).canConvert<QCameraDevice>())
 	{
 		ui->combo_settings->clear();
 		return;
 	}
 
-	const QCameraInfo camera_info = ui->combo_camera->itemData(index).value<QCameraInfo>();
+	const QCameraDevice camera_info = ui->combo_camera->itemData(index).value<QCameraDevice>();
 
 	if (camera_info.isNull())
 	{
@@ -123,7 +118,9 @@ void camera_settings_dialog::handle_camera_change(int index)
 	}
 
 	m_camera.reset(new QCamera(camera_info));
-	m_camera->setViewfinder(ui->viewfinder);
+	m_media_capture_session.reset(new QMediaCaptureSession(nullptr));
+	m_media_capture_session->setCamera(m_camera.get());
+	m_media_capture_session->setVideoSink(ui->videoWidget->videoSink());
 
 	if (!m_camera->isAvailable())
 	{
@@ -132,42 +129,34 @@ void camera_settings_dialog::handle_camera_change(int index)
 		return;
 	}
 
-	m_camera->load();
-
 	ui->combo_settings->blockSignals(true);
 	ui->combo_settings->clear();
 
-	QList<QCameraViewfinderSettings> settings = m_camera->supportedViewfinderSettings();
-	std::sort(settings.begin(), settings.end(), [](const QCameraViewfinderSettings& l, const QCameraViewfinderSettings& r) -> bool
+	QList<QCameraFormat> settings = camera_info.videoFormats();
+	std::sort(settings.begin(), settings.end(), [](const QCameraFormat& l, const QCameraFormat& r) -> bool
 	{
 		if (l.resolution().width() > r.resolution().width()) return true;
 		if (l.resolution().width() < r.resolution().width()) return false;
 		if (l.resolution().height() > r.resolution().height()) return true;
 		if (l.resolution().height() < r.resolution().height()) return false;
-		if (l.minimumFrameRate() > r.minimumFrameRate()) return true;
-		if (l.minimumFrameRate() < r.minimumFrameRate()) return false;
-		if (l.maximumFrameRate() > r.maximumFrameRate()) return true;
-		if (l.maximumFrameRate() < r.maximumFrameRate()) return false;
+		if (l.minFrameRate() > r.minFrameRate()) return true;
+		if (l.minFrameRate() < r.minFrameRate()) return false;
+		if (l.maxFrameRate() > r.maxFrameRate()) return true;
+		if (l.maxFrameRate() < r.maxFrameRate()) return false;
 		if (l.pixelFormat() > r.pixelFormat()) return true;
 		if (l.pixelFormat() < r.pixelFormat()) return false;
-		if (l.pixelAspectRatio().width() > r.pixelAspectRatio().width()) return true;
-		if (l.pixelAspectRatio().width() < r.pixelAspectRatio().width()) return false;
-		if (l.pixelAspectRatio().height() > r.pixelAspectRatio().height()) return true;
-		if (l.pixelAspectRatio().height() < r.pixelAspectRatio().height()) return false;
 		return false;
 	});
 
-	for (const QCameraViewfinderSettings& setting : settings)
+	for (const QCameraFormat& setting : settings)
 	{
 		if (setting.isNull()) continue;
-		const QString description = tr("%0x%1, %2-%3 FPS, Format=%4, PixelAspectRatio=%5x%6")
+		const QString description = tr("%0x%1, %2-%3 FPS, Format=%4")
 			.arg(setting.resolution().width())
 			.arg(setting.resolution().height())
-			.arg(setting.minimumFrameRate())
-			.arg(setting.maximumFrameRate())
-			.arg(QString::fromStdString(fmt::format("%s", setting.pixelFormat())))
-			.arg(setting.pixelAspectRatio().width())
-			.arg(setting.pixelAspectRatio().height());
+			.arg(setting.minFrameRate())
+			.arg(setting.maxFrameRate())
+			.arg(QString::fromStdString(fmt::format("%s", setting.pixelFormat())));
 		ui->combo_settings->addItem(description, QVariant::fromValue(setting));
 	}
 	ui->combo_settings->blockSignals(false);
@@ -181,37 +170,27 @@ void camera_settings_dialog::handle_camera_change(int index)
 		// Load selected settings from config file
 		int index = 0;
 		bool success = false;
-		const std::string key = camera_info.deviceName().toStdString();
+		const std::string key = camera_info.id().toStdString();
 		cfg_camera::camera_setting cfg_setting = g_cfg_camera.get_camera_setting(key, success);
 
 		if (success)
 		{
 			camera_log.notice("Found config entry for camera \"%s\"", key);
 
-			// Convert to Qt data
-			QCameraViewfinderSettings setting;
-			setting.setResolution(cfg_setting.width, cfg_setting.height);
-			setting.setMinimumFrameRate(cfg_setting.min_fps);
-			setting.setMaximumFrameRate(cfg_setting.max_fps);
-			setting.setPixelFormat(static_cast<QVideoFrame::PixelFormat>(cfg_setting.format));
-			setting.setPixelAspectRatio(cfg_setting.pixel_aspect_width, cfg_setting.pixel_aspect_height);
-
 			// Select matching drowdown entry
 			const double epsilon = 0.001;
 
 			for (int i = 0; i < ui->combo_settings->count(); i++)
 			{
-				const QCameraViewfinderSettings tmp = ui->combo_settings->itemData(i).value<QCameraViewfinderSettings>();
-
-				if (tmp.resolution().width() == setting.resolution().width() &&
-					tmp.resolution().height() == setting.resolution().height() &&
-					tmp.minimumFrameRate() >= (setting.minimumFrameRate() - epsilon) &&
-					tmp.minimumFrameRate() <= (setting.minimumFrameRate() + epsilon) &&
-					tmp.maximumFrameRate() >= (setting.maximumFrameRate() - epsilon) &&
-					tmp.maximumFrameRate() <= (setting.maximumFrameRate() + epsilon) &&
-					tmp.pixelFormat() == setting.pixelFormat() &&
-					tmp.pixelAspectRatio().width() == setting.pixelAspectRatio().width() &&
-					tmp.pixelAspectRatio().height() == setting.pixelAspectRatio().height())
+				const QCameraFormat tmp = ui->combo_settings->itemData(i).value<QCameraFormat>();
+
+				if (tmp.resolution().width() == cfg_setting.width &&
+					tmp.resolution().height() == cfg_setting.height &&
+					tmp.minFrameRate() >= (cfg_setting.min_fps - epsilon) &&
+					tmp.minFrameRate() <= (cfg_setting.min_fps + epsilon) &&
+					tmp.maxFrameRate() >= (cfg_setting.max_fps - epsilon) &&
+					tmp.maxFrameRate() <= (cfg_setting.max_fps + epsilon) &&
+					tmp.pixelFormat() == static_cast<QVideoFrameFormat::PixelFormat>(cfg_setting.format))
 				{
 					index = i;
 					break;
@@ -223,14 +202,12 @@ void camera_settings_dialog::handle_camera_change(int index)
 		ui->combo_settings->setEnabled(true);
 
 		// Update config to match user interface outcome
-		const QCameraViewfinderSettings setting = ui->combo_settings->currentData().value<QCameraViewfinderSettings>();
+		const QCameraFormat setting = ui->combo_settings->currentData().value<QCameraFormat>();
 		cfg_setting.width = setting.resolution().width();
 		cfg_setting.height = setting.resolution().height();
-		cfg_setting.min_fps = setting.minimumFrameRate();
-		cfg_setting.max_fps = setting.maximumFrameRate();
+		cfg_setting.min_fps = setting.minFrameRate();
+		cfg_setting.max_fps = setting.maxFrameRate();
 		cfg_setting.format = static_cast<int>(setting.pixelFormat());
-		cfg_setting.pixel_aspect_width = setting.pixelAspectRatio().width();
-		cfg_setting.pixel_aspect_height = setting.pixelAspectRatio().height();
 		g_cfg_camera.set_camera_setting(key, cfg_setting);
 	}
 }
@@ -248,23 +225,21 @@ void camera_settings_dialog::handle_settings_change(int index)
 		return;
 	}
 
-	if (index >= 0 && ui->combo_settings->itemData(index).canConvert<QCameraViewfinderSettings>() && ui->combo_camera->currentData().canConvert<QCameraInfo>())
+	if (index >= 0 && ui->combo_settings->itemData(index).canConvert<QCameraFormat>() && ui->combo_camera->currentData().canConvert<QCameraDevice>())
 	{
-		const QCameraViewfinderSettings setting = ui->combo_settings->itemData(index).value<QCameraViewfinderSettings>();
+		const QCameraFormat setting = ui->combo_settings->itemData(index).value<QCameraFormat>();
 		if (!setting.isNull())
 		{
-			m_camera->setViewfinderSettings(setting);
+			m_camera->setCameraFormat(setting);
 		}
 
 		cfg_camera::camera_setting cfg_setting;
 		cfg_setting.width = setting.resolution().width();
 		cfg_setting.height = setting.resolution().height();
-		cfg_setting.min_fps = setting.minimumFrameRate();
-		cfg_setting.max_fps = setting.maximumFrameRate();
+		cfg_setting.min_fps = setting.minFrameRate();
+		cfg_setting.max_fps = setting.maxFrameRate();
 		cfg_setting.format = static_cast<int>(setting.pixelFormat());
-		cfg_setting.pixel_aspect_width = setting.pixelAspectRatio().width();
-		cfg_setting.pixel_aspect_height = setting.pixelAspectRatio().height();
-		g_cfg_camera.set_camera_setting(ui->combo_camera->currentData().value<QCameraInfo>().deviceName().toStdString(), cfg_setting);
+		g_cfg_camera.set_camera_setting(ui->combo_camera->currentData().value<QCameraDevice>().id().toStdString(), cfg_setting);
 	}
 
 	m_camera->start();
diff --git a/rpcs3/rpcs3qt/camera_settings_dialog.h b/rpcs3/rpcs3qt/camera_settings_dialog.h
index 56aa29a6c..da18f64cc 100644
--- a/rpcs3/rpcs3qt/camera_settings_dialog.h
+++ b/rpcs3/rpcs3qt/camera_settings_dialog.h
@@ -2,6 +2,7 @@
 
 #include <QCamera>
 #include <QDialog>
+#include <QMediaCaptureSession>
 
 namespace Ui
 {
@@ -25,5 +26,6 @@ private:
 	void save_config();
 
 	std::unique_ptr<Ui::camera_settings_dialog> ui;
-	std::shared_ptr<QCamera> m_camera;
+	std::unique_ptr<QCamera> m_camera;
+	std::unique_ptr<QMediaCaptureSession> m_media_capture_session;
 };
diff --git a/rpcs3/rpcs3qt/camera_settings_dialog.ui b/rpcs3/rpcs3qt/camera_settings_dialog.ui
index 6deef8173..8afe262f2 100644
--- a/rpcs3/rpcs3qt/camera_settings_dialog.ui
+++ b/rpcs3/rpcs3qt/camera_settings_dialog.ui
@@ -57,7 +57,7 @@
      </property>
      <layout class="QVBoxLayout" name="preview_layout">
       <item>
-       <widget class="QCameraViewfinder" name="viewfinder" native="true">
+       <widget class="QVideoWidget" name="videoWidget" native="true">
         <property name="minimumSize">
          <size>
           <width>64</width>
@@ -86,9 +86,9 @@
  </widget>
  <customwidgets>
   <customwidget>
-   <class>QCameraViewfinder</class>
+   <class>QVideoWidget</class>
    <extends>QWidget</extends>
-   <header>qcameraviewfinder.h</header>
+   <header>qvideowidget.h</header>
    <container>1</container>
   </customwidget>
  </customwidgets>
diff --git a/rpcs3/rpcs3qt/config_checker.cpp b/rpcs3/rpcs3qt/config_checker.cpp
index 88c847ede..83740e663 100644
--- a/rpcs3/rpcs3qt/config_checker.cpp
+++ b/rpcs3/rpcs3qt/config_checker.cpp
@@ -64,12 +64,12 @@ bool config_checker::check_config(QString content, QString& result, bool is_log)
 		const QString start_token = "SYS: Used configuration:\n";
 		const QString end_token = "\n·";
 
-		int start = content.indexOf(start_token);
-		int end = -1;
+		qsizetype start = content.indexOf(start_token);
+		qsizetype end = -1;
 
 		if (start >= 0)
 		{
-			start += start_token.count();
+			start += start_token.size();
 			end = content.indexOf(end_token, start);
 		}
 
diff --git a/rpcs3/rpcs3qt/custom_table_widget_item.cpp b/rpcs3/rpcs3qt/custom_table_widget_item.cpp
index 83235e395..d67979713 100644
--- a/rpcs3/rpcs3qt/custom_table_widget_item.cpp
+++ b/rpcs3/rpcs3qt/custom_table_widget_item.cpp
@@ -30,35 +30,35 @@ bool custom_table_widget_item::operator<(const QTableWidgetItem& other) const
 
 	const QVariant data_l       = data(m_sort_role);
 	const QVariant data_r       = other.data(m_sort_role);
-	const QVariant::Type type_l = data_l.type();
-	const QVariant::Type type_r = data_r.type();
+	const int type_l = data_l.metaType().id();
+	const int type_r = data_r.metaType().id();
 
 	ensure(type_l == type_r);
 
 	switch (type_l)
 	{
-	case QVariant::Type::Bool:
-	case QVariant::Type::Int:
+	case QMetaType::Type::Bool:
+	case QMetaType::Type::Int:
 		return data_l.toInt() < data_r.toInt();
-	case QVariant::Type::UInt:
+	case QMetaType::Type::UInt:
 		return data_l.toUInt() < data_r.toUInt();
-	case QVariant::Type::LongLong:
+	case QMetaType::Type::LongLong:
 		return data_l.toLongLong() < data_r.toLongLong();
-	case QVariant::Type::ULongLong:
+	case QMetaType::Type::ULongLong:
 		return data_l.toULongLong() < data_r.toULongLong();
-	case QVariant::Type::Double:
+	case QMetaType::Type::Double:
 		return data_l.toDouble() < data_r.toDouble();
-	case QVariant::Type::Date:
+	case QMetaType::Type::QDate:
 		return data_l.toDate() < data_r.toDate();
-	case QVariant::Type::Time:
+	case QMetaType::Type::QTime:
 		return data_l.toTime() < data_r.toTime();
-	case QVariant::Type::DateTime:
+	case QMetaType::Type::QDateTime:
 		return data_l.toDateTime() < data_r.toDateTime();
-	case QVariant::Type::Char:
-	case QVariant::Type::String:
+	case QMetaType::Type::Char:
+	case QMetaType::Type::QString:
 		return data_l.toString() < data_r.toString();
 	default:
-		fmt::throw_exception("Unimplemented type %s", QVariant::typeToName(type_l));
+		fmt::throw_exception("Unimplemented type %s", QMetaType(type_l).name());
 	}
 }
 
diff --git a/rpcs3/rpcs3qt/gs_frame.h b/rpcs3/rpcs3qt/gs_frame.h
index feaaf88f2..b39c790e0 100644
--- a/rpcs3/rpcs3qt/gs_frame.h
+++ b/rpcs3/rpcs3qt/gs_frame.h
@@ -73,7 +73,7 @@ public:
 	void take_screenshot(std::vector<u8> data, const u32 sshot_width, const u32 sshot_height, bool is_bgra) override;
 
 protected:
-	virtual void paintEvent(QPaintEvent *event);
+	void paintEvent(QPaintEvent *event) override;
 	void showEvent(QShowEvent *event) override;
 
 	void keyPressEvent(QKeyEvent *keyEvent) override;
diff --git a/rpcs3/rpcs3qt/gui_application.cpp b/rpcs3/rpcs3qt/gui_application.cpp
index 9b92cfdab..a25de06ab 100644
--- a/rpcs3/rpcs3qt/gui_application.cpp
+++ b/rpcs3/rpcs3qt/gui_application.cpp
@@ -34,7 +34,6 @@
 #include <QLibraryInfo>
 #include <QDirIterator>
 #include <QFileInfo>
-#include <QSound>
 #include <QMessageBox>
 #include <QTextDocument>
 
@@ -171,7 +170,7 @@ void gui_application::SwitchTranslator(QTranslator& translator, const QString& f
 	// remove the old translator
 	removeTranslator(&translator);
 
-	const QString lang_path = QLibraryInfo::location(QLibraryInfo::TranslationsPath) + QStringLiteral("/");
+	const QString lang_path = QLibraryInfo::path(QLibraryInfo::TranslationsPath) + QStringLiteral("/");
 	const QString file_path = lang_path + filename;
 
 	if (QFileInfo(file_path).isFile())
@@ -234,7 +233,7 @@ QStringList gui_application::GetAvailableLanguageCodes()
 {
 	QStringList language_codes;
 
-	const QString language_path = QLibraryInfo::location(QLibraryInfo::TranslationsPath);
+	const QString language_path = QLibraryInfo::path(QLibraryInfo::TranslationsPath);
 
 	if (QFileInfo(language_path).isDir())
 	{
@@ -543,13 +542,17 @@ void gui_application::InitializeCallbacks()
 		return localized_emu::get_u32string(id, args);
 	};
 
-	callbacks.play_sound = [](const std::string& path)
+	callbacks.play_sound = [this](const std::string& path)
 	{
-		Emu.CallFromMainThread([path]()
+		Emu.CallFromMainThread([this, path]()
 		{
 			if (fs::is_file(path))
 			{
-				QSound::play(qstr(path));
+				m_sound_effect.stop();
+				m_sound_effect.setSource(QUrl::fromLocalFile(qstr(path)));
+				m_sound_effect.setVolume(g_cfg.audio.volume * 0.01f);
+				m_sound_effect.setLoopCount(1);
+				m_sound_effect.play();
 			}
 		});
 	};
diff --git a/rpcs3/rpcs3qt/gui_application.h b/rpcs3/rpcs3qt/gui_application.h
index 762a8a045..321e17479 100644
--- a/rpcs3/rpcs3qt/gui_application.h
+++ b/rpcs3/rpcs3qt/gui_application.h
@@ -7,6 +7,7 @@
 #include <QElapsedTimer>
 #include <QTimer>
 #include <QTranslator>
+#include <QSoundEffect>
 
 #include "main_application.h"
 
@@ -85,6 +86,8 @@ private:
 	QTimer m_timer;
 	QElapsedTimer m_timer_playtime;
 
+	QSoundEffect m_sound_effect{};
+
 	std::shared_ptr<emu_settings> m_emu_settings;
 	std::shared_ptr<gui_settings> m_gui_settings;
 	std::shared_ptr<persistent_settings> m_persistent_settings;
diff --git a/rpcs3/rpcs3qt/main_window.cpp b/rpcs3/rpcs3qt/main_window.cpp
index 02fbb31ae..c0064bd31 100644
--- a/rpcs3/rpcs3qt/main_window.cpp
+++ b/rpcs3/rpcs3qt/main_window.cpp
@@ -156,7 +156,7 @@ bool main_window::Init([[maybe_unused]] bool with_cli_boot)
 	ui->toolbar_start->setEnabled(enable_play_last);
 
 	// create tool buttons for the taskbar thumbnail
-#ifdef _WIN32
+#ifdef HAS_QT_WIN_STUFF
 	m_thumb_bar = new QWinThumbnailToolBar(this);
 	m_thumb_bar->setWindow(windowHandle());
 
@@ -1645,7 +1645,7 @@ void main_window::RepaintThumbnailIcons()
 		return gui::utils::get_colorized_icon(QPixmap::fromImage(gui::utils::get_opaque_image_area(path)), Qt::black, new_color);
 	};
 
-#ifdef _WIN32
+#ifdef HAS_QT_WIN_STUFF
 	if (!m_thumb_bar) return;
 
 	m_icon_thumb_play = icon(":/Icons/play.png");
@@ -1732,14 +1732,6 @@ void main_window::RepaintToolBarIcons()
 
 	// resize toolbar elements
 
-	// for highdpi resize toolbar icons and height dynamically
-	// choose factors to mimic Gui-Design in main_window.ui
-	// TODO: delete this in case Qt::AA_EnableHighDpiScaling is enabled in main.cpp
-#ifdef _WIN32
-	const int tool_icon_height = menuBar()->sizeHint().height() * 1.5;
-	ui->toolBar->setIconSize(QSize(tool_icon_height, tool_icon_height));
-#endif
-
 	const int tool_bar_height = ui->toolBar->sizeHint().height();
 
 	for (const auto& act : ui->toolBar->actions())
@@ -1765,7 +1757,7 @@ void main_window::OnEmuRun(bool /*start_playtime*/) const
 
 	m_debugger_frame->EnableButtons(true);
 
-#ifdef _WIN32
+#ifdef HAS_QT_WIN_STUFF
 	m_thumb_stop->setToolTip(stop_tooltip);
 	m_thumb_restart->setToolTip(restart_tooltip);
 	m_thumb_playPause->setToolTip(pause_tooltip);
@@ -1788,7 +1780,7 @@ void main_window::OnEmuResume() const
 	const QString pause_tooltip = tr("Pause %0").arg(title);
 	const QString stop_tooltip = tr("Stop %0").arg(title);
 
-#ifdef _WIN32
+#ifdef HAS_QT_WIN_STUFF
 	m_thumb_stop->setToolTip(stop_tooltip);
 	m_thumb_restart->setToolTip(restart_tooltip);
 	m_thumb_playPause->setToolTip(pause_tooltip);
@@ -1807,7 +1799,7 @@ void main_window::OnEmuPause() const
 	const QString title = GetCurrentTitle();
 	const QString resume_tooltip = tr("Resume %0").arg(title);
 
-#ifdef _WIN32
+#ifdef HAS_QT_WIN_STUFF
 	m_thumb_playPause->setToolTip(resume_tooltip);
 	m_thumb_playPause->setIcon(m_icon_thumb_play);
 #endif
@@ -1833,7 +1825,7 @@ void main_window::OnEmuStop()
 
 	ui->sysPauseAct->setText(Emu.IsReady() ? tr("&Play") : tr("&Resume"));
 	ui->sysPauseAct->setIcon(m_icon_play);
-#ifdef _WIN32
+#ifdef HAS_QT_WIN_STUFF
 	m_thumb_playPause->setToolTip(play_tooltip);
 	m_thumb_playPause->setIcon(m_icon_thumb_play);
 #endif
@@ -1855,7 +1847,7 @@ void main_window::OnEmuStop()
 		ui->toolbar_start->setText(tr("Restart"));
 		ui->toolbar_start->setToolTip(restart_tooltip);
 		ui->sysRebootAct->setEnabled(true);
-#ifdef _WIN32
+#ifdef HAS_QT_WIN_STUFF
 		m_thumb_restart->setToolTip(restart_tooltip);
 		m_thumb_restart->setEnabled(true);
 #endif
@@ -1888,7 +1880,7 @@ void main_window::OnEmuReady() const
 	const QString play_tooltip = Emu.IsReady() ? tr("Play %0").arg(title) : tr("Resume %0").arg(title);
 
 	m_debugger_frame->EnableButtons(true);
-#ifdef _WIN32
+#ifdef HAS_QT_WIN_STUFF
 	m_thumb_playPause->setToolTip(play_tooltip);
 	m_thumb_playPause->setIcon(m_icon_thumb_play);
 #endif
@@ -1907,7 +1899,7 @@ void main_window::OnEmuReady() const
 void main_window::EnableMenus(bool enabled) const
 {
 	// Thumbnail Buttons
-#ifdef _WIN32
+#ifdef HAS_QT_WIN_STUFF
 	m_thumb_playPause->setEnabled(enabled);
 	m_thumb_stop->setEnabled(enabled);
 	m_thumb_restart->setEnabled(enabled);
@@ -2938,14 +2930,14 @@ void main_window::CreateDockWindows()
 
 			ui->toolbar_start->setEnabled(enable_play_buttons);
 			ui->sysPauseAct->setEnabled(enable_play_buttons);
-#ifdef _WIN32
+#ifdef HAS_QT_WIN_STUFF
 			m_thumb_playPause->setEnabled(enable_play_buttons);
 #endif
 
 			if (!tooltip.isEmpty())
 			{
 				ui->toolbar_start->setToolTip(tooltip);
-#ifdef _WIN32
+#ifdef HAS_QT_WIN_STUFF
 				m_thumb_playPause->setToolTip(tooltip);
 #endif
 			}
@@ -3298,7 +3290,7 @@ void main_window::dropEvent(QDropEvent* event)
 
 		for (const auto& path : drop_paths)
 		{
-			const QFileInfo file_info = path;
+			const QFileInfo file_info(path);
 			const std::string extension = file_info.suffix().toLower().toStdString();
 			const std::string filename = sstr(file_info.fileName());
 
diff --git a/rpcs3/rpcs3qt/main_window.cpp.orig b/rpcs3/rpcs3qt/main_window.cpp.orig
new file mode 100644
index 000000000..02fbb31ae
--- /dev/null
+++ b/rpcs3/rpcs3qt/main_window.cpp.orig
@@ -0,0 +1,3405 @@
+#include "main_window.h"
+#include "qt_utils.h"
+#include "vfs_dialog.h"
+#include "save_manager_dialog.h"
+#include "trophy_manager_dialog.h"
+#include "user_manager_dialog.h"
+#include "screenshot_manager_dialog.h"
+#include "kernel_explorer.h"
+#include "game_list_frame.h"
+#include "debugger_frame.h"
+#include "log_frame.h"
+#include "settings_dialog.h"
+#include "rpcn_settings_dialog.h"
+#include "auto_pause_settings_dialog.h"
+#include "cg_disasm_window.h"
+#include "log_viewer.h"
+#include "memory_viewer_panel.h"
+#include "rsx_debugger.h"
+#include "about_dialog.h"
+#include "pad_settings_dialog.h"
+#include "progress_dialog.h"
+#include "skylander_dialog.h"
+#include "infinity_dialog.h"
+#include "cheat_manager.h"
+#include "patch_manager_dialog.h"
+#include "patch_creator_dialog.h"
+#include "pkg_install_dialog.h"
+#include "category.h"
+#include "gui_settings.h"
+#include "input_dialog.h"
+#include "camera_settings_dialog.h"
+#include "ipc_settings_dialog.h"
+#include "shortcut_utils.h"
+#include "config_checker.h"
+#include "shortcut_dialog.h"
+#include "system_cmd_dialog.h"
+#include "emulated_pad_settings_dialog.h"
+
+#include <thread>
+#include <charconv>
+
+#include <QScreen>
+#include <QDirIterator>
+#include <QMimeData>
+#include <QMessageBox>
+#include <QFileDialog>
+#include <QFontDatabase>
+#include <QBuffer>
+#include <QTemporaryFile>
+
+#include "rpcs3_version.h"
+#include "Emu/IdManager.h"
+#include "Emu/VFS.h"
+#include "Emu/vfs_config.h"
+#include "Emu/System.h"
+#include "Emu/system_utils.hpp"
+
+#include "Crypto/unpkg.h"
+#include "Crypto/unself.h"
+#include "Crypto/decrypt_binaries.h"
+
+#include "Loader/PUP.h"
+#include "Loader/TAR.h"
+#include "Loader/PSF.h"
+#include "Loader/mself.hpp"
+
+#include "Utilities/Thread.h"
+#include "util/sysinfo.hpp"
+
+#include "ui_main_window.h"
+
+LOG_CHANNEL(gui_log, "GUI");
+
+extern atomic_t<bool> g_user_asked_for_frame_capture;
+
+class CPUDisAsm;
+std::shared_ptr<CPUDisAsm> make_basic_ppu_disasm();
+
+inline std::string sstr(const QString& _in) { return _in.toStdString(); }
+
+extern void process_qt_events()
+{
+	if (thread_ctrl::is_main())
+	{
+		// NOTE:
+		// I noticed that calling this from an Emu callback can cause the
+		// caller to get stuck for a while during newly opened Qt dialogs.
+		// Adding a timeout here doesn't seem to do anything in that case.
+		QApplication::processEvents();
+	}
+}
+
+main_window::main_window(std::shared_ptr<gui_settings> gui_settings, std::shared_ptr<emu_settings> emu_settings, std::shared_ptr<persistent_settings> persistent_settings, QWidget *parent)
+	: QMainWindow(parent)
+	, ui(new Ui::main_window)
+	, m_gui_settings(gui_settings)
+	, m_emu_settings(std::move(emu_settings))
+	, m_persistent_settings(std::move(persistent_settings))
+	, m_updater(nullptr, gui_settings)
+{
+	Q_INIT_RESOURCE(resources);
+
+	// We have to setup the ui before using a translation
+	ui->setupUi(this);
+
+	setAttribute(Qt::WA_DeleteOnClose);
+}
+
+main_window::~main_window()
+{
+	SaveWindowState();
+}
+
+/* An init method is used so that RPCS3App can create the necessary connects before calling init (specifically the stylesheet connect).
+ * Simplifies logic a bit.
+ */
+bool main_window::Init([[maybe_unused]] bool with_cli_boot)
+{
+	setAcceptDrops(true);
+
+	// add toolbar widgets (crappy Qt designer is not able to)
+	ui->toolBar->setObjectName("mw_toolbar");
+	ui->sizeSlider->setRange(0, gui::gl_max_slider_pos);
+	ui->toolBar->addWidget(ui->sizeSliderContainer);
+	ui->toolBar->addWidget(ui->mw_searchbar);
+
+	CreateActions();
+	CreateDockWindows();
+	CreateConnects();
+
+	setMinimumSize(350, minimumSizeHint().height());    // seems fine on win 10
+	setWindowTitle(QString::fromStdString("RPCS3 " + rpcs3::get_verbose_version()));
+
+	Q_EMIT RequestGlobalStylesheetChange();
+	ConfigureGuiFromSettings();
+
+	m_shortcut_handler = new shortcut_handler(gui::shortcuts::shortcut_handler_id::main_window, this, m_gui_settings);
+	connect(m_shortcut_handler, &shortcut_handler::shortcut_activated, this, &main_window::handle_shortcut);
+
+	show(); // needs to be done before creating the thumbnail toolbar
+
+	// enable play options if a recent game exists
+	const bool enable_play_last = !m_recent_game_acts.isEmpty() && m_recent_game_acts.first();
+
+	const QString start_tooltip = enable_play_last ? tr("Play %0").arg(m_recent_game_acts.first()->text()) : tr("Play");
+
+	if (enable_play_last)
+	{
+		ui->sysPauseAct->setText(tr("&Play last played game"));
+		ui->sysPauseAct->setShortcut(QKeySequence("Ctrl+R"));
+		ui->sysPauseAct->setIcon(m_icon_play);
+		ui->toolbar_start->setToolTip(start_tooltip);
+	}
+
+	ui->sysPauseAct->setEnabled(enable_play_last);
+	ui->toolbar_start->setEnabled(enable_play_last);
+
+	// create tool buttons for the taskbar thumbnail
+#ifdef _WIN32
+	m_thumb_bar = new QWinThumbnailToolBar(this);
+	m_thumb_bar->setWindow(windowHandle());
+
+	m_thumb_playPause = new QWinThumbnailToolButton(m_thumb_bar);
+	m_thumb_playPause->setToolTip(start_tooltip);
+	m_thumb_playPause->setIcon(m_icon_thumb_play);
+	m_thumb_playPause->setEnabled(enable_play_last);
+
+	m_thumb_stop = new QWinThumbnailToolButton(m_thumb_bar);
+	m_thumb_stop->setToolTip(tr("Stop"));
+	m_thumb_stop->setIcon(m_icon_thumb_stop);
+	m_thumb_stop->setEnabled(false);
+
+	m_thumb_restart = new QWinThumbnailToolButton(m_thumb_bar);
+	m_thumb_restart->setToolTip(tr("Restart"));
+	m_thumb_restart->setIcon(m_icon_thumb_restart);
+	m_thumb_restart->setEnabled(false);
+
+	m_thumb_bar->addButton(m_thumb_playPause);
+	m_thumb_bar->addButton(m_thumb_stop);
+	m_thumb_bar->addButton(m_thumb_restart);
+
+	RepaintThumbnailIcons();
+
+	connect(m_thumb_stop, &QWinThumbnailToolButton::clicked, this, []()
+	{
+		gui_log.notice("User clicked stop button on thumbnail toolbar");
+		Emu.GracefulShutdown(false, true);
+	});
+	connect(m_thumb_restart, &QWinThumbnailToolButton::clicked, this, []()
+	{
+		gui_log.notice("User clicked restart button on thumbnail toolbar");
+		Emu.Restart();
+	});
+	connect(m_thumb_playPause, &QWinThumbnailToolButton::clicked, this, &main_window::OnPlayOrPause);
+#endif
+
+	// RPCS3 Updater
+
+	QMenu* download_menu = new QMenu(tr("Update Available!"));
+
+	QAction* download_action = new QAction(tr("Download Update"), download_menu);
+	connect(download_action, &QAction::triggered, this, [this]
+	{
+		m_updater.update(false);
+	});
+
+	download_menu->addAction(download_action);
+
+#ifdef _WIN32
+	// Use a menu at the top right corner to indicate the new version.
+	QMenuBar *corner_bar = new QMenuBar(ui->menuBar);
+	m_download_menu_action = corner_bar->addMenu(download_menu);
+	ui->menuBar->setCornerWidget(corner_bar);
+	ui->menuBar->cornerWidget()->setVisible(false);
+#else
+	// Append a menu to the right of the regular menus to indicate the new version.
+	// Some distros just can't handle corner widgets at the moment.
+	m_download_menu_action = ui->menuBar->addMenu(download_menu);
+#endif
+
+	ensure(m_download_menu_action);
+	m_download_menu_action->setVisible(false);
+
+	connect(&m_updater, &update_manager::signal_update_available, this, [this](bool update_available)
+	{
+		if (m_download_menu_action)
+		{
+			m_download_menu_action->setVisible(update_available);
+		}
+		if (ui->menuBar && ui->menuBar->cornerWidget())
+		{
+			ui->menuBar->cornerWidget()->setVisible(update_available);
+		}
+	});
+
+#if defined(_WIN32) || defined(__linux__)
+	if (const auto update_value = m_gui_settings->GetValue(gui::m_check_upd_start).toString(); update_value != gui::update_off)
+	{
+		const bool in_background = with_cli_boot || update_value == gui::update_bkg;
+		const bool auto_accept   = !in_background && update_value == gui::update_auto;
+		m_updater.check_for_updates(true, in_background, auto_accept, this);
+	}
+#endif
+
+	// Disable vsh if not present.
+	ui->bootVSHAct->setEnabled(fs::is_file(g_cfg_vfs.get_dev_flash() + "vsh/module/vsh.self"));
+
+	// Focus to search bar by default
+	ui->mw_searchbar->setFocus();
+
+	// Refresh gamelist last
+	m_game_list_frame->Refresh(true);
+
+	return true;
+}
+
+QString main_window::GetCurrentTitle()
+{
+	QString title = qstr(Emu.GetTitleAndTitleID());
+	if (title.isEmpty())
+	{
+		title = qstr(Emu.GetBoot());
+	}
+	return title;
+}
+
+// returns appIcon
+QIcon main_window::GetAppIcon() const
+{
+	return m_app_icon;
+}
+
+bool main_window::OnMissingFw()
+{
+	const QString title = tr("Missing Firmware Detected!");
+	const QString message = tr("Commercial games require the firmware (PS3UPDAT.PUP file) to be installed."
+				"\n<br>For information about how to obtain the required firmware read the <a href=\"https://rpcs3.net/quickstart\">quickstart guide</a>.");
+
+	QMessageBox mb(QMessageBox::Question, title, message, QMessageBox::Ok | QMessageBox::Cancel, this, Qt::Dialog | Qt::MSWindowsFixedSizeDialogHint | Qt::WindowStaysOnTopHint);
+	mb.setTextFormat(Qt::RichText);
+
+	mb.button(QMessageBox::Ok)->setText(tr("Locate PS3UPDAT.PUP"));
+
+	if (mb.exec() == QMessageBox::Ok)
+	{
+		InstallPup();
+		return true;
+	}
+
+	return false;
+}
+
+void main_window::ResizeIcons(int index)
+{
+	if (ui->sizeSlider->value() != index)
+	{
+		ui->sizeSlider->setSliderPosition(index);
+		return; // ResizeIcons will be triggered again by setSliderPosition, so return here
+	}
+
+	if (m_save_slider_pos)
+	{
+		m_save_slider_pos = false;
+		m_gui_settings->SetValue(m_is_list_mode ? gui::gl_iconSize : gui::gl_iconSizeGrid, index);
+
+		// this will also fire when we used the actions, but i didn't want to add another boolean member
+		SetIconSizeActions(index);
+	}
+
+	m_game_list_frame->ResizeIcons(index);
+}
+
+void main_window::handle_shortcut(gui::shortcuts::shortcut shortcut_key, const QKeySequence& key_sequence)
+{
+	gui_log.notice("Main window registered shortcut: %s (%s)", shortcut_key, key_sequence.toString().toStdString());
+
+	const system_state status = Emu.GetStatus();
+
+	switch (shortcut_key)
+	{
+	case gui::shortcuts::shortcut::mw_toggle_fullscreen:
+	{
+		ui->toolbar_fullscreen->trigger();
+		break;
+	}
+	case gui::shortcuts::shortcut::mw_exit_fullscreen:
+	{
+		if (isFullScreen())
+			ui->toolbar_fullscreen->trigger();
+		break;
+	}
+	case gui::shortcuts::shortcut::mw_refresh:
+	{
+		m_game_list_frame->Refresh(true);
+		break;
+	}
+	case gui::shortcuts::shortcut::mw_pause:
+	{
+		if (status == system_state::running)
+			Emu.Pause();
+		break;
+	}
+	case gui::shortcuts::shortcut::mw_restart:
+	{
+		if (status == system_state::paused)
+			Emu.Resume();
+		else if (status == system_state::ready)
+			Emu.Run(true);
+		break;
+	}
+	case gui::shortcuts::shortcut::mw_start:
+	{
+		if (!Emu.GetBoot().empty())
+			Emu.Restart();
+		break;
+	}
+	case gui::shortcuts::shortcut::mw_stop:
+	{
+		if (status != system_state::stopped)
+			Emu.GracefulShutdown(false, true);
+		break;
+	}
+	default:
+	{
+		break;
+	}
+	}
+}
+
+void main_window::OnPlayOrPause()
+{
+	gui_log.notice("User triggered OnPlayOrPause");
+
+	switch (Emu.GetStatus())
+	{
+	case system_state::ready: Emu.Run(true); return;
+	case system_state::paused: Emu.Resume(); return;
+	case system_state::running: Emu.Pause(); return;
+	case system_state::stopped:
+	{
+		if (m_selected_game)
+		{
+			gui_log.notice("Booting from OnPlayOrPause...");
+			Boot(m_selected_game->info.path, m_selected_game->info.serial);
+		}
+		else if (const auto path = Emu.GetBoot(); !path.empty())
+		{
+			if (const auto error = Emu.Load(); error != game_boot_result::no_errors)
+			{
+				gui_log.error("Boot failed: reason: %s, path: %s", error, path);
+				show_boot_error(error);
+			}
+		}
+		else if (!m_recent_game_acts.isEmpty())
+		{
+			BootRecentAction(m_recent_game_acts.first());
+		}
+
+		return;
+	}
+	case system_state::starting: break;
+	default: fmt::throw_exception("Unreachable");
+	}
+}
+
+void main_window::show_boot_error(game_boot_result status)
+{
+	QString message;
+	switch (status)
+	{
+	case game_boot_result::nothing_to_boot:
+		message = tr("No bootable content was found.");
+		break;
+	case game_boot_result::wrong_disc_location:
+		message = tr("Disc could not be mounted properly. Make sure the disc is not in the dev_hdd0/game folder.");
+		break;
+	case game_boot_result::invalid_file_or_folder:
+		message = tr("The selected file or folder is invalid or corrupted.");
+		break;
+	case game_boot_result::invalid_bdvd_folder:
+		message = tr("The virtual dev_bdvd folder does not exist or is not empty.");
+		break;
+	case game_boot_result::install_failed:
+		message = tr("Additional content could not be installed.");
+		break;
+	case game_boot_result::decryption_error:
+		message = tr("Digital content could not be decrypted. This is usually caused by a missing or invalid license (RAP) file.");
+		break;
+	case game_boot_result::file_creation_error:
+		message = tr("The emulator could not create files required for booting.");
+		break;
+	case game_boot_result::unsupported_disc_type:
+		message = tr("This disc type is not supported yet.");
+		break;
+	case game_boot_result::savestate_corrupted:
+		message = tr("Savestate data is corrupted or it's not an RPCS3 savestate.");
+		break;
+	case game_boot_result::savestate_version_unsupported:
+		message = tr("Savestate versioning data differes from your RPCS3 build.");
+		break;
+	case game_boot_result::firmware_missing: // Handled elsewhere
+	case game_boot_result::no_errors:
+		return;
+	case game_boot_result::generic_error:
+		message = tr("Unknown error.");
+		break;
+	}
+	const QString link = tr("<br /><br />For information on setting up the emulator and dumping your PS3 games, read the <a href=\"https://rpcs3.net/quickstart\">quickstart guide</a>.");
+
+	QMessageBox msg;
+	msg.setWindowTitle(tr("Boot Failed"));
+	msg.setIcon(QMessageBox::Critical);
+	msg.setTextFormat(Qt::RichText);
+	msg.setStandardButtons(QMessageBox::Ok);
+	msg.setText(tr("Booting failed: %1 %2").arg(message).arg(link));
+	msg.exec();
+}
+
+void main_window::Boot(const std::string& path, const std::string& title_id, bool direct, bool refresh_list, cfg_mode config_mode, const std::string& config_path)
+{
+	if (!m_gui_settings->GetBootConfirmation(this, gui::ib_confirm_boot))
+	{
+		return;
+	}
+
+	Emu.GracefulShutdown(false);
+
+	m_app_icon = gui::utils::get_app_icon_from_path(path, title_id);
+
+	if (const auto error = Emu.BootGame(path, title_id, direct, config_mode, config_path); error != game_boot_result::no_errors)
+	{
+		gui_log.error("Boot failed: reason: %s, path: %s", error, path);
+		show_boot_error(error);
+	}
+	else
+	{
+		gui_log.success("Boot successful.");
+
+		AddRecentAction(gui::Recent_Game(qstr(Emu.GetBoot()), qstr(Emu.GetTitleAndTitleID())));
+
+		if (refresh_list)
+		{
+			m_game_list_frame->Refresh(true);
+		}
+	}
+}
+
+void main_window::BootElf()
+{
+	bool stopped = false;
+
+	if (Emu.IsRunning())
+	{
+		Emu.Pause();
+		stopped = true;
+	}
+
+	const QString path_last_elf = m_gui_settings->GetValue(gui::fd_boot_elf).toString();
+	const QString file_path = QFileDialog::getOpenFileName(this, tr("Select (S)ELF To Boot"), path_last_elf, tr(
+		"(S)ELF files (*BOOT.BIN *.elf *.self);;"
+		"ELF files (BOOT.BIN *.elf);;"
+		"SELF files (EBOOT.BIN *.self);;"
+		"BOOT files (*BOOT.BIN);;"
+		"BIN files (*.bin);;"
+		"All files (*.*)"),
+		Q_NULLPTR, QFileDialog::DontResolveSymlinks);
+
+	if (file_path.isEmpty())
+	{
+		if (stopped)
+		{
+			Emu.Resume();
+		}
+		return;
+	}
+
+	// If we resolved the filepath earlier we would end up setting the last opened dir to the unwanted
+	// game folder in case of having e.g. a Game Folder with collected links to elf files.
+	// Don't set last path earlier in case of cancelled dialog
+	m_gui_settings->SetValue(gui::fd_boot_elf, file_path);
+	const std::string path = sstr(QFileInfo(file_path).absoluteFilePath());
+
+	gui_log.notice("Booting from BootElf...");
+	Boot(path, "", true, true);
+}
+
+void main_window::BootTest()
+{
+	bool stopped = false;
+
+	if (Emu.IsRunning())
+	{
+		Emu.Pause();
+		stopped = true;
+	}
+
+#ifdef _WIN32
+	const QString path_tests = QString::fromStdString(fs::get_config_dir()) + "/test/";
+#elif defined(__linux__)
+	const QString path_tests = QCoreApplication::applicationDirPath() + "/../share/rpcs3/test/";
+#else
+	const QString path_tests = QCoreApplication::applicationDirPath() + "/../Resources/test/";
+#endif
+
+	const QString file_path = QFileDialog::getOpenFileName(this, tr("Select (S)ELF To Boot"), path_tests, tr(
+		"(S)ELF files (*.elf *.self);;"
+		"ELF files (*.elf);;"
+		"SELF files (*.self);;"
+		"All files (*.*)"),
+		Q_NULLPTR, QFileDialog::DontResolveSymlinks);
+
+	if (file_path.isEmpty())
+	{
+		if (stopped)
+		{
+			Emu.Resume();
+		}
+		return;
+	}
+
+	const std::string path = sstr(QFileInfo(file_path).absoluteFilePath());
+
+	gui_log.notice("Booting from BootTest...");
+	Boot(path, "", true);
+}
+
+void main_window::BootSavestate()
+{
+	bool stopped = false;
+
+	if (Emu.IsRunning())
+	{
+		Emu.Pause();
+		stopped = true;
+	}
+
+	const QString file_path = QFileDialog::getOpenFileName(this, tr("Select Savestate To Boot"), qstr(fs::get_cache_dir() + "/savestates/"), tr(
+		"Savestate files (*.SAVESTAT);;"
+		"All files (*.*)"),
+		Q_NULLPTR, QFileDialog::DontResolveSymlinks);
+
+	if (file_path.isEmpty())
+	{
+		if (stopped)
+		{
+			Emu.Resume();
+		}
+		return;
+	}
+
+	const std::string path = sstr(QFileInfo(file_path).absoluteFilePath());
+
+	gui_log.notice("Booting from BootSavestate...");
+	Boot(path, "", true);
+}
+
+void main_window::BootGame()
+{
+	bool stopped = false;
+
+	if (Emu.IsRunning())
+	{
+		Emu.Pause();
+		stopped = true;
+	}
+
+	const QString path_last_game = m_gui_settings->GetValue(gui::fd_boot_game).toString();
+	const QString dir_path = QFileDialog::getExistingDirectory(this, tr("Select Game Folder"), path_last_game, QFileDialog::ShowDirsOnly | QFileDialog::DontResolveSymlinks);
+
+	if (dir_path.isEmpty())
+	{
+		if (stopped)
+		{
+			Emu.Resume();
+		}
+		return;
+	}
+
+	m_gui_settings->SetValue(gui::fd_boot_game, QFileInfo(dir_path).path());
+
+	gui_log.notice("Booting from BootGame...");
+	Boot(sstr(dir_path), "", false, true);
+}
+
+void main_window::BootVSH()
+{
+	gui_log.notice("Booting from BootVSH...");
+	Boot(g_cfg_vfs.get_dev_flash() + "/vsh/module/vsh.self");
+}
+
+void main_window::BootRsxCapture(std::string path)
+{
+	if (path.empty())
+	{
+		bool is_stopped = false;
+
+		if (Emu.IsRunning())
+		{
+			Emu.Pause();
+			is_stopped = true;
+		}
+
+		const QString file_path = QFileDialog::getOpenFileName(this, tr("Select RSX Capture"), qstr(fs::get_config_dir() + "captures/"), tr("RRC files (*.rrc *.RRC);;All files (*.*)"));
+
+		if (file_path.isEmpty())
+		{
+			if (is_stopped)
+			{
+				Emu.Resume();
+			}
+			return;
+		}
+		path = sstr(file_path);
+	}
+
+	if (!m_gui_settings->GetBootConfirmation(this))
+	{
+		return;
+	}
+
+	Emu.GracefulShutdown(false);
+
+	if (!Emu.BootRsxCapture(path))
+	{
+		gui_log.error("Capture Boot Failed. path: %s", path);
+	}
+	else
+	{
+		gui_log.success("Capture Boot Success. path: %s", path);
+	}
+}
+
+bool main_window::InstallFileInExData(const std::string& extension, const QString& path, const std::string& filename)
+{
+	if (path.isEmpty() || filename.empty() || extension.empty())
+	{
+		return false;
+	}
+
+	// Copy file atomically with thread/process-safe error checking for file size
+	const std::string to_path = rpcs3::utils::get_hdd0_dir() + "/home/" + Emu.GetUsr() + "/exdata/" + filename.substr(0, filename.find_last_of('.'));
+	fs::pending_file to(to_path + "." + extension);
+	fs::file from(sstr(path));
+
+	if (!to.file || !from)
+	{
+		return false;
+	}
+
+	to.file.write(from.to_vector<u8>());
+	from.close();
+
+	if (to.file.size() < 0x10)
+	{
+		// Not a RAP file
+		return false;
+	}
+
+#ifdef _WIN32
+	// In the case of an unexpected crash during the operation, the temporary file can be used as the deleted file
+	// See below
+	to.file.sync();
+
+	// In case we want to rename upper-case file to lower-case
+	// Windows will ignore such rename operation if the file exists
+	// So delete it
+	fs::remove_file(to_path + "." + fmt::to_upper(extension));
+#endif
+
+	return to.commit();
+}
+
+bool main_window::InstallPackages(QStringList file_paths, bool from_boot)
+{
+	if (file_paths.isEmpty())
+	{
+		ensure(!from_boot);
+
+		// If this function was called without a path, ask the user for files to install.
+		const QString path_last_pkg = m_gui_settings->GetValue(gui::fd_install_pkg).toString();
+		const QStringList paths = QFileDialog::getOpenFileNames(this, tr("Select packages and/or rap files to install"),
+			path_last_pkg, tr("All relevant (*.pkg *.PKG *.rap *.RAP *.edat *.EDAT);;Package files (*.pkg *.PKG);;Rap files (*.rap *.RAP);;Edat files (*.edat *.EDAT);;All files (*.*)"));
+
+		if (paths.isEmpty())
+		{
+			return true;
+		}
+
+		file_paths.append(paths);
+		const QFileInfo file_info(file_paths[0]);
+		m_gui_settings->SetValue(gui::fd_install_pkg, file_info.path());
+	}
+
+	if (file_paths.count() == 1 && file_paths.front().endsWith(".pkg", Qt::CaseInsensitive))
+	{
+		const QString file_path = file_paths.front();
+		const QFileInfo file_info(file_path);
+
+		compat::package_info info = game_compatibility::GetPkgInfo(file_path, m_game_list_frame ? m_game_list_frame->GetGameCompatibility() : nullptr);
+
+		if (!info.is_valid)
+		{
+			QMessageBox::warning(this, tr("Invalid package!"), tr("The selected package is invalid!\n\nPath:\n%0").arg(file_path));
+			return false;
+		}
+
+		if (info.type != compat::package_type::other)
+		{
+			if (info.type == compat::package_type::dlc)
+			{
+				info.local_cat = tr("\nDLC", "Block for package type (DLC)");
+			}
+			else
+			{
+				info.local_cat = tr("\nUpdate", "Block for package type (Update)");
+			}
+		}
+		else if (!info.local_cat.isEmpty())
+		{
+			info.local_cat = tr("\n%0", "Block for package type").arg(info.local_cat);
+		}
+
+		if (!info.title_id.isEmpty())
+		{
+			info.title_id = tr("\n%0", "Block for Title ID").arg(info.title_id);
+		}
+
+		if (!info.version.isEmpty())
+		{
+			info.version = tr("\nVersion %0", "Block for Version").arg(info.version);
+		}
+
+		if (!info.changelog.isEmpty())
+		{
+			info.changelog = tr("\n\nChangelog:\n%0", "Block for Changelog").arg(info.changelog);
+		}
+
+		const QString info_string = QStringLiteral("%0\n\n%1%2%3%4%5").arg(file_info.fileName()).arg(info.title).arg(info.local_cat)
+			.arg(info.title_id).arg(info.version).arg(info.changelog);
+
+		if (QMessageBox::question(this, tr("PKG Decrypter / Installer"), tr("Do you want to install this package?\n\n%0").arg(info_string),
+			QMessageBox::Yes | QMessageBox::No, QMessageBox::No) != QMessageBox::Yes)
+		{
+			gui_log.notice("PKG: Cancelled installation from drop.\n%s", sstr(info_string));
+			return true;
+		}
+	}
+
+	// Install rap files if available
+	int installed_rap_and_edat_count = 0;
+
+	const auto install_filetype = [&installed_rap_and_edat_count, &file_paths](const std::string extension)
+	{
+		const QString pattern = QString(".*\\.%1").arg(QString::fromStdString(extension));
+		for (const auto& file : file_paths.filter(QRegularExpression(pattern, QRegularExpression::PatternOption::CaseInsensitiveOption)))
+		{
+			const QFileInfo file_info(file);
+			const std::string filename = sstr(file_info.fileName());
+
+			if (InstallFileInExData(extension, file, filename))
+			{
+				gui_log.success("Successfully copied %s file: %s", extension, filename);
+				installed_rap_and_edat_count++;
+			}
+			else
+			{
+				gui_log.error("Could not copy %s file: %s", extension, filename);
+			}
+		}
+	};
+
+	if (!from_boot)
+	{
+		if (!m_gui_settings->GetBootConfirmation(this))
+		{
+			// Last chance to cancel the operation
+			return true;
+		}
+
+		if (!Emu.IsStopped())
+		{
+			Emu.GracefulShutdown(false);
+		}
+
+		install_filetype("rap");
+		install_filetype("edat");
+	}
+
+	if (installed_rap_and_edat_count > 0)
+	{
+		// Refresh game list since we probably unlocked some games now.
+		m_game_list_frame->Refresh(true);
+	}
+
+	// Find remaining package files
+	file_paths = file_paths.filter(QRegularExpression(".*\\.pkg", QRegularExpression::PatternOption::CaseInsensitiveOption));
+
+	if (file_paths.isEmpty())
+	{
+		return true;
+	}
+
+	if (from_boot)
+	{
+		return HandlePackageInstallation(file_paths, true);
+	}
+
+	// Handle further installations with a timeout. Otherwise the source explorer instance is not usable during the following file processing.
+	QTimer::singleShot(0, [this, paths = std::move(file_paths)]()
+	{
+		HandlePackageInstallation(paths, false);
+	});
+
+	return true;
+}
+
+bool main_window::HandlePackageInstallation(QStringList file_paths, bool from_boot)
+{
+	if (file_paths.empty())
+	{
+		return false;
+	}
+
+	std::vector<compat::package_info> packages;
+
+	game_compatibility* compat = m_game_list_frame ? m_game_list_frame->GetGameCompatibility() : nullptr;
+
+	if (file_paths.size() > 1)
+	{
+		// Let the user choose the packages to install and select the order in which they shall be installed.
+		pkg_install_dialog dlg(file_paths, compat, this);
+		connect(&dlg, &QDialog::accepted, this, [&packages, &dlg]()
+		{
+			packages = dlg.GetPathsToInstall();
+		});
+		dlg.exec();
+	}
+	else
+	{
+		packages.push_back(game_compatibility::GetPkgInfo(file_paths.front(), compat));
+	}
+
+	if (packages.empty())
+	{
+		return true;
+	}
+
+	if (!from_boot)
+	{
+		if (!m_gui_settings->GetBootConfirmation(this))
+		{
+			return true;
+		}
+
+		Emu.GracefulShutdown(false);
+	}
+
+	std::vector<std::string> path_vec;
+	for (const compat::package_info& pkg : packages)
+	{
+		path_vec.push_back(pkg.path.toStdString());
+	}
+	gui_log.notice("About to install packages:\n%s", fmt::merge(path_vec, "\n"));
+
+	progress_dialog pdlg(tr("RPCS3 Package Installer"), tr("Installing package, please wait..."), tr("Cancel"), 0, 1000, false, this);
+	pdlg.setAutoClose(false);
+	pdlg.show();
+
+	package_error error = package_error::no_error;
+
+	auto get_app_info = [](compat::package_info& package)
+	{
+		QString app_info = package.title; // This should always be non-empty
+
+		if (!package.title_id.isEmpty() || !package.version.isEmpty())
+		{
+			app_info += QStringLiteral("\n");
+
+			if (!package.title_id.isEmpty())
+			{
+				app_info += package.title_id;
+			}
+
+			if (!package.version.isEmpty())
+			{
+				if (!package.title_id.isEmpty())
+				{
+					app_info += " ";
+				}
+
+				app_info += tr("v.%0", "Package version for install progress dialog").arg(package.version);
+			}
+		}
+
+		return app_info;
+	};
+
+	bool cancelled = false;
+
+	std::deque<package_reader> readers;
+
+	for (const compat::package_info& info : packages)
+	{
+		readers.emplace_back(sstr(info.path));
+	}
+
+	std::deque<std::string> bootable_paths;
+
+	// Run PKG unpacking asynchronously
+	named_thread worker("PKG Installer", [&readers, &error, &bootable_paths]
+	{
+		error = package_reader::extract_data(readers, bootable_paths);
+		return error == package_error::no_error;
+	});
+
+	pdlg.show();
+
+	// Wait for the completion
+	for (usz i = 0, set_text = umax; i < readers.size() && error == package_error::no_error;)
+	{
+		std::this_thread::sleep_for(5ms);
+
+		if (pdlg.wasCanceled())
+		{
+			cancelled = true;
+
+			for (package_reader& reader : readers)
+			{
+				reader.abort_extract();
+			}
+
+			break;
+		}
+
+		// Update progress window
+		const int progress = readers[i].get_progress(pdlg.maximum());
+		pdlg.SetValue(progress);
+
+		if (set_text != i)
+		{
+			pdlg.setLabelText(tr("Installing package (%0/%1), please wait...\n\n%2").arg(i + 1).arg(readers.size()).arg(get_app_info(packages[i])));
+			set_text = i;
+		}
+
+		QCoreApplication::processEvents();
+
+		if (progress == pdlg.maximum())
+		{
+			i++;
+		}
+	}
+
+	const bool success = worker();
+
+	if (success)
+	{
+		pdlg.SetValue(pdlg.maximum());
+		std::this_thread::sleep_for(100ms);
+
+		for (usz i = 0; i < packages.size(); i++)
+		{
+			const compat::package_info& package = ::at32(packages, i);
+			const package_reader& reader = ::at32(readers, i);
+
+			switch (reader.get_result())
+			{
+			case package_reader::result::success:
+			{
+				gui_log.success("Successfully installed %s (title_id=%s, title=%s, version=%s).", sstr(package.path), sstr(package.title_id), sstr(package.title), sstr(package.version));
+				break;
+			}
+			case package_reader::result::not_started:
+			case package_reader::result::started:
+			case package_reader::result::aborted:
+			{
+				gui_log.notice("Aborted installation of %s (title_id=%s, title=%s, version=%s).", sstr(package.path), sstr(package.title_id), sstr(package.title), sstr(package.version));
+				break;
+			}
+			case package_reader::result::error:
+			{
+				gui_log.error("Failed to install %s (title_id=%s, title=%s, version=%s).", sstr(package.path), sstr(package.title_id), sstr(package.title), sstr(package.version));
+				break;
+			}
+			case package_reader::result::aborted_dirty:
+			case package_reader::result::error_dirty:
+			{
+				gui_log.error("Partially installed %s (title_id=%s, title=%s, version=%s).", sstr(package.path), sstr(package.title_id), sstr(package.title), sstr(package.version));
+				break;
+			}
+			}
+		}
+
+		m_game_list_frame->Refresh(true);
+
+		std::map<std::string, QString> bootable_paths_installed; // -> title id
+
+		for (usz index = 0; index < bootable_paths.size(); index++)
+		{
+			if (bootable_paths[index].empty())
+			{
+				continue;
+			}
+
+			bootable_paths_installed[bootable_paths[index]] = packages[index].title_id;
+		}
+
+		pdlg.hide();
+
+		if (!cancelled || !bootable_paths_installed.empty())
+		{
+			if (bootable_paths_installed.empty())
+			{
+				m_gui_settings->ShowInfoBox(tr("Success!"), tr("Successfully installed software from package(s)!"), gui::ib_pkg_success, this);
+				return true;
+			}
+
+			auto dlg = new QDialog(this);
+			dlg->setWindowTitle(tr("Success!"));
+
+			QVBoxLayout* vlayout = new QVBoxLayout(dlg);
+
+			QCheckBox* desk_check = new QCheckBox(tr("Add desktop shortcut(s)"));
+#ifdef _WIN32
+			QCheckBox* quick_check = new QCheckBox(tr("Add Start menu shortcut(s)"));
+#elif defined(__APPLE__)
+			QCheckBox* quick_check = new QCheckBox(tr("Add dock shortcut(s)"));
+#else
+			QCheckBox* quick_check = new QCheckBox(tr("Add launcher shortcut(s)"));
+#endif
+			QLabel* label = new QLabel(tr("Successfully installed software from package(s)!\nWould you like to install shortcuts to the installed software? (%1 new software detected)\n\n").arg(bootable_paths_installed.size()), dlg);
+
+			vlayout->addWidget(label);
+			vlayout->addStretch(10);
+			vlayout->addWidget(desk_check);
+			vlayout->addStretch(3);
+			vlayout->addWidget(quick_check);
+			vlayout->addStretch(3);
+
+			QDialogButtonBox* btn_box = new QDialogButtonBox(QDialogButtonBox::Ok);
+
+			vlayout->addWidget(btn_box);
+			dlg->setLayout(vlayout);
+
+			bool create_desktop_shortcuts = false;
+			bool create_app_shortcut = false;
+
+			connect(btn_box, &QDialogButtonBox::accepted, this, [&]()
+			{
+				create_desktop_shortcuts = desk_check->isChecked();
+				create_app_shortcut = quick_check->isChecked();
+				dlg->accept();
+			});
+
+			dlg->setAttribute(Qt::WA_DeleteOnClose);
+			dlg->exec();
+
+			std::set<gui::utils::shortcut_location> locations;
+#ifdef _WIN32
+			locations.insert(gui::utils::shortcut_location::rpcs3_shortcuts);
+#endif
+			if (create_desktop_shortcuts)
+			{
+				locations.insert(gui::utils::shortcut_location::desktop);
+			}
+			if (create_app_shortcut)
+			{
+				locations.insert(gui::utils::shortcut_location::applications);
+			}
+
+			for (const auto& [boot_path, title_id] : bootable_paths_installed)
+			{
+				for (const game_info& gameinfo : m_game_list_frame->GetGameInfo())
+				{
+					if (gameinfo && gameinfo->info.bootable && gameinfo->info.serial == sstr(title_id) && boot_path.starts_with(gameinfo->info.path))
+					{
+						m_game_list_frame->CreateShortcuts(gameinfo, locations);
+						break;
+					}
+				}
+			}
+		}
+	}
+	else
+	{
+		pdlg.hide();
+		pdlg.SignalFailure();
+
+		if (!cancelled)
+		{
+			const compat::package_info* package = nullptr;
+
+			for (usz i = 0; i < readers.size() && !package; i++)
+			{
+				// Figure out what package failed the installation
+				switch (readers[i].get_result())
+				{
+				case package_reader::result::success:
+				case package_reader::result::not_started:
+				case package_reader::result::started:
+				case package_reader::result::aborted:
+				case package_reader::result::aborted_dirty:
+					break;
+				case package_reader::result::error:
+				case package_reader::result::error_dirty:
+					package = &packages[i];
+					break;
+				}
+			}
+
+			ensure(package);
+
+			if (error == package_error::app_version)
+			{
+				gui_log.error("Cannot install %s.", sstr(package->path));
+				QMessageBox::warning(this, tr("Warning!"), tr("The following package cannot be installed on top of the current data:\n%1!").arg(package->path));
+			}
+			else
+			{
+				gui_log.error("Failed to install %s.", sstr(package->path));
+				QMessageBox::critical(this, tr("Failure!"), tr("Failed to install software from package:\n%1!"
+					"\nThis is very likely caused by external interference from a faulty anti-virus software."
+					"\nPlease add RPCS3 to your anti-virus\' whitelist or use better anti-virus software.").arg(package->path));
+			}
+		}
+	}
+
+	return success;
+}
+
+void main_window::ExtractMSELF()
+{
+	const QString path_last_mself = m_gui_settings->GetValue(gui::fd_ext_mself).toString();
+	const QString file_path = QFileDialog::getOpenFileName(this, tr("Select MSELF To extract"), path_last_mself, tr("All mself files (*.mself *.MSELF);;All files (*.*)"));
+
+	if (file_path.isEmpty())
+	{
+		return;
+	}
+
+	const QString dir = QFileDialog::getExistingDirectory(this, tr("Extraction Directory"), QString{}, QFileDialog::ShowDirsOnly | QFileDialog::DontResolveSymlinks);
+
+	if (!dir.isEmpty())
+	{
+		m_gui_settings->SetValue(gui::fd_ext_mself, QFileInfo(file_path).path());
+		extract_mself(sstr(file_path), sstr(dir) + '/');
+	}
+}
+
+void main_window::InstallPup(QString file_path)
+{
+	if (file_path.isEmpty())
+	{
+		const QString path_last_pup = m_gui_settings->GetValue(gui::fd_install_pup).toString();
+		file_path = QFileDialog::getOpenFileName(this, tr("Select PS3UPDAT.PUP To Install"), path_last_pup, tr("PS3 update file (PS3UPDAT.PUP);;All pup files (*.pup *.PUP);;All files (*.*)"));
+	}
+	else
+	{
+		if (QMessageBox::question(this, tr("RPCS3 Firmware Installer"), tr("Install firmware: %1?").arg(file_path),
+			QMessageBox::Yes | QMessageBox::No, QMessageBox::No) != QMessageBox::Yes)
+		{
+			gui_log.notice("Firmware: Cancelled installation from drop. File: %s", sstr(file_path));
+			return;
+		}
+	}
+
+	if (!file_path.isEmpty())
+	{
+		// Handle the actual installation with a timeout. Otherwise the source explorer instance is not usable during the following file processing.
+		QTimer::singleShot(0, [this, file_path]()
+		{
+			HandlePupInstallation(file_path);
+		});
+	}
+}
+
+void main_window::ExtractPup()
+{
+	const QString path_last_pup = m_gui_settings->GetValue(gui::fd_install_pup).toString();
+	const QString file_path = QFileDialog::getOpenFileName(this, tr("Select PS3UPDAT.PUP To extract"), path_last_pup, tr("PS3 update file (PS3UPDAT.PUP);;All pup files (*.pup *.PUP);;All files (*.*)"));
+
+	if (file_path.isEmpty())
+	{
+		return;
+	}
+
+	const QString dir = QFileDialog::getExistingDirectory(this, tr("Extraction Directory"), QString{}, QFileDialog::ShowDirsOnly | QFileDialog::DontResolveSymlinks);
+
+	if (!dir.isEmpty())
+	{
+		HandlePupInstallation(file_path, dir);
+	}
+}
+
+void main_window::ExtractTar()
+{
+	if (!m_gui_settings->GetBootConfirmation(this))
+	{
+		return;
+	}
+
+	Emu.GracefulShutdown(false);
+
+	const QString path_last_tar = m_gui_settings->GetValue(gui::fd_ext_tar).toString();
+	QStringList files = QFileDialog::getOpenFileNames(this, tr("Select TAR To extract"), path_last_tar, tr("All tar files (*.tar *.TAR *.tar.aa.* *.TAR.AA.*);;All files (*.*)"));
+
+	if (files.isEmpty())
+	{
+		return;
+	}
+
+	const QString dir = QFileDialog::getExistingDirectory(this, tr("Extraction Directory"), QString{}, QFileDialog::ShowDirsOnly | QFileDialog::DontResolveSymlinks);
+
+	if (dir.isEmpty())
+	{
+		return;
+	}
+
+	m_gui_settings->SetValue(gui::fd_ext_tar, QFileInfo(files[0]).path());
+
+	progress_dialog pdlg(tr("TAR Extraction"), tr("Extracting encrypted TARs\nPlease wait..."), tr("Cancel"), 0, files.size(), false, this);
+	pdlg.show();
+
+	QString error;
+
+	for (const QString& file : files)
+	{
+		if (pdlg.wasCanceled())
+		{
+			break;
+		}
+
+		// Do not abort on failure here, in case the user selected a wrong file in multi-selection while the rest are valid
+		if (!extract_tar(sstr(file), sstr(dir) + '/'))
+		{
+			if (error.isEmpty())
+			{
+				error = tr("The following TAR file(s) could not be extracted:");
+			}
+
+			error += "\n";
+			error += file;
+		}
+
+		pdlg.SetValue(pdlg.value() + 1);
+		QApplication::processEvents();
+	}
+
+	if (!error.isEmpty())
+	{
+		pdlg.hide();
+		QMessageBox::critical(this, tr("Tar extraction failed"), error);
+	}
+}
+
+void main_window::HandlePupInstallation(const QString& file_path, const QString& dir_path)
+{
+	const auto critical = [this](QString str)
+	{
+		Emu.CallFromMainThread([this, str = std::move(str)]()
+		{
+			QMessageBox::critical(this, tr("Firmware Installation Failed"), str);
+		}, nullptr, false);
+	};
+
+	if (file_path.isEmpty())
+	{
+		gui_log.error("Error while installing firmware: provided path is empty.");
+		critical(tr("Firmware installation failed: The provided path is empty."));
+		return;
+	}
+
+	if (!m_gui_settings->GetBootConfirmation(this))
+	{
+		return;
+	}
+
+	Emu.GracefulShutdown(false);
+
+	m_gui_settings->SetValue(gui::fd_install_pup, QFileInfo(file_path).path());
+
+	const std::string path = sstr(file_path);
+
+	fs::file pup_f(path);
+	if (!pup_f)
+	{
+		gui_log.error("Error opening PUP file %s (%s)", path, fs::g_tls_error);
+		critical(tr("Firmware installation failed: The selected firmware file couldn't be opened."));
+		return;
+	}
+
+	pup_object pup(std::move(pup_f));
+
+	switch (pup.operator pup_error())
+	{
+	case pup_error::header_read:
+	{
+		gui_log.error("%s", pup.get_formatted_error());
+		critical(tr("Firmware installation failed: The provided file is empty."));
+		return;
+	}
+	case pup_error::header_magic:
+	{
+		gui_log.error("Error while installing firmware: provided file is not a PUP file.");
+		critical(tr("Firmware installation failed: The provided file is not a PUP file."));
+		return;
+	}
+	case pup_error::expected_size:
+	{
+		gui_log.error("%s", pup.get_formatted_error());
+		critical(tr("Firmware installation failed: The provided file is incomplete. Try redownloading it."));
+		return;
+	}
+	case pup_error::header_file_count:
+	case pup_error::file_entries:
+	case pup_error::stream:
+	{
+		std::string error = "Error while installing firmware: PUP file is invalid.";
+
+		if (!pup.get_formatted_error().empty())
+		{
+			fmt::append(error, "\n%s", pup.get_formatted_error());
+		}
+
+		gui_log.error("%s", error);
+		critical(tr("Firmware installation failed: The provided file is corrupted."));
+		return;
+	}
+	case pup_error::hash_mismatch:
+	{
+		gui_log.error("Error while installing firmware: Hash check failed.");
+		critical(tr("Firmware installation failed: The provided file's contents are corrupted."));
+		return;
+	}
+	case pup_error::ok: break;
+	}
+
+	fs::file update_files_f = pup.get_file(0x300);
+
+	if (!update_files_f)
+	{
+		gui_log.error("Error while installing firmware: Couldn't find installation packages database.");
+		critical(tr("Firmware installation failed: The provided file's contents are corrupted."));
+		return;
+	}
+
+	tar_object update_files(update_files_f);
+
+	if (!dir_path.isEmpty())
+	{
+		// Extract only mode, extract direct TAR entries to a user directory
+
+		if (!vfs::mount("/pup_extract", sstr(dir_path) + '/'))
+		{
+			gui_log.error("Error while extracting firmware: Failed to mount '%s'", sstr(dir_path));
+			critical(tr("Firmware extraction failed: VFS mounting failed."));
+			return;
+		}
+
+		if (!update_files.extract("/pup_extract", true))
+		{
+			gui_log.error("Error while installing firmware: TAR contents are invalid.");
+			critical(tr("Firmware installation failed: Firmware contents could not be extracted."));
+		}
+
+		gui_log.success("Extracted PUP file to %s", sstr(dir_path));
+		return;
+	}
+
+	// In regular installation we select specfic entries from the main TAR which are prefixed with "dev_flash_"
+	// Those entries are TAR as well, we extract their packed files from them and that's what installed in /dev_flash
+
+	auto update_filenames = update_files.get_filenames();
+
+	update_filenames.erase(std::remove_if(
+		update_filenames.begin(), update_filenames.end(), [](const std::string& s) { return s.find("dev_flash_") == umax; }),
+		update_filenames.end());
+
+	if (update_filenames.empty())
+	{
+		gui_log.error("Error while installing firmware: No dev_flash_* packages were found.");
+		critical(tr("Firmware installation failed: The provided file's contents are corrupted."));
+		return;
+	}
+
+	static constexpr std::string_view cur_version = "4.90";
+
+	std::string version_string;
+
+	if (fs::file version = pup.get_file(0x100))
+	{
+		version_string = version.to_string();
+	}
+
+	if (const usz version_pos = version_string.find('\n'); version_pos != umax)
+	{
+		version_string.erase(version_pos);
+	}
+
+	if (version_string.empty())
+	{
+		gui_log.error("Error while installing firmware: No version data was found.");
+		critical(tr("Firmware installation failed: The provided file's contents are corrupted."));
+		return;
+	}
+
+	if (version_string < cur_version &&
+		QMessageBox::question(this, tr("RPCS3 Firmware Installer"), tr("Old firmware detected.\nThe newest firmware version is %1 and you are trying to install version %2\nContinue installation?").arg(QString::fromUtf8(cur_version.data(), ::size32(cur_version)), qstr(version_string)),
+			QMessageBox::Yes | QMessageBox::No, QMessageBox::Yes) == QMessageBox::No)
+	{
+		return;
+	}
+
+	if (std::string installed = utils::get_firmware_version(); !installed.empty())
+	{
+		gui_log.warning("Reinstalling firmware: old=%s, new=%s", installed, version_string);
+
+		if (QMessageBox::question(this, tr("RPCS3 Firmware Installer"), tr("Firmware of version %1 has already been installed.\nOverwrite current installation with version %2?").arg(qstr(installed), qstr(version_string)),
+			QMessageBox::Yes | QMessageBox::No, QMessageBox::Yes) == QMessageBox::No)
+		{
+			gui_log.warning("Reinstallation of firmware aborted.");
+			return;
+		}
+	}
+
+	// Remove possibly PS3 fonts from database
+	QFontDatabase::removeAllApplicationFonts();
+
+	progress_dialog pdlg(tr("RPCS3 Firmware Installer"), tr("Installing firmware version %1\nPlease wait...").arg(qstr(version_string)), tr("Cancel"), 0, static_cast<int>(update_filenames.size()), false, this);
+	pdlg.show();
+
+	// Used by tar_object::extract() as destination directory
+	vfs::mount("/dev_flash", g_cfg_vfs.get_dev_flash());
+
+	// Synchronization variable
+	atomic_t<uint> progress(0);
+	{
+		// Run asynchronously
+		named_thread worker("Firmware Installer", [&]
+		{
+			for (const auto& update_filename : update_filenames)
+			{
+				fs::file update_file = update_files.get_file(update_filename);
+
+				SCEDecrypter self_dec(update_file);
+				self_dec.LoadHeaders();
+				self_dec.LoadMetadata(SCEPKG_ERK, SCEPKG_RIV);
+				self_dec.DecryptData();
+
+				auto dev_flash_tar_f = self_dec.MakeFile();
+				if (dev_flash_tar_f.size() < 3)
+				{
+					gui_log.error("Error while installing firmware: PUP contents are invalid.");
+					critical(tr("Firmware installation failed: Firmware could not be decompressed"));
+					progress = -1;
+					return;
+				}
+
+				tar_object dev_flash_tar(dev_flash_tar_f[2]);
+				if (!dev_flash_tar.extract())
+				{
+					gui_log.error("Error while installing firmware: TAR contents are invalid. (package=%s)", update_filename);
+					critical(tr("The firmware contents could not be extracted."
+						"\nThis is very likely caused by external interference from a faulty anti-virus software."
+						"\nPlease add RPCS3 to your anti-virus\' whitelist or use better anti-virus software."));
+
+					progress = -1;
+					return;
+				}
+
+				if (!progress.try_inc(::narrow<uint>(update_filenames.size())))
+				{
+					// Installation was cancelled
+					return;
+				}
+			}
+		});
+
+		// Wait for the completion
+		for (uint value = progress.load(); value < update_filenames.size(); std::this_thread::sleep_for(5ms), value = progress)
+		{
+			if (pdlg.wasCanceled())
+			{
+				progress = -1;
+				break;
+			}
+
+			// Update progress window
+			pdlg.SetValue(static_cast<int>(value));
+			QCoreApplication::processEvents();
+		}
+
+		// Join thread
+		worker();
+	}
+
+	update_files_f.close();
+
+	if (progress == update_filenames.size())
+	{
+		pdlg.SetValue(pdlg.maximum());
+		std::this_thread::sleep_for(100ms);
+	}
+
+	// Update with newly installed PS3 fonts
+	Q_EMIT RequestGlobalStylesheetChange();
+
+	// Unmount
+	Emu.Init();
+
+	if (progress == update_filenames.size())
+	{
+		ui->bootVSHAct->setEnabled(fs::is_file(g_cfg_vfs.get_dev_flash() + "/vsh/module/vsh.self"));
+
+		gui_log.success("Successfully installed PS3 firmware version %s.", version_string);
+		m_gui_settings->ShowInfoBox(tr("Success!"), tr("Successfully installed PS3 firmware and LLE Modules!"), gui::ib_pup_success, this);
+
+		CreateFirmwareCache();
+	}
+}
+
+void main_window::DecryptSPRXLibraries()
+{
+	QString path_last_sprx = m_gui_settings->GetValue(gui::fd_decrypt_sprx).toString();
+
+	if (!fs::is_dir(sstr(path_last_sprx)))
+	{
+		// Default: redirect to userland firmware SPRX directory
+		path_last_sprx = qstr(g_cfg_vfs.get_dev_flash() + "sys/external");
+	}
+
+	const QStringList modules = QFileDialog::getOpenFileNames(this, tr("Select binary files"), path_last_sprx, tr("All Binaries (*.bin *.BIN *.self *.SELF *.sprx *.SPRX *.sdat *.SDAT *.edat *.EDAT);;"
+		"BIN files (*.bin *.BIN);;SELF files (*.self *.SELF);;SPRX files (*.sprx *.SPRX);;SDAT/EDAT files (*.sdat *.SDAT *.edat *.EDAT);;All files (*.*)"));
+
+	if (modules.isEmpty())
+	{
+		return;
+	}
+
+	m_gui_settings->SetValue(gui::fd_decrypt_sprx, QFileInfo(modules.first()).path());
+
+	std::vector<std::string> vec_modules;
+	for (const QString& mod : modules)
+	{
+		vec_modules.push_back(mod.toStdString());
+	}
+
+	const auto input_cb = [this](std::string old_path, std::string path, bool tried) -> std::string
+	{
+		const QString hint = tr("Hint: KLIC (KLicense key) is a 16-byte long string. (32 hexadecimal characters)"
+			"\nAnd is logged with some sceNpDrm* functions when the game/application which owns \"%0\" is running.").arg(qstr(path));
+
+		if (tried)
+		{
+			gui_log.error("Failed to decrypt %s with specfied KLIC, retrying.\n%s", old_path, sstr(hint));
+		}
+
+		input_dialog dlg(32, "", tr("Enter KLIC of %0").arg(qstr(path)),
+			tried ? tr("Decryption failed with provided KLIC.\n%0").arg(hint) : tr("Hexadecimal only."), "00000000000000000000000000000000", this);
+
+		QFont mono = QFontDatabase::systemFont(QFontDatabase::FixedFont);
+		mono.setPointSize(8);
+		dlg.set_input_font(mono, true, '0');
+		dlg.set_clear_button_enabled(false);
+		dlg.set_button_enabled(QDialogButtonBox::StandardButton::Ok, false);
+		dlg.set_validator(new QRegularExpressionValidator(QRegularExpression("^[a-fA-F0-9]*$"))); // HEX only
+
+		connect(&dlg, &input_dialog::text_changed, &dlg, [&dlg](const QString& text)
+		{
+			dlg.set_button_enabled(QDialogButtonBox::StandardButton::Ok, text.size() == 32);
+		});
+
+		if (dlg.exec() == QDialog::Accepted)
+		{
+			return sstr(dlg.get_input_text());
+		}
+
+		return {};
+	};
+
+	decrypt_sprx_libraries(vec_modules, input_cb);
+}
+
+/** Needed so that when a backup occurs of window state in gui_settings, the state is current.
+* Also, so that on close, the window state is preserved.
+*/
+void main_window::SaveWindowState() const
+{
+	// Save gui settings
+	m_gui_settings->SetValue(gui::mw_geometry, saveGeometry());
+	m_gui_settings->SetValue(gui::mw_windowState, saveState());
+	m_gui_settings->SetValue(gui::mw_mwState, m_mw->saveState());
+
+	// Save column settings
+	m_game_list_frame->SaveSettings();
+	// Save splitter state
+	m_debugger_frame->SaveSettings();
+}
+
+void main_window::RepaintThumbnailIcons()
+{
+	[[maybe_unused]] const QColor new_color = gui::utils::get_label_color("thumbnail_icon_color");
+
+	[[maybe_unused]] const auto icon = [&new_color](const QString& path)
+	{
+		return gui::utils::get_colorized_icon(QPixmap::fromImage(gui::utils::get_opaque_image_area(path)), Qt::black, new_color);
+	};
+
+#ifdef _WIN32
+	if (!m_thumb_bar) return;
+
+	m_icon_thumb_play = icon(":/Icons/play.png");
+	m_icon_thumb_pause = icon(":/Icons/pause.png");
+	m_icon_thumb_stop = icon(":/Icons/stop.png");
+	m_icon_thumb_restart = icon(":/Icons/restart.png");
+
+	m_thumb_playPause->setIcon(Emu.IsRunning() || Emu.IsStarting() ? m_icon_thumb_pause : m_icon_thumb_play);
+	m_thumb_stop->setIcon(m_icon_thumb_stop);
+	m_thumb_restart->setIcon(m_icon_thumb_restart);
+#endif
+}
+
+void main_window::RepaintToolBarIcons()
+{
+	std::map<QIcon::Mode, QColor> new_colors{};
+	new_colors[QIcon::Normal] = gui::utils::get_label_color("toolbar_icon_color");
+
+	const QString sheet = static_cast<QApplication *>(QCoreApplication::instance())->styleSheet();
+
+	if (sheet.contains("toolbar_icon_color_disabled"))
+	{
+		new_colors[QIcon::Disabled] = gui::utils::get_label_color("toolbar_icon_color_disabled");
+	}
+	if (sheet.contains("toolbar_icon_color_active"))
+	{
+		new_colors[QIcon::Active] = gui::utils::get_label_color("toolbar_icon_color_active");
+	}
+	if (sheet.contains("toolbar_icon_color_selected"))
+	{
+		new_colors[QIcon::Selected] = gui::utils::get_label_color("toolbar_icon_color_selected");
+	}
+
+	const auto icon = [&new_colors](const QString& path)
+	{
+		return gui::utils::get_colorized_icon(QIcon(path), Qt::black, new_colors);
+	};
+
+	m_icon_play           = icon(":/Icons/play.png");
+	m_icon_pause          = icon(":/Icons/pause.png");
+	m_icon_restart        = icon(":/Icons/restart.png");
+	m_icon_fullscreen_on  = icon(":/Icons/fullscreen.png");
+	m_icon_fullscreen_off = icon(":/Icons/exit_fullscreen.png");
+
+	ui->toolbar_config  ->setIcon(icon(":/Icons/configure.png"));
+	ui->toolbar_controls->setIcon(icon(":/Icons/controllers.png"));
+	ui->toolbar_open    ->setIcon(icon(":/Icons/open.png"));
+	ui->toolbar_grid    ->setIcon(icon(":/Icons/grid.png"));
+	ui->toolbar_list    ->setIcon(icon(":/Icons/list.png"));
+	ui->toolbar_refresh ->setIcon(icon(":/Icons/refresh.png"));
+	ui->toolbar_stop    ->setIcon(icon(":/Icons/stop.png"));
+
+	ui->sysStopAct->setIcon(icon(":/Icons/stop.png"));
+	ui->sysRebootAct->setIcon(m_icon_restart);
+
+	if (Emu.IsRunning())
+	{
+		ui->toolbar_start->setIcon(m_icon_pause);
+		ui->sysPauseAct->setIcon(m_icon_pause);
+	}
+	else if (Emu.IsStopped() && !Emu.GetBoot().empty())
+	{
+		ui->toolbar_start->setIcon(m_icon_restart);
+		ui->sysPauseAct->setIcon(m_icon_restart);
+	}
+	else
+	{
+		ui->toolbar_start->setIcon(m_icon_play);
+		ui->sysPauseAct->setIcon(m_icon_play);
+	}
+
+	if (isFullScreen())
+	{
+		ui->toolbar_fullscreen->setIcon(m_icon_fullscreen_off);
+	}
+	else
+	{
+		ui->toolbar_fullscreen->setIcon(m_icon_fullscreen_on);
+	}
+
+	const QColor& new_color = new_colors[QIcon::Normal];
+	ui->sizeSlider->setStyleSheet(ui->sizeSlider->styleSheet().append("QSlider::handle:horizontal{ background: rgba(%1, %2, %3, %4); }")
+		.arg(new_color.red()).arg(new_color.green()).arg(new_color.blue()).arg(new_color.alpha()));
+
+	// resize toolbar elements
+
+	// for highdpi resize toolbar icons and height dynamically
+	// choose factors to mimic Gui-Design in main_window.ui
+	// TODO: delete this in case Qt::AA_EnableHighDpiScaling is enabled in main.cpp
+#ifdef _WIN32
+	const int tool_icon_height = menuBar()->sizeHint().height() * 1.5;
+	ui->toolBar->setIconSize(QSize(tool_icon_height, tool_icon_height));
+#endif
+
+	const int tool_bar_height = ui->toolBar->sizeHint().height();
+
+	for (const auto& act : ui->toolBar->actions())
+	{
+		if (act->isSeparator())
+		{
+			continue;
+		}
+
+		ui->toolBar->widgetForAction(act)->setMinimumWidth(tool_bar_height);
+	}
+
+	ui->sizeSliderContainer->setFixedWidth(tool_bar_height * 4);
+	ui->mw_searchbar->setFixedWidth(tool_bar_height * 5);
+}
+
+void main_window::OnEmuRun(bool /*start_playtime*/) const
+{
+	const QString title = GetCurrentTitle();
+	const QString restart_tooltip = tr("Restart %0").arg(title);
+	const QString pause_tooltip = tr("Pause %0").arg(title);
+	const QString stop_tooltip = tr("Stop %0").arg(title);
+
+	m_debugger_frame->EnableButtons(true);
+
+#ifdef _WIN32
+	m_thumb_stop->setToolTip(stop_tooltip);
+	m_thumb_restart->setToolTip(restart_tooltip);
+	m_thumb_playPause->setToolTip(pause_tooltip);
+	m_thumb_playPause->setIcon(m_icon_thumb_pause);
+#endif
+	ui->sysPauseAct->setText(tr("&Pause"));
+	ui->sysPauseAct->setIcon(m_icon_pause);
+	ui->toolbar_start->setIcon(m_icon_pause);
+	ui->toolbar_start->setText(tr("Pause"));
+	ui->toolbar_start->setToolTip(pause_tooltip);
+	ui->toolbar_stop->setToolTip(stop_tooltip);
+
+	EnableMenus(true);
+}
+
+void main_window::OnEmuResume() const
+{
+	const QString title = GetCurrentTitle();
+	const QString restart_tooltip = tr("Restart %0").arg(title);
+	const QString pause_tooltip = tr("Pause %0").arg(title);
+	const QString stop_tooltip = tr("Stop %0").arg(title);
+
+#ifdef _WIN32
+	m_thumb_stop->setToolTip(stop_tooltip);
+	m_thumb_restart->setToolTip(restart_tooltip);
+	m_thumb_playPause->setToolTip(pause_tooltip);
+	m_thumb_playPause->setIcon(m_icon_thumb_pause);
+#endif
+	ui->sysPauseAct->setText(tr("&Pause"));
+	ui->sysPauseAct->setIcon(m_icon_pause);
+	ui->toolbar_start->setIcon(m_icon_pause);
+	ui->toolbar_start->setText(tr("Pause"));
+	ui->toolbar_start->setToolTip(pause_tooltip);
+	ui->toolbar_stop->setToolTip(stop_tooltip);
+}
+
+void main_window::OnEmuPause() const
+{
+	const QString title = GetCurrentTitle();
+	const QString resume_tooltip = tr("Resume %0").arg(title);
+
+#ifdef _WIN32
+	m_thumb_playPause->setToolTip(resume_tooltip);
+	m_thumb_playPause->setIcon(m_icon_thumb_play);
+#endif
+	ui->sysPauseAct->setText(tr("&Resume"));
+	ui->sysPauseAct->setIcon(m_icon_play);
+	ui->toolbar_start->setIcon(m_icon_play);
+	ui->toolbar_start->setText(tr("Play"));
+	ui->toolbar_start->setToolTip(resume_tooltip);
+
+	// Refresh game list in order to update time played
+	if (m_game_list_frame)
+	{
+		m_game_list_frame->Refresh();
+	}
+}
+
+void main_window::OnEmuStop()
+{
+	const QString title = GetCurrentTitle();
+	const QString play_tooltip = Emu.IsReady() ? tr("Play %0").arg(title) : tr("Resume %0").arg(title);
+
+	m_debugger_frame->UpdateUI();
+
+	ui->sysPauseAct->setText(Emu.IsReady() ? tr("&Play") : tr("&Resume"));
+	ui->sysPauseAct->setIcon(m_icon_play);
+#ifdef _WIN32
+	m_thumb_playPause->setToolTip(play_tooltip);
+	m_thumb_playPause->setIcon(m_icon_thumb_play);
+#endif
+
+	EnableMenus(false);
+
+	if (title.isEmpty())
+	{
+		ui->toolbar_start->setIcon(m_icon_play);
+		ui->toolbar_start->setText(tr("Play"));
+		ui->toolbar_start->setToolTip(play_tooltip);
+	}
+	else
+	{
+		const QString restart_tooltip = tr("Restart %0").arg(title);
+
+		ui->toolbar_start->setEnabled(true);
+		ui->toolbar_start->setIcon(m_icon_restart);
+		ui->toolbar_start->setText(tr("Restart"));
+		ui->toolbar_start->setToolTip(restart_tooltip);
+		ui->sysRebootAct->setEnabled(true);
+#ifdef _WIN32
+		m_thumb_restart->setToolTip(restart_tooltip);
+		m_thumb_restart->setEnabled(true);
+#endif
+	}
+	ui->actionManage_Users->setEnabled(true);
+	ui->confCamerasAct->setEnabled(true);
+
+	// Refresh game list in order to update time played
+	if (m_game_list_frame && m_is_list_mode)
+	{
+		m_game_list_frame->Refresh();
+	}
+
+	// Close kernel explorer if running
+	if (m_kernel_explorer)
+	{
+		m_kernel_explorer->close();
+	}
+
+	// Close systen command dialog if running
+	if (m_system_cmd_dialog)
+	{
+		m_system_cmd_dialog->close();
+	}
+}
+
+void main_window::OnEmuReady() const
+{
+	const QString title = GetCurrentTitle();
+	const QString play_tooltip = Emu.IsReady() ? tr("Play %0").arg(title) : tr("Resume %0").arg(title);
+
+	m_debugger_frame->EnableButtons(true);
+#ifdef _WIN32
+	m_thumb_playPause->setToolTip(play_tooltip);
+	m_thumb_playPause->setIcon(m_icon_thumb_play);
+#endif
+	ui->sysPauseAct->setText(Emu.IsReady() ? tr("&Play") : tr("&Resume"));
+	ui->sysPauseAct->setIcon(m_icon_play);
+	ui->toolbar_start->setIcon(m_icon_play);
+	ui->toolbar_start->setText(tr("Play"));
+	ui->toolbar_start->setToolTip(play_tooltip);
+
+	EnableMenus(true);
+
+	ui->actionManage_Users->setEnabled(false);
+	ui->confCamerasAct->setEnabled(false);
+}
+
+void main_window::EnableMenus(bool enabled) const
+{
+	// Thumbnail Buttons
+#ifdef _WIN32
+	m_thumb_playPause->setEnabled(enabled);
+	m_thumb_stop->setEnabled(enabled);
+	m_thumb_restart->setEnabled(enabled);
+#endif
+
+	// Toolbar
+	ui->toolbar_start->setEnabled(enabled);
+	ui->toolbar_stop->setEnabled(enabled);
+
+	// Emulation
+	ui->sysPauseAct->setEnabled(enabled);
+	ui->sysStopAct->setEnabled(enabled);
+	ui->sysRebootAct->setEnabled(enabled);
+
+	// Tools
+	ui->toolskernel_explorerAct->setEnabled(enabled);
+	ui->toolsmemory_viewerAct->setEnabled(enabled);
+	ui->toolsRsxDebuggerAct->setEnabled(enabled);
+	ui->toolsSystemCommandsAct->setEnabled(enabled);
+	ui->actionCreate_RSX_Capture->setEnabled(enabled);
+	ui->actionCreate_Savestate->setEnabled(enabled);
+}
+
+void main_window::OnEnableDiscEject(bool enabled) const
+{
+	ui->ejectDiscAct->setEnabled(enabled);
+}
+
+void main_window::OnEnableDiscInsert(bool enabled) const
+{
+	ui->insertDiscAct->setEnabled(enabled);
+}
+
+void main_window::BootRecentAction(const QAction* act)
+{
+	if (Emu.IsRunning())
+	{
+		return;
+	}
+
+	const QString pth = act->data().toString();
+	const std::string path = sstr(pth);
+	QString name;
+	bool contains_path = false;
+
+	int idx = -1;
+	for (int i = 0; i < m_rg_entries.count(); i++)
+	{
+		if (::at32(m_rg_entries, i).first == pth)
+		{
+			idx = i;
+			contains_path = true;
+			name = ::at32(m_rg_entries, idx).second;
+			break;
+		}
+	}
+
+	// path is invalid: remove action from list return
+	if ((contains_path && name.isEmpty()) || (!QFileInfo(pth).isDir() && !QFileInfo(pth).isFile()))
+	{
+		if (contains_path)
+		{
+			// clear menu of actions
+			for (auto action : m_recent_game_acts)
+			{
+				ui->bootRecentMenu->removeAction(action);
+			}
+
+			// remove action from list
+			m_rg_entries.removeAt(idx);
+			m_recent_game_acts.removeAt(idx);
+
+			m_gui_settings->SetValue(gui::rg_entries, gui_settings::List2Var(m_rg_entries));
+
+			gui_log.error("Recent Game not valid, removed from Boot Recent list: %s", path);
+
+			// refill menu with actions
+			for (int i = 0; i < m_recent_game_acts.count(); i++)
+			{
+				m_recent_game_acts[i]->setShortcut(tr("Ctrl+%1").arg(i + 1));
+				m_recent_game_acts[i]->setToolTip(::at32(m_rg_entries, i).second);
+				ui->bootRecentMenu->addAction(m_recent_game_acts[i]);
+			}
+
+			gui_log.warning("Boot Recent list refreshed");
+			return;
+		}
+
+		gui_log.error("Path invalid and not in m_rg_paths: %s", path);
+		return;
+	}
+
+	gui_log.notice("Booting from recent games list...");
+	Boot(path, "", true);
+}
+
+QAction* main_window::CreateRecentAction(const q_string_pair& entry, const uint& sc_idx)
+{
+	// if path is not valid remove from list
+	if (entry.second.isEmpty() || (!QFileInfo(entry.first).isDir() && !QFileInfo(entry.first).isFile()))
+	{
+		if (m_rg_entries.contains(entry))
+		{
+			gui_log.warning("Recent Game not valid, removing from Boot Recent list: %s", sstr(entry.first));
+
+			const int idx = m_rg_entries.indexOf(entry);
+			m_rg_entries.removeAt(idx);
+
+			m_gui_settings->SetValue(gui::rg_entries, gui_settings::List2Var(m_rg_entries));
+		}
+		return nullptr;
+	}
+
+	// if name is a path get filename
+	QString shown_name = entry.second;
+	if (QFileInfo(entry.second).isFile())
+	{
+		shown_name = entry.second.section('/', -1);
+	}
+
+	// create new action
+	QAction* act = new QAction(shown_name, this);
+	act->setData(entry.first);
+	act->setToolTip(entry.second);
+	act->setShortcut(tr("Ctrl+%1").arg(sc_idx));
+
+	// truncate if too long
+	if (shown_name.length() > 60)
+	{
+		act->setText(shown_name.left(27) + "(....)" + shown_name.right(27));
+	}
+
+	// connect boot
+	connect(act, &QAction::triggered, this, [act, this]() {BootRecentAction(act); });
+
+	return act;
+}
+
+void main_window::AddRecentAction(const q_string_pair& entry)
+{
+	// don't change list on freeze
+	if (ui->freezeRecentAct->isChecked())
+	{
+		return;
+	}
+
+	// create new action, return if not valid
+	QAction* act = CreateRecentAction(entry, 1);
+	if (!act)
+	{
+		return;
+	}
+
+	// clear menu of actions
+	for (auto action : m_recent_game_acts)
+	{
+		ui->bootRecentMenu->removeAction(action);
+	}
+
+	// If path already exists, remove it in order to get it to beginning. Also remove duplicates.
+	for (int i = m_rg_entries.count() - 1; i >= 0; --i)
+	{
+		if (m_rg_entries[i].first == entry.first)
+		{
+			m_rg_entries.removeAt(i);
+			m_recent_game_acts.removeAt(i);
+		}
+	}
+
+	// remove oldest action at the end if needed
+	if (m_rg_entries.count() == 9)
+	{
+		m_rg_entries.removeLast();
+		m_recent_game_acts.removeLast();
+	}
+	else if (m_rg_entries.count() > 9)
+	{
+		gui_log.error("Recent games entrylist too big");
+	}
+
+	if (m_rg_entries.count() < 9)
+	{
+		// add new action at the beginning
+		m_rg_entries.prepend(entry);
+		m_recent_game_acts.prepend(act);
+	}
+
+	// refill menu with actions
+	for (int i = 0; i < m_recent_game_acts.count(); i++)
+	{
+		m_recent_game_acts[i]->setShortcut(tr("Ctrl+%1").arg(i + 1));
+		m_recent_game_acts[i]->setToolTip(::at32(m_rg_entries, i).second);
+		ui->bootRecentMenu->addAction(m_recent_game_acts[i]);
+	}
+
+	m_gui_settings->SetValue(gui::rg_entries, gui_settings::List2Var(m_rg_entries));
+}
+
+void main_window::UpdateLanguageActions(const QStringList& language_codes, const QString& language_code)
+{
+	ui->languageMenu->clear();
+
+	for (const auto& code : language_codes)
+	{
+		const QLocale locale      = QLocale(code);
+		const QString locale_name = QLocale::languageToString(locale.language());
+
+		// create new action
+		QAction* act = new QAction(locale_name, this);
+		act->setData(code);
+		act->setToolTip(locale_name);
+		act->setCheckable(true);
+		act->setChecked(code == language_code);
+
+		// connect to language changer
+		connect(act, &QAction::triggered, this, [this, code]()
+		{
+			RequestLanguageChange(code);
+		});
+
+		ui->languageMenu->addAction(act);
+	}
+}
+
+void main_window::UpdateFilterActions()
+{
+	ui->showCatHDDGameAct->setChecked(m_gui_settings->GetCategoryVisibility(Category::HDD_Game, m_is_list_mode));
+	ui->showCatDiscGameAct->setChecked(m_gui_settings->GetCategoryVisibility(Category::Disc_Game, m_is_list_mode));
+	ui->showCatPS1GamesAct->setChecked(m_gui_settings->GetCategoryVisibility(Category::PS1_Game, m_is_list_mode));
+	ui->showCatPS2GamesAct->setChecked(m_gui_settings->GetCategoryVisibility(Category::PS2_Game, m_is_list_mode));
+	ui->showCatPSPGamesAct->setChecked(m_gui_settings->GetCategoryVisibility(Category::PSP_Game, m_is_list_mode));
+	ui->showCatHomeAct->setChecked(m_gui_settings->GetCategoryVisibility(Category::Home, m_is_list_mode));
+	ui->showCatAudioVideoAct->setChecked(m_gui_settings->GetCategoryVisibility(Category::Media, m_is_list_mode));
+	ui->showCatGameDataAct->setChecked(m_gui_settings->GetCategoryVisibility(Category::Data, m_is_list_mode));
+	ui->showCatUnknownAct->setChecked(m_gui_settings->GetCategoryVisibility(Category::Unknown_Cat, m_is_list_mode));
+	ui->showCatOtherAct->setChecked(m_gui_settings->GetCategoryVisibility(Category::Others, m_is_list_mode));
+}
+
+void main_window::RepaintGui()
+{
+	if (m_game_list_frame)
+	{
+		m_game_list_frame->RepaintIcons(true);
+	}
+
+	if (m_log_frame)
+	{
+		m_log_frame->RepaintTextColors();
+	}
+
+	if (m_debugger_frame)
+	{
+		m_debugger_frame->ChangeColors();
+	}
+
+	RepaintToolBarIcons();
+	RepaintThumbnailIcons();
+
+	Q_EMIT RequestTrophyManagerRepaint();
+}
+
+void main_window::RetranslateUI(const QStringList& language_codes, const QString& language)
+{
+	UpdateLanguageActions(language_codes, language);
+
+	ui->retranslateUi(this);
+
+	if (m_game_list_frame)
+	{
+		m_game_list_frame->Refresh(true);
+	}
+}
+
+void main_window::ShowTitleBars(bool show) const
+{
+	m_game_list_frame->SetTitleBarVisible(show);
+	m_debugger_frame->SetTitleBarVisible(show);
+	m_log_frame->SetTitleBarVisible(show);
+}
+
+void main_window::CreateActions()
+{
+	ui->exitAct->setShortcuts(QKeySequence::Quit);
+
+	ui->toolbar_start->setEnabled(false);
+	ui->toolbar_stop->setEnabled(false);
+
+	m_category_visible_act_group = new QActionGroup(this);
+	m_category_visible_act_group->addAction(ui->showCatHDDGameAct);
+	m_category_visible_act_group->addAction(ui->showCatDiscGameAct);
+	m_category_visible_act_group->addAction(ui->showCatPS1GamesAct);
+	m_category_visible_act_group->addAction(ui->showCatPS2GamesAct);
+	m_category_visible_act_group->addAction(ui->showCatPSPGamesAct);
+	m_category_visible_act_group->addAction(ui->showCatHomeAct);
+	m_category_visible_act_group->addAction(ui->showCatAudioVideoAct);
+	m_category_visible_act_group->addAction(ui->showCatGameDataAct);
+	m_category_visible_act_group->addAction(ui->showCatUnknownAct);
+	m_category_visible_act_group->addAction(ui->showCatOtherAct);
+	m_category_visible_act_group->setExclusive(false);
+
+	m_icon_size_act_group = new QActionGroup(this);
+	m_icon_size_act_group->addAction(ui->setIconSizeTinyAct);
+	m_icon_size_act_group->addAction(ui->setIconSizeSmallAct);
+	m_icon_size_act_group->addAction(ui->setIconSizeMediumAct);
+	m_icon_size_act_group->addAction(ui->setIconSizeLargeAct);
+
+	m_list_mode_act_group = new QActionGroup(this);
+	m_list_mode_act_group->addAction(ui->setlistModeListAct);
+	m_list_mode_act_group->addAction(ui->setlistModeGridAct);
+}
+
+void main_window::CreateConnects()
+{
+	connect(ui->bootElfAct, &QAction::triggered, this, &main_window::BootElf);
+	connect(ui->bootTestAct, &QAction::triggered, this, &main_window::BootTest);
+	connect(ui->bootGameAct, &QAction::triggered, this, &main_window::BootGame);
+	connect(ui->bootVSHAct, &QAction::triggered, this, &main_window::BootVSH);
+	connect(ui->actionopen_rsx_capture, &QAction::triggered, this, [this](){ BootRsxCapture(); });
+	connect(ui->actionCreate_RSX_Capture, &QAction::triggered, this, []()
+	{
+		g_user_asked_for_frame_capture = true;
+	});
+
+	connect(ui->actionCreate_Savestate, &QAction::triggered, this, []()
+	{
+		gui_log.notice("User triggered savestate creation from utilities.");
+		Emu.Kill(false, true);
+	});
+
+	connect(ui->bootSavestateAct, &QAction::triggered, this, &main_window::BootSavestate);
+
+	connect(ui->addGamesAct, &QAction::triggered, this, [this]()
+	{
+		if (!m_gui_settings->GetBootConfirmation(this))
+		{
+			return;
+		}
+
+		QStringList paths;
+
+		// Only select one folder for now
+		paths << QFileDialog::getExistingDirectory(this, tr("Select a folder containing one or more games"), qstr(fs::get_config_dir()), QFileDialog::ShowDirsOnly | QFileDialog::DontResolveSymlinks);
+
+		if (!paths.isEmpty())
+		{
+			Emu.GracefulShutdown(false);
+
+			for (const QString& path : paths)
+			{
+				AddGamesFromDir(path);
+			}
+			m_game_list_frame->Refresh(true);
+		}
+	});
+
+	connect(ui->bootRecentMenu, &QMenu::aboutToShow, this, [this]()
+	{
+		// Enable/Disable Recent Games List
+		const bool stopped = Emu.IsStopped();
+		for (QAction* act : ui->bootRecentMenu->actions())
+		{
+			if (act != ui->freezeRecentAct && act != ui->clearRecentAct)
+			{
+				act->setEnabled(stopped);
+			}
+		}
+	});
+
+	connect(ui->clearRecentAct, &QAction::triggered, this, [this]()
+	{
+		if (ui->freezeRecentAct->isChecked())
+		{
+			return;
+		}
+		m_rg_entries.clear();
+		for (QAction* act : m_recent_game_acts)
+		{
+			ui->bootRecentMenu->removeAction(act);
+		}
+		m_recent_game_acts.clear();
+		m_gui_settings->SetValue(gui::rg_entries, gui_settings::List2Var(q_pair_list()));
+	});
+
+	connect(ui->freezeRecentAct, &QAction::triggered, this, [this](bool checked)
+	{
+		m_gui_settings->SetValue(gui::rg_freeze, checked);
+	});
+
+	connect(ui->bootInstallPkgAct, &QAction::triggered, this, [this] {InstallPackages(); });
+	connect(ui->bootInstallPupAct, &QAction::triggered, this, [this] {InstallPup(); });
+	connect(ui->exitAct, &QAction::triggered, this, &QWidget::close);
+
+	connect(ui->batchCreatePPUCachesAct, &QAction::triggered, m_game_list_frame, &game_list_frame::BatchCreatePPUCaches);
+	connect(ui->batchRemovePPUCachesAct, &QAction::triggered, m_game_list_frame, &game_list_frame::BatchRemovePPUCaches);
+	connect(ui->batchRemoveSPUCachesAct, &QAction::triggered, m_game_list_frame, &game_list_frame::BatchRemoveSPUCaches);
+	connect(ui->batchRemoveShaderCachesAct, &QAction::triggered, m_game_list_frame, &game_list_frame::BatchRemoveShaderCaches);
+	connect(ui->batchRemoveCustomConfigurationsAct, &QAction::triggered, m_game_list_frame, &game_list_frame::BatchRemoveCustomConfigurations);
+	connect(ui->batchRemoveCustomPadConfigurationsAct, &QAction::triggered, m_game_list_frame, &game_list_frame::BatchRemoveCustomPadConfigurations);
+
+	connect(ui->removeDiskCacheAct, &QAction::triggered, this, &main_window::RemoveDiskCache);
+
+	connect(ui->removeFirmwareCacheAct, &QAction::triggered, this, &main_window::RemoveFirmwareCache);
+	connect(ui->createFirmwareCacheAct, &QAction::triggered, this, &main_window::CreateFirmwareCache);
+
+	connect(ui->sysPauseAct, &QAction::triggered, this, &main_window::OnPlayOrPause);
+	connect(ui->sysStopAct, &QAction::triggered, this, []()
+	{
+		gui_log.notice("User triggered stop action in menu bar");
+		Emu.GracefulShutdown(false, true);
+	});
+	connect(ui->sysRebootAct, &QAction::triggered, this, []()
+	{
+		gui_log.notice("User triggered restart action in menu bar");
+		Emu.Restart();
+	});
+
+	connect(ui->ejectDiscAct, &QAction::triggered, this, []()
+	{
+		gui_log.notice("User triggered eject disc action in menu bar");
+		Emu.EjectDisc();
+	});
+	connect(ui->insertDiscAct, &QAction::triggered, this, [this]()
+	{
+		gui_log.notice("User triggered insert disc action in menu bar");
+
+		const QString path_last_game = m_gui_settings->GetValue(gui::fd_insert_disc).toString();
+		const QString dir_path = QFileDialog::getExistingDirectory(this, tr("Select Disc Game Folder"), path_last_game, QFileDialog::ShowDirsOnly | QFileDialog::DontResolveSymlinks);
+
+		if (dir_path.isEmpty())
+		{
+			return;
+		}
+
+		const game_boot_result result = Emu.InsertDisc(dir_path.toStdString());
+
+		if (result != game_boot_result::no_errors)
+		{
+			QMessageBox::warning(this, tr("Failed to insert disc"), tr("Make sure that the emulation is running and that the selected path belongs to a valid disc game."));
+			return;
+		}
+
+		m_gui_settings->SetValue(gui::fd_insert_disc, QFileInfo(dir_path).path());
+	});
+
+	const auto open_settings = [this](int tabIndex)
+	{
+		settings_dialog dlg(m_gui_settings, m_emu_settings, tabIndex, this);
+		connect(&dlg, &settings_dialog::GuiStylesheetRequest, this, &main_window::RequestGlobalStylesheetChange);
+		connect(&dlg, &settings_dialog::GuiRepaintRequest, this, &main_window::RepaintGui);
+		connect(&dlg, &settings_dialog::EmuSettingsApplied, this, &main_window::NotifyEmuSettingsChange);
+		connect(&dlg, &settings_dialog::EmuSettingsApplied, m_log_frame, &log_frame::LoadSettings);
+		dlg.exec();
+	};
+
+	connect(ui->confCPUAct,    &QAction::triggered, this, [open_settings]() { open_settings(0); });
+	connect(ui->confGPUAct,    &QAction::triggered, this, [open_settings]() { open_settings(1); });
+	connect(ui->confAudioAct,  &QAction::triggered, this, [open_settings]() { open_settings(2); });
+	connect(ui->confIOAct,     &QAction::triggered, this, [open_settings]() { open_settings(3); });
+	connect(ui->confSystemAct, &QAction::triggered, this, [open_settings]() { open_settings(4); });
+	connect(ui->confAdvAct,    &QAction::triggered, this, [open_settings]() { open_settings(6); });
+	connect(ui->confEmuAct,    &QAction::triggered, this, [open_settings]() { open_settings(7); });
+	connect(ui->confGuiAct,    &QAction::triggered, this, [open_settings]() { open_settings(8); });
+
+	connect(ui->confShortcutsAct, &QAction::triggered, [this]()
+	{
+		shortcut_dialog dlg(m_gui_settings, this);
+		connect(&dlg, &shortcut_dialog::saved, m_shortcut_handler, &shortcut_handler::update);
+		dlg.exec();
+	});
+
+	const auto open_pad_settings = [this]
+	{
+		pad_settings_dialog dlg(m_gui_settings, this);
+		dlg.exec();
+	};
+
+	connect(ui->confPadsAct, &QAction::triggered, this, open_pad_settings);
+
+	connect(ui->confBuzzAct, &QAction::triggered, this, [this]
+	{
+		emulated_pad_settings_dialog* dlg = new emulated_pad_settings_dialog(emulated_pad_settings_dialog::pad_type::buzz, this);
+		dlg->show();
+	});
+
+	connect(ui->confGHLtarAct, &QAction::triggered, this, [this]
+	{
+		emulated_pad_settings_dialog* dlg = new emulated_pad_settings_dialog(emulated_pad_settings_dialog::pad_type::ghltar, this);
+		dlg->show();
+	});
+
+	connect(ui->confTurntableAct, &QAction::triggered, this, [this]
+	{
+		emulated_pad_settings_dialog* dlg = new emulated_pad_settings_dialog(emulated_pad_settings_dialog::pad_type::turntable, this);
+		dlg->show();
+	});
+
+	connect(ui->confUSIOAct, &QAction::triggered, this, [this]
+	{
+		emulated_pad_settings_dialog* dlg = new emulated_pad_settings_dialog(emulated_pad_settings_dialog::pad_type::usio, this);
+		dlg->show();
+	});
+
+	connect(ui->confPSMoveDS3Act, &QAction::triggered, this, [this]
+	{
+		emulated_pad_settings_dialog* dlg = new emulated_pad_settings_dialog(emulated_pad_settings_dialog::pad_type::ds3gem, this);
+		dlg->show();
+	});
+
+	connect(ui->confCamerasAct, &QAction::triggered, this, [this]()
+	{
+		camera_settings_dialog dlg(this);
+		dlg.exec();
+	});
+
+	connect(ui->confRPCNAct, &QAction::triggered, this, [this]()
+	{
+		rpcn_settings_dialog dlg(this);
+		dlg.exec();
+	});
+
+	connect(ui->confIPCAct, &QAction::triggered, this, [this]()
+	{
+		ipc_settings_dialog dlg(this);
+		dlg.exec();
+	});
+
+	connect(ui->confAutopauseManagerAct, &QAction::triggered, this, [this]()
+	{
+		auto_pause_settings_dialog dlg(this);
+		dlg.exec();
+	});
+
+	connect(ui->confVFSDialogAct, &QAction::triggered, this, [this]()
+	{
+		vfs_dialog dlg(m_gui_settings, this);
+		dlg.exec();
+		ui->bootVSHAct->setEnabled(fs::is_file(g_cfg_vfs.get_dev_flash() + "vsh/module/vsh.self")); // dev_flash may have changed. Disable vsh if not present.
+		m_game_list_frame->Refresh(true); // dev_hdd0 may have changed. Refresh just in case.
+	});
+
+	connect(ui->confSavedataManagerAct, &QAction::triggered, this, [this]
+	{
+		save_manager_dialog* save_manager = new save_manager_dialog(m_gui_settings, m_persistent_settings);
+		connect(this, &main_window::RequestTrophyManagerRepaint, save_manager, &save_manager_dialog::HandleRepaintUiRequest);
+		save_manager->show();
+	});
+
+	connect(ui->actionManage_Trophy_Data, &QAction::triggered, this, [this]
+	{
+		trophy_manager_dialog* trop_manager = new trophy_manager_dialog(m_gui_settings);
+		connect(this, &main_window::RequestTrophyManagerRepaint, trop_manager, &trophy_manager_dialog::HandleRepaintUiRequest);
+		trop_manager->show();
+	});
+
+	connect(ui->actionManage_Skylanders_Portal, &QAction::triggered, this, [this]
+	{
+		skylander_dialog* sky_diag = skylander_dialog::get_dlg(this);
+		sky_diag->show();
+	});
+
+	connect(ui->actionManage_Infinity_Base, &QAction::triggered, this, [this]
+	{
+		infinity_dialog* inf_dlg = infinity_dialog::get_dlg(this);
+		inf_dlg->show();
+	});
+
+	connect(ui->actionManage_Cheats, &QAction::triggered, this, [this]
+	{
+		cheat_manager_dialog* cheat_manager = cheat_manager_dialog::get_dlg(this);
+		cheat_manager->show();
+ 	});
+
+	connect(ui->actionManage_Game_Patches, &QAction::triggered, this, [this]
+	{
+		std::unordered_map<std::string, std::set<std::string>> games;
+		if (m_game_list_frame)
+		{
+			for (const game_info& game : m_game_list_frame->GetGameInfo())
+			{
+				if (game)
+				{
+					games[game->info.serial].insert(game_list::GetGameVersion(game));
+				}
+			}
+		}
+		patch_manager_dialog patch_manager(m_gui_settings, games, "", "", this);
+		patch_manager.exec();
+ 	});
+
+	connect(ui->patchCreatorAct, &QAction::triggered, this, [this]
+	{
+		patch_creator_dialog patch_creator(this);
+		patch_creator.exec();
+	});
+
+	connect(ui->actionManage_Users, &QAction::triggered, this, [this]
+	{
+		user_manager_dialog user_manager(m_gui_settings, m_persistent_settings, this);
+		user_manager.exec();
+		m_game_list_frame->Refresh(true); // New user may have different games unlocked.
+	});
+
+	connect(ui->actionManage_Screenshots, &QAction::triggered, this, [this]
+	{
+		screenshot_manager_dialog* screenshot_manager = new screenshot_manager_dialog();
+		screenshot_manager->show();
+	});
+
+	connect(ui->toolsCgDisasmAct, &QAction::triggered, this, [this]
+	{
+		cg_disasm_window* cgdw = new cg_disasm_window(m_gui_settings);
+		cgdw->show();
+	});
+
+	connect(ui->actionLog_Viewer, &QAction::triggered, this, [this]
+	{
+		log_viewer* viewer = new log_viewer(m_gui_settings);
+		viewer->show();
+		viewer->show_log();
+	});
+
+	connect(ui->toolsCheckConfigAct, &QAction::triggered, this, [this]
+	{
+		const QString path_last_cfg = m_gui_settings->GetValue(gui::fd_cfg_check).toString();
+		const QString file_path = QFileDialog::getOpenFileName(this, tr("Select rpcs3.log or config.yml"), path_last_cfg, tr("Log or Config files (*.log *.txt *.yml);;Log files (*.log);;Config Files (*.yml);;Text Files (*.txt);;All files (*.*)"));
+		if (file_path.isEmpty())
+		{
+			// Aborted
+			return;
+		}
+
+		const QFileInfo file_info(file_path);
+
+		if (file_info.isExecutable() || !(file_path.endsWith(".log") || file_path.endsWith(".txt") || file_path.endsWith(".yml")))
+		{
+			if (QMessageBox::question(this, tr("Weird file!"), tr("This file seems to have an unexpected type:\n%0\n\nCheck anyway?").arg(file_path)) != QMessageBox::Yes)
+			{
+				return;
+			}
+		}
+
+		QFile file(file_path);
+		if (!file.exists() || !file.open(QIODevice::ReadOnly))
+		{
+			QMessageBox::warning(this, tr("Failed to open file"), tr("The file could not be opened:\n%0").arg(file_path));
+			return;
+		}
+
+		m_gui_settings->SetValue(gui::fd_cfg_check, file_info.path());
+
+		config_checker* dlg = new config_checker(this, file.readAll(), file_path.endsWith(".log"));
+		dlg->exec();
+	});
+
+	connect(ui->toolskernel_explorerAct, &QAction::triggered, this, [this]
+	{
+		if (!m_kernel_explorer)
+		{
+			m_kernel_explorer = new kernel_explorer(this);
+			connect(m_kernel_explorer, &QDialog::finished, this, [this]() { m_kernel_explorer = nullptr; });
+		}
+
+		m_kernel_explorer->show();
+	});
+
+	connect(ui->toolsmemory_viewerAct, &QAction::triggered, this, [this]
+	{
+		if (!Emu.IsStopped())
+			idm::make<memory_viewer_handle>(this, make_basic_ppu_disasm());
+	});
+
+	connect(ui->toolsRsxDebuggerAct, &QAction::triggered, this, [this]
+	{
+		rsx_debugger* rsx = new rsx_debugger(m_gui_settings);
+		rsx->show();
+	});
+
+	connect(ui->toolsSystemCommandsAct, &QAction::triggered, this, [this]
+	{
+		if (Emu.IsStopped()) return;
+		if (!m_system_cmd_dialog)
+		{
+			m_system_cmd_dialog = new system_cmd_dialog(this);
+			connect(m_system_cmd_dialog, &QDialog::finished, this, [this]() { m_system_cmd_dialog = nullptr; });
+		}
+		m_system_cmd_dialog->show();
+	});
+
+	connect(ui->toolsDecryptSprxLibsAct, &QAction::triggered, this, &main_window::DecryptSPRXLibraries);
+
+	connect(ui->toolsExtractMSELFAct, &QAction::triggered, this, &main_window::ExtractMSELF);
+
+	connect(ui->toolsExtractPUPAct, &QAction::triggered, this, &main_window::ExtractPup);
+
+	connect(ui->toolsExtractTARAct, &QAction::triggered, this, &main_window::ExtractTar);
+
+	connect(ui->showDebuggerAct, &QAction::triggered, this, [this](bool checked)
+	{
+		checked ? m_debugger_frame->show() : m_debugger_frame->hide();
+		m_gui_settings->SetValue(gui::mw_debugger, checked);
+	});
+
+	connect(ui->showLogAct, &QAction::triggered, this, [this](bool checked)
+	{
+		checked ? m_log_frame->show() : m_log_frame->hide();
+		m_gui_settings->SetValue(gui::mw_logger, checked);
+	});
+
+	connect(ui->showGameListAct, &QAction::triggered, this, [this](bool checked)
+	{
+		checked ? m_game_list_frame->show() : m_game_list_frame->hide();
+		m_gui_settings->SetValue(gui::mw_gamelist, checked);
+	});
+
+	connect(ui->showTitleBarsAct, &QAction::triggered, this, [this](bool checked)
+	{
+		ShowTitleBars(checked);
+		m_gui_settings->SetValue(gui::mw_titleBarsVisible, checked);
+	});
+
+	connect(ui->showToolBarAct, &QAction::triggered, this, [this](bool checked)
+	{
+		ui->toolBar->setVisible(checked);
+		m_gui_settings->SetValue(gui::mw_toolBarVisible, checked);
+	});
+
+	connect(ui->showHiddenEntriesAct, &QAction::triggered, this, [this](bool checked)
+	{
+		m_gui_settings->SetValue(gui::gl_show_hidden, checked);
+		m_game_list_frame->SetShowHidden(checked);
+		m_game_list_frame->Refresh();
+	});
+
+	connect(ui->showCompatibilityInGridAct, &QAction::triggered, m_game_list_frame, &game_list_frame::SetShowCompatibilityInGrid);
+
+	connect(ui->refreshGameListAct, &QAction::triggered, this, [this]
+	{
+		m_game_list_frame->Refresh(true);
+	});
+
+	const auto get_cats = [this](QAction* act, int& id) -> QStringList
+	{
+		QStringList categories;
+		if      (act == ui->showCatHDDGameAct)    { categories += cat::cat_hdd_game;  id = Category::HDD_Game;    }
+		else if (act == ui->showCatDiscGameAct)   { categories += cat::cat_disc_game; id = Category::Disc_Game;   }
+		else if (act == ui->showCatPS1GamesAct)   { categories += cat::cat_ps1_game;  id = Category::PS1_Game;    }
+		else if (act == ui->showCatPS2GamesAct)   { categories += cat::ps2_games;     id = Category::PS2_Game;    }
+		else if (act == ui->showCatPSPGamesAct)   { categories += cat::psp_games;     id = Category::PSP_Game;    }
+		else if (act == ui->showCatHomeAct)       { categories += cat::cat_home;      id = Category::Home;        }
+		else if (act == ui->showCatAudioVideoAct) { categories += cat::media;         id = Category::Media;       }
+		else if (act == ui->showCatGameDataAct)   { categories += cat::data;          id = Category::Data;        }
+		else if (act == ui->showCatUnknownAct)    { categories += cat::cat_unknown;   id = Category::Unknown_Cat; }
+		else if (act == ui->showCatOtherAct)      { categories += cat::others;        id = Category::Others;      }
+		else { gui_log.warning("categoryVisibleActGroup: category action not found"); }
+		return categories;
+	};
+
+	connect(m_category_visible_act_group, &QActionGroup::triggered, this, [this, get_cats](QAction* act)
+	{
+		int id = 0;
+		const QStringList categories = get_cats(act, id);
+
+		if (!categories.isEmpty())
+		{
+			const bool checked = act->isChecked();
+			m_game_list_frame->ToggleCategoryFilter(categories, checked);
+			m_gui_settings->SetCategoryVisibility(id, checked, m_is_list_mode);
+		}
+	});
+
+	connect(ui->menuGame_Categories, &QMenu::aboutToShow, ui->menuGame_Categories, [this, get_cats]()
+	{
+		const auto set_cat_count = [&](QAction* act, const QString& text)
+		{
+			int count = 0;
+			int id = 0; // Unused
+			const QStringList categories = get_cats(act, id);
+			for (const game_info& game : m_game_list_frame->GetGameInfo())
+			{
+				if (game && categories.contains(qstr(game->info.category))) count++;
+			}
+			act->setText(QString("%0 (%1)").arg(text).arg(count));
+		};
+
+		set_cat_count(ui->showCatHDDGameAct, tr("HDD Games"));
+		set_cat_count(ui->showCatDiscGameAct, tr("Disc Games"));
+		set_cat_count(ui->showCatPS1GamesAct, tr("PS1 Games"));
+		set_cat_count(ui->showCatPS2GamesAct, tr("PS2 Games"));
+		set_cat_count(ui->showCatPSPGamesAct, tr("PSP Games"));
+		set_cat_count(ui->showCatHomeAct, tr("Home"));
+		set_cat_count(ui->showCatAudioVideoAct, tr("Audio/Video"));
+		set_cat_count(ui->showCatGameDataAct, tr("Game Data"));
+		set_cat_count(ui->showCatUnknownAct, tr("Unknown"));
+		set_cat_count(ui->showCatOtherAct, tr("Other"));
+	});
+
+	connect(ui->updateAct, &QAction::triggered, this, [this]()
+	{
+#if !defined(_WIN32) && !defined(__linux__)
+		QMessageBox::warning(this, tr("Auto-updater"), tr("The auto-updater isn't available for your OS currently."));
+		return;
+#endif
+		m_updater.check_for_updates(false, false, false, this);
+	});
+
+	connect(ui->aboutAct, &QAction::triggered, this, [this]
+	{
+		about_dialog dlg(this);
+		dlg.exec();
+	});
+
+	connect(ui->aboutQtAct, &QAction::triggered, qApp, &QApplication::aboutQt);
+
+	connect(m_icon_size_act_group, &QActionGroup::triggered, this, [this](QAction* act)
+	{
+		static const int index_small  = gui::get_Index(gui::gl_icon_size_small);
+		static const int index_medium = gui::get_Index(gui::gl_icon_size_medium);
+
+		int index;
+
+		if (act == ui->setIconSizeTinyAct)
+			index = 0;
+		else if (act == ui->setIconSizeSmallAct)
+			index = index_small;
+		else if (act == ui->setIconSizeMediumAct)
+			index = index_medium;
+		else
+			index = gui::gl_max_slider_pos;
+
+		m_save_slider_pos = true;
+		ResizeIcons(index);
+	});
+
+	connect(ui->showCustomIconsAct, &QAction::triggered, m_game_list_frame, &game_list_frame::SetShowCustomIcons);
+	connect(ui->playHoverGifsAct, &QAction::triggered, m_game_list_frame, &game_list_frame::SetPlayHoverGifs);
+
+	connect(m_game_list_frame, &game_list_frame::RequestIconSizeChange, this, [this](const int& val)
+	{
+		const int idx = ui->sizeSlider->value() + val;
+		m_save_slider_pos = true;
+		ResizeIcons(idx);
+	});
+
+	connect(m_list_mode_act_group, &QActionGroup::triggered, this, [this](QAction* act)
+	{
+		const bool is_list_act = act == ui->setlistModeListAct;
+		if (is_list_act == m_is_list_mode)
+			return;
+
+		const int slider_pos = ui->sizeSlider->sliderPosition();
+		ui->sizeSlider->setSliderPosition(m_other_slider_pos);
+		SetIconSizeActions(m_other_slider_pos);
+		m_other_slider_pos = slider_pos;
+
+		m_is_list_mode = is_list_act;
+		m_game_list_frame->SetListMode(m_is_list_mode);
+
+		UpdateFilterActions();
+	});
+
+	connect(ui->toolbar_open, &QAction::triggered, this, &main_window::BootGame);
+	connect(ui->toolbar_refresh, &QAction::triggered, this, [this]() { m_game_list_frame->Refresh(true); });
+	connect(ui->toolbar_stop, &QAction::triggered, this, []()
+	{
+		gui_log.notice("User triggered stop action in toolbar");
+		Emu.GracefulShutdown(false);
+	});
+	connect(ui->toolbar_start, &QAction::triggered, this, &main_window::OnPlayOrPause);
+
+	connect(ui->toolbar_fullscreen, &QAction::triggered, this, [this]
+	{
+		if (isFullScreen())
+		{
+			showNormal();
+			ui->toolbar_fullscreen->setIcon(m_icon_fullscreen_on);
+		}
+		else
+		{
+			showFullScreen();
+			ui->toolbar_fullscreen->setIcon(m_icon_fullscreen_off);
+		}
+	});
+
+	connect(ui->toolbar_controls, &QAction::triggered, this, open_pad_settings);
+	connect(ui->toolbar_config, &QAction::triggered, this, [=]() { open_settings(0); });
+	connect(ui->toolbar_list, &QAction::triggered, this, [this]() { ui->setlistModeListAct->trigger(); });
+	connect(ui->toolbar_grid, &QAction::triggered, this, [this]() { ui->setlistModeGridAct->trigger(); });
+
+	connect(ui->sizeSlider, &QSlider::valueChanged, this, &main_window::ResizeIcons);
+	connect(ui->sizeSlider, &QSlider::sliderReleased, this, [this]
+	{
+		const int index = ui->sizeSlider->value();
+		m_gui_settings->SetValue(m_is_list_mode ? gui::gl_iconSize : gui::gl_iconSizeGrid, index);
+		SetIconSizeActions(index);
+	});
+	connect(ui->sizeSlider, &QSlider::actionTriggered, this, [this](int action)
+	{
+		if (action != QAbstractSlider::SliderNoAction && action != QAbstractSlider::SliderMove)
+		{	// we only want to save on mouseclicks or slider release (the other connect handles this)
+			m_save_slider_pos = true; // actionTriggered happens before the value was changed
+		}
+	});
+
+	connect(ui->mw_searchbar, &QLineEdit::textChanged, m_game_list_frame, &game_list_frame::SetSearchText);
+	connect(ui->mw_searchbar, &QLineEdit::returnPressed, m_game_list_frame, &game_list_frame::FocusAndSelectFirstEntryIfNoneIs);
+	connect(m_game_list_frame, &game_list_frame::FocusToSearchBar, this, [this]() { ui->mw_searchbar->setFocus(); });
+}
+
+void main_window::CreateDockWindows()
+{
+	// new mainwindow widget because existing seems to be bugged for now
+	m_mw = new QMainWindow();
+	m_mw->setContextMenuPolicy(Qt::PreventContextMenu);
+
+	m_game_list_frame = new game_list_frame(m_gui_settings, m_emu_settings, m_persistent_settings, m_mw);
+	m_game_list_frame->setObjectName("gamelist");
+	m_debugger_frame = new debugger_frame(m_gui_settings, m_mw);
+	m_debugger_frame->setObjectName("debugger");
+	m_log_frame = new log_frame(m_gui_settings, m_mw);
+	m_log_frame->setObjectName("logger");
+
+	m_mw->addDockWidget(Qt::LeftDockWidgetArea, m_game_list_frame);
+	m_mw->addDockWidget(Qt::LeftDockWidgetArea, m_log_frame);
+	m_mw->addDockWidget(Qt::RightDockWidgetArea, m_debugger_frame);
+	m_mw->setDockNestingEnabled(true);
+	m_mw->resizeDocks({ m_log_frame }, { m_mw->sizeHint().height() / 10 }, Qt::Orientation::Vertical);
+	setCentralWidget(m_mw);
+
+	connect(m_log_frame, &log_frame::LogFrameClosed, this, [this]()
+	{
+		if (ui->showLogAct->isChecked())
+		{
+			ui->showLogAct->setChecked(false);
+			m_gui_settings->SetValue(gui::mw_logger, false);
+		}
+	});
+
+	connect(m_log_frame, &log_frame::PerformGoToOnDebugger, this, [this](const QString& text_argument, bool test_only, std::shared_ptr<bool> signal_accepted)
+	{
+		if (m_debugger_frame && m_debugger_frame->isVisible())
+		{
+			if (signal_accepted)
+			{
+				*signal_accepted = true;
+			}
+
+			if (!test_only)
+			{
+				m_debugger_frame->PerformGoToRequest(text_argument);
+			}
+		}
+	});
+
+	connect(m_debugger_frame, &debugger_frame::DebugFrameClosed, this, [this]()
+	{
+		if (ui->showDebuggerAct->isChecked())
+		{
+			ui->showDebuggerAct->setChecked(false);
+			m_gui_settings->SetValue(gui::mw_debugger, false);
+		}
+	});
+
+	connect(m_game_list_frame, &game_list_frame::GameListFrameClosed, this, [this]()
+	{
+		if (ui->showGameListAct->isChecked())
+		{
+			ui->showGameListAct->setChecked(false);
+			m_gui_settings->SetValue(gui::mw_gamelist, false);
+		}
+	});
+
+	connect(m_game_list_frame, &game_list_frame::NotifyGameSelection, this, [this](const game_info& game)
+	{
+		// Only change the button logic while the emulator is stopped.
+		if (Emu.IsStopped())
+		{
+			QString tooltip;
+
+			bool enable_play_buttons = true;
+
+			if (game) // A game was selected
+			{
+				const std::string title_and_title_id = game->info.name + " [" + game->info.serial + "]";
+
+				if (title_and_title_id == Emu.GetTitleAndTitleID()) // This should usually not cause trouble, but feel free to improve.
+				{
+					tooltip = tr("Restart %0").arg(qstr(title_and_title_id));
+
+					ui->toolbar_start->setIcon(m_icon_restart);
+					ui->toolbar_start->setText(tr("Restart"));
+				}
+				else
+				{
+					tooltip = tr("Play %0").arg(qstr(title_and_title_id));
+
+					ui->toolbar_start->setIcon(m_icon_play);
+					ui->toolbar_start->setText(tr("Play"));
+				}
+			}
+			else if (m_selected_game) // No game was selected. Check if a game was selected before.
+			{
+				if (Emu.IsReady()) // Prefer games that are about to be booted ("Automatically start games" was set to off)
+				{
+					tooltip = tr("Play %0").arg(GetCurrentTitle());
+
+					ui->toolbar_start->setIcon(m_icon_play);
+				}
+				else if (const auto& path = Emu.GetBoot(); !path.empty()) // Restartable games
+				{
+					tooltip = tr("Restart %0").arg(GetCurrentTitle());
+
+					ui->toolbar_start->setIcon(m_icon_restart);
+					ui->toolbar_start->setText(tr("Restart"));
+				}
+				else if (!m_recent_game_acts.isEmpty()) // Get last played game
+				{
+					tooltip = tr("Play %0").arg(m_recent_game_acts.first()->text());
+				}
+				else
+				{
+					enable_play_buttons = false;
+				}
+			}
+			else
+			{
+				enable_play_buttons = false;
+			}
+
+			ui->toolbar_start->setEnabled(enable_play_buttons);
+			ui->sysPauseAct->setEnabled(enable_play_buttons);
+#ifdef _WIN32
+			m_thumb_playPause->setEnabled(enable_play_buttons);
+#endif
+
+			if (!tooltip.isEmpty())
+			{
+				ui->toolbar_start->setToolTip(tooltip);
+#ifdef _WIN32
+				m_thumb_playPause->setToolTip(tooltip);
+#endif
+			}
+		}
+
+		m_selected_game = game;
+	});
+
+	connect(m_game_list_frame, &game_list_frame::RequestBoot, this, [this](const game_info& game, cfg_mode config_mode, const std::string& config_path, const std::string& savestate)
+	{
+		Boot(savestate.empty() ? game->info.path : savestate, game->info.serial, false, false, config_mode, config_path);
+	});
+
+	connect(m_game_list_frame, &game_list_frame::NotifyEmuSettingsChange, this, &main_window::NotifyEmuSettingsChange);
+}
+
+void main_window::ConfigureGuiFromSettings()
+{
+	// Restore GUI state if needed. We need to if they exist.
+	if (!restoreGeometry(m_gui_settings->GetValue(gui::mw_geometry).toByteArray()))
+	{
+		// By default, set the window to 70% of the screen and the debugger frame is hidden.
+		m_debugger_frame->hide();
+		resize(QGuiApplication::primaryScreen()->availableSize() * 0.7);
+	}
+
+	restoreState(m_gui_settings->GetValue(gui::mw_windowState).toByteArray());
+	m_mw->restoreState(m_gui_settings->GetValue(gui::mw_mwState).toByteArray());
+
+	ui->freezeRecentAct->setChecked(m_gui_settings->GetValue(gui::rg_freeze).toBool());
+	m_rg_entries = m_gui_settings->Var2List(m_gui_settings->GetValue(gui::rg_entries));
+
+	// clear recent games menu of actions
+	for (auto act : m_recent_game_acts)
+	{
+		ui->bootRecentMenu->removeAction(act);
+	}
+	m_recent_game_acts.clear();
+
+	// Fill the recent games menu
+	for (int i = 0; i < m_rg_entries.count(); i++)
+	{
+		// adjust old unformatted entries (avoid duplication)
+		m_rg_entries[i] = gui::Recent_Game(m_rg_entries[i].first, m_rg_entries[i].second);
+
+		// create new action
+		QAction* act = CreateRecentAction(m_rg_entries[i], i + 1);
+
+		// add action to menu
+		if (act)
+		{
+			m_recent_game_acts.append(act);
+			ui->bootRecentMenu->addAction(act);
+		}
+		else
+		{
+			i--; // list count is now an entry shorter so we have to repeat the same index in order to load all other entries
+		}
+	}
+
+	ui->showLogAct->setChecked(m_gui_settings->GetValue(gui::mw_logger).toBool());
+	ui->showGameListAct->setChecked(m_gui_settings->GetValue(gui::mw_gamelist).toBool());
+	ui->showDebuggerAct->setChecked(m_gui_settings->GetValue(gui::mw_debugger).toBool());
+	ui->showToolBarAct->setChecked(m_gui_settings->GetValue(gui::mw_toolBarVisible).toBool());
+	ui->showTitleBarsAct->setChecked(m_gui_settings->GetValue(gui::mw_titleBarsVisible).toBool());
+
+	m_debugger_frame->setVisible(ui->showDebuggerAct->isChecked());
+	m_log_frame->setVisible(ui->showLogAct->isChecked());
+	m_game_list_frame->setVisible(ui->showGameListAct->isChecked());
+	ui->toolBar->setVisible(ui->showToolBarAct->isChecked());
+
+	ShowTitleBars(ui->showTitleBarsAct->isChecked());
+
+	ui->showHiddenEntriesAct->setChecked(m_gui_settings->GetValue(gui::gl_show_hidden).toBool());
+	m_game_list_frame->SetShowHidden(ui->showHiddenEntriesAct->isChecked()); // prevent GetValue in m_game_list_frame->LoadSettings
+
+	ui->showCompatibilityInGridAct->setChecked(m_gui_settings->GetValue(gui::gl_draw_compat).toBool());
+	ui->showCustomIconsAct->setChecked(m_gui_settings->GetValue(gui::gl_custom_icon).toBool());
+	ui->playHoverGifsAct->setChecked(m_gui_settings->GetValue(gui::gl_hover_gifs).toBool());
+
+	m_is_list_mode = m_gui_settings->GetValue(gui::gl_listMode).toBool();
+
+	UpdateFilterActions();
+
+	// handle icon size options
+	if (m_is_list_mode)
+		ui->setlistModeListAct->setChecked(true);
+	else
+		ui->setlistModeGridAct->setChecked(true);
+
+	const int icon_size_index = m_gui_settings->GetValue(m_is_list_mode ? gui::gl_iconSize : gui::gl_iconSizeGrid).toInt();
+	m_other_slider_pos = m_gui_settings->GetValue(!m_is_list_mode ? gui::gl_iconSize : gui::gl_iconSizeGrid).toInt();
+	ui->sizeSlider->setSliderPosition(icon_size_index);
+	SetIconSizeActions(icon_size_index);
+
+	// Handle log settings
+	m_log_frame->LoadSettings();
+
+	// Gamelist
+	m_game_list_frame->LoadSettings();
+}
+
+void main_window::SetIconSizeActions(int idx) const
+{
+	static const int threshold_tiny = gui::get_Index((gui::gl_icon_size_small + gui::gl_icon_size_min) / 2);
+	static const int threshold_small = gui::get_Index((gui::gl_icon_size_medium + gui::gl_icon_size_small) / 2);
+	static const int threshold_medium = gui::get_Index((gui::gl_icon_size_max + gui::gl_icon_size_medium) / 2);
+
+	if (idx < threshold_tiny)
+		ui->setIconSizeTinyAct->setChecked(true);
+	else if (idx < threshold_small)
+		ui->setIconSizeSmallAct->setChecked(true);
+	else if (idx < threshold_medium)
+		ui->setIconSizeMediumAct->setChecked(true);
+	else
+		ui->setIconSizeLargeAct->setChecked(true);
+}
+
+void main_window::RemoveDiskCache()
+{
+	const std::string cache_dir = rpcs3::utils::get_hdd1_dir() + "/caches";
+
+	if (fs::remove_all(cache_dir, false))
+	{
+		QMessageBox::information(this, tr("Cache Cleared"), tr("Disk cache was cleared successfully"));
+	}
+	else
+	{
+		QMessageBox::warning(this, tr("Error"), tr("Could not remove disk cache"));
+	}
+}
+
+void main_window::RemoveFirmwareCache()
+{
+	const std::string cache_dir = rpcs3::utils::get_cache_dir();
+
+	if (!fs::is_dir(cache_dir))
+		return;
+
+	if (QMessageBox::question(this, tr("Confirm Removal"), tr("Remove firmware cache?")) != QMessageBox::Yes)
+		return;
+
+	u32 caches_removed = 0;
+	u32 caches_total = 0;
+
+	const QStringList filter{ QStringLiteral("ppu-*-lib*.sprx")};
+
+	QDirIterator dir_iter(qstr(cache_dir), filter, QDir::Dirs | QDir::NoDotAndDotDot);
+
+	while (dir_iter.hasNext())
+	{
+		const QString path = dir_iter.next();
+
+		if (QDir(path).removeRecursively())
+		{
+			++caches_removed;
+			gui_log.notice("Removed firmware cache: %s", sstr(path));
+		}
+		else
+		{
+			gui_log.warning("Could not remove firmware cache: %s", sstr(path));
+		}
+
+		++caches_total;
+	}
+
+	const bool success = caches_total == caches_removed;
+
+	if (success)
+		gui_log.success("Removed firmware cache in %s", cache_dir);
+	else
+		gui_log.fatal("Only %d/%d firmware caches could be removed in %s", caches_removed, caches_total, cache_dir);
+
+	return;
+}
+
+void main_window::CreateFirmwareCache()
+{
+	if (!m_gui_settings->GetBootConfirmation(this))
+	{
+		return;
+	}
+
+	Emu.GracefulShutdown(false);
+	Emu.SetForceBoot(true);
+
+	if (const game_boot_result error = Emu.BootGame(g_cfg_vfs.get_dev_flash() + "sys", "", true);
+		error != game_boot_result::no_errors)
+	{
+		gui_log.error("Creating firmware cache failed: reason: %s", error);
+	}
+}
+
+void main_window::mouseDoubleClickEvent(QMouseEvent *event)
+{
+	if (isFullScreen())
+	{
+		if (event->button() == Qt::LeftButton)
+		{
+			showNormal();
+			ui->toolbar_fullscreen->setIcon(m_icon_fullscreen_on);
+		}
+	}
+}
+
+/** Override the Qt close event to have the emulator stop and the application die.
+*/
+void main_window::closeEvent(QCloseEvent* closeEvent)
+{
+	if (!m_gui_settings->GetBootConfirmation(this, gui::ib_confirm_exit))
+	{
+		closeEvent->ignore();
+		return;
+	}
+
+	// Cleanly stop and quit the emulator.
+	if (!Emu.IsStopped())
+	{
+		Emu.GracefulShutdown(false);
+	}
+
+	Emu.Quit(true);
+}
+
+/**
+Add valid disc games to gamelist (games.yml)
+@param path = dir path to scan for game
+*/
+void main_window::AddGamesFromDir(const QString& path)
+{
+	if (!QFileInfo(path).isDir())
+	{
+		return;
+	}
+
+	Emu.AddGamesFromDir(sstr(path));
+}
+
+/**
+Check data for valid file types and cache their paths if necessary
+@param md = data containing file urls
+@param drop_paths = flag for path caching
+@returns validity of file type
+*/
+main_window::drop_type main_window::IsValidFile(const QMimeData& md, QStringList* drop_paths)
+{
+	auto drop_type = drop_type::drop_error;
+
+	const QList<QUrl> list = md.urls(); // get list of all the dropped file urls
+
+	for (auto&& url : list) // check each file in url list for valid type
+	{
+		const QString path = url.toLocalFile(); // convert url to filepath
+		const QFileInfo info(path);
+
+		// check for directories first, only valid if all other paths led to directories until now.
+		if (info.isDir())
+		{
+			if (drop_type != drop_type::drop_dir && drop_type != drop_type::drop_error)
+			{
+				return drop_type::drop_error;
+			}
+
+			drop_type = drop_type::drop_dir;
+		}
+		else if (info.suffix() == "PUP")
+		{
+			if (list.size() != 1)
+			{
+				return drop_type::drop_error;
+			}
+
+			drop_type = drop_type::drop_pup;
+		}
+		else if (info.fileName().toLower() == "param.sfo")
+		{
+			if (drop_type != drop_type::drop_psf && drop_type != drop_type::drop_error)
+			{
+				return drop_type::drop_error;
+			}
+
+			drop_type = drop_type::drop_psf;
+		}
+		else if (info.suffix().toLower() == "pkg")
+		{
+			if (drop_type != drop_type::drop_pkg && drop_type != drop_type::drop_error)
+			{
+				return drop_type::drop_error;
+			}
+
+			drop_type = drop_type::drop_pkg;
+		}
+		else if (info.suffix().toLower() == "rap" || info.suffix().toLower() == "edat")
+		{
+			if (info.size() < 0x10 || (drop_type != drop_type::drop_rap_edat && drop_type != drop_type::drop_error))
+			{
+				return drop_type::drop_error;
+			}
+
+			drop_type = drop_type::drop_rap_edat;
+		}
+		else if (list.size() == 1)
+		{
+			if (info.suffix() == "rrc")
+			{
+				drop_type = drop_type::drop_rrc;
+			}
+			else
+			{
+				drop_type = drop_type::drop_game;
+			}
+		}
+		else
+		{
+			return drop_type::drop_error;
+		}
+
+		if (drop_paths) // we only need to know the paths on drop
+		{
+			drop_paths->append(path);
+		}
+	}
+
+	return drop_type;
+}
+
+void main_window::dropEvent(QDropEvent* event)
+{
+	QStringList drop_paths;
+
+	switch (IsValidFile(*event->mimeData(), &drop_paths)) // get valid file paths and drop type
+	{
+	case drop_type::drop_error:
+	{
+		break;
+	}
+	case drop_type::drop_pkg: // install the packages
+	{
+		InstallPackages(drop_paths);
+		break;
+	}
+	case drop_type::drop_pup: // install the firmware
+	{
+		InstallPup(drop_paths.first());
+		break;
+	}
+	case drop_type::drop_rap_edat: // import rap files to exdata dir
+	{
+		int installed_count = 0;
+
+		for (const auto& path : drop_paths)
+		{
+			const QFileInfo file_info = path;
+			const std::string extension = file_info.suffix().toLower().toStdString();
+			const std::string filename = sstr(file_info.fileName());
+
+			if (InstallFileInExData(extension, path, filename))
+			{
+				gui_log.success("Successfully copied %s file by drop: %s", extension, filename);
+				installed_count++;
+			}
+			else
+			{
+				gui_log.error("Could not copy %s file by drop: %s", extension, filename);
+			}
+		}
+
+		if (installed_count > 0)
+		{
+			// Refresh game list since we probably unlocked some games now.
+			m_game_list_frame->Refresh(true);
+		}
+
+		break;
+	}
+	case drop_type::drop_psf: // Display PARAM.SFO content
+	{
+		for (const auto& psf : drop_paths)
+		{
+			const std::string psf_path = sstr(psf);
+			std::string info = fmt::format("Dropped PARAM.SFO '%s':\n\n%s", psf_path, psf::load(psf_path).sfo);
+
+			gui_log.success("%s", info);
+			info.erase(info.begin(), info.begin() + info.find_first_of('\''));
+
+			QMessageBox mb(QMessageBox::Information, tr("PARAM.SFO Information"), qstr(info), QMessageBox::Ok, this);
+			mb.setTextInteractionFlags(Qt::TextSelectableByMouse);
+			mb.exec();
+		}
+
+		break;
+	}
+	case drop_type::drop_dir: // import valid games to gamelist (games.yaml)
+	{
+		if (!m_gui_settings->GetBootConfirmation(this))
+		{
+			return;
+		}
+
+		for (const auto& path : drop_paths)
+		{
+			Emu.GracefulShutdown(false);
+			AddGamesFromDir(path);
+		}
+
+		m_game_list_frame->Refresh(true);
+		break;
+	}
+	case drop_type::drop_game: // import valid games to gamelist (games.yaml)
+	{
+		if (!m_gui_settings->GetBootConfirmation(this))
+		{
+			return;
+		}
+
+		Emu.GracefulShutdown(false);
+
+		if (const auto error = Emu.BootGame(sstr(drop_paths.first()), "", true); error != game_boot_result::no_errors)
+		{
+			gui_log.error("Boot failed: reason: %s, path: %s", error, sstr(drop_paths.first()));
+			show_boot_error(error);
+		}
+		else
+		{
+			gui_log.success("Elf Boot from drag and drop done: %s", sstr(drop_paths.first()));
+			m_game_list_frame->Refresh(true);
+		}
+		break;
+	}
+	case drop_type::drop_rrc: // replay a rsx capture file
+	{
+		BootRsxCapture(sstr(drop_paths.first()));
+		break;
+	}
+	}
+}
+
+void main_window::dragEnterEvent(QDragEnterEvent* event)
+{
+	if (IsValidFile(*event->mimeData()) != drop_type::drop_error)
+	{
+		event->accept();
+	}
+}
+
+void main_window::dragMoveEvent(QDragMoveEvent* event)
+{
+	if (IsValidFile(*event->mimeData()) != drop_type::drop_error)
+	{
+		event->accept();
+	}
+}
+
+void main_window::dragLeaveEvent(QDragLeaveEvent* event)
+{
+	event->accept();
+}
diff --git a/rpcs3/rpcs3qt/main_window.h b/rpcs3/rpcs3qt/main_window.h
index edcb4d130..cbacd559b 100644
--- a/rpcs3/rpcs3qt/main_window.h
+++ b/rpcs3/rpcs3qt/main_window.h
@@ -1,6 +1,6 @@
 #pragma once
 
-#ifdef _WIN32
+#ifdef HAS_QT_WIN_STUFF
 #include <QWinTHumbnailToolbar>
 #include <QWinTHumbnailToolbutton>
 #endif
@@ -57,7 +57,7 @@ class main_window : public QMainWindow
 	QIcon m_icon_fullscreen_on;
 	QIcon m_icon_fullscreen_off;
 
-#ifdef _WIN32
+#ifdef HAS_QT_WIN_STUFF
 	QIcon m_icon_thumb_play;
 	QIcon m_icon_thumb_pause;
 	QIcon m_icon_thumb_stop;
diff --git a/rpcs3/rpcs3qt/osk_dialog_frame.cpp b/rpcs3/rpcs3qt/osk_dialog_frame.cpp
index 031199789..32336f44c 100644
--- a/rpcs3/rpcs3qt/osk_dialog_frame.cpp
+++ b/rpcs3/rpcs3qt/osk_dialog_frame.cpp
@@ -182,7 +182,7 @@ void osk_dialog_frame::Create(const osk_params& params)
 
 void osk_dialog_frame::SetOskText(const QString& text)
 {
-	std::memcpy(osk_text.data(), utils::bless<char16_t>(text.constData()), std::min(osk_text.size(), text.size() + usz{1}) * sizeof(char16_t));
+	std::memcpy(osk_text.data(), utils::bless<char16_t>(text.constData()), std::min<usz>(osk_text.size(), text.size() + usz{1}) * sizeof(char16_t));
 }
 
 void osk_dialog_frame::Close(s32 status)
diff --git a/rpcs3/rpcs3qt/progress_indicator.cpp b/rpcs3/rpcs3qt/progress_indicator.cpp
index 335b5b098..3130444fb 100644
--- a/rpcs3/rpcs3qt/progress_indicator.cpp
+++ b/rpcs3/rpcs3qt/progress_indicator.cpp
@@ -1,6 +1,6 @@
 #include "progress_indicator.h"
 
-#ifdef _WIN32
+#ifdef HAS_QT_WIN_STUFF
 #include <QCoreApplication>
 #include <QWinTaskbarProgress>
 #elif HAVE_QTDBUS
@@ -10,7 +10,7 @@
 
 progress_indicator::progress_indicator(int minimum, int maximum)
 {
-#ifdef _WIN32
+#ifdef HAS_QT_WIN_STUFF
 	m_tb_button = std::make_unique<QWinTaskbarButton>();
 	m_tb_button->progress()->setRange(minimum, maximum);
 	m_tb_button->progress()->setVisible(false);
@@ -25,7 +25,7 @@ progress_indicator::progress_indicator(int minimum, int maximum)
 
 progress_indicator::~progress_indicator()
 {
-#ifdef _WIN32
+#ifdef HAS_QT_WIN_STUFF
 	// QWinTaskbarProgress::hide() will crash if the application is already about to close, even if the object is not null.
 	if (!QCoreApplication::closingDown())
 	{
@@ -38,7 +38,7 @@ progress_indicator::~progress_indicator()
 
 void progress_indicator::show(QWindow* window)
 {
-#ifdef _WIN32
+#ifdef HAS_QT_WIN_STUFF
 	m_tb_button->setWindow(window);
 	m_tb_button->progress()->show();
 #else
@@ -48,7 +48,7 @@ void progress_indicator::show(QWindow* window)
 
 int progress_indicator::value() const
 {
-#ifdef _WIN32
+#ifdef HAS_QT_WIN_STUFF
 	return m_tb_button->progress()->value();
 #else
 	return m_value;
@@ -57,7 +57,7 @@ int progress_indicator::value() const
 
 void progress_indicator::set_value(int value)
 {
-#ifdef _WIN32
+#ifdef HAS_QT_WIN_STUFF
 	m_tb_button->progress()->setValue(std::clamp(value, m_tb_button->progress()->minimum(), m_tb_button->progress()->maximum()));
 #else
 	m_value = std::clamp(value, m_minimum, m_maximum);
@@ -69,7 +69,7 @@ void progress_indicator::set_value(int value)
 
 void progress_indicator::set_range(int minimum, int maximum)
 {
-#ifdef _WIN32
+#ifdef HAS_QT_WIN_STUFF
 	m_tb_button->progress()->setRange(minimum, maximum);
 #else
 	m_minimum = minimum;
@@ -79,7 +79,7 @@ void progress_indicator::set_range(int minimum, int maximum)
 
 void progress_indicator::reset()
 {
-#ifdef _WIN32
+#ifdef HAS_QT_WIN_STUFF
 	m_tb_button->progress()->reset();
 #else
 	m_value = m_minimum;
@@ -91,7 +91,7 @@ void progress_indicator::reset()
 
 void progress_indicator::signal_failure()
 {
-#ifdef _WIN32
+#ifdef HAS_QT_WIN_STUFF
 	m_tb_button->progress()->stop();
 #elif HAVE_QTDBUS
 	update_progress(0, false, true);
diff --git a/rpcs3/rpcs3qt/progress_indicator.h b/rpcs3/rpcs3qt/progress_indicator.h
index 1eccced1d..9e27f40ab 100644
--- a/rpcs3/rpcs3qt/progress_indicator.h
+++ b/rpcs3/rpcs3qt/progress_indicator.h
@@ -2,7 +2,7 @@
 
 #include <QWindow>
 
-#ifdef _WIN32
+#ifdef HAS_QT_WIN_STUFF
 #include <QWinTaskbarButton>
 #endif
 
@@ -23,7 +23,7 @@ public:
 
 private:
 
-#ifdef _WIN32
+#ifdef HAS_QT_WIN_STUFF
 	std::unique_ptr<QWinTaskbarButton> m_tb_button;
 #else
 	int m_value = 0;
diff --git a/rpcs3/rpcs3qt/qt_camera_error_handler.cpp b/rpcs3/rpcs3qt/qt_camera_error_handler.cpp
index 495384bc0..967638273 100644
--- a/rpcs3/rpcs3qt/qt_camera_error_handler.cpp
+++ b/rpcs3/rpcs3qt/qt_camera_error_handler.cpp
@@ -3,40 +3,14 @@
 
 LOG_CHANNEL(camera_log, "Camera");
 
-template <>
-void fmt_class_string<QCamera::Status>::format(std::string& out, u64 arg)
-{
-	format_enum(out, arg, [](QCamera::Status value)
-	{
-		switch (value)
-		{
-		case QCamera::Status::UnavailableStatus: return "Unavailable";
-		case QCamera::Status::UnloadedStatus: return "Unloaded";
-		case QCamera::Status::LoadingStatus: return "Loading";
-		case QCamera::Status::UnloadingStatus: return "Unloading";
-		case QCamera::Status::LoadedStatus: return "Loaded";
-		case QCamera::Status::StandbyStatus: return "Standby";
-		case QCamera::Status::StartingStatus: return "Starting";
-		case QCamera::Status::StoppingStatus: return "Stopping";
-		case QCamera::Status::ActiveStatus: return "Active";
-		}
-
-		return unknown;
-	});
-}
-
-qt_camera_error_handler::qt_camera_error_handler(std::shared_ptr<QCamera> camera, std::function<void(QCamera::Status)> status_callback)
+qt_camera_error_handler::qt_camera_error_handler(std::shared_ptr<QCamera> camera, std::function<void(bool)> status_callback)
 	: m_camera(std::move(camera))
 	, m_status_callback(std::move(status_callback))
 {
 	if (m_camera)
 	{
-		connect(m_camera.get(), QOverload<QMultimedia::AvailabilityStatus>::of(&QCamera::availabilityChanged), this, &qt_camera_error_handler::handle_availability);
-		connect(m_camera.get(), &QCamera::stateChanged, this, &qt_camera_error_handler::handle_camera_state);
-		connect(m_camera.get(), &QCamera::statusChanged, this, &qt_camera_error_handler::handle_camera_status);
+		connect(m_camera.get(), &QCamera::activeChanged, this, &qt_camera_error_handler::handle_camera_active);
 		connect(m_camera.get(), &QCamera::errorOccurred, this, &qt_camera_error_handler::handle_camera_error);
-		connect(m_camera.get(), &QCamera::captureModeChanged, this, &qt_camera_error_handler::handle_capture_modes);
-		connect(m_camera.get(), QOverload<QCamera::LockStatus, QCamera::LockChangeReason>::of(&QCamera::lockStatusChanged), this, &qt_camera_error_handler::handle_lock_status);
 	}
 }
 
@@ -44,37 +18,17 @@ qt_camera_error_handler::~qt_camera_error_handler()
 {
 }
 
-void qt_camera_error_handler::handle_availability(QMultimedia::AvailabilityStatus availability)
+void qt_camera_error_handler::handle_camera_active(bool is_active)
 {
-	camera_log.notice("Camera availability changed to %d", static_cast<int>(availability));
-}
-
-void qt_camera_error_handler::handle_camera_state(QCamera::State state)
-{
-	camera_log.notice("Camera state changed to %d", static_cast<int>(state));
-}
-
-void qt_camera_error_handler::handle_camera_status(QCamera::Status status)
-{
-	camera_log.notice("Camera status changed to %s", status);
+	camera_log.notice("Camera active status changed to %d", is_active);
 
 	if (m_status_callback)
 	{
-		m_status_callback(status);
+		m_status_callback(is_active);
 	}
 }
 
-void qt_camera_error_handler::handle_lock_status(QCamera::LockStatus status, QCamera::LockChangeReason reason)
-{
-	camera_log.notice("Camera lock status changed to %d (reason=%d)", static_cast<int>(status), static_cast<int>(reason));
-}
-
-void qt_camera_error_handler::handle_capture_modes(QCamera::CaptureModes capture_modes)
-{
-	camera_log.notice("Camera capture modes changed to %d", static_cast<int>(capture_modes));
-}
-
-void qt_camera_error_handler::handle_camera_error(QCamera::Error error)
+void qt_camera_error_handler::handle_camera_error(QCamera::Error error, const QString& errorString)
 {
-	camera_log.error("Error event: \"%s\" (error=%d)", m_camera ? m_camera->errorString().toStdString() : "", static_cast<int>(error));
+	camera_log.error("Error event: \"%s\" (error=%d)", m_camera ? errorString.toStdString() : "", static_cast<int>(error));
 }
diff --git a/rpcs3/rpcs3qt/qt_camera_error_handler.h b/rpcs3/rpcs3qt/qt_camera_error_handler.h
index cf97a120b..a2d2c81ba 100644
--- a/rpcs3/rpcs3qt/qt_camera_error_handler.h
+++ b/rpcs3/rpcs3qt/qt_camera_error_handler.h
@@ -8,18 +8,14 @@ class qt_camera_error_handler : public QObject
 	Q_OBJECT
 
 public:
-	qt_camera_error_handler(std::shared_ptr<QCamera> camera, std::function<void(QCamera::Status)> status_callback);
+	qt_camera_error_handler(std::shared_ptr<QCamera> camera, std::function<void(bool)> status_callback);
 	virtual ~qt_camera_error_handler();
 
 private Q_SLOTS:
-	void handle_availability(QMultimedia::AvailabilityStatus availability);
-	void handle_lock_status(QCamera::LockStatus, QCamera::LockChangeReason);
-	void handle_capture_modes(QCamera::CaptureModes capture_modes);
-	void handle_camera_state(QCamera::State state);
-	void handle_camera_status(QCamera::Status status);
-	void handle_camera_error(QCamera::Error error);
+	void handle_camera_active(bool is_active);
+	void handle_camera_error(QCamera::Error error, const QString& errorString);
 
 private:
 	std::shared_ptr<QCamera> m_camera;
-	std::function<void(QCamera::Status)> m_status_callback = nullptr;
+	std::function<void(bool)> m_status_callback = nullptr;
 };
diff --git a/rpcs3/rpcs3qt/qt_camera_handler.cpp b/rpcs3/rpcs3qt/qt_camera_handler.cpp
index cbb6f7ed4..a8f775cdf 100644
--- a/rpcs3/rpcs3qt/qt_camera_handler.cpp
+++ b/rpcs3/rpcs3qt/qt_camera_handler.cpp
@@ -5,17 +5,16 @@
 #include "Emu/Io/camera_config.h"
 #include "Emu/Cell/lv2/sys_event.h"
 
-#include <QMediaService>
-#include <QCameraInfo>
+#include <QMediaDevices>
 
 LOG_CHANNEL(camera_log, "Camera");
 
 qt_camera_handler::qt_camera_handler() : camera_handler_base()
 {
 	// List available cameras
-	for (const QCameraInfo& cameraInfo : QCameraInfo::availableCameras())
+	for (const QCameraDevice& camera_device : QMediaDevices::videoInputs())
 	{
-		camera_log.success("Found camera: name=%s, description=%s", cameraInfo.deviceName().toStdString(), cameraInfo.description().toStdString());
+		camera_log.success("Found camera: id=%s, description=%s", camera_device.id().toStdString(), camera_device.description().toStdString());
 	}
 
 	if (!g_cfg_camera.load())
@@ -29,60 +28,53 @@ qt_camera_handler::~qt_camera_handler()
 	Emu.BlockingCallFromMainThread([&]()
 	{
 		close_camera();
-		m_surface.reset();
-		m_camera.reset();
-		m_error_handler.reset();
+		reset();
 	});
 }
 
-void qt_camera_handler::set_camera(const QCameraInfo& camera_info)
+void qt_camera_handler::reset()
+{
+	m_camera.reset();
+	m_error_handler.reset();
+	m_video_sink.reset();
+	m_media_capture_session.reset();
+}
+
+void qt_camera_handler::set_camera(const QCameraDevice& camera_info)
 {
 	if (camera_info.isNull())
 	{
-		m_surface.reset();
-		m_camera.reset();
-		m_error_handler.reset();
+		reset();
 		return;
 	}
 
 	// Determine if the camera is front facing, in which case we will need to flip the image horizontally.
-	const bool front_facing = camera_info.position() == QCamera::Position::FrontFace;
+	const bool front_facing = camera_info.position() == QCameraDevice::Position::FrontFace;
 
-	camera_log.success("Using camera: name=\"%s\", description=\"%s\", front_facing=%d", camera_info.deviceName().toStdString(), camera_info.description().toStdString(), front_facing);
+	camera_log.success("Using camera: id=\"%s\", description=\"%s\", front_facing=%d", camera_info.id().toStdString(), camera_info.description().toStdString(), front_facing);
 
 	// Create camera and video surface
-	m_surface.reset(new qt_camera_video_surface(front_facing, nullptr));
+	m_media_capture_session.reset(new QMediaCaptureSession(nullptr));
+	m_video_sink.reset(new qt_camera_video_sink(front_facing, nullptr));
 	m_camera.reset(new QCamera(camera_info));
 	m_error_handler.reset(new qt_camera_error_handler(m_camera,
-		[this](QCamera::Status status)
+		[this](bool is_active)
 		{
-			switch (status)
+			if (is_active)
 			{
-			case QCamera::UnavailableStatus:
-				m_state = camera_handler_state::not_available;
-				break;
-			case QCamera::UnloadedStatus:
-			case QCamera::UnloadingStatus:
-				m_state = camera_handler_state::closed;
-				break;
-			case QCamera::StandbyStatus:
-			case QCamera::StoppingStatus:
-			case QCamera::LoadedStatus:
-			case QCamera::LoadingStatus:
-				m_state = camera_handler_state::open;
-				break;
-			case QCamera::StartingStatus:
-			case QCamera::ActiveStatus:
 				m_state = camera_handler_state::running;
-				break;
-			default:
-				camera_log.error("Ignoring unknown status %d", static_cast<int>(status));
-				break;
+			}
+			else
+			{
+				m_state = camera_handler_state::closed;
 			}
 		}));
 
-	// Set view finder and update the settings
-	m_camera->setViewfinder(m_surface.get());
+	// Setup video sink
+	m_media_capture_session->setCamera(m_camera.get());
+	m_media_capture_session->setVideoSink(m_video_sink.get());
+
+	// Update the settings
 	update_camera_settings();
 }
 
@@ -94,25 +86,25 @@ void qt_camera_handler::open_camera()
 		m_camera_id != camera_id)
 	{
 		camera_log.notice("Switching camera from %s to %s", m_camera_id, camera_id);
-		camera_log.notice("Unloading old camera...");
-		if (m_camera) m_camera->unload();
+		camera_log.notice("Stopping old camera...");
+		if (m_camera) m_camera->stop();
 		m_camera_id = camera_id;
 	}
 
-	QCameraInfo selected_camera;
+	QCameraDevice selected_camera{};
 
 	if (m_camera_id == g_cfg.io.camera_id.def)
 	{
-		selected_camera = QCameraInfo::defaultCamera();
+		selected_camera = QMediaDevices::defaultVideoInput();
 	}
 	else if (!m_camera_id.empty())
 	{
 		const QString camera_id = QString::fromStdString(m_camera_id);
-		for (const QCameraInfo& camera_info : QCameraInfo::availableCameras())
+		for (const QCameraDevice& camera_device : QMediaDevices::videoInputs())
 		{
-			if (camera_id == camera_info.deviceName())
+			if (camera_id == camera_device.id())
 			{
-				selected_camera = camera_info;
+				selected_camera = camera_device;
 				break;
 			}
 		}
@@ -124,35 +116,26 @@ void qt_camera_handler::open_camera()
 	{
 		if (m_camera_id.empty()) camera_log.notice("Camera disabled");
 		else camera_log.error("No camera found");
-		m_state = camera_handler_state::not_available;
+		m_state = camera_handler_state::closed;
 		return;
 	}
 
-	if (m_camera->state() != QCamera::State::UnloadedState)
+	if (m_camera->isActive())
 	{
-		camera_log.notice("Camera already loaded");
+		camera_log.notice("Camera already active");
 		return;
 	}
 
-	// Load/open camera
-	m_camera->load();
-
 	// List all supported formats for debugging
-	for (const QCamera::FrameRateRange& frame_rate : m_camera->supportedViewfinderFrameRateRanges())
+	for (const QCameraFormat& format : m_camera->cameraDevice().videoFormats())
 	{
-		camera_log.notice("Supported frame rate range: %f-%f", frame_rate.minimumFrameRate, frame_rate.maximumFrameRate);
-	}
-	for (const QVideoFrame::PixelFormat& pixel_format : m_camera->supportedViewfinderPixelFormats())
-	{
-		camera_log.notice("Supported pixel format: %d", static_cast<int>(pixel_format));
-	}
-	for (const QSize& resolution : m_camera->supportedViewfinderResolutions())
-	{
-		camera_log.notice("Supported resolution: %dx%d", resolution.width(), resolution.height());
+		camera_log.notice("Supported format: pixelformat=%s, resolution=%dx%d framerate=%f-%f", format.pixelFormat(), format.resolution().width(), format.resolution().height(), format.minFrameRate(), format.maxFrameRate());
 	}
 
 	// Update camera and view finder settings
 	update_camera_settings();
+
+	m_state = camera_handler_state::open;
 }
 
 void qt_camera_handler::close_camera()
@@ -163,18 +146,12 @@ void qt_camera_handler::close_camera()
 	{
 		if (m_camera_id.empty()) camera_log.notice("Camera disabled");
 		else camera_log.error("No camera found");
-		m_state = camera_handler_state::not_available;
-		return;
-	}
-
-	if (m_camera->state() == QCamera::State::UnloadedState)
-	{
-		camera_log.notice("Camera already unloaded");
+		m_state = camera_handler_state::closed;
 		return;
 	}
 
 	// Unload/close camera
-	m_camera->unload();
+	m_camera->stop();
 }
 
 void qt_camera_handler::start_camera()
@@ -185,22 +162,16 @@ void qt_camera_handler::start_camera()
 	{
 		if (m_camera_id.empty()) camera_log.notice("Camera disabled");
 		else camera_log.error("No camera found");
-		m_state = camera_handler_state::not_available;
+		m_state = camera_handler_state::closed;
 		return;
 	}
 
-	if (m_camera->state() == QCamera::State::ActiveState)
+	if (m_camera->isActive())
 	{
 		camera_log.notice("Camera already started");
 		return;
 	}
 
-	if (m_camera->state() == QCamera::State::UnloadedState)
-	{
-		camera_log.notice("Camera not open");
-		open_camera();
-	}
-
 	// Start camera. We will start receiving frames now.
 	m_camera->start();
 }
@@ -213,11 +184,11 @@ void qt_camera_handler::stop_camera()
 	{
 		if (m_camera_id.empty()) camera_log.notice("Camera disabled");
 		else camera_log.error("No camera found");
-		m_state = camera_handler_state::not_available;
+		m_state = camera_handler_state::closed;
 		return;
 	}
 
-	if (m_camera->state() == QCamera::State::LoadedState)
+	if (!m_camera->isActive())
 	{
 		camera_log.notice("Camera already stopped");
 		return;
@@ -232,9 +203,9 @@ void qt_camera_handler::set_format(s32 format, u32 bytesize)
 	m_format = format;
 	m_bytesize = bytesize;
 
-	if (m_surface)
+	if (m_video_sink)
 	{
-		m_surface->set_format(m_format, m_bytesize);
+		m_video_sink->set_format(m_format, m_bytesize);
 	}
 }
 
@@ -248,9 +219,9 @@ void qt_camera_handler::set_resolution(u32 width, u32 height)
 	m_width = width;
 	m_height = height;
 
-	if (m_surface)
+	if (m_video_sink)
 	{
-		m_surface->set_resolution(m_width, m_height);
+		m_video_sink->set_resolution(m_width, m_height);
 	}
 }
 
@@ -258,15 +229,15 @@ void qt_camera_handler::set_mirrored(bool mirrored)
 {
 	m_mirrored = mirrored;
 
-	if (m_surface)
+	if (m_video_sink)
 	{
-		m_surface->set_mirrored(m_mirrored);
+		m_video_sink->set_mirrored(m_mirrored);
 	}
 }
 
 u64 qt_camera_handler::frame_number() const
 {
-	return m_surface ? m_surface->frame_number() : 0;
+	return m_video_sink ? m_video_sink->frame_number() : 0;
 }
 
 camera_handler_base::camera_handler_state qt_camera_handler::get_image(u8* buf, u64 size, u32& width, u32& height, u64& frame_number, u64& bytes_read)
@@ -280,22 +251,22 @@ camera_handler_base::camera_handler_state qt_camera_handler::get_image(u8* buf,
 		m_camera_id != camera_id)
 	{
 		camera_log.notice("Switching cameras");
-		m_state = camera_handler_state::not_available;
-		return camera_handler_state::not_available;
+		m_state = camera_handler_state::closed;
+		return camera_handler_state::closed;
 	}
 
 	if (m_camera_id.empty())
 	{
 		camera_log.notice("Camera disabled");
-		m_state = camera_handler_state::not_available;
-		return camera_handler_state::not_available;
+		m_state = camera_handler_state::closed;
+		return camera_handler_state::closed;
 	}
 
-	if (!m_camera || !m_surface)
+	if (!m_camera || !m_video_sink)
 	{
 		camera_log.fatal("Error: camera invalid");
-		m_state = camera_handler_state::not_available;
-		return camera_handler_state::not_available;
+		m_state = camera_handler_state::closed;
+		return camera_handler_state::closed;
 	}
 
 	// Backup current state. State may change through events.
@@ -304,7 +275,7 @@ camera_handler_base::camera_handler_state qt_camera_handler::get_image(u8* buf,
 	if (current_state == camera_handler_state::running)
 	{
 		// Copy latest image into out buffer.
-		m_surface->get_image(buf, size, width, height, frame_number, bytes_read);
+		m_video_sink->get_image(buf, size, width, height, frame_number, bytes_read);
 	}
 	else
 	{
@@ -317,7 +288,7 @@ camera_handler_base::camera_handler_state qt_camera_handler::get_image(u8* buf,
 void qt_camera_handler::update_camera_settings()
 {
 	// Update camera if possible. We can only do this if it is already loaded.
-	if (m_camera && m_camera->state() != QCamera::State::UnloadedState)
+	if (m_camera && m_camera->isAvailable())
 	{
 		// Load selected settings from config file
 		bool success = false;
@@ -327,32 +298,23 @@ void qt_camera_handler::update_camera_settings()
 		{
 			camera_log.notice("Found config entry for camera \"%s\"", m_camera_id);
 
-			QCameraViewfinderSettings setting;
-			setting.setResolution(cfg_setting.width, cfg_setting.height);
-			setting.setMinimumFrameRate(cfg_setting.min_fps);
-			setting.setMaximumFrameRate(cfg_setting.max_fps);
-			setting.setPixelFormat(static_cast<QVideoFrame::PixelFormat>(cfg_setting.format));
-			setting.setPixelAspectRatio(cfg_setting.pixel_aspect_width, cfg_setting.pixel_aspect_height);
-
 			// List all available settings and choose the proper value if possible.
 			const double epsilon = 0.001;
 			success = false;
-			for (const QCameraViewfinderSettings& supported_setting : m_camera->supportedViewfinderSettings(setting))
+			for (const QCameraFormat& supported_setting : m_camera->cameraDevice().videoFormats())
 			{
-				if (supported_setting.resolution().width() == setting.resolution().width() &&
-					supported_setting.resolution().height() == setting.resolution().height() &&
-					supported_setting.minimumFrameRate() >= (setting.minimumFrameRate() - epsilon) &&
-					supported_setting.minimumFrameRate() <= (setting.minimumFrameRate() + epsilon) &&
-					supported_setting.maximumFrameRate() >= (setting.maximumFrameRate() - epsilon) &&
-					supported_setting.maximumFrameRate() <= (setting.maximumFrameRate() + epsilon) &&
-					supported_setting.pixelFormat() == setting.pixelFormat() &&
-					supported_setting.pixelAspectRatio().width() == setting.pixelAspectRatio().width() &&
-					supported_setting.pixelAspectRatio().height() == setting.pixelAspectRatio().height())
+				if (supported_setting.resolution().width() == cfg_setting.width &&
+					supported_setting.resolution().height() == cfg_setting.height &&
+					supported_setting.minFrameRate() >= (cfg_setting.min_fps - epsilon) &&
+					supported_setting.minFrameRate() <= (cfg_setting.min_fps + epsilon) &&
+					supported_setting.maxFrameRate() >= (cfg_setting.max_fps - epsilon) &&
+					supported_setting.maxFrameRate() <= (cfg_setting.max_fps + epsilon) &&
+					supported_setting.pixelFormat() == static_cast<QVideoFrameFormat::PixelFormat>(cfg_setting.format))
 				{
 					// Apply settings.
 					camera_log.notice("Setting view finder settings: frame_rate=%f, width=%d, height=%d, pixel_format=%s",
-						supported_setting.maximumFrameRate(), supported_setting.resolution().width(), supported_setting.resolution().height(), supported_setting.pixelFormat());
-					m_camera->setViewfinderSettings(supported_setting);
+						supported_setting.maxFrameRate(), supported_setting.resolution().width(), supported_setting.resolution().height(), supported_setting.pixelFormat());
+					m_camera->setCameraFormat(supported_setting);
 					success = true;
 					break;
 				}
@@ -372,10 +334,10 @@ void qt_camera_handler::update_camera_settings()
 	}
 
 	// Update video surface if possible
-	if (m_surface)
+	if (m_video_sink)
 	{
-		m_surface->set_resolution(m_width, m_height);
-		m_surface->set_format(m_format, m_bytesize);
-		m_surface->set_mirrored(m_mirrored);
+		m_video_sink->set_resolution(m_width, m_height);
+		m_video_sink->set_format(m_format, m_bytesize);
+		m_video_sink->set_mirrored(m_mirrored);
 	}
 }
diff --git a/rpcs3/rpcs3qt/qt_camera_handler.h b/rpcs3/rpcs3qt/qt_camera_handler.h
index 0b4f70735..4cf1f01a7 100644
--- a/rpcs3/rpcs3qt/qt_camera_handler.h
+++ b/rpcs3/rpcs3qt/qt_camera_handler.h
@@ -1,12 +1,12 @@
 #pragma once
 
 #include "Emu/Io/camera_handler_base.h"
-#include "qt_camera_video_surface.h"
+#include "qt_camera_video_sink.h"
 #include "qt_camera_error_handler.h"
 
 #include <QCamera>
-#include <QCameraImageCapture>
-#include <QAbstractVideoSurface>
+#include <QMediaCaptureSession>
+#include <QVideoSink>
 
 class qt_camera_handler final : public camera_handler_base
 {
@@ -14,7 +14,7 @@ public:
 	qt_camera_handler();
 	virtual ~qt_camera_handler();
 
-	void set_camera(const QCameraInfo& camera_info);
+	void set_camera(const QCameraDevice& camera_info);
 
 	void open_camera() override;
 	void close_camera() override;
@@ -28,10 +28,12 @@ public:
 	camera_handler_state get_image(u8* buf, u64 size, u32& width, u32& height, u64& frame_number, u64& bytes_read) override;
 
 private:
+	void reset();
 	void update_camera_settings();
 
 	std::string m_camera_id;
 	std::shared_ptr<QCamera> m_camera;
-	std::unique_ptr<qt_camera_video_surface> m_surface;
+	std::unique_ptr<QMediaCaptureSession> m_media_capture_session;
+	std::unique_ptr<qt_camera_video_sink> m_video_sink;
 	std::unique_ptr<qt_camera_error_handler> m_error_handler;
 };
diff --git a/rpcs3/rpcs3qt/qt_camera_video_surface.cpp b/rpcs3/rpcs3qt/qt_camera_video_sink.cpp
similarity index 78%
rename from rpcs3/rpcs3qt/qt_camera_video_surface.cpp
rename to rpcs3/rpcs3qt/qt_camera_video_sink.cpp
index 459c632d0..4f19155be 100644
--- a/rpcs3/rpcs3qt/qt_camera_video_surface.cpp
+++ b/rpcs3/rpcs3qt/qt_camera_video_sink.cpp
@@ -1,5 +1,5 @@
 #include "stdafx.h"
-#include "qt_camera_video_surface.h"
+#include "qt_camera_video_sink.h"
 
 #include "Emu/Cell/Modules/cellCamera.h"
 #include "Emu/system_config.h"
@@ -8,12 +8,13 @@
 
 LOG_CHANNEL(camera_log, "Camera");
 
-qt_camera_video_surface::qt_camera_video_surface(bool front_facing, QObject *parent)
-	: QAbstractVideoSurface(parent), m_front_facing(front_facing)
+qt_camera_video_sink::qt_camera_video_sink(bool front_facing, QObject *parent)
+	: QVideoSink(parent), m_front_facing(front_facing)
 {
+	connect(this, &QVideoSink::videoFrameChanged, this, &qt_camera_video_sink::present);
 }
 
-qt_camera_video_surface::~qt_camera_video_surface()
+qt_camera_video_sink::~qt_camera_video_sink()
 {
 	std::lock_guard lock(m_mutex);
 
@@ -28,51 +29,7 @@ qt_camera_video_surface::~qt_camera_video_surface()
 	}
 }
 
-QList<QVideoFrame::PixelFormat> qt_camera_video_surface::supportedPixelFormats(QAbstractVideoBuffer::HandleType type) const
-{
-	Q_UNUSED(type)
-
-	// Support all cameras
-	QList<QVideoFrame::PixelFormat> result;
-	result
-		<< QVideoFrame::Format_ARGB32
-		<< QVideoFrame::Format_ARGB32_Premultiplied
-		<< QVideoFrame::Format_RGB32
-		<< QVideoFrame::Format_RGB24
-		<< QVideoFrame::Format_RGB565
-		<< QVideoFrame::Format_RGB555
-		<< QVideoFrame::Format_ARGB8565_Premultiplied
-		<< QVideoFrame::Format_BGRA32
-		<< QVideoFrame::Format_BGRA32_Premultiplied
-		<< QVideoFrame::Format_BGR32
-		<< QVideoFrame::Format_BGR24
-		<< QVideoFrame::Format_BGR565
-		<< QVideoFrame::Format_BGR555
-		<< QVideoFrame::Format_BGRA5658_Premultiplied
-		<< QVideoFrame::Format_AYUV444
-		<< QVideoFrame::Format_AYUV444_Premultiplied
-		<< QVideoFrame::Format_YUV444
-		<< QVideoFrame::Format_YUV420P
-		<< QVideoFrame::Format_YV12
-		<< QVideoFrame::Format_UYVY
-		<< QVideoFrame::Format_YUYV
-		<< QVideoFrame::Format_NV12
-		<< QVideoFrame::Format_NV21
-		<< QVideoFrame::Format_IMC1
-		<< QVideoFrame::Format_IMC2
-		<< QVideoFrame::Format_IMC3
-		<< QVideoFrame::Format_IMC4
-		<< QVideoFrame::Format_Y8
-		<< QVideoFrame::Format_Y16
-		<< QVideoFrame::Format_Jpeg
-		<< QVideoFrame::Format_CameraRaw
-		<< QVideoFrame::Format_AdobeDng
-		<< QVideoFrame::Format_ABGR32
-		<< QVideoFrame::Format_YUV422P;
-	return result;
-}
-
-bool qt_camera_video_surface::present(const QVideoFrame& frame)
+bool qt_camera_video_sink::present(const QVideoFrame& frame)
 {
 	if (!frame.isValid())
 	{
@@ -82,18 +39,18 @@ bool qt_camera_video_surface::present(const QVideoFrame& frame)
 
 	// Get video image. Map frame for faster read operations.
 	QVideoFrame tmp(frame);
-	if (!tmp.map(QAbstractVideoBuffer::ReadOnly))
+	if (!tmp.map(QVideoFrame::ReadOnly))
 	{
 		camera_log.error("Failed to map video frame");
 		return false;
 	}
 
 	// Get image. This usually also converts the image to ARGB32.
-	QImage image = frame.image();
+	QImage image = frame.toImage();
 
 	if (image.isNull())
 	{
-		camera_log.warning("Image is invalid: pixel_format=%s, format=%d", tmp.pixelFormat(), static_cast<int>(QVideoFrame::imageFormatFromPixelFormat(tmp.pixelFormat())));
+		camera_log.warning("Image is invalid: pixel_format=%s, format=%d", tmp.pixelFormat(), static_cast<int>(QVideoFrameFormat::imageFormatFromPixelFormat(tmp.pixelFormat())));
 	}
 	else
 	{
@@ -293,7 +250,7 @@ bool qt_camera_video_surface::present(const QVideoFrame& frame)
 	return true;
 }
 
-void qt_camera_video_surface::set_format(s32 format, u32 bytesize)
+void qt_camera_video_sink::set_format(s32 format, u32 bytesize)
 {
 	camera_log.notice("Setting format: format=%d, bytesize=%d", format, bytesize);
 
@@ -301,7 +258,7 @@ void qt_camera_video_surface::set_format(s32 format, u32 bytesize)
 	m_bytesize = bytesize;
 }
 
-void qt_camera_video_surface::set_resolution(u32 width, u32 height)
+void qt_camera_video_sink::set_resolution(u32 width, u32 height)
 {
 	camera_log.notice("Setting resolution: width=%d, height=%d", width, height);
 
@@ -309,19 +266,19 @@ void qt_camera_video_surface::set_resolution(u32 width, u32 height)
 	m_height = height;
 }
 
-void qt_camera_video_surface::set_mirrored(bool mirrored)
+void qt_camera_video_sink::set_mirrored(bool mirrored)
 {
 	camera_log.notice("Setting mirrored: mirrored=%d", mirrored);
 
 	m_mirrored = mirrored;
 }
 
-u64 qt_camera_video_surface::frame_number() const
+u64 qt_camera_video_sink::frame_number() const
 {
 	return m_frame_number.load();
 }
 
-void qt_camera_video_surface::get_image(u8* buf, u64 size, u32& width, u32& height, u64& frame_number, u64& bytes_read)
+void qt_camera_video_sink::get_image(u8* buf, u64 size, u32& width, u32& height, u64& frame_number, u64& bytes_read)
 {
 	// Lock read buffer
 	std::lock_guard lock(m_mutex);
@@ -348,7 +305,7 @@ void qt_camera_video_surface::get_image(u8* buf, u64 size, u32& width, u32& heig
 	}
 }
 
-u32 qt_camera_video_surface::read_index() const
+u32 qt_camera_video_sink::read_index() const
 {
 	// The read buffer index cannot be the same as the write index
 	return (m_write_index + 1u) % ::narrow<u32>(m_image_buffer.size());
diff --git a/rpcs3/rpcs3qt/qt_camera_video_surface.h b/rpcs3/rpcs3qt/qt_camera_video_sink.h
similarity index 66%
rename from rpcs3/rpcs3qt/qt_camera_video_surface.h
rename to rpcs3/rpcs3qt/qt_camera_video_sink.h
index 4cd42a4cd..3385a5048 100644
--- a/rpcs3/rpcs3qt/qt_camera_video_surface.h
+++ b/rpcs3/rpcs3qt/qt_camera_video_sink.h
@@ -1,18 +1,18 @@
 #pragma once
 
-#include <QAbstractVideoSurface>
+#include <QVideoFrame>
+#include <QVideoSink>
 #include <QImage>
 
 #include <array>
 
-class qt_camera_video_surface final : public QAbstractVideoSurface
+class qt_camera_video_sink final : public QVideoSink
 {
 public:
-	qt_camera_video_surface(bool front_facing, QObject *parent = nullptr);
-	virtual ~qt_camera_video_surface();
+	qt_camera_video_sink(bool front_facing, QObject *parent = nullptr);
+	virtual ~qt_camera_video_sink();
 
-	QList<QVideoFrame::PixelFormat> supportedPixelFormats(QAbstractVideoBuffer::HandleType type = QAbstractVideoBuffer::NoHandle) const override;
-	bool present(const QVideoFrame& frame) override;
+	bool present(const QVideoFrame& frame);
 
 	void set_format(s32 format, u32 bytesize);
 	void set_resolution(u32 width, u32 height);
diff --git a/rpcs3/rpcs3qt/qt_music_error_handler.cpp b/rpcs3/rpcs3qt/qt_music_error_handler.cpp
index aa5af7af8..9f79dcaa7 100644
--- a/rpcs3/rpcs3qt/qt_music_error_handler.cpp
+++ b/rpcs3/rpcs3qt/qt_music_error_handler.cpp
@@ -15,8 +15,6 @@ void fmt_class_string<QMediaPlayer::Error>::format(std::string& out, u64 arg)
 		case QMediaPlayer::Error::FormatError: return "FormatError";
 		case QMediaPlayer::Error::NetworkError: return "NetworkError";
 		case QMediaPlayer::Error::AccessDeniedError: return "AccessDeniedError";
-		case QMediaPlayer::Error::ServiceMissingError: return "ServiceMissingError";
-		case QMediaPlayer::Error::MediaIsPlaylist: return "MediaIsPlaylist";
 		}
 
 		return unknown;
@@ -30,7 +28,6 @@ void fmt_class_string<QMediaPlayer::MediaStatus>::format(std::string& out, u64 a
 	{
 		switch (value)
 		{
-		case QMediaPlayer::MediaStatus::UnknownMediaStatus: return "UnknownMediaStatus";
 		case QMediaPlayer::MediaStatus::NoMedia: return "NoMedia";
 		case QMediaPlayer::MediaStatus::LoadingMedia: return "LoadingMedia";
 		case QMediaPlayer::MediaStatus::LoadedMedia: return "LoadedMedia";
@@ -46,15 +43,15 @@ void fmt_class_string<QMediaPlayer::MediaStatus>::format(std::string& out, u64 a
 }
 
 template <>
-void fmt_class_string<QMediaPlayer::State>::format(std::string& out, u64 arg)
+void fmt_class_string<QMediaPlayer::PlaybackState>::format(std::string& out, u64 arg)
 {
-	format_enum(out, arg, [](QMediaPlayer::State value)
+	format_enum(out, arg, [](QMediaPlayer::PlaybackState value)
 	{
 		switch (value)
 		{
-		case QMediaPlayer::State::StoppedState: return "StoppedState";
-		case QMediaPlayer::State::PlayingState: return "PlayingState";
-		case QMediaPlayer::State::PausedState: return "PausedState";
+		case QMediaPlayer::PlaybackState::StoppedState: return "StoppedState";
+		case QMediaPlayer::PlaybackState::PlayingState: return "PlayingState";
+		case QMediaPlayer::PlaybackState::PausedState: return "PausedState";
 		}
 
 		return unknown;
@@ -68,8 +65,8 @@ qt_music_error_handler::qt_music_error_handler(std::shared_ptr<QMediaPlayer> med
 	if (m_media_player)
 	{
 		connect(m_media_player.get(), &QMediaPlayer::mediaStatusChanged, this, &qt_music_error_handler::handle_media_status);
-		connect(m_media_player.get(), &QMediaPlayer::stateChanged, this, &qt_music_error_handler::handle_music_state);
-		connect(m_media_player.get(), QOverload<QMediaPlayer::Error>::of(&QMediaPlayer::error), this, &qt_music_error_handler::handle_music_error);
+		connect(m_media_player.get(), &QMediaPlayer::playbackStateChanged, this, &qt_music_error_handler::handle_music_state);
+		connect(m_media_player.get(), &QMediaPlayer::errorOccurred, this, &qt_music_error_handler::handle_music_error);
 	}
 }
 
@@ -87,12 +84,11 @@ void qt_music_error_handler::handle_media_status(QMediaPlayer::MediaStatus statu
 	}
 }
 
-void qt_music_error_handler::handle_music_state(QMediaPlayer::State state)
+void qt_music_error_handler::handle_music_state(QMediaPlayer::PlaybackState state)
 {
 	music_log.notice("New playback state: %s (state=%d)", state, static_cast<int>(state));
 }
-
-void qt_music_error_handler::handle_music_error(QMediaPlayer::Error error)
+void qt_music_error_handler::handle_music_error(QMediaPlayer::Error error, const QString& errorString)
 {
-	music_log.error("Error event: \"%s\" (error=%s)", m_media_player ? m_media_player->errorString().toStdString() : "", error);
+	music_log.error("Error event: \"%s\" (error=%s)", m_media_player ? errorString.toStdString() : "", error);
 }
diff --git a/rpcs3/rpcs3qt/qt_music_error_handler.h b/rpcs3/rpcs3qt/qt_music_error_handler.h
index 11c5ff3fb..7d19c22d5 100644
--- a/rpcs3/rpcs3qt/qt_music_error_handler.h
+++ b/rpcs3/rpcs3qt/qt_music_error_handler.h
@@ -13,8 +13,8 @@ public:
 
 private Q_SLOTS:
 	void handle_media_status(QMediaPlayer::MediaStatus status);
-	void handle_music_state(QMediaPlayer::State state);
-	void handle_music_error(QMediaPlayer::Error error);
+	void handle_music_state(QMediaPlayer::PlaybackState state);
+	void handle_music_error(QMediaPlayer::Error error, const QString& errorString);
 
 private:
 	std::shared_ptr<QMediaPlayer> m_media_player;
diff --git a/rpcs3/rpcs3qt/qt_music_handler.cpp b/rpcs3/rpcs3qt/qt_music_handler.cpp
index 39c40a591..d92d379cd 100644
--- a/rpcs3/rpcs3qt/qt_music_handler.cpp
+++ b/rpcs3/rpcs3qt/qt_music_handler.cpp
@@ -4,6 +4,7 @@
 #include "Utilities/Thread.h"
 #include "util/logs.hpp"
 
+#include <QAudioOutput>
 #include <QUrl>
 
 LOG_CHANNEL(music_log, "Music");
@@ -13,7 +14,7 @@ qt_music_handler::qt_music_handler()
 	music_log.notice("Constructing Qt music handler...");
 
 	m_media_player = std::make_shared<QMediaPlayer>();
-	m_media_player->setAudioRole(QAudio::Role::MusicRole);
+	m_media_player->setAudioOutput(new QAudioOutput());
 
 	m_error_handler = std::make_unique<qt_music_error_handler>(m_media_player,
 		[this](QMediaPlayer::MediaStatus status)
@@ -25,7 +26,6 @@ qt_music_handler::qt_music_handler()
 
 			switch (status)
 			{
-			case QMediaPlayer::MediaStatus::UnknownMediaStatus:
 			case QMediaPlayer::MediaStatus::NoMedia:
 			case QMediaPlayer::MediaStatus::LoadingMedia:
 			case QMediaPlayer::MediaStatus::LoadedMedia:
@@ -90,7 +90,7 @@ void qt_music_handler::play(const std::string& path)
 		if (m_path != path)
 		{
 			m_path = path;
-			m_media_player->setMedia(QUrl(QString::fromStdString(path)));
+			m_media_player->setSource(QUrl::fromLocalFile(QString::fromStdString(path)));
 		}
 
 		music_log.notice("Playing music: %s", path);
@@ -110,7 +110,7 @@ void qt_music_handler::fast_forward(const std::string& path)
 		if (m_path != path)
 		{
 			m_path = path;
-			m_media_player->setMedia(QUrl(QString::fromStdString(path)));
+			m_media_player->setSource(QUrl::fromLocalFile(QString::fromStdString(path)));
 		}
 
 		music_log.notice("Fast-forwarding music...");
@@ -130,7 +130,7 @@ void qt_music_handler::fast_reverse(const std::string& path)
 		if (m_path != path)
 		{
 			m_path = path;
-			m_media_player->setMedia(QUrl(QString::fromStdString(path)));
+			m_media_player->setSource(QUrl::fromLocalFile(QString::fromStdString(path)));
 		}
 
 		music_log.notice("Fast-reversing music...");
@@ -149,7 +149,7 @@ void qt_music_handler::set_volume(f32 volume)
 	{
 		const int new_volume = std::max<int>(0, std::min<int>(volume * 100, 100));
 		music_log.notice("Setting volume to %d%%", new_volume);
-		m_media_player->setVolume(new_volume);
+		m_media_player->audioOutput()->setVolume(new_volume);
 	});
 }
 
@@ -160,9 +160,8 @@ f32 qt_music_handler::get_volume() const
 
 	Emu.BlockingCallFromMainThread([&volume, this]()
 	{
-		const int current_volume = std::max(0, std::min(m_media_player->volume(), 100));
-		music_log.notice("Getting volume: %d%%", current_volume);
-		volume = current_volume / 100.0f;
+		volume = std::max(0.f, std::min(m_media_player->audioOutput()->volume(), 1.f));
+		music_log.notice("Getting volume: %d%%", volume);
 	});
 
 	return volume;
diff --git a/rpcs3/rpcs3qt/qt_utils.h b/rpcs3/rpcs3qt/qt_utils.h
index 32312b34a..c238e7b00 100644
--- a/rpcs3/rpcs3qt/qt_utils.h
+++ b/rpcs3/rpcs3qt/qt_utils.h
@@ -133,7 +133,7 @@ namespace gui
 		template <typename T>
 		void stop_future_watcher(QFutureWatcher<T>& watcher, bool cancel, std::shared_ptr<atomic_t<bool>> cancel_flag = nullptr)
 		{
-			if (watcher.isPaused() || watcher.isRunning())
+			if (watcher.isSuspended() || watcher.isRunning())
 			{
 				watcher.resume();
 
diff --git a/rpcs3/rpcs3qt/register_editor_dialog.cpp b/rpcs3/rpcs3qt/register_editor_dialog.cpp
index 01b6ca8f3..8d3cd96f6 100644
--- a/rpcs3/rpcs3qt/register_editor_dialog.cpp
+++ b/rpcs3/rpcs3qt/register_editor_dialog.cpp
@@ -147,7 +147,7 @@ register_editor_dialog::register_editor_dialog(QWidget *parent, CPUDisAsm* _disa
 	connect(button_cancel, &QAbstractButton::clicked, this, &register_editor_dialog::reject);
 	connect(m_register_combo, &QComboBox::currentTextChanged, this, [this](const QString&)
 	{
-		if (const auto qvar = m_register_combo->currentData(); qvar.canConvert(QMetaType::Int))
+		if (const auto qvar = m_register_combo->currentData(); qvar.canConvert<int>())
 		{
 			updateRegister(qvar.toInt());
 		}
diff --git a/rpcs3/rpcs3qt/save_manager_dialog.cpp b/rpcs3/rpcs3qt/save_manager_dialog.cpp
index 07e9a8caf..0a3bdb0d5 100644
--- a/rpcs3/rpcs3qt/save_manager_dialog.cpp
+++ b/rpcs3/rpcs3qt/save_manager_dialog.cpp
@@ -18,7 +18,6 @@
 #include <QMenu>
 #include <QMessageBox>
 #include <QGuiApplication>
-#include <QUrl>
 #include <QDesktopServices>
 #include <QPainter>
 #include <QScreen>
diff --git a/rpcs3/rpcs3qt/settings_dialog.cpp b/rpcs3/rpcs3qt/settings_dialog.cpp
index 5b2e4517b..22b83dccd 100644
--- a/rpcs3/rpcs3qt/settings_dialog.cpp
+++ b/rpcs3/rpcs3qt/settings_dialog.cpp
@@ -1,5 +1,6 @@
 #include <QButtonGroup>
-#include <QCameraInfo>
+#include <QCameraDevice>
+#include <QMediaDevices>
 #include <QDialogButtonBox>
 #include <QFontMetrics>
 #include <QPushButton>
@@ -10,7 +11,6 @@
 #include <QSpinBox>
 #include <QTimer>
 #include <QScreen>
-#include <QUrl>
 
 #include "gui_settings.h"
 #include "display_sleep_control.h"
@@ -1207,10 +1207,10 @@ settings_dialog::settings_dialog(std::shared_ptr<gui_settings> gui_settings, std
 		const std::string selected_camera = m_emu_settings->GetSetting(emu_settings_type::CameraID);
 		ui->cameraIdBox->addItem(tr("None", "Camera Device"), "");
 		ui->cameraIdBox->addItem(tr("Default", "Camera Device"), qstr(default_camera));
-		for (const QCameraInfo& camera_info : QCameraInfo::availableCameras())
+		for (const QCameraDevice& camera_info : QMediaDevices::videoInputs())
 		{
 			if (!camera_info.isNull())
-				ui->cameraIdBox->addItem(camera_info.description(), camera_info.deviceName());
+				ui->cameraIdBox->addItem(camera_info.description(), camera_info.id());
 		}
 		if (const int index = ui->cameraIdBox->findData(qstr(selected_camera)); index >= 0)
 		{
diff --git a/rpcs3/rpcs3qt/trophy_manager_dialog.cpp b/rpcs3/rpcs3qt/trophy_manager_dialog.cpp
index aa070c900..14a680a59 100644
--- a/rpcs3/rpcs3qt/trophy_manager_dialog.cpp
+++ b/rpcs3/rpcs3qt/trophy_manager_dialog.cpp
@@ -29,7 +29,6 @@
 #include <QDir>
 #include <QMenu>
 #include <QDesktopServices>
-#include <QUrl>
 #include <QScrollBar>
 #include <QWheelEvent>
 #include <QGuiApplication>
diff --git a/rpcs3/rpcs3qt/user_manager_dialog.cpp b/rpcs3/rpcs3qt/user_manager_dialog.cpp
index c1a2f1d94..8314e6182 100644
--- a/rpcs3/rpcs3qt/user_manager_dialog.cpp
+++ b/rpcs3/rpcs3qt/user_manager_dialog.cpp
@@ -10,7 +10,6 @@
 #include <QDesktopServices>
 #include <QMessageBox>
 #include <QGuiApplication>
-#include <QUrl>
 
 #include "user_manager_dialog.h"
 #include "table_item_delegate.h"
