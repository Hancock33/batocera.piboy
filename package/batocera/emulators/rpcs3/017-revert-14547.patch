diff --git a/rpcs3/Emu/Cell/PPUAnalyser.cpp b/rpcs3/Emu/Cell/PPUAnalyser.cpp
index 2968190f4..f402ddf43 100644
--- a/rpcs3/Emu/Cell/PPUAnalyser.cpp
+++ b/rpcs3/Emu/Cell/PPUAnalyser.cpp
@@ -1395,9 +1395,9 @@ bool ppu_module::analyse(u32 lib_toc, u32 entry, const u32 sec_end, const std::b
 					block.second = _ptr.addr() - block.first;
 					break;
 				}
-				else if (type & ppu_itype::trap)
+				else if (type == ppu_itype::TW || type == ppu_itype::TWI || type == ppu_itype::TD || type == ppu_itype::TDI)
 				{
-					if (op.bo != 31)
+					if (op.opcode != ppu_instructions::TRAP())
 					{
 						add_block(_ptr.addr());
 					}
@@ -1623,8 +1623,6 @@ bool ppu_module::analyse(u32 lib_toc, u32 entry, const u32 sec_end, const std::b
 		end = 0;
 	}
 
-	u32 per_instruction_bytes = 0;
-
 	for (auto&& [_, func] : as_rvalue(fmap))
 	{
 		if (func.attr & ppu_attr::no_size && entry)
@@ -1643,7 +1641,6 @@ bool ppu_module::analyse(u32 lib_toc, u32 entry, const u32 sec_end, const std::b
 				block.attr = ppu_attr::no_size;
 			}
 
-			per_instruction_bytes += utils::sub_saturate<u32>(lim, func.addr);
 			continue;
 		}
 
@@ -1724,8 +1721,11 @@ bool ppu_module::analyse(u32 lib_toc, u32 entry, const u32 sec_end, const std::b
 	u32 exp = start;
 	u32 lim = end;
 
-	// Start with full scan
-	block_queue.emplace_back(exp, lim);
+	// Start with full scan (disabled for PRX for now)
+	if (entry)
+	{
+		block_queue.emplace_back(exp, lim);
+	}
 
 	// Add entries from patches (on per-instruction basis)
 	for (u32 addr : applied)
@@ -1759,17 +1759,14 @@ bool ppu_module::analyse(u32 lib_toc, u32 entry, const u32 sec_end, const std::b
 		{
 			u32 i_pos = exp;
 
-			u32 block_edges[16];
-			u32 edge_count = 0;
-
 			bool is_good = true;
 			bool is_fallback = true;
 
 			for (; i_pos < lim; i_pos += 4)
 			{
-				const ppu_opcode_t op{get_ref<u32>(i_pos)};
+				const u32 opc = get_ref<u32>(i_pos);
 
-				switch (auto type = s_ppu_itype.decode(op.opcode))
+				switch (auto type = s_ppu_itype.decode(opc))
 				{
 				case ppu_itype::UNK:
 				case ppu_itype::ECIWX:
@@ -1779,20 +1776,10 @@ bool ppu_module::analyse(u32 lib_toc, u32 entry, const u32 sec_end, const std::b
 					is_good = false;
 					break;
 				}
-				case ppu_itype::TDI:
-				case ppu_itype::TWI:
-				{
-					if (op.ra == 1u || op.ra == 13u || op.ra == 2u)
-					{
-						// Non-user registers, checking them against a constant value makes no sense
-						is_good = false;
-						break;
-					}
-
-					[[fallthrough]];
-				}
 				case ppu_itype::TD:
+				case ppu_itype::TDI:
 				case ppu_itype::TW:
+				case ppu_itype::TWI:
 				case ppu_itype::B:
 				case ppu_itype::BC:
 				{
@@ -1803,14 +1790,14 @@ bool ppu_module::analyse(u32 lib_toc, u32 entry, const u32 sec_end, const std::b
 
 					if (type == ppu_itype::B || type == ppu_itype::BC)
 					{
-						if (entry == 0 && op.aa)
+						if (entry == 0 && ppu_opcode_t{opc}.aa)
 						{
 							// Ignore absolute branches in PIC (PRX)
 							is_good = false;
 							break;
 						}
 
-						const u32 target = (op.aa ? 0 : i_pos) + (type == ppu_itype::B ? +op.bt24 : +op.bt14);
+						const u32 target = (opc & 2 ? 0 : i_pos) + (type == ppu_itype::B ? +ppu_opcode_t{opc}.bt24 : +ppu_opcode_t{opc}.bt14);
 
 						if (target < segs[0].addr || target >= segs[0].addr + segs[0].size)
 						{
@@ -1819,43 +1806,9 @@ bool ppu_module::analyse(u32 lib_toc, u32 entry, const u32 sec_end, const std::b
 							break;
 						}
 
-						const ppu_opcode_t test_op{get_ref<u32>(target)};
-						const auto type0 = s_ppu_itype.decode(test_op.opcode);
-
-						if (type0 == ppu_itype::UNK)
-						{
-							is_good = false;
-							break;
-						}
-
-						// Test another instruction just in case (testing more is unlikely to improve results by much)
-						if (!(type0 & ppu_itype::branch))
-						{
-							if (target + 4 >= segs[0].addr + segs[0].size)
-							{
-								is_good = false;
-								break;
-							}
-
-							const auto type1 = s_ppu_itype.decode(get_ref<u32>(target + 4));
-
-							if (type1 == ppu_itype::UNK)
-							{
-								is_good = false;
-								break;
-							}
-						}
-						else if (u32 target0 = (test_op.aa ? 0 : target) + (type == ppu_itype::B ? +test_op.bt24 : +test_op.bt14);
-							target0 < segs[0].addr || target0 >= segs[0].addr + segs[0].size)
-						{
-							// Sanity check
-							is_good = false;
-							break;
-						}
-
 						if (target != i_pos && !fmap.contains(target))
 						{
-							if (block_set.count(target) == 0 && std::count(block_edges, block_edges + edge_count, target) == 0)
+							if (block_set.count(target) == 0)
 							{
 								ppu_log.trace("Block target found: 0x%x (i_pos=0x%x)", target, i_pos);
 								block_queue.emplace_back(target, 0);
@@ -1870,38 +1823,27 @@ bool ppu_module::analyse(u32 lib_toc, u32 entry, const u32 sec_end, const std::b
 				case ppu_itype::BCLR:
 				case ppu_itype::SC:
 				{
-					if (type == ppu_itype::SC && op.opcode != ppu_instructions::SC(0))
+					if (type == ppu_itype::SC && opc != ppu_instructions::SC(0))
 					{
 						// Strict garbage filter
 						is_good = false;
 						break;
 					}
 
-					if (type == ppu_itype::BCCTR && op.opcode & 0xe000)
+					if (type == ppu_itype::BCCTR && opc & 0xe000)
 					{
 						// Garbage filter
 						is_good = false;
 						break;
 					}
 
-					if (type == ppu_itype::BCLR && op.opcode & 0xe000)
+					if (type == ppu_itype::BCLR && opc & 0xe000)
 					{
 						// Garbage filter
 						is_good = false;
 						break;
 					}
 
-					if ((type & ppu_itype::branch && op.lk) || type & ppu_itype::trap || type == ppu_itype::BC)
-					{
-						// if farther instructions are valid: register all blocks
-						// Otherwise, register none (all or nothing)
-						if (edge_count < std::size(block_edges))
-						{
-							block_edges[edge_count++] = i_pos + 4;
-							continue;
-						}
-					}
-
 					// Good block terminator found, add single block
 					break;
 				}
@@ -1932,23 +1874,17 @@ bool ppu_module::analyse(u32 lib_toc, u32 entry, const u32 sec_end, const std::b
 
 			if (is_good)
 			{
-				for (u32 it = 0, prev_addr = exp; it <= edge_count; it++)
-				{
-					const u32 block_end = it < edge_count ? block_edges[it] : i_pos;
-					const u32 block_begin = std::exchange(prev_addr, block_end);
+				auto& block = fmap[exp];
 
-					auto& block = fmap[block_begin];
+				if (!block.addr)
+				{
+					block.addr = exp;
+					block.size = i_pos - exp;
+					ppu_log.trace("Block __0x%x added (size=0x%x)", block.addr, block.size);
 
-					if (!block.addr)
+					if (get_limit(exp) == end)
 					{
-						block.addr = block_begin;
-						block.size = block_end - block_begin;
-						ppu_log.trace("Block __0x%x added (size=0x%x)", block.addr, block.size);
-
-						if (get_limit(block_begin) == end)
-						{
-							block.attr += ppu_attr::no_size;
-						}
+						block.attr += ppu_attr::no_size;
 					}
 				}
 			}
@@ -1971,8 +1907,9 @@ bool ppu_module::analyse(u32 lib_toc, u32 entry, const u32 sec_end, const std::b
 	// Convert map to vector (destructive)
 	for (auto&& [_, block] : as_rvalue(std::move(fmap)))
 	{
-		if (block.attr & ppu_attr::no_size && block.size > 4)
+		if (block.attr & ppu_attr::no_size && block.size > 4 && entry)
 		{
+			// Disabled for PRX for now
 			ppu_log.warning("Block 0x%x will be compiled on per-instruction basis (size=0x%x)", block.addr, block.size);
 
 			for (u32 addr = block.addr; addr < block.addr + block.size; addr += 4)
@@ -1984,19 +1921,12 @@ bool ppu_module::analyse(u32 lib_toc, u32 entry, const u32 sec_end, const std::b
 				i.attr = ppu_attr::no_size;
 			}
 
-			per_instruction_bytes += block.size;
 			continue;
 		}
 
 		funcs.emplace_back(std::move(block));
 	}
 
-	if (per_instruction_bytes)
-	{
-		const bool error = per_instruction_bytes >= 200 && per_instruction_bytes / 4 >= utils::aligned_div<u32>(funcs.size(), 128);
-		(error ? ppu_log.error : ppu_log.notice)("%d instructions will be compiled on per-instruction basis in total", per_instruction_bytes / 4);
-	}
-
 	ppu_log.notice("Block analysis: %zu blocks (%zu enqueued)", funcs.size(), block_queue.size());
 	return true;
 }
diff --git a/rpcs3/Emu/Cell/PPUAnalyser.h b/rpcs3/Emu/Cell/PPUAnalyser.h
index ccbd743f9..ef02faa53 100644
--- a/rpcs3/Emu/Cell/PPUAnalyser.h
+++ b/rpcs3/Emu/Cell/PPUAnalyser.h
@@ -263,7 +263,6 @@ struct ppu_pattern_matrix
 struct ppu_itype
 {
 	static constexpr struct branch_tag{} branch{}; // Branch Instructions
-	static constexpr struct trap_tag{} trap{}; // Branch Instructions
 
 	enum type
 	{
@@ -426,6 +425,8 @@ struct ppu_itype
 		VUPKLSB,
 		VUPKLSH,
 		VXOR,
+		TDI,
+		TWI,
 		MULLI,
 		SUBFIC,
 		CMPLI,
@@ -460,6 +461,7 @@ struct ppu_itype
 		RLDCL,
 		RLDCR,
 		CMP,
+		TW,
 		LVSL,
 		LVEBX,
 		SUBFC,
@@ -486,6 +488,7 @@ struct ppu_itype
 		LWZUX,
 		CNTLZD,
 		ANDC,
+		TD,
 		LVEWX,
 		MULHD,
 		MULHW,
@@ -781,11 +784,6 @@ struct ppu_itype
 		BC,
 		BCLR,
 		BCCTR, // branch_tag last
-
-		TD, // trap_tag first
-		TW,
-		TDI,
-		TWI, // trap_tag last
 	};
 
 	// Enable address-of operator for ppu_decoder<>
@@ -798,11 +796,6 @@ struct ppu_itype
 	{
 		return value >= B && value <= BCCTR;
 	}
-
-	friend constexpr bool operator &(type value, trap_tag)
-	{
-		return value >= TD && value <= TWI;
-	}
 };
 
 struct ppu_iname
