From e9611844f8b8ed8b04d679abf73b8ab1cea17c0f Mon Sep 17 00:00:00 2001
From: kd-11 <karokidii@gmail.com>
Date: Wed, 20 Oct 2021 13:46:12 +0300
Subject: [PATCH 01/13] rsx: Import, rebase and clean up the old detiling
 patches from 2021

---
 rpcs3/Emu/RSX/Common/tiled_dma_copy.hpp | 186 ++++++++++++++++++++++++
 rpcs3/Emu/RSX/VK/VKPresent.cpp          |  18 ++-
 rpcs3/Emu/RSX/VK/VKRenderTargets.cpp    |  25 ++++
 rpcs3/Emu/RSX/VK/VKTexture.cpp          |   2 +-
 rpcs3/Emu/RSX/VK/VKTextureCache.cpp     |   2 +-
 rpcs3/Emu/RSX/VK/VKTextureCache.h       |  31 ++++
 rpcs3/Emu/RSX/rsx_utils.h               |   4 +-
 rpcs3/emucore.vcxproj                   |   2 +
 rpcs3/emucore.vcxproj.filters           |   3 +
 9 files changed, 269 insertions(+), 4 deletions(-)
 create mode 100644 rpcs3/Emu/RSX/Common/tiled_dma_copy.hpp

diff --git a/rpcs3/Emu/RSX/Common/tiled_dma_copy.hpp b/rpcs3/Emu/RSX/Common/tiled_dma_copy.hpp
new file mode 100644
index 00000000000..39e88a36f67
--- /dev/null
+++ b/rpcs3/Emu/RSX/Common/tiled_dma_copy.hpp
@@ -0,0 +1,186 @@
+#pragma once
+
+#include <util/types.hpp>
+#include <cstdint>
+
+// This is a 1:1 port of the GPU code for my own sanity when debugging misplaced bits
+// For a high-level explanation, read https://envytools.readthedocs.io/en/latest/hw/memory/vram.html
+namespace rsx
+{
+	struct detiler_config
+	{
+		uint32_t prime;
+		uint32_t factor;
+		uint32_t num_tiles_per_row;
+		uint32_t tile_base_address;
+		uint32_t tile_size;
+		uint32_t tile_offset;
+		uint32_t tile_pitch;
+		uint32_t tile_bank;
+		uint32_t image_width;
+		uint32_t image_height;
+		uint32_t image_bpp;
+	};
+
+#define RSX_TILE_WIDTH 256
+#define RSX_TILE_HEIGHT 64
+#define RSX_DMA_OP_ENCODE_TILE 0
+#define RSX_DMA_OP_DECODE_TILE 1
+
+	static void tiled_dma_copy(const uint32_t row, const uint32_t col, const detiler_config& conf, char* tiled_data, char* linear_data, int direction)
+	{
+		const uint32_t row_offset = (row * conf.tile_pitch) + conf.tile_base_address + conf.tile_offset;
+		const uint32_t this_address = row_offset + (col * conf.image_bpp);
+
+		// 1. Calculate row_addr
+		const uint32_t texel_offset = (this_address - conf.tile_base_address) / RSX_TILE_WIDTH;
+		// Calculate coordinate of the tile grid we're supposed to be in
+		const uint32_t tile_x = texel_offset % conf.num_tiles_per_row;
+		const uint32_t tile_y = (texel_offset / conf.num_tiles_per_row) / RSX_TILE_HEIGHT;
+		// Calculate the grid offset for the tile selected and add the base offset. It's supposed to affect the bank stuff in the next step
+		const uint32_t tile_id = tile_y * conf.num_tiles_per_row + tile_x;
+		const uint32_t tile_selector = (tile_id + (conf.tile_base_address >> 14)) & 0x3ffff;
+		// Calculate row address
+		const uint32_t row_address = (tile_selector >> 2) & 0xffff;
+
+		// 2. Calculate bank selector
+		// There's a lot of weird math here, but it's just a variant of (tile_selector % 4) to pick a value between [0..3]
+		uint32_t bank_selector = 0;
+		const uint32_t bank_distribution_lookup[16] = { 0, 1, 2, 3, 2, 3, 0, 1, 1, 2, 3, 0, 3, 0, 1, 2 };
+
+		if (conf.factor == 1)
+		{
+			bank_selector = (tile_selector & 3);
+		}
+		else if (conf.factor == 2)
+		{
+			const uint32_t idx = ((tile_selector + ((tile_y & 1) << 1)) & 3) * 4 + (tile_y & 3);
+			bank_selector = bank_distribution_lookup[idx];
+		}
+		else if (conf.factor >= 4)
+		{
+			const uint32_t idx = (tile_selector & 3) * 4 + (tile_y & 3);
+			bank_selector = bank_distribution_lookup[idx];
+		}
+		bank_selector = (bank_selector + conf.tile_bank) & 3;
+
+		// 3. Calculate column selector
+		uint32_t column_selector = 0;
+		const uint32_t line_offset_in_tile = (texel_offset / conf.num_tiles_per_row) % RSX_TILE_HEIGHT;
+		// Calculate column_selector by bit-twiddling line offset and the other calculated parameter bits:
+		// column_selector[9:7] = line_offset_in_tile[5:3]
+		// column_selector[6:4] = this_address[7:5]
+		// column_selector[3:2] = line_offset_in_tile[1:0]
+		// column_selector[1:0] = 0
+		column_selector |= ((line_offset_in_tile >> 3) & 0x7) << 7;
+		column_selector |= ((this_address >> 5) & 0x7) << 4;
+		column_selector |= ((line_offset_in_tile >> 0) & 0x3) << 2;
+
+		// 4. Calculate partition selector (0 or 1)
+		const uint32_t partition_selector = (((line_offset_in_tile >> 2) & 1) + ((this_address >> 6) & 1)) & 1;
+
+		// 5. Build tiled address
+		uint32_t tile_address = 0;
+		// tile_address[31:16] = row_adr[15:0]
+		// tile_address[15:14] = bank_sel[1:0]
+		// tile_address[13:8] = column_sel[9:4]
+		// tile_address[7:7] = partition_sel[0:0]
+		// tile_address[6:5] = column_sel[3:2]
+		// tile_address[4:0] = this_address[4:0]
+		tile_address |= ((row_address >> 0) & 0xFFFF) << 16;
+		tile_address |= ((bank_selector >> 0) & 0x3) << 14;
+		tile_address |= ((column_selector >> 4) & 0x3F) << 8;
+		tile_address |= ((partition_selector >> 0) & 0x1) << 7;
+		tile_address |= ((column_selector >> 2) & 0x3) << 5;
+		tile_address |= ((this_address >> 0) & 0x1F) << 0;
+		// Twiddle bits 9 and 10
+		tile_address ^= (((tile_address >> 12) ^ ((bank_selector ^ tile_selector) & 1) ^ (tile_address >> 14)) & 1) << 9;
+		tile_address ^= ((tile_address >> 11) & 1) << 10;
+
+		// Calculate relative addresses and sample
+		uint32_t linear_image_offset = (row * conf.tile_pitch) + (col * conf.image_bpp);
+		uint32_t tile_data_offset = tile_address - (conf.tile_base_address + conf.tile_offset);
+
+		if (tile_data_offset >= conf.tile_size)
+		{
+			// Do not touch anything out of bounds
+			return;
+		}
+
+		if (direction == RSX_DMA_OP_ENCODE_TILE)
+		{
+			std::memcpy(tiled_data + tile_data_offset, linear_data + linear_image_offset, conf.image_bpp);
+		}
+		else
+		{
+			std::memcpy(linear_data + linear_image_offset, tiled_data + tile_data_offset, conf.image_bpp);
+		}
+	}
+
+	// Entry point. In GPU code this is handled by dispatch + main
+	template <typename T, bool Reverse = false>
+	void tile_texel_data(void* dst, const void* src, uint32_t base_address, uint32_t base_offset, uint32_t tile_size, uint8_t bank_sense, uint16_t row_pitch_in_bytes, uint16_t image_width, uint16_t image_height)
+	{
+		// Some constants
+		auto get_prime_factor = [](uint32_t pitch) -> std::pair<uint32_t, uint32_t>
+		{
+			const uint32_t base = (pitch >> 8);
+			if ((pitch & (pitch - 1)) == 0)
+			{
+				return { 1u, base };
+			}
+
+			for (const auto prime : { 3, 5, 7, 11, 13 })
+			{
+				if ((base % prime) == 0)
+				{
+					return { prime, base / prime };
+				}
+			}
+
+			// rsx_log.error("Unexpected pitch value 0x%x", pitch);
+			return {};
+		};
+
+		const auto [prime, factor] = get_prime_factor(row_pitch_in_bytes);
+		const uint32_t tiles_per_row = prime * factor;
+		constexpr int op = Reverse ? RSX_DMA_OP_DECODE_TILE : RSX_DMA_OP_ENCODE_TILE;
+
+		auto src2 = static_cast<char*>(const_cast<void*>(src));
+		auto dst2 = static_cast<char*>(dst);
+
+		const detiler_config dconf = {
+			.prime = prime,
+			.factor = factor,
+			.num_tiles_per_row = tiles_per_row,
+			.tile_base_address = base_address,
+			.tile_size = tile_size,
+			.tile_offset = base_offset,
+			.tile_pitch = row_pitch_in_bytes,
+			.tile_bank = bank_sense,
+			.image_width = image_width,
+			.image_height = image_height,
+			.image_bpp = sizeof(T)
+		};
+
+		for (u16 row = 0; row < image_height; ++row)
+		{
+			for (u16 col = 0; col < image_width; ++col)
+			{
+				if constexpr (op == RSX_DMA_OP_DECODE_TILE)
+				{
+					tiled_dma_copy(row, col, dconf, src2, dst2, op);
+				}
+				else
+				{
+					tiled_dma_copy(row, col, dconf, dst2, src2, op);
+				}
+			}
+		}
+	}
+
+#undef RSX_TILE_WIDTH
+#undef RSX_TILE_HEIGHT
+#undef RSX_DMA_OP_ENCODE_TILE
+#undef RSX_DMA_OP_DECODE_TILE
+}
diff --git a/rpcs3/Emu/RSX/VK/VKPresent.cpp b/rpcs3/Emu/RSX/VK/VKPresent.cpp
index 2f69505b962..4cbf0a90659 100644
--- a/rpcs3/Emu/RSX/VK/VKPresent.cpp
+++ b/rpcs3/Emu/RSX/VK/VKPresent.cpp
@@ -14,6 +14,11 @@
 extern atomic_t<bool> g_user_asked_for_screenshot;
 extern atomic_t<recording_mode> g_recording_mode;
 
+namespace vk
+{
+	u32 g_debug_vis_address = 0;
+}
+
 void VKGSRender::reinitialize_swapchain()
 {
 	m_swapchain_dims.width = m_frame->client_width();
@@ -477,7 +482,18 @@ void VKGSRender::flip(const rsx::display_flip_info_t& info)
 		present_info.format = av_format;
 		present_info.address = rsx::get_address(display_buffers[info.buffer].offset, CELL_GCM_LOCATION_LOCAL);
 
-		image_to_flip = get_present_source(&present_info, avconfig);
+		if (vk::g_debug_vis_address)
+		{
+			//std::vector<u8> temp_data(5120 * 1024);
+			//std::memcpy(temp_data.data(), vm::get_super_ptr(vk::g_debug_vis_address), 5120 * 1024);
+			//rsx::untile_texel_data<u32>(vm::get_super_ptr(vk::g_debug_vis_address), temp_data.data(), vk::g_debug_vis_address, 0, 0, 5120, 1280, 720);
+			image_to_flip = m_texture_cache.upload_image_simple(*m_current_command_buffer, VK_FORMAT_B8G8R8A8_UNORM, vk::g_debug_vis_address, 1280, 720, 5120);
+			vk::g_debug_vis_address = 0;
+		}
+		else
+		{
+			image_to_flip = get_present_source(&present_info, avconfig);
+		}
 
 		if (avconfig.stereo_mode != stereo_render_mode_options::disabled) [[unlikely]]
 		{
diff --git a/rpcs3/Emu/RSX/VK/VKRenderTargets.cpp b/rpcs3/Emu/RSX/VK/VKRenderTargets.cpp
index 48d693f7a0b..9509894a040 100644
--- a/rpcs3/Emu/RSX/VK/VKRenderTargets.cpp
+++ b/rpcs3/Emu/RSX/VK/VKRenderTargets.cpp
@@ -1,6 +1,9 @@
 #include "VKRenderTargets.h"
 #include "VKResourceManager.h"
 #include "Emu/RSX/rsx_methods.h"
+#include "Emu/RSX/RSXThread.h"
+
+#include "Emu/RSX/Common/tiled_dma_copy.hpp"
 
 namespace vk
 {
@@ -678,6 +681,28 @@ namespace vk
 		subres.depth = 1;
 		subres.data = { vm::get_super_ptr<const std::byte>(base_addr), static_cast<std::span<const std::byte>::size_type>(rsx_pitch * surface_height * samples_y) };
 
+		// FIXME: Move to GPU queue
+		std::vector<std::byte> ext_data;
+		const auto range = get_memory_range();
+
+		if (auto region = rsx::get_current_renderer()->get_tiled_memory_region(range))
+		{
+			auto real_data = vm::get_super_ptr<u8>(range.start);
+			ext_data.resize(region.tile->size);
+			rsx::tile_texel_data<u32, true>(
+				ext_data.data(),
+				real_data,
+				region.base_address,
+				range.start - region.base_address,
+				region.tile->size,
+				region.tile->bank,
+				region.tile->pitch,
+				subres.width_in_block,
+				subres.height_in_block
+			);
+			subres.data = ext_data;
+		}
+
 		if (g_cfg.video.resolution_scale_percent == 100 && spp == 1) [[likely]]
 		{
 			push_layout(cmd, VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL);
diff --git a/rpcs3/Emu/RSX/VK/VKTexture.cpp b/rpcs3/Emu/RSX/VK/VKTexture.cpp
index 78e5004f648..5de83a08fe8 100644
--- a/rpcs3/Emu/RSX/VK/VKTexture.cpp
+++ b/rpcs3/Emu/RSX/VK/VKTexture.cpp
@@ -1009,7 +1009,7 @@ namespace vk
 			{
 				caps.supports_byteswap = (image_linear_size >= 1024);
 				caps.supports_hw_deswizzle = caps.supports_byteswap;
-				caps.supports_zero_copy = caps.supports_byteswap;
+				caps.supports_zero_copy = false;// caps.supports_byteswap;
 				caps.supports_vtc_decoding = false;
 				check_caps = false;
 			}
diff --git a/rpcs3/Emu/RSX/VK/VKTextureCache.cpp b/rpcs3/Emu/RSX/VK/VKTextureCache.cpp
index a22783addf0..41293fc303e 100644
--- a/rpcs3/Emu/RSX/VK/VKTextureCache.cpp
+++ b/rpcs3/Emu/RSX/VK/VKTextureCache.cpp
@@ -1333,7 +1333,7 @@ namespace vk
 
 		void* mem = image->memory->map(0, layout.rowPitch * height);
 
-		auto src = vm::_ptr<const char>(address);
+		auto src = vm::get_super_ptr<const char>(address);
 		auto dst = static_cast<char*>(mem);
 
 		// TODO: SSE optimization
diff --git a/rpcs3/Emu/RSX/VK/VKTextureCache.h b/rpcs3/Emu/RSX/VK/VKTextureCache.h
index e2aace58325..f8f9fa08304 100644
--- a/rpcs3/Emu/RSX/VK/VKTextureCache.h
+++ b/rpcs3/Emu/RSX/VK/VKTextureCache.h
@@ -8,11 +8,18 @@
 #include "vkutils/image_helpers.h"
 
 #include "../Common/texture_cache.h"
+
 #include "Emu/Cell/timers.hpp"
 
 #include <memory>
 #include <vector>
 
+#define DEBUG_DMA_TILING 1
+
+#if DEBUG_DMA_TILING
+#include "../Common/tiled_dma_copy.hpp"
+#endif
+
 namespace vk
 {
 	class cached_texture_section;
@@ -286,6 +293,30 @@ namespace vk
 			const auto range = (context == rsx::texture_upload_context::framebuffer_storage) ? get_section_range() : get_confirmed_range();
 			vk::flush_dma(range.start, range.length());
 
+#if DEBUG_DMA_TILING
+			// Are we a tiled region?
+			if (const auto tiled_region = rsx::get_current_renderer()->get_tiled_memory_region(range))
+			{
+				auto real_data = vm::get_super_ptr<u8>(range.start);
+				auto out_data = std::vector<u8>(tiled_region.tile->size);
+				rsx::tile_texel_data<u32>(
+					out_data.data(),
+					real_data,
+					tiled_region.base_address,
+					range.start - tiled_region.base_address,
+					tiled_region.tile->size,
+					tiled_region.tile->bank,
+					tiled_region.tile->pitch,
+					width,
+					height
+				);
+				const auto available_tile_size = tiled_region.tile->size - (range.start - tiled_region.base_address);
+				const auto max_content_size = tiled_region.tile->pitch * utils::align(height, 64);
+				const auto write_length = std::min(max_content_size, available_tile_size);
+				std::memcpy(real_data, out_data.data(), write_length);
+			}
+#endif
+
 			if (is_swizzled())
 			{
 				// This format is completely worthless to CPU processing algorithms where cache lines on die are linear.
diff --git a/rpcs3/Emu/RSX/rsx_utils.h b/rpcs3/Emu/RSX/rsx_utils.h
index 7ecfe488577..4bb1b634fd7 100644
--- a/rpcs3/Emu/RSX/rsx_utils.h
+++ b/rpcs3/Emu/RSX/rsx_utils.h
@@ -288,7 +288,9 @@ namespace rsx
 
 	static inline u32 get_location(u32 addr)
 	{
-		return (addr >= rsx::constants::local_mem_base) ?
+		// We don't really care about the actual memory map, it shouldn't be possible to use the mmio bar region anyway
+		constexpr address_range local_mem_range = address_range::start_length(rsx::constants::local_mem_base, 0x1000'0000);
+		return local_mem_range.overlaps(addr) ?
 			CELL_GCM_LOCATION_LOCAL :
 			CELL_GCM_LOCATION_MAIN;
 	}
diff --git a/rpcs3/emucore.vcxproj b/rpcs3/emucore.vcxproj
index 4aaaf7ef2d3..9854e484ae3 100644
--- a/rpcs3/emucore.vcxproj
+++ b/rpcs3/emucore.vcxproj
@@ -550,6 +550,7 @@
     <ClInclude Include="Emu\perf_monitor.hpp" />
     <ClInclude Include="Emu\RSX\Common\bitfield.hpp" />
     <ClInclude Include="Emu\RSX\Common\buffer_stream.hpp" />
+    <ClInclude Include="Emu\RSX\Common\tiled_dma_copy.hpp" />
     <ClInclude Include="Emu\RSX\Common\expected.hpp" />
     <ClInclude Include="Emu\RSX\Common\profiling_timer.hpp" />
     <ClInclude Include="Emu\RSX\Common\ranged_map.hpp" />
@@ -905,6 +906,7 @@
     <None Include="Emu\RSX\Program\GLSLSnippets\GPUDeswizzle.glsl" />
     <None Include="Emu\RSX\Program\GLSLSnippets\OverlayRenderFS.glsl" />
     <None Include="Emu\RSX\Program\GLSLSnippets\OverlayRenderVS.glsl" />
+    <None Include="Emu\RSX\Program\GLSLSnippets\RSXMemoryTiling.glsl" />
     <None Include="Emu\RSX\Program\GLSLSnippets\RSXProg\RSXDefines2.glsl" />
     <None Include="Emu\RSX\Program\GLSLSnippets\RSXProg\RSXFragmentPrologue.glsl" />
     <None Include="Emu\RSX\Program\GLSLSnippets\RSXProg\RSXFragmentTextureDepthConversion.glsl" />
diff --git a/rpcs3/emucore.vcxproj.filters b/rpcs3/emucore.vcxproj.filters
index fb5bda5d41f..b780716bbf9 100644
--- a/rpcs3/emucore.vcxproj.filters
+++ b/rpcs3/emucore.vcxproj.filters
@@ -2436,5 +2436,8 @@
     <None Include="Emu\RSX\Program\GLSLSnippets\RSXProg\RSXVertexFetch.glsl">
       <Filter>Emu\GPU\RSX\Program\Snippets\RSXProg</Filter>
     </None>
+    <None Include="Emu\RSX\Program\GLSLSnippets\RSXMemoryTiling.glsl">
+      <Filter>Emu\GPU\RSX\Program\Snippets</Filter>
+    </None>
   </ItemGroup>
 </Project>
\ No newline at end of file

From 83fb9eca32d692d4408cf81989ab7507ab5ad985 Mon Sep 17 00:00:00 2001
From: kd-11 <karokidii@gmail.com>
Date: Fri, 8 Sep 2023 03:47:12 +0300
Subject: [PATCH 02/13] rsx: Refactor out more junk from rsx::thread

---
 rpcs3/Emu/RSX/Core/RSXContext.cpp | 34 +++++++++++++++++++
 rpcs3/Emu/RSX/Core/RSXContext.h   | 55 +++++++++++++++++++++++++++++++
 rpcs3/Emu/RSX/RSXThread.h         | 25 ++------------
 rpcs3/emucore.vcxproj             |  2 ++
 rpcs3/emucore.vcxproj.filters     |  6 ++++
 5 files changed, 100 insertions(+), 22 deletions(-)
 create mode 100644 rpcs3/Emu/RSX/Core/RSXContext.cpp
 create mode 100644 rpcs3/Emu/RSX/Core/RSXContext.h

diff --git a/rpcs3/Emu/RSX/Core/RSXContext.cpp b/rpcs3/Emu/RSX/Core/RSXContext.cpp
new file mode 100644
index 00000000000..ababec24cca
--- /dev/null
+++ b/rpcs3/Emu/RSX/Core/RSXContext.cpp
@@ -0,0 +1,34 @@
+#include "stdafx.h"
+#include "Emu/RSX/rsx_utils.h"
+#include "RSXContext.h"
+
+namespace rsx
+{
+	GCM_tile_reference GCM_context::get_tiled_memory_region(const utils::address_range& range) const
+	{
+		if (rsx::get_location(range.start) != CELL_GCM_LOCATION_MAIN)
+		{
+			// Local mem can be tiled but access is transparent from the memory controller
+			return {};
+		}
+
+		for (const auto& tile : tiles)
+		{
+			if (!tile.bound || tile.location != CELL_GCM_LOCATION_MAIN)
+			{
+				continue;
+			}
+
+			const auto tile_base_address = iomap_table.get_addr(tile.offset);
+			const auto tile_range = utils::address_range::start_length(tile_base_address, tile.size);
+
+			if (range.inside(tile_range))
+			{
+				ensure(tile_base_address + 1);
+				return { .base_address = tile_base_address, .tile = &tile };
+			}
+		}
+
+		return {};
+	}
+}
diff --git a/rpcs3/Emu/RSX/Core/RSXContext.h b/rpcs3/Emu/RSX/Core/RSXContext.h
new file mode 100644
index 00000000000..13fe40e77e1
--- /dev/null
+++ b/rpcs3/Emu/RSX/Core/RSXContext.h
@@ -0,0 +1,55 @@
+#pragma once
+
+#include <util/types.hpp>
+#include "Emu/Cell/lv2/sys_rsx.h"
+#include "Emu/RSX/GCM.h"
+#include "RSXIOMap.hpp"
+
+namespace rsx
+{
+	namespace gcm
+	{
+		enum limits
+		{
+			tiles_count = 15,
+			zculls_count = 8
+		};
+	}
+
+	struct GCM_tile_reference
+	{
+		u32 base_address = 0;
+		const GcmTileInfo* tile = nullptr;
+
+		operator bool() const
+		{
+			return !!tile;
+		}
+	};
+
+	struct GCM_context
+	{
+		RsxDmaControl* ctrl = nullptr;
+		u32 dma_address{ 0 };
+		rsx_iomap_table iomap_table;
+
+		GcmTileInfo tiles[gcm::limits::tiles_count];
+		GcmZcullInfo zculls[gcm::limits::zculls_count];
+
+		RsxDisplayInfo display_buffers[8];
+		u32 display_buffers_count{ 0 };
+		u32 current_display_buffer{ 0 };
+
+		shared_mutex sys_rsx_mtx;
+		u32 device_addr{ 0 };
+		u32 label_addr{ 0 };
+		u32 main_mem_size{ 0 };
+		u32 local_mem_size{ 0 };
+		u32 rsx_event_port{ 0 };
+		u32 driver_info{ 0 };
+
+		atomic_t<u64> unsent_gcm_events = 0; // Unsent event bits when aborting RSX/VBLANK thread (will be sent on savestate load)
+
+		GCM_tile_reference get_tiled_memory_region(const utils::address_range& range) const;
+	};
+}
diff --git a/rpcs3/Emu/RSX/RSXThread.h b/rpcs3/Emu/RSX/RSXThread.h
index a1be7e35ec8..bbae4b3c5a4 100644
--- a/rpcs3/Emu/RSX/RSXThread.h
+++ b/rpcs3/Emu/RSX/RSXThread.h
@@ -29,6 +29,7 @@
 
 #include "Core/RSXDisplay.h"
 #include "Core/RSXFrameBuffer.h"
+#include "Core/RSXContext.h"
 #include "Core/RSXIOMap.hpp"
 #include "Core/RSXVertexTypes.h"
 
@@ -147,7 +148,7 @@ namespace rsx
 	};
 
 	// TODO: This class is a mess, this needs to be broken into smaller chunks, like I did for RSXFIFO and RSXZCULL (kd)
-	class thread : public cpu_thread
+	class thread : public cpu_thread, public GCM_context
 	{
 		u64 timestamp_ctrl = 0;
 		u64 timestamp_subvalue = 0;
@@ -204,11 +205,8 @@ namespace rsx
 		u32 m_pause_after_x_flips = 0;
 
 	public:
-		RsxDmaControl* ctrl = nullptr;
-		u32 dma_address{0};
-		rsx_iomap_table iomap_table;
-		u32 restore_point = 0;
 		atomic_t<u64> new_get_put = u64{umax};
+		u32 restore_point = 0;
 		u32 dbg_step_pc = 0;
 		u32 last_known_code_start = 0;
 		atomic_t<u32> external_interrupt_lock{ 0 };
@@ -257,9 +255,6 @@ namespace rsx
 		atomic_bitmask_t<flip_request> async_flip_requested{};
 		u8 async_flip_buffer{ 0 };
 
-		GcmTileInfo tiles[limits::tiles_count];
-		GcmZcullInfo zculls[limits::zculls_count];
-
 		void capture_frame(const std::string &name);
 		const backend_configuration& get_backend_config() const { return backend_config; }
 
@@ -276,20 +271,6 @@ namespace rsx
 		atomic_t<bool> requested_vsync{true};
 		atomic_t<bool> enable_second_vhandler{false};
 
-		RsxDisplayInfo display_buffers[8];
-		u32 display_buffers_count{0};
-		u32 current_display_buffer{0};
-
-		shared_mutex sys_rsx_mtx;
-		u32 device_addr{0};
-		u32 label_addr{0};
-		u32 main_mem_size{0};
-		u32 local_mem_size{0};
-		u32 rsx_event_port{0};
-		u32 driver_info{0};
-
-		atomic_t<u64> unsent_gcm_events = 0; // Unsent event bits when aborting RSX/VBLANK thread (will be sent on savestate load)
-
 		bool send_event(u64, u64, u64);
 
 		std::array<bool, 16> m_textures_dirty;
diff --git a/rpcs3/emucore.vcxproj b/rpcs3/emucore.vcxproj
index 9854e484ae3..8b22fd6b694 100644
--- a/rpcs3/emucore.vcxproj
+++ b/rpcs3/emucore.vcxproj
@@ -91,6 +91,7 @@
     <ClCompile Include="Emu\NP\upnp_handler.cpp" />
     <ClCompile Include="Emu\perf_monitor.cpp" />
     <ClCompile Include="Emu\RSX\Common\texture_cache.cpp" />
+    <ClCompile Include="Emu\RSX\Core\RSXContext.cpp" />
     <ClCompile Include="Emu\RSX\Overlays\HomeMenu\overlay_home_menu.cpp" />
     <ClCompile Include="Emu\RSX\Overlays\HomeMenu\overlay_home_menu_components.cpp" />
     <ClCompile Include="Emu\RSX\Overlays\HomeMenu\overlay_home_menu_message_box.cpp" />
@@ -558,6 +559,7 @@
     <ClInclude Include="Emu\RSX\Common\surface_cache_dma.hpp" />
     <ClInclude Include="Emu\RSX\Common\time.hpp" />
     <ClInclude Include="Emu\RSX\Common\unordered_map.hpp" />
+    <ClInclude Include="Emu\RSX\Core\RSXContext.h" />
     <ClInclude Include="Emu\RSX\Core\RSXEngLock.hpp" />
     <ClInclude Include="Emu\RSX\Core\RSXFrameBuffer.h" />
     <ClInclude Include="Emu\RSX\Core\RSXIOMap.hpp" />
diff --git a/rpcs3/emucore.vcxproj.filters b/rpcs3/emucore.vcxproj.filters
index b780716bbf9..de842b58454 100644
--- a/rpcs3/emucore.vcxproj.filters
+++ b/rpcs3/emucore.vcxproj.filters
@@ -1168,6 +1168,9 @@
     <ClCompile Include="Emu\Io\pad_types.cpp">
       <Filter>Emu\Io</Filter>
     </ClCompile>
+    <ClCompile Include="Emu\RSX\Core\RSXContext.cpp">
+      <Filter>Emu\GPU\RSX\Core</Filter>
+    </ClCompile>
   </ItemGroup>
   <ItemGroup>
     <ClInclude Include="Crypto\aes.h">
@@ -2374,6 +2377,9 @@
     <ClInclude Include="util\bless.hpp">
       <Filter>Utilities</Filter>
     </ClInclude>
+    <ClInclude Include="Emu\RSX\Core\RSXContext.h">
+      <Filter>Emu\GPU\RSX\Core</Filter>
+    </ClInclude>
   </ItemGroup>
   <ItemGroup>
     <None Include="Emu\RSX\Program\GLSLSnippets\GPUDeswizzle.glsl">

From 6c9c90250a46a625e480a151a89641ff098671b0 Mon Sep 17 00:00:00 2001
From: kd-11 <karokidii@gmail.com>
Date: Tue, 12 Sep 2023 02:41:25 +0300
Subject: [PATCH 03/13] rsx/vk: Initial hw-accelerated tile decoder

---
 .../Program/GLSLSnippets/RSXMemoryTiling.glsl | 349 ++++++++++++++++++
 rpcs3/Emu/RSX/VK/VKCompute.h                  | 153 ++++++++
 rpcs3/Emu/RSX/VK/VKTextureCache.cpp           |  64 +++-
 rpcs3/Emu/RSX/VK/VKTextureCache.h             |   2 +-
 4 files changed, 559 insertions(+), 9 deletions(-)
 create mode 100644 rpcs3/Emu/RSX/Program/GLSLSnippets/RSXMemoryTiling.glsl

diff --git a/rpcs3/Emu/RSX/Program/GLSLSnippets/RSXMemoryTiling.glsl b/rpcs3/Emu/RSX/Program/GLSLSnippets/RSXMemoryTiling.glsl
new file mode 100644
index 00000000000..9b3dd62f737
--- /dev/null
+++ b/rpcs3/Emu/RSX/Program/GLSLSnippets/RSXMemoryTiling.glsl
@@ -0,0 +1,349 @@
+R"(
+#version 450
+layout(local_size_x = %ws, local_size_y = 1, local_size_z = 1) in;
+
+#define SSBO_LOCATION(x) (x + %loc)
+
+#define MEMORY_OP %op
+#define MEMORY_OP_DETILE 0
+#define MEMORY_OP_TILE   1
+
+#if (MEMORY_OP == MEMORY_OP_TILE)
+  #define TILED_DATA_MODIFIER
+  #define LINEAR_DATA_MODIFIER readonly
+#else
+  #define TILED_DATA_MODIFIER readonly
+  #define LINEAR_DATA_MODIFIER
+#endif
+
+layout(%set, binding=SSBO_LOCATION(0), std430) TILED_DATA_MODIFIER restrict buffer TiledDataBlock
+{
+	uint tiled_data[];
+};
+
+layout(%set, binding=SSBO_LOCATION(1), std430) LINEAR_DATA_MODIFIER restrict buffer LinearDataBlock
+{
+	uint linear_data[];
+};
+
+#ifdef VULKAN
+layout(%push_block) uniform Configuration
+{
+	uint prime;
+	uint factor;
+	uint num_tiles_per_row;
+	uint tile_base_address;
+	uint tile_size;
+	uint tile_offset;
+	uint tile_pitch;
+	uint tile_bank;
+	uint image_width;
+	uint image_height;
+	uint image_bpp;
+};
+#else
+	uniform uint prime;
+	uniform uint factor;
+	uniform uint num_tiles_per_row;
+	uniform uint tile_base_address;
+	uniform uint tile_size;
+	uniform uint tile_offset;
+	uniform uint tile_pitch;
+	uniform uint tile_bank;
+	uniform uint image_width;
+	uniform uint image_height;
+	uniform uint image_bpp;
+#endif
+
+// Constants
+#define RSX_TILE_WIDTH  256
+#define RSX_TILE_HEIGHT 64
+
+#if (MEMORY_OP == MEMORY_OP_TILE)
+
+uvec4 read_linear(const in uint offset)
+{
+	switch (image_bpp)
+	{
+	case 16:
+	{
+		return uvec4(
+			linear_data[offset * 4],
+			linear_data[offset * 4 + 1],
+			linear_data[offset * 4 + 2],
+			linear_data[offset * 4 + 3]);
+	}
+	case 8:
+	{
+		return uvec4(
+			linear_data[offset * 2],
+			linear_data[offset * 2 + 1],
+			0,
+			0);
+	}
+	case 4:
+	{
+		return uvec4(linear_data[offset], 0, 0, 0);
+	}
+	case 2:
+	{
+		const uint word = linear_data[offset >> 1];
+		const int shift = int(offset & 1) << 4;
+		return uvec4(bitfieldExtract(word, shift, 16), 0, 0, 0);
+	}
+	case 1:
+	{
+		const uint word = linear_data[offset >> 2];
+		const int shift = int(offset & 3) << 3;
+		return uvec4(bitfieldExtract(word, shift, 8), 0, 0, 0);
+	}
+	default:
+		return uvec4(0);
+	}
+}
+
+void write_tiled(const in uint offset, const in uvec4 value)
+{
+	switch (image_bpp)
+	{
+	case 16:
+	{
+		tiled_data[offset * 4] = value.x;
+		tiled_data[offset * 4 + 1] = value.y;
+		tiled_data[offset * 4 + 2] = value.z;
+		tiled_data[offset * 4 + 3] = value.w;
+		break;
+	}
+	case 8:
+	{
+		tiled_data[offset * 2] = value.x;
+		tiled_data[offset * 2 + 1] = value.y;
+		break;
+	}
+	case 4:
+	{
+		tiled_data[offset] = value.x;
+		break;
+	}
+	case 2:
+	{
+		const uint word_offset = offset >> 1;
+		const uint word = tiled_data[word_offset];
+		const int shift = int(offset & 1) << 4;
+		tiled_data[word_offset] = bitfieldInsert(word, value.x, shift, 16);
+		break;
+	}
+	case 1:
+	{
+		const uint word_offset = offset >> 2;
+		const uint word = tiled_data[word_offset];
+		const int shift = int(offset & 3) << 3;
+		tiled_data[word_offset] = bitfieldInsert(word, value.x, shift, 8);
+		break;
+	}
+	default:
+		break;
+	}
+}
+
+#else
+
+uvec4 read_tiled(const in uint offset)
+{
+	switch (image_bpp)
+	{
+	case 16:
+	{
+		return uvec4(
+			tiled_data[offset * 4],
+			tiled_data[offset * 4 + 1],
+			tiled_data[offset * 4 + 2],
+			tiled_data[offset * 4 + 3]);
+	}
+	case 8:
+	{
+		return uvec4(
+			tiled_data[offset * 2],
+			tiled_data[offset * 2 + 1],
+			0,
+			0);
+	}
+	case 4:
+	{
+		return uvec4(tiled_data[offset], 0, 0, 0);
+	}
+	case 2:
+	{
+		const uint word = tiled_data[offset >> 1];
+		const int shift = int(offset & 1) << 4;
+		return uvec4(bitfieldExtract(word, shift, 16), 0, 0, 0);
+	}
+	case 1:
+	{
+		const uint word = tiled_data[offset >> 2];
+		const int shift = int(offset & 3) << 3;
+		return uvec4(bitfieldExtract(word, shift, 8), 0, 0, 0);
+	}
+	default:
+		return uvec4(0);
+	}
+}
+
+void write_linear(const in uint offset, const in uvec4 value)
+{
+	switch (image_bpp)
+	{
+	case 16:
+	{
+		linear_data[offset * 4] = value.x;
+		linear_data[offset * 4 + 1] = value.y;
+		linear_data[offset * 4 + 2] = value.z;
+		linear_data[offset * 4 + 3] = value.w;
+		break;
+	}
+	case 8:
+	{
+		linear_data[offset * 2] = value.x;
+		linear_data[offset * 2 + 1] = value.y;
+		break;
+	}
+	case 4:
+	{
+		linear_data[offset] = value.x;
+		break;
+	}
+	case 2:
+	{
+		const uint word_offset = offset >> 1;
+		const uint word = linear_data[word_offset];
+		const int shift = int(offset & 1) << 4;
+		linear_data[word_offset] = bitfieldInsert(word, value.x, shift, 16);
+		break;
+	}
+	case 1:
+	{
+		const uint word_offset = offset >> 2;
+		const uint word = linear_data[word_offset];
+		const int shift = int(offset & 3) << 3;
+		linear_data[word_offset] = bitfieldInsert(word, value.x, shift, 8);
+		break;
+	}
+	default:
+		break;
+	}
+}
+
+#endif
+
+void do_memory_op(const in uint row, const in uint col)
+{
+	const uint row_offset = (row * tile_pitch) + tile_base_address + tile_offset;
+	const uint this_address = row_offset + (col * image_bpp);
+
+	// 1. Calculate row_addr
+	const uint texel_offset = (this_address - tile_base_address) / RSX_TILE_WIDTH;
+	// Calculate coordinate of the tile grid we're supposed to be in
+	const uint tile_x = texel_offset % num_tiles_per_row;
+	const uint tile_y = (texel_offset / num_tiles_per_row) / RSX_TILE_HEIGHT;
+	// Calculate the grid offset for the tile selected and add the base offset. It's supposed to affect the bank stuff in the next step
+	const uint tile_id = tile_y * num_tiles_per_row + tile_x;
+	const uint tile_selector = (tile_id + (tile_base_address >> 14)) & 0x3ffff;
+	// Calculate row address
+	const uint row_address = (tile_selector >> 2) & 0xffff;
+
+	// 2. Calculate bank selector
+	// There's a lot of weird math here, but it's just a variant of (tile_selector % 4) to pick a value between [0..3]
+	uint bank_selector = 0;
+	const uint bank_distribution_lookup[16] = { 0, 1, 2, 3, 2, 3, 0, 1, 1, 2, 3, 0, 3, 0, 1, 2 };
+
+	if (factor == 1)
+	{
+		bank_selector = (tile_selector & 3);
+	}
+	else if (factor == 2)
+	{
+		const uint idx = ((tile_selector + ((tile_y & 1) << 1)) & 3) * 4 + (tile_y & 3);
+		bank_selector = bank_distribution_lookup[idx];
+	}
+	else if (factor >= 4)
+	{
+		const uint idx = (tile_selector & 3) * 4 + (tile_y & 3);
+		bank_selector = bank_distribution_lookup[idx];
+	}
+	bank_selector = (bank_selector + tile_bank) % 4;
+
+	// 3. Calculate column selector
+	uint column_selector = 0;
+	const uint line_offset_in_tile = (texel_offset / num_tiles_per_row) % RSX_TILE_HEIGHT;
+	// Calculate column_selector by bit-twiddling line offset and the other calculated parameter bits:
+	// column_selector[9:7] = line_offset_in_tile[5:3]
+	// column_selector[6:4] = this_address[7:5]
+	// column_selector[3:2] = line_offset_in_tile[1:0]
+	// column_selector[1:0] = 0
+	column_selector |= ((line_offset_in_tile >> 3) & 0x7) << 7;
+	column_selector |= ((this_address >> 5) & 0x7) << 4;
+	column_selector |= ((line_offset_in_tile >> 0) & 0x3) << 2;
+
+	// 4. Calculate partition selector (0 or 1)
+	const uint partition_selector = (((line_offset_in_tile >> 2) & 1) + ((this_address >> 6) & 1)) & 1;
+
+	// 5. Build tiled address
+	uint tile_address = 0;
+	// tile_address[31:16] = row_adr[15:0]
+	// tile_address[15:14] = bank_sel[1:0]
+	// tile_address[13:8] = column_sel[9:4]
+	// tile_address[7:7] = partition_sel[0:0]
+	// tile_address[6:5] = column_sel[3:2]
+	// tile_address[4:0] = this_address[4:0]
+	tile_address |= ((row_address >> 0) & 0xFFFF) << 16;
+	tile_address |= ((bank_selector >> 0) & 0x3) << 14;
+	tile_address |= ((column_selector >> 4) & 0x3F) << 8;
+	tile_address |= ((partition_selector >> 0) & 0x1) << 7;
+	tile_address |= ((column_selector >> 2) & 0x3) << 5;
+	tile_address |= ((this_address >> 0) & 0x1F) << 0;
+	// Twiddle bits 9 and 10
+	tile_address ^= (((tile_address >> 12) ^ ((bank_selector ^ tile_selector) & 1) ^ (tile_address >> 14)) & 1) << 9;
+	tile_address ^= ((tile_address >> 11) & 1) << 10;
+
+	// Calculate relative addresses and sample
+	uint linear_image_offset = (row * tile_pitch) + (col * image_bpp);
+	uint tile_data_offset = tile_address - (tile_base_address + tile_offset);
+
+	if (tile_data_offset >= tile_size)
+	{
+		// Do not touch anything out of bounds
+		return;
+	}
+
+	// Convert to texel addresses for data access
+	linear_image_offset /= image_bpp;
+	tile_data_offset /= image_bpp;
+
+#if (MEMORY_OP == MEMORY_OP_DETILE)
+	// Write to linear from tiled
+	write_linear(linear_image_offset, read_tiled(tile_data_offset));
+#else
+	// Opposite. Write to tile from linear
+	write_tiled(tile_data_offset, read_linear(linear_image_offset));
+#endif
+}
+
+void main()
+{
+	// The 2D coordinates are retrieved from gl_GlobalInvocationID
+	const uint num_iterations = (image_bpp < 4) ? (4 / image_bpp) : 1;
+	const uint row = gl_GlobalInvocationID.y;
+	const uint col0 = gl_GlobalInvocationID.x;
+	
+	// for (uint col = col0; col < (col0 + num_iterations); ++col)
+	{
+		if (row >= image_height || col0 >= image_width)
+		{
+			// Out of bounds
+			return;
+		}
+
+		do_memory_op(row, col0);
+	}
+}
+)"
diff --git a/rpcs3/Emu/RSX/VK/VKCompute.h b/rpcs3/Emu/RSX/VK/VKCompute.h
index d79f809c570..c48ab89d767 100644
--- a/rpcs3/Emu/RSX/VK/VKCompute.h
+++ b/rpcs3/Emu/RSX/VK/VKCompute.h
@@ -502,6 +502,159 @@ namespace vk
 		void run(const vk::command_buffer& cmd, const vk::buffer* dst, const vk::buffer* src, u32 num_words);
 	};
 
+	enum RSX_detiler_op
+	{
+		decode = 0,
+		encode = 1
+	};
+
+	struct RSX_detiler_config
+	{
+		u32 tile_base_address;
+		u32 tile_base_offset;
+		u32 tile_size;
+		u32 tile_pitch;
+		u32 bank;
+
+		const vk::buffer* dst;
+		u32 dst_offset;
+		const vk::buffer* src;
+		u32 src_offset;
+
+		u16 image_width;
+		u16 image_height;
+		u32 image_pitch;
+	};
+
+	template <RSX_detiler_op Op>
+	struct cs_tile_memcpy : compute_task
+	{
+#pragma pack (push, 1)
+		struct
+		{
+			u32 prime;
+			u32 factor;
+			u32 num_tiles_per_row;
+			u32 tile_base_address;
+			u32 tile_size;
+			u32 tile_offset;
+			u32 tile_pitch;
+			u32 tile_bank;
+			u32 image_width;
+			u32 image_height;
+			u32 image_bpp;
+		} params;
+#pragma pack (pop)
+
+		const vk::buffer* src_buffer = nullptr;
+		const vk::buffer* dst_buffer = nullptr;
+		u32 in_offset = 0;
+		u32 out_offset = 0;
+		u32 in_block_length = 0;
+		u32 out_block_length = 0;
+
+		cs_tile_memcpy()
+		{
+			ssbo_count = 2;
+			use_push_constants = true;
+			push_constants_size = 44;
+
+			create();
+
+			m_src =
+			#include "../Program/GLSLSnippets/RSXMemoryTiling.glsl"
+				;
+
+			optimal_group_size = 1;
+			const std::pair<std::string_view, std::string> syntax_replace[] =
+			{
+				{ "%loc", "0" },
+				{ "%set", "set = 0" },
+				{ "%push_block", "push_constant" },
+				{ "%ws", std::to_string(optimal_group_size) },
+				{ "%op", std::to_string(Op) }
+			};
+
+			m_src = fmt::replace_all(m_src, syntax_replace);
+		}
+
+		void bind_resources() override
+		{
+			const auto op = static_cast<int>(Op);
+			m_program->bind_buffer({ src_buffer->value, in_offset, in_block_length }, 0 ^ op, VK_DESCRIPTOR_TYPE_STORAGE_BUFFER, m_descriptor_set);
+			m_program->bind_buffer({ dst_buffer->value, out_offset, out_block_length }, 1 ^ op, VK_DESCRIPTOR_TYPE_STORAGE_BUFFER, m_descriptor_set);
+		}
+
+		void set_parameters(const vk::command_buffer& cmd)
+		{
+			vkCmdPushConstants(cmd, m_pipeline_layout, VK_SHADER_STAGE_COMPUTE_BIT, 0, push_constants_size, &params);
+		}
+
+		void run(const vk::command_buffer& cmd, const RSX_detiler_config& config)
+		{
+			dst_buffer = config.dst;
+			src_buffer = config.src;
+
+			this->in_offset = config.src_offset;
+			this->out_offset = config.dst_offset;
+
+			const auto tiled_height = std::min(
+				utils::align<u32>(config.image_height, 64),
+				utils::aligned_div(config.tile_size - config.tile_base_offset, config.tile_pitch)
+			);
+
+			if constexpr (Op == RSX_detiler_op::decode)
+			{
+				this->in_block_length = tiled_height * config.tile_pitch;
+				this->out_block_length = config.image_height * config.image_pitch;
+			}
+			else
+			{
+				this->in_block_length = config.image_height * config.image_pitch;
+				this->out_block_length = tiled_height* config.tile_pitch;
+			}
+
+			auto get_prime_factor = [](u32 pitch) -> std::pair<u32, u32>
+			{
+				const u32 base = (pitch >> 8);
+				if ((pitch & (pitch - 1)) == 0)
+				{
+					return { 1u, base };
+				}
+
+				for (const auto prime : { 3, 5, 7, 11, 13 })
+				{
+					if ((base % prime) == 0)
+					{
+						return { prime, base / prime };
+					}
+				}
+
+				rsx_log.error("Unexpected pitch value 0x%x", pitch);
+				return {};
+			};
+
+			const auto [prime, factor] = get_prime_factor(config.tile_pitch);
+			const u32 tiles_per_row = prime * factor;
+
+			params.prime = prime;
+			params.factor = factor;
+			params.num_tiles_per_row = tiles_per_row;
+			params.tile_base_address = config.tile_base_address;
+			params.tile_size = config.tile_size;
+			params.tile_offset = config.tile_base_offset;
+			params.tile_pitch = config.tile_pitch;
+			params.tile_bank = config.bank;
+			params.image_width = config.image_width;
+			params.image_height = config.image_height;
+			params.image_bpp = config.image_pitch / config.image_width;
+			set_parameters(cmd);
+
+			const u32 invocations_x = utils::aligned_div(config.image_width, optimal_group_size);
+			compute_task::run(cmd, invocations_x, config.image_height, 1);
+		}
+	};
+
 	// TODO: Replace with a proper manager
 	extern std::unordered_map<u32, std::unique_ptr<vk::compute_task>> g_compute_tasks;
 
diff --git a/rpcs3/Emu/RSX/VK/VKTextureCache.cpp b/rpcs3/Emu/RSX/VK/VKTextureCache.cpp
index 41293fc303e..f7fd3e88d4e 100644
--- a/rpcs3/Emu/RSX/VK/VKTextureCache.cpp
+++ b/rpcs3/Emu/RSX/VK/VKTextureCache.cpp
@@ -92,16 +92,24 @@ namespace vk
 		rsx_pitch = pitch;
 
 		const bool require_format_conversion = !!(src->aspect() & VK_IMAGE_ASPECT_STENCIL_BIT) || src->format() == VK_FORMAT_D32_SFLOAT;
+		const auto tiled_region = rsx::get_current_renderer()->get_tiled_memory_region(valid_range);
+		const bool require_tiling = !!tiled_region;
+		const bool require_gpu_transform = require_format_conversion || pack_unpack_swap_bytes || require_tiling;
 		auto dma_mapping = vk::map_dma(valid_range.start, valid_range.length());
 
-		if (require_format_conversion || pack_unpack_swap_bytes)
+		if (require_gpu_transform)
 		{
 			const auto section_length = valid_range.length();
 			const auto transfer_pitch = real_pitch;
 			const auto task_length = transfer_pitch * src_area.height();
-			const auto working_buffer_length = calculate_working_buffer_size(task_length, src->aspect());
+			auto working_buffer_length = calculate_working_buffer_size(task_length, src->aspect());
+
+			if (require_tiling) {
+				working_buffer_length += tiled_region.tile->size;
+			}
 
 			auto working_buffer = vk::get_scratch_buffer(cmd, working_buffer_length);
+			u32 result_offset = 0;
 
 			VkBufferImageCopy region = {};
 			region.imageSubresource = { src->aspect(), 0, 0, 1 };
@@ -142,17 +150,56 @@ namespace vk
 
 					shuffle_kernel->run(cmd, working_buffer, task_length);
 
-					vk::insert_buffer_memory_barrier(cmd, working_buffer->value, 0, task_length,
-						VK_PIPELINE_STAGE_COMPUTE_SHADER_BIT, VK_PIPELINE_STAGE_TRANSFER_BIT,
-						VK_ACCESS_SHADER_WRITE_BIT, VK_ACCESS_TRANSFER_READ_BIT);
+					if (!require_tiling)
+					{
+						vk::insert_buffer_memory_barrier(cmd, working_buffer->value, 0, task_length,
+							VK_PIPELINE_STAGE_COMPUTE_SHADER_BIT, VK_PIPELINE_STAGE_TRANSFER_BIT,
+							VK_ACCESS_SHADER_WRITE_BIT, VK_ACCESS_TRANSFER_READ_BIT);
 
-					require_rw_barrier = false;
+						require_rw_barrier = false;
+					}
 				}
 			}
 
+			if (require_tiling)
+			{
+#if !DEBUG_DMA_TILING
+				// Compute -> Compute barrier
+				vk::insert_buffer_memory_barrier(cmd, working_buffer->value, 0, task_length,
+					VK_PIPELINE_STAGE_COMPUTE_SHADER_BIT, VK_PIPELINE_STAGE_TRANSFER_BIT,
+					VK_PIPELINE_STAGE_COMPUTE_SHADER_BIT, VK_ACCESS_SHADER_READ_BIT);
+
+				// Prepare payload
+				const RSX_detiler_config config =
+				{
+					.tile_base_address = tiled_region.base_address,
+					.tile_base_offset = valid_range.start - tiled_region.base_address,
+					.tile_size = tiled_region.tile->size,
+					.tile_pitch = tiled_region.tile->pitch,
+					.bank = tiled_region.tile->bank,
+
+					.dst = working_buffer,
+					.dst_offset = task_length,
+					.src = working_buffer,
+					.src_offset = 0,
+
+					.image_width = width,
+					.image_height = height,
+					.image_pitch = real_pitch
+				};
+
+				// Execute
+				const auto job = vk::get_compute_task<vk::cs_tile_memcpy<RSX_detiler_op::encode>>();
+				job->run(cmd, config);
+
+				result_offset = task_length;
+				require_rw_barrier = true;
+#endif
+			}
+
 			if (require_rw_barrier)
 			{
-				vk::insert_buffer_memory_barrier(cmd, working_buffer->value, 0, working_buffer_length,
+				vk::insert_buffer_memory_barrier(cmd, working_buffer->value, result_offset, working_buffer_length,
 					VK_PIPELINE_STAGE_TRANSFER_BIT | VK_PIPELINE_STAGE_COMPUTE_SHADER_BIT, VK_PIPELINE_STAGE_COMPUTE_SHADER_BIT,
 					VK_ACCESS_TRANSFER_WRITE_BIT | VK_ACCESS_SHADER_WRITE_BIT, VK_ACCESS_SHADER_READ_BIT);
 			}
@@ -160,6 +207,7 @@ namespace vk
 			if (rsx_pitch == real_pitch) [[likely]]
 			{
 				VkBufferCopy copy = {};
+				copy.srcOffset = result_offset;
 				copy.dstOffset = dma_mapping.first;
 				copy.size = section_length;
 				vkCmdCopyBuffer(cmd, working_buffer->value, dma_mapping.second->value, 1, &copy);
@@ -178,7 +226,7 @@ namespace vk
 				copy.reserve(transfer_height);
 
 				u32 dst_offset = dma_mapping.first;
-				u32 src_offset = 0;
+				u32 src_offset = result_offset;
 
 				for (unsigned row = 0; row < transfer_height; ++row)
 				{
diff --git a/rpcs3/Emu/RSX/VK/VKTextureCache.h b/rpcs3/Emu/RSX/VK/VKTextureCache.h
index f8f9fa08304..09df70d67d5 100644
--- a/rpcs3/Emu/RSX/VK/VKTextureCache.h
+++ b/rpcs3/Emu/RSX/VK/VKTextureCache.h
@@ -14,7 +14,7 @@
 #include <memory>
 #include <vector>
 
-#define DEBUG_DMA_TILING 1
+#define DEBUG_DMA_TILING 0
 
 #if DEBUG_DMA_TILING
 #include "../Common/tiled_dma_copy.hpp"

From 82c4cd84b1474e8dd07790090b8a4c0b31cbc52b Mon Sep 17 00:00:00 2001
From: kd-11 <karokidii@gmail.com>
Date: Tue, 12 Sep 2023 03:38:59 +0300
Subject: [PATCH 04/13] rsx/vk: Support mismatched pitch (padded) and fix the
 overscan problem

---
 rpcs3/Emu/RSX/Common/tiled_dma_copy.hpp       |  4 +++-
 .../Program/GLSLSnippets/RSXMemoryTiling.glsl |  6 ++++--
 rpcs3/Emu/RSX/VK/VKCompute.h                  | 14 ++++++++-----
 rpcs3/Emu/RSX/VK/VKTextureCache.cpp           | 20 ++++++++++++++++---
 rpcs3/Emu/RSX/VK/VKTextureCache.h             | 17 +++++++++++-----
 5 files changed, 45 insertions(+), 16 deletions(-)

diff --git a/rpcs3/Emu/RSX/Common/tiled_dma_copy.hpp b/rpcs3/Emu/RSX/Common/tiled_dma_copy.hpp
index 39e88a36f67..28f4577085e 100644
--- a/rpcs3/Emu/RSX/Common/tiled_dma_copy.hpp
+++ b/rpcs3/Emu/RSX/Common/tiled_dma_copy.hpp
@@ -19,6 +19,7 @@ namespace rsx
 		uint32_t tile_bank;
 		uint32_t image_width;
 		uint32_t image_height;
+		uint32_t image_pitch;
 		uint32_t image_bpp;
 	};
 
@@ -98,7 +99,7 @@ namespace rsx
 		tile_address ^= ((tile_address >> 11) & 1) << 10;
 
 		// Calculate relative addresses and sample
-		uint32_t linear_image_offset = (row * conf.tile_pitch) + (col * conf.image_bpp);
+		uint32_t linear_image_offset = (row * conf.image_pitch) + (col * conf.image_bpp);
 		uint32_t tile_data_offset = tile_address - (conf.tile_base_address + conf.tile_offset);
 
 		if (tile_data_offset >= conf.tile_size)
@@ -160,6 +161,7 @@ namespace rsx
 			.tile_bank = bank_sense,
 			.image_width = image_width,
 			.image_height = image_height,
+			.image_pitch = row_pitch_in_bytes,
 			.image_bpp = sizeof(T)
 		};
 
diff --git a/rpcs3/Emu/RSX/Program/GLSLSnippets/RSXMemoryTiling.glsl b/rpcs3/Emu/RSX/Program/GLSLSnippets/RSXMemoryTiling.glsl
index 9b3dd62f737..eebed180c66 100644
--- a/rpcs3/Emu/RSX/Program/GLSLSnippets/RSXMemoryTiling.glsl
+++ b/rpcs3/Emu/RSX/Program/GLSLSnippets/RSXMemoryTiling.glsl
@@ -39,6 +39,7 @@ layout(%push_block) uniform Configuration
 	uint tile_bank;
 	uint image_width;
 	uint image_height;
+	uint image_pitch;
 	uint image_bpp;
 };
 #else
@@ -52,6 +53,7 @@ layout(%push_block) uniform Configuration
 	uniform uint tile_bank;
 	uniform uint image_width;
 	uniform uint image_height;
+	uniform uint image_pitch;
 	uniform uint image_bpp;
 #endif
 
@@ -306,7 +308,7 @@ void do_memory_op(const in uint row, const in uint col)
 	tile_address ^= ((tile_address >> 11) & 1) << 10;
 
 	// Calculate relative addresses and sample
-	uint linear_image_offset = (row * tile_pitch) + (col * image_bpp);
+	uint linear_image_offset = (row * image_pitch) + (col * image_bpp);
 	uint tile_data_offset = tile_address - (tile_base_address + tile_offset);
 
 	if (tile_data_offset >= tile_size)
@@ -335,7 +337,7 @@ void main()
 	const uint row = gl_GlobalInvocationID.y;
 	const uint col0 = gl_GlobalInvocationID.x;
 	
-	// for (uint col = col0; col < (col0 + num_iterations); ++col)
+	for (uint col = col0; col < (col0 + num_iterations); ++col)
 	{
 		if (row >= image_height || col0 >= image_width)
 		{
diff --git a/rpcs3/Emu/RSX/VK/VKCompute.h b/rpcs3/Emu/RSX/VK/VKCompute.h
index c48ab89d767..94604020bf5 100644
--- a/rpcs3/Emu/RSX/VK/VKCompute.h
+++ b/rpcs3/Emu/RSX/VK/VKCompute.h
@@ -524,6 +524,7 @@ namespace vk
 		u16 image_width;
 		u16 image_height;
 		u32 image_pitch;
+		u8  image_bpp;
 	};
 
 	template <RSX_detiler_op Op>
@@ -542,6 +543,7 @@ namespace vk
 			u32 tile_bank;
 			u32 image_width;
 			u32 image_height;
+			u32 image_pitch;
 			u32 image_bpp;
 		} params;
 #pragma pack (pop)
@@ -557,7 +559,7 @@ namespace vk
 		{
 			ssbo_count = 2;
 			use_push_constants = true;
-			push_constants_size = 44;
+			push_constants_size = 48;
 
 			create();
 
@@ -565,7 +567,6 @@ namespace vk
 			#include "../Program/GLSLSnippets/RSXMemoryTiling.glsl"
 				;
 
-			optimal_group_size = 1;
 			const std::pair<std::string_view, std::string> syntax_replace[] =
 			{
 				{ "%loc", "0" },
@@ -646,11 +647,14 @@ namespace vk
 			params.tile_pitch = config.tile_pitch;
 			params.tile_bank = config.bank;
 			params.image_width = config.image_width;
-			params.image_height = config.image_height;
-			params.image_bpp = config.image_pitch / config.image_width;
+			params.image_height = tiled_height;
+			params.image_pitch = config.image_pitch;
+			params.image_bpp = config.image_bpp;
 			set_parameters(cmd);
 
-			const u32 invocations_x = utils::aligned_div(config.image_width, optimal_group_size);
+			const u32 subtexels_per_invocation = (config.image_bpp < 4) ? (4 / config.image_bpp) : 1;
+			const u32 virtual_width = config.image_width / subtexels_per_invocation;
+			const u32 invocations_x = utils::aligned_div(virtual_width, optimal_group_size);
 			compute_task::run(cmd, invocations_x, config.image_height, 1);
 		}
 	};
diff --git a/rpcs3/Emu/RSX/VK/VKTextureCache.cpp b/rpcs3/Emu/RSX/VK/VKTextureCache.cpp
index f7fd3e88d4e..0f6a2804eaa 100644
--- a/rpcs3/Emu/RSX/VK/VKTextureCache.cpp
+++ b/rpcs3/Emu/RSX/VK/VKTextureCache.cpp
@@ -99,13 +99,24 @@ namespace vk
 
 		if (require_gpu_transform)
 		{
-			const auto section_length = valid_range.length();
+			auto section_length = valid_range.length();
 			const auto transfer_pitch = real_pitch;
 			const auto task_length = transfer_pitch * src_area.height();
 			auto working_buffer_length = calculate_working_buffer_size(task_length, src->aspect());
 
-			if (require_tiling) {
+			if (require_tiling)
+			{
 				working_buffer_length += tiled_region.tile->size;
+
+				// Calculate actual section length
+				const auto available_tile_size = tiled_region.tile->size - (valid_range.start - tiled_region.base_address);
+				const auto max_content_size = tiled_region.tile->pitch * utils::align(height, 64);
+				section_length = std::min(max_content_size, available_tile_size);
+
+				if (section_length > valid_range.length()) [[ likely ]]
+				{
+					dma_mapping = vk::map_dma(valid_range.start, section_length);
+				}
 			}
 
 			auto working_buffer = vk::get_scratch_buffer(cmd, working_buffer_length);
@@ -185,14 +196,17 @@ namespace vk
 
 					.image_width = width,
 					.image_height = height,
-					.image_pitch = real_pitch
+					.image_pitch = real_pitch,
+					.image_bpp = rsx::get_format_block_size_in_bytes(gcm_format)
 				};
 
 				// Execute
 				const auto job = vk::get_compute_task<vk::cs_tile_memcpy<RSX_detiler_op::encode>>();
 				job->run(cmd, config);
 
+				// Update internal variables
 				result_offset = task_length;
+				real_pitch = tiled_region.tile->pitch;
 				require_rw_barrier = true;
 #endif
 			}
diff --git a/rpcs3/Emu/RSX/VK/VKTextureCache.h b/rpcs3/Emu/RSX/VK/VKTextureCache.h
index 09df70d67d5..f418f761a7c 100644
--- a/rpcs3/Emu/RSX/VK/VKTextureCache.h
+++ b/rpcs3/Emu/RSX/VK/VKTextureCache.h
@@ -291,7 +291,17 @@ namespace vk
 
 			// Calculate smallest range to flush - for framebuffers, the raster region is enough
 			const auto range = (context == rsx::texture_upload_context::framebuffer_storage) ? get_section_range() : get_confirmed_range();
-			vk::flush_dma(range.start, range.length());
+			auto flush_length = range.length();
+
+			const auto tiled_region = rsx::get_current_renderer()->get_tiled_memory_region(range);
+			if (tiled_region)
+			{
+				const auto available_tile_size = tiled_region.tile->size - (range.start - tiled_region.base_address);
+				const auto max_content_size = tiled_region.tile->pitch * utils::align(height, 64);
+				flush_length = std::min(max_content_size, available_tile_size);
+			}
+
+			vk::flush_dma(range.start, flush_length);
 
 #if DEBUG_DMA_TILING
 			// Are we a tiled region?
@@ -310,10 +320,7 @@ namespace vk
 					width,
 					height
 				);
-				const auto available_tile_size = tiled_region.tile->size - (range.start - tiled_region.base_address);
-				const auto max_content_size = tiled_region.tile->pitch * utils::align(height, 64);
-				const auto write_length = std::min(max_content_size, available_tile_size);
-				std::memcpy(real_data, out_data.data(), write_length);
+				std::memcpy(real_data, out_data.data(), flush_length);
 			}
 #endif
 

From e2d52a307444279badd73bb64bcad0726074d950 Mon Sep 17 00:00:00 2001
From: kd-11 <karokidii@gmail.com>
Date: Thu, 14 Sep 2023 02:50:16 +0300
Subject: [PATCH 05/13] rsx: Make the texture source an io-buffer

---
 rpcs3/Emu/RSX/Common/TextureUtils.cpp | 62 +++++++++++++--------------
 rpcs3/Emu/RSX/Common/TextureUtils.h   |  2 +-
 rpcs3/Emu/RSX/VK/VKRenderTargets.cpp  |  2 +-
 rpcs3/io_buffer.h                     | 29 +++++++++----
 4 files changed, 53 insertions(+), 42 deletions(-)

diff --git a/rpcs3/Emu/RSX/Common/TextureUtils.cpp b/rpcs3/Emu/RSX/Common/TextureUtils.cpp
index 30d4abbf8c9..f940c830623 100644
--- a/rpcs3/Emu/RSX/Common/TextureUtils.cpp
+++ b/rpcs3/Emu/RSX/Common/TextureUtils.cpp
@@ -627,7 +627,7 @@ namespace
 
 				const u32 slice_sz = src_pitch_in_block * block_size_in_bytes * full_height_in_block * miplevel_depth;
 				current_subresource_layout.pitch_in_block = src_pitch_in_block;
-				current_subresource_layout.data = std::span<const std::byte>(texture_data_pointer + offset_in_src, slice_sz);
+				current_subresource_layout.data = { texture_data_pointer + offset_in_src, slice_sz };
 
 				offset_in_src += slice_sz;
 				miplevel_width_in_texel = std::max(miplevel_width_in_texel / 2, 1);
@@ -825,13 +825,13 @@ namespace rsx
 
 		case CELL_GCM_TEXTURE_COMPRESSED_B8R8_G8R8:
 		{
-			copy_decoded_rb_rg_block::copy_mipmap_level<true>(dst_buffer.as_span<u32>(), utils::bless<const u32>(src_layout.data), w, h, depth, get_row_pitch_in_block<u32>(src_layout.width_in_texel, caps.alignment), src_layout.pitch_in_block);
+			copy_decoded_rb_rg_block::copy_mipmap_level<true>(dst_buffer.as_span<u32>(), src_layout.data.as_span<const u32>(), w, h, depth, get_row_pitch_in_block<u32>(src_layout.width_in_texel, caps.alignment), src_layout.pitch_in_block);
 			break;
 		}
 
 		case CELL_GCM_TEXTURE_COMPRESSED_R8B8_R8G8:
 		{
-			copy_decoded_rb_rg_block::copy_mipmap_level(dst_buffer.as_span<u32>(), utils::bless<const u32>(src_layout.data), w, h, depth, get_row_pitch_in_block<u32>(src_layout.width_in_texel, caps.alignment), src_layout.pitch_in_block);
+			copy_decoded_rb_rg_block::copy_mipmap_level(dst_buffer.as_span<u32>(), src_layout.data.as_span<const u32>(), w, h, depth, get_row_pitch_in_block<u32>(src_layout.width_in_texel, caps.alignment), src_layout.pitch_in_block);
 			break;
 		}
 
@@ -839,9 +839,9 @@ namespace rsx
 		case CELL_GCM_TEXTURE_R6G5B5:
 		{
 			if (is_swizzled)
-				copy_rgb655_block_swizzled::copy_mipmap_level(dst_buffer.as_span<u16>(), utils::bless<const be_t<u16>>(src_layout.data), w, h, depth, src_layout.border, get_row_pitch_in_block<u16>(w, caps.alignment));
+				copy_rgb655_block_swizzled::copy_mipmap_level(dst_buffer.as_span<u16>(), src_layout.data.as_span<const be_t<u16>>(), w, h, depth, src_layout.border, get_row_pitch_in_block<u16>(w, caps.alignment));
 			else
-				copy_rgb655_block::copy_mipmap_level(dst_buffer.as_span<u16>(), utils::bless<const be_t<u16>>(src_layout.data), w, h, depth, src_layout.border, get_row_pitch_in_block<u16>(w, caps.alignment), src_layout.pitch_in_block);
+				copy_rgb655_block::copy_mipmap_level(dst_buffer.as_span<u16>(), src_layout.data.as_span<const be_t<u16>>(), w, h, depth, src_layout.border, get_row_pitch_in_block<u16>(w, caps.alignment), src_layout.pitch_in_block);
 			break;
 		}
 
@@ -855,49 +855,49 @@ namespace rsx
 		case CELL_GCM_TEXTURE_R6G5B5:
 		{
 			if (is_swizzled)
-				convert_16_block_32_swizzled::copy_mipmap_level(dst_buffer.as_span<u32>(), utils::bless<const be_t<u16>>(src_layout.data), w, h, depth, src_layout.border, get_row_pitch_in_block<u32>(w, caps.alignment), &convert_rgb655_to_bgra8);
+				convert_16_block_32_swizzled::copy_mipmap_level(dst_buffer.as_span<u32>(), src_layout.data.as_span<const be_t<u16>>(), w, h, depth, src_layout.border, get_row_pitch_in_block<u32>(w, caps.alignment), &convert_rgb655_to_bgra8);
 			else
-				convert_16_block_32::copy_mipmap_level(dst_buffer.as_span<u32>(), utils::bless<const be_t<u16>>(src_layout.data), w, h, depth, src_layout.border, get_row_pitch_in_block<u32>(w, caps.alignment), src_layout.pitch_in_block, &convert_rgb655_to_bgra8);
+				convert_16_block_32::copy_mipmap_level(dst_buffer.as_span<u32>(), src_layout.data.as_span<const be_t<u16>>(), w, h, depth, src_layout.border, get_row_pitch_in_block<u32>(w, caps.alignment), src_layout.pitch_in_block, &convert_rgb655_to_bgra8);
 			break;
 		}
 		case CELL_GCM_TEXTURE_D1R5G5B5:
 		{
 			if (is_swizzled)
-				convert_16_block_32_swizzled::copy_mipmap_level(dst_buffer.as_span<u32>(), utils::bless<const be_t<u16>>(src_layout.data), w, h, depth, src_layout.border, get_row_pitch_in_block<u32>(w, caps.alignment), &convert_d1rgb5_to_bgra8);
+				convert_16_block_32_swizzled::copy_mipmap_level(dst_buffer.as_span<u32>(), src_layout.data.as_span<const be_t<u16>>(), w, h, depth, src_layout.border, get_row_pitch_in_block<u32>(w, caps.alignment), &convert_d1rgb5_to_bgra8);
 			else
-				convert_16_block_32::copy_mipmap_level(dst_buffer.as_span<u32>(), utils::bless<const be_t<u16>>(src_layout.data), w, h, depth, src_layout.border, get_row_pitch_in_block<u32>(w, caps.alignment), src_layout.pitch_in_block, &convert_d1rgb5_to_bgra8);
+				convert_16_block_32::copy_mipmap_level(dst_buffer.as_span<u32>(), src_layout.data.as_span<const be_t<u16>>(), w, h, depth, src_layout.border, get_row_pitch_in_block<u32>(w, caps.alignment), src_layout.pitch_in_block, &convert_d1rgb5_to_bgra8);
 			break;
 		}
 		case CELL_GCM_TEXTURE_A1R5G5B5:
 		{
 			if (is_swizzled)
-				convert_16_block_32_swizzled::copy_mipmap_level(dst_buffer.as_span<u32>(), utils::bless<const be_t<u16>>(src_layout.data), w, h, depth, src_layout.border, get_row_pitch_in_block<u32>(w, caps.alignment), &convert_a1rgb5_to_bgra8);
+				convert_16_block_32_swizzled::copy_mipmap_level(dst_buffer.as_span<u32>(), src_layout.data.as_span<const be_t<u16>>(), w, h, depth, src_layout.border, get_row_pitch_in_block<u32>(w, caps.alignment), &convert_a1rgb5_to_bgra8);
 			else
-				convert_16_block_32::copy_mipmap_level(dst_buffer.as_span<u32>(), utils::bless<const be_t<u16>>(src_layout.data), w, h, depth, src_layout.border, get_row_pitch_in_block<u32>(w, caps.alignment), src_layout.pitch_in_block, &convert_a1rgb5_to_bgra8);
+				convert_16_block_32::copy_mipmap_level(dst_buffer.as_span<u32>(), src_layout.data.as_span<const be_t<u16>>(), w, h, depth, src_layout.border, get_row_pitch_in_block<u32>(w, caps.alignment), src_layout.pitch_in_block, &convert_a1rgb5_to_bgra8);
 			break;
 		}
 		case CELL_GCM_TEXTURE_A4R4G4B4:
 		{
 			if (is_swizzled)
-				convert_16_block_32_swizzled::copy_mipmap_level(dst_buffer.as_span<u32>(), utils::bless<const be_t<u16>>(src_layout.data), w, h, depth, src_layout.border, get_row_pitch_in_block<u32>(w, caps.alignment), &convert_argb4_to_bgra8);
+				convert_16_block_32_swizzled::copy_mipmap_level(dst_buffer.as_span<u32>(), src_layout.data.as_span<const be_t<u16>>(), w, h, depth, src_layout.border, get_row_pitch_in_block<u32>(w, caps.alignment), &convert_argb4_to_bgra8);
 			else
-				convert_16_block_32::copy_mipmap_level(dst_buffer.as_span<u32>(), utils::bless<const be_t<u16>>(src_layout.data), w, h, depth, src_layout.border, get_row_pitch_in_block<u32>(w, caps.alignment), src_layout.pitch_in_block, &convert_argb4_to_bgra8);
+				convert_16_block_32::copy_mipmap_level(dst_buffer.as_span<u32>(), src_layout.data.as_span<const be_t<u16>>(), w, h, depth, src_layout.border, get_row_pitch_in_block<u32>(w, caps.alignment), src_layout.pitch_in_block, &convert_argb4_to_bgra8);
 			break;
 		}
 		case CELL_GCM_TEXTURE_R5G5B5A1:
 		{
 			if (is_swizzled)
-				convert_16_block_32_swizzled::copy_mipmap_level(dst_buffer.as_span<u32>(), utils::bless<const be_t<u16>>(src_layout.data), w, h, depth, src_layout.border, get_row_pitch_in_block<u32>(w, caps.alignment), &convert_rgb5a1_to_bgra8);
+				convert_16_block_32_swizzled::copy_mipmap_level(dst_buffer.as_span<u32>(), src_layout.data.as_span<const be_t<u16>>(), w, h, depth, src_layout.border, get_row_pitch_in_block<u32>(w, caps.alignment), &convert_rgb5a1_to_bgra8);
 			else
-				convert_16_block_32::copy_mipmap_level(dst_buffer.as_span<u32>(), utils::bless<const be_t<u16>>(src_layout.data), w, h, depth, src_layout.border, get_row_pitch_in_block<u32>(w, caps.alignment), src_layout.pitch_in_block, &convert_rgb5a1_to_bgra8);
+				convert_16_block_32::copy_mipmap_level(dst_buffer.as_span<u32>(), src_layout.data.as_span<const be_t<u16>>(), w, h, depth, src_layout.border, get_row_pitch_in_block<u32>(w, caps.alignment), src_layout.pitch_in_block, &convert_rgb5a1_to_bgra8);
 			break;
 		}
 		case CELL_GCM_TEXTURE_R5G6B5:
 		{
 			if (is_swizzled)
-				convert_16_block_32_swizzled::copy_mipmap_level(dst_buffer.as_span<u32>(), utils::bless<const be_t<u16>>(src_layout.data), w, h, depth, src_layout.border, get_row_pitch_in_block<u32>(w, caps.alignment), &convert_rgb565_to_bgra8);
+				convert_16_block_32_swizzled::copy_mipmap_level(dst_buffer.as_span<u32>(), src_layout.data.as_span<const be_t<u16>>(), w, h, depth, src_layout.border, get_row_pitch_in_block<u32>(w, caps.alignment), &convert_rgb565_to_bgra8);
 			else
-				convert_16_block_32::copy_mipmap_level(dst_buffer.as_span<u32>(), utils::bless<const be_t<u16>>(src_layout.data), w, h, depth, src_layout.border, get_row_pitch_in_block<u32>(w, caps.alignment), src_layout.pitch_in_block, &convert_rgb565_to_bgra8);
+				convert_16_block_32::copy_mipmap_level(dst_buffer.as_span<u32>(), src_layout.data.as_span<const be_t<u16>>(), w, h, depth, src_layout.border, get_row_pitch_in_block<u32>(w, caps.alignment), src_layout.pitch_in_block, &convert_rgb565_to_bgra8);
 			break;
 		}
 #endif
@@ -960,13 +960,13 @@ namespace rsx
 				// PS3 uses the Nvidia VTC memory layout for compressed 3D textures.
 				// This is only supported using Nvidia OpenGL.
 				// Remove the VTC tiling to support ATI and Vulkan.
-				copy_unmodified_block_vtc::copy_mipmap_level(dst_buffer.as_span<u64>(), utils::bless<const u64>(src_layout.data), w, h, depth, get_row_pitch_in_block<u64>(w, caps.alignment), src_layout.pitch_in_block);
+				copy_unmodified_block_vtc::copy_mipmap_level(dst_buffer.as_span<u64>(), src_layout.data.as_span<const u64>(), w, h, depth, get_row_pitch_in_block<u64>(w, caps.alignment), src_layout.pitch_in_block);
 			}
 			else if (is_3d && !is_po2 && caps.supports_vtc_decoding)
 			{
 				// In this case, hardware expects us to feed it a VTC input, but on PS3 we only have a linear one.
 				// We need to compress the 2D-planar DXT input into a VTC output
-				copy_linear_block_to_vtc::copy_mipmap_level(dst_buffer.as_span<u64>(), utils::bless<const u64>(src_layout.data), w, h, depth, get_row_pitch_in_block<u64>(w, caps.alignment), src_layout.pitch_in_block);
+				copy_linear_block_to_vtc::copy_mipmap_level(dst_buffer.as_span<u64>(), src_layout.data.as_span<const u64>(), w, h, depth, get_row_pitch_in_block<u64>(w, caps.alignment), src_layout.pitch_in_block);
 			}
 			else if (caps.supports_zero_copy)
 			{
@@ -975,7 +975,7 @@ namespace rsx
 			}
 			else
 			{
-				copy_unmodified_block::copy_mipmap_level(dst_buffer.as_span<u64>(), utils::bless<const u64>(src_layout.data), 1, w, h, depth, 0, get_row_pitch_in_block<u64>(w, caps.alignment), src_layout.pitch_in_block);
+				copy_unmodified_block::copy_mipmap_level(dst_buffer.as_span<u64>(), src_layout.data.as_span<const u64>(), 1, w, h, depth, 0, get_row_pitch_in_block<u64>(w, caps.alignment), src_layout.pitch_in_block);
 			}
 			break;
 		}
@@ -991,13 +991,13 @@ namespace rsx
 				// PS3 uses the Nvidia VTC memory layout for compressed 3D textures.
 				// This is only supported using Nvidia OpenGL.
 				// Remove the VTC tiling to support ATI and Vulkan.
-				copy_unmodified_block_vtc::copy_mipmap_level(dst_buffer.as_span<u128>(), utils::bless<const u128>(src_layout.data), w, h, depth, get_row_pitch_in_block<u128>(w, caps.alignment), src_layout.pitch_in_block);
+				copy_unmodified_block_vtc::copy_mipmap_level(dst_buffer.as_span<u128>(), src_layout.data.as_span<const u128>(), w, h, depth, get_row_pitch_in_block<u128>(w, caps.alignment), src_layout.pitch_in_block);
 			}
 			else if (is_3d && !is_po2 && caps.supports_vtc_decoding)
 			{
 				// In this case, hardware expects us to feed it a VTC input, but on PS3 we only have a linear one.
 				// We need to compress the 2D-planar DXT input into a VTC output
-				copy_linear_block_to_vtc::copy_mipmap_level(dst_buffer.as_span<u128>(), utils::bless<const u128>(src_layout.data), w, h, depth, get_row_pitch_in_block<u128>(w, caps.alignment), src_layout.pitch_in_block);
+				copy_linear_block_to_vtc::copy_mipmap_level(dst_buffer.as_span<u128>(), src_layout.data.as_span<const u128>(), w, h, depth, get_row_pitch_in_block<u128>(w, caps.alignment), src_layout.pitch_in_block);
 			}
 			else if (caps.supports_zero_copy)
 			{
@@ -1006,7 +1006,7 @@ namespace rsx
 			}
 			else
 			{
-				copy_unmodified_block::copy_mipmap_level(dst_buffer.as_span<u128>(), utils::bless<const u128>(src_layout.data), 1, w, h, depth, 0, get_row_pitch_in_block<u128>(w, caps.alignment), src_layout.pitch_in_block);
+				copy_unmodified_block::copy_mipmap_level(dst_buffer.as_span<u128>(), src_layout.data.as_span<const u128>(), 1, w, h, depth, 0, get_row_pitch_in_block<u128>(w, caps.alignment), src_layout.pitch_in_block);
 			}
 			break;
 		}
@@ -1021,7 +1021,7 @@ namespace rsx
 			{
 				if (is_swizzled)
 				{
-					copy_unmodified_block_swizzled::copy_mipmap_level(dst_buffer.as_span<u8>(), utils::bless<const u8>(src_layout.data), words_per_block, w, h, depth, src_layout.border, dst_pitch_in_block);
+					copy_unmodified_block_swizzled::copy_mipmap_level(dst_buffer.as_span<u8>(), src_layout.data.as_span<const u8>(), words_per_block, w, h, depth, src_layout.border, dst_pitch_in_block);
 				}
 				else if (caps.supports_zero_copy)
 				{
@@ -1030,7 +1030,7 @@ namespace rsx
 				}
 				else
 				{
-					copy_unmodified_block::copy_mipmap_level(dst_buffer.as_span<u8>(), utils::bless<const u8>(src_layout.data), words_per_block, w, h, depth, src_layout.border, dst_pitch_in_block, src_layout.pitch_in_block);
+					copy_unmodified_block::copy_mipmap_level(dst_buffer.as_span<u8>(), src_layout.data.as_span<const u8>(), words_per_block, w, h, depth, src_layout.border, dst_pitch_in_block, src_layout.pitch_in_block);
 				}
 			}
 			else
@@ -1064,11 +1064,11 @@ namespace rsx
 					}
 					else if (word_size == 2)
 					{
-						copy_unmodified_block::copy_mipmap_level(dst_buffer.as_span<u16>(), utils::bless<const u16>(src_layout.data), words_per_block, w, h, depth, src_layout.border, dst_pitch_in_block, src_layout.pitch_in_block);
+						copy_unmodified_block::copy_mipmap_level(dst_buffer.as_span<u16>(), src_layout.data.as_span<const u16>(), words_per_block, w, h, depth, src_layout.border, dst_pitch_in_block, src_layout.pitch_in_block);
 					}
 					else if (word_size == 4)
 					{
-						copy_unmodified_block::copy_mipmap_level(dst_buffer.as_span<u32>(), utils::bless<const u32>(src_layout.data), words_per_block, w, h, depth, src_layout.border, dst_pitch_in_block, src_layout.pitch_in_block);
+						copy_unmodified_block::copy_mipmap_level(dst_buffer.as_span<u32>(), src_layout.data.as_span<const u32>(), words_per_block, w, h, depth, src_layout.border, dst_pitch_in_block, src_layout.pitch_in_block);
 					}
 				}
 				else
@@ -1076,16 +1076,16 @@ namespace rsx
 					if (word_size == 2)
 					{
 						if (is_swizzled)
-							copy_unmodified_block_swizzled::copy_mipmap_level(dst_buffer.as_span<u16>(), utils::bless<const be_t<u16>>(src_layout.data), words_per_block, w, h, depth, src_layout.border, dst_pitch_in_block);
+							copy_unmodified_block_swizzled::copy_mipmap_level(dst_buffer.as_span<u16>(), src_layout.data.as_span<const be_t<u16>>(), words_per_block, w, h, depth, src_layout.border, dst_pitch_in_block);
 						else
-							copy_unmodified_block::copy_mipmap_level(dst_buffer.as_span<u16>(), utils::bless<const be_t<u16>>(src_layout.data), words_per_block, w, h, depth, src_layout.border, dst_pitch_in_block, src_layout.pitch_in_block);
+							copy_unmodified_block::copy_mipmap_level(dst_buffer.as_span<u16>(), src_layout.data.as_span<const be_t<u16>>(), words_per_block, w, h, depth, src_layout.border, dst_pitch_in_block, src_layout.pitch_in_block);
 					}
 					else if (word_size == 4)
 					{
 						if (is_swizzled)
-							copy_unmodified_block_swizzled::copy_mipmap_level(dst_buffer.as_span<u32>(), utils::bless<const be_t<u32>>(src_layout.data), words_per_block, w, h, depth, src_layout.border, dst_pitch_in_block);
+							copy_unmodified_block_swizzled::copy_mipmap_level(dst_buffer.as_span<u32>(), src_layout.data.as_span<const be_t<u32>>(), words_per_block, w, h, depth, src_layout.border, dst_pitch_in_block);
 						else
-							copy_unmodified_block::copy_mipmap_level(dst_buffer.as_span<u32>(), utils::bless<const be_t<u32>>(src_layout.data), words_per_block, w, h, depth, src_layout.border, dst_pitch_in_block, src_layout.pitch_in_block);
+							copy_unmodified_block::copy_mipmap_level(dst_buffer.as_span<u32>(), src_layout.data.as_span<const be_t<u32>>(), words_per_block, w, h, depth, src_layout.border, dst_pitch_in_block, src_layout.pitch_in_block);
 					}
 				}
 			}
diff --git a/rpcs3/Emu/RSX/Common/TextureUtils.h b/rpcs3/Emu/RSX/Common/TextureUtils.h
index c4cb11b30eb..7f99e21eb77 100644
--- a/rpcs3/Emu/RSX/Common/TextureUtils.h
+++ b/rpcs3/Emu/RSX/Common/TextureUtils.h
@@ -189,7 +189,7 @@ namespace rsx
 
 	struct subresource_layout
 	{
-		std::span<const std::byte> data;
+		rsx::io_buffer data;
 		u16 width_in_texel;
 		u16 height_in_texel;
 		u16 width_in_block;
diff --git a/rpcs3/Emu/RSX/VK/VKRenderTargets.cpp b/rpcs3/Emu/RSX/VK/VKRenderTargets.cpp
index 9509894a040..f19908d7645 100644
--- a/rpcs3/Emu/RSX/VK/VKRenderTargets.cpp
+++ b/rpcs3/Emu/RSX/VK/VKRenderTargets.cpp
@@ -700,7 +700,7 @@ namespace vk
 				subres.width_in_block,
 				subres.height_in_block
 			);
-			subres.data = ext_data;
+			subres.data = std::span(ext_data);
 		}
 
 		if (g_cfg.video.resolution_scale_percent == 100 && spp == 1) [[likely]]
diff --git a/rpcs3/io_buffer.h b/rpcs3/io_buffer.h
index 5f4dd32331a..945bdc9c906 100644
--- a/rpcs3/io_buffer.h
+++ b/rpcs3/io_buffer.h
@@ -1,5 +1,6 @@
 #pragma once
 #include <util/types.hpp>
+#include <util/bless.hpp>
 #include <span>
 #include <vector>
 #include <functional>
@@ -18,8 +19,8 @@ namespace rsx
 
 	class io_buffer
 	{
-		void* m_ptr = nullptr;
-		usz m_size = 0;
+		mutable void* m_ptr = nullptr;
+		mutable usz m_size = 0;
 
 		std::function<std::tuple<void*, usz> ()> m_allocator = nullptr;
 
@@ -27,7 +28,7 @@ namespace rsx
 		io_buffer() = default;
 
 		template <SpanLike T>
-		io_buffer(T& container)
+		io_buffer(const T& container)
 		{
 			m_ptr = reinterpret_cast<void*>(container.data());
 			m_size = container.size_bytes();
@@ -39,8 +40,18 @@ namespace rsx
 			m_allocator = allocator;
 		}
 
-		template<Integral T>
-		T* data()
+		template <Integral T>
+		io_buffer(void* ptr, T size)
+			: m_ptr(ptr), m_size(size)
+		{}
+
+		template <Integral T>
+		io_buffer(const void* ptr, T size)
+			: m_ptr(const_cast<void*>(ptr)), m_size(size)
+		{}
+
+		template <Integral T = u8>
+		T* data() const
 		{
 			if (!m_ptr && m_allocator)
 			{
@@ -55,11 +66,11 @@ namespace rsx
 			return m_size;
 		}
 
-		template<Integral T>
-		std::span<T> as_span()
+		template<typename T>
+		std::span<T> as_span() const
 		{
-			const auto bytes = data<T>();
-			return { bytes, m_size / sizeof(T) };
+			auto bytes = data();
+			return { utils::bless<T>(bytes), m_size / sizeof(T) };
 		}
 	};
 }

From d5a136b0f213a24f942a40a1e3ed411a80902a72 Mon Sep 17 00:00:00 2001
From: kd-11 <karokidii@gmail.com>
Date: Thu, 14 Sep 2023 05:16:36 +0300
Subject: [PATCH 06/13] rsx/vk: Support ingesting pre-processed GPU data as
 texture input

---
 rpcs3/Emu/RSX/VK/VKHelpers.h         |  1 +
 rpcs3/Emu/RSX/VK/VKRenderTargets.cpp | 83 +++++++++++++++++++++-------
 rpcs3/Emu/RSX/VK/VKTexture.cpp       | 29 ++++++++--
 rpcs3/Emu/RSX/VK/VKTextureCache.cpp  |  1 +
 rpcs3/io_buffer.h                    | 16 +++++-
 5 files changed, 104 insertions(+), 26 deletions(-)

diff --git a/rpcs3/Emu/RSX/VK/VKHelpers.h b/rpcs3/Emu/RSX/VK/VKHelpers.h
index 3b87ba46dad..63973a785a4 100644
--- a/rpcs3/Emu/RSX/VK/VKHelpers.h
+++ b/rpcs3/Emu/RSX/VK/VKHelpers.h
@@ -75,6 +75,7 @@ namespace vk
 		upload_contents_async   = 1,
 		initialize_image_layout = 2,
 		preserve_image_layout   = 4,
+		source_is_gpu_resident  = 8,
 
 		// meta-flags
 		upload_contents_inline    = 0,
diff --git a/rpcs3/Emu/RSX/VK/VKRenderTargets.cpp b/rpcs3/Emu/RSX/VK/VKRenderTargets.cpp
index f19908d7645..db9a51962ee 100644
--- a/rpcs3/Emu/RSX/VK/VKRenderTargets.cpp
+++ b/rpcs3/Emu/RSX/VK/VKRenderTargets.cpp
@@ -1,3 +1,5 @@
+#include "VKCompute.h"
+#include "VKDMA.h"
 #include "VKRenderTargets.h"
 #include "VKResourceManager.h"
 #include "Emu/RSX/rsx_methods.h"
@@ -681,32 +683,75 @@ namespace vk
 		subres.depth = 1;
 		subres.data = { vm::get_super_ptr<const std::byte>(base_addr), static_cast<std::span<const std::byte>::size_type>(rsx_pitch * surface_height * samples_y) };
 
-		// FIXME: Move to GPU queue
-		std::vector<std::byte> ext_data;
 		const auto range = get_memory_range();
+		rsx::flags32_t upload_flags = upload_contents_inline;
+		u32 heap_align = rsx_pitch;
 
-		if (auto region = rsx::get_current_renderer()->get_tiled_memory_region(range))
+		if (auto tiled_region = rsx::get_current_renderer()->get_tiled_memory_region(range))
 		{
-			auto real_data = vm::get_super_ptr<u8>(range.start);
-			ext_data.resize(region.tile->size);
-			rsx::tile_texel_data<u32, true>(
-				ext_data.data(),
-				real_data,
-				region.base_address,
-				range.start - region.base_address,
-				region.tile->size,
-				region.tile->bank,
-				region.tile->pitch,
-				subres.width_in_block,
-				subres.height_in_block
-			);
-			subres.data = std::span(ext_data);
+			const auto available_tile_size = tiled_region.tile->size - (range.start - tiled_region.base_address);
+			const auto max_content_size = tiled_region.tile->pitch * utils::align<u32>(subres.height_in_block, 64);
+			const auto section_length = std::min(max_content_size, available_tile_size);
+
+			const auto dma_mapping = vk::map_dma(range.start, section_length);
+			const auto scratch_buf = vk::get_scratch_buffer(cmd, section_length * 3); // 0 = linear data, 1 = padding (deswz), 2 = tiled data
+			const auto tiled_data_scratch_offset = section_length * 2;
+			const auto linear_data_scratch_offset = 0;
+
+			// Schedule the job
+			const RSX_detiler_config config =
+			{
+				.tile_base_address = tiled_region.base_address,
+				.tile_base_offset = range.start - tiled_region.base_address,
+				.tile_size = tiled_region.tile->size,
+				.tile_pitch = tiled_region.tile->pitch,
+				.bank = tiled_region.tile->bank,
+
+				.dst = scratch_buf,
+				.dst_offset = linear_data_scratch_offset,
+				.src = scratch_buf,
+				.src_offset = section_length * 2,
+
+				.image_width = subres.width_in_block,
+				.image_height = subres.height_in_block,
+				.image_pitch = subres.width_in_block * static_cast<u32>(get_bpp()),
+				.image_bpp = get_bpp()
+			};
+
+			// Transfer
+			VkBufferCopy copy_rgn
+			{
+				.srcOffset = dma_mapping.first,
+				.dstOffset = tiled_data_scratch_offset,
+				.size = section_length
+			};
+			vkCmdCopyBuffer(cmd, dma_mapping.second->value, scratch_buf->value, 1, &copy_rgn);
+
+			// Barrier
+			vk::insert_buffer_memory_barrier(
+				cmd, scratch_buf->value, linear_data_scratch_offset, section_length,
+				VK_PIPELINE_STAGE_TRANSFER_BIT, VK_PIPELINE_STAGE_COMPUTE_SHADER_BIT,
+				VK_ACCESS_TRANSFER_WRITE_BIT, VK_ACCESS_SHADER_READ_BIT);
+
+			// Detile
+			vk::get_compute_task<vk::cs_tile_memcpy<RSX_detiler_op::decode>>()->run(cmd, config);
+
+			// Barrier
+			vk::insert_buffer_memory_barrier(
+				cmd, scratch_buf->value, linear_data_scratch_offset, subres.width_in_block * get_bpp() * subres.height_in_block,
+				VK_PIPELINE_STAGE_COMPUTE_SHADER_BIT, VK_PIPELINE_STAGE_TRANSFER_BIT | VK_PIPELINE_STAGE_COMPUTE_SHADER_BIT,
+				VK_ACCESS_SHADER_WRITE_BIT, VK_ACCESS_SHADER_READ_BIT | VK_ACCESS_TRANSFER_READ_BIT);
+
+			// FIXME: !!EVIL!!
+			subres.data = { scratch_buf, linear_data_scratch_offset };
+			upload_flags |= source_is_gpu_resident;
+			heap_align = subres.width_in_block * get_bpp();
 		}
 
 		if (g_cfg.video.resolution_scale_percent == 100 && spp == 1) [[likely]]
 		{
 			push_layout(cmd, VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL);
-			vk::upload_image(cmd, this, { subres }, get_gcm_format(), is_swizzled, 1, aspect(), upload_heap, rsx_pitch, upload_contents_inline);
+			vk::upload_image(cmd, this, { subres }, get_gcm_format(), is_swizzled, 1, aspect(), upload_heap, heap_align, upload_flags);
 			pop_layout(cmd);
 		}
 		else
@@ -735,7 +780,7 @@ namespace vk
 			}
 
 			// Load Cell data into temp buffer
-			vk::upload_image(cmd, content, { subres }, get_gcm_format(), is_swizzled, 1, aspect(), upload_heap, rsx_pitch, upload_contents_inline);
+			vk::upload_image(cmd, content, { subres }, get_gcm_format(), is_swizzled, 1, aspect(), upload_heap, heap_align, upload_flags);
 
 			// Write into final image
 			if (content != final_dst)
diff --git a/rpcs3/Emu/RSX/VK/VKTexture.cpp b/rpcs3/Emu/RSX/VK/VKTexture.cpp
index 5de83a08fe8..770381767da 100644
--- a/rpcs3/Emu/RSX/VK/VKTexture.cpp
+++ b/rpcs3/Emu/RSX/VK/VKTexture.cpp
@@ -1009,13 +1009,19 @@ namespace vk
 			{
 				caps.supports_byteswap = (image_linear_size >= 1024);
 				caps.supports_hw_deswizzle = caps.supports_byteswap;
-				caps.supports_zero_copy = false;// caps.supports_byteswap;
+				caps.supports_zero_copy = caps.supports_byteswap;
 				caps.supports_vtc_decoding = false;
 				check_caps = false;
 			}
 
 			auto buf_allocator = [&]() -> std::tuple<void*, usz>
 			{
+				if (image_setup_flags & source_is_gpu_resident)
+				{
+					// We should never reach here, unless something is very wrong...
+					fmt::throw_exception("Cannot allocate CPU memory for GPU-only data");
+				}
+
 				// Map with extra padding bytes in case of realignment
 				offset_in_upload_buffer = upload_heap.alloc<512>(image_linear_size + 8);
 				void* mapped_buffer = upload_heap.map(offset_in_upload_buffer, image_linear_size + 8);
@@ -1026,6 +1032,21 @@ namespace vk
 			opt = upload_texture_subresource(io_buf, layout, format, is_swizzled, caps);
 			upload_heap.unmap();
 
+			if (image_setup_flags & source_is_gpu_resident)
+			{
+				// Read from GPU buf if the input is already uploaded.
+				auto [iobuf, io_offset] = layout.data.raw();
+				upload_buffer = static_cast<buffer*>(iobuf);
+				offset_in_upload_buffer = io_offset;
+				// Never upload. Data is already resident.
+				opt.require_upload = false;
+			}
+			else
+			{
+				// Read from upload buffer
+				upload_buffer = upload_heap.heap.get();
+			}
+
 			copy_regions.push_back({});
 			auto& copy_info = copy_regions.back();
 			copy_info.bufferOffset = offset_in_upload_buffer;
@@ -1038,8 +1059,6 @@ namespace vk
 			copy_info.imageSubresource.mipLevel = layout.level;
 			copy_info.bufferRowLength = upload_pitch_in_texel;
 
-			upload_buffer = upload_heap.heap.get();
-
 			if (opt.require_upload)
 			{
 				ensure(!opt.deferred_cmds.empty());
@@ -1117,7 +1136,7 @@ namespace vk
 						copy.size = copy_cmd.length;
 					}
 				}
-				else
+				else if (upload_buffer != scratch_buf || offset_in_upload_buffer != scratch_offset)
 				{
 					buffer_copies.push_back({});
 					auto& copy = buffer_copies.back();
@@ -1163,7 +1182,7 @@ namespace vk
 					range_ptr += op.second;
 				}
 			}
-			else
+			else if (!buffer_copies.empty())
 			{
 				vkCmdCopyBuffer(cmd2, upload_buffer->value, scratch_buf->value, static_cast<u32>(buffer_copies.size()), buffer_copies.data());
 			}
diff --git a/rpcs3/Emu/RSX/VK/VKTextureCache.cpp b/rpcs3/Emu/RSX/VK/VKTextureCache.cpp
index 0f6a2804eaa..7b1f69f92ed 100644
--- a/rpcs3/Emu/RSX/VK/VKTextureCache.cpp
+++ b/rpcs3/Emu/RSX/VK/VKTextureCache.cpp
@@ -194,6 +194,7 @@ namespace vk
 					.src = working_buffer,
 					.src_offset = 0,
 
+					// TODO: Check interaction with anti-aliasing
 					.image_width = width,
 					.image_height = height,
 					.image_pitch = real_pitch,
diff --git a/rpcs3/io_buffer.h b/rpcs3/io_buffer.h
index 945bdc9c906..876d885f591 100644
--- a/rpcs3/io_buffer.h
+++ b/rpcs3/io_buffer.h
@@ -22,15 +22,22 @@ namespace rsx
 		mutable void* m_ptr = nullptr;
 		mutable usz m_size = 0;
 
-		std::function<std::tuple<void*, usz> ()> m_allocator = nullptr;
+		std::function<std::tuple<void*, usz>()> m_allocator{};
 
 	public:
 		io_buffer() = default;
 
+		io_buffer(const io_buffer& that)
+		{
+			m_ptr = that.m_ptr;
+			m_size = that.m_size;
+			m_allocator = that.m_allocator;
+		}
+
 		template <SpanLike T>
 		io_buffer(const T& container)
 		{
-			m_ptr = reinterpret_cast<void*>(container.data());
+			m_ptr = const_cast<void*>(reinterpret_cast<const void*>(container.data()));
 			m_size = container.size_bytes();
 		}
 
@@ -50,6 +57,11 @@ namespace rsx
 			: m_ptr(const_cast<void*>(ptr)), m_size(size)
 		{}
 
+		std::pair<void*, usz> raw() const
+		{
+			return { m_ptr, m_size };
+		}
+
 		template <Integral T = u8>
 		T* data() const
 		{

From 7dd4438432d3a4b2bc79ca340b021230d3d3ff44 Mon Sep 17 00:00:00 2001
From: kd-11 <karokidii@gmail.com>
Date: Thu, 14 Sep 2023 20:24:44 +0300
Subject: [PATCH 07/13] vk: Load DMA before decode operation

---
 rpcs3/Emu/RSX/VK/VKRenderTargets.cpp | 1 +
 1 file changed, 1 insertion(+)

diff --git a/rpcs3/Emu/RSX/VK/VKRenderTargets.cpp b/rpcs3/Emu/RSX/VK/VKRenderTargets.cpp
index db9a51962ee..74b7f565e4e 100644
--- a/rpcs3/Emu/RSX/VK/VKRenderTargets.cpp
+++ b/rpcs3/Emu/RSX/VK/VKRenderTargets.cpp
@@ -693,6 +693,7 @@ namespace vk
 			const auto max_content_size = tiled_region.tile->pitch * utils::align<u32>(subres.height_in_block, 64);
 			const auto section_length = std::min(max_content_size, available_tile_size);
 
+			vk::load_dma(range.start, section_length);
 			const auto dma_mapping = vk::map_dma(range.start, section_length);
 			const auto scratch_buf = vk::get_scratch_buffer(cmd, section_length * 3); // 0 = linear data, 1 = padding (deswz), 2 = tiled data
 			const auto tiled_data_scratch_offset = section_length * 2;

From 752f253366c3b8e608d33fca8e003be67d3d88de Mon Sep 17 00:00:00 2001
From: kd-11 <karokidii@gmail.com>
Date: Thu, 14 Sep 2023 20:41:00 +0300
Subject: [PATCH 08/13] Fix linux build

---
 rpcs3/Emu/CMakeLists.txt | 1 +
 1 file changed, 1 insertion(+)

diff --git a/rpcs3/Emu/CMakeLists.txt b/rpcs3/Emu/CMakeLists.txt
index b1673a80779..70df0385bf2 100644
--- a/rpcs3/Emu/CMakeLists.txt
+++ b/rpcs3/Emu/CMakeLists.txt
@@ -473,6 +473,7 @@ target_sources(rpcs3_emu PRIVATE
     RSX/Common/surface_store.cpp
     RSX/Common/TextureUtils.cpp
     RSX/Common/texture_cache.cpp
+    RSX/Core/RSXContext.cpp
     RSX/Null/NullGSRender.cpp
     RSX/Overlays/HomeMenu/overlay_home_menu.cpp
     RSX/Overlays/HomeMenu/overlay_home_menu_components.cpp

From 41bdeb20a5cef8a018d2dd23c492a753c616826c Mon Sep 17 00:00:00 2001
From: kd-11 <karokidii@gmail.com>
Date: Thu, 14 Sep 2023 20:50:20 +0300
Subject: [PATCH 09/13] Fix msvc filters

---
 rpcs3/emucore.vcxproj.filters | 3 +++
 1 file changed, 3 insertions(+)

diff --git a/rpcs3/emucore.vcxproj.filters b/rpcs3/emucore.vcxproj.filters
index de842b58454..87ef6910e7a 100644
--- a/rpcs3/emucore.vcxproj.filters
+++ b/rpcs3/emucore.vcxproj.filters
@@ -2337,6 +2337,9 @@
     </ClInclude>
     <ClInclude Include="io_buffer.h">
       <Filter>Emu\GPU\RSX\Common</Filter>
+    </ClInclude>
+	<ClInclude Include="Emu\RSX\Common\tiled_dma_copy.hpp">
+      <Filter>Emu\GPU\RSX\Common</Filter>
     </ClInclude>
     <ClInclude Include="Emu\games_config.h">
       <Filter>Emu</Filter>

From 0b0db05ca29cd6179cae66d4408cf26f5b2bb986 Mon Sep 17 00:00:00 2001
From: kd-11 <karokidii@gmail.com>
Date: Thu, 14 Sep 2023 21:02:00 +0300
Subject: [PATCH 10/13] vk: Restore CPU fallback on the upload path

---
 rpcs3/Emu/RSX/Common/tiled_dma_copy.hpp |  3 +++
 rpcs3/Emu/RSX/VK/VKRenderTargets.cpp    | 21 +++++++++++++++++++++
 rpcs3/Emu/RSX/VK/VKTextureCache.h       |  7 +------
 3 files changed, 25 insertions(+), 6 deletions(-)

diff --git a/rpcs3/Emu/RSX/Common/tiled_dma_copy.hpp b/rpcs3/Emu/RSX/Common/tiled_dma_copy.hpp
index 28f4577085e..33d35abbbd4 100644
--- a/rpcs3/Emu/RSX/Common/tiled_dma_copy.hpp
+++ b/rpcs3/Emu/RSX/Common/tiled_dma_copy.hpp
@@ -3,6 +3,9 @@
 #include <util/types.hpp>
 #include <cstdint>
 
+// Set this to 1 to force all decoding to be done on the CPU.
+#define DEBUG_DMA_TILING 0
+
 // This is a 1:1 port of the GPU code for my own sanity when debugging misplaced bits
 // For a high-level explanation, read https://envytools.readthedocs.io/en/latest/hw/memory/vram.html
 namespace rsx
diff --git a/rpcs3/Emu/RSX/VK/VKRenderTargets.cpp b/rpcs3/Emu/RSX/VK/VKRenderTargets.cpp
index 74b7f565e4e..7ac76fe8f7f 100644
--- a/rpcs3/Emu/RSX/VK/VKRenderTargets.cpp
+++ b/rpcs3/Emu/RSX/VK/VKRenderTargets.cpp
@@ -687,8 +687,28 @@ namespace vk
 		rsx::flags32_t upload_flags = upload_contents_inline;
 		u32 heap_align = rsx_pitch;
 
+#if DEBUG_DMA_TILING
+		std::vector<u8> ext_data;
+#endif
+
 		if (auto tiled_region = rsx::get_current_renderer()->get_tiled_memory_region(range))
 		{
+#if DEBUG_DMA_TILING
+			auto real_data = vm::get_super_ptr<u8>(range.start);
+			ext_data.resize(tiled_region.tile->size);
+			rsx::tile_texel_data<u32, true>(
+				ext_data.data(),
+				real_data,
+				tiled_region.base_address,
+				range.start - tiled_region.base_address,
+				tiled_region.tile->size,
+				tiled_region.tile->bank,
+				tiled_region.tile->pitch,
+				subres.width_in_block,
+				subres.height_in_block
+				);
+			subres.data = std::span(ext_data);
+#else
 			const auto available_tile_size = tiled_region.tile->size - (range.start - tiled_region.base_address);
 			const auto max_content_size = tiled_region.tile->pitch * utils::align<u32>(subres.height_in_block, 64);
 			const auto section_length = std::min(max_content_size, available_tile_size);
@@ -747,6 +767,7 @@ namespace vk
 			subres.data = { scratch_buf, linear_data_scratch_offset };
 			upload_flags |= source_is_gpu_resident;
 			heap_align = subres.width_in_block * get_bpp();
+#endif
 		}
 
 		if (g_cfg.video.resolution_scale_percent == 100 && spp == 1) [[likely]]
diff --git a/rpcs3/Emu/RSX/VK/VKTextureCache.h b/rpcs3/Emu/RSX/VK/VKTextureCache.h
index f418f761a7c..5c4d87b5879 100644
--- a/rpcs3/Emu/RSX/VK/VKTextureCache.h
+++ b/rpcs3/Emu/RSX/VK/VKTextureCache.h
@@ -8,18 +8,13 @@
 #include "vkutils/image_helpers.h"
 
 #include "../Common/texture_cache.h"
+#include "../Common/tiled_dma_copy.hpp"
 
 #include "Emu/Cell/timers.hpp"
 
 #include <memory>
 #include <vector>
 
-#define DEBUG_DMA_TILING 0
-
-#if DEBUG_DMA_TILING
-#include "../Common/tiled_dma_copy.hpp"
-#endif
-
 namespace vk
 {
 	class cached_texture_section;

From ceb5b4158049337c018c3094572d65936bf3885a Mon Sep 17 00:00:00 2001
From: kd-11 <karokidii@gmail.com>
Date: Thu, 14 Sep 2023 21:09:14 +0300
Subject: [PATCH 11/13] vk: Remove debug visualization code

---
 rpcs3/Emu/RSX/VK/VKPresent.cpp | 18 +-----------------
 1 file changed, 1 insertion(+), 17 deletions(-)

diff --git a/rpcs3/Emu/RSX/VK/VKPresent.cpp b/rpcs3/Emu/RSX/VK/VKPresent.cpp
index 4cbf0a90659..2f69505b962 100644
--- a/rpcs3/Emu/RSX/VK/VKPresent.cpp
+++ b/rpcs3/Emu/RSX/VK/VKPresent.cpp
@@ -14,11 +14,6 @@
 extern atomic_t<bool> g_user_asked_for_screenshot;
 extern atomic_t<recording_mode> g_recording_mode;
 
-namespace vk
-{
-	u32 g_debug_vis_address = 0;
-}
-
 void VKGSRender::reinitialize_swapchain()
 {
 	m_swapchain_dims.width = m_frame->client_width();
@@ -482,18 +477,7 @@ void VKGSRender::flip(const rsx::display_flip_info_t& info)
 		present_info.format = av_format;
 		present_info.address = rsx::get_address(display_buffers[info.buffer].offset, CELL_GCM_LOCATION_LOCAL);
 
-		if (vk::g_debug_vis_address)
-		{
-			//std::vector<u8> temp_data(5120 * 1024);
-			//std::memcpy(temp_data.data(), vm::get_super_ptr(vk::g_debug_vis_address), 5120 * 1024);
-			//rsx::untile_texel_data<u32>(vm::get_super_ptr(vk::g_debug_vis_address), temp_data.data(), vk::g_debug_vis_address, 0, 0, 5120, 1280, 720);
-			image_to_flip = m_texture_cache.upload_image_simple(*m_current_command_buffer, VK_FORMAT_B8G8R8A8_UNORM, vk::g_debug_vis_address, 1280, 720, 5120);
-			vk::g_debug_vis_address = 0;
-		}
-		else
-		{
-			image_to_flip = get_present_source(&present_info, avconfig);
-		}
+		image_to_flip = get_present_source(&present_info, avconfig);
 
 		if (avconfig.stereo_mode != stereo_render_mode_options::disabled) [[unlikely]]
 		{

From 70abc8835989a194ee72a4317020b7adaa96c6b3 Mon Sep 17 00:00:00 2001
From: kd-11 <karokidii@gmail.com>
Date: Thu, 14 Sep 2023 21:12:19 +0300
Subject: [PATCH 12/13] vk: Revert more debugging code

---
 rpcs3/Emu/RSX/VK/VKTextureCache.cpp | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/rpcs3/Emu/RSX/VK/VKTextureCache.cpp b/rpcs3/Emu/RSX/VK/VKTextureCache.cpp
index 7b1f69f92ed..fd3bf407968 100644
--- a/rpcs3/Emu/RSX/VK/VKTextureCache.cpp
+++ b/rpcs3/Emu/RSX/VK/VKTextureCache.cpp
@@ -1396,7 +1396,7 @@ namespace vk
 
 		void* mem = image->memory->map(0, layout.rowPitch * height);
 
-		auto src = vm::get_super_ptr<const char>(address);
+		auto src = vm::_ptr<const char>(address);
 		auto dst = static_cast<char*>(mem);
 
 		// TODO: SSE optimization

From 7170e1c07206941e97a798de5c02a3d42ded8e32 Mon Sep 17 00:00:00 2001
From: kd-11 <karokidii@gmail.com>
Date: Thu, 14 Sep 2023 21:31:20 +0300
Subject: [PATCH 13/13] rsx::io_buffer cleanup

---
 rpcs3/{ => Emu/RSX/Common}/io_buffer.h | 7 -------
 rpcs3/emucore.vcxproj                  | 2 +-
 rpcs3/emucore.vcxproj.filters          | 2 +-
 3 files changed, 2 insertions(+), 9 deletions(-)
 rename rpcs3/{ => Emu/RSX/Common}/io_buffer.h (87%)

diff --git a/rpcs3/io_buffer.h b/rpcs3/Emu/RSX/Common/io_buffer.h
similarity index 87%
rename from rpcs3/io_buffer.h
rename to rpcs3/Emu/RSX/Common/io_buffer.h
index 876d885f591..7029608f6e4 100644
--- a/rpcs3/io_buffer.h
+++ b/rpcs3/Emu/RSX/Common/io_buffer.h
@@ -27,13 +27,6 @@ namespace rsx
 	public:
 		io_buffer() = default;
 
-		io_buffer(const io_buffer& that)
-		{
-			m_ptr = that.m_ptr;
-			m_size = that.m_size;
-			m_allocator = that.m_allocator;
-		}
-
 		template <SpanLike T>
 		io_buffer(const T& container)
 		{
diff --git a/rpcs3/emucore.vcxproj b/rpcs3/emucore.vcxproj
index 8b22fd6b694..5e7215434c1 100644
--- a/rpcs3/emucore.vcxproj
+++ b/rpcs3/emucore.vcxproj
@@ -553,6 +553,7 @@
     <ClInclude Include="Emu\RSX\Common\buffer_stream.hpp" />
     <ClInclude Include="Emu\RSX\Common\tiled_dma_copy.hpp" />
     <ClInclude Include="Emu\RSX\Common\expected.hpp" />
+    <ClInclude Include="Emu\RSX\Common\io_buffer.h" />
     <ClInclude Include="Emu\RSX\Common\profiling_timer.hpp" />
     <ClInclude Include="Emu\RSX\Common\ranged_map.hpp" />
     <ClInclude Include="Emu\RSX\Common\simple_array.hpp" />
@@ -612,7 +613,6 @@
     <ClInclude Include="Emu\vfs_config.h" />
     <ClInclude Include="Loader\disc.h" />
     <ClInclude Include="Loader\mself.hpp" />
-    <ClInclude Include="io_buffer.h" />
     <ClInclude Include="util\atomic.hpp" />
     <ClInclude Include="util\bless.hpp" />
     <ClInclude Include="util\image_sink.h" />
diff --git a/rpcs3/emucore.vcxproj.filters b/rpcs3/emucore.vcxproj.filters
index 87ef6910e7a..288c31d939d 100644
--- a/rpcs3/emucore.vcxproj.filters
+++ b/rpcs3/emucore.vcxproj.filters
@@ -2335,7 +2335,7 @@
     <ClInclude Include="Emu\NP\upnp_config.h">
       <Filter>Emu\NP</Filter>
     </ClInclude>
-    <ClInclude Include="io_buffer.h">
+    <ClInclude Include="Emu\RSX\Common\io_buffer.h">
       <Filter>Emu\GPU\RSX\Common</Filter>
     </ClInclude>
 	<ClInclude Include="Emu\RSX\Common\tiled_dma_copy.hpp">
