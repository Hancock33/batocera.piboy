diff --git a/Externals/fmt/CMakeLists.txt b/Externals/fmt/CMakeLists.txt
index 4ea516f85b3a..2b4e30dc32d1 100755
--- a/Externals/fmt/CMakeLists.txt
+++ b/Externals/fmt/CMakeLists.txt
@@ -1,388 +1,2 @@
-cmake_minimum_required(VERSION 3.1...3.18)
-
-# Fallback for using newer policies on CMake <3.12.
-if(${CMAKE_VERSION} VERSION_LESS 3.12)
-  cmake_policy(VERSION ${CMAKE_MAJOR_VERSION}.${CMAKE_MINOR_VERSION})
-endif()
-
-# Determine if fmt is built as a subproject (using add_subdirectory)
-# or if it is the master project.
-if (NOT DEFINED FMT_MASTER_PROJECT)
-  set(FMT_MASTER_PROJECT OFF)
-  if (CMAKE_CURRENT_SOURCE_DIR STREQUAL CMAKE_SOURCE_DIR)
-    set(FMT_MASTER_PROJECT ON)
-    message(STATUS "CMake version: ${CMAKE_VERSION}")
-  endif ()
-endif ()
-
-# Joins arguments and places the results in ${result_var}.
-function(join result_var)
-  set(result "")
-  foreach (arg ${ARGN})
-    set(result "${result}${arg}")
-  endforeach ()
-  set(${result_var} "${result}" PARENT_SCOPE)
-endfunction()
-
-function(enable_module target)
-  if (MSVC)
-    set(BMI ${CMAKE_CURRENT_BINARY_DIR}/${target}.ifc)
-    target_compile_options(${target}
-      PRIVATE /interface /ifcOutput ${BMI}
-      INTERFACE /reference fmt=${BMI})
-  endif ()
-  set_target_properties(${target} PROPERTIES ADDITIONAL_CLEAN_FILES ${BMI})
-  set_source_files_properties(${BMI} PROPERTIES GENERATED ON)
-endfunction()
-
-include(CMakeParseArguments)
-
-# Sets a cache variable with a docstring joined from multiple arguments:
-#   set(<variable> <value>... CACHE <type> <docstring>...)
-# This allows splitting a long docstring for readability.
-function(set_verbose)
-  # cmake_parse_arguments is broken in CMake 3.4 (cannot parse CACHE) so use
-  # list instead.
-  list(GET ARGN 0 var)
-  list(REMOVE_AT ARGN 0)
-  list(GET ARGN 0 val)
-  list(REMOVE_AT ARGN 0)
-  list(REMOVE_AT ARGN 0)
-  list(GET ARGN 0 type)
-  list(REMOVE_AT ARGN 0)
-  join(doc ${ARGN})
-  set(${var} ${val} CACHE ${type} ${doc})
-endfunction()
-
-# Set the default CMAKE_BUILD_TYPE to Release.
-# This should be done before the project command since the latter can set
-# CMAKE_BUILD_TYPE itself (it does so for nmake).
-if (FMT_MASTER_PROJECT AND NOT CMAKE_BUILD_TYPE)
-  set_verbose(CMAKE_BUILD_TYPE Release CACHE STRING
-              "Choose the type of build, options are: None(CMAKE_CXX_FLAGS or "
-              "CMAKE_C_FLAGS used) Debug Release RelWithDebInfo MinSizeRel.")
-endif ()
-
-project(FMT CXX)
-include(GNUInstallDirs)
-set_verbose(FMT_INC_DIR ${CMAKE_INSTALL_INCLUDEDIR} CACHE STRING
-            "Installation directory for include files, a relative path that "
-            "will be joined with ${CMAKE_INSTALL_PREFIX} or an absolute path.")
-
-option(FMT_PEDANTIC "Enable extra warnings and expensive tests." OFF)
-option(FMT_WERROR "Halt the compilation with an error on compiler warnings."
-       OFF)
-
-# Options that control generation of various targets.
-option(FMT_DOC "Generate the doc target." ${FMT_MASTER_PROJECT})
-option(FMT_INSTALL "Generate the install target." ${FMT_MASTER_PROJECT})
-option(FMT_TEST "Generate the test target." ${FMT_MASTER_PROJECT})
-option(FMT_FUZZ "Generate the fuzz target." OFF)
-option(FMT_CUDA_TEST "Generate the cuda-test target." OFF)
-option(FMT_OS "Include core requiring OS (Windows/Posix) " ON)
-option(FMT_MODULE "Build a module instead of a traditional library." OFF)
-option(FMT_SYSTEM_HEADERS "Expose headers with marking them as system." OFF)
-
-set(FMT_CAN_MODULE OFF)
-if (CMAKE_CXX_STANDARD GREATER 17 AND
-    # msvc 16.10-pre4
-    MSVC AND CMAKE_CXX_COMPILER_VERSION VERSION_GREATER 19.29.30035)
-  set(FMT_CAN_MODULE OFF)
-endif ()
-if (NOT FMT_CAN_MODULE)
-  set(FMT_MODULE OFF)
-  message(STATUS "Module support is disabled.")
-endif ()
-if (FMT_TEST AND FMT_MODULE)
-  # The tests require {fmt} to be compiled as traditional library
-  message(STATUS "Testing is incompatible with build mode 'module'.")
-endif ()
-set(FMT_SYSTEM_HEADERS_ATTRIBUTE "")
-if (FMT_SYSTEM_HEADERS)
-  set(FMT_SYSTEM_HEADERS_ATTRIBUTE SYSTEM)
-endif ()
-
-# Get version from core.h
-file(READ include/fmt/core.h core_h)
-if (NOT core_h MATCHES "FMT_VERSION ([0-9]+)([0-9][0-9])([0-9][0-9])")
-  message(FATAL_ERROR "Cannot get FMT_VERSION from core.h.")
-endif ()
-# Use math to skip leading zeros if any.
-math(EXPR CPACK_PACKAGE_VERSION_MAJOR ${CMAKE_MATCH_1})
-math(EXPR CPACK_PACKAGE_VERSION_MINOR ${CMAKE_MATCH_2})
-math(EXPR CPACK_PACKAGE_VERSION_PATCH ${CMAKE_MATCH_3})
-join(FMT_VERSION ${CPACK_PACKAGE_VERSION_MAJOR}.${CPACK_PACKAGE_VERSION_MINOR}.
-                 ${CPACK_PACKAGE_VERSION_PATCH})
-message(STATUS "Version: ${FMT_VERSION}")
-
-message(STATUS "Build type: ${CMAKE_BUILD_TYPE}")
-
-if (NOT CMAKE_RUNTIME_OUTPUT_DIRECTORY)
-  set(CMAKE_RUNTIME_OUTPUT_DIRECTORY ${CMAKE_BINARY_DIR}/bin)
-endif ()
-
-set(CMAKE_MODULE_PATH ${CMAKE_MODULE_PATH}
-  "${CMAKE_CURRENT_SOURCE_DIR}/support/cmake")
-
-include(cxx14)
-include(JoinPaths)
-
-list(FIND CMAKE_CXX_COMPILE_FEATURES "cxx_variadic_templates" index)
-if (${index} GREATER -1)
-  # Use cxx_variadic_templates instead of more appropriate cxx_std_11 for
-  # compatibility with older CMake versions.
-  set(FMT_REQUIRED_FEATURES cxx_variadic_templates)
-endif ()
-message(STATUS "Required features: ${FMT_REQUIRED_FEATURES}")
-
-if (FMT_MASTER_PROJECT AND NOT DEFINED CMAKE_CXX_VISIBILITY_PRESET)
-  set_verbose(CMAKE_CXX_VISIBILITY_PRESET hidden CACHE STRING
-              "Preset for the export of private symbols")
-  set_property(CACHE CMAKE_CXX_VISIBILITY_PRESET PROPERTY STRINGS
-               hidden default)
-endif ()
-
-if (FMT_MASTER_PROJECT AND NOT DEFINED CMAKE_VISIBILITY_INLINES_HIDDEN)
-  set_verbose(CMAKE_VISIBILITY_INLINES_HIDDEN ON CACHE BOOL
-              "Whether to add a compile flag to hide symbols of inline functions")
-endif ()
-
-if (CMAKE_CXX_COMPILER_ID MATCHES "GNU")
-  set(PEDANTIC_COMPILE_FLAGS -pedantic-errors -Wall -Wextra -pedantic
-      -Wold-style-cast -Wundef
-      -Wredundant-decls -Wwrite-strings -Wpointer-arith
-      -Wcast-qual -Wformat=2 -Wmissing-include-dirs
-      -Wcast-align
-      -Wctor-dtor-privacy -Wdisabled-optimization
-      -Winvalid-pch -Woverloaded-virtual
-      -Wconversion -Wundef
-      -Wno-ctor-dtor-privacy -Wno-format-nonliteral)
-  if (NOT CMAKE_CXX_COMPILER_VERSION VERSION_LESS 4.6)
-      set(PEDANTIC_COMPILE_FLAGS ${PEDANTIC_COMPILE_FLAGS}
-         -Wno-dangling-else -Wno-unused-local-typedefs)
-  endif ()
-  if (NOT CMAKE_CXX_COMPILER_VERSION VERSION_LESS 5.0)
-      set(PEDANTIC_COMPILE_FLAGS ${PEDANTIC_COMPILE_FLAGS} -Wdouble-promotion
-          -Wtrampolines -Wzero-as-null-pointer-constant -Wuseless-cast
-          -Wvector-operation-performance -Wsized-deallocation -Wshadow)
-  endif ()
-  if (NOT CMAKE_CXX_COMPILER_VERSION VERSION_LESS 6.0)
-      set(PEDANTIC_COMPILE_FLAGS ${PEDANTIC_COMPILE_FLAGS} -Wshift-overflow=2
-          -Wnull-dereference -Wduplicated-cond)
-  endif ()
-  set(WERROR_FLAG -Werror)
-endif ()
-
-if (CMAKE_CXX_COMPILER_ID MATCHES "Clang")
-  set(PEDANTIC_COMPILE_FLAGS -Wall -Wextra -pedantic -Wconversion -Wundef
-      -Wdeprecated -Wweak-vtables -Wshadow
-      -Wno-gnu-zero-variadic-macro-arguments)
-  check_cxx_compiler_flag(-Wzero-as-null-pointer-constant HAS_NULLPTR_WARNING)
-  if (HAS_NULLPTR_WARNING)
-    set(PEDANTIC_COMPILE_FLAGS ${PEDANTIC_COMPILE_FLAGS}
-        -Wzero-as-null-pointer-constant)
-  endif ()
-  set(WERROR_FLAG -Werror)
-endif ()
-
-if (MSVC)
-  set(PEDANTIC_COMPILE_FLAGS /W3)
-  set(WERROR_FLAG /WX)
-endif ()
-
-if (FMT_MASTER_PROJECT AND CMAKE_GENERATOR MATCHES "Visual Studio")
-  # If Microsoft SDK is installed create script run-msbuild.bat that
-  # calls SetEnv.cmd to set up build environment and runs msbuild.
-  # It is useful when building Visual Studio projects with the SDK
-  # toolchain rather than Visual Studio.
-  include(FindSetEnv)
-  if (WINSDK_SETENV)
-    set(MSBUILD_SETUP "call \"${WINSDK_SETENV}\"")
-  endif ()
-  # Set FrameworkPathOverride to get rid of MSB3644 warnings.
-  join(netfxpath
-       "C:\\Program Files\\Reference Assemblies\\Microsoft\\Framework\\"
-       ".NETFramework\\v4.0")
-  file(WRITE run-msbuild.bat "
-    ${MSBUILD_SETUP}
-    ${CMAKE_MAKE_PROGRAM} -p:FrameworkPathOverride=\"${netfxpath}\" %*")
-endif ()
-
-function(add_headers VAR)
-  set(headers ${${VAR}})
-  foreach (header ${ARGN})
-    set(headers ${headers} include/fmt/${header})
-  endforeach()
-  set(${VAR} ${headers} PARENT_SCOPE)
-endfunction()
-
-# Define the fmt library, its includes and the needed defines.
-add_headers(FMT_HEADERS args.h chrono.h color.h compile.h core.h format.h
-                        format-inl.h os.h ostream.h printf.h ranges.h std.h
-                        xchar.h)
-if (FMT_MODULE)
-  set(FMT_SOURCES src/fmt.cc)
-elseif (FMT_OS)
-  set(FMT_SOURCES src/format.cc src/os.cc)
-else()
-  set(FMT_SOURCES src/format.cc)
-endif ()
-
-add_library(fmt ${FMT_SOURCES} ${FMT_HEADERS} README.rst ChangeLog.rst)
+add_subdirectory(fmt)
 dolphin_disable_warnings_msvc(fmt)
-add_library(fmt::fmt ALIAS fmt)
-
-if (FMT_WERROR)
-  target_compile_options(fmt PRIVATE ${WERROR_FLAG})
-endif ()
-if (FMT_PEDANTIC)
-  target_compile_options(fmt PRIVATE ${PEDANTIC_COMPILE_FLAGS})
-endif ()
-if (FMT_MODULE)
-  enable_module(fmt)
-endif ()
-
-target_compile_features(fmt INTERFACE ${FMT_REQUIRED_FEATURES})
-
-target_include_directories(fmt ${FMT_SYSTEM_HEADERS_ATTRIBUTE} PUBLIC
-  $<BUILD_INTERFACE:${PROJECT_SOURCE_DIR}/include>
-  $<INSTALL_INTERFACE:${FMT_INC_DIR}>)
-
-set(FMT_DEBUG_POSTFIX d CACHE STRING "Debug library postfix.")
-
-set_target_properties(fmt PROPERTIES
-  VERSION ${FMT_VERSION} SOVERSION ${CPACK_PACKAGE_VERSION_MAJOR}
-  PUBLIC_HEADER "${FMT_HEADERS}"
-  DEBUG_POSTFIX "${FMT_DEBUG_POSTFIX}")
-
-# Set FMT_LIB_NAME for pkg-config fmt.pc. We cannot use the OUTPUT_NAME target
-# property because it's not set by default.
-set(FMT_LIB_NAME fmt)
-if (CMAKE_BUILD_TYPE STREQUAL "Debug")
-  set(FMT_LIB_NAME ${FMT_LIB_NAME}${FMT_DEBUG_POSTFIX})
-endif ()
-
-if (BUILD_SHARED_LIBS)
-  target_compile_definitions(fmt PRIVATE FMT_EXPORT INTERFACE FMT_SHARED)
-endif ()
-if (FMT_SAFE_DURATION_CAST)
-  target_compile_definitions(fmt PUBLIC FMT_SAFE_DURATION_CAST)
-endif()
-
-add_library(fmt-header-only INTERFACE)
-add_library(fmt::fmt-header-only ALIAS fmt-header-only)
-
-target_compile_definitions(fmt-header-only INTERFACE FMT_HEADER_ONLY=1)
-target_compile_features(fmt-header-only INTERFACE ${FMT_REQUIRED_FEATURES})
-
-target_include_directories(fmt-header-only ${FMT_SYSTEM_HEADERS_ATTRIBUTE} INTERFACE
-  $<BUILD_INTERFACE:${PROJECT_SOURCE_DIR}/include>
-  $<INSTALL_INTERFACE:${FMT_INC_DIR}>)
-
-# Install targets.
-if (FMT_INSTALL)
-  include(CMakePackageConfigHelpers)
-  set_verbose(FMT_CMAKE_DIR ${CMAKE_INSTALL_LIBDIR}/cmake/fmt CACHE STRING
-              "Installation directory for cmake files, a relative path that "
-              "will be joined with ${CMAKE_INSTALL_PREFIX} or an absolute "
-              "path.")
-  set(version_config ${PROJECT_BINARY_DIR}/fmt-config-version.cmake)
-  set(project_config ${PROJECT_BINARY_DIR}/fmt-config.cmake)
-  set(pkgconfig ${PROJECT_BINARY_DIR}/fmt.pc)
-  set(targets_export_name fmt-targets)
-
-  set_verbose(FMT_LIB_DIR ${CMAKE_INSTALL_LIBDIR} CACHE STRING
-              "Installation directory for libraries, a relative path that "
-              "will be joined to ${CMAKE_INSTALL_PREFIX} or an absolute path.")
-
-  set_verbose(FMT_PKGCONFIG_DIR ${CMAKE_INSTALL_LIBDIR}/pkgconfig CACHE PATH
-              "Installation directory for pkgconfig (.pc) files, a relative "
-              "path that will be joined with ${CMAKE_INSTALL_PREFIX} or an "
-              "absolute path.")
-
-  # Generate the version, config and target files into the build directory.
-  write_basic_package_version_file(
-    ${version_config}
-    VERSION ${FMT_VERSION}
-    COMPATIBILITY AnyNewerVersion)
-
-  join_paths(libdir_for_pc_file "\${exec_prefix}" "${FMT_LIB_DIR}")
-  join_paths(includedir_for_pc_file "\${prefix}" "${FMT_INC_DIR}")
-
-  configure_file(
-    "${PROJECT_SOURCE_DIR}/support/cmake/fmt.pc.in"
-    "${pkgconfig}"
-    @ONLY)
-  configure_package_config_file(
-    ${PROJECT_SOURCE_DIR}/support/cmake/fmt-config.cmake.in
-    ${project_config}
-    INSTALL_DESTINATION ${FMT_CMAKE_DIR})
-
-  set(INSTALL_TARGETS fmt fmt-header-only)
-
-  # Install the library and headers.
-  install(TARGETS ${INSTALL_TARGETS} EXPORT ${targets_export_name}
-          LIBRARY DESTINATION ${FMT_LIB_DIR}
-          ARCHIVE DESTINATION ${FMT_LIB_DIR}
-          PUBLIC_HEADER DESTINATION "${FMT_INC_DIR}/fmt"
-          FRAMEWORK DESTINATION "."
-          RUNTIME DESTINATION ${CMAKE_INSTALL_BINDIR})
-
-  # Use a namespace because CMake provides better diagnostics for namespaced
-  # imported targets.
-  export(TARGETS ${INSTALL_TARGETS} NAMESPACE fmt::
-         FILE ${PROJECT_BINARY_DIR}/${targets_export_name}.cmake)
-
-  # Install version, config and target files.
-  install(
-    FILES ${project_config} ${version_config}
-    DESTINATION ${FMT_CMAKE_DIR})
-  install(EXPORT ${targets_export_name} DESTINATION ${FMT_CMAKE_DIR}
-          NAMESPACE fmt::)
-
-  install(FILES $<TARGET_PDB_FILE:${INSTALL_TARGETS}>
-          DESTINATION ${FMT_LIB_DIR} OPTIONAL)
-  install(FILES "${pkgconfig}" DESTINATION "${FMT_PKGCONFIG_DIR}")
-endif ()
-
-if (FMT_DOC)
-  add_subdirectory(doc)
-endif ()
-
-if (FMT_TEST)
-  enable_testing()
-  add_subdirectory(test)
-endif ()
-
-# Control fuzzing independent of the unit tests.
-if (FMT_FUZZ)
-  add_subdirectory(test/fuzzing)
-
-  # The FMT_FUZZ macro is used to prevent resource exhaustion in fuzzing
-  # mode and make fuzzing practically possible. It is similar to
-  # FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION but uses a different name to
-  # avoid interfering with fuzzing of projects that use {fmt}.
-  # See also https://llvm.org/docs/LibFuzzer.html#fuzzer-friendly-build-mode.
-  target_compile_definitions(fmt PUBLIC FMT_FUZZ)
-endif ()
-
-set(gitignore ${PROJECT_SOURCE_DIR}/.gitignore)
-if (FMT_MASTER_PROJECT AND EXISTS ${gitignore})
-  # Get the list of ignored files from .gitignore.
-  file (STRINGS ${gitignore} lines)
-  list(REMOVE_ITEM lines /doc/html)
-  foreach (line ${lines})
-    string(REPLACE "." "[.]" line "${line}")
-    string(REPLACE "*" ".*" line "${line}")
-    set(ignored_files ${ignored_files} "${line}$" "${line}/")
-  endforeach ()
-  set(ignored_files ${ignored_files}
-    /.git /breathe /format-benchmark sphinx/ .buildinfo .doctrees)
-
-  set(CPACK_SOURCE_GENERATOR ZIP)
-  set(CPACK_SOURCE_IGNORE_FILES ${ignored_files})
-  set(CPACK_SOURCE_PACKAGE_FILE_NAME fmt-${FMT_VERSION})
-  set(CPACK_PACKAGE_NAME fmt)
-  set(CPACK_RESOURCE_FILE_README ${PROJECT_SOURCE_DIR}/README.rst)
-  include(CPack)
-endif ()
diff --git a/Externals/fmt/CONTRIBUTING.md b/Externals/fmt/CONTRIBUTING.md
deleted file mode 100644
index b82f145069a8..000000000000
--- a/Externals/fmt/CONTRIBUTING.md
+++ /dev/null
@@ -1,20 +0,0 @@
-Contributing to {fmt}
-=====================
-
-By submitting a pull request or a patch, you represent that you have the right
-to license your contribution to the {fmt} project owners and the community,
-agree that your contributions are licensed under the {fmt} license, and agree
-to future changes to the licensing.
-
-All C++ code must adhere to [Google C++ Style Guide](
-https://google.github.io/styleguide/cppguide.html) with the following
-exceptions:
-
-* Exceptions are permitted
-* snake_case should be used instead of UpperCamelCase for function and type
-  names
-
-All documentation must adhere to the [Google Developer Documentation Style
-Guide](https://developers.google.com/style).
-
-Thanks for contributing!
diff --git a/Externals/fmt/ChangeLog.rst b/Externals/fmt/ChangeLog.rst
deleted file mode 100755
index 4ebc5c733064..000000000000
--- a/Externals/fmt/ChangeLog.rst
+++ /dev/null
@@ -1,5255 +0,0 @@
-9.1.0 - 2022-08-27
-------------------
-
-* ``fmt::formatted_size`` now works at compile time
-  (`#3026 <https://github.com/fmtlib/fmt/pull/3026>`_). For example
-  (`godbolt <https://godbolt.org/z/1MW5rMdf8>`__):
-
-  .. code:: c++
-
-     #include <fmt/compile.h>
-
-     int main() {
-       using namespace fmt::literals;
-       constexpr size_t n = fmt::formatted_size("{}"_cf, 42);
-       fmt::print("{}\n", n); // prints 2
-     }
-
-  Thanks `@marksantaniello (Mark Santaniello)
-  <https://github.com/marksantaniello>`_.
-
-* Fixed handling of invalid UTF-8 
-  (`#3038 <https://github.com/fmtlib/fmt/pull/3038>`_,
-  `#3044 <https://github.com/fmtlib/fmt/pull/3044>`_,
-  `#3056 <https://github.com/fmtlib/fmt/pull/3056>`_).
-  Thanks `@phprus (Vladislav Shchapov) <https://github.com/phprus>`_ and
-  `@skeeto (Christopher Wellons) <https://github.com/skeeto>`_.
-
-* Improved Unicode support in ``ostream`` overloads of ``print``
-  (`#2994 <https://github.com/fmtlib/fmt/pull/2994>`_,
-  `#3001 <https://github.com/fmtlib/fmt/pull/3001>`_,
-  `#3025 <https://github.com/fmtlib/fmt/pull/3025>`_).
-  Thanks `@dimztimz (Dimitrij Mijoski) <https://github.com/dimztimz>`_.
-
-* Fixed handling of the sign specifier in localized formatting on systems with
-  32-bit ``wchar_t`` (`#3041 <https://github.com/fmtlib/fmt/issues/3041>`_).
-
-* Added support for wide streams to ``fmt::streamed``
-  (`#2994 <https://github.com/fmtlib/fmt/pull/2994>`_).
-  Thanks `@phprus (Vladislav Shchapov) <https://github.com/phprus>`_.
-
-* Added the ``n`` specifier that disables the output of delimiters when
-  formatting ranges (`#2981 <https://github.com/fmtlib/fmt/pull/2981>`_,
-  `#2983 <https://github.com/fmtlib/fmt/pull/2983>`_).
-  For example (`godbolt <https://godbolt.org/z/roKqGdj8c>`__):
-
-  .. code:: c++
-
-     #include <fmt/ranges.h>
-     #include <vector>
-
-     int main() {
-       auto v = std::vector{1, 2, 3};
-       fmt::print("{:n}\n", v); // prints 1, 2, 3
-     }
-
-  Thanks `@BRevzin (Barry Revzin) <https://github.com/BRevzin>`_.
-
-* Worked around problematic ``std::string_view`` constructors introduced in
-  C++23 (`#3030 <https://github.com/fmtlib/fmt/issues/3030>`_,
-  `#3050 <https://github.com/fmtlib/fmt/issues/3050>`_).
-  Thanks `@strega-nil-ms (nicole mazzuca) <https://github.com/strega-nil-ms>`_.
-
-* Improve handling (exclusion) of recursive ranges
-  (`#2968 <https://github.com/fmtlib/fmt/issues/2968>`_,
-  `#2974 <https://github.com/fmtlib/fmt/pull/2974>`_).
-  Thanks `@Dani-Hub (Daniel Krügler) <https://github.com/Dani-Hub>`_.
-
-* Improved error reporting in format string compilation
-  (`#3055 <https://github.com/fmtlib/fmt/issues/3055>`_).
-
-* Improved the implementation of
-  `Dragonbox <https://github.com/jk-jeon/dragonbox>`_, the algorithm used for
-  the default floating-point formatting
-  (`#2984 <https://github.com/fmtlib/fmt/pull/2984>`_).
-  Thanks `@jk-jeon (Junekey Jeon) <https://github.com/jk-jeon>`_.
-
-* Fixed issues with floating-point formatting on exotic platforms.
-
-* Improved the implementation of chrono formatting
-  (`#3010 <https://github.com/fmtlib/fmt/pull/3010>`_).
-  Thanks `@phprus (Vladislav Shchapov) <https://github.com/phprus>`_.
-
-* Improved documentation
-  (`#2966 <https://github.com/fmtlib/fmt/pull/2966>`_,
-  `#3009 <https://github.com/fmtlib/fmt/pull/3009>`_,
-  `#3020 <https://github.com/fmtlib/fmt/issues/3020>`_,
-  `#3037 <https://github.com/fmtlib/fmt/pull/3037>`_).
-  Thanks `@mwinterb <https://github.com/mwinterb>`_,
-  `@jcelerier (Jean-Michaël Celerier) <https://github.com/jcelerier>`_
-  and `@remiburtin (Rémi Burtin) <https://github.com/remiburtin>`_.
-
-* Improved build configuration
-  (`#2991 <https://github.com/fmtlib/fmt/pull/2991>`_,
-  `#2995 <https://github.com/fmtlib/fmt/pull/2995>`_,
-  `#3004 <https://github.com/fmtlib/fmt/issues/3004>`_,
-  `#3007 <https://github.com/fmtlib/fmt/pull/3007>`_,
-  `#3040 <https://github.com/fmtlib/fmt/pull/3040>`_).
-  Thanks `@dimztimz (Dimitrij Mijoski) <https://github.com/dimztimz>`_ and
-  `@hwhsu1231 (Haowei Hsu) <https://github.com/hwhsu1231>`_.
-
-* Fixed various warnings and compilation issues
-  (`#2969 <https://github.com/fmtlib/fmt/issues/2969>`_,
-  `#2971 <https://github.com/fmtlib/fmt/pull/2971>`_,
-  `#2975 <https://github.com/fmtlib/fmt/issues/2975>`_,
-  `#2982 <https://github.com/fmtlib/fmt/pull/2982>`_,
-  `#2985 <https://github.com/fmtlib/fmt/pull/2985>`_,
-  `#2988 <https://github.com/fmtlib/fmt/issues/2988>`_,
-  `#3000 <https://github.com/fmtlib/fmt/issues/3000>`_,
-  `#3006 <https://github.com/fmtlib/fmt/issues/3006>`_,
-  `#3014 <https://github.com/fmtlib/fmt/issues/3014>`_,
-  `#3015 <https://github.com/fmtlib/fmt/issues/3015>`_,
-  `#3021 <https://github.com/fmtlib/fmt/pull/3021>`_,
-  `#3023 <https://github.com/fmtlib/fmt/issues/3023>`_,
-  `#3024 <https://github.com/fmtlib/fmt/pull/3024>`_,
-  `#3029 <https://github.com/fmtlib/fmt/pull/3029>`_,
-  `#3043 <https://github.com/fmtlib/fmt/pull/3043>`_,
-  `#3052 <https://github.com/fmtlib/fmt/issues/3052>`_,
-  `#3053 <https://github.com/fmtlib/fmt/pull/3053>`_,
-  `#3054 <https://github.com/fmtlib/fmt/pull/3054>`_).
-  Thanks `@h-friederich (Hannes Friederich) <https://github.com/h-friederich>`_,
-  `@dimztimz (Dimitrij Mijoski) <https://github.com/dimztimz>`_,
-  `@olupton (Olli Lupton) <https://github.com/olupton>`_,
-  `@bernhardmgruber (Bernhard Manfred Gruber)
-  <https://github.com/bernhardmgruber>`_,
-  `@phprus (Vladislav Shchapov) <https://github.com/phprus>`_.
-
-9.0.0 - 2022-07-04
-------------------
-
-* Switched to the internal floating point formatter for all decimal presentation
-  formats. In particular this results in consistent rounding on all platforms
-  and removing the ``s[n]printf`` fallback for decimal FP formatting.
-
-* Compile-time floating point formatting no longer requires the header-only
-  mode. For example (`godbolt <https://godbolt.org/z/G37PTeG3b>`__):
-
-  .. code:: c++
-
-     #include <array>
-     #include <fmt/compile.h>
-
-     consteval auto compile_time_dtoa(double value) -> std::array<char, 10> {
-       auto result = std::array<char, 10>();
-       fmt::format_to(result.data(), FMT_COMPILE("{}"), value);
-       return result;
-     }
-
-     constexpr auto answer = compile_time_dtoa(0.42);
-
-  works with the default settings.
-
-* Improved the implementation of
-  `Dragonbox <https://github.com/jk-jeon/dragonbox>`_, the algorithm used for
-  the default floating-point formatting
-  (`#2713 <https://github.com/fmtlib/fmt/pull/2713>`_,
-  `#2750 <https://github.com/fmtlib/fmt/pull/2750>`_).
-  Thanks `@jk-jeon (Junekey Jeon) <https://github.com/jk-jeon>`_.
-
-* Made ``fmt::to_string`` work with ``__float128``. This uses the internal
-  FP formatter and works even on system without ``__float128`` support in
-  ``[s]printf``.
-
-* Disabled automatic ``std::ostream`` insertion operator (``operator<<``)
-  discovery when ``fmt/ostream.h`` is included to prevent ODR violations.
-  You can get the old behavior by defining ``FMT_DEPRECATED_OSTREAM`` but this
-  will be removed in the next major release. Use ``fmt::streamed`` or
-  ``fmt::ostream_formatter`` to enable formatting via ``std::ostream`` instead.
-  
-* Added ``fmt::ostream_formatter`` that can be used to write ``formatter``
-  specializations that perform formatting via ``std::ostream``.
-  For example (`godbolt <https://godbolt.org/z/5sEc5qMsf>`__):
-
-  .. code:: c++
-
-     #include <fmt/ostream.h>
-
-     struct date {
-       int year, month, day;
-
-       friend std::ostream& operator<<(std::ostream& os, const date& d) {
-         return os << d.year << '-' << d.month << '-' << d.day;
-       }
-     };
-
-     template <> struct fmt::formatter<date> : ostream_formatter {};
-
-     std::string s = fmt::format("The date is {}", date{2012, 12, 9});
-     // s == "The date is 2012-12-9"
-
-* Added the ``fmt::streamed`` function that takes an object and formats it
-  via ``std::ostream``.
-  For example (`godbolt <https://godbolt.org/z/5G3346G1f>`__):
-
-  .. code:: c++
-
-     #include <thread>
-     #include <fmt/ostream.h>
-
-     int main() {
-       fmt::print("Current thread id: {}\n",
-                  fmt::streamed(std::this_thread::get_id()));
-     }
-
-  Note that ``fmt/std.h`` provides a ``formatter`` specialization for
-  ``std::thread::id`` so you don't need to format it via ``std::ostream``.
-
-* Deprecated implicit conversions of unscoped enums to integers for consistency
-  with scoped enums.
-
-* Added an argument-dependent lookup based ``format_as`` extension API to
-  simplify formatting of enums.
-
-* Added experimental ``std::variant`` formatting support
-  (`#2941 <https://github.com/fmtlib/fmt/pull/2941>`_).
-  For example (`godbolt <https://godbolt.org/z/KG9z6cq68>`__):
-
-  .. code:: c++
-
-     #include <variant>
-     #include <fmt/std.h>
-
-     int main() {
-       auto v = std::variant<int, std::string>(42);
-       fmt::print("{}\n", v);
-     }
-
-  prints::
-
-     variant(42)
-
-  Thanks `@jehelset <https://github.com/jehelset>`_.
-
-* Added experimental ``std::filesystem::path`` formatting support
-  (`#2865 <https://github.com/fmtlib/fmt/issues/2865>`_,
-  `#2902 <https://github.com/fmtlib/fmt/pull/2902>`_,
-  `#2917 <https://github.com/fmtlib/fmt/issues/2917>`_,
-  `#2918 <https://github.com/fmtlib/fmt/pull/2918>`_).
-  For example (`godbolt <https://godbolt.org/z/o44dMexEb>`__):
-
-  .. code:: c++
-
-     #include <filesystem>
-     #include <fmt/std.h>
-
-     int main() {
-       fmt::print("There is no place like {}.", std::filesystem::path("/home"));
-     }
-
-  prints::
-
-     There is no place like "/home".
-
-  Thanks `@phprus (Vladislav Shchapov) <https://github.com/phprus>`_.
-
-* Added a ``std::thread::id`` formatter to ``fmt/std.h``.
-  For example (`godbolt <https://godbolt.org/z/j1azbYf3E>`__):
-
-  .. code:: c++
-
-     #include <thread>
-     #include <fmt/std.h>
-
-     int main() {
-       fmt::print("Current thread id: {}\n", std::this_thread::get_id());
-     }
-
-* Added ``fmt::styled`` that applies a text style to an individual argument
-  (`#2793 <https://github.com/fmtlib/fmt/pull/2793>`_).
-  For example (`godbolt <https://godbolt.org/z/vWGW7v5M6>`__):
-
-  .. code:: c++
-
-     #include <fmt/chrono.h>
-     #include <fmt/color.h>
-
-     int main() {
-       auto now = std::chrono::system_clock::now();
-       fmt::print(
-         "[{}] {}: {}\n",
-         fmt::styled(now, fmt::emphasis::bold),
-         fmt::styled("error", fg(fmt::color::red)),
-         "something went wrong");
-     }
-
-  prints
-
-  .. image:: https://user-images.githubusercontent.com/576385/
-             175071215-12809244-dab0-4005-96d8-7cd911c964d5.png
-
-  Thanks `@rbrugo (Riccardo Brugo) <https://github.com/rbrugo>`_.
-
-* Made ``fmt::print`` overload for text styles correctly handle UTF-8
-  (`#2681 <https://github.com/fmtlib/fmt/issues/2681>`_,
-  `#2701 <https://github.com/fmtlib/fmt/pull/2701>`_).
-  Thanks `@AlexGuteniev (Alex Guteniev) <https://github.com/AlexGuteniev>`_.
-
-* Fixed Unicode handling when writing to an ostream.
-
-* Added support for nested specifiers to range formatting
-  (`#2673 <https://github.com/fmtlib/fmt/pull/2673>`_).
-  For example (`godbolt <https://godbolt.org/z/xd3Gj38cf>`__):
-
-  .. code:: c++
-
-     #include <vector>
-     #include <fmt/ranges.h>
-
-     int main() {
-       fmt::print("{::#x}\n", std::vector{10, 20, 30});
-     }
-
-  prints ``[0xa, 0x14, 0x1e]``.
-
-  Thanks `@BRevzin (Barry Revzin) <https://github.com/BRevzin>`_.
-
-* Implemented escaping of wide strings in ranges
-  (`#2904 <https://github.com/fmtlib/fmt/pull/2904>`_).
-  Thanks `@phprus (Vladislav Shchapov) <https://github.com/phprus>`_.
-
-* Added support for ranges with ``begin`` / ``end`` found via the
-  argument-dependent lookup
-  (`#2807 <https://github.com/fmtlib/fmt/pull/2807>`_).
-  Thanks `@rbrugo (Riccardo Brugo) <https://github.com/rbrugo>`_.
-
-* Fixed formatting of certain kinds of ranges of ranges
-  (`#2787 <https://github.com/fmtlib/fmt/pull/2787>`_).
-  Thanks `@BRevzin (Barry Revzin) <https://github.com/BRevzin>`_.
-
-* Fixed handling of maps with element types other than ``std::pair``
-  (`#2944 <https://github.com/fmtlib/fmt/pull/2944>`_).
-  Thanks `@BrukerJWD (Jonathan W) <https://github.com/BrukerJWD>`_.
-
-* Made tuple formatter enabled only if elements are formattable
-  (`#2939 <https://github.com/fmtlib/fmt/issues/2939>`_,
-  `#2940 <https://github.com/fmtlib/fmt/pull/2940>`_).
-  Thanks `@jehelset <https://github.com/jehelset>`_.
-
-* Made ``fmt::join`` compatible with format string compilation
-  (`#2719 <https://github.com/fmtlib/fmt/issues/2719>`_,
-  `#2720 <https://github.com/fmtlib/fmt/pull/2720>`_).
-  Thanks `@phprus (Vladislav Shchapov) <https://github.com/phprus>`_.
-
-* Made compile-time checks work with named arguments of custom types and
-  ``std::ostream`` ``print`` overloads
-  (`#2816 <https://github.com/fmtlib/fmt/issues/2816>`_,
-  `#2817 <https://github.com/fmtlib/fmt/issues/2817>`_,
-  `#2819 <https://github.com/fmtlib/fmt/pull/2819>`_).
-  Thanks `@timsong-cpp <https://github.com/timsong-cpp>`_.
-
-* Removed ``make_args_checked`` because it is no longer needed for compile-time
-  checks (`#2760 <https://github.com/fmtlib/fmt/pull/2760>`_).
-  Thanks `@phprus (Vladislav Shchapov) <https://github.com/phprus>`_.
-
-* Removed the following deprecated APIs: ``_format``, ``arg_join``,
-  the ``format_to`` overload that takes a memory buffer,
-  ``[v]fprintf`` that takes an ``ostream``.
-
-* Removed the deprecated implicit conversion of ``[const] signed char*`` and 
-  ``[const] unsigned char*`` to C strings.
-
-* Removed the deprecated ``fmt/locale.h``.
-
-* Replaced the deprecated ``fileno()`` with ``descriptor()`` in
-  ``buffered_file``.
-
-* Moved ``to_string_view`` to the ``detail`` namespace since it's an
-  implementation detail.
-
-* Made access mode of a created file consistent with ``fopen`` by setting
-  ``S_IWGRP`` and ``S_IWOTH``
-  (`#2733 <https://github.com/fmtlib/fmt/pull/2733>`_).
-  Thanks `@arogge (Andreas Rogge) <https://github.com/arogge>`_.
-
-* Removed a redundant buffer resize when formatting to ``std::ostream``
-  (`#2842 <https://github.com/fmtlib/fmt/issues/2842>`_,
-  `#2843 <https://github.com/fmtlib/fmt/pull/2843>`_).
-  Thanks `@jcelerier (Jean-Michaël Celerier) <https://github.com/jcelerier>`_.
-
-* Made precision computation for strings consistent with width
-  (`#2888 <https://github.com/fmtlib/fmt/issues/2888>`_).
-
-* Fixed handling of locale separators in floating point formatting
-  (`#2830 <https://github.com/fmtlib/fmt/issues/2830>`_).
-
-* Made sign specifiers work with ``__int128_t``
-  (`#2773 <https://github.com/fmtlib/fmt/issues/2773>`_).
-
-* Improved support for systems such as CHERI with extra data stored in pointers
-  (`#2932 <https://github.com/fmtlib/fmt/pull/2932>`_).
-  Thanks `@davidchisnall (David Chisnall) <https://github.com/davidchisnall>`_.
-
-* Improved documentation
-  (`#2706 <https://github.com/fmtlib/fmt/pull/2706>`_,
-  `#2712 <https://github.com/fmtlib/fmt/pull/2712>`_,
-  `#2789 <https://github.com/fmtlib/fmt/pull/2789>`_,
-  `#2803 <https://github.com/fmtlib/fmt/pull/2803>`_,
-  `#2805 <https://github.com/fmtlib/fmt/pull/2805>`_,
-  `#2815 <https://github.com/fmtlib/fmt/pull/2815>`_,
-  `#2924 <https://github.com/fmtlib/fmt/pull/2924>`_).
-  Thanks `@BRevzin (Barry Revzin) <https://github.com/BRevzin>`_,
-  `@Pokechu22 <https://github.com/Pokechu22>`_,
-  `@setoye (Alta) <https://github.com/setoye>`_,
-  `@rtobar <https://github.com/rtobar>`_,
-  `@rbrugo (Riccardo Brugo) <https://github.com/rbrugo>`_,
-  `@anoonD (cre) <https://github.com/anoonD>`_,
-  `@leha-bot (Alex) <https://github.com/leha-bot>`_.
-
-* Improved build configuration
-  (`#2766 <https://github.com/fmtlib/fmt/pull/2766>`_,
-  `#2772 <https://github.com/fmtlib/fmt/pull/2772>`_,
-  `#2836 <https://github.com/fmtlib/fmt/pull/2836>`_,
-  `#2852 <https://github.com/fmtlib/fmt/pull/2852>`_,
-  `#2907 <https://github.com/fmtlib/fmt/pull/2907>`_,
-  `#2913 <https://github.com/fmtlib/fmt/pull/2913>`_,
-  `#2914 <https://github.com/fmtlib/fmt/pull/2914>`_).
-  Thanks `@kambala-decapitator (Andrey Filipenkov)
-  <https://github.com/kambala-decapitator>`_,
-  `@mattiasljungstrom (Mattias Ljungström)
-  <https://github.com/mattiasljungstrom>`_,
-  `@kieselnb (Nick Kiesel) <https://github.com/kieselnb>`_,
-  `@nathannaveen <https://github.com/nathannaveen>`_,
-  `@Vertexwahn <https://github.com/Vertexwahn>`_.
-
-* Fixed various warnings and compilation issues
-  (`#2408 <https://github.com/fmtlib/fmt/issues/2408>`_,
-  `#2507 <https://github.com/fmtlib/fmt/issues/2507>`_,
-  `#2697 <https://github.com/fmtlib/fmt/issues/2697>`_,
-  `#2715 <https://github.com/fmtlib/fmt/issues/2715>`_,
-  `#2717 <https://github.com/fmtlib/fmt/issues/2717>`_,
-  `#2722 <https://github.com/fmtlib/fmt/pull/2722>`_,
-  `#2724 <https://github.com/fmtlib/fmt/pull/2724>`_,
-  `#2725 <https://github.com/fmtlib/fmt/pull/2725>`_,
-  `#2726 <https://github.com/fmtlib/fmt/issues/2726>`_,
-  `#2728 <https://github.com/fmtlib/fmt/pull/2728>`_,
-  `#2732 <https://github.com/fmtlib/fmt/pull/2732>`_,
-  `#2738 <https://github.com/fmtlib/fmt/issues/2738>`_,
-  `#2742 <https://github.com/fmtlib/fmt/pull/2742>`_,
-  `#2744 <https://github.com/fmtlib/fmt/issues/2744>`_,
-  `#2745 <https://github.com/fmtlib/fmt/issues/2745>`_,
-  `#2746 <https://github.com/fmtlib/fmt/issues/2746>`_,
-  `#2754 <https://github.com/fmtlib/fmt/issues/2754>`_,
-  `#2755 <https://github.com/fmtlib/fmt/pull/2755>`_,
-  `#2757 <https://github.com/fmtlib/fmt/issues/2757>`_,
-  `#2758 <https://github.com/fmtlib/fmt/pull/2758>`_,
-  `#2761 <https://github.com/fmtlib/fmt/issues/2761>`_,
-  `#2762 <https://github.com/fmtlib/fmt/pull/2762>`_,
-  `#2763 <https://github.com/fmtlib/fmt/issues/2763>`_,
-  `#2765 <https://github.com/fmtlib/fmt/pull/2765>`_,
-  `#2769 <https://github.com/fmtlib/fmt/issues/2769>`_,
-  `#2770 <https://github.com/fmtlib/fmt/pull/2770>`_,
-  `#2771 <https://github.com/fmtlib/fmt/issues/2771>`_,
-  `#2777 <https://github.com/fmtlib/fmt/issues/2777>`_,
-  `#2779 <https://github.com/fmtlib/fmt/pull/2779>`_,
-  `#2782 <https://github.com/fmtlib/fmt/pull/2782>`_,
-  `#2783 <https://github.com/fmtlib/fmt/pull/2783>`_,
-  `#2794 <https://github.com/fmtlib/fmt/issues/2794>`_,
-  `#2796 <https://github.com/fmtlib/fmt/issues/2796>`_,
-  `#2797 <https://github.com/fmtlib/fmt/pull/2797>`_,
-  `#2801 <https://github.com/fmtlib/fmt/pull/2801>`_,
-  `#2802 <https://github.com/fmtlib/fmt/pull/2802>`_,
-  `#2808 <https://github.com/fmtlib/fmt/issues/2808>`_,
-  `#2818 <https://github.com/fmtlib/fmt/issues/2818>`_,
-  `#2819 <https://github.com/fmtlib/fmt/pull/2819>`_,
-  `#2829 <https://github.com/fmtlib/fmt/issues/2829>`_,
-  `#2835 <https://github.com/fmtlib/fmt/issues/2835>`_,
-  `#2848 <https://github.com/fmtlib/fmt/issues/2848>`_,
-  `#2860 <https://github.com/fmtlib/fmt/issues/2860>`_,
-  `#2861 <https://github.com/fmtlib/fmt/pull/2861>`_,
-  `#2882 <https://github.com/fmtlib/fmt/pull/2882>`_,
-  `#2886 <https://github.com/fmtlib/fmt/issues/2886>`_,
-  `#2891 <https://github.com/fmtlib/fmt/issues/2891>`_,
-  `#2892 <https://github.com/fmtlib/fmt/pull/2892>`_,
-  `#2895 <https://github.com/fmtlib/fmt/issues/2895>`_,
-  `#2896 <https://github.com/fmtlib/fmt/issues/2896>`_,
-  `#2903 <https://github.com/fmtlib/fmt/pull/2903>`_,
-  `#2906 <https://github.com/fmtlib/fmt/issues/2906>`_,
-  `#2908 <https://github.com/fmtlib/fmt/issues/2908>`_,
-  `#2909 <https://github.com/fmtlib/fmt/pull/2909>`_,
-  `#2920 <https://github.com/fmtlib/fmt/issues/2920>`_,
-  `#2922 <https://github.com/fmtlib/fmt/pull/2922>`_,
-  `#2927 <https://github.com/fmtlib/fmt/pull/2927>`_,
-  `#2929 <https://github.com/fmtlib/fmt/pull/2929>`_,
-  `#2936 <https://github.com/fmtlib/fmt/issues/2936>`_,
-  `#2937 <https://github.com/fmtlib/fmt/pull/2937>`_,
-  `#2938 <https://github.com/fmtlib/fmt/pull/2938>`_,
-  `#2951 <https://github.com/fmtlib/fmt/pull/2951>`_,
-  `#2954 <https://github.com/fmtlib/fmt/issues/2954>`_,
-  `#2957 <https://github.com/fmtlib/fmt/pull/2957>`_,
-  `#2958 <https://github.com/fmtlib/fmt/issues/2958>`_,
-  `#2960 <https://github.com/fmtlib/fmt/pull/2960>`_).
-  Thanks `@matrackif <https://github.com/matrackif>`_
-  `@Tobi823 (Tobias Hellmann) <https://github.com/Tobi823>`_,
-  `@ivan-volnov (Ivan Volnov) <https://github.com/ivan-volnov>`_,
-  `@VasiliPupkin256 <https://github.com/VasiliPupkin256>`_,
-  `@federico-busato (Federico) <https://github.com/federico-busato>`_,
-  `@barcharcraz (Charlie Barto) <https://github.com/barcharcraz>`_,
-  `@jk-jeon (Junekey Jeon) <https://github.com/jk-jeon>`_,
-  `@HazardyKnusperkeks (Björn Schäpers)
-  <https://github.com/HazardyKnusperkeks>`_,
-  `@dalboris (Boris Dalstein) <https://github.com/dalboris>`_,
-  `@seanm (Sean McBride) <https://github.com/seanm>`_,
-  `@gsjaardema (Greg Sjaardema) <https://github.com/gsjaardema>`_,
-  `@timsong-cpp <https://github.com/timsong-cpp>`_,
-  `@seanm (Sean McBride) <https://github.com/seanm>`_,
-  `@frithrah <https://github.com/frithrah>`_,
-  `@chronoxor (Ivan Shynkarenka) <https://github.com/chronoxor>`_,
-  `@Agga <https://github.com/Agga>`_,
-  `@madmaxoft (Mattes D) <https://github.com/madmaxoft>`_,
-  `@JurajX (Juraj) <https://github.com/JurajX>`_,
-  `@phprus (Vladislav Shchapov) <https://github.com/phprus>`_,
-  `@Dani-Hub (Daniel Krügler) <https://github.com/Dani-Hub>`_.
-
-8.1.1 - 2022-01-06
-------------------
-
-* Restored ABI compatibility with version 8.0.x
-  (`#2695 <https://github.com/fmtlib/fmt/issues/2695>`_,
-  `#2696 <https://github.com/fmtlib/fmt/pull/2696>`_).
-  Thanks `@saraedum (Julian Rüth) <https://github.com/saraedum>`_.
-
-* Fixed chrono formatting on big endian systems
-  (`#2698 <https://github.com/fmtlib/fmt/issues/2698>`_,
-  `#2699 <https://github.com/fmtlib/fmt/pull/2699>`_).
-  Thanks `@phprus (Vladislav Shchapov) <https://github.com/phprus>`_ and
-  `@xvitaly (Vitaly Zaitsev) <https://github.com/xvitaly>`_.
-
-* Fixed a linkage error with mingw
-  (`#2691 <https://github.com/fmtlib/fmt/issues/2691>`_,
-  `#2692 <https://github.com/fmtlib/fmt/pull/2692>`_).
-  Thanks `@rbberger (Richard Berger) <https://github.com/rbberger>`_.
-
-8.1.0 - 2022-01-02
-------------------
-
-* Optimized chrono formatting
-  (`#2500 <https://github.com/fmtlib/fmt/pull/2500>`_,
-  `#2537 <https://github.com/fmtlib/fmt/pull/2537>`_,
-  `#2541 <https://github.com/fmtlib/fmt/issues/2541>`_,
-  `#2544 <https://github.com/fmtlib/fmt/pull/2544>`_,
-  `#2550 <https://github.com/fmtlib/fmt/pull/2550>`_,
-  `#2551 <https://github.com/fmtlib/fmt/pull/2551>`_,
-  `#2576 <https://github.com/fmtlib/fmt/pull/2576>`_,
-  `#2577 <https://github.com/fmtlib/fmt/issues/2577>`_,
-  `#2586 <https://github.com/fmtlib/fmt/pull/2586>`_,
-  `#2591 <https://github.com/fmtlib/fmt/pull/2591>`_,
-  `#2594 <https://github.com/fmtlib/fmt/pull/2594>`_,
-  `#2602 <https://github.com/fmtlib/fmt/pull/2602>`_,
-  `#2617 <https://github.com/fmtlib/fmt/pull/2617>`_,
-  `#2628 <https://github.com/fmtlib/fmt/issues/2628>`_,
-  `#2633 <https://github.com/fmtlib/fmt/pull/2633>`_,
-  `#2670 <https://github.com/fmtlib/fmt/issues/2670>`_,
-  `#2671 <https://github.com/fmtlib/fmt/pull/2671>`_).
-
-  Processing of some specifiers such as ``%z`` and ``%Y`` is now up to 10-20
-  times faster, for example on GCC 11 with libstdc++::
-
-    ----------------------------------------------------------------------------
-    Benchmark                                  Before             After
-    ----------------------------------------------------------------------------
-    FMTFormatter_z                             261 ns             26.3 ns
-    FMTFormatterCompile_z                      246 ns             11.6 ns
-    FMTFormatter_Y                             263 ns             26.1 ns
-    FMTFormatterCompile_Y                      244 ns             10.5 ns
-    ----------------------------------------------------------------------------
-
-  Thanks `@phprus (Vladislav Shchapov) <https://github.com/phprus>`_ and
-  `@toughengineer (Pavel Novikov) <https://github.com/toughengineer>`_.
-
-* Implemented subsecond formatting for chrono durations
-  (`#2623 <https://github.com/fmtlib/fmt/pull/2623>`_).
-  For example (`godbolt <https://godbolt.org/z/es7vWTETe>`__):
-
-  .. code:: c++
-
-     #include <fmt/chrono.h>
-
-     int main() {
-       fmt::print("{:%S}", std::chrono::milliseconds(1234));
-     }
-
-  prints "01.234".
-
-  Thanks `@matrackif <https://github.com/matrackif>`_.
-
-* Fixed handling of precision 0 when formatting chrono durations
-  (`#2587 <https://github.com/fmtlib/fmt/issues/2587>`_,
-  `#2588 <https://github.com/fmtlib/fmt/pull/2588>`_).
-  Thanks `@lukester1975 <https://github.com/lukester1975>`_.
-
-* Fixed an overflow on invalid inputs in the ``tm`` formatter
-  (`#2564 <https://github.com/fmtlib/fmt/pull/2564>`_).
-  Thanks `@phprus (Vladislav Shchapov) <https://github.com/phprus>`_.
-
-* Added ``fmt::group_digits`` that formats integers with a non-localized digit
-  separator (comma) for groups of three digits.
-  For example (`godbolt <https://godbolt.org/z/TxGxG9Poq>`__):
-
-  .. code:: c++
-
-     #include <fmt/format.h>
-
-     int main() {
-       fmt::print("{} dollars", fmt::group_digits(1000000));
-     }
-
-  prints "1,000,000 dollars".
-
-* Added support for faint, conceal, reverse and blink text styles
-  (`#2394 <https://github.com/fmtlib/fmt/pull/2394>`_):
-
-  https://user-images.githubusercontent.com/576385/147710227-c68f5317-f8fa-42c3-9123-7c4ba3c398cb.mp4
-
-  Thanks `@benit8 (Benoît Lormeau) <https://github.com/benit8>`_ and
-  `@data-man (Dmitry Atamanov) <https://github.com/data-man>`_.
-
-* Added experimental support for compile-time floating point formatting
-  (`#2426 <https://github.com/fmtlib/fmt/pull/2426>`_,
-  `#2470 <https://github.com/fmtlib/fmt/pull/2470>`_).
-  It is currently limited to the header-only mode.
-  Thanks `@alexezeder (Alexey Ochapov) <https://github.com/alexezeder>`_.
-
-* Added UDL-based named argument support to compile-time format string checks
-  (`#2640 <https://github.com/fmtlib/fmt/issues/2640>`_,
-  `#2649 <https://github.com/fmtlib/fmt/pull/2649>`_).
-  For example (`godbolt <https://godbolt.org/z/ohGbbvonv>`__):
-
-  .. code:: c++
-
-     #include <fmt/format.h>
-
-     int main() {
-       using namespace fmt::literals;
-       fmt::print("{answer:s}", "answer"_a=42);
-     }
-
-  gives a compile-time error on compilers with C++20 ``consteval`` and non-type
-  template parameter support (gcc 10+) because ``s`` is not a valid format
-  specifier for an integer.
-
-  Thanks `@alexezeder (Alexey Ochapov) <https://github.com/alexezeder>`_.
-
-* Implemented escaping of string range elements.
-  For example (`godbolt <https://godbolt.org/z/rKvM1vKf3>`__):
-
-  .. code:: c++
-
-     #include <fmt/ranges.h>
-     #include <vector>
-
-     int main() {
-       fmt::print("{}", std::vector<std::string>{"\naan"});
-     }
-
-  is now printed as::
-
-    ["\naan"]
-
-  instead of::
-  
-    ["
-    aan"]
-
-* Added an experimental ``?`` specifier for escaping strings.
-  (`#2674 <https://github.com/fmtlib/fmt/pull/2674>`_).
-  Thanks `@BRevzin (Barry Revzin) <https://github.com/BRevzin>`_.
-
-* Switched to JSON-like representation of maps and sets for consistency with
-  Python's ``str.format``.
-  For example (`godbolt <https://godbolt.org/z/seKjoY9W5>`__):
-
-  .. code:: c++
-
-     #include <fmt/ranges.h>
-     #include <map>
-
-     int main() {
-       fmt::print("{}", std::map<std::string, int>{{"answer", 42}});
-     }
-
-  is now printed as::
-
-    {"answer": 42}
-
-* Extended ``fmt::join`` to support C++20-only ranges
-  (`#2549 <https://github.com/fmtlib/fmt/pull/2549>`_).
-  Thanks `@BRevzin (Barry Revzin) <https://github.com/BRevzin>`_.
-
-* Optimized handling of non-const-iterable ranges and implemented initial
-  support for non-const-formattable types.
-
-* Disabled implicit conversions of scoped enums to integers that was
-  accidentally introduced in earlier versions
-  (`#1841 <https://github.com/fmtlib/fmt/pull/1841>`_).
-
-* Deprecated implicit conversion of ``[const] signed char*`` and 
-  ``[const] unsigned char*`` to C strings.
-
-* Deprecated ``_format``, a legacy UDL-based format API
-  (`#2646 <https://github.com/fmtlib/fmt/pull/2646>`_).
-  Thanks `@alexezeder (Alexey Ochapov) <https://github.com/alexezeder>`_.
-
-* Marked ``format``, ``formatted_size`` and ``to_string`` as ``[[nodiscard]]``
-  (`#2612 <https://github.com/fmtlib/fmt/pull/2612>`_).
-  `@0x8000-0000 (Florin Iucha) <https://github.com/0x8000-0000>`_.
-
-* Added missing diagnostic when trying to format function and member pointers
-  as well as objects convertible to pointers which is explicitly disallowed
-  (`#2598 <https://github.com/fmtlib/fmt/issues/2598>`_,
-  `#2609 <https://github.com/fmtlib/fmt/pull/2609>`_,
-  `#2610 <https://github.com/fmtlib/fmt/pull/2610>`_).
-  Thanks `@AlexGuteniev (Alex Guteniev) <https://github.com/AlexGuteniev>`_.
-
-* Optimized writing to a contiguous buffer with ``format_to_n``
-  (`#2489 <https://github.com/fmtlib/fmt/pull/2489>`_).
-  Thanks `@Roman-Koshelev <https://github.com/Roman-Koshelev>`_.
-
-* Optimized writing to non-``char`` buffers
-  (`#2477 <https://github.com/fmtlib/fmt/pull/2477>`_).
-  Thanks `@Roman-Koshelev <https://github.com/Roman-Koshelev>`_.
-
-* Decimal point is now localized when using the ``L`` specifier.
-
-* Improved floating point formatter implementation
-  (`#2498 <https://github.com/fmtlib/fmt/pull/2498>`_,
-  `#2499 <https://github.com/fmtlib/fmt/pull/2499>`_).
-  Thanks `@Roman-Koshelev <https://github.com/Roman-Koshelev>`_.
-
-* Fixed handling of very large precision in fixed format
-  (`#2616 <https://github.com/fmtlib/fmt/pull/2616>`_).
-
-* Made a table of cached powers used in FP formatting static
-  (`#2509 <https://github.com/fmtlib/fmt/pull/2509>`_).
-  Thanks `@jk-jeon (Junekey Jeon) <https://github.com/jk-jeon>`_.
-
-* Resolved a lookup ambiguity with C++20 format-related functions due to ADL
-  (`#2639 <https://github.com/fmtlib/fmt/issues/2639>`_,
-  `#2641 <https://github.com/fmtlib/fmt/pull/2641>`_).
-  Thanks `@mkurdej (Marek Kurdej) <https://github.com/mkurdej>`_.
-
-* Removed unnecessary inline namespace qualification
-  (`#2642 <https://github.com/fmtlib/fmt/issues/2642>`_,
-  `#2643 <https://github.com/fmtlib/fmt/pull/2643>`_).
-  Thanks `@mkurdej (Marek Kurdej) <https://github.com/mkurdej>`_.
-
-* Implemented argument forwarding in ``format_to_n``
-  (`#2462 <https://github.com/fmtlib/fmt/issues/2462>`_,
-  `#2463 <https://github.com/fmtlib/fmt/pull/2463>`_).
-  Thanks `@owent (WenTao Ou) <https://github.com/owent>`_.
-
-* Fixed handling of implicit conversions in ``fmt::to_string`` and format string
-  compilation (`#2565 <https://github.com/fmtlib/fmt/issues/2565>`_).
-
-* Changed the default access mode of files created by ``fmt::output_file`` to
-  ``-rw-r--r--`` for consistency with ``fopen``
-  (`#2530 <https://github.com/fmtlib/fmt/issues/2530>`_).
-
-* Make ``fmt::ostream::flush`` public
-  (`#2435 <https://github.com/fmtlib/fmt/issues/2435>`_).
-
-* Improved C++14/17 attribute detection
-  (`#2615 <https://github.com/fmtlib/fmt/pull/2615>`_).
-  Thanks `@AlexGuteniev (Alex Guteniev) <https://github.com/AlexGuteniev>`_.
-
-* Improved ``consteval`` detection for MSVC
-  (`#2559 <https://github.com/fmtlib/fmt/pull/2559>`_).
-  Thanks `@DanielaE (Daniela Engert) <https://github.com/DanielaE>`_.
-
-* Improved documentation
-  (`#2406 <https://github.com/fmtlib/fmt/issues/2406>`_,
-  `#2446 <https://github.com/fmtlib/fmt/pull/2446>`_,
-  `#2493 <https://github.com/fmtlib/fmt/issues/2493>`_,
-  `#2513 <https://github.com/fmtlib/fmt/issues/2513>`_,
-  `#2515 <https://github.com/fmtlib/fmt/pull/2515>`_,
-  `#2522 <https://github.com/fmtlib/fmt/issues/2522>`_,
-  `#2562 <https://github.com/fmtlib/fmt/pull/2562>`_,
-  `#2575 <https://github.com/fmtlib/fmt/pull/2575>`_,
-  `#2606 <https://github.com/fmtlib/fmt/pull/2606>`_,
-  `#2620 <https://github.com/fmtlib/fmt/pull/2620>`_,
-  `#2676 <https://github.com/fmtlib/fmt/issues/2676>`_).
-  Thanks `@sobolevn (Nikita Sobolev) <https://github.com/sobolevn>`_,
-  `@UnePierre (Max FERGER) <https://github.com/UnePierre>`_,
-  `@zhsj <https://github.com/zhsj>`_,
-  `@phprus (Vladislav Shchapov) <https://github.com/phprus>`_,
-  `@ericcurtin (Eric Curtin) <https://github.com/ericcurtin>`_,
-  `@Lounarok <https://github.com/Lounarok>`_.
-
-* Improved fuzzers and added a fuzzer for chrono timepoint formatting
-  (`#2461 <https://github.com/fmtlib/fmt/pull/2461>`_,
-  `#2469 <https://github.com/fmtlib/fmt/pull/2469>`_).
-  `@pauldreik (Paul Dreik) <https://github.com/pauldreik>`_,
-
-* Added the ``FMT_SYSTEM_HEADERS`` CMake option setting which marks {fmt}'s
-  headers as system. It can be used to suppress warnings
-  (`#2644 <https://github.com/fmtlib/fmt/issues/2644>`_,
-  `#2651 <https://github.com/fmtlib/fmt/pull/2651>`_).
-  Thanks `@alexezeder (Alexey Ochapov) <https://github.com/alexezeder>`_.
-
-* Added the Bazel build system support
-  (`#2505 <https://github.com/fmtlib/fmt/pull/2505>`_,
-  `#2516 <https://github.com/fmtlib/fmt/pull/2516>`_).
-  Thanks `@Vertexwahn <https://github.com/Vertexwahn>`_.
-
-* Improved build configuration and tests
-  (`#2437 <https://github.com/fmtlib/fmt/issues/2437>`_,
-  `#2558 <https://github.com/fmtlib/fmt/pull/2558>`_,
-  `#2648 <https://github.com/fmtlib/fmt/pull/2648>`_,
-  `#2650 <https://github.com/fmtlib/fmt/pull/2650>`_,
-  `#2663 <https://github.com/fmtlib/fmt/pull/2663>`_,
-  `#2677 <https://github.com/fmtlib/fmt/pull/2677>`_).
-  Thanks `@DanielaE (Daniela Engert) <https://github.com/DanielaE>`_,
-  `@alexezeder (Alexey Ochapov) <https://github.com/alexezeder>`_,
-  `@phprus (Vladislav Shchapov) <https://github.com/phprus>`_.
-
-* Fixed various warnings and compilation issues
-  (`#2353 <https://github.com/fmtlib/fmt/pull/2353>`_,
-  `#2356 <https://github.com/fmtlib/fmt/pull/2356>`_,
-  `#2399 <https://github.com/fmtlib/fmt/pull/2399>`_,
-  `#2408 <https://github.com/fmtlib/fmt/issues/2408>`_,
-  `#2414 <https://github.com/fmtlib/fmt/pull/2414>`_,
-  `#2427 <https://github.com/fmtlib/fmt/pull/2427>`_,
-  `#2432 <https://github.com/fmtlib/fmt/pull/2432>`_,
-  `#2442 <https://github.com/fmtlib/fmt/pull/2442>`_,
-  `#2434 <https://github.com/fmtlib/fmt/pull/2434>`_,
-  `#2439 <https://github.com/fmtlib/fmt/issues/2439>`_,
-  `#2447 <https://github.com/fmtlib/fmt/pull/2447>`_,
-  `#2450 <https://github.com/fmtlib/fmt/pull/2450>`_,
-  `#2455 <https://github.com/fmtlib/fmt/issues/2455>`_,
-  `#2465 <https://github.com/fmtlib/fmt/issues/2465>`_,
-  `#2472 <https://github.com/fmtlib/fmt/issues/2472>`_,
-  `#2474 <https://github.com/fmtlib/fmt/issues/2474>`_,
-  `#2476 <https://github.com/fmtlib/fmt/pull/2476>`_,
-  `#2478 <https://github.com/fmtlib/fmt/issues/2478>`_,
-  `#2479 <https://github.com/fmtlib/fmt/issues/2479>`_,
-  `#2481 <https://github.com/fmtlib/fmt/issues/2481>`_,
-  `#2482 <https://github.com/fmtlib/fmt/pull/2482>`_,
-  `#2483 <https://github.com/fmtlib/fmt/pull/2483>`_,
-  `#2490 <https://github.com/fmtlib/fmt/issues/2490>`_,
-  `#2491 <https://github.com/fmtlib/fmt/pull/2491>`_,
-  `#2510 <https://github.com/fmtlib/fmt/pull/2510>`_,
-  `#2518 <https://github.com/fmtlib/fmt/pull/2518>`_,
-  `#2528 <https://github.com/fmtlib/fmt/issues/2528>`_,
-  `#2529 <https://github.com/fmtlib/fmt/pull/2529>`_,
-  `#2539 <https://github.com/fmtlib/fmt/pull/2539>`_,
-  `#2540 <https://github.com/fmtlib/fmt/issues/2540>`_,
-  `#2545 <https://github.com/fmtlib/fmt/pull/2545>`_,
-  `#2555 <https://github.com/fmtlib/fmt/pull/2555>`_,
-  `#2557 <https://github.com/fmtlib/fmt/issues/2557>`_,
-  `#2570 <https://github.com/fmtlib/fmt/issues/2570>`_,
-  `#2573 <https://github.com/fmtlib/fmt/pull/2573>`_,
-  `#2582 <https://github.com/fmtlib/fmt/pull/2582>`_,
-  `#2605 <https://github.com/fmtlib/fmt/issues/2605>`_,
-  `#2611 <https://github.com/fmtlib/fmt/pull/2611>`_,
-  `#2647 <https://github.com/fmtlib/fmt/pull/2647>`_,
-  `#2627 <https://github.com/fmtlib/fmt/issues/2627>`_,
-  `#2630 <https://github.com/fmtlib/fmt/pull/2630>`_,
-  `#2635 <https://github.com/fmtlib/fmt/issues/2635>`_,
-  `#2638 <https://github.com/fmtlib/fmt/issues/2638>`_,
-  `#2653 <https://github.com/fmtlib/fmt/issues/2653>`_,
-  `#2654 <https://github.com/fmtlib/fmt/issues/2654>`_,
-  `#2661 <https://github.com/fmtlib/fmt/issues/2661>`_,
-  `#2664 <https://github.com/fmtlib/fmt/pull/2664>`_,
-  `#2684 <https://github.com/fmtlib/fmt/pull/2684>`_).
-  Thanks `@DanielaE (Daniela Engert) <https://github.com/DanielaE>`_,
-  `@mwinterb <https://github.com/mwinterb>`_,
-  `@cdacamar (Cameron DaCamara) <https://github.com/cdacamar>`_,
-  `@TrebledJ (Johnathan) <https://github.com/TrebledJ>`_,
-  `@bodomartin (brm) <https://github.com/bodomartin>`_,
-  `@cquammen (Cory Quammen) <https://github.com/cquammen>`_,
-  `@white238 (Chris White) <https://github.com/white238>`_,
-  `@mmarkeloff (Max) <https://github.com/mmarkeloff>`_,
-  `@palacaze (Pierre-Antoine Lacaze) <https://github.com/palacaze>`_,
-  `@jcelerier (Jean-Michaël Celerier) <https://github.com/jcelerier>`_,
-  `@mborn-adi (Mathias Born) <https://github.com/mborn-adi>`_,
-  `@BrukerJWD (Jonathan W) <https://github.com/BrukerJWD>`_,
-  `@spyridon97 (Spiros Tsalikis) <https://github.com/spyridon97>`_,
-  `@phprus (Vladislav Shchapov) <https://github.com/phprus>`_,
-  `@oliverlee (Oliver Lee) <https://github.com/oliverlee>`_,
-  `@joshessman-llnl (Josh Essman) <https://github.com/joshessman-llnl>`_,
-  `@akohlmey (Axel Kohlmeyer) <https://github.com/akohlmey>`_,
-  `@timkalu <https://github.com/timkalu>`_,
-  `@olupton (Olli Lupton) <https://github.com/olupton>`_,
-  `@Acretock <https://github.com/Acretock>`_,
-  `@alexezeder (Alexey Ochapov) <https://github.com/alexezeder>`_,
-  `@andrewcorrigan (Andrew Corrigan) <https://github.com/andrewcorrigan>`_,
-  `@lucpelletier <https://github.com/lucpelletier>`_,
-  `@HazardyKnusperkeks (Björn Schäpers)
-  <https://github.com/HazardyKnusperkeks>`_.
-
-8.0.1 - 2021-07-02
-------------------
-
-* Fixed the version number in the inline namespace
-  (`#2374 <https://github.com/fmtlib/fmt/issues/2374>`_).
-
-* Added a missing presentation type check for ``std::string``
-  (`#2402 <https://github.com/fmtlib/fmt/issues/2402>`_).
-
-* Fixed a linkage error when mixing code built with clang and gcc
-  (`#2377 <https://github.com/fmtlib/fmt/issues/2377>`_).
-
-* Fixed documentation issues
-  (`#2396 <https://github.com/fmtlib/fmt/pull/2396>`_,
-  `#2403 <https://github.com/fmtlib/fmt/issues/2403>`_,
-  `#2406 <https://github.com/fmtlib/fmt/issues/2406>`_).
-  Thanks `@mkurdej (Marek Kurdej) <https://github.com/mkurdej>`_.
-
-* Removed dead code in FP formatter (
-  `#2398 <https://github.com/fmtlib/fmt/pull/2398>`_).
-  Thanks `@javierhonduco (Javier Honduvilla Coto)
-  <https://github.com/javierhonduco>`_.
-
-* Fixed various warnings and compilation issues
-  (`#2351 <https://github.com/fmtlib/fmt/issues/2351>`_,
-  `#2359 <https://github.com/fmtlib/fmt/issues/2359>`_,
-  `#2365 <https://github.com/fmtlib/fmt/pull/2365>`_,
-  `#2368 <https://github.com/fmtlib/fmt/issues/2368>`_,
-  `#2370 <https://github.com/fmtlib/fmt/pull/2370>`_,
-  `#2376 <https://github.com/fmtlib/fmt/pull/2376>`_,
-  `#2381 <https://github.com/fmtlib/fmt/pull/2381>`_,
-  `#2382 <https://github.com/fmtlib/fmt/pull/2382>`_,
-  `#2386 <https://github.com/fmtlib/fmt/issues/2386>`_,
-  `#2389 <https://github.com/fmtlib/fmt/pull/2389>`_,
-  `#2395 <https://github.com/fmtlib/fmt/pull/2395>`_,
-  `#2397 <https://github.com/fmtlib/fmt/pull/2397>`_,
-  `#2400 <https://github.com/fmtlib/fmt/issues/2400>`_,
-  `#2401 <https://github.com/fmtlib/fmt/issues/2401>`_,
-  `#2407 <https://github.com/fmtlib/fmt/pull/2407>`_).
-  Thanks `@zx2c4 (Jason A. Donenfeld) <https://github.com/zx2c4>`_,
-  `@AidanSun05 (Aidan Sun) <https://github.com/AidanSun05>`_,
-  `@mattiasljungstrom (Mattias Ljungström)
-  <https://github.com/mattiasljungstrom>`_,
-  `@joemmett (Jonathan Emmett) <https://github.com/joemmett>`_,
-  `@erengy (Eren Okka) <https://github.com/erengy>`_,
-  `@patlkli (Patrick Geltinger) <https://github.com/patlkli>`_,
-  `@gsjaardema (Greg Sjaardema) <https://github.com/gsjaardema>`_,
-  `@phprus (Vladislav Shchapov) <https://github.com/phprus>`_.
-
-8.0.0 - 2021-06-21
-------------------
-
-* Enabled compile-time format string checks by default.
-  For example (`godbolt <https://godbolt.org/z/sMxcohGjz>`__):
-
-  .. code:: c++
-
-     #include <fmt/core.h>
-
-     int main() {
-       fmt::print("{:d}", "I am not a number");
-     }
-
-  gives a compile-time error on compilers with C++20 ``consteval`` support
-  (gcc 10+, clang 11+) because ``d`` is not a valid format specifier for a
-  string.
-
-  To pass a runtime string wrap it in ``fmt::runtime``:
-
-  .. code:: c++
-
-     fmt::print(fmt::runtime("{:d}"), "I am not a number");
-
-* Added compile-time formatting
-  (`#2019 <https://github.com/fmtlib/fmt/pull/2019>`_,
-  `#2044 <https://github.com/fmtlib/fmt/pull/2044>`_,
-  `#2056 <https://github.com/fmtlib/fmt/pull/2056>`_,
-  `#2072 <https://github.com/fmtlib/fmt/pull/2072>`_,
-  `#2075 <https://github.com/fmtlib/fmt/pull/2075>`_,
-  `#2078 <https://github.com/fmtlib/fmt/issues/2078>`_,
-  `#2129 <https://github.com/fmtlib/fmt/pull/2129>`_,
-  `#2326 <https://github.com/fmtlib/fmt/pull/2326>`_).
-  For example (`godbolt <https://godbolt.org/z/Mxx9d89jM>`__):
-
-  .. code:: c++
-
-     #include <fmt/compile.h>
-
-     consteval auto compile_time_itoa(int value) -> std::array<char, 10> {
-       auto result = std::array<char, 10>();
-       fmt::format_to(result.data(), FMT_COMPILE("{}"), value);
-       return result;
-     }
-
-     constexpr auto answer = compile_time_itoa(42);
-
-  Most of the formatting functionality is available at compile time with a
-  notable exception of floating-point numbers and pointers.
-  Thanks `@alexezeder (Alexey Ochapov) <https://github.com/alexezeder>`_.
-
-* Optimized handling of format specifiers during format string compilation.
-  For example, hexadecimal formatting (``"{:x}"``) is now 3-7x faster than
-  before when using ``format_to`` with format string compilation and a
-  stack-allocated buffer (`#1944 <https://github.com/fmtlib/fmt/issues/1944>`_).
-
-  Before (7.1.3)::
-
-    ----------------------------------------------------------------------------
-    Benchmark                                  Time             CPU   Iterations
-    ----------------------------------------------------------------------------
-    FMTCompileOld/0                         15.5 ns         15.5 ns     43302898
-    FMTCompileOld/42                        16.6 ns         16.6 ns     43278267
-    FMTCompileOld/273123                    18.7 ns         18.6 ns     37035861
-    FMTCompileOld/9223372036854775807       19.4 ns         19.4 ns     35243000
-    ----------------------------------------------------------------------------
-
-  After (8.x)::
-
-    ----------------------------------------------------------------------------
-    Benchmark                                  Time             CPU   Iterations
-    ----------------------------------------------------------------------------
-    FMTCompileNew/0                         1.99 ns         1.99 ns    360523686
-    FMTCompileNew/42                        2.33 ns         2.33 ns    279865664
-    FMTCompileNew/273123                    3.72 ns         3.71 ns    190230315
-    FMTCompileNew/9223372036854775807       5.28 ns         5.26 ns    130711631
-    ----------------------------------------------------------------------------
-
-  It is even faster than ``std::to_chars`` from libc++ compiled with clang on
-  macOS::
-
-    ----------------------------------------------------------------------------
-    Benchmark                                  Time             CPU   Iterations
-    ----------------------------------------------------------------------------
-    ToChars/0                               4.42 ns         4.41 ns    160196630
-    ToChars/42                              5.00 ns         4.98 ns    140735201
-    ToChars/273123                          7.26 ns         7.24 ns     95784130
-    ToChars/9223372036854775807             8.77 ns         8.75 ns     75872534
-    ----------------------------------------------------------------------------
-
-  In other cases, especially involving ``std::string`` construction, the
-  speed up is usually lower because handling format specifiers takes a smaller
-  fraction of the total time.
-
-* Added the ``_cf`` user-defined literal to represent a compiled format string.
-  It can be used instead of the ``FMT_COMPILE`` macro
-  (`#2043 <https://github.com/fmtlib/fmt/pull/2043>`_,
-  `#2242 <https://github.com/fmtlib/fmt/pull/2242>`_):
-
-  .. code:: c++
-
-     #include <fmt/compile.h>
-
-     using namespace fmt::literals;
-     auto s = fmt::format(FMT_COMPILE("{}"), 42); // 🙁 not modern
-     auto s = fmt::format("{}"_cf, 42);           // 🙂 modern as hell
-
-  It requires compiler support for class types in non-type template parameters
-  (a C++20 feature) which is available in GCC 9.3+.
-  Thanks `@alexezeder (Alexey Ochapov) <https://github.com/alexezeder>`_.
-
-* Format string compilation now requires ``format`` functions of ``formatter``
-  specializations for user-defined types to be ``const``:
-
-  .. code:: c++
-
-     template <> struct fmt::formatter<my_type>: formatter<string_view> {
-       template <typename FormatContext>
-       auto format(my_type obj, FormatContext& ctx) const {  // Note const here.
-         // ...
-       }
-     };
-
-* Added UDL-based named argument support to format string compilation
-  (`#2243 <https://github.com/fmtlib/fmt/pull/2243>`_,
-  `#2281 <https://github.com/fmtlib/fmt/pull/2281>`_). For example:
-
-  .. code:: c++
-
-     #include <fmt/compile.h>
-
-     using namespace fmt::literals;
-     auto s = fmt::format(FMT_COMPILE("{answer}"), "answer"_a = 42);
-
-  Here the argument named "answer" is resolved at compile time with no
-  runtime overhead.
-  Thanks `@alexezeder (Alexey Ochapov) <https://github.com/alexezeder>`_.
-
-* Added format string compilation support to ``fmt::print``
-  (`#2280 <https://github.com/fmtlib/fmt/issues/2280>`_,
-  `#2304 <https://github.com/fmtlib/fmt/pull/2304>`_).
-  Thanks `@alexezeder (Alexey Ochapov) <https://github.com/alexezeder>`_.
-
-* Added initial support for compiling {fmt} as a C++20 module
-  (`#2235 <https://github.com/fmtlib/fmt/pull/2235>`_,
-  `#2240 <https://github.com/fmtlib/fmt/pull/2240>`_,
-  `#2260 <https://github.com/fmtlib/fmt/pull/2260>`_,
-  `#2282 <https://github.com/fmtlib/fmt/pull/2282>`_,
-  `#2283 <https://github.com/fmtlib/fmt/pull/2283>`_,
-  `#2288 <https://github.com/fmtlib/fmt/pull/2288>`_,
-  `#2298 <https://github.com/fmtlib/fmt/pull/2298>`_,
-  `#2306 <https://github.com/fmtlib/fmt/pull/2306>`_,
-  `#2307 <https://github.com/fmtlib/fmt/pull/2307>`_,
-  `#2309 <https://github.com/fmtlib/fmt/pull/2309>`_,
-  `#2318 <https://github.com/fmtlib/fmt/pull/2318>`_,
-  `#2324 <https://github.com/fmtlib/fmt/pull/2324>`_,
-  `#2332 <https://github.com/fmtlib/fmt/pull/2332>`_,
-  `#2340 <https://github.com/fmtlib/fmt/pull/2340>`_).
-  Thanks `@DanielaE (Daniela Engert) <https://github.com/DanielaE>`_.
-
-* Made symbols private by default reducing shared library size
-  (`#2301 <https://github.com/fmtlib/fmt/pull/2301>`_). For example there was
-  a ~15% reported reduction on one platform.
-  Thanks `@sergiud (Sergiu Deitsch) <https://github.com/sergiud>`_.
-
-* Optimized includes making the result of preprocessing ``fmt/format.h``
-  ~20% smaller with libstdc++/C++20 and slightly improving build times
-  (`#1998 <https://github.com/fmtlib/fmt/issues/1998>`_).
-
-* Added support of ranges with non-const ``begin`` / ``end``
-  (`#1953 <https://github.com/fmtlib/fmt/pull/1953>`_).
-  Thanks `@kitegi (sarah) <https://github.com/kitegi>`_.
-
-* Added support of ``std::byte`` and other formattable types to ``fmt::join``
-  (`#1981 <https://github.com/fmtlib/fmt/issues/1981>`_,
-  `#2040 <https://github.com/fmtlib/fmt/issues/2040>`_,
-  `#2050 <https://github.com/fmtlib/fmt/pull/2050>`_,
-  `#2262 <https://github.com/fmtlib/fmt/issues/2262>`_). For example:
-
-  .. code:: c++
-
-     #include <fmt/format.h>
-     #include <cstddef>
-     #include <vector>
-
-     int main() {
-       auto bytes = std::vector{std::byte(4), std::byte(2)};
-       fmt::print("{}", fmt::join(bytes, ""));
-     }
-
-  prints "42".
-
-  Thanks `@kamibo (Camille Bordignon) <https://github.com/kamibo>`_.
-
-* Implemented the default format for ``std::chrono::system_clock``
-  (`#2319 <https://github.com/fmtlib/fmt/issues/2319>`_,
-  `#2345 <https://github.com/fmtlib/fmt/pull/2345>`_). For example:
-
-  .. code:: c++
-
-     #include <fmt/chrono.h>
-
-     int main() {
-       fmt::print("{}", std::chrono::system_clock::now());
-     }
-
-  prints "2021-06-18 15:22:00" (the output depends on the current date and
-  time). Thanks `@sunmy2019 <https://github.com/sunmy2019>`_.
-
-* Made more chrono specifiers locale independent by default. Use the ``'L'``
-  specifier to get localized formatting. For example:
-
-  .. code:: c++
-
-     #include <fmt/chrono.h>
-
-     int main() {
-       std::locale::global(std::locale("ru_RU.UTF-8"));
-       auto monday = std::chrono::weekday(1);
-       fmt::print("{}\n", monday);   // prints "Mon"
-       fmt::print("{:L}\n", monday); // prints "пн"
-     }
-
-* Improved locale handling in chrono formatting
-  (`#2337 <https://github.com/fmtlib/fmt/issues/2337>`_,
-  `#2349 <https://github.com/fmtlib/fmt/pull/2349>`_,
-  `#2350 <https://github.com/fmtlib/fmt/pull/2350>`_).
-  Thanks `@phprus (Vladislav Shchapov) <https://github.com/phprus>`_.
-
-* Deprecated ``fmt/locale.h`` moving the formatting functions that take a
-  locale to ``fmt/format.h`` (``char``) and ``fmt/xchar`` (other overloads).
-  This doesn't introduce a dependency on ``<locale>`` so there is virtually no
-  compile time effect.
-
-* Deprecated an undocumented ``format_to`` overload that takes
-  ``basic_memory_buffer``.
-
-* Made parameter order in ``vformat_to`` consistent with ``format_to``
-  (`#2327 <https://github.com/fmtlib/fmt/issues/2327>`_).
-
-* Added support for time points with arbitrary durations
-  (`#2208 <https://github.com/fmtlib/fmt/issues/2208>`_). For example:
-
-  .. code:: c++
-
-     #include <fmt/chrono.h>
-
-     int main() {
-       using tp = std::chrono::time_point<
-         std::chrono::system_clock, std::chrono::seconds>;
-       fmt::print("{:%S}", tp(std::chrono::seconds(42)));
-     }
-
-  prints "42".
-
-* Formatting floating-point numbers no longer produces trailing zeros by default
-  for consistency with ``std::format``. For example:
-
-  .. code:: c++
-
-     #include <fmt/core.h>
-
-     int main() {
-       fmt::print("{0:.3}", 1.1);
-     }
-
-  prints "1.1". Use the ``'#'`` specifier to keep trailing zeros.
-
-* Dropped a limit on the number of elements in a range and replaced ``{}`` with
-  ``[]`` as range delimiters for consistency with Python's ``str.format``.
-
-* The ``'L'`` specifier for locale-specific numeric formatting can now be
-  combined with presentation specifiers as in ``std::format``. For example:
-
-  .. code:: c++
-
-     #include <fmt/core.h>
-     #include <locale>
-
-     int main() {
-       std::locale::global(std::locale("fr_FR.UTF-8"));
-       fmt::print("{0:.2Lf}", 0.42);
-     }
-
-  prints "0,42". The deprecated ``'n'`` specifier has been removed.
-
-* Made the ``0`` specifier ignored for infinity and NaN
-  (`#2305 <https://github.com/fmtlib/fmt/issues/2305>`_,
-  `#2310 <https://github.com/fmtlib/fmt/pull/2310>`_).
-  Thanks `@Liedtke (Matthias Liedtke) <https://github.com/Liedtke>`_.
-
-* Made the hexfloat formatting use the right alignment by default
-  (`#2308 <https://github.com/fmtlib/fmt/issues/2308>`_,
-  `#2317 <https://github.com/fmtlib/fmt/pull/2317>`_).
-  Thanks `@Liedtke (Matthias Liedtke) <https://github.com/Liedtke>`_.
-
-* Removed the deprecated numeric alignment (``'='``). Use the ``'0'`` specifier
-  instead.
-
-* Removed the deprecated ``fmt/posix.h`` header that has been replaced with
-  ``fmt/os.h``.
-
-* Removed the deprecated ``format_to_n_context``, ``format_to_n_args`` and
-  ``make_format_to_n_args``. They have been replaced with ``format_context``,
-  ``format_args` and ``make_format_args`` respectively.
-
-* Moved ``wchar_t``-specific functions and types to ``fmt/xchar.h``.
-  You can define ``FMT_DEPRECATED_INCLUDE_XCHAR`` to automatically include
-  ``fmt/xchar.h`` from ``fmt/format.h`` but this will be disabled in the next
-  major release.
-
-* Fixed handling of the ``'+'`` specifier in localized formatting
-  (`#2133 <https://github.com/fmtlib/fmt/issues/2133>`_).
-
-* Added support for the ``'s'`` format specifier that gives textual
-  representation of ``bool``
-  (`#2094 <https://github.com/fmtlib/fmt/issues/2094>`_,
-  `#2109 <https://github.com/fmtlib/fmt/pull/2109>`_). For example:
-
-  .. code:: c++
-
-     #include <fmt/core.h>
-
-     int main() {
-       fmt::print("{:s}", true);
-     }
-
-  prints "true".
-  Thanks `@powercoderlol (Ivan Polyakov) <https://github.com/powercoderlol>`_.
-
-* Made ``fmt::ptr`` work with function pointers
-  (`#2131 <https://github.com/fmtlib/fmt/pull/2131>`_). For example:
-
-  .. code:: c++
-
-     #include <fmt/format.h>
-
-     int main() {
-       fmt::print("My main: {}\n", fmt::ptr(main));
-     }
-
-  Thanks `@mikecrowe (Mike Crowe) <https://github.com/mikecrowe>`_.
-
-* The undocumented support for specializing ``formatter`` for pointer types
-  has been removed.
-
-* Fixed ``fmt::formatted_size`` with format string compilation
-  (`#2141 <https://github.com/fmtlib/fmt/pull/2141>`_,
-  `#2161 <https://github.com/fmtlib/fmt/pull/2161>`_).
-  Thanks `@alexezeder (Alexey Ochapov) <https://github.com/alexezeder>`_.
-
-* Fixed handling of empty format strings during format string compilation
-  (`#2042 <https://github.com/fmtlib/fmt/issues/2042>`_):
-
-  .. code:: c++
-
-     auto s = fmt::format(FMT_COMPILE(""));
-
-  Thanks `@alexezeder (Alexey Ochapov) <https://github.com/alexezeder>`_.
-
-* Fixed handling of enums in ``fmt::to_string``
-  (`#2036 <https://github.com/fmtlib/fmt/issues/2036>`_).
-
-* Improved width computation
-  (`#2033 <https://github.com/fmtlib/fmt/issues/2033>`_,
-  `#2091 <https://github.com/fmtlib/fmt/issues/2091>`_). For example:
-
-  .. code:: c++
-
-     #include <fmt/core.h>
-
-     int main() {
-       fmt::print("{:-<10}{}\n", "你好", "世界");
-       fmt::print("{:-<10}{}\n", "hello", "world");
-     }
-
-  prints
-
-  .. image:: https://user-images.githubusercontent.com/576385/
-             119840373-cea3ca80-beb9-11eb-91e0-54266c48e181.png
-
-  on a modern terminal.
-
-* The experimental fast output stream (``fmt::ostream``) is now truncated by
-  default for consistency with ``fopen``
-  (`#2018 <https://github.com/fmtlib/fmt/issues/2018>`_). For example:
-
-  .. code:: c++
-
-     #include <fmt/os.h>
-
-     int main() {
-       fmt::ostream out1 = fmt::output_file("guide");
-       out1.print("Zaphod");
-       out1.close();
-       fmt::ostream out2 = fmt::output_file("guide");
-       out2.print("Ford");
-     }
-
-  writes "Ford" to the file "guide". To preserve the old file content if any
-  pass ``fmt::file::WRONLY | fmt::file::CREATE`` flags to ``fmt::output_file``.
-
-* Fixed moving of ``fmt::ostream`` that holds buffered data
-  (`#2197 <https://github.com/fmtlib/fmt/issues/2197>`_,
-  `#2198 <https://github.com/fmtlib/fmt/pull/2198>`_).
-  Thanks `@vtta <https://github.com/vtta>`_.
-
-* Replaced the ``fmt::system_error`` exception with a function of the same
-  name that constructs ``std::system_error``
-  (`#2266 <https://github.com/fmtlib/fmt/issues/2266>`_).
-
-* Replaced the ``fmt::windows_error`` exception with a function of the same
-  name that constructs ``std::system_error`` with the category returned by
-  ``fmt::system_category()``
-  (`#2274 <https://github.com/fmtlib/fmt/issues/2274>`_,
-  `#2275 <https://github.com/fmtlib/fmt/pull/2275>`_).
-  The latter is similar to ``std::sytem_category`` but correctly handles UTF-8.
-  Thanks `@phprus (Vladislav Shchapov) <https://github.com/phprus>`_.
-
-* Replaced ``fmt::error_code`` with ``std::error_code`` and made it formattable
-  (`#2269 <https://github.com/fmtlib/fmt/issues/2269>`_,
-  `#2270 <https://github.com/fmtlib/fmt/pull/2270>`_,
-  `#2273 <https://github.com/fmtlib/fmt/pull/2273>`_).
-  Thanks `@phprus (Vladislav Shchapov) <https://github.com/phprus>`_.
- 
-* Added speech synthesis support
-  (`#2206 <https://github.com/fmtlib/fmt/pull/2206>`_).
-
-* Made ``format_to`` work with a memory buffer that has a custom allocator
-  (`#2300 <https://github.com/fmtlib/fmt/pull/2300>`_).
-  Thanks `@voxmea <https://github.com/voxmea>`_.
-
-* Added ``Allocator::max_size`` support to ``basic_memory_buffer``.
-  (`#1960 <https://github.com/fmtlib/fmt/pull/1960>`_).
-  Thanks `@phprus (Vladislav Shchapov) <https://github.com/phprus>`_.
-
-* Added wide string support to ``fmt::join``
-  (`#2236 <https://github.com/fmtlib/fmt/pull/2236>`_).
-  Thanks `@crbrz <https://github.com/crbrz>`_.
-
-* Made iterators passed to ``formatter`` specializations via a format context
-  satisfy C++20 ``std::output_iterator`` requirements
-  (`#2156 <https://github.com/fmtlib/fmt/issues/2156>`_,
-  `#2158 <https://github.com/fmtlib/fmt/pull/2158>`_,
-  `#2195 <https://github.com/fmtlib/fmt/issues/2195>`_,
-  `#2204 <https://github.com/fmtlib/fmt/pull/2204>`_).
-  Thanks `@randomnetcat (Jason Cobb) <https://github.com/randomnetcat>`_.
-
-* Optimized the ``printf`` implementation
-  (`#1982 <https://github.com/fmtlib/fmt/pull/1982>`_,
-  `#1984 <https://github.com/fmtlib/fmt/pull/1984>`_,
-  `#2016 <https://github.com/fmtlib/fmt/pull/2016>`_,
-  `#2164 <https://github.com/fmtlib/fmt/pull/2164>`_).
-  Thanks `@rimathia <https://github.com/rimathia>`_ and
-  `@moiwi <https://github.com/moiwi>`_.
-
-* Improved detection of ``constexpr`` ``char_traits``
-  (`#2246 <https://github.com/fmtlib/fmt/pull/2246>`_,
-  `#2257 <https://github.com/fmtlib/fmt/pull/2257>`_).
-  Thanks `@phprus (Vladislav Shchapov) <https://github.com/phprus>`_.
-
-* Fixed writing to ``stdout`` when it is redirected to ``NUL`` on Windows
-  (`#2080 <https://github.com/fmtlib/fmt/issues/2080>`_).
-
-* Fixed exception propagation from iterators
-  (`#2097 <https://github.com/fmtlib/fmt/issues/2097>`_).
-  
-* Improved ``strftime`` error handling 
-  (`#2238 <https://github.com/fmtlib/fmt/issues/2238>`_,
-  `#2244 <https://github.com/fmtlib/fmt/pull/2244>`_).
-  Thanks `@yumeyao <https://github.com/yumeyao>`_.
-
-* Stopped using deprecated GCC UDL template extension.
-
-* Added ``fmt/args.h`` to the install target
-  (`#2096 <https://github.com/fmtlib/fmt/issues/2096>`_).
-
-* Error messages are now passed to assert when exceptions are disabled
-  (`#2145 <https://github.com/fmtlib/fmt/pull/2145>`_).
-  Thanks `@NobodyXu (Jiahao XU) <https://github.com/NobodyXu>`_.
-
-* Added the ``FMT_MASTER_PROJECT`` CMake option to control build and install
-  targets when {fmt} is included via ``add_subdirectory``
-  (`#2098 <https://github.com/fmtlib/fmt/issues/2098>`_,
-  `#2100 <https://github.com/fmtlib/fmt/pull/2100>`_).
-  Thanks `@randomizedthinking <https://github.com/randomizedthinking>`_.
-
-* Improved build configuration
-  (`#2026 <https://github.com/fmtlib/fmt/pull/2026>`_,
-  `#2122 <https://github.com/fmtlib/fmt/pull/2122>`_).
-  Thanks `@luncliff (Park DongHa) <https://github.com/luncliff>`_ and
-  `@ibaned (Dan Ibanez) <https://github.com/ibaned>`_.
-
-* Fixed various warnings and compilation issues
-  (`#1947 <https://github.com/fmtlib/fmt/issues/1947>`_,
-  `#1959 <https://github.com/fmtlib/fmt/pull/1959>`_,
-  `#1963 <https://github.com/fmtlib/fmt/pull/1963>`_,
-  `#1965 <https://github.com/fmtlib/fmt/pull/1965>`_,
-  `#1966 <https://github.com/fmtlib/fmt/issues/1966>`_,
-  `#1974 <https://github.com/fmtlib/fmt/pull/1974>`_,
-  `#1975 <https://github.com/fmtlib/fmt/pull/1975>`_,
-  `#1990 <https://github.com/fmtlib/fmt/pull/1990>`_,
-  `#2000 <https://github.com/fmtlib/fmt/issues/2000>`_,
-  `#2001 <https://github.com/fmtlib/fmt/pull/2001>`_,
-  `#2002 <https://github.com/fmtlib/fmt/issues/2002>`_,
-  `#2004 <https://github.com/fmtlib/fmt/issues/2004>`_,
-  `#2006 <https://github.com/fmtlib/fmt/pull/2006>`_,
-  `#2009 <https://github.com/fmtlib/fmt/pull/2009>`_,
-  `#2010 <https://github.com/fmtlib/fmt/pull/2010>`_,
-  `#2038 <https://github.com/fmtlib/fmt/issues/2038>`_,
-  `#2039 <https://github.com/fmtlib/fmt/issues/2039>`_,
-  `#2047 <https://github.com/fmtlib/fmt/issues/2047>`_,
-  `#2053 <https://github.com/fmtlib/fmt/pull/2053>`_,
-  `#2059 <https://github.com/fmtlib/fmt/issues/2059>`_,
-  `#2065 <https://github.com/fmtlib/fmt/pull/2065>`_,
-  `#2067 <https://github.com/fmtlib/fmt/pull/2067>`_,
-  `#2068 <https://github.com/fmtlib/fmt/pull/2068>`_,
-  `#2073 <https://github.com/fmtlib/fmt/pull/2073>`_,
-  `#2103 <https://github.com/fmtlib/fmt/issues/2103>`_,
-  `#2105 <https://github.com/fmtlib/fmt/issues/2105>`_,
-  `#2106 <https://github.com/fmtlib/fmt/pull/2106>`_,
-  `#2107 <https://github.com/fmtlib/fmt/pull/2107>`_,
-  `#2116 <https://github.com/fmtlib/fmt/issues/2116>`_,
-  `#2117 <https://github.com/fmtlib/fmt/pull/2117>`_,
-  `#2118 <https://github.com/fmtlib/fmt/issues/2118>`_,
-  `#2119 <https://github.com/fmtlib/fmt/pull/2119>`_,
-  `#2127 <https://github.com/fmtlib/fmt/issues/2127>`_,
-  `#2128 <https://github.com/fmtlib/fmt/pull/2128>`_,
-  `#2140 <https://github.com/fmtlib/fmt/issues/2140>`_,
-  `#2142 <https://github.com/fmtlib/fmt/issues/2142>`_,
-  `#2143 <https://github.com/fmtlib/fmt/pull/2143>`_,
-  `#2144 <https://github.com/fmtlib/fmt/pull/2144>`_,
-  `#2147 <https://github.com/fmtlib/fmt/issues/2147>`_,
-  `#2148 <https://github.com/fmtlib/fmt/issues/2148>`_,
-  `#2149 <https://github.com/fmtlib/fmt/issues/2149>`_,
-  `#2152 <https://github.com/fmtlib/fmt/pull/2152>`_,
-  `#2160 <https://github.com/fmtlib/fmt/pull/2160>`_,
-  `#2170 <https://github.com/fmtlib/fmt/issues/2170>`_,
-  `#2175 <https://github.com/fmtlib/fmt/issues/2175>`_,
-  `#2176 <https://github.com/fmtlib/fmt/issues/2176>`_,
-  `#2177 <https://github.com/fmtlib/fmt/pull/2177>`_,
-  `#2178 <https://github.com/fmtlib/fmt/issues/2178>`_,
-  `#2179 <https://github.com/fmtlib/fmt/pull/2179>`_,
-  `#2180 <https://github.com/fmtlib/fmt/issues/2180>`_,
-  `#2181 <https://github.com/fmtlib/fmt/issues/2181>`_,
-  `#2183 <https://github.com/fmtlib/fmt/pull/2183>`_,
-  `#2184 <https://github.com/fmtlib/fmt/issues/2184>`_,
-  `#2185 <https://github.com/fmtlib/fmt/issues/2185>`_,
-  `#2186 <https://github.com/fmtlib/fmt/pull/2186>`_,
-  `#2187 <https://github.com/fmtlib/fmt/pull/2187>`_,
-  `#2190 <https://github.com/fmtlib/fmt/pull/2190>`_,
-  `#2192 <https://github.com/fmtlib/fmt/pull/2192>`_,
-  `#2194 <https://github.com/fmtlib/fmt/pull/2194>`_,
-  `#2205 <https://github.com/fmtlib/fmt/pull/2205>`_,
-  `#2210 <https://github.com/fmtlib/fmt/issues/2210>`_,
-  `#2211 <https://github.com/fmtlib/fmt/pull/2211>`_,
-  `#2215 <https://github.com/fmtlib/fmt/pull/2215>`_,
-  `#2216 <https://github.com/fmtlib/fmt/pull/2216>`_,
-  `#2218 <https://github.com/fmtlib/fmt/pull/2218>`_,
-  `#2220 <https://github.com/fmtlib/fmt/pull/2220>`_,
-  `#2228 <https://github.com/fmtlib/fmt/issues/2228>`_,
-  `#2229 <https://github.com/fmtlib/fmt/pull/2229>`_,
-  `#2230 <https://github.com/fmtlib/fmt/pull/2230>`_,
-  `#2233 <https://github.com/fmtlib/fmt/issues/2233>`_,
-  `#2239 <https://github.com/fmtlib/fmt/pull/2239>`_,
-  `#2248 <https://github.com/fmtlib/fmt/issues/2248>`_,
-  `#2252 <https://github.com/fmtlib/fmt/issues/2252>`_,
-  `#2253 <https://github.com/fmtlib/fmt/pull/2253>`_,
-  `#2255 <https://github.com/fmtlib/fmt/pull/2255>`_,
-  `#2261 <https://github.com/fmtlib/fmt/issues/2261>`_,
-  `#2278 <https://github.com/fmtlib/fmt/issues/2278>`_,
-  `#2284 <https://github.com/fmtlib/fmt/issues/2284>`_,
-  `#2287 <https://github.com/fmtlib/fmt/pull/2287>`_,
-  `#2289 <https://github.com/fmtlib/fmt/pull/2289>`_,
-  `#2290 <https://github.com/fmtlib/fmt/pull/2290>`_,
-  `#2293 <https://github.com/fmtlib/fmt/pull/2293>`_,
-  `#2295 <https://github.com/fmtlib/fmt/issues/2295>`_,
-  `#2296 <https://github.com/fmtlib/fmt/pull/2296>`_,
-  `#2297 <https://github.com/fmtlib/fmt/pull/2297>`_,
-  `#2311 <https://github.com/fmtlib/fmt/issues/2311>`_,
-  `#2313 <https://github.com/fmtlib/fmt/pull/2313>`_,
-  `#2315 <https://github.com/fmtlib/fmt/pull/2315>`_,
-  `#2320 <https://github.com/fmtlib/fmt/issues/2320>`_,
-  `#2321 <https://github.com/fmtlib/fmt/pull/2321>`_,
-  `#2323 <https://github.com/fmtlib/fmt/pull/2323>`_,
-  `#2328 <https://github.com/fmtlib/fmt/issues/2328>`_,
-  `#2329 <https://github.com/fmtlib/fmt/pull/2329>`_,
-  `#2333 <https://github.com/fmtlib/fmt/pull/2333>`_,
-  `#2338 <https://github.com/fmtlib/fmt/pull/2338>`_,
-  `#2341 <https://github.com/fmtlib/fmt/pull/2341>`_).
-  Thanks `@darklukee <https://github.com/darklukee>`_,
-  `@fagg (Ashton Fagg) <https://github.com/fagg>`_,
-  `@killerbot242 (Lieven de Cock) <https://github.com/killerbot242>`_,
-  `@jgopel (Jonathan Gopel) <https://github.com/jgopel>`_,
-  `@yeswalrus (Walter Gray) <https://github.com/yeswalrus>`_,
-  `@Finkman <https://github.com/Finkman>`_,
-  `@HazardyKnusperkeks (Björn Schäpers) <https://github.com/HazardyKnusperkeks>`_,
-  `@dkavolis (Daumantas Kavolis) <https://github.com/dkavolis>`_,
-  `@concatime (Issam Maghni) <https://github.com/concatime>`_,
-  `@chronoxor (Ivan Shynkarenka) <https://github.com/chronoxor>`_,
-  `@summivox (Yin Zhong) <https://github.com/summivox>`_,
-  `@yNeo <https://github.com/yNeo>`_,
-  `@Apache-HB (Elliot) <https://github.com/Apache-HB>`_,
-  `@alexezeder (Alexey Ochapov) <https://github.com/alexezeder>`_,
-  `@toojays (John Steele Scott) <https://github.com/toojays>`_,
-  `@Brainy0207 <https://github.com/Brainy0207>`_,
-  `@vadz (VZ) <https://github.com/vadz>`_,
-  `@imsherlock (Ryan Sherlock) <https://github.com/imsherlock>`_,
-  `@phprus (Vladislav Shchapov) <https://github.com/phprus>`_,
-  `@white238 (Chris White) <https://github.com/white238>`_,
-  `@yafshar (Yaser Afshar) <https://github.com/yafshar>`_,
-  `@BillyDonahue (Billy Donahue) <https://github.com/BillyDonahue>`_,
-  `@jstaahl <https://github.com/jstaahl>`_,
-  `@denchat <https://github.com/denchat>`_,
-  `@DanielaE (Daniela Engert) <https://github.com/DanielaE>`_,
-  `@ilyakurdyukov (Ilya Kurdyukov) <https://github.com/ilyakurdyukov>`_,
-  `@ilmai <https://github.com/ilmai>`_,
-  `@JessyDL (Jessy De Lannoit) <https://github.com/JessyDL>`_,
-  `@sergiud (Sergiu Deitsch) <https://github.com/sergiud>`_,
-  `@mwinterb <https://github.com/mwinterb>`_,
-  `@sven-herrmann <https://github.com/sven-herrmann>`_,
-  `@jmelas (John Melas) <https://github.com/jmelas>`_,
-  `@twoixter (Jose Miguel Pérez) <https://github.com/twoixter>`_,
-  `@crbrz <https://github.com/crbrz>`_,
-  `@upsj (Tobias Ribizel) <https://github.com/upsj>`_.
-
-* Improved documentation
-  (`#1986 <https://github.com/fmtlib/fmt/issues/1986>`_,
-  `#2051 <https://github.com/fmtlib/fmt/pull/2051>`_,
-  `#2057 <https://github.com/fmtlib/fmt/issues/2057>`_,
-  `#2081 <https://github.com/fmtlib/fmt/pull/2081>`_,
-  `#2084 <https://github.com/fmtlib/fmt/issues/2084>`_,
-  `#2312 <https://github.com/fmtlib/fmt/pull/2312>`_).
-  Thanks `@imba-tjd (谭九鼎) <https://github.com/imba-tjd>`_,
-  `@0x416c69 (AlιAѕѕaѕѕιN) <https://github.com/0x416c69>`_,
-  `@mordante <https://github.com/mordante>`_.
-
-* Continuous integration and test improvements
-  (`#1969 <https://github.com/fmtlib/fmt/issues/1969>`_,
-  `#1991 <https://github.com/fmtlib/fmt/pull/1991>`_,
-  `#2020 <https://github.com/fmtlib/fmt/pull/2020>`_,
-  `#2110 <https://github.com/fmtlib/fmt/pull/2110>`_,
-  `#2114 <https://github.com/fmtlib/fmt/pull/2114>`_,
-  `#2196 <https://github.com/fmtlib/fmt/issues/2196>`_,
-  `#2217 <https://github.com/fmtlib/fmt/pull/2217>`_,
-  `#2247 <https://github.com/fmtlib/fmt/pull/2247>`_,
-  `#2256 <https://github.com/fmtlib/fmt/pull/2256>`_,
-  `#2336 <https://github.com/fmtlib/fmt/pull/2336>`_,
-  `#2346 <https://github.com/fmtlib/fmt/pull/2346>`_).
-  Thanks `@jgopel (Jonathan Gopel) <https://github.com/jgopel>`_,
-  `@alexezeder (Alexey Ochapov) <https://github.com/alexezeder>`_ and
-  `@DanielaE (Daniela Engert) <https://github.com/DanielaE>`_.
-  
-7.1.3 - 2020-11-24
-------------------
-
-* Fixed handling of buffer boundaries in ``format_to_n``
-  (`#1996 <https://github.com/fmtlib/fmt/issues/1996>`_,
-  `#2029 <https://github.com/fmtlib/fmt/issues/2029>`_).
-
-* Fixed linkage errors when linking with a shared library
-  (`#2011 <https://github.com/fmtlib/fmt/issues/2011>`_).
-
-* Reintroduced ostream support to range formatters
-  (`#2014 <https://github.com/fmtlib/fmt/issues/2014>`_).
-
-* Worked around an issue with mixing std versions in gcc
-  (`#2017 <https://github.com/fmtlib/fmt/issues/2017>`_).
-
-7.1.2 - 2020-11-04
-------------------
-
-* Fixed floating point formatting with large precision
-  (`#1976 <https://github.com/fmtlib/fmt/issues/1976>`_).
-
-7.1.1 - 2020-11-01
-------------------
-
-* Fixed ABI compatibility with 7.0.x
-  (`#1961 <https://github.com/fmtlib/fmt/issues/1961>`_).
-
-* Added the ``FMT_ARM_ABI_COMPATIBILITY`` macro to work around ABI
-  incompatibility between GCC and Clang on ARM
-  (`#1919 <https://github.com/fmtlib/fmt/issues/1919>`_).
-
-* Worked around a SFINAE bug in GCC 8
-  (`#1957 <https://github.com/fmtlib/fmt/issues/1957>`_).
-
-* Fixed linkage errors when building with GCC's LTO
-  (`#1955 <https://github.com/fmtlib/fmt/issues/1955>`_).
-
-* Fixed a compilation error when building without ``__builtin_clz`` or equivalent
-  (`#1968 <https://github.com/fmtlib/fmt/pull/1968>`_).
-  Thanks `@tohammer (Tobias Hammer) <https://github.com/tohammer>`_.
-
-* Fixed a sign conversion warning
-  (`#1964 <https://github.com/fmtlib/fmt/pull/1964>`_).
-  Thanks `@OptoCloud <https://github.com/OptoCloud>`_.
-
-7.1.0 - 2020-10-25
-------------------
-
-* Switched from `Grisu3
-  <https://www.cs.tufts.edu/~nr/cs257/archive/florian-loitsch/printf.pdf>`_
-  to `Dragonbox <https://github.com/jk-jeon/dragonbox>`_ for the default
-  floating-point formatting which gives the shortest decimal representation
-  with round-trip guarantee and correct rounding
-  (`#1882 <https://github.com/fmtlib/fmt/pull/1882>`_,
-  `#1887 <https://github.com/fmtlib/fmt/pull/1887>`_,
-  `#1894 <https://github.com/fmtlib/fmt/pull/1894>`_). This makes {fmt} up to
-  20-30x faster than common implementations of ``std::ostringstream`` and
-  ``sprintf`` on `dtoa-benchmark <https://github.com/fmtlib/dtoa-benchmark>`_
-  and faster than double-conversion and Ryū:
-
-  .. image:: https://user-images.githubusercontent.com/576385/
-             95684665-11719600-0ba8-11eb-8e5b-972ff4e49428.png
-
-  It is possible to get even better performance at the cost of larger binary
-  size by compiling with the ``FMT_USE_FULL_CACHE_DRAGONBOX`` macro set to 1.
-
-  Thanks `@jk-jeon (Junekey Jeon) <https://github.com/jk-jeon>`_.
-
-* Added an experimental unsynchronized file output API which, together with
-  `format string compilation <https://fmt.dev/latest/api.html#compile-api>`_,
-  can give `5-9 times speed up compared to fprintf
-  <https://www.zverovich.net/2020/08/04/optimal-file-buffer-size.html>`_
-  on common platforms (`godbolt <https://godbolt.org/z/nsTcG8>`__):
-
-  .. code:: c++
-
-     #include <fmt/os.h>
-
-     int main() {
-       auto f = fmt::output_file("guide");
-       f.print("The answer is {}.", 42);
-     }
-
-* Added a formatter for ``std::chrono::time_point<system_clock>``
-  (`#1819 <https://github.com/fmtlib/fmt/issues/1819>`_,
-  `#1837 <https://github.com/fmtlib/fmt/pull/1837>`_). For example
-  (`godbolt <https://godbolt.org/z/c4M6fh>`__):
-
-  .. code:: c++
-
-     #include <fmt/chrono.h>
-
-     int main() {
-       auto now = std::chrono::system_clock::now();
-       fmt::print("The time is {:%H:%M:%S}.\n", now);
-     }
-
-  Thanks `@adamburgess (Adam Burgess) <https://github.com/adamburgess>`_.
-
-* Added support for ranges with non-const ``begin``/``end`` to ``fmt::join``
-  (`#1784 <https://github.com/fmtlib/fmt/issues/1784>`_,
-  `#1786 <https://github.com/fmtlib/fmt/pull/1786>`_). For example
-  (`godbolt <https://godbolt.org/z/jP63Tv>`__):
-
-  .. code:: c++
-
-     #include <fmt/ranges.h>
-     #include <range/v3/view/filter.hpp>
-
-     int main() {
-       using std::literals::string_literals::operator""s;
-       auto strs = std::array{"a"s, "bb"s, "ccc"s};
-       auto range = strs | ranges::views::filter(
-         [] (const std::string &x) { return x.size() != 2; }
-       );
-       fmt::print("{}\n", fmt::join(range, ""));
-     }
-
-  prints "accc".
-
-  Thanks `@tonyelewis (Tony E Lewis) <https://github.com/tonyelewis>`_.
-
-* Added a ``memory_buffer::append`` overload that takes a range
-  (`#1806 <https://github.com/fmtlib/fmt/pull/1806>`_).
-  Thanks `@BRevzin (Barry Revzin) <https://github.com/BRevzin>`_.
-
-* Improved handling of single code units in ``FMT_COMPILE``. For example:
-
-  .. code:: c++
-
-     #include <fmt/compile.h>
-
-     char* f(char* buf) {
-       return fmt::format_to(buf, FMT_COMPILE("x{}"), 42);
-     }
-
-  compiles to just (`godbolt <https://godbolt.org/z/5vncz3>`__):
-
-  .. code:: asm
-
-     _Z1fPc:
-       movb $120, (%rdi)
-       xorl %edx, %edx
-       cmpl $42, _ZN3fmt2v76detail10basic_dataIvE23zero_or_powers_of_10_32E+8(%rip)
-       movl $3, %eax
-       seta %dl
-       subl %edx, %eax
-       movzwl _ZN3fmt2v76detail10basic_dataIvE6digitsE+84(%rip), %edx
-       cltq
-       addq %rdi, %rax
-       movw %dx, -2(%rax)
-       ret
-
-  Here a single ``mov`` instruction writes ``'x'`` (``$120``) to the output
-  buffer.
-
-* Added dynamic width support to format string compilation
-  (`#1809 <https://github.com/fmtlib/fmt/issues/1809>`_).
-
-* Improved error reporting for unformattable types: now you'll get the type name
-  directly in the error message instead of the note:
-
-  .. code:: c++
-
-     #include <fmt/core.h>
-
-     struct how_about_no {};
-
-     int main() {
-       fmt::print("{}", how_about_no());
-     }
-
-  Error (`godbolt <https://godbolt.org/z/GoxM4e>`__):
-
-  ``fmt/core.h:1438:3: error: static_assert failed due to requirement
-  'fmt::v7::formattable<how_about_no>()' "Cannot format an argument.
-  To make type T formattable provide a formatter<T> specialization:
-  https://fmt.dev/latest/api.html#udt"
-  ...``
-
-* Added the `make_args_checked <https://fmt.dev/7.1.0/api.html#argument-lists>`_
-  function template that allows you to write formatting functions with
-  compile-time format string checks and avoid binary code bloat
-  (`godbolt <https://godbolt.org/z/PEf9qr>`__):
-
-  .. code:: c++
-
-     void vlog(const char* file, int line, fmt::string_view format,
-               fmt::format_args args) {
-       fmt::print("{}: {}: ", file, line);
-       fmt::vprint(format, args);
-     }
-
-     template <typename S, typename... Args>
-     void log(const char* file, int line, const S& format, Args&&... args) {
-       vlog(file, line, format,
-           fmt::make_args_checked<Args...>(format, args...));
-     }
-
-     #define MY_LOG(format, ...) \
-       log(__FILE__, __LINE__, FMT_STRING(format), __VA_ARGS__)
-
-     MY_LOG("invalid squishiness: {}", 42);
-
-* Replaced ``snprintf`` fallback with a faster internal IEEE 754 ``float`` and
-  ``double`` formatter for arbitrary precision. For example
-  (`godbolt <https://godbolt.org/z/dPhWvj>`__):
-
-  .. code:: c++
-
-     #include <fmt/core.h>
-
-     int main() {
-       fmt::print("{:.500}\n", 4.9406564584124654E-324);
-     }
-
-  prints
-
-  ``4.9406564584124654417656879286822137236505980261432476442558568250067550727020875186529983636163599237979656469544571773092665671035593979639877479601078187812630071319031140452784581716784898210368871863605699873072305000638740915356498438731247339727316961514003171538539807412623856559117102665855668676818703956031062493194527159149245532930545654440112748012970999954193198940908041656332452475714786901472678015935523861155013480352649347201937902681071074917033322268447533357208324319360923829e-324``.
-
-* Made ``format_to_n`` and ``formatted_size`` part of the `core API
-  <https://fmt.dev/latest/api.html#core-api>`__
-  (`godbolt <https://godbolt.org/z/sPjY1K>`__):
-
-  .. code:: c++
-
-     #include <fmt/core.h>
-
-     int main() {
-       char buffer[10];
-       auto result = fmt::format_to_n(buffer, sizeof(buffer), "{}", 42);
-     }
-
-* Added ``fmt::format_to_n`` overload with format string compilation
-  (`#1764 <https://github.com/fmtlib/fmt/issues/1764>`_,
-  `#1767 <https://github.com/fmtlib/fmt/pull/1767>`_,
-  `#1869 <https://github.com/fmtlib/fmt/pull/1869>`_). For example
-  (`godbolt <https://godbolt.org/z/93h86q>`__):
-
-  .. code:: c++
-
-     #include <fmt/compile.h>
-
-     int main() {
-       char buffer[8];
-       fmt::format_to_n(buffer, sizeof(buffer), FMT_COMPILE("{}"), 42);
-     }
-
-  Thanks `@Kurkin (Dmitry Kurkin) <https://github.com/Kurkin>`_,
-  `@alexezeder (Alexey Ochapov) <https://github.com/alexezeder>`_.
-
-* Added ``fmt::format_to`` overload that take ``text_style``
-  (`#1593 <https://github.com/fmtlib/fmt/issues/1593>`_,
-  `#1842 <https://github.com/fmtlib/fmt/issues/1842>`_,
-  `#1843 <https://github.com/fmtlib/fmt/pull/1843>`_). For example
-  (`godbolt <https://godbolt.org/z/91153r>`__):
-
-  .. code:: c++
-
-     #include <fmt/color.h>
-
-     int main() {
-       std::string out;
-       fmt::format_to(std::back_inserter(out),
-                      fmt::emphasis::bold | fg(fmt::color::red),
-                      "The answer is {}.", 42);
-     }
-
-  Thanks `@Naios (Denis Blank) <https://github.com/Naios>`_.
-
-* Made the ``'#'`` specifier emit trailing zeros in addition to the decimal
-  point (`#1797 <https://github.com/fmtlib/fmt/issues/1797>`_). For example
-  (`godbolt <https://godbolt.org/z/bhdcW9>`__):
-
-  .. code:: c++
-
-     #include <fmt/core.h>
-
-     int main() {
-       fmt::print("{:#.2g}", 0.5);
-     }
-
-  prints ``0.50``.
-
-* Changed the default floating point format to not include ``.0`` for
-  consistency with ``std::format`` and ``std::to_chars``
-  (`#1893 <https://github.com/fmtlib/fmt/issues/1893>`_,
-  `#1943 <https://github.com/fmtlib/fmt/issues/1943>`_). It is possible to get
-  the decimal point and trailing zero with the ``#`` specifier.
-
-* Fixed an issue with floating-point formatting that could result in addition of
-  a non-significant trailing zero in rare cases e.g. ``1.00e-34`` instead of
-  ``1.0e-34`` (`#1873 <https://github.com/fmtlib/fmt/issues/1873>`_,
-  `#1917 <https://github.com/fmtlib/fmt/issues/1917>`_).
-
-* Made ``fmt::to_string`` fallback on ``ostream`` insertion operator if
-  the ``formatter`` specialization is not provided
-  (`#1815 <https://github.com/fmtlib/fmt/issues/1815>`_,
-  `#1829 <https://github.com/fmtlib/fmt/pull/1829>`_).
-  Thanks `@alexezeder (Alexey Ochapov) <https://github.com/alexezeder>`_.
-
-* Added support for the append mode to the experimental file API and
-  improved ``fcntl.h`` detection.
-  (`#1847 <https://github.com/fmtlib/fmt/pull/1847>`_,
-  `#1848 <https://github.com/fmtlib/fmt/pull/1848>`_).
-  Thanks `@t-wiser <https://github.com/t-wiser>`_.
-
-* Fixed handling of types that have both an implicit conversion operator and
-  an overloaded ``ostream`` insertion operator
-  (`#1766 <https://github.com/fmtlib/fmt/issues/1766>`_).
-
-* Fixed a slicing issue in an internal iterator type
-  (`#1822 <https://github.com/fmtlib/fmt/pull/1822>`_).
-  Thanks `@BRevzin (Barry Revzin) <https://github.com/BRevzin>`_.
-
-* Fixed an issue in locale-specific integer formatting
-  (`#1927 <https://github.com/fmtlib/fmt/issues/1927>`_).
-
-* Fixed handling of exotic code unit types
-  (`#1870 <https://github.com/fmtlib/fmt/issues/1870>`_,
-  `#1932 <https://github.com/fmtlib/fmt/issues/1932>`_).
-
-* Improved ``FMT_ALWAYS_INLINE``
-  (`#1878 <https://github.com/fmtlib/fmt/pull/1878>`_).
-  Thanks `@jk-jeon (Junekey Jeon) <https://github.com/jk-jeon>`_.
-
-* Removed dependency on ``windows.h``
-  (`#1900 <https://github.com/fmtlib/fmt/pull/1900>`_).
-  Thanks `@bernd5 (Bernd Baumanns) <https://github.com/bernd5>`_.
-
-* Optimized counting of decimal digits on MSVC
-  (`#1890 <https://github.com/fmtlib/fmt/pull/1890>`_).
-  Thanks `@mwinterb <https://github.com/mwinterb>`_.
-
-* Improved documentation
-  (`#1772 <https://github.com/fmtlib/fmt/issues/1772>`_,
-  `#1775 <https://github.com/fmtlib/fmt/pull/1775>`_,
-  `#1792 <https://github.com/fmtlib/fmt/pull/1792>`_,
-  `#1838 <https://github.com/fmtlib/fmt/pull/1838>`_,
-  `#1888 <https://github.com/fmtlib/fmt/pull/1888>`_,
-  `#1918 <https://github.com/fmtlib/fmt/pull/1918>`_,
-  `#1939 <https://github.com/fmtlib/fmt/pull/1939>`_).
-  Thanks `@leolchat (Léonard Gérard) <https://github.com/leolchat>`_,
-  `@pepsiman (Malcolm Parsons) <https://github.com/pepsiman>`_,
-  `@Klaim (Joël Lamotte) <https://github.com/Klaim>`_,
-  `@ravijanjam (Ravi J) <https://github.com/ravijanjam>`_,
-  `@francesco-st <https://github.com/francesco-st>`_,
-  `@udnaan (Adnan) <https://github.com/udnaan>`_.
-
-* Added the ``FMT_REDUCE_INT_INSTANTIATIONS`` CMake option that reduces the
-  binary code size at the cost of some integer formatting performance. This can
-  be useful for extremely memory-constrained embedded systems
-  (`#1778 <https://github.com/fmtlib/fmt/issues/1778>`_,
-  `#1781 <https://github.com/fmtlib/fmt/pull/1781>`_).
-  Thanks `@kammce (Khalil Estell) <https://github.com/kammce>`_.
-
-* Added the ``FMT_USE_INLINE_NAMESPACES`` macro to control usage of inline
-  namespaces (`#1945 <https://github.com/fmtlib/fmt/pull/1945>`_).
-  Thanks `@darklukee <https://github.com/darklukee>`_.
-
-* Improved build configuration
-  (`#1760 <https://github.com/fmtlib/fmt/pull/1760>`_,
-  `#1770 <https://github.com/fmtlib/fmt/pull/1770>`_,
-  `#1779 <https://github.com/fmtlib/fmt/issues/1779>`_,
-  `#1783 <https://github.com/fmtlib/fmt/pull/1783>`_,
-  `#1823 <https://github.com/fmtlib/fmt/pull/1823>`_).
-  Thanks `@dvetutnev (Dmitriy Vetutnev) <https://github.com/dvetutnev>`_,
-  `@xvitaly (Vitaly Zaitsev) <https://github.com/xvitaly>`_,
-  `@tambry (Raul Tambre) <https://github.com/tambry>`_,
-  `@medithe <https://github.com/medithe>`_,
-  `@martinwuehrer (Martin Wührer) <https://github.com/martinwuehrer>`_.
-
-* Fixed various warnings and compilation issues
-  (`#1790 <https://github.com/fmtlib/fmt/pull/1790>`_,
-  `#1802 <https://github.com/fmtlib/fmt/pull/1802>`_,
-  `#1808 <https://github.com/fmtlib/fmt/pull/1808>`_,
-  `#1810 <https://github.com/fmtlib/fmt/issues/1810>`_,
-  `#1811 <https://github.com/fmtlib/fmt/issues/1811>`_,
-  `#1812 <https://github.com/fmtlib/fmt/pull/1812>`_,
-  `#1814 <https://github.com/fmtlib/fmt/pull/1814>`_,
-  `#1816 <https://github.com/fmtlib/fmt/pull/1816>`_,
-  `#1817 <https://github.com/fmtlib/fmt/pull/1817>`_,
-  `#1818 <https://github.com/fmtlib/fmt/pull/1818>`_,
-  `#1825 <https://github.com/fmtlib/fmt/issues/1825>`_,
-  `#1836 <https://github.com/fmtlib/fmt/pull/1836>`_,
-  `#1855 <https://github.com/fmtlib/fmt/pull/1855>`_,
-  `#1856 <https://github.com/fmtlib/fmt/pull/1856>`_,
-  `#1860 <https://github.com/fmtlib/fmt/pull/1860>`_,
-  `#1877 <https://github.com/fmtlib/fmt/pull/1877>`_,
-  `#1879 <https://github.com/fmtlib/fmt/pull/1879>`_,
-  `#1880 <https://github.com/fmtlib/fmt/pull/1880>`_,
-  `#1896 <https://github.com/fmtlib/fmt/issues/1896>`_,
-  `#1897 <https://github.com/fmtlib/fmt/pull/1897>`_,
-  `#1898 <https://github.com/fmtlib/fmt/pull/1898>`_,
-  `#1904 <https://github.com/fmtlib/fmt/issues/1904>`_,
-  `#1908 <https://github.com/fmtlib/fmt/pull/1908>`_,
-  `#1911 <https://github.com/fmtlib/fmt/issues/1911>`_,
-  `#1912 <https://github.com/fmtlib/fmt/issues/1912>`_,
-  `#1928 <https://github.com/fmtlib/fmt/issues/1928>`_,
-  `#1929 <https://github.com/fmtlib/fmt/pull/1929>`_,
-  `#1935 <https://github.com/fmtlib/fmt/issues/1935>`_,
-  `#1937 <https://github.com/fmtlib/fmt/pull/1937>`_,
-  `#1942 <https://github.com/fmtlib/fmt/pull/1942>`_,
-  `#1949 <https://github.com/fmtlib/fmt/issues/1949>`_).
-  Thanks `@TheQwertiest <https://github.com/TheQwertiest>`_,
-  `@medithe <https://github.com/medithe>`_,
-  `@martinwuehrer (Martin Wührer) <https://github.com/martinwuehrer>`_,
-  `@n16h7hunt3r <https://github.com/n16h7hunt3r>`_,
-  `@Othereum (Seokjin Lee) <https://github.com/Othereum>`_,
-  `@gsjaardema (Greg Sjaardema) <https://github.com/gsjaardema>`_,
-  `@AlexanderLanin (Alexander Lanin) <https://github.com/AlexanderLanin>`_,
-  `@gcerretani (Giovanni Cerretani) <https://github.com/gcerretani>`_,
-  `@chronoxor (Ivan Shynkarenka) <https://github.com/chronoxor>`_,
-  `@noizefloor (Jan Schwers) <https://github.com/noizefloor>`_,
-  `@akohlmey (Axel Kohlmeyer) <https://github.com/akohlmey>`_,
-  `@jk-jeon (Junekey Jeon) <https://github.com/jk-jeon>`_,
-  `@rimathia <https://github.com/rimathia>`_,
-  `@rglarix (Riccardo Ghetta (larix)) <https://github.com/rglarix>`_,
-  `@moiwi <https://github.com/moiwi>`_,
-  `@heckad (Kazantcev Andrey) <https://github.com/heckad>`_,
-  `@MarcDirven <https://github.com/MarcDirven>`_.
-  `@BartSiwek (Bart Siwek) <https://github.com/BartSiwek>`_,
-  `@darklukee <https://github.com/darklukee>`_.
-
-7.0.3 - 2020-08-06
-------------------
-
-* Worked around broken ``numeric_limits`` for 128-bit integers
-  (`#1787 <https://github.com/fmtlib/fmt/issues/1787>`_).
-
-* Added error reporting on missing named arguments
-  (`#1796 <https://github.com/fmtlib/fmt/issues/1796>`_).
-
-* Stopped using 128-bit integers with clang-cl
-  (`#1800 <https://github.com/fmtlib/fmt/pull/1800>`_).
-  Thanks `@Kingcom <https://github.com/Kingcom>`_.
-
-* Fixed issues in locale-specific integer formatting
-  (`#1782 <https://github.com/fmtlib/fmt/issues/1782>`_,
-  `#1801 <https://github.com/fmtlib/fmt/issues/1801>`_).
-
-7.0.2 - 2020-07-29
-------------------
-
-* Worked around broken ``numeric_limits`` for 128-bit integers
-  (`#1725 <https://github.com/fmtlib/fmt/issues/1725>`_).
-
-* Fixed compatibility with CMake 3.4
-  (`#1779 <https://github.com/fmtlib/fmt/issues/1779>`_).
-
-* Fixed handling of digit separators in locale-specific formatting
-  (`#1782 <https://github.com/fmtlib/fmt/issues/1782>`_).
-
-7.0.1 - 2020-07-07
-------------------
-
-* Updated the inline version namespace name.
-
-* Worked around a gcc bug in mangling of alias templates
-  (`#1753 <https://github.com/fmtlib/fmt/issues/1753>`_).
-
-* Fixed a linkage error on Windows
-  (`#1757 <https://github.com/fmtlib/fmt/issues/1757>`_).
-  Thanks `@Kurkin (Dmitry Kurkin) <https://github.com/Kurkin>`_.
-
-* Fixed minor issues with the documentation.
-
-7.0.0 - 2020-07-05
-------------------
-
-* Reduced the library size. For example, on macOS a stripped test binary
-  statically linked with {fmt} `shrank from ~368k to less than 100k
-  <http://www.zverovich.net/2020/05/21/reducing-library-size.html>`_.
-
-* Added a simpler and more efficient `format string compilation API
-  <https://fmt.dev/7.0.0/api.html#compile-api>`_:
-
-  .. code:: c++
-
-     #include <fmt/compile.h>
-
-     // Converts 42 into std::string using the most efficient method and no
-     // runtime format string processing.
-     std::string s = fmt::format(FMT_COMPILE("{}"), 42);
-
-  The old ``fmt::compile`` API is now deprecated.
-
-* Optimized integer formatting: ``format_to`` with format string compilation
-  and a stack-allocated buffer is now `faster than to_chars on both
-  libc++ and libstdc++
-  <http://www.zverovich.net/2020/06/13/fast-int-to-string-revisited.html>`_.
-
-* Optimized handling of small format strings. For example,
-
-  .. code:: c++
-
-      fmt::format("Result: {}: ({},{},{},{})", str1, str2, str3, str4, str5)
-
-  is now ~40% faster (`#1685 <https://github.com/fmtlib/fmt/issues/1685>`_).
-
-* Applied extern templates to improve compile times when using the core API
-  and ``fmt/format.h`` (`#1452 <https://github.com/fmtlib/fmt/issues/1452>`_).
-  For example, on macOS with clang the compile time of a test translation unit
-  dropped from 2.3s to 0.3s with ``-O2`` and from 0.6s to 0.3s with the default
-  settings (``-O0``).
-
-  Before (``-O2``)::
-
-    % time c++ -c test.cc -I include -std=c++17 -O2
-    c++ -c test.cc -I include -std=c++17 -O2  2.22s user 0.08s system 99% cpu 2.311 total
-
-  After (``-O2``)::
-
-    % time c++ -c test.cc -I include -std=c++17 -O2
-    c++ -c test.cc -I include -std=c++17 -O2  0.26s user 0.04s system 98% cpu 0.303 total
-
-  Before (default)::
-
-    % time c++ -c test.cc -I include -std=c++17
-    c++ -c test.cc -I include -std=c++17  0.53s user 0.06s system 98% cpu 0.601 total
-
-  After (default)::
-
-    % time c++ -c test.cc -I include -std=c++17
-    c++ -c test.cc -I include -std=c++17  0.24s user 0.06s system 98% cpu 0.301 total
-
-  It is still recommended to use ``fmt/core.h`` instead of ``fmt/format.h`` but
-  the compile time difference is now smaller. Thanks
-  `@alex3d <https://github.com/alex3d>`_ for the suggestion.
-
-* Named arguments are now stored on stack (no dynamic memory allocations) and
-  the compiled code is more compact and efficient. For example
-
-  .. code:: c++
-
-     #include <fmt/core.h>
-
-     int main() {
-       fmt::print("The answer is {answer}\n", fmt::arg("answer", 42));
-     }
-
-  compiles to just (`godbolt <https://godbolt.org/z/NcfEp_>`__)
-
-  .. code:: asm
-
-      .LC0:
-              .string "answer"
-      .LC1:
-              .string "The answer is {answer}\n"
-      main:
-              sub     rsp, 56
-              mov     edi, OFFSET FLAT:.LC1
-              mov     esi, 23
-              movabs  rdx, 4611686018427387905
-              lea     rax, [rsp+32]
-              lea     rcx, [rsp+16]
-              mov     QWORD PTR [rsp+8], 1
-              mov     QWORD PTR [rsp], rax
-              mov     DWORD PTR [rsp+16], 42
-              mov     QWORD PTR [rsp+32], OFFSET FLAT:.LC0
-              mov     DWORD PTR [rsp+40], 0
-              call    fmt::v6::vprint(fmt::v6::basic_string_view<char>,
-                                      fmt::v6::format_args)
-              xor     eax, eax
-              add     rsp, 56
-              ret
-
-          .L.str.1:
-                  .asciz  "answer"
-
-* Implemented compile-time checks for dynamic width and precision
-  (`#1614 <https://github.com/fmtlib/fmt/issues/1614>`_):
-
-  .. code:: c++
-
-     #include <fmt/format.h>
-
-     int main() {
-       fmt::print(FMT_STRING("{0:{1}}"), 42);
-     }
-
-  now gives a compilation error because argument 1 doesn't exist::
-
-    In file included from test.cc:1:
-    include/fmt/format.h:2726:27: error: constexpr variable 'invalid_format' must be
-    initialized by a constant expression
-      FMT_CONSTEXPR_DECL bool invalid_format =
-                              ^
-    ...
-    include/fmt/core.h:569:26: note: in call to
-    '&checker(s, {}).context_->on_error(&"argument not found"[0])'
-        if (id >= num_args_) on_error("argument not found");
-                            ^
-
-* Added sentinel support to ``fmt::join``
-  (`#1689 <https://github.com/fmtlib/fmt/pull/1689>`_)
-
-  .. code:: c++
-
-    struct zstring_sentinel {};
-    bool operator==(const char* p, zstring_sentinel) { return *p == '\0'; }
-    bool operator!=(const char* p, zstring_sentinel) { return *p != '\0'; }
-
-    struct zstring {
-      const char* p;
-      const char* begin() const { return p; }
-      zstring_sentinel end() const { return {}; }
-    };
-
-    auto s = fmt::format("{}", fmt::join(zstring{"hello"}, "_"));
-    // s == "h_e_l_l_o"
-
-  Thanks `@BRevzin (Barry Revzin) <https://github.com/BRevzin>`_.
-
-* Added support for named arguments, ``clear`` and ``reserve`` to
-  ``dynamic_format_arg_store``
-  (`#1655 <https://github.com/fmtlib/fmt/issues/1655>`_,
-  `#1663 <https://github.com/fmtlib/fmt/pull/1663>`_,
-  `#1674 <https://github.com/fmtlib/fmt/pull/1674>`_,
-  `#1677 <https://github.com/fmtlib/fmt/pull/1677>`_).
-  Thanks `@vsolontsov-ll (Vladimir Solontsov)
-  <https://github.com/vsolontsov-ll>`_.
-
-* Added support for the ``'c'`` format specifier to integral types for
-  compatibility with ``std::format``
-  (`#1652 <https://github.com/fmtlib/fmt/issues/1652>`_).
-
-* Replaced the ``'n'`` format specifier with ``'L'`` for compatibility with
-  ``std::format`` (`#1624 <https://github.com/fmtlib/fmt/issues/1624>`_).
-  The ``'n'`` specifier can be enabled via the ``FMT_DEPRECATED_N_SPECIFIER``
-  macro.
-
-* The ``'='`` format specifier is now disabled by default for compatibility with
-  ``std::format``. It can be enabled via the ``FMT_DEPRECATED_NUMERIC_ALIGN``
-  macro.
-
-* Removed the following deprecated APIs:
-
-  * ``FMT_STRING_ALIAS`` and ``fmt`` macros - replaced by ``FMT_STRING``
-  * ``fmt::basic_string_view::char_type`` - replaced by
-    ``fmt::basic_string_view::value_type``
-  * ``convert_to_int``
-  * ``format_arg_store::types``
-  * ``*parse_context`` - replaced by ``*format_parse_context``
-  * ``FMT_DEPRECATED_INCLUDE_OS``
-  * ``FMT_DEPRECATED_PERCENT`` - incompatible with ``std::format``
-  * ``*writer`` - replaced by compiled format API
-
-* Renamed the ``internal`` namespace to ``detail``
-  (`#1538 <https://github.com/fmtlib/fmt/issues/1538>`_). The former is still
-  provided as an alias if the ``FMT_USE_INTERNAL`` macro is defined.
-
-* Improved compatibility between ``fmt::printf`` with the standard specs
-  (`#1595 <https://github.com/fmtlib/fmt/issues/1595>`_,
-  `#1682 <https://github.com/fmtlib/fmt/pull/1682>`_,
-  `#1683 <https://github.com/fmtlib/fmt/pull/1683>`_,
-  `#1687 <https://github.com/fmtlib/fmt/pull/1687>`_,
-  `#1699 <https://github.com/fmtlib/fmt/pull/1699>`_).
-  Thanks `@rimathia <https://github.com/rimathia>`_.
-
-* Fixed handling of ``operator<<`` overloads that use ``copyfmt``
-  (`#1666 <https://github.com/fmtlib/fmt/issues/1666>`_).
-
-* Added the ``FMT_OS`` CMake option to control inclusion of OS-specific APIs
-  in the fmt target. This can be useful for embedded platforms
-  (`#1654 <https://github.com/fmtlib/fmt/issues/1654>`_,
-  `#1656 <https://github.com/fmtlib/fmt/pull/1656>`_).
-  Thanks `@kwesolowski (Krzysztof Wesolowski)
-  <https://github.com/kwesolowski>`_.
-
-* Replaced ``FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION`` with the ``FMT_FUZZ``
-  macro to prevent interferring with fuzzing of projects using {fmt}
-  (`#1650 <https://github.com/fmtlib/fmt/pull/1650>`_).
-  Thanks `@asraa (Asra Ali) <https://github.com/asraa>`_.
-
-* Fixed compatibility with emscripten
-  (`#1636 <https://github.com/fmtlib/fmt/issues/1636>`_,
-  `#1637 <https://github.com/fmtlib/fmt/pull/1637>`_).
-  Thanks `@ArthurSonzogni (Arthur Sonzogni)
-  <https://github.com/ArthurSonzogni>`_.
-
-* Improved documentation
-  (`#704 <https://github.com/fmtlib/fmt/issues/704>`_,
-  `#1643 <https://github.com/fmtlib/fmt/pull/1643>`_,
-  `#1660 <https://github.com/fmtlib/fmt/pull/1660>`_,
-  `#1681 <https://github.com/fmtlib/fmt/pull/1681>`_,
-  `#1691 <https://github.com/fmtlib/fmt/pull/1691>`_,
-  `#1706 <https://github.com/fmtlib/fmt/pull/1706>`_,
-  `#1714 <https://github.com/fmtlib/fmt/pull/1714>`_,
-  `#1721 <https://github.com/fmtlib/fmt/pull/1721>`_,
-  `#1739 <https://github.com/fmtlib/fmt/pull/1739>`_,
-  `#1740 <https://github.com/fmtlib/fmt/pull/1740>`_,
-  `#1741 <https://github.com/fmtlib/fmt/pull/1741>`_,
-  `#1751 <https://github.com/fmtlib/fmt/pull/1751>`_).
-  Thanks `@senior7515 (Alexander Gallego) <https://github.com/senior7515>`_,
-  `@lsr0 (Lindsay Roberts) <https://github.com/lsr0>`_,
-  `@puetzk (Kevin Puetz) <https://github.com/puetzk>`_,
-  `@fpelliccioni (Fernando Pelliccioni) <https://github.com/fpelliccioni>`_,
-  Alexey Kuzmenko, `@jelly (jelle van der Waa) <https://github.com/jelly>`_,
-  `@claremacrae (Clare Macrae) <https://github.com/claremacrae>`_,
-  `@jiapengwen (文佳鹏) <https://github.com/jiapengwen>`_,
-  `@gsjaardema (Greg Sjaardema) <https://github.com/gsjaardema>`_,
-  `@alexey-milovidov <https://github.com/alexey-milovidov>`_.
-
-* Implemented various build configuration fixes and improvements
-  (`#1603 <https://github.com/fmtlib/fmt/pull/1603>`_,
-  `#1657 <https://github.com/fmtlib/fmt/pull/1657>`_,
-  `#1702 <https://github.com/fmtlib/fmt/pull/1702>`_,
-  `#1728 <https://github.com/fmtlib/fmt/pull/1728>`_).
-  Thanks `@scramsby (Scott Ramsby) <https://github.com/scramsby>`_,
-  `@jtojnar (Jan Tojnar) <https://github.com/jtojnar>`_,
-  `@orivej (Orivej Desh) <https://github.com/orivej>`_,
-  `@flagarde <https://github.com/flagarde>`_.
-
-* Fixed various warnings and compilation issues
-  (`#1616 <https://github.com/fmtlib/fmt/pull/1616>`_,
-  `#1620 <https://github.com/fmtlib/fmt/issues/1620>`_,
-  `#1622 <https://github.com/fmtlib/fmt/issues/1622>`_,
-  `#1625 <https://github.com/fmtlib/fmt/issues/1625>`_,
-  `#1627 <https://github.com/fmtlib/fmt/pull/1627>`_,
-  `#1628 <https://github.com/fmtlib/fmt/issues/1628>`_,
-  `#1629 <https://github.com/fmtlib/fmt/pull/1629>`_,
-  `#1631 <https://github.com/fmtlib/fmt/issues/1631>`_,
-  `#1633 <https://github.com/fmtlib/fmt/pull/1633>`_,
-  `#1649 <https://github.com/fmtlib/fmt/pull/1649>`_,
-  `#1658 <https://github.com/fmtlib/fmt/issues/1658>`_,
-  `#1661 <https://github.com/fmtlib/fmt/pull/1661>`_,
-  `#1667 <https://github.com/fmtlib/fmt/pull/1667>`_,
-  `#1668 <https://github.com/fmtlib/fmt/issues/1668>`_,
-  `#1669 <https://github.com/fmtlib/fmt/pull/1669>`_,
-  `#1692 <https://github.com/fmtlib/fmt/issues/1692>`_,
-  `#1696 <https://github.com/fmtlib/fmt/pull/1696>`_,
-  `#1697 <https://github.com/fmtlib/fmt/pull/1697>`_,
-  `#1707 <https://github.com/fmtlib/fmt/issues/1707>`_,
-  `#1712 <https://github.com/fmtlib/fmt/pull/1712>`_,
-  `#1716 <https://github.com/fmtlib/fmt/pull/1716>`_,
-  `#1722 <https://github.com/fmtlib/fmt/pull/1722>`_,
-  `#1724 <https://github.com/fmtlib/fmt/issues/1724>`_,
-  `#1729 <https://github.com/fmtlib/fmt/pull/1729>`_,
-  `#1738 <https://github.com/fmtlib/fmt/pull/1738>`_,
-  `#1742 <https://github.com/fmtlib/fmt/issues/1742>`_,
-  `#1743 <https://github.com/fmtlib/fmt/issues/1743>`_,
-  `#1744 <https://github.com/fmtlib/fmt/pull/1744>`_,
-  `#1747 <https://github.com/fmtlib/fmt/issues/1747>`_,
-  `#1750 <https://github.com/fmtlib/fmt/pull/1750>`_).
-  Thanks `@gsjaardema (Greg Sjaardema) <https://github.com/gsjaardema>`_,
-  `@gabime (Gabi Melman) <https://github.com/gabime>`_,
-  `@johnor (Johan) <https://github.com/johnor>`_,
-  `@Kurkin (Dmitry Kurkin) <https://github.com/Kurkin>`_,
-  `@invexed (James Beach) <https://github.com/invexed>`_,
-  `@peterbell10 <https://github.com/peterbell10>`_,
-  `@daixtrose (Markus Werle) <https://github.com/daixtrose>`_,
-  `@petrutlucian94 (Lucian Petrut) <https://github.com/petrutlucian94>`_,
-  `@Neargye (Daniil Goncharov) <https://github.com/Neargye>`_,
-  `@ambitslix (Attila M. Szilagyi) <https://github.com/ambitslix>`_,
-  `@gabime (Gabi Melman) <https://github.com/gabime>`_,
-  `@erthink (Leonid Yuriev) <https://github.com/erthink>`_,
-  `@tohammer (Tobias Hammer) <https://github.com/tohammer>`_,
-  `@0x8000-0000 (Florin Iucha) <https://github.com/0x8000-0000>`_.
-
-6.2.1 - 2020-05-09
-------------------
-
-* Fixed ostream support in ``sprintf``
-  (`#1631 <https://github.com/fmtlib/fmt/issues/1631>`_).
-
-* Fixed type detection when using implicit conversion to ``string_view`` and
-  ostream ``operator<<`` inconsistently
-  (`#1662 <https://github.com/fmtlib/fmt/issues/1662>`_).
-
-6.2.0 - 2020-04-05
-------------------
-
-* Improved error reporting when trying to format an object of a non-formattable
-  type:
-
-  .. code:: c++
-
-     fmt::format("{}", S());
-
-  now gives::
-
-    include/fmt/core.h:1015:5: error: static_assert failed due to requirement
-    'formattable' "Cannot format argument. To make type T formattable provide a
-    formatter<T> specialization:
-    https://fmt.dev/latest/api.html#formatting-user-defined-types"
-        static_assert(
-        ^
-    ...
-    note: in instantiation of function template specialization
-    'fmt::v6::format<char [3], S, char>' requested here
-      fmt::format("{}", S());
-           ^
-
-  if ``S`` is not formattable.
-
-* Reduced the library size by ~10%.
-
-* Always print decimal point if ``#`` is specified
-  (`#1476 <https://github.com/fmtlib/fmt/issues/1476>`_,
-  `#1498 <https://github.com/fmtlib/fmt/issues/1498>`_):
-
-  .. code:: c++
-
-     fmt::print("{:#.0f}", 42.0);
-
-  now prints ``42.``
-
-* Implemented the ``'L'`` specifier for locale-specific numeric formatting to
-  improve compatibility with ``std::format``. The ``'n'`` specifier is now
-  deprecated and will be removed in the next major release.
-
-* Moved OS-specific APIs such as ``windows_error`` from ``fmt/format.h`` to
-  ``fmt/os.h``. You can define ``FMT_DEPRECATED_INCLUDE_OS`` to automatically
-  include ``fmt/os.h`` from ``fmt/format.h`` for compatibility but this will be
-  disabled in the next major release.
-
-* Added precision overflow detection in floating-point formatting.
-
-* Implemented detection of invalid use of ``fmt::arg``.
-
-* Used ``type_identity`` to block unnecessary template argument deduction.
-  Thanks Tim Song.
-
-* Improved UTF-8 handling
-  (`#1109 <https://github.com/fmtlib/fmt/issues/1109>`_):
-
-  .. code:: c++
-
-     fmt::print("┌{0:─^{2}}┐\n"
-                "│{1: ^{2}}│\n"
-                "└{0:─^{2}}┘\n", "", "Привет, мир!", 20);
-
-  now prints::
-
-     ┌────────────────────┐
-     │    Привет, мир!    │
-     └────────────────────┘
-
-  on systems that support Unicode.
-
-* Added experimental dynamic argument storage
-  (`#1170 <https://github.com/fmtlib/fmt/issues/1170>`_,
-  `#1584 <https://github.com/fmtlib/fmt/pull/1584>`_):
-
-  .. code:: c++
-
-     fmt::dynamic_format_arg_store<fmt::format_context> store;
-     store.push_back("answer");
-     store.push_back(42);
-     fmt::vprint("The {} is {}.\n", store);
-  
-  prints::
-
-     The answer is 42.
-
-  Thanks `@vsolontsov-ll (Vladimir Solontsov)
-  <https://github.com/vsolontsov-ll>`_.
-
-* Made ``fmt::join`` accept ``initializer_list``
-  (`#1591 <https://github.com/fmtlib/fmt/pull/1591>`_).
-  Thanks `@Rapotkinnik (Nikolay Rapotkin) <https://github.com/Rapotkinnik>`_.
-
-* Fixed handling of empty tuples
-  (`#1588 <https://github.com/fmtlib/fmt/issues/1588>`_).
-
-* Fixed handling of output iterators in ``format_to_n``
-  (`#1506 <https://github.com/fmtlib/fmt/issues/1506>`_).
-
-* Fixed formatting of ``std::chrono::duration`` types to wide output
-  (`#1533 <https://github.com/fmtlib/fmt/pull/1533>`_).
-  Thanks `@zeffy (pilao) <https://github.com/zeffy>`_.
-
-* Added const ``begin`` and ``end`` overload to buffers
-  (`#1553 <https://github.com/fmtlib/fmt/pull/1553>`_).
-  Thanks `@dominicpoeschko <https://github.com/dominicpoeschko>`_.
-
-* Added the ability to disable floating-point formatting via ``FMT_USE_FLOAT``,
-  ``FMT_USE_DOUBLE`` and ``FMT_USE_LONG_DOUBLE`` macros for extremely
-  memory-constrained embedded system
-  (`#1590 <https://github.com/fmtlib/fmt/pull/1590>`_).
-  Thanks `@albaguirre (Alberto Aguirre) <https://github.com/albaguirre>`_.
-
-* Made ``FMT_STRING`` work with ``constexpr`` ``string_view``
-  (`#1589 <https://github.com/fmtlib/fmt/pull/1589>`_).
-  Thanks `@scramsby (Scott Ramsby) <https://github.com/scramsby>`_.
-
-* Implemented a minor optimization in the format string parser
-  (`#1560 <https://github.com/fmtlib/fmt/pull/1560>`_).
-  Thanks `@IkarusDeveloper <https://github.com/IkarusDeveloper>`_.
-
-* Improved attribute detection
-  (`#1469 <https://github.com/fmtlib/fmt/pull/1469>`_,
-  `#1475 <https://github.com/fmtlib/fmt/pull/1475>`_,
-  `#1576 <https://github.com/fmtlib/fmt/pull/1576>`_).
-  Thanks `@federico-busato (Federico) <https://github.com/federico-busato>`_,
-  `@chronoxor (Ivan Shynkarenka) <https://github.com/chronoxor>`_,
-  `@refnum <https://github.com/refnum>`_.
-
-* Improved documentation
-  (`#1481 <https://github.com/fmtlib/fmt/pull/1481>`_,
-  `#1523 <https://github.com/fmtlib/fmt/pull/1523>`_).
-  Thanks `@JackBoosY (Jack·Boos·Yu) <https://github.com/JackBoosY>`_,
-  `@imba-tjd (谭九鼎) <https://github.com/imba-tjd>`_.
-
-* Fixed symbol visibility on Linux when compiling with ``-fvisibility=hidden``
-  (`#1535 <https://github.com/fmtlib/fmt/pull/1535>`_).
-  Thanks `@milianw (Milian Wolff) <https://github.com/milianw>`_.
-
-* Implemented various build configuration fixes and improvements
-  (`#1264 <https://github.com/fmtlib/fmt/issues/1264>`_,
-  `#1460 <https://github.com/fmtlib/fmt/issues/1460>`_,
-  `#1534 <https://github.com/fmtlib/fmt/pull/1534>`_,
-  `#1536 <https://github.com/fmtlib/fmt/issues/1536>`_,
-  `#1545 <https://github.com/fmtlib/fmt/issues/1545>`_,
-  `#1546 <https://github.com/fmtlib/fmt/pull/1546>`_,
-  `#1566 <https://github.com/fmtlib/fmt/issues/1566>`_,
-  `#1582 <https://github.com/fmtlib/fmt/pull/1582>`_,
-  `#1597 <https://github.com/fmtlib/fmt/issues/1597>`_,
-  `#1598 <https://github.com/fmtlib/fmt/pull/1598>`_).
-  Thanks `@ambitslix (Attila M. Szilagyi) <https://github.com/ambitslix>`_,
-  `@jwillikers (Jordan Williams) <https://github.com/jwillikers>`_,
-  `@stac47 (Laurent Stacul) <https://github.com/stac47>`_.
-
-* Fixed various warnings and compilation issues
-  (`#1433 <https://github.com/fmtlib/fmt/pull/1433>`_,
-  `#1461 <https://github.com/fmtlib/fmt/issues/1461>`_,
-  `#1470 <https://github.com/fmtlib/fmt/pull/1470>`_,
-  `#1480 <https://github.com/fmtlib/fmt/pull/1480>`_,
-  `#1485 <https://github.com/fmtlib/fmt/pull/1485>`_,
-  `#1492 <https://github.com/fmtlib/fmt/pull/1492>`_,
-  `#1493 <https://github.com/fmtlib/fmt/issues/1493>`_,
-  `#1504 <https://github.com/fmtlib/fmt/issues/1504>`_,
-  `#1505 <https://github.com/fmtlib/fmt/pull/1505>`_,
-  `#1512 <https://github.com/fmtlib/fmt/pull/1512>`_,
-  `#1515 <https://github.com/fmtlib/fmt/issues/1515>`_,
-  `#1516 <https://github.com/fmtlib/fmt/pull/1516>`_,
-  `#1518 <https://github.com/fmtlib/fmt/pull/1518>`_,
-  `#1519 <https://github.com/fmtlib/fmt/pull/1519>`_,
-  `#1520 <https://github.com/fmtlib/fmt/pull/1520>`_,
-  `#1521 <https://github.com/fmtlib/fmt/pull/1521>`_,
-  `#1522 <https://github.com/fmtlib/fmt/pull/1522>`_,
-  `#1524 <https://github.com/fmtlib/fmt/issues/1524>`_,
-  `#1530 <https://github.com/fmtlib/fmt/pull/1530>`_,
-  `#1531 <https://github.com/fmtlib/fmt/issues/1531>`_,
-  `#1532 <https://github.com/fmtlib/fmt/pull/1532>`_,
-  `#1539 <https://github.com/fmtlib/fmt/issues/1539>`_,
-  `#1547 <https://github.com/fmtlib/fmt/issues/1547>`_,
-  `#1548 <https://github.com/fmtlib/fmt/issues/1548>`_,
-  `#1554 <https://github.com/fmtlib/fmt/pull/1554>`_,
-  `#1567 <https://github.com/fmtlib/fmt/issues/1567>`_,
-  `#1568 <https://github.com/fmtlib/fmt/pull/1568>`_,
-  `#1569 <https://github.com/fmtlib/fmt/pull/1569>`_,
-  `#1571 <https://github.com/fmtlib/fmt/pull/1571>`_,
-  `#1573 <https://github.com/fmtlib/fmt/pull/1573>`_,
-  `#1575 <https://github.com/fmtlib/fmt/pull/1575>`_,
-  `#1581 <https://github.com/fmtlib/fmt/pull/1581>`_,
-  `#1583 <https://github.com/fmtlib/fmt/issues/1583>`_,
-  `#1586 <https://github.com/fmtlib/fmt/issues/1586>`_,
-  `#1587 <https://github.com/fmtlib/fmt/issues/1587>`_,
-  `#1594 <https://github.com/fmtlib/fmt/issues/1594>`_,
-  `#1596 <https://github.com/fmtlib/fmt/pull/1596>`_,
-  `#1604 <https://github.com/fmtlib/fmt/issues/1604>`_,
-  `#1606 <https://github.com/fmtlib/fmt/pull/1606>`_,
-  `#1607 <https://github.com/fmtlib/fmt/issues/1607>`_,
-  `#1609 <https://github.com/fmtlib/fmt/issues/1609>`_).
-  Thanks `@marti4d (Chris Martin) <https://github.com/marti4d>`_,
-  `@iPherian <https://github.com/iPherian>`_,
-  `@parkertomatoes <https://github.com/parkertomatoes>`_,
-  `@gsjaardema (Greg Sjaardema) <https://github.com/gsjaardema>`_,
-  `@chronoxor (Ivan Shynkarenka) <https://github.com/chronoxor>`_,
-  `@DanielaE (Daniela Engert) <https://github.com/DanielaE>`_,
-  `@torsten48 <https://github.com/torsten48>`_,
-  `@tohammer (Tobias Hammer) <https://github.com/tohammer>`_,
-  `@lefticus (Jason Turner) <https://github.com/lefticus>`_,
-  `@ryusakki (Haise) <https://github.com/ryusakki>`_,
-  `@adnsv (Alex Denisov) <https://github.com/adnsv>`_,
-  `@fghzxm <https://github.com/fghzxm>`_,
-  `@refnum <https://github.com/refnum>`_,
-  `@pramodk (Pramod Kumbhar) <https://github.com/pramodk>`_,
-  `@Spirrwell <https://github.com/Spirrwell>`_,
-  `@scramsby (Scott Ramsby) <https://github.com/scramsby>`_.
-
-6.1.2 - 2019-12-11
-------------------
-
-* Fixed ABI compatibility with ``libfmt.so.6.0.0``
-  (`#1471 <https://github.com/fmtlib/fmt/issues/1471>`_).
-
-* Fixed handling types convertible to ``std::string_view``
-  (`#1451 <https://github.com/fmtlib/fmt/pull/1451>`_).
-  Thanks `@denizevrenci (Deniz Evrenci) <https://github.com/denizevrenci>`_.
-
-* Made CUDA test an opt-in enabled via the ``FMT_CUDA_TEST`` CMake option.
-
-* Fixed sign conversion warnings
-  (`#1440 <https://github.com/fmtlib/fmt/pull/1440>`_).
-  Thanks `@0x8000-0000 (Florin Iucha) <https://github.com/0x8000-0000>`_.
-
-6.1.1 - 2019-12-04
-------------------
-
-* Fixed shared library build on Windows
-  (`#1443 <https://github.com/fmtlib/fmt/pull/1443>`_,
-  `#1445 <https://github.com/fmtlib/fmt/issues/1445>`_,
-  `#1446 <https://github.com/fmtlib/fmt/pull/1446>`_,
-  `#1450 <https://github.com/fmtlib/fmt/issues/1450>`_).
-  Thanks `@egorpugin (Egor Pugin) <https://github.com/egorpugin>`_,
-  `@bbolli (Beat Bolli) <https://github.com/bbolli>`_.
-
-* Added a missing decimal point in exponent notation with trailing zeros.
-
-* Removed deprecated ``format_arg_store::TYPES``.
-
-6.1.0 - 2019-12-01
-------------------
-
-* {fmt} now formats IEEE 754 ``float`` and ``double`` using the shortest decimal
-  representation with correct rounding by default:
-
-  .. code:: c++
-
-     #include <cmath>
-     #include <fmt/core.h>
-
-     int main() {
-       fmt::print("{}", M_PI);
-     }
-
-  prints ``3.141592653589793``.
-
-* Made the fast binary to decimal floating-point formatter the default,
-  simplified it and improved performance. {fmt} is now 15 times faster than
-  libc++'s ``std::ostringstream``, 11 times faster than ``printf`` and 10%
-  faster than double-conversion on `dtoa-benchmark
-  <https://github.com/fmtlib/dtoa-benchmark>`_:
-
-  ==================  =========  =======
-  Function            Time (ns)  Speedup
-  ==================  =========  =======
-  ostringstream        1,346.30    1.00x
-  ostrstream           1,195.74    1.13x
-  sprintf                995.08    1.35x
-  doubleconv              99.10   13.59x
-  fmt                     88.34   15.24x
-  ==================  =========  =======
-
-  .. image:: https://user-images.githubusercontent.com/576385/
-             69767160-cdaca400-112f-11ea-9fc5-347c9f83caad.png
-
-* {fmt} no longer converts ``float`` arguments to ``double``. In particular this
-  improves the default (shortest) representation of floats and makes
-  ``fmt::format`` consistent with ``std::format`` specs
-  (`#1336 <https://github.com/fmtlib/fmt/issues/1336>`_,
-  `#1353 <https://github.com/fmtlib/fmt/issues/1353>`_,
-  `#1360 <https://github.com/fmtlib/fmt/pull/1360>`_,
-  `#1361 <https://github.com/fmtlib/fmt/pull/1361>`_):
-
-  .. code:: c++
-
-     fmt::print("{}", 0.1f);
-
-  prints ``0.1`` instead of ``0.10000000149011612``.
-
-  Thanks `@orivej (Orivej Desh) <https://github.com/orivej>`_.
-
-* Made floating-point formatting output consistent with ``printf``/iostreams
-  (`#1376 <https://github.com/fmtlib/fmt/issues/1376>`_,
-  `#1417 <https://github.com/fmtlib/fmt/issues/1417>`_).
-
-* Added support for 128-bit integers
-  (`#1287 <https://github.com/fmtlib/fmt/pull/1287>`_):
-
-  .. code:: c++
-
-     fmt::print("{}", std::numeric_limits<__int128_t>::max());
-
-  prints ``170141183460469231731687303715884105727``.
-
-  Thanks `@denizevrenci (Deniz Evrenci) <https://github.com/denizevrenci>`_.
-
-* The overload of ``print`` that takes ``text_style`` is now atomic, i.e. the
-  output from different threads doesn't interleave
-  (`#1351 <https://github.com/fmtlib/fmt/pull/1351>`_).
-  Thanks `@tankiJong (Tanki Zhang) <https://github.com/tankiJong>`_.
-
-* Made compile time in the header-only mode ~20% faster by reducing the number
-  of template instantiations. ``wchar_t`` overload of ``vprint`` was moved from
-  ``fmt/core.h`` to ``fmt/format.h``.
-
-* Added an overload of ``fmt::join`` that works with tuples
-  (`#1322 <https://github.com/fmtlib/fmt/issues/1322>`_,
-  `#1330 <https://github.com/fmtlib/fmt/pull/1330>`_):
-
-  .. code:: c++
-
-     #include <tuple>
-     #include <fmt/ranges.h>
-
-     int main() {
-       std::tuple<char, int, float> t{'a', 1, 2.0f};
-       fmt::print("{}", t);
-     }
-
-  prints ``('a', 1, 2.0)``.
-
-  Thanks `@jeremyong (Jeremy Ong) <https://github.com/jeremyong>`_.
-
-* Changed formatting of octal zero with prefix from "00" to "0":
-
-  .. code:: c++
-
-     fmt::print("{:#o}", 0);
-
-  prints ``0``.
-
-* The locale is now passed to ostream insertion (``<<``) operators
-  (`#1406 <https://github.com/fmtlib/fmt/pull/1406>`_):
-
-  .. code:: c++
-
-     #include <fmt/locale.h>
-     #include <fmt/ostream.h>
-
-     struct S {
-       double value;
-     };
-
-     std::ostream& operator<<(std::ostream& os, S s) {
-       return os << s.value;
-     }
-
-     int main() {
-       auto s = fmt::format(std::locale("fr_FR.UTF-8"), "{}", S{0.42});
-       // s == "0,42"
-     }
-
-  Thanks `@dlaugt (Daniel Laügt) <https://github.com/dlaugt>`_.
-
-* Locale-specific number formatting now uses grouping
-  (`#1393 <https://github.com/fmtlib/fmt/issues/1393>`_
-  `#1394 <https://github.com/fmtlib/fmt/pull/1394>`_).
-  Thanks `@skrdaniel <https://github.com/skrdaniel>`_.
-
-* Fixed handling of types with deleted implicit rvalue conversion to
-  ``const char**`` (`#1421 <https://github.com/fmtlib/fmt/issues/1421>`_):
-
-  .. code:: c++
-
-     struct mystring {
-       operator const char*() const&;
-       operator const char*() &;
-       operator const char*() const&& = delete;
-       operator const char*() && = delete;
-     };
-     mystring str;
-     fmt::print("{}", str); // now compiles
-
-* Enums are now mapped to correct underlying types instead of ``int``
-  (`#1286 <https://github.com/fmtlib/fmt/pull/1286>`_).
-  Thanks `@agmt (Egor Seredin) <https://github.com/agmt>`_.
-
-* Enum classes are no longer implicitly converted to ``int``
-  (`#1424 <https://github.com/fmtlib/fmt/issues/1424>`_).
-
-* Added ``basic_format_parse_context`` for consistency with C++20
-  ``std::format`` and deprecated ``basic_parse_context``.
-
-* Fixed handling of UTF-8 in precision
-  (`#1389 <https://github.com/fmtlib/fmt/issues/1389>`_,
-  `#1390 <https://github.com/fmtlib/fmt/pull/1390>`_).
-  Thanks `@tajtiattila (Attila Tajti) <https://github.com/tajtiattila>`_.
-
-* {fmt} can now be installed on Linux, macOS and Windows with
-  `Conda <https://docs.conda.io/en/latest/>`__ using its
-  `conda-forge <https://conda-forge.org>`__
-  `package <https://github.com/conda-forge/fmt-feedstock>`__
-  (`#1410 <https://github.com/fmtlib/fmt/pull/1410>`_)::
-
-    conda install -c conda-forge fmt
-
-  Thanks `@tdegeus (Tom de Geus) <https://github.com/tdegeus>`_.
-
-* Added a CUDA test (`#1285 <https://github.com/fmtlib/fmt/pull/1285>`_,
-  `#1317 <https://github.com/fmtlib/fmt/pull/1317>`_).
-  Thanks `@luncliff (Park DongHa) <https://github.com/luncliff>`_ and
-  `@risa2000 <https://github.com/risa2000>`_.
-
-* Improved documentation (`#1276 <https://github.com/fmtlib/fmt/pull/1276>`_,
-  `#1291 <https://github.com/fmtlib/fmt/issues/1291>`_,
-  `#1296 <https://github.com/fmtlib/fmt/issues/1296>`_,
-  `#1315 <https://github.com/fmtlib/fmt/pull/1315>`_,
-  `#1332 <https://github.com/fmtlib/fmt/pull/1332>`_,
-  `#1337 <https://github.com/fmtlib/fmt/pull/1337>`_,
-  `#1395 <https://github.com/fmtlib/fmt/issues/1395>`_
-  `#1418 <https://github.com/fmtlib/fmt/pull/1418>`_).
-  Thanks
-  `@waywardmonkeys (Bruce Mitchener) <https://github.com/waywardmonkeys>`_,
-  `@pauldreik (Paul Dreik) <https://github.com/pauldreik>`_,
-  `@jackoalan (Jack Andersen) <https://github.com/jackoalan>`_.
-
-* Various code improvements
-  (`#1358 <https://github.com/fmtlib/fmt/pull/1358>`_,
-  `#1407 <https://github.com/fmtlib/fmt/pull/1407>`_).
-  Thanks `@orivej (Orivej Desh) <https://github.com/orivej>`_,
-  `@dpacbach (David P. Sicilia) <https://github.com/dpacbach>`_,
-
-* Fixed compile-time format string checks for user-defined types
-  (`#1292 <https://github.com/fmtlib/fmt/issues/1292>`_).
-
-* Worked around a false positive in ``unsigned-integer-overflow`` sanitizer
-  (`#1377 <https://github.com/fmtlib/fmt/issues/1377>`_).
-
-* Fixed various warnings and compilation issues
-  (`#1273 <https://github.com/fmtlib/fmt/issues/1273>`_,
-  `#1278 <https://github.com/fmtlib/fmt/pull/1278>`_,
-  `#1280 <https://github.com/fmtlib/fmt/pull/1280>`_,
-  `#1281 <https://github.com/fmtlib/fmt/issues/1281>`_,
-  `#1288 <https://github.com/fmtlib/fmt/issues/1288>`_,
-  `#1290 <https://github.com/fmtlib/fmt/pull/1290>`_,
-  `#1301 <https://github.com/fmtlib/fmt/pull/1301>`_,
-  `#1305 <https://github.com/fmtlib/fmt/issues/1305>`_,
-  `#1306 <https://github.com/fmtlib/fmt/issues/1306>`_,
-  `#1309 <https://github.com/fmtlib/fmt/issues/1309>`_,
-  `#1312 <https://github.com/fmtlib/fmt/pull/1312>`_,
-  `#1313 <https://github.com/fmtlib/fmt/issues/1313>`_,
-  `#1316 <https://github.com/fmtlib/fmt/issues/1316>`_,
-  `#1319 <https://github.com/fmtlib/fmt/issues/1319>`_,
-  `#1320 <https://github.com/fmtlib/fmt/pull/1320>`_,
-  `#1326 <https://github.com/fmtlib/fmt/pull/1326>`_,
-  `#1328 <https://github.com/fmtlib/fmt/pull/1328>`_,
-  `#1344 <https://github.com/fmtlib/fmt/issues/1344>`_,
-  `#1345 <https://github.com/fmtlib/fmt/pull/1345>`_,
-  `#1347 <https://github.com/fmtlib/fmt/pull/1347>`_,
-  `#1349 <https://github.com/fmtlib/fmt/pull/1349>`_,
-  `#1354 <https://github.com/fmtlib/fmt/issues/1354>`_,
-  `#1362 <https://github.com/fmtlib/fmt/issues/1362>`_,
-  `#1366 <https://github.com/fmtlib/fmt/issues/1366>`_,
-  `#1364 <https://github.com/fmtlib/fmt/pull/1364>`_,
-  `#1370 <https://github.com/fmtlib/fmt/pull/1370>`_,
-  `#1371 <https://github.com/fmtlib/fmt/pull/1371>`_,
-  `#1385 <https://github.com/fmtlib/fmt/issues/1385>`_,
-  `#1388 <https://github.com/fmtlib/fmt/issues/1388>`_,
-  `#1397 <https://github.com/fmtlib/fmt/pull/1397>`_,
-  `#1414 <https://github.com/fmtlib/fmt/pull/1414>`_,
-  `#1416 <https://github.com/fmtlib/fmt/pull/1416>`_,
-  `#1422 <https://github.com/fmtlib/fmt/issues/1422>`_
-  `#1427 <https://github.com/fmtlib/fmt/pull/1427>`_,
-  `#1431 <https://github.com/fmtlib/fmt/issues/1431>`_,
-  `#1433 <https://github.com/fmtlib/fmt/pull/1433>`_).
-  Thanks `@hhb <https://github.com/hhb>`_,
-  `@gsjaardema (Greg Sjaardema) <https://github.com/gsjaardema>`_,
-  `@gabime (Gabi Melman) <https://github.com/gabime>`_,
-  `@neheb (Rosen Penev) <https://github.com/neheb>`_,
-  `@vedranmiletic (Vedran Miletić) <https://github.com/vedranmiletic>`_,
-  `@dkavolis (Daumantas Kavolis) <https://github.com/dkavolis>`_,
-  `@mwinterb <https://github.com/mwinterb>`_,
-  `@orivej (Orivej Desh) <https://github.com/orivej>`_,
-  `@denizevrenci (Deniz Evrenci) <https://github.com/denizevrenci>`_
-  `@leonklingele <https://github.com/leonklingele>`_,
-  `@chronoxor (Ivan Shynkarenka) <https://github.com/chronoxor>`_,
-  `@kent-tri <https://github.com/kent-tri>`_,
-  `@0x8000-0000 (Florin Iucha) <https://github.com/0x8000-0000>`_,
-  `@marti4d (Chris Martin) <https://github.com/marti4d>`_.
-
-6.0.0 - 2019-08-26
-------------------
-
-* Switched to the `MIT license
-  <https://github.com/fmtlib/fmt/blob/5a4b24613ba16cc689977c3b5bd8274a3ba1dd1f/LICENSE.rst>`_
-  with an optional exception that allows distributing binary code without
-  attribution.
-
-* Floating-point formatting is now locale-independent by default:
-
-  .. code:: c++
-
-     #include <locale>
-     #include <fmt/core.h>
-
-     int main() {
-       std::locale::global(std::locale("ru_RU.UTF-8"));
-       fmt::print("value = {}", 4.2);
-     }
-
-  prints "value = 4.2" regardless of the locale.
-
-  For locale-specific formatting use the ``n`` specifier:
-
-  .. code:: c++
-
-     std::locale::global(std::locale("ru_RU.UTF-8"));
-     fmt::print("value = {:n}", 4.2);
-
-  prints "value = 4,2".
-
-* Added an experimental Grisu floating-point formatting algorithm
-  implementation (disabled by default). To enable it compile with the
-  ``FMT_USE_GRISU`` macro defined to 1:
-
-  .. code:: c++
-
-     #define FMT_USE_GRISU 1
-     #include <fmt/format.h>
-
-     auto s = fmt::format("{}", 4.2); // formats 4.2 using Grisu
-
-  With Grisu enabled, {fmt} is 13x faster than ``std::ostringstream`` (libc++)
-  and 10x faster than ``sprintf`` on `dtoa-benchmark
-  <https://github.com/fmtlib/dtoa-benchmark>`_ (`full results
-  <https://fmt.dev/unknown_mac64_clang10.0.html>`_):
-
-  .. image:: https://user-images.githubusercontent.com/576385/
-             54883977-9fe8c000-4e28-11e9-8bde-272d122e7c52.jpg
-
-* Separated formatting and parsing contexts for consistency with
-  `C++20 std::format <http://eel.is/c++draft/format>`_, removing the
-  undocumented ``basic_format_context::parse_context()`` function.
-
-* Added `oss-fuzz <https://github.com/google/oss-fuzz>`_ support
-  (`#1199 <https://github.com/fmtlib/fmt/pull/1199>`_).
-  Thanks `@pauldreik (Paul Dreik) <https://github.com/pauldreik>`_.
-
-* ``formatter`` specializations now always take precedence over ``operator<<``
-  (`#952 <https://github.com/fmtlib/fmt/issues/952>`_):
-
-  .. code:: c++
-
-     #include <iostream>
-     #include <fmt/ostream.h>
-
-     struct S {};
-
-     std::ostream& operator<<(std::ostream& os, S) {
-       return os << 1;
-     }
-
-     template <>
-     struct fmt::formatter<S> : fmt::formatter<int> {
-       auto format(S, format_context& ctx) {
-         return formatter<int>::format(2, ctx);
-       }
-     };
-
-     int main() {
-       std::cout << S() << "\n"; // prints 1 using operator<<
-       fmt::print("{}\n", S());  // prints 2 using formatter
-     }
-
-* Introduced the experimental ``fmt::compile`` function that does format string
-  compilation (`#618 <https://github.com/fmtlib/fmt/issues/618>`_,
-  `#1169 <https://github.com/fmtlib/fmt/issues/1169>`_,
-  `#1171 <https://github.com/fmtlib/fmt/pull/1171>`_):
-
-  .. code:: c++
-
-     #include <fmt/compile.h>
-
-     auto f = fmt::compile<int>("{}");
-     std::string s = fmt::format(f, 42); // can be called multiple times to
-                                         // format different values
-     // s == "42"
-
-  It moves the cost of parsing a format string outside of the format function
-  which can be beneficial when identically formatting many objects of the same
-  types. Thanks `@stryku (Mateusz Janek) <https://github.com/stryku>`_.
-
-* Added experimental ``%`` format specifier that formats floating-point values
-  as percentages (`#1060 <https://github.com/fmtlib/fmt/pull/1060>`_,
-  `#1069 <https://github.com/fmtlib/fmt/pull/1069>`_,
-  `#1071 <https://github.com/fmtlib/fmt/pull/1071>`_):
-
-  .. code:: c++
-
-     auto s = fmt::format("{:.1%}", 0.42); // s == "42.0%"
-
-  Thanks `@gawain-bolton (Gawain Bolton) <https://github.com/gawain-bolton>`_.
-
-* Implemented precision for floating-point durations
-  (`#1004 <https://github.com/fmtlib/fmt/issues/1004>`_,
-  `#1012 <https://github.com/fmtlib/fmt/pull/1012>`_):
-
-  .. code:: c++
-
-     auto s = fmt::format("{:.1}", std::chrono::duration<double>(1.234));
-     // s == 1.2s
-
-  Thanks `@DanielaE (Daniela Engert) <https://github.com/DanielaE>`_.
-
-* Implemented ``chrono`` format specifiers ``%Q`` and ``%q`` that give the value
-  and the unit respectively (`#1019 <https://github.com/fmtlib/fmt/pull/1019>`_):
-
-  .. code:: c++
-
-     auto value = fmt::format("{:%Q}", 42s); // value == "42"
-     auto unit  = fmt::format("{:%q}", 42s); // unit == "s"
-
-  Thanks `@DanielaE (Daniela Engert) <https://github.com/DanielaE>`_.
-
-* Fixed handling of dynamic width in chrono formatter:
-
-  .. code:: c++
-
-     auto s = fmt::format("{0:{1}%H:%M:%S}", std::chrono::seconds(12345), 12);
-     //                        ^ width argument index                     ^ width
-     // s == "03:25:45    "
-
-  Thanks Howard Hinnant.
-
-* Removed deprecated ``fmt/time.h``. Use ``fmt/chrono.h`` instead.
-
-* Added ``fmt::format`` and ``fmt::vformat`` overloads that take ``text_style``
-  (`#993 <https://github.com/fmtlib/fmt/issues/993>`_,
-  `#994 <https://github.com/fmtlib/fmt/pull/994>`_):
-
-  .. code:: c++
-
-     #include <fmt/color.h>
-
-     std::string message = fmt::format(fmt::emphasis::bold | fg(fmt::color::red),
-                                       "The answer is {}.", 42);
-
-  Thanks `@Naios (Denis Blank) <https://github.com/Naios>`_.
-
-* Removed the deprecated color API (``print_colored``). Use the new API, namely
-  ``print`` overloads that take ``text_style`` instead.
-
-* Made ``std::unique_ptr`` and ``std::shared_ptr`` formattable as pointers via
-  ``fmt::ptr`` (`#1121 <https://github.com/fmtlib/fmt/pull/1121>`_):
-
-  .. code:: c++
-
-     std::unique_ptr<int> p = ...;
-     fmt::print("{}", fmt::ptr(p)); // prints p as a pointer
-
-  Thanks `@sighingnow (Tao He) <https://github.com/sighingnow>`_.
-
-* Made ``print`` and ``vprint`` report I/O errors
-  (`#1098 <https://github.com/fmtlib/fmt/issues/1098>`_,
-  `#1099 <https://github.com/fmtlib/fmt/pull/1099>`_).
-  Thanks `@BillyDonahue (Billy Donahue) <https://github.com/BillyDonahue>`_.
-
-* Marked deprecated APIs with the ``[[deprecated]]`` attribute and removed
-  internal uses of deprecated APIs
-  (`#1022 <https://github.com/fmtlib/fmt/pull/1022>`_).
-  Thanks `@eliaskosunen (Elias Kosunen) <https://github.com/eliaskosunen>`_.
-
-* Modernized the codebase using more C++11 features and removing workarounds.
-  Most importantly, ``buffer_context`` is now an alias template, so
-  use ``buffer_context<T>`` instead of ``buffer_context<T>::type``.
-  These features require GCC 4.8 or later.
-
-* ``formatter`` specializations now always take precedence over implicit
-  conversions to ``int`` and the undocumented ``convert_to_int`` trait
-  is now deprecated.
-
-* Moved the undocumented ``basic_writer``, ``writer``, and ``wwriter`` types
-  to the ``internal`` namespace.
-
-* Removed deprecated ``basic_format_context::begin()``. Use ``out()`` instead.
-
-* Disallowed passing the result of ``join`` as an lvalue to prevent misuse.
-
-* Refactored the undocumented structs that represent parsed format specifiers
-  to simplify the API and allow multibyte fill.
-
-* Moved SFINAE to template parameters to reduce symbol sizes.
-
-* Switched to ``fputws`` for writing wide strings so that it's no longer
-  required to call ``_setmode`` on Windows
-  (`#1229 <https://github.com/fmtlib/fmt/issues/1229>`_,
-  `#1243 <https://github.com/fmtlib/fmt/pull/1243>`_).
-  Thanks `@jackoalan (Jack Andersen) <https://github.com/jackoalan>`_.
-
-* Improved literal-based API
-  (`#1254 <https://github.com/fmtlib/fmt/pull/1254>`_).
-  Thanks `@sylveon (Charles Milette) <https://github.com/sylveon>`_.
-
-* Added support for exotic platforms without ``uintptr_t`` such as IBM i
-  (AS/400) which has 128-bit pointers and only 64-bit integers
-  (`#1059 <https://github.com/fmtlib/fmt/issues/1059>`_).
-
-* Added `Sublime Text syntax highlighting config
-  <https://github.com/fmtlib/fmt/blob/master/support/C%2B%2B.sublime-syntax>`_
-  (`#1037 <https://github.com/fmtlib/fmt/issues/1037>`_).
-  Thanks `@Kronuz (Germán Méndez Bravo) <https://github.com/Kronuz>`_.
-
-* Added the ``FMT_ENFORCE_COMPILE_STRING`` macro to enforce the use of
-  compile-time format strings
-  (`#1231 <https://github.com/fmtlib/fmt/pull/1231>`_).
-  Thanks `@jackoalan (Jack Andersen) <https://github.com/jackoalan>`_.
-
-* Stopped setting ``CMAKE_BUILD_TYPE`` if {fmt} is a subproject
-  (`#1081 <https://github.com/fmtlib/fmt/issues/1081>`_).
-
-* Various build improvements
-  (`#1039 <https://github.com/fmtlib/fmt/pull/1039>`_,
-  `#1078 <https://github.com/fmtlib/fmt/pull/1078>`_,
-  `#1091 <https://github.com/fmtlib/fmt/pull/1091>`_,
-  `#1103 <https://github.com/fmtlib/fmt/pull/1103>`_,
-  `#1177 <https://github.com/fmtlib/fmt/pull/1177>`_).
-  Thanks `@luncliff (Park DongHa) <https://github.com/luncliff>`_,
-  `@jasonszang (Jason Shuo Zang) <https://github.com/jasonszang>`_,
-  `@olafhering (Olaf Hering) <https://github.com/olafhering>`_,
-  `@Lecetem <https://github.com/Lectem>`_,
-  `@pauldreik (Paul Dreik) <https://github.com/pauldreik>`_.
-
-* Improved documentation
-  (`#1049 <https://github.com/fmtlib/fmt/issues/1049>`_,
-  `#1051 <https://github.com/fmtlib/fmt/pull/1051>`_,
-  `#1083 <https://github.com/fmtlib/fmt/pull/1083>`_,
-  `#1113 <https://github.com/fmtlib/fmt/pull/1113>`_,
-  `#1114 <https://github.com/fmtlib/fmt/pull/1114>`_,
-  `#1146 <https://github.com/fmtlib/fmt/issues/1146>`_,
-  `#1180 <https://github.com/fmtlib/fmt/issues/1180>`_,
-  `#1250 <https://github.com/fmtlib/fmt/pull/1250>`_,
-  `#1252 <https://github.com/fmtlib/fmt/pull/1252>`_,
-  `#1265 <https://github.com/fmtlib/fmt/pull/1265>`_).
-  Thanks `@mikelui (Michael Lui) <https://github.com/mikelui>`_,
-  `@foonathan (Jonathan Müller) <https://github.com/foonathan>`_,
-  `@BillyDonahue (Billy Donahue) <https://github.com/BillyDonahue>`_,
-  `@jwakely (Jonathan Wakely) <https://github.com/jwakely>`_,
-  `@kaisbe (Kais Ben Salah) <https://github.com/kaisbe>`_,
-  `@sdebionne (Samuel Debionne) <https://github.com/sdebionne>`_.
-
-* Fixed ambiguous formatter specialization in ``fmt/ranges.h``
-  (`#1123 <https://github.com/fmtlib/fmt/issues/1123>`_).
-
-* Fixed formatting of a non-empty ``std::filesystem::path`` which is an
-  infinitely deep range of its components
-  (`#1268 <https://github.com/fmtlib/fmt/issues/1268>`_).
-
-* Fixed handling of general output iterators when formatting characters
-  (`#1056 <https://github.com/fmtlib/fmt/issues/1056>`_,
-  `#1058 <https://github.com/fmtlib/fmt/pull/1058>`_).
-  Thanks `@abolz (Alexander Bolz) <https://github.com/abolz>`_.
-
-* Fixed handling of output iterators in ``formatter`` specialization for
-  ranges (`#1064 <https://github.com/fmtlib/fmt/issues/1064>`_).
-
-* Fixed handling of exotic character types
-  (`#1188 <https://github.com/fmtlib/fmt/issues/1188>`_).
-
-* Made chrono formatting work with exceptions disabled
-  (`#1062 <https://github.com/fmtlib/fmt/issues/1062>`_).
-
-* Fixed DLL visibility issues
-  (`#1134 <https://github.com/fmtlib/fmt/pull/1134>`_,
-  `#1147 <https://github.com/fmtlib/fmt/pull/1147>`_).
-  Thanks `@denchat <https://github.com/denchat>`_.
-
-* Disabled the use of UDL template extension on GCC 9
-  (`#1148 <https://github.com/fmtlib/fmt/issues/1148>`_).
-
-* Removed misplaced ``format`` compile-time checks from ``printf``
-  (`#1173 <https://github.com/fmtlib/fmt/issues/1173>`_).
-
-* Fixed issues in the experimental floating-point formatter
-  (`#1072 <https://github.com/fmtlib/fmt/issues/1072>`_,
-  `#1129 <https://github.com/fmtlib/fmt/issues/1129>`_,
-  `#1153 <https://github.com/fmtlib/fmt/issues/1153>`_,
-  `#1155 <https://github.com/fmtlib/fmt/pull/1155>`_,
-  `#1210 <https://github.com/fmtlib/fmt/issues/1210>`_,
-  `#1222 <https://github.com/fmtlib/fmt/issues/1222>`_).
-  Thanks `@alabuzhev (Alex Alabuzhev) <https://github.com/alabuzhev>`_.
-
-* Fixed bugs discovered by fuzzing or during fuzzing integration
-  (`#1124 <https://github.com/fmtlib/fmt/issues/1124>`_,
-  `#1127 <https://github.com/fmtlib/fmt/issues/1127>`_,
-  `#1132 <https://github.com/fmtlib/fmt/issues/1132>`_,
-  `#1135 <https://github.com/fmtlib/fmt/pull/1135>`_,
-  `#1136 <https://github.com/fmtlib/fmt/issues/1136>`_,
-  `#1141 <https://github.com/fmtlib/fmt/issues/1141>`_,
-  `#1142 <https://github.com/fmtlib/fmt/issues/1142>`_,
-  `#1178 <https://github.com/fmtlib/fmt/issues/1178>`_,
-  `#1179 <https://github.com/fmtlib/fmt/issues/1179>`_,
-  `#1194 <https://github.com/fmtlib/fmt/issues/1194>`_).
-  Thanks `@pauldreik (Paul Dreik) <https://github.com/pauldreik>`_.
-
-* Fixed building tests on FreeBSD and Hurd
-  (`#1043 <https://github.com/fmtlib/fmt/issues/1043>`_).
-  Thanks `@jackyf (Eugene V. Lyubimkin) <https://github.com/jackyf>`_.
-
-* Fixed various warnings and compilation issues
-  (`#998 <https://github.com/fmtlib/fmt/pull/998>`_,
-  `#1006 <https://github.com/fmtlib/fmt/pull/1006>`_,
-  `#1008 <https://github.com/fmtlib/fmt/issues/1008>`_,
-  `#1011 <https://github.com/fmtlib/fmt/issues/1011>`_,
-  `#1025 <https://github.com/fmtlib/fmt/issues/1025>`_,
-  `#1027 <https://github.com/fmtlib/fmt/pull/1027>`_,
-  `#1028 <https://github.com/fmtlib/fmt/pull/1028>`_,
-  `#1029 <https://github.com/fmtlib/fmt/pull/1029>`_,
-  `#1030 <https://github.com/fmtlib/fmt/pull/1030>`_,
-  `#1031 <https://github.com/fmtlib/fmt/pull/1031>`_,
-  `#1054 <https://github.com/fmtlib/fmt/pull/1054>`_,
-  `#1063 <https://github.com/fmtlib/fmt/issues/1063>`_,
-  `#1068 <https://github.com/fmtlib/fmt/pull/1068>`_,
-  `#1074 <https://github.com/fmtlib/fmt/pull/1074>`_,
-  `#1075 <https://github.com/fmtlib/fmt/pull/1075>`_,
-  `#1079 <https://github.com/fmtlib/fmt/pull/1079>`_,
-  `#1086 <https://github.com/fmtlib/fmt/pull/1086>`_,
-  `#1088 <https://github.com/fmtlib/fmt/issues/1088>`_,
-  `#1089 <https://github.com/fmtlib/fmt/pull/1089>`_,
-  `#1094 <https://github.com/fmtlib/fmt/pull/1094>`_,
-  `#1101 <https://github.com/fmtlib/fmt/issues/1101>`_,
-  `#1102 <https://github.com/fmtlib/fmt/pull/1102>`_,
-  `#1105 <https://github.com/fmtlib/fmt/issues/1105>`_,
-  `#1107 <https://github.com/fmtlib/fmt/pull/1107>`_,
-  `#1115 <https://github.com/fmtlib/fmt/issues/1115>`_,
-  `#1117 <https://github.com/fmtlib/fmt/issues/1117>`_,
-  `#1118 <https://github.com/fmtlib/fmt/issues/1118>`_,
-  `#1120 <https://github.com/fmtlib/fmt/issues/1120>`_,
-  `#1123 <https://github.com/fmtlib/fmt/issues/1123>`_,
-  `#1139 <https://github.com/fmtlib/fmt/pull/1139>`_,
-  `#1140 <https://github.com/fmtlib/fmt/issues/1140>`_,
-  `#1143 <https://github.com/fmtlib/fmt/issues/1143>`_,
-  `#1144 <https://github.com/fmtlib/fmt/pull/1144>`_,
-  `#1150 <https://github.com/fmtlib/fmt/pull/1150>`_,
-  `#1151 <https://github.com/fmtlib/fmt/pull/1151>`_,
-  `#1152 <https://github.com/fmtlib/fmt/issues/1152>`_,
-  `#1154 <https://github.com/fmtlib/fmt/issues/1154>`_,
-  `#1156 <https://github.com/fmtlib/fmt/issues/1156>`_,
-  `#1159 <https://github.com/fmtlib/fmt/pull/1159>`_,
-  `#1175 <https://github.com/fmtlib/fmt/issues/1175>`_,
-  `#1181 <https://github.com/fmtlib/fmt/issues/1181>`_,
-  `#1186 <https://github.com/fmtlib/fmt/issues/1186>`_,
-  `#1187 <https://github.com/fmtlib/fmt/pull/1187>`_,
-  `#1191 <https://github.com/fmtlib/fmt/pull/1191>`_,
-  `#1197 <https://github.com/fmtlib/fmt/issues/1197>`_,
-  `#1200 <https://github.com/fmtlib/fmt/issues/1200>`_,
-  `#1203 <https://github.com/fmtlib/fmt/issues/1203>`_,
-  `#1205 <https://github.com/fmtlib/fmt/issues/1205>`_,
-  `#1206 <https://github.com/fmtlib/fmt/pull/1206>`_,
-  `#1213 <https://github.com/fmtlib/fmt/issues/1213>`_,
-  `#1214 <https://github.com/fmtlib/fmt/issues/1214>`_,
-  `#1217 <https://github.com/fmtlib/fmt/pull/1217>`_,
-  `#1228 <https://github.com/fmtlib/fmt/issues/1228>`_,
-  `#1230 <https://github.com/fmtlib/fmt/pull/1230>`_,
-  `#1232 <https://github.com/fmtlib/fmt/issues/1232>`_,
-  `#1235 <https://github.com/fmtlib/fmt/pull/1235>`_,
-  `#1236 <https://github.com/fmtlib/fmt/pull/1236>`_,
-  `#1240 <https://github.com/fmtlib/fmt/issues/1240>`_).
-  Thanks `@DanielaE (Daniela Engert) <https://github.com/DanielaE>`_,
-  `@mwinterb <https://github.com/mwinterb>`_,
-  `@eliaskosunen (Elias Kosunen) <https://github.com/eliaskosunen>`_,
-  `@morinmorin <https://github.com/morinmorin>`_,
-  `@ricco19 (Brian Ricciardelli) <https://github.com/ricco19>`_,
-  `@waywardmonkeys (Bruce Mitchener) <https://github.com/waywardmonkeys>`_,
-  `@chronoxor (Ivan Shynkarenka) <https://github.com/chronoxor>`_,
-  `@remyabel <https://github.com/remyabel>`_,
-  `@pauldreik (Paul Dreik) <https://github.com/pauldreik>`_,
-  `@gsjaardema (Greg Sjaardema) <https://github.com/gsjaardema>`_,
-  `@rcane (Ronny Krüger) <https://github.com/rcane>`_,
-  `@mocabe <https://github.com/mocabe>`_,
-  `@denchat <https://github.com/denchat>`_,
-  `@cjdb (Christopher Di Bella) <https://github.com/cjdb>`_,
-  `@HazardyKnusperkeks (Björn Schäpers) <https://github.com/HazardyKnusperkeks>`_,
-  `@vedranmiletic (Vedran Miletić) <https://github.com/vedranmiletic>`_,
-  `@jackoalan (Jack Andersen) <https://github.com/jackoalan>`_,
-  `@DaanDeMeyer (Daan De Meyer) <https://github.com/DaanDeMeyer>`_,
-  `@starkmapper (Mark Stapper) <https://github.com/starkmapper>`_.
-
-5.3.0 - 2018-12-28
-------------------
-
-* Introduced experimental chrono formatting support:
-
-  .. code:: c++
-
-     #include <fmt/chrono.h>
-
-     int main() {
-       using namespace std::literals::chrono_literals;
-       fmt::print("Default format: {} {}\n", 42s, 100ms);
-       fmt::print("strftime-like format: {:%H:%M:%S}\n", 3h + 15min + 30s);
-     }
-
-  prints::
-
-     Default format: 42s 100ms
-     strftime-like format: 03:15:30
-
-* Added experimental support for emphasis (bold, italic, underline,
-  strikethrough), colored output to a file stream, and improved colored
-  formatting API
-  (`#961 <https://github.com/fmtlib/fmt/pull/961>`_,
-  `#967 <https://github.com/fmtlib/fmt/pull/967>`_,
-  `#973 <https://github.com/fmtlib/fmt/pull/973>`_):
-
-  .. code:: c++
-
-     #include <fmt/color.h>
-
-     int main() {
-       print(fg(fmt::color::crimson) | fmt::emphasis::bold,
-             "Hello, {}!\n", "world");
-       print(fg(fmt::color::floral_white) | bg(fmt::color::slate_gray) |
-             fmt::emphasis::underline, "Hello, {}!\n", "мир");
-       print(fg(fmt::color::steel_blue) | fmt::emphasis::italic,
-             "Hello, {}!\n", "世界");
-     }
-
-  prints the following on modern terminals with RGB color support:
-
-  .. image:: https://user-images.githubusercontent.com/576385/
-             50405788-b66e7500-076e-11e9-9592-7324d1f951d8.png
-
-  Thanks `@Rakete1111 (Nicolas) <https://github.com/Rakete1111>`_.
-
-* Added support for 4-bit terminal colors
-  (`#968 <https://github.com/fmtlib/fmt/issues/968>`_,
-  `#974 <https://github.com/fmtlib/fmt/pull/974>`_)
-
-  .. code:: c++
-
-     #include <fmt/color.h>
-
-     int main() {
-       print(fg(fmt::terminal_color::red), "stop\n");
-     }
-
-  Note that these colors vary by terminal:
-
-  .. image:: https://user-images.githubusercontent.com/576385/
-             50405925-dbfc7e00-0770-11e9-9b85-333fab0af9ac.png
-
-  Thanks `@Rakete1111 (Nicolas) <https://github.com/Rakete1111>`_.
-
-* Parameterized formatting functions on the type of the format string
-  (`#880 <https://github.com/fmtlib/fmt/issues/880>`_,
-  `#881 <https://github.com/fmtlib/fmt/pull/881>`_,
-  `#883 <https://github.com/fmtlib/fmt/pull/883>`_,
-  `#885 <https://github.com/fmtlib/fmt/pull/885>`_,
-  `#897 <https://github.com/fmtlib/fmt/pull/897>`_,
-  `#920 <https://github.com/fmtlib/fmt/issues/920>`_).
-  Any object of type ``S`` that has an overloaded ``to_string_view(const S&)``
-  returning ``fmt::string_view`` can be used as a format string:
-
-  .. code:: c++
-
-     namespace my_ns {
-     inline string_view to_string_view(const my_string& s) {
-       return {s.data(), s.length()};
-     }
-     }
-
-     std::string message = fmt::format(my_string("The answer is {}."), 42);
-
-  Thanks `@DanielaE (Daniela Engert) <https://github.com/DanielaE>`_.
-
-* Made ``std::string_view`` work as a format string
-  (`#898 <https://github.com/fmtlib/fmt/pull/898>`_):
-
-  .. code:: c++
-
-     auto message = fmt::format(std::string_view("The answer is {}."), 42);
-
-  Thanks `@DanielaE (Daniela Engert) <https://github.com/DanielaE>`_.
-
-* Added wide string support to compile-time format string checks
-  (`#924 <https://github.com/fmtlib/fmt/pull/924>`_):
-
-  .. code:: c++
-
-     print(fmt(L"{:f}"), 42); // compile-time error: invalid type specifier
-
-  Thanks `@XZiar <https://github.com/XZiar>`_.
-
-* Made colored print functions work with wide strings
-  (`#867 <https://github.com/fmtlib/fmt/pull/867>`_):
-
-  .. code:: c++
-
-     #include <fmt/color.h>
-
-     int main() {
-       print(fg(fmt::color::red), L"{}\n", 42);
-     }
-
-  Thanks `@DanielaE (Daniela Engert) <https://github.com/DanielaE>`_.
-
-* Introduced experimental Unicode support
-  (`#628 <https://github.com/fmtlib/fmt/issues/628>`_,
-  `#891 <https://github.com/fmtlib/fmt/pull/891>`_):
-
-  .. code:: c++
-
-     using namespace fmt::literals;
-     auto s = fmt::format("{:*^5}"_u, "🤡"_u); // s == "**🤡**"_u
-
-* Improved locale support:
-
-  .. code:: c++
-
-     #include <fmt/locale.h>
-
-     struct numpunct : std::numpunct<char> {
-      protected:
-       char do_thousands_sep() const override { return '~'; }
-     };
-
-     std::locale loc;
-     auto s = fmt::format(std::locale(loc, new numpunct()), "{:n}", 1234567);
-     // s == "1~234~567"
-
-* Constrained formatting functions on proper iterator types
-  (`#921 <https://github.com/fmtlib/fmt/pull/921>`_).
-  Thanks `@DanielaE (Daniela Engert) <https://github.com/DanielaE>`_.
-
-* Added ``make_printf_args`` and ``make_wprintf_args`` functions
-  (`#934 <https://github.com/fmtlib/fmt/pull/934>`_).
-  Thanks `@tnovotny <https://github.com/tnovotny>`_.
-
-* Deprecated ``fmt::visit``, ``parse_context``, and ``wparse_context``.
-  Use ``fmt::visit_format_arg``, ``format_parse_context``, and
-  ``wformat_parse_context`` instead.
-
-* Removed undocumented ``basic_fixed_buffer`` which has been superseded by the
-  iterator-based API
-  (`#873 <https://github.com/fmtlib/fmt/issues/873>`_,
-  `#902 <https://github.com/fmtlib/fmt/pull/902>`_).
-  Thanks `@superfunc (hollywood programmer) <https://github.com/superfunc>`_.
-
-* Disallowed repeated leading zeros in an argument ID:
-
-  .. code:: c++
-
-     fmt::print("{000}", 42); // error
-
-* Reintroduced support for gcc 4.4.
-
-* Fixed compilation on platforms with exotic ``double``
-  (`#878 <https://github.com/fmtlib/fmt/issues/878>`_).
-
-* Improved documentation
-  (`#164 <https://github.com/fmtlib/fmt/issues/164>`_,
-  `#877 <https://github.com/fmtlib/fmt/issues/877>`_,
-  `#901 <https://github.com/fmtlib/fmt/pull/901>`_,
-  `#906 <https://github.com/fmtlib/fmt/pull/906>`_,
-  `#979 <https://github.com/fmtlib/fmt/pull/979>`_).
-  Thanks `@kookjr (Mathew Cucuzella) <https://github.com/kookjr>`_,
-  `@DarkDimius (Dmitry Petrashko) <https://github.com/DarkDimius>`_,
-  `@HecticSerenity <https://github.com/HecticSerenity>`_.
-
-* Added pkgconfig support which makes it easier to consume the library from
-  meson and other build systems
-  (`#916 <https://github.com/fmtlib/fmt/pull/916>`_).
-  Thanks `@colemickens (Cole Mickens) <https://github.com/colemickens>`_.
-
-* Various build improvements
-  (`#909 <https://github.com/fmtlib/fmt/pull/909>`_,
-  `#926 <https://github.com/fmtlib/fmt/pull/926>`_,
-  `#937 <https://github.com/fmtlib/fmt/pull/937>`_,
-  `#953 <https://github.com/fmtlib/fmt/pull/953>`_,
-  `#959 <https://github.com/fmtlib/fmt/pull/959>`_).
-  Thanks `@tchaikov (Kefu Chai) <https://github.com/tchaikov>`_,
-  `@luncliff (Park DongHa) <https://github.com/luncliff>`_,
-  `@AndreasSchoenle (Andreas Schönle) <https://github.com/AndreasSchoenle>`_,
-  `@hotwatermorning <https://github.com/hotwatermorning>`_,
-  `@Zefz (JohanJansen) <https://github.com/Zefz>`_.
-
-* Improved ``string_view`` construction performance
-  (`#914 <https://github.com/fmtlib/fmt/pull/914>`_).
-  Thanks `@gabime (Gabi Melman) <https://github.com/gabime>`_.
-
-* Fixed non-matching char types
-  (`#895 <https://github.com/fmtlib/fmt/pull/895>`_).
-  Thanks `@DanielaE (Daniela Engert) <https://github.com/DanielaE>`_.
-
-* Fixed ``format_to_n`` with ``std::back_insert_iterator``
-  (`#913 <https://github.com/fmtlib/fmt/pull/913>`_).
-  Thanks `@DanielaE (Daniela Engert) <https://github.com/DanielaE>`_.
-
-* Fixed locale-dependent formatting
-  (`#905 <https://github.com/fmtlib/fmt/issues/905>`_).
-
-* Fixed various compiler warnings and errors
-  (`#882 <https://github.com/fmtlib/fmt/pull/882>`_,
-  `#886 <https://github.com/fmtlib/fmt/pull/886>`_,
-  `#933 <https://github.com/fmtlib/fmt/pull/933>`_,
-  `#941 <https://github.com/fmtlib/fmt/pull/941>`_,
-  `#931 <https://github.com/fmtlib/fmt/issues/931>`_,
-  `#943 <https://github.com/fmtlib/fmt/pull/943>`_,
-  `#954 <https://github.com/fmtlib/fmt/pull/954>`_,
-  `#956 <https://github.com/fmtlib/fmt/pull/956>`_,
-  `#962 <https://github.com/fmtlib/fmt/pull/962>`_,
-  `#965 <https://github.com/fmtlib/fmt/issues/965>`_,
-  `#977 <https://github.com/fmtlib/fmt/issues/977>`_,
-  `#983 <https://github.com/fmtlib/fmt/pull/983>`_,
-  `#989 <https://github.com/fmtlib/fmt/pull/989>`_).
-  Thanks `@Luthaf (Guillaume Fraux) <https://github.com/Luthaf>`_,
-  `@stevenhoving (Steven Hoving) <https://github.com/stevenhoving>`_,
-  `@christinaa (Kristina Brooks) <https://github.com/christinaa>`_,
-  `@lgritz (Larry Gritz) <https://github.com/lgritz>`_,
-  `@DanielaE (Daniela Engert) <https://github.com/DanielaE>`_,
-  `@0x8000-0000 (Sign Bit) <https://github.com/0x8000-0000>`_,
-  `@liuping1997 <https://github.com/liuping1997>`_.
-
-5.2.1 - 2018-09-21
-------------------
-
-* Fixed ``visit`` lookup issues on gcc 7 & 8
-  (`#870 <https://github.com/fmtlib/fmt/pull/870>`_).
-  Thanks `@medithe <https://github.com/medithe>`_.
-
-* Fixed linkage errors on older gcc.
-
-* Prevented ``fmt/range.h`` from specializing ``fmt::basic_string_view``
-  (`#865 <https://github.com/fmtlib/fmt/issues/865>`_,
-  `#868 <https://github.com/fmtlib/fmt/pull/868>`_).
-  Thanks `@hhggit (dual) <https://github.com/hhggit>`_.
-
-* Improved error message when formatting unknown types
-  (`#872 <https://github.com/fmtlib/fmt/pull/872>`_).
-  Thanks `@foonathan (Jonathan Müller) <https://github.com/foonathan>`_,
-
-* Disabled templated user-defined literals when compiled under nvcc
-  (`#875 <https://github.com/fmtlib/fmt/pull/875>`_).
-  Thanks `@CandyGumdrop (Candy Gumdrop) <https://github.com/CandyGumdrop>`_,
-
-* Fixed ``format_to`` formatting to ``wmemory_buffer``
-  (`#874 <https://github.com/fmtlib/fmt/issues/874>`_).
-
-5.2.0 - 2018-09-13
-------------------
-
-* Optimized format string parsing and argument processing which resulted in up
-  to 5x speed up on long format strings and significant performance boost on
-  various benchmarks. For example, version 5.2 is 2.22x faster than 5.1 on
-  decimal integer formatting with ``format_to`` (macOS, clang-902.0.39.2):
-
-  ==================  =======  =======
-  Method              Time, s  Speedup
-  ==================  =======  =======
-  fmt::format 5.1      0.58
-  fmt::format 5.2      0.35     1.66x
-  fmt::format_to 5.1   0.51
-  fmt::format_to 5.2   0.23     2.22x
-  sprintf              0.71
-  std::to_string       1.01
-  std::stringstream    1.73
-  ==================  =======  =======
-
-* Changed the ``fmt`` macro from opt-out to opt-in to prevent name collisions.
-  To enable it define the ``FMT_STRING_ALIAS`` macro to 1 before including
-  ``fmt/format.h``:
-
-  .. code:: c++
-
-     #define FMT_STRING_ALIAS 1
-     #include <fmt/format.h>
-     std::string answer = format(fmt("{}"), 42);
-
-* Added compile-time format string checks to ``format_to`` overload that takes
-  ``fmt::memory_buffer`` (`#783 <https://github.com/fmtlib/fmt/issues/783>`_):
-
-  .. code:: c++
-
-     fmt::memory_buffer buf;
-     // Compile-time error: invalid type specifier.
-     fmt::format_to(buf, fmt("{:d}"), "foo");
-
-* Moved experimental color support to ``fmt/color.h`` and enabled the
-  new API by default. The old API can be enabled by defining the
-  ``FMT_DEPRECATED_COLORS`` macro.
-
-* Added formatting support for types explicitly convertible to
-  ``fmt::string_view``:
-
-  .. code:: c++
-
-     struct foo {
-       explicit operator fmt::string_view() const { return "foo"; }
-     };
-     auto s = format("{}", foo());
-
-  In particular, this makes formatting function work with
-  ``folly::StringPiece``.
-
-* Implemented preliminary support for ``char*_t`` by replacing the ``format``
-  function overloads with a single function template parameterized on the string
-  type.
-
-* Added support for dynamic argument lists
-  (`#814 <https://github.com/fmtlib/fmt/issues/814>`_,
-  `#819 <https://github.com/fmtlib/fmt/pull/819>`_).
-  Thanks `@MikePopoloski (Michael Popoloski)
-  <https://github.com/MikePopoloski>`_.
-
-* Reduced executable size overhead for embedded targets using newlib nano by
-  making locale dependency optional
-  (`#839 <https://github.com/fmtlib/fmt/pull/839>`_).
-  Thanks `@teajay-fr (Thomas Benard) <https://github.com/teajay-fr>`_.
-
-* Keep ``noexcept`` specifier when exceptions are disabled
-  (`#801 <https://github.com/fmtlib/fmt/issues/801>`_,
-  `#810 <https://github.com/fmtlib/fmt/pull/810>`_).
-  Thanks `@qis (Alexej Harm) <https://github.com/qis>`_.
-
-* Fixed formatting of user-defined types providing ``operator<<`` with
-  ``format_to_n``
-  (`#806 <https://github.com/fmtlib/fmt/pull/806>`_).
-  Thanks `@mkurdej (Marek Kurdej) <https://github.com/mkurdej>`_.
-
-* Fixed dynamic linkage of new symbols
-  (`#808 <https://github.com/fmtlib/fmt/issues/808>`_).
-
-* Fixed global initialization issue
-  (`#807 <https://github.com/fmtlib/fmt/issues/807>`_):
-
-  .. code:: c++
-
-     // This works on compilers with constexpr support.
-     static const std::string answer = fmt::format("{}", 42);
-
-* Fixed various compiler warnings and errors
-  (`#804 <https://github.com/fmtlib/fmt/pull/804>`_,
-  `#809 <https://github.com/fmtlib/fmt/issues/809>`_,
-  `#811 <https://github.com/fmtlib/fmt/pull/811>`_,
-  `#822 <https://github.com/fmtlib/fmt/issues/822>`_,
-  `#827 <https://github.com/fmtlib/fmt/pull/827>`_,
-  `#830 <https://github.com/fmtlib/fmt/issues/830>`_,
-  `#838 <https://github.com/fmtlib/fmt/pull/838>`_,
-  `#843 <https://github.com/fmtlib/fmt/issues/843>`_,
-  `#844 <https://github.com/fmtlib/fmt/pull/844>`_,
-  `#851 <https://github.com/fmtlib/fmt/issues/851>`_,
-  `#852 <https://github.com/fmtlib/fmt/pull/852>`_,
-  `#854 <https://github.com/fmtlib/fmt/pull/854>`_).
-  Thanks `@henryiii (Henry Schreiner) <https://github.com/henryiii>`_,
-  `@medithe <https://github.com/medithe>`_, and
-  `@eliasdaler (Elias Daler) <https://github.com/eliasdaler>`_.
-
-5.1.0 - 2018-07-05
-------------------
-
-* Added experimental support for RGB color output enabled with
-  the ``FMT_EXTENDED_COLORS`` macro:
-
-  .. code:: c++
-
-     #define FMT_EXTENDED_COLORS
-     #define FMT_HEADER_ONLY // or compile fmt with FMT_EXTENDED_COLORS defined
-     #include <fmt/format.h>
-
-     fmt::print(fmt::color::steel_blue, "Some beautiful text");
-
-  The old API (the ``print_colored`` and ``vprint_colored`` functions and the
-  ``color`` enum) is now deprecated.
-  (`#762 <https://github.com/fmtlib/fmt/issues/762>`_
-  `#767 <https://github.com/fmtlib/fmt/pull/767>`_).
-  thanks `@Remotion (Remo) <https://github.com/Remotion>`_.
-
-* Added quotes to strings in ranges and tuples
-  (`#766 <https://github.com/fmtlib/fmt/pull/766>`_).
-  Thanks `@Remotion (Remo) <https://github.com/Remotion>`_.
-
-* Made ``format_to`` work with ``basic_memory_buffer``
-  (`#776 <https://github.com/fmtlib/fmt/issues/776>`_).
-
-* Added ``vformat_to_n`` and ``wchar_t`` overload of ``format_to_n``
-  (`#764 <https://github.com/fmtlib/fmt/issues/764>`_,
-  `#769 <https://github.com/fmtlib/fmt/issues/769>`_).
-
-* Made ``is_range`` and ``is_tuple_like`` part of public (experimental) API
-  to allow specialization for user-defined types
-  (`#751 <https://github.com/fmtlib/fmt/issues/751>`_,
-  `#759 <https://github.com/fmtlib/fmt/pull/759>`_).
-  Thanks `@drrlvn (Dror Levin) <https://github.com/drrlvn>`_.
-
-* Added more compilers to continuous integration and increased ``FMT_PEDANTIC``
-  warning levels
-  (`#736 <https://github.com/fmtlib/fmt/pull/736>`_).
-  Thanks `@eliaskosunen (Elias Kosunen) <https://github.com/eliaskosunen>`_.
-
-* Fixed compilation with MSVC 2013.
-
-* Fixed handling of user-defined types in ``format_to``
-  (`#793 <https://github.com/fmtlib/fmt/issues/793>`_).
-
-* Forced linking of inline ``vformat`` functions into the library
-  (`#795 <https://github.com/fmtlib/fmt/issues/795>`_).
-
-* Fixed incorrect call to on_align in ``'{:}='``
-  (`#750 <https://github.com/fmtlib/fmt/issues/750>`_).
-
-* Fixed floating-point formatting to a non-back_insert_iterator with sign &
-  numeric alignment specified
-  (`#756 <https://github.com/fmtlib/fmt/issues/756>`_).
-
-* Fixed formatting to an array with ``format_to_n``
-  (`#778 <https://github.com/fmtlib/fmt/issues/778>`_).
-
-* Fixed formatting of more than 15 named arguments
-  (`#754 <https://github.com/fmtlib/fmt/issues/754>`_).
-
-* Fixed handling of compile-time strings when including ``fmt/ostream.h``.
-  (`#768 <https://github.com/fmtlib/fmt/issues/768>`_).
-
-* Fixed various compiler warnings and errors
-  (`#742 <https://github.com/fmtlib/fmt/issues/742>`_,
-  `#748 <https://github.com/fmtlib/fmt/issues/748>`_,
-  `#752 <https://github.com/fmtlib/fmt/issues/752>`_,
-  `#770 <https://github.com/fmtlib/fmt/issues/770>`_,
-  `#775 <https://github.com/fmtlib/fmt/pull/775>`_,
-  `#779 <https://github.com/fmtlib/fmt/issues/779>`_,
-  `#780 <https://github.com/fmtlib/fmt/pull/780>`_,
-  `#790 <https://github.com/fmtlib/fmt/pull/790>`_,
-  `#792 <https://github.com/fmtlib/fmt/pull/792>`_,
-  `#800 <https://github.com/fmtlib/fmt/pull/800>`_).
-  Thanks `@Remotion (Remo) <https://github.com/Remotion>`_,
-  `@gabime (Gabi Melman) <https://github.com/gabime>`_,
-  `@foonathan (Jonathan Müller) <https://github.com/foonathan>`_,
-  `@Dark-Passenger (Dhruv Paranjape) <https://github.com/Dark-Passenger>`_, and
-  `@0x8000-0000 (Sign Bit) <https://github.com/0x8000-0000>`_.
-
-5.0.0 - 2018-05-21
-------------------
-
-* Added a requirement for partial C++11 support, most importantly variadic
-  templates and type traits, and dropped ``FMT_VARIADIC_*`` emulation macros.
-  Variadic templates are available since GCC 4.4, Clang 2.9 and MSVC 18.0 (2013).
-  For older compilers use {fmt} `version 4.x
-  <https://github.com/fmtlib/fmt/releases/tag/4.1.0>`_ which continues to be
-  maintained and works with C++98 compilers.
-
-* Renamed symbols to follow standard C++ naming conventions and proposed a subset
-  of the library for standardization in `P0645R2 Text Formatting
-  <https://wg21.link/P0645>`_.
-
-* Implemented ``constexpr`` parsing of format strings and `compile-time format
-  string checks
-  <https://fmt.dev/latest/api.html#compile-time-format-string-checks>`_. For
-  example
-
-  .. code:: c++
-
-     #include <fmt/format.h>
-
-     std::string s = format(fmt("{:d}"), "foo");
-
-  gives a compile-time error because ``d`` is an invalid specifier for strings
-  (`godbolt <https://godbolt.org/g/rnCy9Q>`__)::
-
-     ...
-     <source>:4:19: note: in instantiation of function template specialization 'fmt::v5::format<S, char [4]>' requested here
-       std::string s = format(fmt("{:d}"), "foo");
-                       ^
-     format.h:1337:13: note: non-constexpr function 'on_error' cannot be used in a constant expression
-         handler.on_error("invalid type specifier");
-
-  Compile-time checks require relaxed ``constexpr`` (C++14 feature) support. If
-  the latter is not available, checks will be performed at runtime.
-
-* Separated format string parsing and formatting in the extension API to enable
-  compile-time format string processing. For example
-
-  .. code:: c++
-
-     struct Answer {};
-
-     namespace fmt {
-     template <>
-     struct formatter<Answer> {
-       constexpr auto parse(parse_context& ctx) {
-         auto it = ctx.begin();
-         spec = *it;
-         if (spec != 'd' && spec != 's')
-           throw format_error("invalid specifier");
-         return ++it;
-       }
-
-       template <typename FormatContext>
-       auto format(Answer, FormatContext& ctx) {
-         return spec == 's' ?
-           format_to(ctx.begin(), "{}", "fourty-two") :
-           format_to(ctx.begin(), "{}", 42);
-       }
-
-       char spec = 0;
-     };
-     }
-
-     std::string s = format(fmt("{:x}"), Answer());
-
-  gives a compile-time error due to invalid format specifier (`godbolt
-  <https://godbolt.org/g/2jQ1Dv>`__)::
-
-     ...
-     <source>:12:45: error: expression '<throw-expression>' is not a constant expression
-            throw format_error("invalid specifier");
-
-* Added `iterator support
-  <https://fmt.dev/latest/api.html#output-iterator-support>`_:
-
-  .. code:: c++
-
-     #include <vector>
-     #include <fmt/format.h>
-
-     std::vector<char> out;
-     fmt::format_to(std::back_inserter(out), "{}", 42);
-
-* Added the `format_to_n
-  <https://fmt.dev/latest/api.html#_CPPv2N3fmt11format_to_nE8OutputItNSt6size_tE11string_viewDpRK4Args>`_
-  function that restricts the output to the specified number of characters
-  (`#298 <https://github.com/fmtlib/fmt/issues/298>`_):
-
-  .. code:: c++
-
-     char out[4];
-     fmt::format_to_n(out, sizeof(out), "{}", 12345);
-     // out == "1234" (without terminating '\0')
-
-* Added the `formatted_size
-  <https://fmt.dev/latest/api.html#_CPPv2N3fmt14formatted_sizeE11string_viewDpRK4Args>`_
-  function for computing the output size:
-
-  .. code:: c++
-
-     #include <fmt/format.h>
-
-     auto size = fmt::formatted_size("{}", 12345); // size == 5
-
-* Improved compile times by reducing dependencies on standard headers and
-  providing a lightweight `core API <https://fmt.dev/latest/api.html#core-api>`_:
-
-  .. code:: c++
-
-     #include <fmt/core.h>
-
-     fmt::print("The answer is {}.", 42);
-
-  See `Compile time and code bloat
-  <https://github.com/fmtlib/fmt#compile-time-and-code-bloat>`_.
-
-* Added the `make_format_args
-  <https://fmt.dev/latest/api.html#_CPPv2N3fmt16make_format_argsEDpRK4Args>`_
-  function for capturing formatting arguments:
-
-  .. code:: c++
-  
-     // Prints formatted error message.
-     void vreport_error(const char *format, fmt::format_args args) {
-       fmt::print("Error: ");
-       fmt::vprint(format, args);
-     }
-     template <typename... Args>
-     void report_error(const char *format, const Args & ... args) {
-       vreport_error(format, fmt::make_format_args(args...));
-     }
-
-* Added the ``make_printf_args`` function for capturing ``printf`` arguments
-  (`#687 <https://github.com/fmtlib/fmt/issues/687>`_,
-  `#694 <https://github.com/fmtlib/fmt/pull/694>`_).
-  Thanks `@Kronuz (Germán Méndez Bravo) <https://github.com/Kronuz>`_.
-
-* Added prefix ``v`` to non-variadic functions taking ``format_args`` to
-  distinguish them from variadic ones:
-
-  .. code:: c++
-
-     std::string vformat(string_view format_str, format_args args);
-     
-     template <typename... Args>
-     std::string format(string_view format_str, const Args & ... args);
-
-* Added experimental support for formatting ranges, containers and tuple-like
-  types in ``fmt/ranges.h`` (`#735 <https://github.com/fmtlib/fmt/pull/735>`_):
-
-  .. code:: c++
-
-     #include <fmt/ranges.h>
-
-     std::vector<int> v = {1, 2, 3};
-     fmt::print("{}", v); // prints {1, 2, 3}
-
-  Thanks `@Remotion (Remo) <https://github.com/Remotion>`_.
-
-* Implemented ``wchar_t`` date and time formatting
-  (`#712 <https://github.com/fmtlib/fmt/pull/712>`_):
-
-  .. code:: c++
-
-     #include <fmt/time.h>
-
-     std::time_t t = std::time(nullptr);
-     auto s = fmt::format(L"The date is {:%Y-%m-%d}.", *std::localtime(&t));
-
-  Thanks `@DanielaE (Daniela Engert) <https://github.com/DanielaE>`_.
-
-* Provided more wide string overloads
-  (`#724 <https://github.com/fmtlib/fmt/pull/724>`_).
-  Thanks `@DanielaE (Daniela Engert) <https://github.com/DanielaE>`_.
-
-* Switched from a custom null-terminated string view class to ``string_view``
-  in the format API and provided ``fmt::string_view`` which implements a subset
-  of ``std::string_view`` API for pre-C++17 systems.
-
-* Added support for ``std::experimental::string_view``
-  (`#607 <https://github.com/fmtlib/fmt/pull/607>`_):
-
-  .. code:: c++
-
-     #include <fmt/core.h>
-     #include <experimental/string_view>
-
-     fmt::print("{}", std::experimental::string_view("foo"));
-
-  Thanks `@virgiliofornazin (Virgilio Alexandre Fornazin)
-  <https://github.com/virgiliofornazin>`__.
-
-* Allowed mixing named and automatic arguments:
-
-  .. code:: c++
-
-     fmt::format("{} {two}", 1, fmt::arg("two", 2));
-
-* Removed the write API in favor of the `format API
-  <https://fmt.dev/latest/api.html#format-api>`_ with compile-time handling of
-  format strings.
-
-* Disallowed formatting of multibyte strings into a wide character target
-  (`#606 <https://github.com/fmtlib/fmt/pull/606>`_).
-
-* Improved documentation
-  (`#515 <https://github.com/fmtlib/fmt/pull/515>`_,
-  `#614 <https://github.com/fmtlib/fmt/issues/614>`_,
-  `#617 <https://github.com/fmtlib/fmt/pull/617>`_,
-  `#661 <https://github.com/fmtlib/fmt/pull/661>`_,
-  `#680 <https://github.com/fmtlib/fmt/pull/680>`_).
-  Thanks `@ibell (Ian Bell) <https://github.com/ibell>`_,
-  `@mihaitodor (Mihai Todor) <https://github.com/mihaitodor>`_, and
-  `@johnthagen <https://github.com/johnthagen>`_.
-
-* Implemented more efficient handling of large number of format arguments.
-
-* Introduced an inline namespace for symbol versioning.
-
-* Added debug postfix ``d`` to the ``fmt`` library name
-  (`#636 <https://github.com/fmtlib/fmt/issues/636>`_).
-
-* Removed unnecessary ``fmt/`` prefix in includes
-  (`#397 <https://github.com/fmtlib/fmt/pull/397>`_).
-  Thanks `@chronoxor (Ivan Shynkarenka) <https://github.com/chronoxor>`_.
-
-* Moved ``fmt/*.h`` to ``include/fmt/*.h`` to prevent irrelevant files and
-  directories appearing on the include search paths when fmt is used as a
-  subproject and moved source files to the ``src`` directory.
-
-* Added qmake project file ``support/fmt.pro``
-  (`#641 <https://github.com/fmtlib/fmt/pull/641>`_).
-  Thanks `@cowo78 (Giuseppe Corbelli) <https://github.com/cowo78>`_.
-
-* Added Gradle build file ``support/build.gradle``
-  (`#649 <https://github.com/fmtlib/fmt/pull/649>`_).
-  Thanks `@luncliff (Park DongHa) <https://github.com/luncliff>`_.
-
-* Removed ``FMT_CPPFORMAT`` CMake option.
-
-* Fixed a name conflict with the macro ``CHAR_WIDTH`` in glibc
-  (`#616 <https://github.com/fmtlib/fmt/pull/616>`_).
-  Thanks `@aroig (Abdó Roig-Maranges) <https://github.com/aroig>`_.
-
-* Fixed handling of nested braces in ``fmt::join``
-  (`#638 <https://github.com/fmtlib/fmt/issues/638>`_).
-
-* Added ``SOURCELINK_SUFFIX`` for compatibility with Sphinx 1.5
-  (`#497 <https://github.com/fmtlib/fmt/pull/497>`_).
-  Thanks `@ginggs (Graham Inggs) <https://github.com/ginggs>`_.
-
-* Added a missing ``inline`` in the header-only mode
-  (`#626 <https://github.com/fmtlib/fmt/pull/626>`_).
-  Thanks `@aroig (Abdó Roig-Maranges) <https://github.com/aroig>`_.
-
-* Fixed various compiler warnings
-  (`#640 <https://github.com/fmtlib/fmt/pull/640>`_,
-  `#656 <https://github.com/fmtlib/fmt/pull/656>`_,
-  `#679 <https://github.com/fmtlib/fmt/pull/679>`_,
-  `#681 <https://github.com/fmtlib/fmt/pull/681>`_,
-  `#705 <https://github.com/fmtlib/fmt/pull/705>`__,
-  `#715 <https://github.com/fmtlib/fmt/issues/715>`_,
-  `#717 <https://github.com/fmtlib/fmt/pull/717>`_,
-  `#720 <https://github.com/fmtlib/fmt/pull/720>`_,
-  `#723 <https://github.com/fmtlib/fmt/pull/723>`_,
-  `#726 <https://github.com/fmtlib/fmt/pull/726>`_,
-  `#730 <https://github.com/fmtlib/fmt/pull/730>`_,
-  `#739 <https://github.com/fmtlib/fmt/pull/739>`_).
-  Thanks `@peterbell10 <https://github.com/peterbell10>`_,
-  `@LarsGullik <https://github.com/LarsGullik>`_,
-  `@foonathan (Jonathan Müller) <https://github.com/foonathan>`_,
-  `@eliaskosunen (Elias Kosunen) <https://github.com/eliaskosunen>`_,
-  `@christianparpart (Christian Parpart) <https://github.com/christianparpart>`_,
-  `@DanielaE (Daniela Engert) <https://github.com/DanielaE>`_,
-  and `@mwinterb <https://github.com/mwinterb>`_.
-
-* Worked around an MSVC bug and fixed several warnings
-  (`#653 <https://github.com/fmtlib/fmt/pull/653>`_).
-  Thanks `@alabuzhev (Alex Alabuzhev) <https://github.com/alabuzhev>`_.
-
-* Worked around GCC bug 67371
-  (`#682 <https://github.com/fmtlib/fmt/issues/682>`_).
-
-* Fixed compilation with ``-fno-exceptions``
-  (`#655 <https://github.com/fmtlib/fmt/pull/655>`_).
-  Thanks `@chenxiaolong (Andrew Gunnerson) <https://github.com/chenxiaolong>`_.
-
-* Made ``constexpr remove_prefix`` gcc version check tighter
-  (`#648 <https://github.com/fmtlib/fmt/issues/648>`_).
-
-* Renamed internal type enum constants to prevent collision with poorly written
-  C libraries (`#644 <https://github.com/fmtlib/fmt/issues/644>`_).
-
-* Added detection of ``wostream operator<<``
-  (`#650 <https://github.com/fmtlib/fmt/issues/650>`_).
-
-* Fixed compilation on OpenBSD
-  (`#660 <https://github.com/fmtlib/fmt/pull/660>`_).
-  Thanks `@hubslave <https://github.com/hubslave>`_.
-
-* Fixed compilation on FreeBSD 12
-  (`#732 <https://github.com/fmtlib/fmt/pull/732>`_).
-  Thanks `@dankm <https://github.com/dankm>`_.
-
-* Fixed compilation when there is a mismatch between ``-std`` options between
-  the library and user code
-  (`#664 <https://github.com/fmtlib/fmt/issues/664>`_).
-
-* Fixed compilation with GCC 7 and ``-std=c++11``
-  (`#734 <https://github.com/fmtlib/fmt/issues/734>`_).
-
-* Improved generated binary code on GCC 7 and older
-  (`#668 <https://github.com/fmtlib/fmt/issues/668>`_).
-
-* Fixed handling of numeric alignment with no width 
-  (`#675 <https://github.com/fmtlib/fmt/issues/675>`_).
-
-* Fixed handling of empty strings in UTF8/16 converters
-  (`#676 <https://github.com/fmtlib/fmt/pull/676>`_).
-  Thanks `@vgalka-sl (Vasili Galka) <https://github.com/vgalka-sl>`_.
-
-* Fixed formatting of an empty ``string_view``
-  (`#689 <https://github.com/fmtlib/fmt/issues/689>`_).
-
-* Fixed detection of ``string_view`` on libc++ 
-  (`#686 <https://github.com/fmtlib/fmt/issues/686>`_).
-
-* Fixed DLL issues (`#696 <https://github.com/fmtlib/fmt/pull/696>`_).
-  Thanks `@sebkoenig <https://github.com/sebkoenig>`_.
-
-* Fixed compile checks for mixing narrow and wide strings
-  (`#690 <https://github.com/fmtlib/fmt/issues/690>`_).
-
-* Disabled unsafe implicit conversion to ``std::string``
-  (`#729 <https://github.com/fmtlib/fmt/issues/729>`_).
-
-* Fixed handling of reused format specs (as in ``fmt::join``) for pointers
-  (`#725 <https://github.com/fmtlib/fmt/pull/725>`_).
-  Thanks `@mwinterb <https://github.com/mwinterb>`_.
-
-* Fixed installation of ``fmt/ranges.h``
-  (`#738 <https://github.com/fmtlib/fmt/pull/738>`_).
-  Thanks `@sv1990 <https://github.com/sv1990>`_.
-
-4.1.0 - 2017-12-20
-------------------
-
-* Added ``fmt::to_wstring()`` in addition to ``fmt::to_string()``
-  (`#559 <https://github.com/fmtlib/fmt/pull/559>`_).
-  Thanks `@alabuzhev (Alex Alabuzhev) <https://github.com/alabuzhev>`_.
-
-* Added support for C++17 ``std::string_view``
-  (`#571 <https://github.com/fmtlib/fmt/pull/571>`_ and
-  `#578 <https://github.com/fmtlib/fmt/pull/578>`_).
-  Thanks `@thelostt (Mário Feroldi) <https://github.com/thelostt>`_ and
-  `@mwinterb <https://github.com/mwinterb>`_.
-
-* Enabled stream exceptions to catch errors
-  (`#581 <https://github.com/fmtlib/fmt/issues/581>`_).
-  Thanks `@crusader-mike <https://github.com/crusader-mike>`_.
-
-* Allowed formatting of class hierarchies with ``fmt::format_arg()``
-  (`#547 <https://github.com/fmtlib/fmt/pull/547>`_).
-  Thanks `@rollbear (Björn Fahller) <https://github.com/rollbear>`_.
-
-* Removed limitations on character types
-  (`#563 <https://github.com/fmtlib/fmt/pull/563>`_).
-  Thanks `@Yelnats321 (Elnar Dakeshov) <https://github.com/Yelnats321>`_.
-
-* Conditionally enabled use of ``std::allocator_traits``
-  (`#583 <https://github.com/fmtlib/fmt/pull/583>`_).
-  Thanks `@mwinterb <https://github.com/mwinterb>`_.
-
-* Added support for ``const`` variadic member function emulation with
-  ``FMT_VARIADIC_CONST`` (`#591 <https://github.com/fmtlib/fmt/pull/591>`_).
-  Thanks `@ludekvodicka (Ludek Vodicka) <https://github.com/ludekvodicka>`_.
-
-* Various bugfixes: bad overflow check, unsupported implicit type conversion
-  when determining formatting function, test segfaults
-  (`#551 <https://github.com/fmtlib/fmt/issues/551>`_), ill-formed macros
-  (`#542 <https://github.com/fmtlib/fmt/pull/542>`_) and ambiguous overloads
-  (`#580 <https://github.com/fmtlib/fmt/issues/580>`_).
-  Thanks `@xylosper (Byoung-young Lee) <https://github.com/xylosper>`_.
-
-* Prevented warnings on MSVC (`#605 <https://github.com/fmtlib/fmt/pull/605>`_,
-  `#602 <https://github.com/fmtlib/fmt/pull/602>`_, and
-  `#545 <https://github.com/fmtlib/fmt/pull/545>`_),
-  clang (`#582 <https://github.com/fmtlib/fmt/pull/582>`_),
-  GCC (`#573 <https://github.com/fmtlib/fmt/issues/573>`_),
-  various conversion warnings (`#609 <https://github.com/fmtlib/fmt/pull/609>`_,
-  `#567 <https://github.com/fmtlib/fmt/pull/567>`_,
-  `#553 <https://github.com/fmtlib/fmt/pull/553>`_ and
-  `#553 <https://github.com/fmtlib/fmt/pull/553>`_), and added ``override`` and
-  ``[[noreturn]]`` (`#549 <https://github.com/fmtlib/fmt/pull/549>`_ and
-  `#555 <https://github.com/fmtlib/fmt/issues/555>`_).
-  Thanks `@alabuzhev (Alex Alabuzhev) <https://github.com/alabuzhev>`_,
-  `@virgiliofornazin (Virgilio Alexandre Fornazin)
-  <https://gihtub.com/virgiliofornazin>`_,
-  `@alexanderbock (Alexander Bock) <https://github.com/alexanderbock>`_,
-  `@yumetodo <https://github.com/yumetodo>`_,
-  `@VaderY (Császár Mátyás) <https://github.com/VaderY>`_,
-  `@jpcima (JP Cimalando) <https://github.com/jpcima>`_,
-  `@thelostt (Mário Feroldi) <https://github.com/thelostt>`_, and
-  `@Manu343726 (Manu Sánchez) <https://github.com/Manu343726>`_.
-
-* Improved CMake: Used ``GNUInstallDirs`` to set installation location
-  (`#610 <https://github.com/fmtlib/fmt/pull/610>`_) and fixed warnings
-  (`#536 <https://github.com/fmtlib/fmt/pull/536>`_ and
-  `#556 <https://github.com/fmtlib/fmt/pull/556>`_).
-  Thanks `@mikecrowe (Mike Crowe) <https://github.com/mikecrowe>`_,
-  `@evgen231 <https://github.com/evgen231>`_ and
-  `@henryiii (Henry Schreiner) <https://github.com/henryiii>`_.
-
-4.0.0 - 2017-06-27
-------------------
-
-* Removed old compatibility headers ``cppformat/*.h`` and CMake options
-  (`#527 <https://github.com/fmtlib/fmt/pull/527>`_).
-  Thanks `@maddinat0r (Alex Martin) <https://github.com/maddinat0r>`_.
-
-* Added ``string.h`` containing ``fmt::to_string()`` as alternative to
-  ``std::to_string()`` as well as other string writer functionality
-  (`#326 <https://github.com/fmtlib/fmt/issues/326>`_ and
-  `#441 <https://github.com/fmtlib/fmt/pull/441>`_):
-
-  .. code:: c++
-
-    #include "fmt/string.h"
-  
-    std::string answer = fmt::to_string(42);
-
-  Thanks to `@glebov-andrey (Andrey Glebov)
-  <https://github.com/glebov-andrey>`_.
-
-* Moved ``fmt::printf()`` to new ``printf.h`` header and allowed ``%s`` as
-  generic specifier (`#453 <https://github.com/fmtlib/fmt/pull/453>`_),
-  made ``%.f`` more conformant to regular ``printf()``
-  (`#490 <https://github.com/fmtlib/fmt/pull/490>`_), added custom writer
-  support (`#476 <https://github.com/fmtlib/fmt/issues/476>`_) and implemented
-  missing custom argument formatting
-  (`#339 <https://github.com/fmtlib/fmt/pull/339>`_ and
-  `#340 <https://github.com/fmtlib/fmt/pull/340>`_):
-
-  .. code:: c++
-
-    #include "fmt/printf.h"
- 
-    // %s format specifier can be used with any argument type.
-    fmt::printf("%s", 42);
-
-  Thanks `@mojoBrendan <https://github.com/mojoBrendan>`_,
-  `@manylegged (Arthur Danskin) <https://github.com/manylegged>`_ and
-  `@spacemoose (Glen Stark) <https://github.com/spacemoose>`_.
-  See also `#360 <https://github.com/fmtlib/fmt/issues/360>`_,
-  `#335 <https://github.com/fmtlib/fmt/issues/335>`_ and
-  `#331 <https://github.com/fmtlib/fmt/issues/331>`_.
-
-* Added ``container.h`` containing a ``BasicContainerWriter``
-  to write to containers like ``std::vector``
-  (`#450 <https://github.com/fmtlib/fmt/pull/450>`_).
-  Thanks `@polyvertex (Jean-Charles Lefebvre) <https://github.com/polyvertex>`_.
-
-* Added ``fmt::join()`` function that takes a range and formats
-  its elements separated by a given string
-  (`#466 <https://github.com/fmtlib/fmt/pull/466>`_):
-
-  .. code:: c++
-
-    #include "fmt/format.h"
- 
-    std::vector<double> v = {1.2, 3.4, 5.6};
-    // Prints "(+01.20, +03.40, +05.60)".
-    fmt::print("({:+06.2f})", fmt::join(v.begin(), v.end(), ", "));
-
-  Thanks `@olivier80 <https://github.com/olivier80>`_.
-
-* Added support for custom formatting specifications to simplify customization
-  of built-in formatting (`#444 <https://github.com/fmtlib/fmt/pull/444>`_).
-  Thanks `@polyvertex (Jean-Charles Lefebvre) <https://github.com/polyvertex>`_.
-  See also `#439 <https://github.com/fmtlib/fmt/issues/439>`_.
-
-* Added ``fmt::format_system_error()`` for error code formatting
-  (`#323 <https://github.com/fmtlib/fmt/issues/323>`_ and
-  `#526 <https://github.com/fmtlib/fmt/pull/526>`_).
-  Thanks `@maddinat0r (Alex Martin) <https://github.com/maddinat0r>`_.
-
-* Added thread-safe ``fmt::localtime()`` and ``fmt::gmtime()``
-  as replacement   for the standard version to ``time.h``
-  (`#396 <https://github.com/fmtlib/fmt/pull/396>`_).
-  Thanks `@codicodi <https://github.com/codicodi>`_.
-
-* Internal improvements to ``NamedArg`` and ``ArgLists``
-  (`#389 <https://github.com/fmtlib/fmt/pull/389>`_ and
-  `#390 <https://github.com/fmtlib/fmt/pull/390>`_).
-  Thanks `@chronoxor <https://github.com/chronoxor>`_.
-
-* Fixed crash due to bug in ``FormatBuf``
-  (`#493 <https://github.com/fmtlib/fmt/pull/493>`_).
-  Thanks `@effzeh <https://github.com/effzeh>`_. See also
-  `#480 <https://github.com/fmtlib/fmt/issues/480>`_ and
-  `#491 <https://github.com/fmtlib/fmt/issues/491>`_.
-
-* Fixed handling of wide strings in ``fmt::StringWriter``.
-
-* Improved compiler error messages
-  (`#357 <https://github.com/fmtlib/fmt/issues/357>`_).
-
-* Fixed various warnings and issues with various compilers
-  (`#494 <https://github.com/fmtlib/fmt/pull/494>`_,
-  `#499 <https://github.com/fmtlib/fmt/pull/499>`_,
-  `#483 <https://github.com/fmtlib/fmt/pull/483>`_,
-  `#485 <https://github.com/fmtlib/fmt/pull/485>`_,
-  `#482 <https://github.com/fmtlib/fmt/pull/482>`_,
-  `#475 <https://github.com/fmtlib/fmt/pull/475>`_,
-  `#473 <https://github.com/fmtlib/fmt/pull/473>`_ and
-  `#414 <https://github.com/fmtlib/fmt/pull/414>`_).
-  Thanks `@chronoxor <https://github.com/chronoxor>`_,
-  `@zhaohuaxishi <https://github.com/zhaohuaxishi>`_,
-  `@pkestene (Pierre Kestener) <https://github.com/pkestene>`_,
-  `@dschmidt (Dominik Schmidt) <https://github.com/dschmidt>`_ and
-  `@0x414c (Alexey Gorishny) <https://github.com/0x414c>`_ .
-
-* Improved CMake: targets are now namespaced
-  (`#511 <https://github.com/fmtlib/fmt/pull/511>`_ and
-  `#513 <https://github.com/fmtlib/fmt/pull/513>`_), supported header-only
-  ``printf.h`` (`#354 <https://github.com/fmtlib/fmt/pull/354>`_), fixed issue
-  with minimal supported library subset
-  (`#418 <https://github.com/fmtlib/fmt/issues/418>`_,
-  `#419 <https://github.com/fmtlib/fmt/pull/419>`_ and
-  `#420 <https://github.com/fmtlib/fmt/pull/420>`_).
-  Thanks `@bjoernthiel (Bjoern Thiel) <https://github.com/bjoernthiel>`_,
-  `@niosHD (Mario Werner) <https://github.com/niosHD>`_,
-  `@LogicalKnight (Sean LK) <https://github.com/LogicalKnight>`_ and
-  `@alabuzhev (Alex Alabuzhev) <https://github.com/alabuzhev>`_.
-
-* Improved documentation. Thanks to
-  `@pwm1234 (Phil) <https://github.com/pwm1234>`_ for
-  `#393 <https://github.com/fmtlib/fmt/pull/393>`_.
-
-3.0.2 - 2017-06-14
-------------------
-
-* Added ``FMT_VERSION`` macro
-  (`#411 <https://github.com/fmtlib/fmt/issues/411>`_).
-
-* Used ``FMT_NULL`` instead of literal ``0``
-  (`#409 <https://github.com/fmtlib/fmt/pull/409>`_).
-  Thanks `@alabuzhev (Alex Alabuzhev) <https://github.com/alabuzhev>`_.
-
-* Added extern templates for ``format_float``
-  (`#413 <https://github.com/fmtlib/fmt/issues/413>`_).
-
-* Fixed implicit conversion issue
-  (`#507 <https://github.com/fmtlib/fmt/issues/507>`_).
-
-* Fixed signbit detection (`#423 <https://github.com/fmtlib/fmt/issues/423>`_).
-
-* Fixed naming collision (`#425 <https://github.com/fmtlib/fmt/issues/425>`_).
-
-* Fixed missing intrinsic for C++/CLI
-  (`#457 <https://github.com/fmtlib/fmt/pull/457>`_).
-  Thanks `@calumr (Calum Robinson) <https://github.com/calumr>`_
-
-* Fixed Android detection (`#458 <https://github.com/fmtlib/fmt/pull/458>`_).
-  Thanks `@Gachapen (Magnus Bjerke Vik) <https://github.com/Gachapen>`_.
-
-* Use lean ``windows.h`` if not in header-only mode
-  (`#503 <https://github.com/fmtlib/fmt/pull/503>`_).
-  Thanks `@Quentin01 (Quentin Buathier) <https://github.com/Quentin01>`_.
-
-* Fixed issue with CMake exporting C++11 flag
-  (`#445 <https://github.com/fmtlib/fmt/pull/455>`_).
-  Thanks `@EricWF (Eric) <https://github.com/EricWF>`_.
-
-* Fixed issue with nvcc and MSVC compiler bug and MinGW
-  (`#505 <https://github.com/fmtlib/fmt/issues/505>`_).
-
-* Fixed DLL issues (`#469 <https://github.com/fmtlib/fmt/pull/469>`_ and
-  `#502 <https://github.com/fmtlib/fmt/pull/502>`_).
-  Thanks `@richardeakin (Richard Eakin) <https://github.com/richardeakin>`_ and
-  `@AndreasSchoenle (Andreas Schönle) <https://github.com/AndreasSchoenle>`_.
-
-* Fixed test compilation under FreeBSD
-  (`#433 <https://github.com/fmtlib/fmt/issues/433>`_).
-
-* Fixed various warnings (`#403 <https://github.com/fmtlib/fmt/pull/403>`_,
-  `#410 <https://github.com/fmtlib/fmt/pull/410>`_ and
-  `#510 <https://github.com/fmtlib/fmt/pull/510>`_).
-  Thanks `@Lecetem <https://github.com/Lectem>`_,
-  `@chenhayat (Chen Hayat) <https://github.com/chenhayat>`_ and
-  `@trozen <https://github.com/trozen>`_.
-
-* Worked around a broken ``__builtin_clz`` in clang with MS codegen
-  (`#519 <https://github.com/fmtlib/fmt/issues/519>`_).
-
-* Removed redundant include
-  (`#479 <https://github.com/fmtlib/fmt/issues/479>`_).
-
-* Fixed documentation issues.
-
-3.0.1 - 2016-11-01
-------------------
-* Fixed handling of thousands separator
-  (`#353 <https://github.com/fmtlib/fmt/issues/353>`_).
-
-* Fixed handling of ``unsigned char`` strings
-  (`#373 <https://github.com/fmtlib/fmt/issues/373>`_).
-
-* Corrected buffer growth when formatting time
-  (`#367 <https://github.com/fmtlib/fmt/issues/367>`_).
-
-* Removed warnings under MSVC and clang
-  (`#318 <https://github.com/fmtlib/fmt/issues/318>`_,
-  `#250 <https://github.com/fmtlib/fmt/issues/250>`_, also merged
-  `#385 <https://github.com/fmtlib/fmt/pull/385>`_ and
-  `#361 <https://github.com/fmtlib/fmt/pull/361>`_).
-  Thanks `@jcelerier (Jean-Michaël Celerier) <https://github.com/jcelerier>`_
-  and `@nmoehrle (Nils Moehrle) <https://github.com/nmoehrle>`_.
-
-* Fixed compilation issues under Android
-  (`#327 <https://github.com/fmtlib/fmt/pull/327>`_,
-  `#345 <https://github.com/fmtlib/fmt/issues/345>`_ and
-  `#381 <https://github.com/fmtlib/fmt/pull/381>`_),
-  FreeBSD (`#358 <https://github.com/fmtlib/fmt/pull/358>`_),
-  Cygwin (`#388 <https://github.com/fmtlib/fmt/issues/388>`_),
-  MinGW (`#355 <https://github.com/fmtlib/fmt/issues/355>`_) as well as other
-  issues (`#350 <https://github.com/fmtlib/fmt/issues/350>`_,
-  `#366 <https://github.com/fmtlib/fmt/issues/355>`_,
-  `#348 <https://github.com/fmtlib/fmt/pull/348>`_,
-  `#402 <https://github.com/fmtlib/fmt/pull/402>`_,
-  `#405 <https://github.com/fmtlib/fmt/pull/405>`_).
-  Thanks to `@dpantele (Dmitry) <https://github.com/dpantele>`_,
-  `@hghwng (Hugh Wang) <https://github.com/hghwng>`_,
-  `@arvedarved (Tilman Keskinöz) <https://github.com/arvedarved>`_,
-  `@LogicalKnight (Sean) <https://github.com/LogicalKnight>`_ and
-  `@JanHellwig (Jan Hellwig) <https://github.com/janhellwig>`_.
-
-* Fixed some documentation issues and extended specification
-  (`#320 <https://github.com/fmtlib/fmt/issues/320>`_,
-  `#333 <https://github.com/fmtlib/fmt/pull/333>`_,
-  `#347 <https://github.com/fmtlib/fmt/issues/347>`_,
-  `#362 <https://github.com/fmtlib/fmt/pull/362>`_).
-  Thanks to `@smellman (Taro Matsuzawa aka. btm)
-  <https://github.com/smellman>`_.
-
-3.0.0 - 2016-05-07
-------------------
-
-* The project has been renamed from C++ Format (cppformat) to fmt for
-  consistency with the used namespace and macro prefix
-  (`#307 <https://github.com/fmtlib/fmt/issues/307>`_).
-  Library headers are now located in the ``fmt`` directory:
-
-  .. code:: c++
-
-    #include "fmt/format.h"
-
-  Including ``format.h`` from the ``cppformat`` directory is deprecated
-  but works via a proxy header which will be removed in the next major version.
-  
-  The documentation is now available at https://fmt.dev.
-
-* Added support for `strftime <http://en.cppreference.com/w/cpp/chrono/c/strftime>`_-like
-  `date and time formatting <https://fmt.dev/3.0.0/api.html#date-and-time-formatting>`_
-  (`#283 <https://github.com/fmtlib/fmt/issues/283>`_):
-
-  .. code:: c++
-
-    #include "fmt/time.h"
-
-    std::time_t t = std::time(nullptr);
-    // Prints "The date is 2016-04-29." (with the current date)
-    fmt::print("The date is {:%Y-%m-%d}.", *std::localtime(&t));
-
-* ``std::ostream`` support including formatting of user-defined types that provide
-  overloaded ``operator<<`` has been moved to ``fmt/ostream.h``:
-
-  .. code:: c++
-
-    #include "fmt/ostream.h"
-
-    class Date {
-      int year_, month_, day_;
-    public:
-      Date(int year, int month, int day) : year_(year), month_(month), day_(day) {}
-
-      friend std::ostream &operator<<(std::ostream &os, const Date &d) {
-        return os << d.year_ << '-' << d.month_ << '-' << d.day_;
-      }
-    };
-
-    std::string s = fmt::format("The date is {}", Date(2012, 12, 9));
-    // s == "The date is 2012-12-9"
-
-* Added support for `custom argument formatters
-  <https://fmt.dev/3.0.0/api.html#argument-formatters>`_
-  (`#235 <https://github.com/fmtlib/fmt/issues/235>`_).
-
-* Added support for locale-specific integer formatting with the ``n`` specifier
-  (`#305 <https://github.com/fmtlib/fmt/issues/305>`_):
-
-  .. code:: c++
-
-    std::setlocale(LC_ALL, "en_US.utf8");
-    fmt::print("cppformat: {:n}\n", 1234567); // prints 1,234,567
-
-* Sign is now preserved when formatting an integer with an incorrect ``printf``
-  format specifier (`#265 <https://github.com/fmtlib/fmt/issues/265>`_):
-
-  .. code:: c++
-
-    fmt::printf("%lld", -42); // prints -42
-
-  Note that it would be an undefined behavior in ``std::printf``.
-
-* Length modifiers such as ``ll`` are now optional in printf formatting
-  functions and the correct type is determined automatically
-  (`#255 <https://github.com/fmtlib/fmt/issues/255>`_):
-
-  .. code:: c++
-
-    fmt::printf("%d", std::numeric_limits<long long>::max());
-
-  Note that it would be an undefined behavior in ``std::printf``.
-
-* Added initial support for custom formatters
-  (`#231 <https://github.com/fmtlib/fmt/issues/231>`_).
-
-* Fixed detection of user-defined literal support on Intel C++ compiler
-  (`#311 <https://github.com/fmtlib/fmt/issues/311>`_,
-  `#312 <https://github.com/fmtlib/fmt/pull/312>`_).
-  Thanks to `@dean0x7d (Dean Moldovan) <https://github.com/dean0x7d>`_ and
-  `@speth (Ray Speth) <https://github.com/speth>`_.
-
-* Reduced compile time
-  (`#243 <https://github.com/fmtlib/fmt/pull/243>`_,
-  `#249 <https://github.com/fmtlib/fmt/pull/249>`_,
-  `#317 <https://github.com/fmtlib/fmt/issues/317>`_):
-
-  .. image:: https://cloud.githubusercontent.com/assets/4831417/11614060/
-             b9e826d2-9c36-11e5-8666-d4131bf503ef.png
-
-  .. image:: https://cloud.githubusercontent.com/assets/4831417/11614080/
-             6ac903cc-9c37-11e5-8165-26df6efae364.png
-
-  Thanks to `@dean0x7d (Dean Moldovan) <https://github.com/dean0x7d>`_.
-
-* Compile test fixes (`#313 <https://github.com/fmtlib/fmt/pull/313>`_).
-  Thanks to `@dean0x7d (Dean Moldovan) <https://github.com/dean0x7d>`_.
-
-* Documentation fixes (`#239 <https://github.com/fmtlib/fmt/pull/239>`_,
-  `#248 <https://github.com/fmtlib/fmt/issues/248>`_,
-  `#252 <https://github.com/fmtlib/fmt/issues/252>`_,
-  `#258 <https://github.com/fmtlib/fmt/pull/258>`_,
-  `#260 <https://github.com/fmtlib/fmt/issues/260>`_,
-  `#301 <https://github.com/fmtlib/fmt/issues/301>`_,
-  `#309 <https://github.com/fmtlib/fmt/pull/309>`_).
-  Thanks to `@ReadmeCritic <https://github.com/ReadmeCritic>`_
-  `@Gachapen (Magnus Bjerke Vik) <https://github.com/Gachapen>`_ and
-  `@jwilk (Jakub Wilk) <https://github.com/jwilk>`_.
-
-* Fixed compiler and sanitizer warnings
-  (`#244 <https://github.com/fmtlib/fmt/issues/244>`_,
-  `#256 <https://github.com/fmtlib/fmt/pull/256>`_,
-  `#259 <https://github.com/fmtlib/fmt/pull/259>`_,
-  `#263 <https://github.com/fmtlib/fmt/issues/263>`_,
-  `#274 <https://github.com/fmtlib/fmt/issues/274>`_,
-  `#277 <https://github.com/fmtlib/fmt/pull/277>`_,
-  `#286 <https://github.com/fmtlib/fmt/pull/286>`_,
-  `#291 <https://github.com/fmtlib/fmt/issues/291>`_,
-  `#296 <https://github.com/fmtlib/fmt/issues/296>`_,
-  `#308 <https://github.com/fmtlib/fmt/issues/308>`_)
-  Thanks to `@mwinterb <https://github.com/mwinterb>`_,
-  `@pweiskircher (Patrik Weiskircher) <https://github.com/pweiskircher>`_,
-  `@Naios <https://github.com/Naios>`_.
-
-* Improved compatibility with Windows Store apps
-  (`#280 <https://github.com/fmtlib/fmt/issues/280>`_,
-  `#285 <https://github.com/fmtlib/fmt/pull/285>`_)
-  Thanks to `@mwinterb <https://github.com/mwinterb>`_.
-
-* Added tests of compatibility with older C++ standards
-  (`#273 <https://github.com/fmtlib/fmt/pull/273>`_).
-  Thanks to `@niosHD <https://github.com/niosHD>`_.
-
-* Fixed Android build (`#271 <https://github.com/fmtlib/fmt/pull/271>`_).
-  Thanks to `@newnon <https://github.com/newnon>`_.
-
-* Changed ``ArgMap`` to be backed by a vector instead of a map.
-  (`#261 <https://github.com/fmtlib/fmt/issues/261>`_,
-  `#262 <https://github.com/fmtlib/fmt/pull/262>`_).
-  Thanks to `@mwinterb <https://github.com/mwinterb>`_.
-
-* Added ``fprintf`` overload that writes to a ``std::ostream``
-  (`#251 <https://github.com/fmtlib/fmt/pull/251>`_).
-  Thanks to `nickhutchinson (Nicholas Hutchinson) <https://github.com/nickhutchinson>`_.
-
-* Export symbols when building a Windows DLL
-  (`#245 <https://github.com/fmtlib/fmt/pull/245>`_).
-  Thanks to `macdems (Maciek Dems) <https://github.com/macdems>`_.
-
-* Fixed compilation on Cygwin (`#304 <https://github.com/fmtlib/fmt/issues/304>`_).
-
-* Implemented a workaround for a bug in Apple LLVM version 4.2 of clang
-  (`#276 <https://github.com/fmtlib/fmt/issues/276>`_).
-
-* Implemented a workaround for Google Test bug
-  `#705 <https://github.com/google/googletest/issues/705>`_ on gcc 6
-  (`#268 <https://github.com/fmtlib/fmt/issues/268>`_).
-  Thanks to `octoploid <https://github.com/octoploid>`_.
-
-* Removed Biicode support because the latter has been discontinued.
-
-2.1.1 - 2016-04-11
-------------------
-
-* The install location for generated CMake files is now configurable via
-  the ``FMT_CMAKE_DIR`` CMake variable
-  (`#299 <https://github.com/fmtlib/fmt/pull/299>`_).
-  Thanks to `@niosHD <https://github.com/niosHD>`_.
-
-* Documentation fixes (`#252 <https://github.com/fmtlib/fmt/issues/252>`_).
-
-2.1.0 - 2016-03-21
-------------------
-
-* Project layout and build system improvements
-  (`#267 <https://github.com/fmtlib/fmt/pull/267>`_):
-
-  * The code have been moved to the ``cppformat`` directory.
-    Including ``format.h`` from the top-level directory is deprecated
-    but works via a proxy header which will be removed in the next
-    major version.
-
-  * C++ Format CMake targets now have proper interface definitions.
-
-  * Installed version of the library now supports the header-only
-    configuration.
-
-  * Targets ``doc``, ``install``, and ``test`` are now disabled if C++ Format
-    is included as a CMake subproject. They can be enabled by setting
-    ``FMT_DOC``, ``FMT_INSTALL``, and ``FMT_TEST`` in the parent project.
-
-  Thanks to `@niosHD <https://github.com/niosHD>`_.
-
-2.0.1 - 2016-03-13
-------------------
-
-* Improved CMake find and package support
-  (`#264 <https://github.com/fmtlib/fmt/issues/264>`_).
-  Thanks to `@niosHD <https://github.com/niosHD>`_.
-
-* Fix compile error with Android NDK and mingw32
-  (`#241 <https://github.com/fmtlib/fmt/issues/241>`_).
-  Thanks to `@Gachapen (Magnus Bjerke Vik) <https://github.com/Gachapen>`_.
-
-* Documentation fixes
-  (`#248 <https://github.com/fmtlib/fmt/issues/248>`_,
-  `#260 <https://github.com/fmtlib/fmt/issues/260>`_).
-
-2.0.0 - 2015-12-01
-------------------
-
-General
-~~~~~~~
-
-* [Breaking] Named arguments
-  (`#169 <https://github.com/fmtlib/fmt/pull/169>`_,
-  `#173 <https://github.com/fmtlib/fmt/pull/173>`_,
-  `#174 <https://github.com/fmtlib/fmt/pull/174>`_):
-
-  .. code:: c++
-
-    fmt::print("The answer is {answer}.", fmt::arg("answer", 42));
-
-  Thanks to `@jamboree <https://github.com/jamboree>`_.
-
-* [Experimental] User-defined literals for format and named arguments
-  (`#204 <https://github.com/fmtlib/fmt/pull/204>`_,
-  `#206 <https://github.com/fmtlib/fmt/pull/206>`_,
-  `#207 <https://github.com/fmtlib/fmt/pull/207>`_):
-
-  .. code:: c++
-
-    using namespace fmt::literals;
-    fmt::print("The answer is {answer}.", "answer"_a=42);
-
-  Thanks to `@dean0x7d (Dean Moldovan) <https://github.com/dean0x7d>`_.
-
-* [Breaking] Formatting of more than 16 arguments is now supported when using
-  variadic templates
-  (`#141 <https://github.com/fmtlib/fmt/issues/141>`_).
-  Thanks to `@Shauren <https://github.com/Shauren>`_.
-
-* Runtime width specification
-  (`#168 <https://github.com/fmtlib/fmt/pull/168>`_):
-
-  .. code:: c++
-
-    fmt::format("{0:{1}}", 42, 5); // gives "   42"
-
-  Thanks to `@jamboree <https://github.com/jamboree>`_.
-
-* [Breaking] Enums are now formatted with an overloaded ``std::ostream`` insertion
-  operator (``operator<<``) if available
-  (`#232 <https://github.com/fmtlib/fmt/issues/232>`_).
-
-* [Breaking] Changed default ``bool`` format to textual, "true" or "false"
-  (`#170 <https://github.com/fmtlib/fmt/issues/170>`_):
-
-  .. code:: c++
-  
-    fmt::print("{}", true); // prints "true"
-
-  To print ``bool`` as a number use numeric format specifier such as ``d``:
-
-  .. code:: c++
-
-    fmt::print("{:d}", true); // prints "1"
-
-* ``fmt::printf`` and ``fmt::sprintf`` now support formatting of ``bool`` with the
-  ``%s`` specifier giving textual output, "true" or "false"
-  (`#223 <https://github.com/fmtlib/fmt/pull/223>`_):
-
-  .. code:: c++
-
-    fmt::printf("%s", true); // prints "true"
-
-  Thanks to `@LarsGullik <https://github.com/LarsGullik>`_.
-
-* [Breaking] ``signed char`` and ``unsigned char`` are now formatted as integers by default
-  (`#217 <https://github.com/fmtlib/fmt/pull/217>`_).
-
-* [Breaking] Pointers to C strings can now be formatted with the ``p`` specifier
-  (`#223 <https://github.com/fmtlib/fmt/pull/223>`_):
-
-  .. code:: c++
-
-    fmt::print("{:p}", "test"); // prints pointer value
-
-  Thanks to `@LarsGullik <https://github.com/LarsGullik>`_.
-
-* [Breaking] ``fmt::printf`` and ``fmt::sprintf`` now print null pointers as ``(nil)``
-  and null strings as ``(null)`` for consistency with glibc
-  (`#226 <https://github.com/fmtlib/fmt/pull/226>`_).
-  Thanks to `@LarsGullik <https://github.com/LarsGullik>`_.
-
-* [Breaking] ``fmt::(s)printf`` now supports formatting of objects of user-defined types
-  that provide an overloaded ``std::ostream`` insertion operator (``operator<<``)
-  (`#201 <https://github.com/fmtlib/fmt/issues/201>`_):
-
-  .. code:: c++
-
-    fmt::printf("The date is %s", Date(2012, 12, 9));
-
-* [Breaking] The ``Buffer`` template is now part of the public API and can be used
-  to implement custom memory buffers
-  (`#140 <https://github.com/fmtlib/fmt/issues/140>`_).
-  Thanks to `@polyvertex (Jean-Charles Lefebvre) <https://github.com/polyvertex>`_.
-
-* [Breaking] Improved compatibility between ``BasicStringRef`` and
-  `std::experimental::basic_string_view
-  <http://en.cppreference.com/w/cpp/experimental/basic_string_view>`_
-  (`#100 <https://github.com/fmtlib/fmt/issues/100>`_,
-  `#159 <https://github.com/fmtlib/fmt/issues/159>`_,
-  `#183 <https://github.com/fmtlib/fmt/issues/183>`_):
-
-  - Comparison operators now compare string content, not pointers
-  - ``BasicStringRef::c_str`` replaced by ``BasicStringRef::data``
-  - ``BasicStringRef`` is no longer assumed to be null-terminated
-
-  References to null-terminated strings are now represented by a new class,
-  ``BasicCStringRef``.
-
-* Dependency on pthreads introduced by Google Test is now optional
-  (`#185 <https://github.com/fmtlib/fmt/issues/185>`_).
-
-* New CMake options ``FMT_DOC``, ``FMT_INSTALL`` and ``FMT_TEST`` to control
-  generation of ``doc``, ``install`` and ``test`` targets respectively, on by default
-  (`#197 <https://github.com/fmtlib/fmt/issues/197>`_,
-  `#198 <https://github.com/fmtlib/fmt/issues/198>`_,
-  `#200 <https://github.com/fmtlib/fmt/issues/200>`_).
-  Thanks to `@maddinat0r (Alex Martin) <https://github.com/maddinat0r>`_.
-
-* ``noexcept`` is now used when compiling with MSVC2015
-  (`#215 <https://github.com/fmtlib/fmt/pull/215>`_).
-  Thanks to `@dmkrepo (Dmitriy) <https://github.com/dmkrepo>`_.
-
-* Added an option to disable use of ``windows.h`` when ``FMT_USE_WINDOWS_H``
-  is defined as 0 before including ``format.h``
-  (`#171 <https://github.com/fmtlib/fmt/issues/171>`_).
-  Thanks to `@alfps (Alf P. Steinbach) <https://github.com/alfps>`_.
-
-* [Breaking] ``windows.h`` is now included with ``NOMINMAX`` unless
-  ``FMT_WIN_MINMAX`` is defined. This is done to prevent breaking code using
-  ``std::min`` and ``std::max`` and only affects the header-only configuration
-  (`#152 <https://github.com/fmtlib/fmt/issues/152>`_,
-  `#153 <https://github.com/fmtlib/fmt/pull/153>`_,
-  `#154 <https://github.com/fmtlib/fmt/pull/154>`_).
-  Thanks to `@DevO2012 <https://github.com/DevO2012>`_.
-
-* Improved support for custom character types
-  (`#171 <https://github.com/fmtlib/fmt/issues/171>`_).
-  Thanks to `@alfps (Alf P. Steinbach) <https://github.com/alfps>`_.
-
-* Added an option to disable use of IOStreams when ``FMT_USE_IOSTREAMS``
-  is defined as 0 before including ``format.h``
-  (`#205 <https://github.com/fmtlib/fmt/issues/205>`_,
-  `#208 <https://github.com/fmtlib/fmt/pull/208>`_).
-  Thanks to `@JodiTheTigger <https://github.com/JodiTheTigger>`_.
-
-* Improved detection of ``isnan``, ``isinf`` and ``signbit``.
-
-Optimization
-~~~~~~~~~~~~
-
-* Made formatting of user-defined types more efficient with a custom stream buffer
-  (`#92 <https://github.com/fmtlib/fmt/issues/92>`_,
-  `#230 <https://github.com/fmtlib/fmt/pull/230>`_).
-  Thanks to `@NotImplemented <https://github.com/NotImplemented>`_.
-
-* Further improved performance of ``fmt::Writer`` on integer formatting
-  and fixed a minor regression. Now it is ~7% faster than ``karma::generate``
-  on Karma's benchmark
-  (`#186 <https://github.com/fmtlib/fmt/issues/186>`_).
-
-* [Breaking] Reduced `compiled code size
-  <https://github.com/fmtlib/fmt#compile-time-and-code-bloat>`_
-  (`#143 <https://github.com/fmtlib/fmt/issues/143>`_,
-  `#149 <https://github.com/fmtlib/fmt/pull/149>`_).
-
-Distribution
-~~~~~~~~~~~~
-
-* [Breaking] Headers are now installed in
-  ``${CMAKE_INSTALL_PREFIX}/include/cppformat``
-  (`#178 <https://github.com/fmtlib/fmt/issues/178>`_).
-  Thanks to `@jackyf (Eugene V. Lyubimkin) <https://github.com/jackyf>`_.
-
-* [Breaking] Changed the library name from ``format`` to ``cppformat``
-  for consistency with the project name and to avoid potential conflicts
-  (`#178 <https://github.com/fmtlib/fmt/issues/178>`_).
-  Thanks to `@jackyf (Eugene V. Lyubimkin) <https://github.com/jackyf>`_.
-
-* C++ Format is now available in `Debian <https://www.debian.org/>`_ GNU/Linux
-  (`stretch <https://packages.debian.org/source/stretch/cppformat>`_,
-  `sid <https://packages.debian.org/source/sid/cppformat>`_) and 
-  derived distributions such as
-  `Ubuntu <https://launchpad.net/ubuntu/+source/cppformat>`_ 15.10 and later
-  (`#155 <https://github.com/fmtlib/fmt/issues/155>`_)::
-
-    $ sudo apt-get install libcppformat1-dev
-
-  Thanks to `@jackyf (Eugene V. Lyubimkin) <https://github.com/jackyf>`_.
-
-* `Packages for Fedora and RHEL <https://admin.fedoraproject.org/pkgdb/package/cppformat/>`_
-  are now available. Thanks to Dave Johansen.
-  
-* C++ Format can now be installed via `Homebrew <http://brew.sh/>`_ on OS X
-  (`#157 <https://github.com/fmtlib/fmt/issues/157>`_)::
-
-    $ brew install cppformat
-
-  Thanks to `@ortho <https://github.com/ortho>`_, Anatoliy Bulukin.
-
-Documentation
-~~~~~~~~~~~~~
-
-* Migrated from ReadTheDocs to GitHub Pages for better responsiveness
-  and reliability
-  (`#128 <https://github.com/fmtlib/fmt/issues/128>`_).
-  New documentation address is http://cppformat.github.io/.
-
-
-* Added `Building the documentation
-  <https://fmt.dev/2.0.0/usage.html#building-the-documentation>`_
-  section to the documentation.
-
-* Documentation build script is now compatible with Python 3 and newer pip versions.
-  (`#189 <https://github.com/fmtlib/fmt/pull/189>`_,
-  `#209 <https://github.com/fmtlib/fmt/issues/209>`_).
-  Thanks to `@JodiTheTigger <https://github.com/JodiTheTigger>`_ and
-  `@xentec <https://github.com/xentec>`_.
-  
-* Documentation fixes and improvements
-  (`#36 <https://github.com/fmtlib/fmt/issues/36>`_,
-  `#75 <https://github.com/fmtlib/fmt/issues/75>`_,
-  `#125 <https://github.com/fmtlib/fmt/issues/125>`_,
-  `#160 <https://github.com/fmtlib/fmt/pull/160>`_,
-  `#161 <https://github.com/fmtlib/fmt/pull/161>`_,
-  `#162 <https://github.com/fmtlib/fmt/issues/162>`_,
-  `#165 <https://github.com/fmtlib/fmt/issues/165>`_,
-  `#210 <https://github.com/fmtlib/fmt/issues/210>`_).
-  Thanks to `@syohex (Syohei YOSHIDA) <https://github.com/syohex>`_ and
-  bug reporters.
-
-* Fixed out-of-tree documentation build
-  (`#177 <https://github.com/fmtlib/fmt/issues/177>`_).
-  Thanks to `@jackyf (Eugene V. Lyubimkin) <https://github.com/jackyf>`_.
-
-Fixes
-~~~~~
-
-* Fixed ``initializer_list`` detection
-  (`#136 <https://github.com/fmtlib/fmt/issues/136>`_).
-  Thanks to `@Gachapen (Magnus Bjerke Vik) <https://github.com/Gachapen>`_.
-
-* [Breaking] Fixed formatting of enums with numeric format specifiers in
-  ``fmt::(s)printf`` 
-  (`#131 <https://github.com/fmtlib/fmt/issues/131>`_,
-  `#139 <https://github.com/fmtlib/fmt/issues/139>`_):
-
-  .. code:: c++
-
-    enum { ANSWER = 42 };
-    fmt::printf("%d", ANSWER);
-
-  Thanks to `@Naios <https://github.com/Naios>`_.
-
-* Improved compatibility with old versions of MinGW
-  (`#129 <https://github.com/fmtlib/fmt/issues/129>`_,
-  `#130 <https://github.com/fmtlib/fmt/pull/130>`_,
-  `#132 <https://github.com/fmtlib/fmt/issues/132>`_).
-  Thanks to `@cstamford (Christopher Stamford) <https://github.com/cstamford>`_.
-
-* Fixed a compile error on MSVC with disabled exceptions
-  (`#144 <https://github.com/fmtlib/fmt/issues/144>`_).
-
-* Added a workaround for broken implementation of variadic templates in MSVC2012
-  (`#148 <https://github.com/fmtlib/fmt/issues/148>`_).
-
-* Placed the anonymous namespace within ``fmt`` namespace for the header-only
-  configuration
-  (`#171 <https://github.com/fmtlib/fmt/issues/171>`_).
-  Thanks to `@alfps (Alf P. Steinbach) <https://github.com/alfps>`_.
-
-* Fixed issues reported by Coverity Scan
-  (`#187 <https://github.com/fmtlib/fmt/issues/187>`_,
-  `#192 <https://github.com/fmtlib/fmt/issues/192>`_).
-
-* Implemented a workaround for a name lookup bug in MSVC2010
-  (`#188 <https://github.com/fmtlib/fmt/issues/188>`_).
-
-* Fixed compiler warnings
-  (`#95 <https://github.com/fmtlib/fmt/issues/95>`_,
-  `#96 <https://github.com/fmtlib/fmt/issues/96>`_,
-  `#114 <https://github.com/fmtlib/fmt/pull/114>`_,
-  `#135 <https://github.com/fmtlib/fmt/issues/135>`_,
-  `#142 <https://github.com/fmtlib/fmt/issues/142>`_,
-  `#145 <https://github.com/fmtlib/fmt/issues/145>`_,
-  `#146 <https://github.com/fmtlib/fmt/issues/146>`_,
-  `#158 <https://github.com/fmtlib/fmt/issues/158>`_,
-  `#163 <https://github.com/fmtlib/fmt/issues/163>`_,
-  `#175 <https://github.com/fmtlib/fmt/issues/175>`_,
-  `#190 <https://github.com/fmtlib/fmt/issues/190>`_,
-  `#191 <https://github.com/fmtlib/fmt/pull/191>`_,
-  `#194 <https://github.com/fmtlib/fmt/issues/194>`_,
-  `#196 <https://github.com/fmtlib/fmt/pull/196>`_,
-  `#216 <https://github.com/fmtlib/fmt/issues/216>`_,
-  `#218 <https://github.com/fmtlib/fmt/pull/218>`_,
-  `#220 <https://github.com/fmtlib/fmt/pull/220>`_,
-  `#229 <https://github.com/fmtlib/fmt/pull/229>`_,
-  `#233 <https://github.com/fmtlib/fmt/issues/233>`_,
-  `#234 <https://github.com/fmtlib/fmt/issues/234>`_,
-  `#236 <https://github.com/fmtlib/fmt/pull/236>`_,
-  `#281 <https://github.com/fmtlib/fmt/issues/281>`_,
-  `#289 <https://github.com/fmtlib/fmt/issues/289>`_).
-  Thanks to `@seanmiddleditch (Sean Middleditch) <https://github.com/seanmiddleditch>`_,
-  `@dixlorenz (Dix Lorenz) <https://github.com/dixlorenz>`_,
-  `@CarterLi (李通洲) <https://github.com/CarterLi>`_,
-  `@Naios <https://github.com/Naios>`_,
-  `@fmatthew5876 (Matthew Fioravante) <https://github.com/fmatthew5876>`_,
-  `@LevskiWeng (Levski Weng) <https://github.com/LevskiWeng>`_,
-  `@rpopescu <https://github.com/rpopescu>`_,
-  `@gabime (Gabi Melman) <https://github.com/gabime>`_,
-  `@cubicool (Jeremy Moles) <https://github.com/cubicool>`_,
-  `@jkflying (Julian Kent) <https://github.com/jkflying>`_,
-  `@LogicalKnight (Sean L) <https://github.com/LogicalKnight>`_,
-  `@inguin (Ingo van Lil) <https://github.com/inguin>`_ and
-  `@Jopie64 (Johan) <https://github.com/Jopie64>`_.
-
-* Fixed portability issues (mostly causing test failures) on ARM, ppc64, ppc64le,
-  s390x and SunOS 5.11 i386
-  (`#138 <https://github.com/fmtlib/fmt/issues/138>`_,
-  `#179 <https://github.com/fmtlib/fmt/issues/179>`_,
-  `#180 <https://github.com/fmtlib/fmt/issues/180>`_,
-  `#202 <https://github.com/fmtlib/fmt/issues/202>`_,
-  `#225 <https://github.com/fmtlib/fmt/issues/225>`_,
-  `Red Hat Bugzilla Bug 1260297 <https://bugzilla.redhat.com/show_bug.cgi?id=1260297>`_).
-  Thanks to `@Naios <https://github.com/Naios>`_,
-  `@jackyf (Eugene V. Lyubimkin) <https://github.com/jackyf>`_ and Dave Johansen.
-
-* Fixed a name conflict with macro ``free`` defined in
-  ``crtdbg.h`` when ``_CRTDBG_MAP_ALLOC`` is set
-  (`#211 <https://github.com/fmtlib/fmt/issues/211>`_).
-
-* Fixed shared library build on OS X
-  (`#212 <https://github.com/fmtlib/fmt/pull/212>`_).
-  Thanks to `@dean0x7d (Dean Moldovan) <https://github.com/dean0x7d>`_.
-
-* Fixed an overload conflict on MSVC when ``/Zc:wchar_t-`` option is specified
-  (`#214 <https://github.com/fmtlib/fmt/pull/214>`_).
-  Thanks to `@slavanap (Vyacheslav Napadovsky) <https://github.com/slavanap>`_.
-
-* Improved compatibility with MSVC 2008
-  (`#236 <https://github.com/fmtlib/fmt/pull/236>`_).
-  Thanks to `@Jopie64 (Johan) <https://github.com/Jopie64>`_.
-
-* Improved compatibility with bcc32
-  (`#227 <https://github.com/fmtlib/fmt/issues/227>`_).
-
-* Fixed ``static_assert`` detection on Clang
-  (`#228 <https://github.com/fmtlib/fmt/pull/228>`_).
-  Thanks to `@dean0x7d (Dean Moldovan) <https://github.com/dean0x7d>`_.
-
-1.1.0 - 2015-03-06
-------------------
-
-* Added ``BasicArrayWriter``, a class template that provides operations for
-  formatting and writing data into a fixed-size array
-  (`#105 <https://github.com/fmtlib/fmt/issues/105>`_ and
-  `#122 <https://github.com/fmtlib/fmt/issues/122>`_):
-
-  .. code:: c++
-  
-    char buffer[100];
-    fmt::ArrayWriter w(buffer);
-    w.write("The answer is {}", 42);
-
-* Added `0 A.D. <http://play0ad.com/>`_ and `PenUltima Online (POL)
-  <http://www.polserver.com/>`_ to the list of notable projects using C++ Format.
-
-* C++ Format now uses MSVC intrinsics for better formatting performance
-  (`#115 <https://github.com/fmtlib/fmt/pull/115>`_,
-  `#116 <https://github.com/fmtlib/fmt/pull/116>`_,
-  `#118 <https://github.com/fmtlib/fmt/pull/118>`_ and
-  `#121 <https://github.com/fmtlib/fmt/pull/121>`_).
-  Previously these optimizations where only used on GCC and Clang.
-  Thanks to `@CarterLi <https://github.com/CarterLi>`_ and
-  `@objectx <https://github.com/objectx>`_.
-
-* CMake install target (`#119 <https://github.com/fmtlib/fmt/pull/119>`_).
-  Thanks to `@TrentHouliston <https://github.com/TrentHouliston>`_.
-
-  You can now install C++ Format with ``make install`` command.
-
-* Improved `Biicode <http://www.biicode.com/>`_ support
-  (`#98 <https://github.com/fmtlib/fmt/pull/98>`_ and
-  `#104 <https://github.com/fmtlib/fmt/pull/104>`_). Thanks to
-  `@MariadeAnton <https://github.com/MariadeAnton>`_ and
-  `@franramirez688 <https://github.com/franramirez688>`_.
-
-* Improved support for building with `Android NDK
-  <https://developer.android.com/tools/sdk/ndk/index.html>`_
-  (`#107 <https://github.com/fmtlib/fmt/pull/107>`_).
-  Thanks to `@newnon <https://github.com/newnon>`_.
-  
-  The `android-ndk-example <https://github.com/fmtlib/android-ndk-example>`_
-  repository provides and example of using C++ Format with Android NDK:
-
-  .. image:: https://raw.githubusercontent.com/fmtlib/android-ndk-example/
-            master/screenshot.png
-
-* Improved documentation of ``SystemError`` and ``WindowsError``
-  (`#54 <https://github.com/fmtlib/fmt/issues/54>`_).
-
-* Various code improvements
-  (`#110 <https://github.com/fmtlib/fmt/pull/110>`_,
-  `#111 <https://github.com/fmtlib/fmt/pull/111>`_
-  `#112 <https://github.com/fmtlib/fmt/pull/112>`_).
-  Thanks to `@CarterLi <https://github.com/CarterLi>`_.
-
-* Improved compile-time errors when formatting wide into narrow strings
-  (`#117 <https://github.com/fmtlib/fmt/issues/117>`_).
-
-* Fixed ``BasicWriter::write`` without formatting arguments when C++11 support
-  is disabled (`#109 <https://github.com/fmtlib/fmt/issues/109>`_).
-
-* Fixed header-only build on OS X with GCC 4.9
-  (`#124 <https://github.com/fmtlib/fmt/issues/124>`_).
-
-* Fixed packaging issues (`#94 <https://github.com/fmtlib/fmt/issues/94>`_).
-
-* Added `changelog <https://github.com/fmtlib/fmt/blob/master/ChangeLog.rst>`_
-  (`#103 <https://github.com/fmtlib/fmt/issues/103>`_).
-
-1.0.0 - 2015-02-05
-------------------
-
-* Add support for a header-only configuration when ``FMT_HEADER_ONLY`` is
-  defined before including ``format.h``:
-
-  .. code:: c++
-
-    #define FMT_HEADER_ONLY
-    #include "format.h"
-
-* Compute string length in the constructor of ``BasicStringRef``
-  instead of the ``size`` method
-  (`#79 <https://github.com/fmtlib/fmt/issues/79>`_).
-  This eliminates size computation for string literals on reasonable optimizing
-  compilers.
-
-* Fix formatting of types with overloaded ``operator <<`` for ``std::wostream``
-  (`#86 <https://github.com/fmtlib/fmt/issues/86>`_):
-
-  .. code:: c++
-
-    fmt::format(L"The date is {0}", Date(2012, 12, 9));
-
-* Fix linkage of tests on Arch Linux
-  (`#89 <https://github.com/fmtlib/fmt/issues/89>`_).
-
-* Allow precision specifier for non-float arguments
-  (`#90 <https://github.com/fmtlib/fmt/issues/90>`_):
-
-  .. code:: c++
-
-    fmt::print("{:.3}\n", "Carpet"); // prints "Car"
-
-* Fix build on Android NDK
-  (`#93 <https://github.com/fmtlib/fmt/issues/93>`_)
-
-* Improvements to documentation build procedure.
-
-* Remove ``FMT_SHARED`` CMake variable in favor of standard `BUILD_SHARED_LIBS
-  <http://www.cmake.org/cmake/help/v3.0/variable/BUILD_SHARED_LIBS.html>`_.
-
-* Fix error handling in ``fmt::fprintf``.
-
-* Fix a number of warnings.
-
-0.12.0 - 2014-10-25
--------------------
-
-* [Breaking] Improved separation between formatting and buffer management.
-  ``Writer`` is now a base class that cannot be instantiated directly.
-  The new ``MemoryWriter`` class implements the default buffer management
-  with small allocations done on stack. So ``fmt::Writer`` should be replaced
-  with ``fmt::MemoryWriter`` in variable declarations.
-
-  Old code:
-
-  .. code:: c++
-
-    fmt::Writer w;
-
-  New code: 
-
-  .. code:: c++
-
-    fmt::MemoryWriter w;
-
-  If you pass ``fmt::Writer`` by reference, you can continue to do so:
-
-  .. code:: c++
-
-      void f(fmt::Writer &w);
-
-  This doesn't affect the formatting API.
-
-* Support for custom memory allocators
-  (`#69 <https://github.com/fmtlib/fmt/issues/69>`_)
-
-* Formatting functions now accept `signed char` and `unsigned char` strings as
-  arguments (`#73 <https://github.com/fmtlib/fmt/issues/73>`_):
-
-  .. code:: c++
-
-    auto s = format("GLSL version: {}", glGetString(GL_VERSION));
-
-* Reduced code bloat. According to the new `benchmark results
-  <https://github.com/fmtlib/fmt#compile-time-and-code-bloat>`_,
-  cppformat is close to ``printf`` and by the order of magnitude better than
-  Boost Format in terms of compiled code size.
-
-* Improved appearance of the documentation on mobile by using the `Sphinx
-  Bootstrap theme <http://ryan-roemer.github.io/sphinx-bootstrap-theme/>`_:
-
-  .. |old| image:: https://cloud.githubusercontent.com/assets/576385/4792130/
-                   cd256436-5de3-11e4-9a62-c077d0c2b003.png
-
-  .. |new| image:: https://cloud.githubusercontent.com/assets/576385/4792131/
-                   cd29896c-5de3-11e4-8f59-cac952942bf0.png
-  
-  +-------+-------+
-  |  Old  |  New  |
-  +-------+-------+
-  | |old| | |new| |
-  +-------+-------+
-
-0.11.0 - 2014-08-21
--------------------
-
-* Safe printf implementation with a POSIX extension for positional arguments:
-
-  .. code:: c++
-
-    fmt::printf("Elapsed time: %.2f seconds", 1.23);
-    fmt::printf("%1$s, %3$d %2$s", weekday, month, day);
-
-* Arguments of ``char`` type can now be formatted as integers
-  (Issue `#55 <https://github.com/fmtlib/fmt/issues/55>`_):
-
-  .. code:: c++
-
-    fmt::format("0x{0:02X}", 'a');
-
-* Deprecated parts of the API removed.
-
-* The library is now built and tested on MinGW with Appveyor in addition to
-  existing test platforms Linux/GCC, OS X/Clang, Windows/MSVC.
-
-0.10.0 - 2014-07-01
--------------------
-
-**Improved API**
-
-* All formatting methods are now implemented as variadic functions instead
-  of using ``operator<<`` for feeding arbitrary arguments into a temporary
-  formatter object. This works both with C++11 where variadic templates are
-  used and with older standards where variadic functions are emulated by
-  providing lightweight wrapper functions defined with the ``FMT_VARIADIC``
-  macro. You can use this macro for defining your own portable variadic
-  functions:
-
-  .. code:: c++
-
-    void report_error(const char *format, const fmt::ArgList &args) {
-      fmt::print("Error: {}");
-      fmt::print(format, args);
-    }
-    FMT_VARIADIC(void, report_error, const char *)
-
-    report_error("file not found: {}", path);
-
-  Apart from a more natural syntax, this also improves performance as there
-  is no need to construct temporary formatter objects and control arguments'
-  lifetimes. Because the wrapper functions are very lightweight, this doesn't
-  cause code bloat even in pre-C++11 mode.
-
-* Simplified common case of formatting an ``std::string``. Now it requires a
-  single function call:
-
-  .. code:: c++
-
-    std::string s = format("The answer is {}.", 42);
-
-  Previously it required 2 function calls:
-
-  .. code:: c++
-
-    std::string s = str(Format("The answer is {}.") << 42);
-
-  Instead of unsafe ``c_str`` function, ``fmt::Writer`` should be used directly
-  to bypass creation of ``std::string``:
-
-  .. code:: c++
-
-    fmt::Writer w;
-    w.write("The answer is {}.", 42);
-    w.c_str();  // returns a C string
-
-  This doesn't do dynamic memory allocation for small strings and is less error
-  prone as the lifetime of the string is the same as for ``std::string::c_str``
-  which is well understood (hopefully).
-
-* Improved consistency in naming functions that are a part of the public API.
-  Now all public functions are lowercase following the standard library
-  conventions. Previously it was a combination of lowercase and
-  CapitalizedWords.
-  Issue `#50 <https://github.com/fmtlib/fmt/issues/50>`_.
-
-* Old functions are marked as deprecated and will be removed in the next
-  release.
-
-**Other Changes**
-
-* Experimental support for printf format specifications (work in progress):
-
-  .. code:: c++
-
-    fmt::printf("The answer is %d.", 42);
-    std::string s = fmt::sprintf("Look, a %s!", "string");
-
-* Support for hexadecimal floating point format specifiers ``a`` and ``A``:
-
-  .. code:: c++
-
-    print("{:a}", -42.0); // Prints -0x1.5p+5
-    print("{:A}", -42.0); // Prints -0X1.5P+5
-
-* CMake option ``FMT_SHARED`` that specifies whether to build format as a
-  shared library (off by default).
-
-0.9.0 - 2014-05-13
-------------------
-
-* More efficient implementation of variadic formatting functions.
-
-* ``Writer::Format`` now has a variadic overload:
-
-  .. code:: c++
-
-    Writer out;
-    out.Format("Look, I'm {}!", "variadic");
-
-* For efficiency and consistency with other overloads, variadic overload of
-  the ``Format`` function now returns ``Writer`` instead of ``std::string``.
-  Use the ``str`` function to convert it to ``std::string``:
-
-  .. code:: c++
-
-    std::string s = str(Format("Look, I'm {}!", "variadic"));
-
-* Replaced formatter actions with output sinks: ``NoAction`` -> ``NullSink``,
-  ``Write`` -> ``FileSink``, ``ColorWriter`` -> ``ANSITerminalSink``.
-  This improves naming consistency and shouldn't affect client code unless
-  these classes are used directly which should be rarely needed.
-
-* Added ``ThrowSystemError`` function that formats a message and throws
-  ``SystemError`` containing the formatted message and system-specific error
-  description. For example, the following code
-
-  .. code:: c++
-
-    FILE *f = fopen(filename, "r");
-    if (!f)
-      ThrowSystemError(errno, "Failed to open file '{}'") << filename;
-
-  will throw ``SystemError`` exception with description
-  "Failed to open file '<filename>': No such file or directory" if file
-  doesn't exist.
-
-* Support for AppVeyor continuous integration platform.
-
-* ``Format`` now throws ``SystemError`` in case of I/O errors.
-
-* Improve test infrastructure. Print functions are now tested by redirecting
-  the output to a pipe.
-
-0.8.0 - 2014-04-14
-------------------
-
-* Initial release
diff --git a/Externals/fmt/LICENSE.rst b/Externals/fmt/LICENSE.rst
deleted file mode 100755
index f0ec3db4d2a0..000000000000
--- a/Externals/fmt/LICENSE.rst
+++ /dev/null
@@ -1,27 +0,0 @@
-Copyright (c) 2012 - present, Victor Zverovich
-
-Permission is hereby granted, free of charge, to any person obtaining
-a copy of this software and associated documentation files (the
-"Software"), to deal in the Software without restriction, including
-without limitation the rights to use, copy, modify, merge, publish,
-distribute, sublicense, and/or sell copies of the Software, and to
-permit persons to whom the Software is furnished to do so, subject to
-the following conditions:
-
-The above copyright notice and this permission notice shall be
-included in all copies or substantial portions of the Software.
-
-THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
-EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
-MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
-NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
-LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
-OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
-WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
-
---- Optional exception to the license ---
-
-As an exception, if, as a result of your compiling your source code, portions
-of this Software are embedded into a machine-executable object form of such
-source code, you may redistribute such embedded portions in such object form
-without including the above copyright and permission notices.
diff --git a/Externals/fmt/README.rst b/Externals/fmt/README.rst
deleted file mode 100755
index cc6d7c41ada1..000000000000
--- a/Externals/fmt/README.rst
+++ /dev/null
@@ -1,531 +0,0 @@
-.. image:: https://user-images.githubusercontent.com/
-           576385/156254208-f5b743a9-88cf-439d-b0c0-923d53e8d551.png
-   :width: 25%
-   :alt: {fmt}
-
-.. image:: https://github.com/fmtlib/fmt/workflows/linux/badge.svg
-   :target: https://github.com/fmtlib/fmt/actions?query=workflow%3Alinux
-
-.. image:: https://github.com/fmtlib/fmt/workflows/macos/badge.svg
-   :target: https://github.com/fmtlib/fmt/actions?query=workflow%3Amacos
-
-.. image:: https://github.com/fmtlib/fmt/workflows/windows/badge.svg
-   :target: https://github.com/fmtlib/fmt/actions?query=workflow%3Awindows
-
-.. image:: https://oss-fuzz-build-logs.storage.googleapis.com/badges/fmt.svg
-   :alt: fmt is continuously fuzzed at oss-fuzz
-   :target: https://bugs.chromium.org/p/oss-fuzz/issues/list?\
-            colspec=ID%20Type%20Component%20Status%20Proj%20Reported%20Owner%20\
-            Summary&q=proj%3Dfmt&can=1
-
-.. image:: https://img.shields.io/badge/stackoverflow-fmt-blue.svg
-   :alt: Ask questions at StackOverflow with the tag fmt
-   :target: https://stackoverflow.com/questions/tagged/fmt
-
-**{fmt}** is an open-source formatting library providing a fast and safe
-alternative to C stdio and C++ iostreams.
-
-If you like this project, please consider donating to one of the funds that
-help victims of the war in Ukraine: https://www.stopputin.net/.
-
-`Documentation <https://fmt.dev>`__
-
-`Cheat Sheets <https://hackingcpp.com/cpp/libs/fmt.html>`__
-
-Q&A: ask questions on `StackOverflow with the tag fmt
-<https://stackoverflow.com/questions/tagged/fmt>`_.
-
-Try {fmt} in `Compiler Explorer <https://godbolt.org/z/Eq5763>`_.
-
-Features
---------
-
-* Simple `format API <https://fmt.dev/latest/api.html>`_ with positional arguments
-  for localization
-* Implementation of `C++20 std::format
-  <https://en.cppreference.com/w/cpp/utility/format>`__
-* `Format string syntax <https://fmt.dev/latest/syntax.html>`_ similar to Python's
-  `format <https://docs.python.org/3/library/stdtypes.html#str.format>`_
-* Fast IEEE 754 floating-point formatter with correct rounding, shortness and
-  round-trip guarantees
-* Safe `printf implementation
-  <https://fmt.dev/latest/api.html#printf-formatting>`_ including the POSIX
-  extension for positional arguments
-* Extensibility: `support for user-defined types
-  <https://fmt.dev/latest/api.html#formatting-user-defined-types>`_
-* High performance: faster than common standard library implementations of
-  ``(s)printf``, iostreams, ``to_string`` and ``to_chars``, see `Speed tests`_
-  and `Converting a hundred million integers to strings per second
-  <http://www.zverovich.net/2020/06/13/fast-int-to-string-revisited.html>`_
-* Small code size both in terms of source code with the minimum configuration
-  consisting of just three files, ``core.h``, ``format.h`` and ``format-inl.h``,
-  and compiled code; see `Compile time and code bloat`_
-* Reliability: the library has an extensive set of `tests
-  <https://github.com/fmtlib/fmt/tree/master/test>`_ and is `continuously fuzzed
-  <https://bugs.chromium.org/p/oss-fuzz/issues/list?colspec=ID%20Type%20
-  Component%20Status%20Proj%20Reported%20Owner%20Summary&q=proj%3Dfmt&can=1>`_
-* Safety: the library is fully type safe, errors in format strings can be
-  reported at compile time, automatic memory management prevents buffer overflow
-  errors
-* Ease of use: small self-contained code base, no external dependencies,
-  permissive MIT `license
-  <https://github.com/fmtlib/fmt/blob/master/LICENSE.rst>`_
-* `Portability <https://fmt.dev/latest/index.html#portability>`_ with
-  consistent output across platforms and support for older compilers
-* Clean warning-free codebase even on high warning levels such as
-  ``-Wall -Wextra -pedantic``
-* Locale-independence by default
-* Optional header-only configuration enabled with the ``FMT_HEADER_ONLY`` macro
-
-See the `documentation <https://fmt.dev>`_ for more details.
-
-Examples
---------
-
-**Print to stdout** (`run <https://godbolt.org/z/Tevcjh>`_)
-
-.. code:: c++
-
-    #include <fmt/core.h>
-    
-    int main() {
-      fmt::print("Hello, world!\n");
-    }
-
-**Format a string** (`run <https://godbolt.org/z/oK8h33>`_)
-
-.. code:: c++
-
-    std::string s = fmt::format("The answer is {}.", 42);
-    // s == "The answer is 42."
-
-**Format a string using positional arguments** (`run <https://godbolt.org/z/Yn7Txe>`_)
-
-.. code:: c++
-
-    std::string s = fmt::format("I'd rather be {1} than {0}.", "right", "happy");
-    // s == "I'd rather be happy than right."
-
-**Print chrono durations** (`run <https://godbolt.org/z/K8s4Mc>`_)
-
-.. code:: c++
-
-    #include <fmt/chrono.h>
-
-    int main() {
-      using namespace std::literals::chrono_literals;
-      fmt::print("Default format: {} {}\n", 42s, 100ms);
-      fmt::print("strftime-like format: {:%H:%M:%S}\n", 3h + 15min + 30s);
-    }
-
-Output::
-
-    Default format: 42s 100ms
-    strftime-like format: 03:15:30
-
-**Print a container** (`run <https://godbolt.org/z/MxM1YqjE7>`_)
-
-.. code:: c++
-
-    #include <vector>
-    #include <fmt/ranges.h>
-
-    int main() {
-      std::vector<int> v = {1, 2, 3};
-      fmt::print("{}\n", v);
-    }
-
-Output::
-
-    [1, 2, 3]
-
-**Check a format string at compile time**
-
-.. code:: c++
-
-    std::string s = fmt::format("{:d}", "I am not a number");
-
-This gives a compile-time error in C++20 because ``d`` is an invalid format
-specifier for a string.
-
-**Write a file from a single thread**
-
-.. code:: c++
-
-    #include <fmt/os.h>
-
-    int main() {
-      auto out = fmt::output_file("guide.txt");
-      out.print("Don't {}", "Panic");
-    }
-
-This can be `5 to 9 times faster than fprintf
-<http://www.zverovich.net/2020/08/04/optimal-file-buffer-size.html>`_.
-
-**Print with colors and text styles**
-
-.. code:: c++
-
-    #include <fmt/color.h>
-
-    int main() {
-      fmt::print(fg(fmt::color::crimson) | fmt::emphasis::bold,
-                 "Hello, {}!\n", "world");
-      fmt::print(fg(fmt::color::floral_white) | bg(fmt::color::slate_gray) |
-                 fmt::emphasis::underline, "Hello, {}!\n", "мир");
-      fmt::print(fg(fmt::color::steel_blue) | fmt::emphasis::italic,
-                 "Hello, {}!\n", "世界");
-    }
-
-Output on a modern terminal:
-
-.. image:: https://user-images.githubusercontent.com/
-           576385/88485597-d312f600-cf2b-11ea-9cbe-61f535a86e28.png
-
-Benchmarks
-----------
-
-Speed tests
-~~~~~~~~~~~
-
-================= ============= ===========
-Library           Method        Run Time, s
-================= ============= ===========
-libc              printf          1.04
-libc++            std::ostream    3.05
-{fmt} 6.1.1       fmt::print      0.75
-Boost Format 1.67 boost::format   7.24
-Folly Format      folly::format   2.23
-================= ============= ===========
-
-{fmt} is the fastest of the benchmarked methods, ~35% faster than ``printf``.
-
-The above results were generated by building ``tinyformat_test.cpp`` on macOS
-10.14.6 with ``clang++ -O3 -DNDEBUG -DSPEED_TEST -DHAVE_FORMAT``, and taking the
-best of three runs. In the test, the format string ``"%0.10f:%04d:%+g:%s:%p:%c:%%\n"``
-or equivalent is filled 2,000,000 times with output sent to ``/dev/null``; for
-further details refer to the `source
-<https://github.com/fmtlib/format-benchmark/blob/master/src/tinyformat-test.cc>`_.
-
-{fmt} is up to 20-30x faster than ``std::ostringstream`` and ``sprintf`` on
-floating-point formatting (`dtoa-benchmark <https://github.com/fmtlib/dtoa-benchmark>`_)
-and faster than `double-conversion <https://github.com/google/double-conversion>`_ and
-`ryu <https://github.com/ulfjack/ryu>`_:
-
-.. image:: https://user-images.githubusercontent.com/576385/
-           95684665-11719600-0ba8-11eb-8e5b-972ff4e49428.png
-   :target: https://fmt.dev/unknown_mac64_clang12.0.html
-
-Compile time and code bloat
-~~~~~~~~~~~~~~~~~~~~~~~~~~~
-
-The script `bloat-test.py
-<https://github.com/fmtlib/format-benchmark/blob/master/bloat-test.py>`_
-from `format-benchmark <https://github.com/fmtlib/format-benchmark>`_
-tests compile time and code bloat for nontrivial projects.
-It generates 100 translation units and uses ``printf()`` or its alternative
-five times in each to simulate a medium sized project.  The resulting
-executable size and compile time (Apple LLVM version 8.1.0 (clang-802.0.42),
-macOS Sierra, best of three) is shown in the following tables.
-
-**Optimized build (-O3)**
-
-============= =============== ==================== ==================
-Method        Compile Time, s Executable size, KiB Stripped size, KiB
-============= =============== ==================== ==================
-printf                    2.6                   29                 26
-printf+string            16.4                   29                 26
-iostreams                31.1                   59                 55
-{fmt}                    19.0                   37                 34
-Boost Format             91.9                  226                203
-Folly Format            115.7                  101                 88
-============= =============== ==================== ==================
-
-As you can see, {fmt} has 60% less overhead in terms of resulting binary code
-size compared to iostreams and comes pretty close to ``printf``. Boost Format
-and Folly Format have the largest overheads.
-
-``printf+string`` is the same as ``printf`` but with extra ``<string>``
-include to measure the overhead of the latter.
-
-**Non-optimized build**
-
-============= =============== ==================== ==================
-Method        Compile Time, s Executable size, KiB Stripped size, KiB
-============= =============== ==================== ==================
-printf                    2.2                   33                 30
-printf+string            16.0                   33                 30
-iostreams                28.3                   56                 52
-{fmt}                    18.2                   59                 50
-Boost Format             54.1                  365                303
-Folly Format             79.9                  445                430
-============= =============== ==================== ==================
-
-``libc``, ``lib(std)c++`` and ``libfmt`` are all linked as shared libraries to
-compare formatting function overhead only. Boost Format is a
-header-only library so it doesn't provide any linkage options.
-
-Running the tests
-~~~~~~~~~~~~~~~~~
-
-Please refer to `Building the library`__ for the instructions on how to build
-the library and run the unit tests.
-
-__ https://fmt.dev/latest/usage.html#building-the-library
-
-Benchmarks reside in a separate repository,
-`format-benchmarks <https://github.com/fmtlib/format-benchmark>`_,
-so to run the benchmarks you first need to clone this repository and
-generate Makefiles with CMake::
-
-    $ git clone --recursive https://github.com/fmtlib/format-benchmark.git
-    $ cd format-benchmark
-    $ cmake .
-
-Then you can run the speed test::
-
-    $ make speed-test
-
-or the bloat test::
-
-    $ make bloat-test
-    
-Migrating code
---------------
-
-`clang-tidy-fmt <https://github.com/mikecrowe/clang-tidy-fmt>`_ provides clang
-tidy checks for converting occurrences of ``printf`` and ``fprintf`` to
-``fmt::print``.
-
-Projects using this library
----------------------------
-
-* `0 A.D. <https://play0ad.com/>`_: a free, open-source, cross-platform
-  real-time strategy game
-
-* `2GIS <https://2gis.ru/>`_: free business listings with a city map
-
-* `AMPL/MP <https://github.com/ampl/mp>`_:
-  an open-source library for mathematical programming
-
-* `Aseprite <https://github.com/aseprite/aseprite>`_:
-  animated sprite editor & pixel art tool 
-
-* `AvioBook <https://www.aviobook.aero/en>`_: a comprehensive aircraft
-  operations suite
-  
-* `Blizzard Battle.net <https://battle.net/>`_: an online gaming platform
-  
-* `Celestia <https://celestia.space/>`_: real-time 3D visualization of space
-
-* `Ceph <https://ceph.com/>`_: a scalable distributed storage system
-
-* `ccache <https://ccache.dev/>`_: a compiler cache
-
-* `ClickHouse <https://github.com/ClickHouse/ClickHouse>`_: analytical database
-  management system
-
-* `CUAUV <https://cuauv.org/>`_: Cornell University's autonomous underwater
-  vehicle
-
-* `Drake <https://drake.mit.edu/>`_: a planning, control, and analysis toolbox
-  for nonlinear dynamical systems (MIT)
-
-* `Envoy <https://lyft.github.io/envoy/>`_: C++ L7 proxy and communication bus
-  (Lyft)
-
-* `FiveM <https://fivem.net/>`_: a modification framework for GTA V
-
-* `fmtlog <https://github.com/MengRao/fmtlog>`_: a performant fmtlib-style
-  logging library with latency in nanoseconds
-
-* `Folly <https://github.com/facebook/folly>`_: Facebook open-source library
-
-* `GemRB <https://gemrb.org/>`_: a portable open-source implementation of
-  Bioware’s Infinity Engine
-
-* `Grand Mountain Adventure
-  <https://store.steampowered.com/app/1247360/Grand_Mountain_Adventure/>`_:
-  a beautiful open-world ski & snowboarding game
-
-* `HarpyWar/pvpgn <https://github.com/pvpgn/pvpgn-server>`_:
-  Player vs Player Gaming Network with tweaks
-
-* `KBEngine <https://github.com/kbengine/kbengine>`_: an open-source MMOG server
-  engine
-
-* `Keypirinha <https://keypirinha.com/>`_: a semantic launcher for Windows
-
-* `Kodi <https://kodi.tv/>`_ (formerly xbmc): home theater software
-
-* `Knuth <https://kth.cash/>`_: high-performance Bitcoin full-node
-
-* `Microsoft Verona <https://github.com/microsoft/verona>`_:
-  research programming language for concurrent ownership
-
-* `MongoDB <https://mongodb.com/>`_: distributed document database
-
-* `MongoDB Smasher <https://github.com/duckie/mongo_smasher>`_: a small tool to
-  generate randomized datasets
-
-* `OpenSpace <https://openspaceproject.com/>`_: an open-source
-  astrovisualization framework
-
-* `PenUltima Online (POL) <https://www.polserver.com/>`_:
-  an MMO server, compatible with most Ultima Online clients
-
-* `PyTorch <https://github.com/pytorch/pytorch>`_: an open-source machine
-  learning library
-
-* `quasardb <https://www.quasardb.net/>`_: a distributed, high-performance,
-  associative database
-  
-* `Quill <https://github.com/odygrd/quill>`_: asynchronous low-latency logging library
-
-* `QKW <https://github.com/ravijanjam/qkw>`_: generalizing aliasing to simplify
-  navigation, and executing complex multi-line terminal command sequences
-
-* `redis-cerberus <https://github.com/HunanTV/redis-cerberus>`_: a Redis cluster
-  proxy
-
-* `redpanda <https://vectorized.io/redpanda>`_: a 10x faster Kafka® replacement
-  for mission critical systems written in C++
-
-* `rpclib <http://rpclib.net/>`_: a modern C++ msgpack-RPC server and client
-  library
-
-* `Salesforce Analytics Cloud
-  <https://www.salesforce.com/analytics-cloud/overview/>`_:
-  business intelligence software
-
-* `Scylla <https://www.scylladb.com/>`_: a Cassandra-compatible NoSQL data store
-  that can handle 1 million transactions per second on a single server
-
-* `Seastar <http://www.seastar-project.org/>`_: an advanced, open-source C++
-  framework for high-performance server applications on modern hardware
-
-* `spdlog <https://github.com/gabime/spdlog>`_: super fast C++ logging library
-
-* `Stellar <https://www.stellar.org/>`_: financial platform
-
-* `Touch Surgery <https://www.touchsurgery.com/>`_: surgery simulator
-
-* `TrinityCore <https://github.com/TrinityCore/TrinityCore>`_: open-source
-  MMORPG framework
-
-* `Windows Terminal <https://github.com/microsoft/terminal>`_: the new Windows
-  terminal
-
-`More... <https://github.com/search?q=fmtlib&type=Code>`_
-
-If you are aware of other projects using this library, please let me know
-by `email <mailto:victor.zverovich@gmail.com>`_ or by submitting an
-`issue <https://github.com/fmtlib/fmt/issues>`_.
-
-Motivation
-----------
-
-So why yet another formatting library?
-
-There are plenty of methods for doing this task, from standard ones like
-the printf family of function and iostreams to Boost Format and FastFormat
-libraries. The reason for creating a new library is that every existing
-solution that I found either had serious issues or didn't provide
-all the features I needed.
-
-printf
-~~~~~~
-
-The good thing about ``printf`` is that it is pretty fast and readily available
-being a part of the C standard library. The main drawback is that it
-doesn't support user-defined types. ``printf`` also has safety issues although
-they are somewhat mitigated with `__attribute__ ((format (printf, ...))
-<https://gcc.gnu.org/onlinedocs/gcc/Function-Attributes.html>`_ in GCC.
-There is a POSIX extension that adds positional arguments required for
-`i18n <https://en.wikipedia.org/wiki/Internationalization_and_localization>`_
-to ``printf`` but it is not a part of C99 and may not be available on some
-platforms.
-
-iostreams
-~~~~~~~~~
-
-The main issue with iostreams is best illustrated with an example:
-
-.. code:: c++
-
-    std::cout << std::setprecision(2) << std::fixed << 1.23456 << "\n";
-
-which is a lot of typing compared to printf:
-
-.. code:: c++
-
-    printf("%.2f\n", 1.23456);
-
-Matthew Wilson, the author of FastFormat, called this "chevron hell". iostreams
-don't support positional arguments by design.
-
-The good part is that iostreams support user-defined types and are safe although
-error handling is awkward.
-
-Boost Format
-~~~~~~~~~~~~
-
-This is a very powerful library which supports both ``printf``-like format
-strings and positional arguments. Its main drawback is performance. According to
-various benchmarks, it is much slower than other methods considered here. Boost
-Format also has excessive build times and severe code bloat issues (see
-`Benchmarks`_).
-
-FastFormat
-~~~~~~~~~~
-
-This is an interesting library which is fast, safe and has positional arguments.
-However, it has significant limitations, citing its author:
-
-    Three features that have no hope of being accommodated within the
-    current design are:
-
-    * Leading zeros (or any other non-space padding)
-    * Octal/hexadecimal encoding
-    * Runtime width/alignment specification
-
-It is also quite big and has a heavy dependency, STLSoft, which might be too
-restrictive for using it in some projects.
-
-Boost Spirit.Karma
-~~~~~~~~~~~~~~~~~~
-
-This is not really a formatting library but I decided to include it here for
-completeness. As iostreams, it suffers from the problem of mixing verbatim text
-with arguments. The library is pretty fast, but slower on integer formatting
-than ``fmt::format_to`` with format string compilation on Karma's own benchmark,
-see `Converting a hundred million integers to strings per second
-<http://www.zverovich.net/2020/06/13/fast-int-to-string-revisited.html>`_.
-
-License
--------
-
-{fmt} is distributed under the MIT `license
-<https://github.com/fmtlib/fmt/blob/master/LICENSE.rst>`_.
-
-Documentation License
----------------------
-
-The `Format String Syntax <https://fmt.dev/latest/syntax.html>`_
-section in the documentation is based on the one from Python `string module
-documentation <https://docs.python.org/3/library/string.html#module-string>`_.
-For this reason the documentation is distributed under the Python Software
-Foundation license available in `doc/python-license.txt
-<https://raw.github.com/fmtlib/fmt/master/doc/python-license.txt>`_.
-It only applies if you distribute the documentation of {fmt}.
-
-Maintainers
------------
-
-The {fmt} library is maintained by Victor Zverovich (`vitaut
-<https://github.com/vitaut>`_) and Jonathan Müller (`foonathan
-<https://github.com/foonathan>`_) with contributions from many other people.
-See `Contributors <https://github.com/fmtlib/fmt/graphs/contributors>`_ and
-`Releases <https://github.com/fmtlib/fmt/releases>`_ for some of the names.
-Let us know if your contribution is not listed or mentioned incorrectly and
-we'll make it right.
diff --git a/Externals/fmt/exports.props b/Externals/fmt/exports.props
index d2bad1416419..25e07f5e17fb 100644
--- a/Externals/fmt/exports.props
+++ b/Externals/fmt/exports.props
@@ -2,7 +2,7 @@
 <Project>
   <ItemDefinitionGroup>
     <ClCompile>
-      <AdditionalIncludeDirectories>$(ExternalsDir)fmt\include;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
+      <AdditionalIncludeDirectories>$(ExternalsDir)fmt\fmt\include;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
     </ClCompile>
   </ItemDefinitionGroup>
   <ItemGroup>
diff --git a/Externals/fmt/fmt b/Externals/fmt/fmt
new file mode 160000
index 000000000000..f5e54359df4c
--- /dev/null
+++ b/Externals/fmt/fmt
@@ -0,0 +1 @@
+Subproject commit f5e54359df4c26b6230fc61d38aa294581393084
diff --git a/Externals/fmt/fmt.vcxproj b/Externals/fmt/fmt.vcxproj
index b7015f05586c..9a978b584893 100644
--- a/Externals/fmt/fmt.vcxproj
+++ b/Externals/fmt/fmt.vcxproj
@@ -17,27 +17,27 @@
   <PropertyGroup Label="UserMacros" />
   <ItemDefinitionGroup>
     <ClCompile>
-      <AdditionalIncludeDirectories>include;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
+      <AdditionalIncludeDirectories>fmt\include;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
     </ClCompile>
   </ItemDefinitionGroup>
   <ItemGroup>
-    <ClCompile Include="src/format.cc" />
-    <ClCompile Include="src/os.cc" />
+    <ClCompile Include="fmt/src/format.cc" />
+    <ClCompile Include="fmt/src/os.cc" />
   </ItemGroup>
   <ItemGroup>
-    <ClInclude Include="include/fmt/args.h" />
-    <ClInclude Include="include/fmt/chrono.h" />
-    <ClInclude Include="include/fmt/color.h" />
-    <ClInclude Include="include/fmt/compile.h" />
-    <ClInclude Include="include/fmt/core.h" />
-    <ClInclude Include="include/fmt/format-inl.h" />
-    <ClInclude Include="include/fmt/format.h" />
-    <ClInclude Include="include/fmt/os.h" />
-    <ClInclude Include="include/fmt/ostream.h" />
-    <ClInclude Include="include/fmt/printf.h" />
-    <ClInclude Include="include/fmt/ranges.h" />
-    <ClInclude Include="include/fmt/std.h" />
-    <ClInclude Include="include/fmt/xchar.h" />
+    <ClInclude Include="fmt/include/fmt/args.h" />
+    <ClInclude Include="fmt/include/fmt/chrono.h" />
+    <ClInclude Include="fmt/include/fmt/color.h" />
+    <ClInclude Include="fmt/include/fmt/compile.h" />
+    <ClInclude Include="fmt/include/fmt/core.h" />
+    <ClInclude Include="fmt/include/fmt/format-inl.h" />
+    <ClInclude Include="fmt/include/fmt/format.h" />
+    <ClInclude Include="fmt/include/fmt/os.h" />
+    <ClInclude Include="fmt/include/fmt/ostream.h" />
+    <ClInclude Include="fmt/include/fmt/printf.h" />
+    <ClInclude Include="fmt/include/fmt/ranges.h" />
+    <ClInclude Include="fmt/include/fmt/std.h" />
+    <ClInclude Include="fmt/include/fmt/xchar.h" />
   </ItemGroup>
   <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
   <ImportGroup Label="ExtensionTargets">
diff --git a/Externals/fmt/include/fmt/args.h b/Externals/fmt/include/fmt/args.h
deleted file mode 100644
index a3966d140719..000000000000
--- a/Externals/fmt/include/fmt/args.h
+++ /dev/null
@@ -1,234 +0,0 @@
-// Formatting library for C++ - dynamic format arguments
-//
-// Copyright (c) 2012 - present, Victor Zverovich
-// All rights reserved.
-//
-// For the license information refer to format.h.
-
-#ifndef FMT_ARGS_H_
-#define FMT_ARGS_H_
-
-#include <functional>  // std::reference_wrapper
-#include <memory>      // std::unique_ptr
-#include <vector>
-
-#include "core.h"
-
-FMT_BEGIN_NAMESPACE
-
-namespace detail {
-
-template <typename T> struct is_reference_wrapper : std::false_type {};
-template <typename T>
-struct is_reference_wrapper<std::reference_wrapper<T>> : std::true_type {};
-
-template <typename T> const T& unwrap(const T& v) { return v; }
-template <typename T> const T& unwrap(const std::reference_wrapper<T>& v) {
-  return static_cast<const T&>(v);
-}
-
-class dynamic_arg_list {
-  // Workaround for clang's -Wweak-vtables. Unlike for regular classes, for
-  // templates it doesn't complain about inability to deduce single translation
-  // unit for placing vtable. So storage_node_base is made a fake template.
-  template <typename = void> struct node {
-    virtual ~node() = default;
-    std::unique_ptr<node<>> next;
-  };
-
-  template <typename T> struct typed_node : node<> {
-    T value;
-
-    template <typename Arg>
-    FMT_CONSTEXPR typed_node(const Arg& arg) : value(arg) {}
-
-    template <typename Char>
-    FMT_CONSTEXPR typed_node(const basic_string_view<Char>& arg)
-        : value(arg.data(), arg.size()) {}
-  };
-
-  std::unique_ptr<node<>> head_;
-
- public:
-  template <typename T, typename Arg> const T& push(const Arg& arg) {
-    auto new_node = std::unique_ptr<typed_node<T>>(new typed_node<T>(arg));
-    auto& value = new_node->value;
-    new_node->next = std::move(head_);
-    head_ = std::move(new_node);
-    return value;
-  }
-};
-}  // namespace detail
-
-/**
-  \rst
-  A dynamic version of `fmt::format_arg_store`.
-  It's equipped with a storage to potentially temporary objects which lifetimes
-  could be shorter than the format arguments object.
-
-  It can be implicitly converted into `~fmt::basic_format_args` for passing
-  into type-erased formatting functions such as `~fmt::vformat`.
-  \endrst
- */
-template <typename Context>
-class dynamic_format_arg_store
-#if FMT_GCC_VERSION && FMT_GCC_VERSION < 409
-    // Workaround a GCC template argument substitution bug.
-    : public basic_format_args<Context>
-#endif
-{
- private:
-  using char_type = typename Context::char_type;
-
-  template <typename T> struct need_copy {
-    static constexpr detail::type mapped_type =
-        detail::mapped_type_constant<T, Context>::value;
-
-    enum {
-      value = !(detail::is_reference_wrapper<T>::value ||
-                std::is_same<T, basic_string_view<char_type>>::value ||
-                std::is_same<T, detail::std_string_view<char_type>>::value ||
-                (mapped_type != detail::type::cstring_type &&
-                 mapped_type != detail::type::string_type &&
-                 mapped_type != detail::type::custom_type))
-    };
-  };
-
-  template <typename T>
-  using stored_type = conditional_t<
-      std::is_convertible<T, std::basic_string<char_type>>::value &&
-          !detail::is_reference_wrapper<T>::value,
-      std::basic_string<char_type>, T>;
-
-  // Storage of basic_format_arg must be contiguous.
-  std::vector<basic_format_arg<Context>> data_;
-  std::vector<detail::named_arg_info<char_type>> named_info_;
-
-  // Storage of arguments not fitting into basic_format_arg must grow
-  // without relocation because items in data_ refer to it.
-  detail::dynamic_arg_list dynamic_args_;
-
-  friend class basic_format_args<Context>;
-
-  unsigned long long get_types() const {
-    return detail::is_unpacked_bit | data_.size() |
-           (named_info_.empty()
-                ? 0ULL
-                : static_cast<unsigned long long>(detail::has_named_args_bit));
-  }
-
-  const basic_format_arg<Context>* data() const {
-    return named_info_.empty() ? data_.data() : data_.data() + 1;
-  }
-
-  template <typename T> void emplace_arg(const T& arg) {
-    data_.emplace_back(detail::make_arg<Context>(arg));
-  }
-
-  template <typename T>
-  void emplace_arg(const detail::named_arg<char_type, T>& arg) {
-    if (named_info_.empty()) {
-      constexpr const detail::named_arg_info<char_type>* zero_ptr{nullptr};
-      data_.insert(data_.begin(), {zero_ptr, 0});
-    }
-    data_.emplace_back(detail::make_arg<Context>(detail::unwrap(arg.value)));
-    auto pop_one = [](std::vector<basic_format_arg<Context>>* data) {
-      data->pop_back();
-    };
-    std::unique_ptr<std::vector<basic_format_arg<Context>>, decltype(pop_one)>
-        guard{&data_, pop_one};
-    named_info_.push_back({arg.name, static_cast<int>(data_.size() - 2u)});
-    data_[0].value_.named_args = {named_info_.data(), named_info_.size()};
-    guard.release();
-  }
-
- public:
-  constexpr dynamic_format_arg_store() = default;
-
-  /**
-    \rst
-    Adds an argument into the dynamic store for later passing to a formatting
-    function.
-
-    Note that custom types and string types (but not string views) are copied
-    into the store dynamically allocating memory if necessary.
-
-    **Example**::
-
-      fmt::dynamic_format_arg_store<fmt::format_context> store;
-      store.push_back(42);
-      store.push_back("abc");
-      store.push_back(1.5f);
-      std::string result = fmt::vformat("{} and {} and {}", store);
-    \endrst
-  */
-  template <typename T> void push_back(const T& arg) {
-    if (detail::const_check(need_copy<T>::value))
-      emplace_arg(dynamic_args_.push<stored_type<T>>(arg));
-    else
-      emplace_arg(detail::unwrap(arg));
-  }
-
-  /**
-    \rst
-    Adds a reference to the argument into the dynamic store for later passing to
-    a formatting function.
-
-    **Example**::
-
-      fmt::dynamic_format_arg_store<fmt::format_context> store;
-      char band[] = "Rolling Stones";
-      store.push_back(std::cref(band));
-      band[9] = 'c'; // Changing str affects the output.
-      std::string result = fmt::vformat("{}", store);
-      // result == "Rolling Scones"
-    \endrst
-  */
-  template <typename T> void push_back(std::reference_wrapper<T> arg) {
-    static_assert(
-        need_copy<T>::value,
-        "objects of built-in types and string views are always copied");
-    emplace_arg(arg.get());
-  }
-
-  /**
-    Adds named argument into the dynamic store for later passing to a formatting
-    function. ``std::reference_wrapper`` is supported to avoid copying of the
-    argument. The name is always copied into the store.
-  */
-  template <typename T>
-  void push_back(const detail::named_arg<char_type, T>& arg) {
-    const char_type* arg_name =
-        dynamic_args_.push<std::basic_string<char_type>>(arg.name).c_str();
-    if (detail::const_check(need_copy<T>::value)) {
-      emplace_arg(
-          fmt::arg(arg_name, dynamic_args_.push<stored_type<T>>(arg.value)));
-    } else {
-      emplace_arg(fmt::arg(arg_name, arg.value));
-    }
-  }
-
-  /** Erase all elements from the store */
-  void clear() {
-    data_.clear();
-    named_info_.clear();
-    dynamic_args_ = detail::dynamic_arg_list();
-  }
-
-  /**
-    \rst
-    Reserves space to store at least *new_cap* arguments including
-    *new_cap_named* named arguments.
-    \endrst
-  */
-  void reserve(size_t new_cap, size_t new_cap_named) {
-    FMT_ASSERT(new_cap >= new_cap_named,
-               "Set of arguments includes set of named arguments");
-    data_.reserve(new_cap);
-    named_info_.reserve(new_cap_named);
-  }
-};
-
-FMT_END_NAMESPACE
-
-#endif  // FMT_ARGS_H_
diff --git a/Externals/fmt/include/fmt/chrono.h b/Externals/fmt/include/fmt/chrono.h
deleted file mode 100755
index b112f76e991c..000000000000
--- a/Externals/fmt/include/fmt/chrono.h
+++ /dev/null
@@ -1,2069 +0,0 @@
-// Formatting library for C++ - chrono support
-//
-// Copyright (c) 2012 - present, Victor Zverovich
-// All rights reserved.
-//
-// For the license information refer to format.h.
-
-#ifndef FMT_CHRONO_H_
-#define FMT_CHRONO_H_
-
-#include <algorithm>
-#include <chrono>
-#include <cmath>    // std::isfinite
-#include <cstring>  // std::memcpy
-#include <ctime>
-#include <iterator>
-#include <locale>
-#include <ostream>
-#include <type_traits>
-
-#include "format.h"
-
-FMT_BEGIN_NAMESPACE
-
-// Enable tzset.
-#ifndef FMT_USE_TZSET
-// UWP doesn't provide _tzset.
-#  if FMT_HAS_INCLUDE("winapifamily.h")
-#    include <winapifamily.h>
-#  endif
-#  if defined(_WIN32) && (!defined(WINAPI_FAMILY) || \
-                          (WINAPI_FAMILY == WINAPI_FAMILY_DESKTOP_APP))
-#    define FMT_USE_TZSET 1
-#  else
-#    define FMT_USE_TZSET 0
-#  endif
-#endif
-
-// Enable safe chrono durations, unless explicitly disabled.
-#ifndef FMT_SAFE_DURATION_CAST
-#  define FMT_SAFE_DURATION_CAST 1
-#endif
-#if FMT_SAFE_DURATION_CAST
-
-// For conversion between std::chrono::durations without undefined
-// behaviour or erroneous results.
-// This is a stripped down version of duration_cast, for inclusion in fmt.
-// See https://github.com/pauldreik/safe_duration_cast
-//
-// Copyright Paul Dreik 2019
-namespace safe_duration_cast {
-
-template <typename To, typename From,
-          FMT_ENABLE_IF(!std::is_same<From, To>::value &&
-                        std::numeric_limits<From>::is_signed ==
-                            std::numeric_limits<To>::is_signed)>
-FMT_CONSTEXPR To lossless_integral_conversion(const From from, int& ec) {
-  ec = 0;
-  using F = std::numeric_limits<From>;
-  using T = std::numeric_limits<To>;
-  static_assert(F::is_integer, "From must be integral");
-  static_assert(T::is_integer, "To must be integral");
-
-  // A and B are both signed, or both unsigned.
-  if (detail::const_check(F::digits <= T::digits)) {
-    // From fits in To without any problem.
-  } else {
-    // From does not always fit in To, resort to a dynamic check.
-    if (from < (T::min)() || from > (T::max)()) {
-      // outside range.
-      ec = 1;
-      return {};
-    }
-  }
-  return static_cast<To>(from);
-}
-
-/**
- * converts From to To, without loss. If the dynamic value of from
- * can't be converted to To without loss, ec is set.
- */
-template <typename To, typename From,
-          FMT_ENABLE_IF(!std::is_same<From, To>::value &&
-                        std::numeric_limits<From>::is_signed !=
-                            std::numeric_limits<To>::is_signed)>
-FMT_CONSTEXPR To lossless_integral_conversion(const From from, int& ec) {
-  ec = 0;
-  using F = std::numeric_limits<From>;
-  using T = std::numeric_limits<To>;
-  static_assert(F::is_integer, "From must be integral");
-  static_assert(T::is_integer, "To must be integral");
-
-  if (detail::const_check(F::is_signed && !T::is_signed)) {
-    // From may be negative, not allowed!
-    if (fmt::detail::is_negative(from)) {
-      ec = 1;
-      return {};
-    }
-    // From is positive. Can it always fit in To?
-    if (detail::const_check(F::digits > T::digits) &&
-        from > static_cast<From>(detail::max_value<To>())) {
-      ec = 1;
-      return {};
-    }
-  }
-
-  if (detail::const_check(!F::is_signed && T::is_signed &&
-                          F::digits >= T::digits) &&
-      from > static_cast<From>(detail::max_value<To>())) {
-    ec = 1;
-    return {};
-  }
-  return static_cast<To>(from);  // Lossless conversion.
-}
-
-template <typename To, typename From,
-          FMT_ENABLE_IF(std::is_same<From, To>::value)>
-FMT_CONSTEXPR To lossless_integral_conversion(const From from, int& ec) {
-  ec = 0;
-  return from;
-}  // function
-
-// clang-format off
-/**
- * converts From to To if possible, otherwise ec is set.
- *
- * input                            |    output
- * ---------------------------------|---------------
- * NaN                              | NaN
- * Inf                              | Inf
- * normal, fits in output           | converted (possibly lossy)
- * normal, does not fit in output   | ec is set
- * subnormal                        | best effort
- * -Inf                             | -Inf
- */
-// clang-format on
-template <typename To, typename From,
-          FMT_ENABLE_IF(!std::is_same<From, To>::value)>
-FMT_CONSTEXPR To safe_float_conversion(const From from, int& ec) {
-  ec = 0;
-  using T = std::numeric_limits<To>;
-  static_assert(std::is_floating_point<From>::value, "From must be floating");
-  static_assert(std::is_floating_point<To>::value, "To must be floating");
-
-  // catch the only happy case
-  if (std::isfinite(from)) {
-    if (from >= T::lowest() && from <= (T::max)()) {
-      return static_cast<To>(from);
-    }
-    // not within range.
-    ec = 1;
-    return {};
-  }
-
-  // nan and inf will be preserved
-  return static_cast<To>(from);
-}  // function
-
-template <typename To, typename From,
-          FMT_ENABLE_IF(std::is_same<From, To>::value)>
-FMT_CONSTEXPR To safe_float_conversion(const From from, int& ec) {
-  ec = 0;
-  static_assert(std::is_floating_point<From>::value, "From must be floating");
-  return from;
-}
-
-/**
- * safe duration cast between integral durations
- */
-template <typename To, typename FromRep, typename FromPeriod,
-          FMT_ENABLE_IF(std::is_integral<FromRep>::value),
-          FMT_ENABLE_IF(std::is_integral<typename To::rep>::value)>
-To safe_duration_cast(std::chrono::duration<FromRep, FromPeriod> from,
-                      int& ec) {
-  using From = std::chrono::duration<FromRep, FromPeriod>;
-  ec = 0;
-  // the basic idea is that we need to convert from count() in the from type
-  // to count() in the To type, by multiplying it with this:
-  struct Factor
-      : std::ratio_divide<typename From::period, typename To::period> {};
-
-  static_assert(Factor::num > 0, "num must be positive");
-  static_assert(Factor::den > 0, "den must be positive");
-
-  // the conversion is like this: multiply from.count() with Factor::num
-  // /Factor::den and convert it to To::rep, all this without
-  // overflow/underflow. let's start by finding a suitable type that can hold
-  // both To, From and Factor::num
-  using IntermediateRep =
-      typename std::common_type<typename From::rep, typename To::rep,
-                                decltype(Factor::num)>::type;
-
-  // safe conversion to IntermediateRep
-  IntermediateRep count =
-      lossless_integral_conversion<IntermediateRep>(from.count(), ec);
-  if (ec) return {};
-  // multiply with Factor::num without overflow or underflow
-  if (detail::const_check(Factor::num != 1)) {
-    const auto max1 = detail::max_value<IntermediateRep>() / Factor::num;
-    if (count > max1) {
-      ec = 1;
-      return {};
-    }
-    const auto min1 =
-        (std::numeric_limits<IntermediateRep>::min)() / Factor::num;
-    if (!std::is_unsigned<IntermediateRep>::value && count < min1) {
-      ec = 1;
-      return {};
-    }
-    count *= Factor::num;
-  }
-
-  if (detail::const_check(Factor::den != 1)) count /= Factor::den;
-  auto tocount = lossless_integral_conversion<typename To::rep>(count, ec);
-  return ec ? To() : To(tocount);
-}
-
-/**
- * safe duration_cast between floating point durations
- */
-template <typename To, typename FromRep, typename FromPeriod,
-          FMT_ENABLE_IF(std::is_floating_point<FromRep>::value),
-          FMT_ENABLE_IF(std::is_floating_point<typename To::rep>::value)>
-To safe_duration_cast(std::chrono::duration<FromRep, FromPeriod> from,
-                      int& ec) {
-  using From = std::chrono::duration<FromRep, FromPeriod>;
-  ec = 0;
-  if (std::isnan(from.count())) {
-    // nan in, gives nan out. easy.
-    return To{std::numeric_limits<typename To::rep>::quiet_NaN()};
-  }
-  // maybe we should also check if from is denormal, and decide what to do about
-  // it.
-
-  // +-inf should be preserved.
-  if (std::isinf(from.count())) {
-    return To{from.count()};
-  }
-
-  // the basic idea is that we need to convert from count() in the from type
-  // to count() in the To type, by multiplying it with this:
-  struct Factor
-      : std::ratio_divide<typename From::period, typename To::period> {};
-
-  static_assert(Factor::num > 0, "num must be positive");
-  static_assert(Factor::den > 0, "den must be positive");
-
-  // the conversion is like this: multiply from.count() with Factor::num
-  // /Factor::den and convert it to To::rep, all this without
-  // overflow/underflow. let's start by finding a suitable type that can hold
-  // both To, From and Factor::num
-  using IntermediateRep =
-      typename std::common_type<typename From::rep, typename To::rep,
-                                decltype(Factor::num)>::type;
-
-  // force conversion of From::rep -> IntermediateRep to be safe,
-  // even if it will never happen be narrowing in this context.
-  IntermediateRep count =
-      safe_float_conversion<IntermediateRep>(from.count(), ec);
-  if (ec) {
-    return {};
-  }
-
-  // multiply with Factor::num without overflow or underflow
-  if (detail::const_check(Factor::num != 1)) {
-    constexpr auto max1 = detail::max_value<IntermediateRep>() /
-                          static_cast<IntermediateRep>(Factor::num);
-    if (count > max1) {
-      ec = 1;
-      return {};
-    }
-    constexpr auto min1 = std::numeric_limits<IntermediateRep>::lowest() /
-                          static_cast<IntermediateRep>(Factor::num);
-    if (count < min1) {
-      ec = 1;
-      return {};
-    }
-    count *= static_cast<IntermediateRep>(Factor::num);
-  }
-
-  // this can't go wrong, right? den>0 is checked earlier.
-  if (detail::const_check(Factor::den != 1)) {
-    using common_t = typename std::common_type<IntermediateRep, intmax_t>::type;
-    count /= static_cast<common_t>(Factor::den);
-  }
-
-  // convert to the to type, safely
-  using ToRep = typename To::rep;
-
-  const ToRep tocount = safe_float_conversion<ToRep>(count, ec);
-  if (ec) {
-    return {};
-  }
-  return To{tocount};
-}
-}  // namespace safe_duration_cast
-#endif
-
-// Prevents expansion of a preceding token as a function-style macro.
-// Usage: f FMT_NOMACRO()
-#define FMT_NOMACRO
-
-namespace detail {
-template <typename T = void> struct null {};
-inline null<> localtime_r FMT_NOMACRO(...) { return null<>(); }
-inline null<> localtime_s(...) { return null<>(); }
-inline null<> gmtime_r(...) { return null<>(); }
-inline null<> gmtime_s(...) { return null<>(); }
-
-inline const std::locale& get_classic_locale() {
-  static const auto& locale = std::locale::classic();
-  return locale;
-}
-
-template <typename CodeUnit> struct codecvt_result {
-  static constexpr const size_t max_size = 32;
-  CodeUnit buf[max_size];
-  CodeUnit* end;
-};
-template <typename CodeUnit>
-constexpr const size_t codecvt_result<CodeUnit>::max_size;
-
-template <typename CodeUnit>
-void write_codecvt(codecvt_result<CodeUnit>& out, string_view in_buf,
-                   const std::locale& loc) {
-#if FMT_CLANG_VERSION
-#  pragma clang diagnostic push
-#  pragma clang diagnostic ignored "-Wdeprecated"
-  auto& f = std::use_facet<std::codecvt<CodeUnit, char, std::mbstate_t>>(loc);
-#  pragma clang diagnostic pop
-#else
-  auto& f = std::use_facet<std::codecvt<CodeUnit, char, std::mbstate_t>>(loc);
-#endif
-  auto mb = std::mbstate_t();
-  const char* from_next = nullptr;
-  auto result = f.in(mb, in_buf.begin(), in_buf.end(), from_next,
-                     std::begin(out.buf), std::end(out.buf), out.end);
-  if (result != std::codecvt_base::ok)
-    FMT_THROW(format_error("failed to format time"));
-}
-
-template <typename OutputIt>
-auto write_encoded_tm_str(OutputIt out, string_view in, const std::locale& loc)
-    -> OutputIt {
-  if (detail::is_utf8() && loc != get_classic_locale()) {
-    // char16_t and char32_t codecvts are broken in MSVC (linkage errors) and
-    // gcc-4.
-#if FMT_MSC_VERSION != 0 || \
-    (defined(__GLIBCXX__) && !defined(_GLIBCXX_USE_DUAL_ABI))
-    // The _GLIBCXX_USE_DUAL_ABI macro is always defined in libstdc++ from gcc-5
-    // and newer.
-    using code_unit = wchar_t;
-#else
-    using code_unit = char32_t;
-#endif
-
-    using unit_t = codecvt_result<code_unit>;
-    unit_t unit;
-    write_codecvt(unit, in, loc);
-    // In UTF-8 is used one to four one-byte code units.
-    auto&& buf = basic_memory_buffer<char, unit_t::max_size * 4>();
-    for (code_unit* p = unit.buf; p != unit.end; ++p) {
-      uint32_t c = static_cast<uint32_t>(*p);
-      if (sizeof(code_unit) == 2 && c >= 0xd800 && c <= 0xdfff) {
-        // surrogate pair
-        ++p;
-        if (p == unit.end || (c & 0xfc00) != 0xd800 ||
-            (*p & 0xfc00) != 0xdc00) {
-          FMT_THROW(format_error("failed to format time"));
-        }
-        c = (c << 10) + static_cast<uint32_t>(*p) - 0x35fdc00;
-      }
-      if (c < 0x80) {
-        buf.push_back(static_cast<char>(c));
-      } else if (c < 0x800) {
-        buf.push_back(static_cast<char>(0xc0 | (c >> 6)));
-        buf.push_back(static_cast<char>(0x80 | (c & 0x3f)));
-      } else if ((c >= 0x800 && c <= 0xd7ff) || (c >= 0xe000 && c <= 0xffff)) {
-        buf.push_back(static_cast<char>(0xe0 | (c >> 12)));
-        buf.push_back(static_cast<char>(0x80 | ((c & 0xfff) >> 6)));
-        buf.push_back(static_cast<char>(0x80 | (c & 0x3f)));
-      } else if (c >= 0x10000 && c <= 0x10ffff) {
-        buf.push_back(static_cast<char>(0xf0 | (c >> 18)));
-        buf.push_back(static_cast<char>(0x80 | ((c & 0x3ffff) >> 12)));
-        buf.push_back(static_cast<char>(0x80 | ((c & 0xfff) >> 6)));
-        buf.push_back(static_cast<char>(0x80 | (c & 0x3f)));
-      } else {
-        FMT_THROW(format_error("failed to format time"));
-      }
-    }
-    return copy_str<char>(buf.data(), buf.data() + buf.size(), out);
-  }
-  return copy_str<char>(in.data(), in.data() + in.size(), out);
-}
-
-template <typename Char, typename OutputIt,
-          FMT_ENABLE_IF(!std::is_same<Char, char>::value)>
-auto write_tm_str(OutputIt out, string_view sv, const std::locale& loc)
-    -> OutputIt {
-  codecvt_result<Char> unit;
-  write_codecvt(unit, sv, loc);
-  return copy_str<Char>(unit.buf, unit.end, out);
-}
-
-template <typename Char, typename OutputIt,
-          FMT_ENABLE_IF(std::is_same<Char, char>::value)>
-auto write_tm_str(OutputIt out, string_view sv, const std::locale& loc)
-    -> OutputIt {
-  return write_encoded_tm_str(out, sv, loc);
-}
-
-template <typename Char>
-inline void do_write(buffer<Char>& buf, const std::tm& time,
-                     const std::locale& loc, char format, char modifier) {
-  auto&& format_buf = formatbuf<std::basic_streambuf<Char>>(buf);
-  auto&& os = std::basic_ostream<Char>(&format_buf);
-  os.imbue(loc);
-  using iterator = std::ostreambuf_iterator<Char>;
-  const auto& facet = std::use_facet<std::time_put<Char, iterator>>(loc);
-  auto end = facet.put(os, os, Char(' '), &time, format, modifier);
-  if (end.failed()) FMT_THROW(format_error("failed to format time"));
-}
-
-template <typename Char, typename OutputIt,
-          FMT_ENABLE_IF(!std::is_same<Char, char>::value)>
-auto write(OutputIt out, const std::tm& time, const std::locale& loc,
-           char format, char modifier = 0) -> OutputIt {
-  auto&& buf = get_buffer<Char>(out);
-  do_write<Char>(buf, time, loc, format, modifier);
-  return buf.out();
-}
-
-template <typename Char, typename OutputIt,
-          FMT_ENABLE_IF(std::is_same<Char, char>::value)>
-auto write(OutputIt out, const std::tm& time, const std::locale& loc,
-           char format, char modifier = 0) -> OutputIt {
-  auto&& buf = basic_memory_buffer<Char>();
-  do_write<char>(buf, time, loc, format, modifier);
-  return write_encoded_tm_str(out, string_view(buf.data(), buf.size()), loc);
-}
-
-}  // namespace detail
-
-FMT_MODULE_EXPORT_BEGIN
-
-/**
-  Converts given time since epoch as ``std::time_t`` value into calendar time,
-  expressed in local time. Unlike ``std::localtime``, this function is
-  thread-safe on most platforms.
- */
-inline std::tm localtime(std::time_t time) {
-  struct dispatcher {
-    std::time_t time_;
-    std::tm tm_;
-
-    dispatcher(std::time_t t) : time_(t) {}
-
-    bool run() {
-      using namespace fmt::detail;
-      return handle(localtime_r(&time_, &tm_));
-    }
-
-    bool handle(std::tm* tm) { return tm != nullptr; }
-
-    bool handle(detail::null<>) {
-      using namespace fmt::detail;
-      return fallback(localtime_s(&tm_, &time_));
-    }
-
-    bool fallback(int res) { return res == 0; }
-
-#if !FMT_MSC_VERSION
-    bool fallback(detail::null<>) {
-      using namespace fmt::detail;
-      std::tm* tm = std::localtime(&time_);
-      if (tm) tm_ = *tm;
-      return tm != nullptr;
-    }
-#endif
-  };
-  dispatcher lt(time);
-  // Too big time values may be unsupported.
-  if (!lt.run()) FMT_THROW(format_error("time_t value out of range"));
-  return lt.tm_;
-}
-
-inline std::tm localtime(
-    std::chrono::time_point<std::chrono::system_clock> time_point) {
-  return localtime(std::chrono::system_clock::to_time_t(time_point));
-}
-
-/**
-  Converts given time since epoch as ``std::time_t`` value into calendar time,
-  expressed in Coordinated Universal Time (UTC). Unlike ``std::gmtime``, this
-  function is thread-safe on most platforms.
- */
-inline std::tm gmtime(std::time_t time) {
-  struct dispatcher {
-    std::time_t time_;
-    std::tm tm_;
-
-    dispatcher(std::time_t t) : time_(t) {}
-
-    bool run() {
-      using namespace fmt::detail;
-      return handle(gmtime_r(&time_, &tm_));
-    }
-
-    bool handle(std::tm* tm) { return tm != nullptr; }
-
-    bool handle(detail::null<>) {
-      using namespace fmt::detail;
-      return fallback(gmtime_s(&tm_, &time_));
-    }
-
-    bool fallback(int res) { return res == 0; }
-
-#if !FMT_MSC_VERSION
-    bool fallback(detail::null<>) {
-      std::tm* tm = std::gmtime(&time_);
-      if (tm) tm_ = *tm;
-      return tm != nullptr;
-    }
-#endif
-  };
-  dispatcher gt(time);
-  // Too big time values may be unsupported.
-  if (!gt.run()) FMT_THROW(format_error("time_t value out of range"));
-  return gt.tm_;
-}
-
-inline std::tm gmtime(
-    std::chrono::time_point<std::chrono::system_clock> time_point) {
-  return gmtime(std::chrono::system_clock::to_time_t(time_point));
-}
-
-FMT_BEGIN_DETAIL_NAMESPACE
-
-// Writes two-digit numbers a, b and c separated by sep to buf.
-// The method by Pavel Novikov based on
-// https://johnnylee-sde.github.io/Fast-unsigned-integer-to-time-string/.
-inline void write_digit2_separated(char* buf, unsigned a, unsigned b,
-                                   unsigned c, char sep) {
-  unsigned long long digits =
-      a | (b << 24) | (static_cast<unsigned long long>(c) << 48);
-  // Convert each value to BCD.
-  // We have x = a * 10 + b and we want to convert it to BCD y = a * 16 + b.
-  // The difference is
-  //   y - x = a * 6
-  // a can be found from x:
-  //   a = floor(x / 10)
-  // then
-  //   y = x + a * 6 = x + floor(x / 10) * 6
-  // floor(x / 10) is (x * 205) >> 11 (needs 16 bits).
-  digits += (((digits * 205) >> 11) & 0x000f00000f00000f) * 6;
-  // Put low nibbles to high bytes and high nibbles to low bytes.
-  digits = ((digits & 0x00f00000f00000f0) >> 4) |
-           ((digits & 0x000f00000f00000f) << 8);
-  auto usep = static_cast<unsigned long long>(sep);
-  // Add ASCII '0' to each digit byte and insert separators.
-  digits |= 0x3030003030003030 | (usep << 16) | (usep << 40);
-
-  constexpr const size_t len = 8;
-  if (const_check(is_big_endian())) {
-    char tmp[len];
-    std::memcpy(tmp, &digits, len);
-    std::reverse_copy(tmp, tmp + len, buf);
-  } else {
-    std::memcpy(buf, &digits, len);
-  }
-}
-
-template <typename Period> FMT_CONSTEXPR inline const char* get_units() {
-  if (std::is_same<Period, std::atto>::value) return "as";
-  if (std::is_same<Period, std::femto>::value) return "fs";
-  if (std::is_same<Period, std::pico>::value) return "ps";
-  if (std::is_same<Period, std::nano>::value) return "ns";
-  if (std::is_same<Period, std::micro>::value) return "µs";
-  if (std::is_same<Period, std::milli>::value) return "ms";
-  if (std::is_same<Period, std::centi>::value) return "cs";
-  if (std::is_same<Period, std::deci>::value) return "ds";
-  if (std::is_same<Period, std::ratio<1>>::value) return "s";
-  if (std::is_same<Period, std::deca>::value) return "das";
-  if (std::is_same<Period, std::hecto>::value) return "hs";
-  if (std::is_same<Period, std::kilo>::value) return "ks";
-  if (std::is_same<Period, std::mega>::value) return "Ms";
-  if (std::is_same<Period, std::giga>::value) return "Gs";
-  if (std::is_same<Period, std::tera>::value) return "Ts";
-  if (std::is_same<Period, std::peta>::value) return "Ps";
-  if (std::is_same<Period, std::exa>::value) return "Es";
-  if (std::is_same<Period, std::ratio<60>>::value) return "m";
-  if (std::is_same<Period, std::ratio<3600>>::value) return "h";
-  return nullptr;
-}
-
-enum class numeric_system {
-  standard,
-  // Alternative numeric system, e.g. 十二 instead of 12 in ja_JP locale.
-  alternative
-};
-
-// Parses a put_time-like format string and invokes handler actions.
-template <typename Char, typename Handler>
-FMT_CONSTEXPR const Char* parse_chrono_format(const Char* begin,
-                                              const Char* end,
-                                              Handler&& handler) {
-  auto ptr = begin;
-  while (ptr != end) {
-    auto c = *ptr;
-    if (c == '}') break;
-    if (c != '%') {
-      ++ptr;
-      continue;
-    }
-    if (begin != ptr) handler.on_text(begin, ptr);
-    ++ptr;  // consume '%'
-    if (ptr == end) FMT_THROW(format_error("invalid format"));
-    c = *ptr++;
-    switch (c) {
-    case '%':
-      handler.on_text(ptr - 1, ptr);
-      break;
-    case 'n': {
-      const Char newline[] = {'\n'};
-      handler.on_text(newline, newline + 1);
-      break;
-    }
-    case 't': {
-      const Char tab[] = {'\t'};
-      handler.on_text(tab, tab + 1);
-      break;
-    }
-    // Year:
-    case 'Y':
-      handler.on_year(numeric_system::standard);
-      break;
-    case 'y':
-      handler.on_short_year(numeric_system::standard);
-      break;
-    case 'C':
-      handler.on_century(numeric_system::standard);
-      break;
-    case 'G':
-      handler.on_iso_week_based_year();
-      break;
-    case 'g':
-      handler.on_iso_week_based_short_year();
-      break;
-    // Day of the week:
-    case 'a':
-      handler.on_abbr_weekday();
-      break;
-    case 'A':
-      handler.on_full_weekday();
-      break;
-    case 'w':
-      handler.on_dec0_weekday(numeric_system::standard);
-      break;
-    case 'u':
-      handler.on_dec1_weekday(numeric_system::standard);
-      break;
-    // Month:
-    case 'b':
-    case 'h':
-      handler.on_abbr_month();
-      break;
-    case 'B':
-      handler.on_full_month();
-      break;
-    case 'm':
-      handler.on_dec_month(numeric_system::standard);
-      break;
-    // Day of the year/month:
-    case 'U':
-      handler.on_dec0_week_of_year(numeric_system::standard);
-      break;
-    case 'W':
-      handler.on_dec1_week_of_year(numeric_system::standard);
-      break;
-    case 'V':
-      handler.on_iso_week_of_year(numeric_system::standard);
-      break;
-    case 'j':
-      handler.on_day_of_year();
-      break;
-    case 'd':
-      handler.on_day_of_month(numeric_system::standard);
-      break;
-    case 'e':
-      handler.on_day_of_month_space(numeric_system::standard);
-      break;
-    // Hour, minute, second:
-    case 'H':
-      handler.on_24_hour(numeric_system::standard);
-      break;
-    case 'I':
-      handler.on_12_hour(numeric_system::standard);
-      break;
-    case 'M':
-      handler.on_minute(numeric_system::standard);
-      break;
-    case 'S':
-      handler.on_second(numeric_system::standard);
-      break;
-    // Other:
-    case 'c':
-      handler.on_datetime(numeric_system::standard);
-      break;
-    case 'x':
-      handler.on_loc_date(numeric_system::standard);
-      break;
-    case 'X':
-      handler.on_loc_time(numeric_system::standard);
-      break;
-    case 'D':
-      handler.on_us_date();
-      break;
-    case 'F':
-      handler.on_iso_date();
-      break;
-    case 'r':
-      handler.on_12_hour_time();
-      break;
-    case 'R':
-      handler.on_24_hour_time();
-      break;
-    case 'T':
-      handler.on_iso_time();
-      break;
-    case 'p':
-      handler.on_am_pm();
-      break;
-    case 'Q':
-      handler.on_duration_value();
-      break;
-    case 'q':
-      handler.on_duration_unit();
-      break;
-    case 'z':
-      handler.on_utc_offset();
-      break;
-    case 'Z':
-      handler.on_tz_name();
-      break;
-    // Alternative representation:
-    case 'E': {
-      if (ptr == end) FMT_THROW(format_error("invalid format"));
-      c = *ptr++;
-      switch (c) {
-      case 'Y':
-        handler.on_year(numeric_system::alternative);
-        break;
-      case 'y':
-        handler.on_offset_year();
-        break;
-      case 'C':
-        handler.on_century(numeric_system::alternative);
-        break;
-      case 'c':
-        handler.on_datetime(numeric_system::alternative);
-        break;
-      case 'x':
-        handler.on_loc_date(numeric_system::alternative);
-        break;
-      case 'X':
-        handler.on_loc_time(numeric_system::alternative);
-        break;
-      default:
-        FMT_THROW(format_error("invalid format"));
-      }
-      break;
-    }
-    case 'O':
-      if (ptr == end) FMT_THROW(format_error("invalid format"));
-      c = *ptr++;
-      switch (c) {
-      case 'y':
-        handler.on_short_year(numeric_system::alternative);
-        break;
-      case 'm':
-        handler.on_dec_month(numeric_system::alternative);
-        break;
-      case 'U':
-        handler.on_dec0_week_of_year(numeric_system::alternative);
-        break;
-      case 'W':
-        handler.on_dec1_week_of_year(numeric_system::alternative);
-        break;
-      case 'V':
-        handler.on_iso_week_of_year(numeric_system::alternative);
-        break;
-      case 'd':
-        handler.on_day_of_month(numeric_system::alternative);
-        break;
-      case 'e':
-        handler.on_day_of_month_space(numeric_system::alternative);
-        break;
-      case 'w':
-        handler.on_dec0_weekday(numeric_system::alternative);
-        break;
-      case 'u':
-        handler.on_dec1_weekday(numeric_system::alternative);
-        break;
-      case 'H':
-        handler.on_24_hour(numeric_system::alternative);
-        break;
-      case 'I':
-        handler.on_12_hour(numeric_system::alternative);
-        break;
-      case 'M':
-        handler.on_minute(numeric_system::alternative);
-        break;
-      case 'S':
-        handler.on_second(numeric_system::alternative);
-        break;
-      default:
-        FMT_THROW(format_error("invalid format"));
-      }
-      break;
-    default:
-      FMT_THROW(format_error("invalid format"));
-    }
-    begin = ptr;
-  }
-  if (begin != ptr) handler.on_text(begin, ptr);
-  return ptr;
-}
-
-template <typename Derived> struct null_chrono_spec_handler {
-  FMT_CONSTEXPR void unsupported() {
-    static_cast<Derived*>(this)->unsupported();
-  }
-  FMT_CONSTEXPR void on_year(numeric_system) { unsupported(); }
-  FMT_CONSTEXPR void on_short_year(numeric_system) { unsupported(); }
-  FMT_CONSTEXPR void on_offset_year() { unsupported(); }
-  FMT_CONSTEXPR void on_century(numeric_system) { unsupported(); }
-  FMT_CONSTEXPR void on_iso_week_based_year() { unsupported(); }
-  FMT_CONSTEXPR void on_iso_week_based_short_year() { unsupported(); }
-  FMT_CONSTEXPR void on_abbr_weekday() { unsupported(); }
-  FMT_CONSTEXPR void on_full_weekday() { unsupported(); }
-  FMT_CONSTEXPR void on_dec0_weekday(numeric_system) { unsupported(); }
-  FMT_CONSTEXPR void on_dec1_weekday(numeric_system) { unsupported(); }
-  FMT_CONSTEXPR void on_abbr_month() { unsupported(); }
-  FMT_CONSTEXPR void on_full_month() { unsupported(); }
-  FMT_CONSTEXPR void on_dec_month(numeric_system) { unsupported(); }
-  FMT_CONSTEXPR void on_dec0_week_of_year(numeric_system) { unsupported(); }
-  FMT_CONSTEXPR void on_dec1_week_of_year(numeric_system) { unsupported(); }
-  FMT_CONSTEXPR void on_iso_week_of_year(numeric_system) { unsupported(); }
-  FMT_CONSTEXPR void on_day_of_year() { unsupported(); }
-  FMT_CONSTEXPR void on_day_of_month(numeric_system) { unsupported(); }
-  FMT_CONSTEXPR void on_day_of_month_space(numeric_system) { unsupported(); }
-  FMT_CONSTEXPR void on_24_hour(numeric_system) { unsupported(); }
-  FMT_CONSTEXPR void on_12_hour(numeric_system) { unsupported(); }
-  FMT_CONSTEXPR void on_minute(numeric_system) { unsupported(); }
-  FMT_CONSTEXPR void on_second(numeric_system) { unsupported(); }
-  FMT_CONSTEXPR void on_datetime(numeric_system) { unsupported(); }
-  FMT_CONSTEXPR void on_loc_date(numeric_system) { unsupported(); }
-  FMT_CONSTEXPR void on_loc_time(numeric_system) { unsupported(); }
-  FMT_CONSTEXPR void on_us_date() { unsupported(); }
-  FMT_CONSTEXPR void on_iso_date() { unsupported(); }
-  FMT_CONSTEXPR void on_12_hour_time() { unsupported(); }
-  FMT_CONSTEXPR void on_24_hour_time() { unsupported(); }
-  FMT_CONSTEXPR void on_iso_time() { unsupported(); }
-  FMT_CONSTEXPR void on_am_pm() { unsupported(); }
-  FMT_CONSTEXPR void on_duration_value() { unsupported(); }
-  FMT_CONSTEXPR void on_duration_unit() { unsupported(); }
-  FMT_CONSTEXPR void on_utc_offset() { unsupported(); }
-  FMT_CONSTEXPR void on_tz_name() { unsupported(); }
-};
-
-struct tm_format_checker : null_chrono_spec_handler<tm_format_checker> {
-  FMT_NORETURN void unsupported() { FMT_THROW(format_error("no format")); }
-
-  template <typename Char>
-  FMT_CONSTEXPR void on_text(const Char*, const Char*) {}
-  FMT_CONSTEXPR void on_year(numeric_system) {}
-  FMT_CONSTEXPR void on_short_year(numeric_system) {}
-  FMT_CONSTEXPR void on_offset_year() {}
-  FMT_CONSTEXPR void on_century(numeric_system) {}
-  FMT_CONSTEXPR void on_iso_week_based_year() {}
-  FMT_CONSTEXPR void on_iso_week_based_short_year() {}
-  FMT_CONSTEXPR void on_abbr_weekday() {}
-  FMT_CONSTEXPR void on_full_weekday() {}
-  FMT_CONSTEXPR void on_dec0_weekday(numeric_system) {}
-  FMT_CONSTEXPR void on_dec1_weekday(numeric_system) {}
-  FMT_CONSTEXPR void on_abbr_month() {}
-  FMT_CONSTEXPR void on_full_month() {}
-  FMT_CONSTEXPR void on_dec_month(numeric_system) {}
-  FMT_CONSTEXPR void on_dec0_week_of_year(numeric_system) {}
-  FMT_CONSTEXPR void on_dec1_week_of_year(numeric_system) {}
-  FMT_CONSTEXPR void on_iso_week_of_year(numeric_system) {}
-  FMT_CONSTEXPR void on_day_of_year() {}
-  FMT_CONSTEXPR void on_day_of_month(numeric_system) {}
-  FMT_CONSTEXPR void on_day_of_month_space(numeric_system) {}
-  FMT_CONSTEXPR void on_24_hour(numeric_system) {}
-  FMT_CONSTEXPR void on_12_hour(numeric_system) {}
-  FMT_CONSTEXPR void on_minute(numeric_system) {}
-  FMT_CONSTEXPR void on_second(numeric_system) {}
-  FMT_CONSTEXPR void on_datetime(numeric_system) {}
-  FMT_CONSTEXPR void on_loc_date(numeric_system) {}
-  FMT_CONSTEXPR void on_loc_time(numeric_system) {}
-  FMT_CONSTEXPR void on_us_date() {}
-  FMT_CONSTEXPR void on_iso_date() {}
-  FMT_CONSTEXPR void on_12_hour_time() {}
-  FMT_CONSTEXPR void on_24_hour_time() {}
-  FMT_CONSTEXPR void on_iso_time() {}
-  FMT_CONSTEXPR void on_am_pm() {}
-  FMT_CONSTEXPR void on_utc_offset() {}
-  FMT_CONSTEXPR void on_tz_name() {}
-};
-
-inline const char* tm_wday_full_name(int wday) {
-  static constexpr const char* full_name_list[] = {
-      "Sunday",   "Monday", "Tuesday", "Wednesday",
-      "Thursday", "Friday", "Saturday"};
-  return wday >= 0 && wday <= 6 ? full_name_list[wday] : "?";
-}
-inline const char* tm_wday_short_name(int wday) {
-  static constexpr const char* short_name_list[] = {"Sun", "Mon", "Tue", "Wed",
-                                                    "Thu", "Fri", "Sat"};
-  return wday >= 0 && wday <= 6 ? short_name_list[wday] : "???";
-}
-
-inline const char* tm_mon_full_name(int mon) {
-  static constexpr const char* full_name_list[] = {
-      "January", "February", "March",     "April",   "May",      "June",
-      "July",    "August",   "September", "October", "November", "December"};
-  return mon >= 0 && mon <= 11 ? full_name_list[mon] : "?";
-}
-inline const char* tm_mon_short_name(int mon) {
-  static constexpr const char* short_name_list[] = {
-      "Jan", "Feb", "Mar", "Apr", "May", "Jun",
-      "Jul", "Aug", "Sep", "Oct", "Nov", "Dec",
-  };
-  return mon >= 0 && mon <= 11 ? short_name_list[mon] : "???";
-}
-
-template <typename T, typename = void>
-struct has_member_data_tm_gmtoff : std::false_type {};
-template <typename T>
-struct has_member_data_tm_gmtoff<T, void_t<decltype(T::tm_gmtoff)>>
-    : std::true_type {};
-
-template <typename T, typename = void>
-struct has_member_data_tm_zone : std::false_type {};
-template <typename T>
-struct has_member_data_tm_zone<T, void_t<decltype(T::tm_zone)>>
-    : std::true_type {};
-
-#if FMT_USE_TZSET
-inline void tzset_once() {
-  static bool init = []() -> bool {
-    _tzset();
-    return true;
-  }();
-  ignore_unused(init);
-}
-#endif
-
-template <typename OutputIt, typename Char> class tm_writer {
- private:
-  static constexpr int days_per_week = 7;
-
-  const std::locale& loc_;
-  const bool is_classic_;
-  OutputIt out_;
-  const std::tm& tm_;
-
-  auto tm_sec() const noexcept -> int {
-    FMT_ASSERT(tm_.tm_sec >= 0 && tm_.tm_sec <= 61, "");
-    return tm_.tm_sec;
-  }
-  auto tm_min() const noexcept -> int {
-    FMT_ASSERT(tm_.tm_min >= 0 && tm_.tm_min <= 59, "");
-    return tm_.tm_min;
-  }
-  auto tm_hour() const noexcept -> int {
-    FMT_ASSERT(tm_.tm_hour >= 0 && tm_.tm_hour <= 23, "");
-    return tm_.tm_hour;
-  }
-  auto tm_mday() const noexcept -> int {
-    FMT_ASSERT(tm_.tm_mday >= 1 && tm_.tm_mday <= 31, "");
-    return tm_.tm_mday;
-  }
-  auto tm_mon() const noexcept -> int {
-    FMT_ASSERT(tm_.tm_mon >= 0 && tm_.tm_mon <= 11, "");
-    return tm_.tm_mon;
-  }
-  auto tm_year() const noexcept -> long long { return 1900ll + tm_.tm_year; }
-  auto tm_wday() const noexcept -> int {
-    FMT_ASSERT(tm_.tm_wday >= 0 && tm_.tm_wday <= 6, "");
-    return tm_.tm_wday;
-  }
-  auto tm_yday() const noexcept -> int {
-    FMT_ASSERT(tm_.tm_yday >= 0 && tm_.tm_yday <= 365, "");
-    return tm_.tm_yday;
-  }
-
-  auto tm_hour12() const noexcept -> int {
-    const auto h = tm_hour();
-    const auto z = h < 12 ? h : h - 12;
-    return z == 0 ? 12 : z;
-  }
-
-  // POSIX and the C Standard are unclear or inconsistent about what %C and %y
-  // do if the year is negative or exceeds 9999. Use the convention that %C
-  // concatenated with %y yields the same output as %Y, and that %Y contains at
-  // least 4 characters, with more only if necessary.
-  auto split_year_lower(long long year) const noexcept -> int {
-    auto l = year % 100;
-    if (l < 0) l = -l;  // l in [0, 99]
-    return static_cast<int>(l);
-  }
-
-  // Algorithm:
-  // https://en.wikipedia.org/wiki/ISO_week_date#Calculating_the_week_number_from_a_month_and_day_of_the_month_or_ordinal_date
-  auto iso_year_weeks(long long curr_year) const noexcept -> int {
-    const auto prev_year = curr_year - 1;
-    const auto curr_p =
-        (curr_year + curr_year / 4 - curr_year / 100 + curr_year / 400) %
-        days_per_week;
-    const auto prev_p =
-        (prev_year + prev_year / 4 - prev_year / 100 + prev_year / 400) %
-        days_per_week;
-    return 52 + ((curr_p == 4 || prev_p == 3) ? 1 : 0);
-  }
-  auto iso_week_num(int tm_yday, int tm_wday) const noexcept -> int {
-    return (tm_yday + 11 - (tm_wday == 0 ? days_per_week : tm_wday)) /
-           days_per_week;
-  }
-  auto tm_iso_week_year() const noexcept -> long long {
-    const auto year = tm_year();
-    const auto w = iso_week_num(tm_yday(), tm_wday());
-    if (w < 1) return year - 1;
-    if (w > iso_year_weeks(year)) return year + 1;
-    return year;
-  }
-  auto tm_iso_week_of_year() const noexcept -> int {
-    const auto year = tm_year();
-    const auto w = iso_week_num(tm_yday(), tm_wday());
-    if (w < 1) return iso_year_weeks(year - 1);
-    if (w > iso_year_weeks(year)) return 1;
-    return w;
-  }
-
-  void write1(int value) {
-    *out_++ = static_cast<char>('0' + to_unsigned(value) % 10);
-  }
-  void write2(int value) {
-    const char* d = digits2(to_unsigned(value) % 100);
-    *out_++ = *d++;
-    *out_++ = *d;
-  }
-
-  void write_year_extended(long long year) {
-    // At least 4 characters.
-    int width = 4;
-    if (year < 0) {
-      *out_++ = '-';
-      year = 0 - year;
-      --width;
-    }
-    uint32_or_64_or_128_t<long long> n = to_unsigned(year);
-    const int num_digits = count_digits(n);
-    if (width > num_digits) out_ = std::fill_n(out_, width - num_digits, '0');
-    out_ = format_decimal<Char>(out_, n, num_digits).end;
-  }
-  void write_year(long long year) {
-    if (year >= 0 && year < 10000) {
-      write2(static_cast<int>(year / 100));
-      write2(static_cast<int>(year % 100));
-    } else {
-      write_year_extended(year);
-    }
-  }
-
-  void write_utc_offset(long offset) {
-    if (offset < 0) {
-      *out_++ = '-';
-      offset = -offset;
-    } else {
-      *out_++ = '+';
-    }
-    offset /= 60;
-    write2(static_cast<int>(offset / 60));
-    write2(static_cast<int>(offset % 60));
-  }
-  template <typename T, FMT_ENABLE_IF(has_member_data_tm_gmtoff<T>::value)>
-  void format_utc_offset_impl(const T& tm) {
-    write_utc_offset(tm.tm_gmtoff);
-  }
-  template <typename T, FMT_ENABLE_IF(!has_member_data_tm_gmtoff<T>::value)>
-  void format_utc_offset_impl(const T& tm) {
-#if defined(_WIN32) && defined(_UCRT)
-#  if FMT_USE_TZSET
-    tzset_once();
-#  endif
-    long offset = 0;
-    _get_timezone(&offset);
-    if (tm.tm_isdst) {
-      long dstbias = 0;
-      _get_dstbias(&dstbias);
-      offset += dstbias;
-    }
-    write_utc_offset(-offset);
-#else
-    ignore_unused(tm);
-    format_localized('z');
-#endif
-  }
-
-  template <typename T, FMT_ENABLE_IF(has_member_data_tm_zone<T>::value)>
-  void format_tz_name_impl(const T& tm) {
-    if (is_classic_)
-      out_ = write_tm_str<Char>(out_, tm.tm_zone, loc_);
-    else
-      format_localized('Z');
-  }
-  template <typename T, FMT_ENABLE_IF(!has_member_data_tm_zone<T>::value)>
-  void format_tz_name_impl(const T&) {
-    format_localized('Z');
-  }
-
-  void format_localized(char format, char modifier = 0) {
-    out_ = write<Char>(out_, tm_, loc_, format, modifier);
-  }
-
- public:
-  tm_writer(const std::locale& loc, OutputIt out, const std::tm& tm)
-      : loc_(loc),
-        is_classic_(loc_ == get_classic_locale()),
-        out_(out),
-        tm_(tm) {}
-
-  OutputIt out() const { return out_; }
-
-  FMT_CONSTEXPR void on_text(const Char* begin, const Char* end) {
-    out_ = copy_str<Char>(begin, end, out_);
-  }
-
-  void on_abbr_weekday() {
-    if (is_classic_)
-      out_ = write(out_, tm_wday_short_name(tm_wday()));
-    else
-      format_localized('a');
-  }
-  void on_full_weekday() {
-    if (is_classic_)
-      out_ = write(out_, tm_wday_full_name(tm_wday()));
-    else
-      format_localized('A');
-  }
-  void on_dec0_weekday(numeric_system ns) {
-    if (is_classic_ || ns == numeric_system::standard) return write1(tm_wday());
-    format_localized('w', 'O');
-  }
-  void on_dec1_weekday(numeric_system ns) {
-    if (is_classic_ || ns == numeric_system::standard) {
-      auto wday = tm_wday();
-      write1(wday == 0 ? days_per_week : wday);
-    } else {
-      format_localized('u', 'O');
-    }
-  }
-
-  void on_abbr_month() {
-    if (is_classic_)
-      out_ = write(out_, tm_mon_short_name(tm_mon()));
-    else
-      format_localized('b');
-  }
-  void on_full_month() {
-    if (is_classic_)
-      out_ = write(out_, tm_mon_full_name(tm_mon()));
-    else
-      format_localized('B');
-  }
-
-  void on_datetime(numeric_system ns) {
-    if (is_classic_) {
-      on_abbr_weekday();
-      *out_++ = ' ';
-      on_abbr_month();
-      *out_++ = ' ';
-      on_day_of_month_space(numeric_system::standard);
-      *out_++ = ' ';
-      on_iso_time();
-      *out_++ = ' ';
-      on_year(numeric_system::standard);
-    } else {
-      format_localized('c', ns == numeric_system::standard ? '\0' : 'E');
-    }
-  }
-  void on_loc_date(numeric_system ns) {
-    if (is_classic_)
-      on_us_date();
-    else
-      format_localized('x', ns == numeric_system::standard ? '\0' : 'E');
-  }
-  void on_loc_time(numeric_system ns) {
-    if (is_classic_)
-      on_iso_time();
-    else
-      format_localized('X', ns == numeric_system::standard ? '\0' : 'E');
-  }
-  void on_us_date() {
-    char buf[8];
-    write_digit2_separated(buf, to_unsigned(tm_mon() + 1),
-                           to_unsigned(tm_mday()),
-                           to_unsigned(split_year_lower(tm_year())), '/');
-    out_ = copy_str<Char>(std::begin(buf), std::end(buf), out_);
-  }
-  void on_iso_date() {
-    auto year = tm_year();
-    char buf[10];
-    size_t offset = 0;
-    if (year >= 0 && year < 10000) {
-      copy2(buf, digits2(static_cast<size_t>(year / 100)));
-    } else {
-      offset = 4;
-      write_year_extended(year);
-      year = 0;
-    }
-    write_digit2_separated(buf + 2, static_cast<unsigned>(year % 100),
-                           to_unsigned(tm_mon() + 1), to_unsigned(tm_mday()),
-                           '-');
-    out_ = copy_str<Char>(std::begin(buf) + offset, std::end(buf), out_);
-  }
-
-  void on_utc_offset() { format_utc_offset_impl(tm_); }
-  void on_tz_name() { format_tz_name_impl(tm_); }
-
-  void on_year(numeric_system ns) {
-    if (is_classic_ || ns == numeric_system::standard)
-      return write_year(tm_year());
-    format_localized('Y', 'E');
-  }
-  void on_short_year(numeric_system ns) {
-    if (is_classic_ || ns == numeric_system::standard)
-      return write2(split_year_lower(tm_year()));
-    format_localized('y', 'O');
-  }
-  void on_offset_year() {
-    if (is_classic_) return write2(split_year_lower(tm_year()));
-    format_localized('y', 'E');
-  }
-
-  void on_century(numeric_system ns) {
-    if (is_classic_ || ns == numeric_system::standard) {
-      auto year = tm_year();
-      auto upper = year / 100;
-      if (year >= -99 && year < 0) {
-        // Zero upper on negative year.
-        *out_++ = '-';
-        *out_++ = '0';
-      } else if (upper >= 0 && upper < 100) {
-        write2(static_cast<int>(upper));
-      } else {
-        out_ = write<Char>(out_, upper);
-      }
-    } else {
-      format_localized('C', 'E');
-    }
-  }
-
-  void on_dec_month(numeric_system ns) {
-    if (is_classic_ || ns == numeric_system::standard)
-      return write2(tm_mon() + 1);
-    format_localized('m', 'O');
-  }
-
-  void on_dec0_week_of_year(numeric_system ns) {
-    if (is_classic_ || ns == numeric_system::standard)
-      return write2((tm_yday() + days_per_week - tm_wday()) / days_per_week);
-    format_localized('U', 'O');
-  }
-  void on_dec1_week_of_year(numeric_system ns) {
-    if (is_classic_ || ns == numeric_system::standard) {
-      auto wday = tm_wday();
-      write2((tm_yday() + days_per_week -
-              (wday == 0 ? (days_per_week - 1) : (wday - 1))) /
-             days_per_week);
-    } else {
-      format_localized('W', 'O');
-    }
-  }
-  void on_iso_week_of_year(numeric_system ns) {
-    if (is_classic_ || ns == numeric_system::standard)
-      return write2(tm_iso_week_of_year());
-    format_localized('V', 'O');
-  }
-
-  void on_iso_week_based_year() { write_year(tm_iso_week_year()); }
-  void on_iso_week_based_short_year() {
-    write2(split_year_lower(tm_iso_week_year()));
-  }
-
-  void on_day_of_year() {
-    auto yday = tm_yday() + 1;
-    write1(yday / 100);
-    write2(yday % 100);
-  }
-  void on_day_of_month(numeric_system ns) {
-    if (is_classic_ || ns == numeric_system::standard) return write2(tm_mday());
-    format_localized('d', 'O');
-  }
-  void on_day_of_month_space(numeric_system ns) {
-    if (is_classic_ || ns == numeric_system::standard) {
-      auto mday = to_unsigned(tm_mday()) % 100;
-      const char* d2 = digits2(mday);
-      *out_++ = mday < 10 ? ' ' : d2[0];
-      *out_++ = d2[1];
-    } else {
-      format_localized('e', 'O');
-    }
-  }
-
-  void on_24_hour(numeric_system ns) {
-    if (is_classic_ || ns == numeric_system::standard) return write2(tm_hour());
-    format_localized('H', 'O');
-  }
-  void on_12_hour(numeric_system ns) {
-    if (is_classic_ || ns == numeric_system::standard)
-      return write2(tm_hour12());
-    format_localized('I', 'O');
-  }
-  void on_minute(numeric_system ns) {
-    if (is_classic_ || ns == numeric_system::standard) return write2(tm_min());
-    format_localized('M', 'O');
-  }
-  void on_second(numeric_system ns) {
-    if (is_classic_ || ns == numeric_system::standard) return write2(tm_sec());
-    format_localized('S', 'O');
-  }
-
-  void on_12_hour_time() {
-    if (is_classic_) {
-      char buf[8];
-      write_digit2_separated(buf, to_unsigned(tm_hour12()),
-                             to_unsigned(tm_min()), to_unsigned(tm_sec()), ':');
-      out_ = copy_str<Char>(std::begin(buf), std::end(buf), out_);
-      *out_++ = ' ';
-      on_am_pm();
-    } else {
-      format_localized('r');
-    }
-  }
-  void on_24_hour_time() {
-    write2(tm_hour());
-    *out_++ = ':';
-    write2(tm_min());
-  }
-  void on_iso_time() {
-    char buf[8];
-    write_digit2_separated(buf, to_unsigned(tm_hour()), to_unsigned(tm_min()),
-                           to_unsigned(tm_sec()), ':');
-    out_ = copy_str<Char>(std::begin(buf), std::end(buf), out_);
-  }
-
-  void on_am_pm() {
-    if (is_classic_) {
-      *out_++ = tm_hour() < 12 ? 'A' : 'P';
-      *out_++ = 'M';
-    } else {
-      format_localized('p');
-    }
-  }
-
-  // These apply to chrono durations but not tm.
-  void on_duration_value() {}
-  void on_duration_unit() {}
-};
-
-struct chrono_format_checker : null_chrono_spec_handler<chrono_format_checker> {
-  FMT_NORETURN void unsupported() { FMT_THROW(format_error("no date")); }
-
-  template <typename Char>
-  FMT_CONSTEXPR void on_text(const Char*, const Char*) {}
-  FMT_CONSTEXPR void on_24_hour(numeric_system) {}
-  FMT_CONSTEXPR void on_12_hour(numeric_system) {}
-  FMT_CONSTEXPR void on_minute(numeric_system) {}
-  FMT_CONSTEXPR void on_second(numeric_system) {}
-  FMT_CONSTEXPR void on_12_hour_time() {}
-  FMT_CONSTEXPR void on_24_hour_time() {}
-  FMT_CONSTEXPR void on_iso_time() {}
-  FMT_CONSTEXPR void on_am_pm() {}
-  FMT_CONSTEXPR void on_duration_value() {}
-  FMT_CONSTEXPR void on_duration_unit() {}
-};
-
-template <typename T, FMT_ENABLE_IF(std::is_integral<T>::value)>
-inline bool isfinite(T) {
-  return true;
-}
-
-// Converts value to Int and checks that it's in the range [0, upper).
-template <typename T, typename Int, FMT_ENABLE_IF(std::is_integral<T>::value)>
-inline Int to_nonnegative_int(T value, Int upper) {
-  FMT_ASSERT(std::is_unsigned<Int>::value ||
-             (value >= 0 && to_unsigned(value) <= to_unsigned(upper)),
-             "invalid value");
-  (void)upper;
-  return static_cast<Int>(value);
-}
-template <typename T, typename Int, FMT_ENABLE_IF(!std::is_integral<T>::value)>
-inline Int to_nonnegative_int(T value, Int upper) {
-  if (value < 0 || value > static_cast<T>(upper))
-    FMT_THROW(format_error("invalid value"));
-  return static_cast<Int>(value);
-}
-
-template <typename T, FMT_ENABLE_IF(std::is_integral<T>::value)>
-inline T mod(T x, int y) {
-  return x % static_cast<T>(y);
-}
-template <typename T, FMT_ENABLE_IF(std::is_floating_point<T>::value)>
-inline T mod(T x, int y) {
-  return std::fmod(x, static_cast<T>(y));
-}
-
-// If T is an integral type, maps T to its unsigned counterpart, otherwise
-// leaves it unchanged (unlike std::make_unsigned).
-template <typename T, bool INTEGRAL = std::is_integral<T>::value>
-struct make_unsigned_or_unchanged {
-  using type = T;
-};
-
-template <typename T> struct make_unsigned_or_unchanged<T, true> {
-  using type = typename std::make_unsigned<T>::type;
-};
-
-#if FMT_SAFE_DURATION_CAST
-// throwing version of safe_duration_cast
-template <typename To, typename FromRep, typename FromPeriod>
-To fmt_safe_duration_cast(std::chrono::duration<FromRep, FromPeriod> from) {
-  int ec;
-  To to = safe_duration_cast::safe_duration_cast<To>(from, ec);
-  if (ec) FMT_THROW(format_error("cannot format duration"));
-  return to;
-}
-#endif
-
-template <typename Rep, typename Period,
-          FMT_ENABLE_IF(std::is_integral<Rep>::value)>
-inline std::chrono::duration<Rep, std::milli> get_milliseconds(
-    std::chrono::duration<Rep, Period> d) {
-  // this may overflow and/or the result may not fit in the
-  // target type.
-#if FMT_SAFE_DURATION_CAST
-  using CommonSecondsType =
-      typename std::common_type<decltype(d), std::chrono::seconds>::type;
-  const auto d_as_common = fmt_safe_duration_cast<CommonSecondsType>(d);
-  const auto d_as_whole_seconds =
-      fmt_safe_duration_cast<std::chrono::seconds>(d_as_common);
-  // this conversion should be nonproblematic
-  const auto diff = d_as_common - d_as_whole_seconds;
-  const auto ms =
-      fmt_safe_duration_cast<std::chrono::duration<Rep, std::milli>>(diff);
-  return ms;
-#else
-  auto s = std::chrono::duration_cast<std::chrono::seconds>(d);
-  return std::chrono::duration_cast<std::chrono::milliseconds>(d - s);
-#endif
-}
-
-// Counts the number of fractional digits in the range [0, 18] according to the
-// C++20 spec. If more than 18 fractional digits are required then returns 6 for
-// microseconds precision.
-template <long long Num, long long Den, int N = 0,
-          bool Enabled = (N < 19) && (Num <= max_value<long long>() / 10)>
-struct count_fractional_digits {
-  static constexpr int value =
-      Num % Den == 0 ? N : count_fractional_digits<Num * 10, Den, N + 1>::value;
-};
-
-// Base case that doesn't instantiate any more templates
-// in order to avoid overflow.
-template <long long Num, long long Den, int N>
-struct count_fractional_digits<Num, Den, N, false> {
-  static constexpr int value = (Num % Den == 0) ? N : 6;
-};
-
-constexpr long long pow10(std::uint32_t n) {
-  return n == 0 ? 1 : 10 * pow10(n - 1);
-}
-
-template <class Rep, class Period,
-          FMT_ENABLE_IF(std::numeric_limits<Rep>::is_signed)>
-constexpr std::chrono::duration<Rep, Period> abs(
-    std::chrono::duration<Rep, Period> d) {
-  // We need to compare the duration using the count() method directly
-  // due to a compiler bug in clang-11 regarding the spaceship operator,
-  // when -Wzero-as-null-pointer-constant is enabled.
-  // In clang-12 the bug has been fixed. See
-  // https://bugs.llvm.org/show_bug.cgi?id=46235 and the reproducible example:
-  // https://www.godbolt.org/z/Knbb5joYx.
-  return d.count() >= d.zero().count() ? d : -d;
-}
-
-template <class Rep, class Period,
-          FMT_ENABLE_IF(!std::numeric_limits<Rep>::is_signed)>
-constexpr std::chrono::duration<Rep, Period> abs(
-    std::chrono::duration<Rep, Period> d) {
-  return d;
-}
-
-template <typename Char, typename Rep, typename OutputIt,
-          FMT_ENABLE_IF(std::is_integral<Rep>::value)>
-OutputIt format_duration_value(OutputIt out, Rep val, int) {
-  return write<Char>(out, val);
-}
-
-template <typename Char, typename Rep, typename OutputIt,
-          FMT_ENABLE_IF(std::is_floating_point<Rep>::value)>
-OutputIt format_duration_value(OutputIt out, Rep val, int precision) {
-  auto specs = basic_format_specs<Char>();
-  specs.precision = precision;
-  specs.type = precision >= 0 ? presentation_type::fixed_lower
-                              : presentation_type::general_lower;
-  return write<Char>(out, val, specs);
-}
-
-template <typename Char, typename OutputIt>
-OutputIt copy_unit(string_view unit, OutputIt out, Char) {
-  return std::copy(unit.begin(), unit.end(), out);
-}
-
-template <typename OutputIt>
-OutputIt copy_unit(string_view unit, OutputIt out, wchar_t) {
-  // This works when wchar_t is UTF-32 because units only contain characters
-  // that have the same representation in UTF-16 and UTF-32.
-  utf8_to_utf16 u(unit);
-  return std::copy(u.c_str(), u.c_str() + u.size(), out);
-}
-
-template <typename Char, typename Period, typename OutputIt>
-OutputIt format_duration_unit(OutputIt out) {
-  if (const char* unit = get_units<Period>())
-    return copy_unit(string_view(unit), out, Char());
-  *out++ = '[';
-  out = write<Char>(out, Period::num);
-  if (const_check(Period::den != 1)) {
-    *out++ = '/';
-    out = write<Char>(out, Period::den);
-  }
-  *out++ = ']';
-  *out++ = 's';
-  return out;
-}
-
-class get_locale {
- private:
-  union {
-    std::locale locale_;
-  };
-  bool has_locale_ = false;
-
- public:
-  get_locale(bool localized, locale_ref loc) : has_locale_(localized) {
-    if (localized)
-      ::new (&locale_) std::locale(loc.template get<std::locale>());
-  }
-  ~get_locale() {
-    if (has_locale_) locale_.~locale();
-  }
-  operator const std::locale&() const {
-    return has_locale_ ? locale_ : get_classic_locale();
-  }
-};
-
-template <typename FormatContext, typename OutputIt, typename Rep,
-          typename Period>
-struct chrono_formatter {
-  FormatContext& context;
-  OutputIt out;
-  int precision;
-  bool localized = false;
-  // rep is unsigned to avoid overflow.
-  using rep =
-      conditional_t<std::is_integral<Rep>::value && sizeof(Rep) < sizeof(int),
-                    unsigned, typename make_unsigned_or_unchanged<Rep>::type>;
-  rep val;
-  using seconds = std::chrono::duration<rep>;
-  seconds s;
-  using milliseconds = std::chrono::duration<rep, std::milli>;
-  bool negative;
-
-  using char_type = typename FormatContext::char_type;
-  using tm_writer_type = tm_writer<OutputIt, char_type>;
-
-  chrono_formatter(FormatContext& ctx, OutputIt o,
-                   std::chrono::duration<Rep, Period> d)
-      : context(ctx),
-        out(o),
-        val(static_cast<rep>(d.count())),
-        negative(false) {
-    if (d.count() < 0) {
-      val = 0 - val;
-      negative = true;
-    }
-
-    // this may overflow and/or the result may not fit in the
-    // target type.
-#if FMT_SAFE_DURATION_CAST
-    // might need checked conversion (rep!=Rep)
-    auto tmpval = std::chrono::duration<rep, Period>(val);
-    s = fmt_safe_duration_cast<seconds>(tmpval);
-#else
-    s = std::chrono::duration_cast<seconds>(
-        std::chrono::duration<rep, Period>(val));
-#endif
-  }
-
-  // returns true if nan or inf, writes to out.
-  bool handle_nan_inf() {
-    if (isfinite(val)) {
-      return false;
-    }
-    if (isnan(val)) {
-      write_nan();
-      return true;
-    }
-    // must be +-inf
-    if (val > 0) {
-      write_pinf();
-    } else {
-      write_ninf();
-    }
-    return true;
-  }
-
-  Rep hour() const { return static_cast<Rep>(mod((s.count() / 3600), 24)); }
-
-  Rep hour12() const {
-    Rep hour = static_cast<Rep>(mod((s.count() / 3600), 12));
-    return hour <= 0 ? 12 : hour;
-  }
-
-  Rep minute() const { return static_cast<Rep>(mod((s.count() / 60), 60)); }
-  Rep second() const { return static_cast<Rep>(mod(s.count(), 60)); }
-
-  std::tm time() const {
-    auto time = std::tm();
-    time.tm_hour = to_nonnegative_int(hour(), 24);
-    time.tm_min = to_nonnegative_int(minute(), 60);
-    time.tm_sec = to_nonnegative_int(second(), 60);
-    return time;
-  }
-
-  void write_sign() {
-    if (negative) {
-      *out++ = '-';
-      negative = false;
-    }
-  }
-
-  void write(Rep value, int width) {
-    write_sign();
-    if (isnan(value)) return write_nan();
-    uint32_or_64_or_128_t<int> n =
-        to_unsigned(to_nonnegative_int(value, max_value<int>()));
-    int num_digits = detail::count_digits(n);
-    if (width > num_digits) out = std::fill_n(out, width - num_digits, '0');
-    out = format_decimal<char_type>(out, n, num_digits).end;
-  }
-
-  template <typename Duration> void write_fractional_seconds(Duration d) {
-    FMT_ASSERT(!std::is_floating_point<typename Duration::rep>::value, "");
-    constexpr auto num_fractional_digits =
-        count_fractional_digits<Duration::period::num,
-                                Duration::period::den>::value;
-
-    using subsecond_precision = std::chrono::duration<
-        typename std::common_type<typename Duration::rep,
-                                  std::chrono::seconds::rep>::type,
-        std::ratio<1, detail::pow10(num_fractional_digits)>>;
-    if (std::ratio_less<typename subsecond_precision::period,
-                        std::chrono::seconds::period>::value) {
-      *out++ = '.';
-      auto fractional =
-          detail::abs(d) - std::chrono::duration_cast<std::chrono::seconds>(d);
-      auto subseconds =
-          std::chrono::treat_as_floating_point<
-              typename subsecond_precision::rep>::value
-              ? fractional.count()
-              : std::chrono::duration_cast<subsecond_precision>(fractional)
-                    .count();
-      uint32_or_64_or_128_t<long long> n =
-          to_unsigned(to_nonnegative_int(subseconds, max_value<long long>()));
-      int num_digits = detail::count_digits(n);
-      if (num_fractional_digits > num_digits)
-        out = std::fill_n(out, num_fractional_digits - num_digits, '0');
-      out = format_decimal<char_type>(out, n, num_digits).end;
-    }
-  }
-
-  void write_nan() { std::copy_n("nan", 3, out); }
-  void write_pinf() { std::copy_n("inf", 3, out); }
-  void write_ninf() { std::copy_n("-inf", 4, out); }
-
-  template <typename Callback, typename... Args>
-  void format_tm(const tm& time, Callback cb, Args... args) {
-    if (isnan(val)) return write_nan();
-    get_locale loc(localized, context.locale());
-    auto w = tm_writer_type(loc, out, time);
-    (w.*cb)(args...);
-    out = w.out();
-  }
-
-  void on_text(const char_type* begin, const char_type* end) {
-    std::copy(begin, end, out);
-  }
-
-  // These are not implemented because durations don't have date information.
-  void on_abbr_weekday() {}
-  void on_full_weekday() {}
-  void on_dec0_weekday(numeric_system) {}
-  void on_dec1_weekday(numeric_system) {}
-  void on_abbr_month() {}
-  void on_full_month() {}
-  void on_datetime(numeric_system) {}
-  void on_loc_date(numeric_system) {}
-  void on_loc_time(numeric_system) {}
-  void on_us_date() {}
-  void on_iso_date() {}
-  void on_utc_offset() {}
-  void on_tz_name() {}
-  void on_year(numeric_system) {}
-  void on_short_year(numeric_system) {}
-  void on_offset_year() {}
-  void on_century(numeric_system) {}
-  void on_iso_week_based_year() {}
-  void on_iso_week_based_short_year() {}
-  void on_dec_month(numeric_system) {}
-  void on_dec0_week_of_year(numeric_system) {}
-  void on_dec1_week_of_year(numeric_system) {}
-  void on_iso_week_of_year(numeric_system) {}
-  void on_day_of_year() {}
-  void on_day_of_month(numeric_system) {}
-  void on_day_of_month_space(numeric_system) {}
-
-  void on_24_hour(numeric_system ns) {
-    if (handle_nan_inf()) return;
-
-    if (ns == numeric_system::standard) return write(hour(), 2);
-    auto time = tm();
-    time.tm_hour = to_nonnegative_int(hour(), 24);
-    format_tm(time, &tm_writer_type::on_24_hour, ns);
-  }
-
-  void on_12_hour(numeric_system ns) {
-    if (handle_nan_inf()) return;
-
-    if (ns == numeric_system::standard) return write(hour12(), 2);
-    auto time = tm();
-    time.tm_hour = to_nonnegative_int(hour12(), 12);
-    format_tm(time, &tm_writer_type::on_12_hour, ns);
-  }
-
-  void on_minute(numeric_system ns) {
-    if (handle_nan_inf()) return;
-
-    if (ns == numeric_system::standard) return write(minute(), 2);
-    auto time = tm();
-    time.tm_min = to_nonnegative_int(minute(), 60);
-    format_tm(time, &tm_writer_type::on_minute, ns);
-  }
-
-  void on_second(numeric_system ns) {
-    if (handle_nan_inf()) return;
-
-    if (ns == numeric_system::standard) {
-      if (std::is_floating_point<rep>::value) {
-        constexpr auto num_fractional_digits =
-            count_fractional_digits<Period::num, Period::den>::value;
-        auto buf = memory_buffer();
-        format_to(std::back_inserter(buf), runtime("{:.{}f}"),
-                  std::fmod(val * static_cast<rep>(Period::num) /
-                                static_cast<rep>(Period::den),
-                            static_cast<rep>(60)),
-                  num_fractional_digits);
-        if (negative) *out++ = '-';
-        if (buf.size() < 2 || buf[1] == '.') *out++ = '0';
-        out = std::copy(buf.begin(), buf.end(), out);
-      } else {
-        write(second(), 2);
-        write_fractional_seconds(std::chrono::duration<rep, Period>(val));
-      }
-      return;
-    }
-    auto time = tm();
-    time.tm_sec = to_nonnegative_int(second(), 60);
-    format_tm(time, &tm_writer_type::on_second, ns);
-  }
-
-  void on_12_hour_time() {
-    if (handle_nan_inf()) return;
-    format_tm(time(), &tm_writer_type::on_12_hour_time);
-  }
-
-  void on_24_hour_time() {
-    if (handle_nan_inf()) {
-      *out++ = ':';
-      handle_nan_inf();
-      return;
-    }
-
-    write(hour(), 2);
-    *out++ = ':';
-    write(minute(), 2);
-  }
-
-  void on_iso_time() {
-    on_24_hour_time();
-    *out++ = ':';
-    if (handle_nan_inf()) return;
-    on_second(numeric_system::standard);
-  }
-
-  void on_am_pm() {
-    if (handle_nan_inf()) return;
-    format_tm(time(), &tm_writer_type::on_am_pm);
-  }
-
-  void on_duration_value() {
-    if (handle_nan_inf()) return;
-    write_sign();
-    out = format_duration_value<char_type>(out, val, precision);
-  }
-
-  void on_duration_unit() {
-    out = format_duration_unit<char_type, Period>(out);
-  }
-};
-
-FMT_END_DETAIL_NAMESPACE
-
-#if defined(__cpp_lib_chrono) && __cpp_lib_chrono >= 201907
-using weekday = std::chrono::weekday;
-#else
-// A fallback version of weekday.
-class weekday {
- private:
-  unsigned char value;
-
- public:
-  weekday() = default;
-  explicit constexpr weekday(unsigned wd) noexcept
-      : value(static_cast<unsigned char>(wd != 7 ? wd : 0)) {}
-  constexpr unsigned c_encoding() const noexcept { return value; }
-};
-
-class year_month_day {};
-#endif
-
-// A rudimentary weekday formatter.
-template <typename Char> struct formatter<weekday, Char> {
- private:
-  bool localized = false;
-
- public:
-  FMT_CONSTEXPR auto parse(basic_format_parse_context<Char>& ctx)
-      -> decltype(ctx.begin()) {
-    auto begin = ctx.begin(), end = ctx.end();
-    if (begin != end && *begin == 'L') {
-      ++begin;
-      localized = true;
-    }
-    return begin;
-  }
-
-  template <typename FormatContext>
-  auto format(weekday wd, FormatContext& ctx) const -> decltype(ctx.out()) {
-    auto time = std::tm();
-    time.tm_wday = static_cast<int>(wd.c_encoding());
-    detail::get_locale loc(localized, ctx.locale());
-    auto w = detail::tm_writer<decltype(ctx.out()), Char>(loc, ctx.out(), time);
-    w.on_abbr_weekday();
-    return w.out();
-  }
-};
-
-template <typename Rep, typename Period, typename Char>
-struct formatter<std::chrono::duration<Rep, Period>, Char> {
- private:
-  basic_format_specs<Char> specs;
-  int precision = -1;
-  using arg_ref_type = detail::arg_ref<Char>;
-  arg_ref_type width_ref;
-  arg_ref_type precision_ref;
-  bool localized = false;
-  basic_string_view<Char> format_str;
-  using duration = std::chrono::duration<Rep, Period>;
-
-  struct spec_handler {
-    formatter& f;
-    basic_format_parse_context<Char>& context;
-    basic_string_view<Char> format_str;
-
-    template <typename Id> FMT_CONSTEXPR arg_ref_type make_arg_ref(Id arg_id) {
-      context.check_arg_id(arg_id);
-      return arg_ref_type(arg_id);
-    }
-
-    FMT_CONSTEXPR arg_ref_type make_arg_ref(basic_string_view<Char> arg_id) {
-      context.check_arg_id(arg_id);
-      return arg_ref_type(arg_id);
-    }
-
-    FMT_CONSTEXPR arg_ref_type make_arg_ref(detail::auto_id) {
-      return arg_ref_type(context.next_arg_id());
-    }
-
-    void on_error(const char* msg) { FMT_THROW(format_error(msg)); }
-    FMT_CONSTEXPR void on_fill(basic_string_view<Char> fill) {
-      f.specs.fill = fill;
-    }
-    FMT_CONSTEXPR void on_align(align_t align) { f.specs.align = align; }
-    FMT_CONSTEXPR void on_width(int width) { f.specs.width = width; }
-    FMT_CONSTEXPR void on_precision(int _precision) {
-      f.precision = _precision;
-    }
-    FMT_CONSTEXPR void end_precision() {}
-
-    template <typename Id> FMT_CONSTEXPR void on_dynamic_width(Id arg_id) {
-      f.width_ref = make_arg_ref(arg_id);
-    }
-
-    template <typename Id> FMT_CONSTEXPR void on_dynamic_precision(Id arg_id) {
-      f.precision_ref = make_arg_ref(arg_id);
-    }
-  };
-
-  using iterator = typename basic_format_parse_context<Char>::iterator;
-  struct parse_range {
-    iterator begin;
-    iterator end;
-  };
-
-  FMT_CONSTEXPR parse_range do_parse(basic_format_parse_context<Char>& ctx) {
-    auto begin = ctx.begin(), end = ctx.end();
-    if (begin == end || *begin == '}') return {begin, begin};
-    spec_handler handler{*this, ctx, format_str};
-    begin = detail::parse_align(begin, end, handler);
-    if (begin == end) return {begin, begin};
-    begin = detail::parse_width(begin, end, handler);
-    if (begin == end) return {begin, begin};
-    if (*begin == '.') {
-      if (std::is_floating_point<Rep>::value)
-        begin = detail::parse_precision(begin, end, handler);
-      else
-        handler.on_error("precision not allowed for this argument type");
-    }
-    if (begin != end && *begin == 'L') {
-      ++begin;
-      localized = true;
-    }
-    end = detail::parse_chrono_format(begin, end,
-                                      detail::chrono_format_checker());
-    return {begin, end};
-  }
-
- public:
-  FMT_CONSTEXPR auto parse(basic_format_parse_context<Char>& ctx)
-      -> decltype(ctx.begin()) {
-    auto range = do_parse(ctx);
-    format_str = basic_string_view<Char>(
-        &*range.begin, detail::to_unsigned(range.end - range.begin));
-    return range.end;
-  }
-
-  template <typename FormatContext>
-  auto format(const duration& d, FormatContext& ctx) const
-      -> decltype(ctx.out()) {
-    auto specs_copy = specs;
-    auto precision_copy = precision;
-    auto begin = format_str.begin(), end = format_str.end();
-    // As a possible future optimization, we could avoid extra copying if width
-    // is not specified.
-    basic_memory_buffer<Char> buf;
-    auto out = std::back_inserter(buf);
-    detail::handle_dynamic_spec<detail::width_checker>(specs_copy.width,
-                                                       width_ref, ctx);
-    detail::handle_dynamic_spec<detail::precision_checker>(precision_copy,
-                                                           precision_ref, ctx);
-    if (begin == end || *begin == '}') {
-      out = detail::format_duration_value<Char>(out, d.count(), precision_copy);
-      detail::format_duration_unit<Char, Period>(out);
-    } else {
-      detail::chrono_formatter<FormatContext, decltype(out), Rep, Period> f(
-          ctx, out, d);
-      f.precision = precision_copy;
-      f.localized = localized;
-      detail::parse_chrono_format(begin, end, f);
-    }
-    return detail::write(
-        ctx.out(), basic_string_view<Char>(buf.data(), buf.size()), specs_copy);
-  }
-};
-
-template <typename Char, typename Duration>
-struct formatter<std::chrono::time_point<std::chrono::system_clock, Duration>,
-                 Char> : formatter<std::tm, Char> {
-  FMT_CONSTEXPR formatter() {
-    basic_string_view<Char> default_specs =
-        detail::string_literal<Char, '%', 'F', ' ', '%', 'T'>{};
-    this->do_parse(default_specs.begin(), default_specs.end());
-  }
-
-  template <typename FormatContext>
-  auto format(std::chrono::time_point<std::chrono::system_clock> val,
-              FormatContext& ctx) const -> decltype(ctx.out()) {
-    return formatter<std::tm, Char>::format(localtime(val), ctx);
-  }
-};
-
-template <typename Char> struct formatter<std::tm, Char> {
- private:
-  enum class spec {
-    unknown,
-    year_month_day,
-    hh_mm_ss,
-  };
-  spec spec_ = spec::unknown;
-  basic_string_view<Char> specs;
-
- protected:
-  template <typename It> FMT_CONSTEXPR auto do_parse(It begin, It end) -> It {
-    if (begin != end && *begin == ':') ++begin;
-    end = detail::parse_chrono_format(begin, end, detail::tm_format_checker());
-    // Replace default spec only if the new spec is not empty.
-    if (end != begin) specs = {begin, detail::to_unsigned(end - begin)};
-    return end;
-  }
-
- public:
-  FMT_CONSTEXPR auto parse(basic_format_parse_context<Char>& ctx)
-      -> decltype(ctx.begin()) {
-    auto end = this->do_parse(ctx.begin(), ctx.end());
-    // basic_string_view<>::compare isn't constexpr before C++17.
-    if (specs.size() == 2 && specs[0] == Char('%')) {
-      if (specs[1] == Char('F'))
-        spec_ = spec::year_month_day;
-      else if (specs[1] == Char('T'))
-        spec_ = spec::hh_mm_ss;
-    }
-    return end;
-  }
-
-  template <typename FormatContext>
-  auto format(const std::tm& tm, FormatContext& ctx) const
-      -> decltype(ctx.out()) {
-    const auto loc_ref = ctx.locale();
-    detail::get_locale loc(static_cast<bool>(loc_ref), loc_ref);
-    auto w = detail::tm_writer<decltype(ctx.out()), Char>(loc, ctx.out(), tm);
-    if (spec_ == spec::year_month_day)
-      w.on_iso_date();
-    else if (spec_ == spec::hh_mm_ss)
-      w.on_iso_time();
-    else
-      detail::parse_chrono_format(specs.begin(), specs.end(), w);
-    return w.out();
-  }
-};
-
-FMT_MODULE_EXPORT_END
-FMT_END_NAMESPACE
-
-#endif  // FMT_CHRONO_H_
diff --git a/Externals/fmt/include/fmt/color.h b/Externals/fmt/include/fmt/color.h
deleted file mode 100755
index 4c163277ef18..000000000000
--- a/Externals/fmt/include/fmt/color.h
+++ /dev/null
@@ -1,651 +0,0 @@
-// Formatting library for C++ - color support
-//
-// Copyright (c) 2018 - present, Victor Zverovich and fmt contributors
-// All rights reserved.
-//
-// For the license information refer to format.h.
-
-#ifndef FMT_COLOR_H_
-#define FMT_COLOR_H_
-
-#include "format.h"
-
-FMT_BEGIN_NAMESPACE
-FMT_MODULE_EXPORT_BEGIN
-
-enum class color : uint32_t {
-  alice_blue = 0xF0F8FF,               // rgb(240,248,255)
-  antique_white = 0xFAEBD7,            // rgb(250,235,215)
-  aqua = 0x00FFFF,                     // rgb(0,255,255)
-  aquamarine = 0x7FFFD4,               // rgb(127,255,212)
-  azure = 0xF0FFFF,                    // rgb(240,255,255)
-  beige = 0xF5F5DC,                    // rgb(245,245,220)
-  bisque = 0xFFE4C4,                   // rgb(255,228,196)
-  black = 0x000000,                    // rgb(0,0,0)
-  blanched_almond = 0xFFEBCD,          // rgb(255,235,205)
-  blue = 0x0000FF,                     // rgb(0,0,255)
-  blue_violet = 0x8A2BE2,              // rgb(138,43,226)
-  brown = 0xA52A2A,                    // rgb(165,42,42)
-  burly_wood = 0xDEB887,               // rgb(222,184,135)
-  cadet_blue = 0x5F9EA0,               // rgb(95,158,160)
-  chartreuse = 0x7FFF00,               // rgb(127,255,0)
-  chocolate = 0xD2691E,                // rgb(210,105,30)
-  coral = 0xFF7F50,                    // rgb(255,127,80)
-  cornflower_blue = 0x6495ED,          // rgb(100,149,237)
-  cornsilk = 0xFFF8DC,                 // rgb(255,248,220)
-  crimson = 0xDC143C,                  // rgb(220,20,60)
-  cyan = 0x00FFFF,                     // rgb(0,255,255)
-  dark_blue = 0x00008B,                // rgb(0,0,139)
-  dark_cyan = 0x008B8B,                // rgb(0,139,139)
-  dark_golden_rod = 0xB8860B,          // rgb(184,134,11)
-  dark_gray = 0xA9A9A9,                // rgb(169,169,169)
-  dark_green = 0x006400,               // rgb(0,100,0)
-  dark_khaki = 0xBDB76B,               // rgb(189,183,107)
-  dark_magenta = 0x8B008B,             // rgb(139,0,139)
-  dark_olive_green = 0x556B2F,         // rgb(85,107,47)
-  dark_orange = 0xFF8C00,              // rgb(255,140,0)
-  dark_orchid = 0x9932CC,              // rgb(153,50,204)
-  dark_red = 0x8B0000,                 // rgb(139,0,0)
-  dark_salmon = 0xE9967A,              // rgb(233,150,122)
-  dark_sea_green = 0x8FBC8F,           // rgb(143,188,143)
-  dark_slate_blue = 0x483D8B,          // rgb(72,61,139)
-  dark_slate_gray = 0x2F4F4F,          // rgb(47,79,79)
-  dark_turquoise = 0x00CED1,           // rgb(0,206,209)
-  dark_violet = 0x9400D3,              // rgb(148,0,211)
-  deep_pink = 0xFF1493,                // rgb(255,20,147)
-  deep_sky_blue = 0x00BFFF,            // rgb(0,191,255)
-  dim_gray = 0x696969,                 // rgb(105,105,105)
-  dodger_blue = 0x1E90FF,              // rgb(30,144,255)
-  fire_brick = 0xB22222,               // rgb(178,34,34)
-  floral_white = 0xFFFAF0,             // rgb(255,250,240)
-  forest_green = 0x228B22,             // rgb(34,139,34)
-  fuchsia = 0xFF00FF,                  // rgb(255,0,255)
-  gainsboro = 0xDCDCDC,                // rgb(220,220,220)
-  ghost_white = 0xF8F8FF,              // rgb(248,248,255)
-  gold = 0xFFD700,                     // rgb(255,215,0)
-  golden_rod = 0xDAA520,               // rgb(218,165,32)
-  gray = 0x808080,                     // rgb(128,128,128)
-  green = 0x008000,                    // rgb(0,128,0)
-  green_yellow = 0xADFF2F,             // rgb(173,255,47)
-  honey_dew = 0xF0FFF0,                // rgb(240,255,240)
-  hot_pink = 0xFF69B4,                 // rgb(255,105,180)
-  indian_red = 0xCD5C5C,               // rgb(205,92,92)
-  indigo = 0x4B0082,                   // rgb(75,0,130)
-  ivory = 0xFFFFF0,                    // rgb(255,255,240)
-  khaki = 0xF0E68C,                    // rgb(240,230,140)
-  lavender = 0xE6E6FA,                 // rgb(230,230,250)
-  lavender_blush = 0xFFF0F5,           // rgb(255,240,245)
-  lawn_green = 0x7CFC00,               // rgb(124,252,0)
-  lemon_chiffon = 0xFFFACD,            // rgb(255,250,205)
-  light_blue = 0xADD8E6,               // rgb(173,216,230)
-  light_coral = 0xF08080,              // rgb(240,128,128)
-  light_cyan = 0xE0FFFF,               // rgb(224,255,255)
-  light_golden_rod_yellow = 0xFAFAD2,  // rgb(250,250,210)
-  light_gray = 0xD3D3D3,               // rgb(211,211,211)
-  light_green = 0x90EE90,              // rgb(144,238,144)
-  light_pink = 0xFFB6C1,               // rgb(255,182,193)
-  light_salmon = 0xFFA07A,             // rgb(255,160,122)
-  light_sea_green = 0x20B2AA,          // rgb(32,178,170)
-  light_sky_blue = 0x87CEFA,           // rgb(135,206,250)
-  light_slate_gray = 0x778899,         // rgb(119,136,153)
-  light_steel_blue = 0xB0C4DE,         // rgb(176,196,222)
-  light_yellow = 0xFFFFE0,             // rgb(255,255,224)
-  lime = 0x00FF00,                     // rgb(0,255,0)
-  lime_green = 0x32CD32,               // rgb(50,205,50)
-  linen = 0xFAF0E6,                    // rgb(250,240,230)
-  magenta = 0xFF00FF,                  // rgb(255,0,255)
-  maroon = 0x800000,                   // rgb(128,0,0)
-  medium_aquamarine = 0x66CDAA,        // rgb(102,205,170)
-  medium_blue = 0x0000CD,              // rgb(0,0,205)
-  medium_orchid = 0xBA55D3,            // rgb(186,85,211)
-  medium_purple = 0x9370DB,            // rgb(147,112,219)
-  medium_sea_green = 0x3CB371,         // rgb(60,179,113)
-  medium_slate_blue = 0x7B68EE,        // rgb(123,104,238)
-  medium_spring_green = 0x00FA9A,      // rgb(0,250,154)
-  medium_turquoise = 0x48D1CC,         // rgb(72,209,204)
-  medium_violet_red = 0xC71585,        // rgb(199,21,133)
-  midnight_blue = 0x191970,            // rgb(25,25,112)
-  mint_cream = 0xF5FFFA,               // rgb(245,255,250)
-  misty_rose = 0xFFE4E1,               // rgb(255,228,225)
-  moccasin = 0xFFE4B5,                 // rgb(255,228,181)
-  navajo_white = 0xFFDEAD,             // rgb(255,222,173)
-  navy = 0x000080,                     // rgb(0,0,128)
-  old_lace = 0xFDF5E6,                 // rgb(253,245,230)
-  olive = 0x808000,                    // rgb(128,128,0)
-  olive_drab = 0x6B8E23,               // rgb(107,142,35)
-  orange = 0xFFA500,                   // rgb(255,165,0)
-  orange_red = 0xFF4500,               // rgb(255,69,0)
-  orchid = 0xDA70D6,                   // rgb(218,112,214)
-  pale_golden_rod = 0xEEE8AA,          // rgb(238,232,170)
-  pale_green = 0x98FB98,               // rgb(152,251,152)
-  pale_turquoise = 0xAFEEEE,           // rgb(175,238,238)
-  pale_violet_red = 0xDB7093,          // rgb(219,112,147)
-  papaya_whip = 0xFFEFD5,              // rgb(255,239,213)
-  peach_puff = 0xFFDAB9,               // rgb(255,218,185)
-  peru = 0xCD853F,                     // rgb(205,133,63)
-  pink = 0xFFC0CB,                     // rgb(255,192,203)
-  plum = 0xDDA0DD,                     // rgb(221,160,221)
-  powder_blue = 0xB0E0E6,              // rgb(176,224,230)
-  purple = 0x800080,                   // rgb(128,0,128)
-  rebecca_purple = 0x663399,           // rgb(102,51,153)
-  red = 0xFF0000,                      // rgb(255,0,0)
-  rosy_brown = 0xBC8F8F,               // rgb(188,143,143)
-  royal_blue = 0x4169E1,               // rgb(65,105,225)
-  saddle_brown = 0x8B4513,             // rgb(139,69,19)
-  salmon = 0xFA8072,                   // rgb(250,128,114)
-  sandy_brown = 0xF4A460,              // rgb(244,164,96)
-  sea_green = 0x2E8B57,                // rgb(46,139,87)
-  sea_shell = 0xFFF5EE,                // rgb(255,245,238)
-  sienna = 0xA0522D,                   // rgb(160,82,45)
-  silver = 0xC0C0C0,                   // rgb(192,192,192)
-  sky_blue = 0x87CEEB,                 // rgb(135,206,235)
-  slate_blue = 0x6A5ACD,               // rgb(106,90,205)
-  slate_gray = 0x708090,               // rgb(112,128,144)
-  snow = 0xFFFAFA,                     // rgb(255,250,250)
-  spring_green = 0x00FF7F,             // rgb(0,255,127)
-  steel_blue = 0x4682B4,               // rgb(70,130,180)
-  tan = 0xD2B48C,                      // rgb(210,180,140)
-  teal = 0x008080,                     // rgb(0,128,128)
-  thistle = 0xD8BFD8,                  // rgb(216,191,216)
-  tomato = 0xFF6347,                   // rgb(255,99,71)
-  turquoise = 0x40E0D0,                // rgb(64,224,208)
-  violet = 0xEE82EE,                   // rgb(238,130,238)
-  wheat = 0xF5DEB3,                    // rgb(245,222,179)
-  white = 0xFFFFFF,                    // rgb(255,255,255)
-  white_smoke = 0xF5F5F5,              // rgb(245,245,245)
-  yellow = 0xFFFF00,                   // rgb(255,255,0)
-  yellow_green = 0x9ACD32              // rgb(154,205,50)
-};                                     // enum class color
-
-enum class terminal_color : uint8_t {
-  black = 30,
-  red,
-  green,
-  yellow,
-  blue,
-  magenta,
-  cyan,
-  white,
-  bright_black = 90,
-  bright_red,
-  bright_green,
-  bright_yellow,
-  bright_blue,
-  bright_magenta,
-  bright_cyan,
-  bright_white
-};
-
-enum class emphasis : uint8_t {
-  bold = 1,
-  faint = 1 << 1,
-  italic = 1 << 2,
-  underline = 1 << 3,
-  blink = 1 << 4,
-  reverse = 1 << 5,
-  conceal = 1 << 6,
-  strikethrough = 1 << 7,
-};
-
-// rgb is a struct for red, green and blue colors.
-// Using the name "rgb" makes some editors show the color in a tooltip.
-struct rgb {
-  FMT_CONSTEXPR rgb() : r(0), g(0), b(0) {}
-  FMT_CONSTEXPR rgb(uint8_t r_, uint8_t g_, uint8_t b_) : r(r_), g(g_), b(b_) {}
-  FMT_CONSTEXPR rgb(uint32_t hex)
-      : r((hex >> 16) & 0xFF), g((hex >> 8) & 0xFF), b(hex & 0xFF) {}
-  FMT_CONSTEXPR rgb(color hex)
-      : r((uint32_t(hex) >> 16) & 0xFF),
-        g((uint32_t(hex) >> 8) & 0xFF),
-        b(uint32_t(hex) & 0xFF) {}
-  uint8_t r;
-  uint8_t g;
-  uint8_t b;
-};
-
-FMT_BEGIN_DETAIL_NAMESPACE
-
-// color is a struct of either a rgb color or a terminal color.
-struct color_type {
-  FMT_CONSTEXPR color_type() noexcept : is_rgb(), value{} {}
-  FMT_CONSTEXPR color_type(color rgb_color) noexcept : is_rgb(true), value{} {
-    value.rgb_color = static_cast<uint32_t>(rgb_color);
-  }
-  FMT_CONSTEXPR color_type(rgb rgb_color) noexcept : is_rgb(true), value{} {
-    value.rgb_color = (static_cast<uint32_t>(rgb_color.r) << 16) |
-                      (static_cast<uint32_t>(rgb_color.g) << 8) | rgb_color.b;
-  }
-  FMT_CONSTEXPR color_type(terminal_color term_color) noexcept
-      : is_rgb(), value{} {
-    value.term_color = static_cast<uint8_t>(term_color);
-  }
-  bool is_rgb;
-  union color_union {
-    uint8_t term_color;
-    uint32_t rgb_color;
-  } value;
-};
-
-FMT_END_DETAIL_NAMESPACE
-
-/** A text style consisting of foreground and background colors and emphasis. */
-class text_style {
- public:
-  FMT_CONSTEXPR text_style(emphasis em = emphasis()) noexcept
-      : set_foreground_color(), set_background_color(), ems(em) {}
-
-  FMT_CONSTEXPR text_style& operator|=(const text_style& rhs) {
-    if (!set_foreground_color) {
-      set_foreground_color = rhs.set_foreground_color;
-      foreground_color = rhs.foreground_color;
-    } else if (rhs.set_foreground_color) {
-      if (!foreground_color.is_rgb || !rhs.foreground_color.is_rgb)
-        FMT_THROW(format_error("can't OR a terminal color"));
-      foreground_color.value.rgb_color |= rhs.foreground_color.value.rgb_color;
-    }
-
-    if (!set_background_color) {
-      set_background_color = rhs.set_background_color;
-      background_color = rhs.background_color;
-    } else if (rhs.set_background_color) {
-      if (!background_color.is_rgb || !rhs.background_color.is_rgb)
-        FMT_THROW(format_error("can't OR a terminal color"));
-      background_color.value.rgb_color |= rhs.background_color.value.rgb_color;
-    }
-
-    ems = static_cast<emphasis>(static_cast<uint8_t>(ems) |
-                                static_cast<uint8_t>(rhs.ems));
-    return *this;
-  }
-
-  friend FMT_CONSTEXPR text_style operator|(text_style lhs,
-                                            const text_style& rhs) {
-    return lhs |= rhs;
-  }
-
-  FMT_CONSTEXPR bool has_foreground() const noexcept {
-    return set_foreground_color;
-  }
-  FMT_CONSTEXPR bool has_background() const noexcept {
-    return set_background_color;
-  }
-  FMT_CONSTEXPR bool has_emphasis() const noexcept {
-    return static_cast<uint8_t>(ems) != 0;
-  }
-  FMT_CONSTEXPR detail::color_type get_foreground() const noexcept {
-    FMT_ASSERT(has_foreground(), "no foreground specified for this style");
-    return foreground_color;
-  }
-  FMT_CONSTEXPR detail::color_type get_background() const noexcept {
-    FMT_ASSERT(has_background(), "no background specified for this style");
-    return background_color;
-  }
-  FMT_CONSTEXPR emphasis get_emphasis() const noexcept {
-    FMT_ASSERT(has_emphasis(), "no emphasis specified for this style");
-    return ems;
-  }
-
- private:
-  FMT_CONSTEXPR text_style(bool is_foreground,
-                           detail::color_type text_color) noexcept
-      : set_foreground_color(), set_background_color(), ems() {
-    if (is_foreground) {
-      foreground_color = text_color;
-      set_foreground_color = true;
-    } else {
-      background_color = text_color;
-      set_background_color = true;
-    }
-  }
-
-  friend FMT_CONSTEXPR text_style fg(detail::color_type foreground) noexcept;
-
-  friend FMT_CONSTEXPR text_style bg(detail::color_type background) noexcept;
-
-  detail::color_type foreground_color;
-  detail::color_type background_color;
-  bool set_foreground_color;
-  bool set_background_color;
-  emphasis ems;
-};
-
-/** Creates a text style from the foreground (text) color. */
-FMT_CONSTEXPR inline text_style fg(detail::color_type foreground) noexcept {
-  return text_style(true, foreground);
-}
-
-/** Creates a text style from the background color. */
-FMT_CONSTEXPR inline text_style bg(detail::color_type background) noexcept {
-  return text_style(false, background);
-}
-
-FMT_CONSTEXPR inline text_style operator|(emphasis lhs, emphasis rhs) noexcept {
-  return text_style(lhs) | rhs;
-}
-
-FMT_BEGIN_DETAIL_NAMESPACE
-
-template <typename Char> struct ansi_color_escape {
-  FMT_CONSTEXPR ansi_color_escape(detail::color_type text_color,
-                                  const char* esc) noexcept {
-    // If we have a terminal color, we need to output another escape code
-    // sequence.
-    if (!text_color.is_rgb) {
-      bool is_background = esc == string_view("\x1b[48;2;");
-      uint32_t value = text_color.value.term_color;
-      // Background ASCII codes are the same as the foreground ones but with
-      // 10 more.
-      if (is_background) value += 10u;
-
-      size_t index = 0;
-      buffer[index++] = static_cast<Char>('\x1b');
-      buffer[index++] = static_cast<Char>('[');
-
-      if (value >= 100u) {
-        buffer[index++] = static_cast<Char>('1');
-        value %= 100u;
-      }
-      buffer[index++] = static_cast<Char>('0' + value / 10u);
-      buffer[index++] = static_cast<Char>('0' + value % 10u);
-
-      buffer[index++] = static_cast<Char>('m');
-      buffer[index++] = static_cast<Char>('\0');
-      return;
-    }
-
-    for (int i = 0; i < 7; i++) {
-      buffer[i] = static_cast<Char>(esc[i]);
-    }
-    rgb color(text_color.value.rgb_color);
-    to_esc(color.r, buffer + 7, ';');
-    to_esc(color.g, buffer + 11, ';');
-    to_esc(color.b, buffer + 15, 'm');
-    buffer[19] = static_cast<Char>(0);
-  }
-  FMT_CONSTEXPR ansi_color_escape(emphasis em) noexcept {
-    uint8_t em_codes[num_emphases] = {};
-    if (has_emphasis(em, emphasis::bold)) em_codes[0] = 1;
-    if (has_emphasis(em, emphasis::faint)) em_codes[1] = 2;
-    if (has_emphasis(em, emphasis::italic)) em_codes[2] = 3;
-    if (has_emphasis(em, emphasis::underline)) em_codes[3] = 4;
-    if (has_emphasis(em, emphasis::blink)) em_codes[4] = 5;
-    if (has_emphasis(em, emphasis::reverse)) em_codes[5] = 7;
-    if (has_emphasis(em, emphasis::conceal)) em_codes[6] = 8;
-    if (has_emphasis(em, emphasis::strikethrough)) em_codes[7] = 9;
-
-    size_t index = 0;
-    for (size_t i = 0; i < num_emphases; ++i) {
-      if (!em_codes[i]) continue;
-      buffer[index++] = static_cast<Char>('\x1b');
-      buffer[index++] = static_cast<Char>('[');
-      buffer[index++] = static_cast<Char>('0' + em_codes[i]);
-      buffer[index++] = static_cast<Char>('m');
-    }
-    buffer[index++] = static_cast<Char>(0);
-  }
-  FMT_CONSTEXPR operator const Char*() const noexcept { return buffer; }
-
-  FMT_CONSTEXPR const Char* begin() const noexcept { return buffer; }
-  FMT_CONSTEXPR_CHAR_TRAITS const Char* end() const noexcept {
-    return buffer + std::char_traits<Char>::length(buffer);
-  }
-
- private:
-  static constexpr size_t num_emphases = 8;
-  Char buffer[7u + 3u * num_emphases + 1u];
-
-  static FMT_CONSTEXPR void to_esc(uint8_t c, Char* out,
-                                   char delimiter) noexcept {
-    out[0] = static_cast<Char>('0' + c / 100);
-    out[1] = static_cast<Char>('0' + c / 10 % 10);
-    out[2] = static_cast<Char>('0' + c % 10);
-    out[3] = static_cast<Char>(delimiter);
-  }
-  static FMT_CONSTEXPR bool has_emphasis(emphasis em, emphasis mask) noexcept {
-    return static_cast<uint8_t>(em) & static_cast<uint8_t>(mask);
-  }
-};
-
-template <typename Char>
-FMT_CONSTEXPR ansi_color_escape<Char> make_foreground_color(
-    detail::color_type foreground) noexcept {
-  return ansi_color_escape<Char>(foreground, "\x1b[38;2;");
-}
-
-template <typename Char>
-FMT_CONSTEXPR ansi_color_escape<Char> make_background_color(
-    detail::color_type background) noexcept {
-  return ansi_color_escape<Char>(background, "\x1b[48;2;");
-}
-
-template <typename Char>
-FMT_CONSTEXPR ansi_color_escape<Char> make_emphasis(emphasis em) noexcept {
-  return ansi_color_escape<Char>(em);
-}
-
-template <typename Char> inline void fputs(const Char* chars, FILE* stream) {
-  int result = std::fputs(chars, stream);
-  if (result < 0)
-    FMT_THROW(system_error(errno, FMT_STRING("cannot write to file")));
-}
-
-template <> inline void fputs<wchar_t>(const wchar_t* chars, FILE* stream) {
-  int result = std::fputws(chars, stream);
-  if (result < 0)
-    FMT_THROW(system_error(errno, FMT_STRING("cannot write to file")));
-}
-
-template <typename Char> inline void reset_color(FILE* stream) {
-  fputs("\x1b[0m", stream);
-}
-
-template <> inline void reset_color<wchar_t>(FILE* stream) {
-  fputs(L"\x1b[0m", stream);
-}
-
-template <typename Char> inline void reset_color(buffer<Char>& buffer) {
-  auto reset_color = string_view("\x1b[0m");
-  buffer.append(reset_color.begin(), reset_color.end());
-}
-
-template <typename T> struct styled_arg {
-  const T& value;
-  text_style style;
-};
-
-template <typename Char>
-void vformat_to(buffer<Char>& buf, const text_style& ts,
-                basic_string_view<Char> format_str,
-                basic_format_args<buffer_context<type_identity_t<Char>>> args) {
-  bool has_style = false;
-  if (ts.has_emphasis()) {
-    has_style = true;
-    auto emphasis = detail::make_emphasis<Char>(ts.get_emphasis());
-    buf.append(emphasis.begin(), emphasis.end());
-  }
-  if (ts.has_foreground()) {
-    has_style = true;
-    auto foreground = detail::make_foreground_color<Char>(ts.get_foreground());
-    buf.append(foreground.begin(), foreground.end());
-  }
-  if (ts.has_background()) {
-    has_style = true;
-    auto background = detail::make_background_color<Char>(ts.get_background());
-    buf.append(background.begin(), background.end());
-  }
-  detail::vformat_to(buf, format_str, args, {});
-  if (has_style) detail::reset_color<Char>(buf);
-}
-
-FMT_END_DETAIL_NAMESPACE
-
-template <typename S, typename Char = char_t<S>>
-void vprint(std::FILE* f, const text_style& ts, const S& format,
-            basic_format_args<buffer_context<type_identity_t<Char>>> args) {
-  basic_memory_buffer<Char> buf;
-  detail::vformat_to(buf, ts, detail::to_string_view(format), args);
-  if (detail::is_utf8()) {
-    detail::print(f, basic_string_view<Char>(buf.begin(), buf.size()));
-  } else {
-    buf.push_back(Char(0));
-    detail::fputs(buf.data(), f);
-  }
-}
-
-/**
-  \rst
-  Formats a string and prints it to the specified file stream using ANSI
-  escape sequences to specify text formatting.
-
-  **Example**::
-
-    fmt::print(fmt::emphasis::bold | fg(fmt::color::red),
-               "Elapsed time: {0:.2f} seconds", 1.23);
-  \endrst
- */
-template <typename S, typename... Args,
-          FMT_ENABLE_IF(detail::is_string<S>::value)>
-void print(std::FILE* f, const text_style& ts, const S& format_str,
-           const Args&... args) {
-  vprint(f, ts, format_str,
-         fmt::make_format_args<buffer_context<char_t<S>>>(args...));
-}
-
-/**
-  \rst
-  Formats a string and prints it to stdout using ANSI escape sequences to
-  specify text formatting.
-
-  **Example**::
-
-    fmt::print(fmt::emphasis::bold | fg(fmt::color::red),
-               "Elapsed time: {0:.2f} seconds", 1.23);
-  \endrst
- */
-template <typename S, typename... Args,
-          FMT_ENABLE_IF(detail::is_string<S>::value)>
-void print(const text_style& ts, const S& format_str, const Args&... args) {
-  return print(stdout, ts, format_str, args...);
-}
-
-template <typename S, typename Char = char_t<S>>
-inline std::basic_string<Char> vformat(
-    const text_style& ts, const S& format_str,
-    basic_format_args<buffer_context<type_identity_t<Char>>> args) {
-  basic_memory_buffer<Char> buf;
-  detail::vformat_to(buf, ts, detail::to_string_view(format_str), args);
-  return fmt::to_string(buf);
-}
-
-/**
-  \rst
-  Formats arguments and returns the result as a string using ANSI
-  escape sequences to specify text formatting.
-
-  **Example**::
-
-    #include <fmt/color.h>
-    std::string message = fmt::format(fmt::emphasis::bold | fg(fmt::color::red),
-                                      "The answer is {}", 42);
-  \endrst
-*/
-template <typename S, typename... Args, typename Char = char_t<S>>
-inline std::basic_string<Char> format(const text_style& ts, const S& format_str,
-                                      const Args&... args) {
-  return fmt::vformat(ts, detail::to_string_view(format_str),
-                      fmt::make_format_args<buffer_context<Char>>(args...));
-}
-
-/**
-  Formats a string with the given text_style and writes the output to ``out``.
- */
-template <typename OutputIt, typename Char,
-          FMT_ENABLE_IF(detail::is_output_iterator<OutputIt, Char>::value)>
-OutputIt vformat_to(
-    OutputIt out, const text_style& ts, basic_string_view<Char> format_str,
-    basic_format_args<buffer_context<type_identity_t<Char>>> args) {
-  auto&& buf = detail::get_buffer<Char>(out);
-  detail::vformat_to(buf, ts, format_str, args);
-  return detail::get_iterator(buf);
-}
-
-/**
-  \rst
-  Formats arguments with the given text_style, writes the result to the output
-  iterator ``out`` and returns the iterator past the end of the output range.
-
-  **Example**::
-
-    std::vector<char> out;
-    fmt::format_to(std::back_inserter(out),
-                   fmt::emphasis::bold | fg(fmt::color::red), "{}", 42);
-  \endrst
-*/
-template <typename OutputIt, typename S, typename... Args,
-          bool enable = detail::is_output_iterator<OutputIt, char_t<S>>::value&&
-              detail::is_string<S>::value>
-inline auto format_to(OutputIt out, const text_style& ts, const S& format_str,
-                      Args&&... args) ->
-    typename std::enable_if<enable, OutputIt>::type {
-  return vformat_to(out, ts, detail::to_string_view(format_str),
-                    fmt::make_format_args<buffer_context<char_t<S>>>(args...));
-}
-
-template <typename T, typename Char>
-struct formatter<detail::styled_arg<T>, Char> : formatter<T, Char> {
-  template <typename FormatContext>
-  auto format(const detail::styled_arg<T>& arg, FormatContext& ctx) const
-      -> decltype(ctx.out()) {
-    const auto& ts = arg.style;
-    const auto& value = arg.value;
-    auto out = ctx.out();
-
-    bool has_style = false;
-    if (ts.has_emphasis()) {
-      has_style = true;
-      auto emphasis = detail::make_emphasis<Char>(ts.get_emphasis());
-      out = std::copy(emphasis.begin(), emphasis.end(), out);
-    }
-    if (ts.has_foreground()) {
-      has_style = true;
-      auto foreground =
-          detail::make_foreground_color<Char>(ts.get_foreground());
-      out = std::copy(foreground.begin(), foreground.end(), out);
-    }
-    if (ts.has_background()) {
-      has_style = true;
-      auto background =
-          detail::make_background_color<Char>(ts.get_background());
-      out = std::copy(background.begin(), background.end(), out);
-    }
-    out = formatter<T, Char>::format(value, ctx);
-    if (has_style) {
-      auto reset_color = string_view("\x1b[0m");
-      out = std::copy(reset_color.begin(), reset_color.end(), out);
-    }
-    return out;
-  }
-};
-
-/**
-  \rst
-  Returns an argument that will be formatted using ANSI escape sequences,
-  to be used in a formatting function.
-
-  **Example**::
-
-    fmt::print("Elapsed time: {0:.2f} seconds",
-               fmt::styled(1.23, fmt::fg(fmt::color::green) |
-                                 fmt::bg(fmt::color::blue)));
-  \endrst
- */
-template <typename T>
-FMT_CONSTEXPR auto styled(const T& value, text_style ts)
-    -> detail::styled_arg<remove_cvref_t<T>> {
-  return detail::styled_arg<remove_cvref_t<T>>{value, ts};
-}
-
-FMT_MODULE_EXPORT_END
-FMT_END_NAMESPACE
-
-#endif  // FMT_COLOR_H_
diff --git a/Externals/fmt/include/fmt/compile.h b/Externals/fmt/include/fmt/compile.h
deleted file mode 100644
index 933668c41c3e..000000000000
--- a/Externals/fmt/include/fmt/compile.h
+++ /dev/null
@@ -1,611 +0,0 @@
-// Formatting library for C++ - experimental format string compilation
-//
-// Copyright (c) 2012 - present, Victor Zverovich and fmt contributors
-// All rights reserved.
-//
-// For the license information refer to format.h.
-
-#ifndef FMT_COMPILE_H_
-#define FMT_COMPILE_H_
-
-#include "format.h"
-
-FMT_BEGIN_NAMESPACE
-namespace detail {
-
-template <typename Char, typename InputIt>
-FMT_CONSTEXPR inline counting_iterator copy_str(InputIt begin, InputIt end,
-                                                counting_iterator it) {
-  return it + (end - begin);
-}
-
-template <typename OutputIt> class truncating_iterator_base {
- protected:
-  OutputIt out_;
-  size_t limit_;
-  size_t count_ = 0;
-
-  truncating_iterator_base() : out_(), limit_(0) {}
-
-  truncating_iterator_base(OutputIt out, size_t limit)
-      : out_(out), limit_(limit) {}
-
- public:
-  using iterator_category = std::output_iterator_tag;
-  using value_type = typename std::iterator_traits<OutputIt>::value_type;
-  using difference_type = std::ptrdiff_t;
-  using pointer = void;
-  using reference = void;
-  FMT_UNCHECKED_ITERATOR(truncating_iterator_base);
-
-  OutputIt base() const { return out_; }
-  size_t count() const { return count_; }
-};
-
-// An output iterator that truncates the output and counts the number of objects
-// written to it.
-template <typename OutputIt,
-          typename Enable = typename std::is_void<
-              typename std::iterator_traits<OutputIt>::value_type>::type>
-class truncating_iterator;
-
-template <typename OutputIt>
-class truncating_iterator<OutputIt, std::false_type>
-    : public truncating_iterator_base<OutputIt> {
-  mutable typename truncating_iterator_base<OutputIt>::value_type blackhole_;
-
- public:
-  using value_type = typename truncating_iterator_base<OutputIt>::value_type;
-
-  truncating_iterator() = default;
-
-  truncating_iterator(OutputIt out, size_t limit)
-      : truncating_iterator_base<OutputIt>(out, limit) {}
-
-  truncating_iterator& operator++() {
-    if (this->count_++ < this->limit_) ++this->out_;
-    return *this;
-  }
-
-  truncating_iterator operator++(int) {
-    auto it = *this;
-    ++*this;
-    return it;
-  }
-
-  value_type& operator*() const {
-    return this->count_ < this->limit_ ? *this->out_ : blackhole_;
-  }
-};
-
-template <typename OutputIt>
-class truncating_iterator<OutputIt, std::true_type>
-    : public truncating_iterator_base<OutputIt> {
- public:
-  truncating_iterator() = default;
-
-  truncating_iterator(OutputIt out, size_t limit)
-      : truncating_iterator_base<OutputIt>(out, limit) {}
-
-  template <typename T> truncating_iterator& operator=(T val) {
-    if (this->count_++ < this->limit_) *this->out_++ = val;
-    return *this;
-  }
-
-  truncating_iterator& operator++() { return *this; }
-  truncating_iterator& operator++(int) { return *this; }
-  truncating_iterator& operator*() { return *this; }
-};
-
-// A compile-time string which is compiled into fast formatting code.
-class compiled_string {};
-
-template <typename S>
-struct is_compiled_string : std::is_base_of<compiled_string, S> {};
-
-/**
-  \rst
-  Converts a string literal *s* into a format string that will be parsed at
-  compile time and converted into efficient formatting code. Requires C++17
-  ``constexpr if`` compiler support.
-
-  **Example**::
-
-    // Converts 42 into std::string using the most efficient method and no
-    // runtime format string processing.
-    std::string s = fmt::format(FMT_COMPILE("{}"), 42);
-  \endrst
- */
-#if defined(__cpp_if_constexpr) && defined(__cpp_return_type_deduction)
-#  define FMT_COMPILE(s) \
-    FMT_STRING_IMPL(s, fmt::detail::compiled_string, explicit)
-#else
-#  define FMT_COMPILE(s) FMT_STRING(s)
-#endif
-
-#if FMT_USE_NONTYPE_TEMPLATE_ARGS
-template <typename Char, size_t N,
-          fmt::detail_exported::fixed_string<Char, N> Str>
-struct udl_compiled_string : compiled_string {
-  using char_type = Char;
-  explicit constexpr operator basic_string_view<char_type>() const {
-    return {Str.data, N - 1};
-  }
-};
-#endif
-
-template <typename T, typename... Tail>
-const T& first(const T& value, const Tail&...) {
-  return value;
-}
-
-#if defined(__cpp_if_constexpr) && defined(__cpp_return_type_deduction)
-template <typename... Args> struct type_list {};
-
-// Returns a reference to the argument at index N from [first, rest...].
-template <int N, typename T, typename... Args>
-constexpr const auto& get([[maybe_unused]] const T& first,
-                          [[maybe_unused]] const Args&... rest) {
-  static_assert(N < 1 + sizeof...(Args), "index is out of bounds");
-  if constexpr (N == 0)
-    return first;
-  else
-    return detail::get<N - 1>(rest...);
-}
-
-template <typename Char, typename... Args>
-constexpr int get_arg_index_by_name(basic_string_view<Char> name,
-                                    type_list<Args...>) {
-  return get_arg_index_by_name<Args...>(name);
-}
-
-template <int N, typename> struct get_type_impl;
-
-template <int N, typename... Args> struct get_type_impl<N, type_list<Args...>> {
-  using type =
-      remove_cvref_t<decltype(detail::get<N>(std::declval<Args>()...))>;
-};
-
-template <int N, typename T>
-using get_type = typename get_type_impl<N, T>::type;
-
-template <typename T> struct is_compiled_format : std::false_type {};
-
-template <typename Char> struct text {
-  basic_string_view<Char> data;
-  using char_type = Char;
-
-  template <typename OutputIt, typename... Args>
-  constexpr OutputIt format(OutputIt out, const Args&...) const {
-    return write<Char>(out, data);
-  }
-};
-
-template <typename Char>
-struct is_compiled_format<text<Char>> : std::true_type {};
-
-template <typename Char>
-constexpr text<Char> make_text(basic_string_view<Char> s, size_t pos,
-                               size_t size) {
-  return {{&s[pos], size}};
-}
-
-template <typename Char> struct code_unit {
-  Char value;
-  using char_type = Char;
-
-  template <typename OutputIt, typename... Args>
-  constexpr OutputIt format(OutputIt out, const Args&...) const {
-    return write<Char>(out, value);
-  }
-};
-
-// This ensures that the argument type is convertible to `const T&`.
-template <typename T, int N, typename... Args>
-constexpr const T& get_arg_checked(const Args&... args) {
-  const auto& arg = detail::get<N>(args...);
-  if constexpr (detail::is_named_arg<remove_cvref_t<decltype(arg)>>()) {
-    return arg.value;
-  } else {
-    return arg;
-  }
-}
-
-template <typename Char>
-struct is_compiled_format<code_unit<Char>> : std::true_type {};
-
-// A replacement field that refers to argument N.
-template <typename Char, typename T, int N> struct field {
-  using char_type = Char;
-
-  template <typename OutputIt, typename... Args>
-  constexpr OutputIt format(OutputIt out, const Args&... args) const {
-    return write<Char>(out, get_arg_checked<T, N>(args...));
-  }
-};
-
-template <typename Char, typename T, int N>
-struct is_compiled_format<field<Char, T, N>> : std::true_type {};
-
-// A replacement field that refers to argument with name.
-template <typename Char> struct runtime_named_field {
-  using char_type = Char;
-  basic_string_view<Char> name;
-
-  template <typename OutputIt, typename T>
-  constexpr static bool try_format_argument(
-      OutputIt& out,
-      // [[maybe_unused]] due to unused-but-set-parameter warning in GCC 7,8,9
-      [[maybe_unused]] basic_string_view<Char> arg_name, const T& arg) {
-    if constexpr (is_named_arg<typename std::remove_cv<T>::type>::value) {
-      if (arg_name == arg.name) {
-        out = write<Char>(out, arg.value);
-        return true;
-      }
-    }
-    return false;
-  }
-
-  template <typename OutputIt, typename... Args>
-  constexpr OutputIt format(OutputIt out, const Args&... args) const {
-    bool found = (try_format_argument(out, name, args) || ...);
-    if (!found) {
-      FMT_THROW(format_error("argument with specified name is not found"));
-    }
-    return out;
-  }
-};
-
-template <typename Char>
-struct is_compiled_format<runtime_named_field<Char>> : std::true_type {};
-
-// A replacement field that refers to argument N and has format specifiers.
-template <typename Char, typename T, int N> struct spec_field {
-  using char_type = Char;
-  formatter<T, Char> fmt;
-
-  template <typename OutputIt, typename... Args>
-  constexpr FMT_INLINE OutputIt format(OutputIt out,
-                                       const Args&... args) const {
-    const auto& vargs =
-        fmt::make_format_args<basic_format_context<OutputIt, Char>>(args...);
-    basic_format_context<OutputIt, Char> ctx(out, vargs);
-    return fmt.format(get_arg_checked<T, N>(args...), ctx);
-  }
-};
-
-template <typename Char, typename T, int N>
-struct is_compiled_format<spec_field<Char, T, N>> : std::true_type {};
-
-template <typename L, typename R> struct concat {
-  L lhs;
-  R rhs;
-  using char_type = typename L::char_type;
-
-  template <typename OutputIt, typename... Args>
-  constexpr OutputIt format(OutputIt out, const Args&... args) const {
-    out = lhs.format(out, args...);
-    return rhs.format(out, args...);
-  }
-};
-
-template <typename L, typename R>
-struct is_compiled_format<concat<L, R>> : std::true_type {};
-
-template <typename L, typename R>
-constexpr concat<L, R> make_concat(L lhs, R rhs) {
-  return {lhs, rhs};
-}
-
-struct unknown_format {};
-
-template <typename Char>
-constexpr size_t parse_text(basic_string_view<Char> str, size_t pos) {
-  for (size_t size = str.size(); pos != size; ++pos) {
-    if (str[pos] == '{' || str[pos] == '}') break;
-  }
-  return pos;
-}
-
-template <typename Args, size_t POS, int ID, typename S>
-constexpr auto compile_format_string(S format_str);
-
-template <typename Args, size_t POS, int ID, typename T, typename S>
-constexpr auto parse_tail(T head, S format_str) {
-  if constexpr (POS !=
-                basic_string_view<typename S::char_type>(format_str).size()) {
-    constexpr auto tail = compile_format_string<Args, POS, ID>(format_str);
-    if constexpr (std::is_same<remove_cvref_t<decltype(tail)>,
-                               unknown_format>())
-      return tail;
-    else
-      return make_concat(head, tail);
-  } else {
-    return head;
-  }
-}
-
-template <typename T, typename Char> struct parse_specs_result {
-  formatter<T, Char> fmt;
-  size_t end;
-  int next_arg_id;
-};
-
-constexpr int manual_indexing_id = -1;
-
-template <typename T, typename Char>
-constexpr parse_specs_result<T, Char> parse_specs(basic_string_view<Char> str,
-                                                  size_t pos, int next_arg_id) {
-  str.remove_prefix(pos);
-  auto ctx = compile_parse_context<Char>(str, max_value<int>(), nullptr, {},
-                                         next_arg_id);
-  auto f = formatter<T, Char>();
-  auto end = f.parse(ctx);
-  return {f, pos + fmt::detail::to_unsigned(end - str.data()),
-          next_arg_id == 0 ? manual_indexing_id : ctx.next_arg_id()};
-}
-
-template <typename Char> struct arg_id_handler {
-  arg_ref<Char> arg_id;
-
-  constexpr int operator()() {
-    FMT_ASSERT(false, "handler cannot be used with automatic indexing");
-    return 0;
-  }
-  constexpr int operator()(int id) {
-    arg_id = arg_ref<Char>(id);
-    return 0;
-  }
-  constexpr int operator()(basic_string_view<Char> id) {
-    arg_id = arg_ref<Char>(id);
-    return 0;
-  }
-
-  constexpr void on_error(const char* message) {
-    FMT_THROW(format_error(message));
-  }
-};
-
-template <typename Char> struct parse_arg_id_result {
-  arg_ref<Char> arg_id;
-  const Char* arg_id_end;
-};
-
-template <int ID, typename Char>
-constexpr auto parse_arg_id(const Char* begin, const Char* end) {
-  auto handler = arg_id_handler<Char>{arg_ref<Char>{}};
-  auto arg_id_end = parse_arg_id(begin, end, handler);
-  return parse_arg_id_result<Char>{handler.arg_id, arg_id_end};
-}
-
-template <typename T, typename Enable = void> struct field_type {
-  using type = remove_cvref_t<T>;
-};
-
-template <typename T>
-struct field_type<T, enable_if_t<detail::is_named_arg<T>::value>> {
-  using type = remove_cvref_t<decltype(T::value)>;
-};
-
-template <typename T, typename Args, size_t END_POS, int ARG_INDEX, int NEXT_ID,
-          typename S>
-constexpr auto parse_replacement_field_then_tail(S format_str) {
-  using char_type = typename S::char_type;
-  constexpr auto str = basic_string_view<char_type>(format_str);
-  constexpr char_type c = END_POS != str.size() ? str[END_POS] : char_type();
-  if constexpr (c == '}') {
-    return parse_tail<Args, END_POS + 1, NEXT_ID>(
-        field<char_type, typename field_type<T>::type, ARG_INDEX>(),
-        format_str);
-  } else if constexpr (c != ':') {
-    FMT_THROW(format_error("expected ':'"));
-  } else {
-    constexpr auto result = parse_specs<typename field_type<T>::type>(
-        str, END_POS + 1, NEXT_ID == manual_indexing_id ? 0 : NEXT_ID);
-    if constexpr (result.end >= str.size() || str[result.end] != '}') {
-      FMT_THROW(format_error("expected '}'"));
-      return 0;
-    } else {
-      return parse_tail<Args, result.end + 1, result.next_arg_id>(
-          spec_field<char_type, typename field_type<T>::type, ARG_INDEX>{
-              result.fmt},
-          format_str);
-    }
-  }
-}
-
-// Compiles a non-empty format string and returns the compiled representation
-// or unknown_format() on unrecognized input.
-template <typename Args, size_t POS, int ID, typename S>
-constexpr auto compile_format_string(S format_str) {
-  using char_type = typename S::char_type;
-  constexpr auto str = basic_string_view<char_type>(format_str);
-  if constexpr (str[POS] == '{') {
-    if constexpr (POS + 1 == str.size())
-      FMT_THROW(format_error("unmatched '{' in format string"));
-    if constexpr (str[POS + 1] == '{') {
-      return parse_tail<Args, POS + 2, ID>(make_text(str, POS, 1), format_str);
-    } else if constexpr (str[POS + 1] == '}' || str[POS + 1] == ':') {
-      static_assert(ID != manual_indexing_id,
-                    "cannot switch from manual to automatic argument indexing");
-      constexpr auto next_id =
-          ID != manual_indexing_id ? ID + 1 : manual_indexing_id;
-      return parse_replacement_field_then_tail<get_type<ID, Args>, Args,
-                                               POS + 1, ID, next_id>(
-          format_str);
-    } else {
-      constexpr auto arg_id_result =
-          parse_arg_id<ID>(str.data() + POS + 1, str.data() + str.size());
-      constexpr auto arg_id_end_pos = arg_id_result.arg_id_end - str.data();
-      constexpr char_type c =
-          arg_id_end_pos != str.size() ? str[arg_id_end_pos] : char_type();
-      static_assert(c == '}' || c == ':', "missing '}' in format string");
-      if constexpr (arg_id_result.arg_id.kind == arg_id_kind::index) {
-        static_assert(
-            ID == manual_indexing_id || ID == 0,
-            "cannot switch from automatic to manual argument indexing");
-        constexpr auto arg_index = arg_id_result.arg_id.val.index;
-        return parse_replacement_field_then_tail<get_type<arg_index, Args>,
-                                                 Args, arg_id_end_pos,
-                                                 arg_index, manual_indexing_id>(
-            format_str);
-      } else if constexpr (arg_id_result.arg_id.kind == arg_id_kind::name) {
-        constexpr auto arg_index =
-            get_arg_index_by_name(arg_id_result.arg_id.val.name, Args{});
-        if constexpr (arg_index != invalid_arg_index) {
-          constexpr auto next_id =
-              ID != manual_indexing_id ? ID + 1 : manual_indexing_id;
-          return parse_replacement_field_then_tail<
-              decltype(get_type<arg_index, Args>::value), Args, arg_id_end_pos,
-              arg_index, next_id>(format_str);
-        } else {
-          if constexpr (c == '}') {
-            return parse_tail<Args, arg_id_end_pos + 1, ID>(
-                runtime_named_field<char_type>{arg_id_result.arg_id.val.name},
-                format_str);
-          } else if constexpr (c == ':') {
-            return unknown_format();  // no type info for specs parsing
-          }
-        }
-      }
-    }
-  } else if constexpr (str[POS] == '}') {
-    if constexpr (POS + 1 == str.size())
-      FMT_THROW(format_error("unmatched '}' in format string"));
-    return parse_tail<Args, POS + 2, ID>(make_text(str, POS, 1), format_str);
-  } else {
-    constexpr auto end = parse_text(str, POS + 1);
-    if constexpr (end - POS > 1) {
-      return parse_tail<Args, end, ID>(make_text(str, POS, end - POS),
-                                       format_str);
-    } else {
-      return parse_tail<Args, end, ID>(code_unit<char_type>{str[POS]},
-                                       format_str);
-    }
-  }
-}
-
-template <typename... Args, typename S,
-          FMT_ENABLE_IF(detail::is_compiled_string<S>::value)>
-constexpr auto compile(S format_str) {
-  constexpr auto str = basic_string_view<typename S::char_type>(format_str);
-  if constexpr (str.size() == 0) {
-    return detail::make_text(str, 0, 0);
-  } else {
-    constexpr auto result =
-        detail::compile_format_string<detail::type_list<Args...>, 0, 0>(
-            format_str);
-    return result;
-  }
-}
-#endif  // defined(__cpp_if_constexpr) && defined(__cpp_return_type_deduction)
-}  // namespace detail
-
-FMT_MODULE_EXPORT_BEGIN
-
-#if defined(__cpp_if_constexpr) && defined(__cpp_return_type_deduction)
-
-template <typename CompiledFormat, typename... Args,
-          typename Char = typename CompiledFormat::char_type,
-          FMT_ENABLE_IF(detail::is_compiled_format<CompiledFormat>::value)>
-FMT_INLINE std::basic_string<Char> format(const CompiledFormat& cf,
-                                          const Args&... args) {
-  auto s = std::basic_string<Char>();
-  cf.format(std::back_inserter(s), args...);
-  return s;
-}
-
-template <typename OutputIt, typename CompiledFormat, typename... Args,
-          FMT_ENABLE_IF(detail::is_compiled_format<CompiledFormat>::value)>
-constexpr FMT_INLINE OutputIt format_to(OutputIt out, const CompiledFormat& cf,
-                                        const Args&... args) {
-  return cf.format(out, args...);
-}
-
-template <typename S, typename... Args,
-          FMT_ENABLE_IF(detail::is_compiled_string<S>::value)>
-FMT_INLINE std::basic_string<typename S::char_type> format(const S&,
-                                                           Args&&... args) {
-  if constexpr (std::is_same<typename S::char_type, char>::value) {
-    constexpr auto str = basic_string_view<typename S::char_type>(S());
-    if constexpr (str.size() == 2 && str[0] == '{' && str[1] == '}') {
-      const auto& first = detail::first(args...);
-      if constexpr (detail::is_named_arg<
-                        remove_cvref_t<decltype(first)>>::value) {
-        return fmt::to_string(first.value);
-      } else {
-        return fmt::to_string(first);
-      }
-    }
-  }
-  constexpr auto compiled = detail::compile<Args...>(S());
-  if constexpr (std::is_same<remove_cvref_t<decltype(compiled)>,
-                             detail::unknown_format>()) {
-    return fmt::format(
-        static_cast<basic_string_view<typename S::char_type>>(S()),
-        std::forward<Args>(args)...);
-  } else {
-    return fmt::format(compiled, std::forward<Args>(args)...);
-  }
-}
-
-template <typename OutputIt, typename S, typename... Args,
-          FMT_ENABLE_IF(detail::is_compiled_string<S>::value)>
-FMT_CONSTEXPR OutputIt format_to(OutputIt out, const S&, Args&&... args) {
-  constexpr auto compiled = detail::compile<Args...>(S());
-  if constexpr (std::is_same<remove_cvref_t<decltype(compiled)>,
-                             detail::unknown_format>()) {
-    return fmt::format_to(
-        out, static_cast<basic_string_view<typename S::char_type>>(S()),
-        std::forward<Args>(args)...);
-  } else {
-    return fmt::format_to(out, compiled, std::forward<Args>(args)...);
-  }
-}
-#endif
-
-template <typename OutputIt, typename S, typename... Args,
-          FMT_ENABLE_IF(detail::is_compiled_string<S>::value)>
-format_to_n_result<OutputIt> format_to_n(OutputIt out, size_t n,
-                                         const S& format_str, Args&&... args) {
-  auto it = fmt::format_to(detail::truncating_iterator<OutputIt>(out, n),
-                           format_str, std::forward<Args>(args)...);
-  return {it.base(), it.count()};
-}
-
-template <typename S, typename... Args,
-          FMT_ENABLE_IF(detail::is_compiled_string<S>::value)>
-FMT_CONSTEXPR20 size_t formatted_size(const S& format_str,
-                                      const Args&... args) {
-  return fmt::format_to(detail::counting_iterator(), format_str, args...)
-      .count();
-}
-
-template <typename S, typename... Args,
-          FMT_ENABLE_IF(detail::is_compiled_string<S>::value)>
-void print(std::FILE* f, const S& format_str, const Args&... args) {
-  memory_buffer buffer;
-  fmt::format_to(std::back_inserter(buffer), format_str, args...);
-  detail::print(f, {buffer.data(), buffer.size()});
-}
-
-template <typename S, typename... Args,
-          FMT_ENABLE_IF(detail::is_compiled_string<S>::value)>
-void print(const S& format_str, const Args&... args) {
-  print(stdout, format_str, args...);
-}
-
-#if FMT_USE_NONTYPE_TEMPLATE_ARGS
-inline namespace literals {
-template <detail_exported::fixed_string Str> constexpr auto operator""_cf() {
-  using char_t = remove_cvref_t<decltype(Str.data[0])>;
-  return detail::udl_compiled_string<char_t, sizeof(Str.data) / sizeof(char_t),
-                                     Str>();
-}
-}  // namespace literals
-#endif
-
-FMT_MODULE_EXPORT_END
-FMT_END_NAMESPACE
-
-#endif  // FMT_COMPILE_H_
diff --git a/Externals/fmt/include/fmt/core.h b/Externals/fmt/include/fmt/core.h
deleted file mode 100755
index f6a37af9e35d..000000000000
--- a/Externals/fmt/include/fmt/core.h
+++ /dev/null
@@ -1,3323 +0,0 @@
-// Formatting library for C++ - the core API for char/UTF-8
-//
-// Copyright (c) 2012 - present, Victor Zverovich
-// All rights reserved.
-//
-// For the license information refer to format.h.
-
-#ifndef FMT_CORE_H_
-#define FMT_CORE_H_
-
-#include <cstddef>  // std::byte
-#include <cstdio>   // std::FILE
-#include <cstring>  // std::strlen
-#include <iterator>
-#include <limits>
-#include <string>
-#include <type_traits>
-
-// The fmt library version in the form major * 10000 + minor * 100 + patch.
-#define FMT_VERSION 90100
-
-#if defined(__clang__) && !defined(__ibmxl__)
-#  define FMT_CLANG_VERSION (__clang_major__ * 100 + __clang_minor__)
-#else
-#  define FMT_CLANG_VERSION 0
-#endif
-
-#if defined(__GNUC__) && !defined(__clang__) && !defined(__INTEL_COMPILER) && \
-    !defined(__NVCOMPILER)
-#  define FMT_GCC_VERSION (__GNUC__ * 100 + __GNUC_MINOR__)
-#else
-#  define FMT_GCC_VERSION 0
-#endif
-
-#ifndef FMT_GCC_PRAGMA
-// Workaround _Pragma bug https://gcc.gnu.org/bugzilla/show_bug.cgi?id=59884.
-#  if FMT_GCC_VERSION >= 504
-#    define FMT_GCC_PRAGMA(arg) _Pragma(arg)
-#  else
-#    define FMT_GCC_PRAGMA(arg)
-#  endif
-#endif
-
-#ifdef __ICL
-#  define FMT_ICC_VERSION __ICL
-#elif defined(__INTEL_COMPILER)
-#  define FMT_ICC_VERSION __INTEL_COMPILER
-#else
-#  define FMT_ICC_VERSION 0
-#endif
-
-#ifdef _MSC_VER
-#  define FMT_MSC_VERSION _MSC_VER
-#  define FMT_MSC_WARNING(...) __pragma(warning(__VA_ARGS__))
-#else
-#  define FMT_MSC_VERSION 0
-#  define FMT_MSC_WARNING(...)
-#endif
-
-#ifdef _MSVC_LANG
-#  define FMT_CPLUSPLUS _MSVC_LANG
-#else
-#  define FMT_CPLUSPLUS __cplusplus
-#endif
-
-#ifdef __has_feature
-#  define FMT_HAS_FEATURE(x) __has_feature(x)
-#else
-#  define FMT_HAS_FEATURE(x) 0
-#endif
-
-#if (defined(__has_include) || FMT_ICC_VERSION >= 1600 || \
-     FMT_MSC_VERSION > 1900) &&                           \
-    !defined(__INTELLISENSE__)
-#  define FMT_HAS_INCLUDE(x) __has_include(x)
-#else
-#  define FMT_HAS_INCLUDE(x) 0
-#endif
-
-#ifdef __has_cpp_attribute
-#  define FMT_HAS_CPP_ATTRIBUTE(x) __has_cpp_attribute(x)
-#else
-#  define FMT_HAS_CPP_ATTRIBUTE(x) 0
-#endif
-
-#define FMT_HAS_CPP14_ATTRIBUTE(attribute) \
-  (FMT_CPLUSPLUS >= 201402L && FMT_HAS_CPP_ATTRIBUTE(attribute))
-
-#define FMT_HAS_CPP17_ATTRIBUTE(attribute) \
-  (FMT_CPLUSPLUS >= 201703L && FMT_HAS_CPP_ATTRIBUTE(attribute))
-
-// Check if relaxed C++14 constexpr is supported.
-// GCC doesn't allow throw in constexpr until version 6 (bug 67371).
-#ifndef FMT_USE_CONSTEXPR
-#  if (FMT_HAS_FEATURE(cxx_relaxed_constexpr) || FMT_MSC_VERSION >= 1912 || \
-       (FMT_GCC_VERSION >= 600 && FMT_CPLUSPLUS >= 201402L)) &&             \
-      !FMT_ICC_VERSION && !defined(__NVCC__)
-#    define FMT_USE_CONSTEXPR 1
-#  else
-#    define FMT_USE_CONSTEXPR 0
-#  endif
-#endif
-#if FMT_USE_CONSTEXPR
-#  define FMT_CONSTEXPR constexpr
-#else
-#  define FMT_CONSTEXPR
-#endif
-
-#if ((FMT_CPLUSPLUS >= 202002L) &&                            \
-     (!defined(_GLIBCXX_RELEASE) || _GLIBCXX_RELEASE > 9)) || \
-    (FMT_CPLUSPLUS >= 201709L && FMT_GCC_VERSION >= 1002)
-#  define FMT_CONSTEXPR20 constexpr
-#else
-#  define FMT_CONSTEXPR20
-#endif
-
-// Check if constexpr std::char_traits<>::{compare,length} are supported.
-#if defined(__GLIBCXX__)
-#  if FMT_CPLUSPLUS >= 201703L && defined(_GLIBCXX_RELEASE) && \
-      _GLIBCXX_RELEASE >= 7  // GCC 7+ libstdc++ has _GLIBCXX_RELEASE.
-#    define FMT_CONSTEXPR_CHAR_TRAITS constexpr
-#  endif
-#elif defined(_LIBCPP_VERSION) && FMT_CPLUSPLUS >= 201703L && \
-    _LIBCPP_VERSION >= 4000
-#  define FMT_CONSTEXPR_CHAR_TRAITS constexpr
-#elif FMT_MSC_VERSION >= 1914 && FMT_CPLUSPLUS >= 201703L
-#  define FMT_CONSTEXPR_CHAR_TRAITS constexpr
-#endif
-#ifndef FMT_CONSTEXPR_CHAR_TRAITS
-#  define FMT_CONSTEXPR_CHAR_TRAITS
-#endif
-
-// Check if exceptions are disabled.
-#ifndef FMT_EXCEPTIONS
-#  if (defined(__GNUC__) && !defined(__EXCEPTIONS)) || \
-      (FMT_MSC_VERSION && !_HAS_EXCEPTIONS)
-#    define FMT_EXCEPTIONS 0
-#  else
-#    define FMT_EXCEPTIONS 1
-#  endif
-#endif
-
-#ifndef FMT_DEPRECATED
-#  if FMT_HAS_CPP14_ATTRIBUTE(deprecated) || FMT_MSC_VERSION >= 1900
-#    define FMT_DEPRECATED [[deprecated]]
-#  else
-#    if (defined(__GNUC__) && !defined(__LCC__)) || defined(__clang__)
-#      define FMT_DEPRECATED __attribute__((deprecated))
-#    elif FMT_MSC_VERSION
-#      define FMT_DEPRECATED __declspec(deprecated)
-#    else
-#      define FMT_DEPRECATED /* deprecated */
-#    endif
-#  endif
-#endif
-
-// [[noreturn]] is disabled on MSVC and NVCC because of bogus unreachable code
-// warnings.
-#if FMT_EXCEPTIONS && FMT_HAS_CPP_ATTRIBUTE(noreturn) && !FMT_MSC_VERSION && \
-    !defined(__NVCC__)
-#  define FMT_NORETURN [[noreturn]]
-#else
-#  define FMT_NORETURN
-#endif
-
-#if FMT_HAS_CPP17_ATTRIBUTE(fallthrough)
-#  define FMT_FALLTHROUGH [[fallthrough]]
-#elif defined(__clang__)
-#  define FMT_FALLTHROUGH [[clang::fallthrough]]
-#elif FMT_GCC_VERSION >= 700 && \
-    (!defined(__EDG_VERSION__) || __EDG_VERSION__ >= 520)
-#  define FMT_FALLTHROUGH [[gnu::fallthrough]]
-#else
-#  define FMT_FALLTHROUGH
-#endif
-
-#ifndef FMT_NODISCARD
-#  if FMT_HAS_CPP17_ATTRIBUTE(nodiscard)
-#    define FMT_NODISCARD [[nodiscard]]
-#  else
-#    define FMT_NODISCARD
-#  endif
-#endif
-
-#ifndef FMT_USE_FLOAT
-#  define FMT_USE_FLOAT 1
-#endif
-#ifndef FMT_USE_DOUBLE
-#  define FMT_USE_DOUBLE 1
-#endif
-#ifndef FMT_USE_LONG_DOUBLE
-#  define FMT_USE_LONG_DOUBLE 1
-#endif
-
-#ifndef FMT_INLINE
-#  if FMT_GCC_VERSION || FMT_CLANG_VERSION
-#    define FMT_INLINE inline __attribute__((always_inline))
-#  else
-#    define FMT_INLINE inline
-#  endif
-#endif
-
-// An inline std::forward replacement.
-#define FMT_FORWARD(...) static_cast<decltype(__VA_ARGS__)&&>(__VA_ARGS__)
-
-#ifdef _MSC_VER
-#  define FMT_UNCHECKED_ITERATOR(It) \
-    using _Unchecked_type = It  // Mark iterator as checked.
-#else
-#  define FMT_UNCHECKED_ITERATOR(It) using unchecked_type = It
-#endif
-
-#ifndef FMT_BEGIN_NAMESPACE
-#  define FMT_BEGIN_NAMESPACE \
-    namespace fmt {           \
-    inline namespace v9 {
-#  define FMT_END_NAMESPACE \
-    }                       \
-    }
-#endif
-
-#ifndef FMT_MODULE_EXPORT
-#  define FMT_MODULE_EXPORT
-#  define FMT_MODULE_EXPORT_BEGIN
-#  define FMT_MODULE_EXPORT_END
-#  define FMT_BEGIN_DETAIL_NAMESPACE namespace detail {
-#  define FMT_END_DETAIL_NAMESPACE }
-#endif
-
-#if !defined(FMT_HEADER_ONLY) && defined(_WIN32)
-#  define FMT_CLASS_API FMT_MSC_WARNING(suppress : 4275)
-#  ifdef FMT_EXPORT
-#    define FMT_API __declspec(dllexport)
-#  elif defined(FMT_SHARED)
-#    define FMT_API __declspec(dllimport)
-#  endif
-#else
-#  define FMT_CLASS_API
-#  if defined(FMT_EXPORT) || defined(FMT_SHARED)
-#    if defined(__GNUC__) || defined(__clang__)
-#      define FMT_API __attribute__((visibility("default")))
-#    endif
-#  endif
-#endif
-#ifndef FMT_API
-#  define FMT_API
-#endif
-
-// libc++ supports string_view in pre-c++17.
-#if FMT_HAS_INCLUDE(<string_view>) && \
-    (FMT_CPLUSPLUS >= 201703L || defined(_LIBCPP_VERSION))
-#  include <string_view>
-#  define FMT_USE_STRING_VIEW
-#elif FMT_HAS_INCLUDE("experimental/string_view") && FMT_CPLUSPLUS >= 201402L
-#  include <experimental/string_view>
-#  define FMT_USE_EXPERIMENTAL_STRING_VIEW
-#endif
-
-#ifndef FMT_UNICODE
-#  define FMT_UNICODE !FMT_MSC_VERSION
-#endif
-
-#ifndef FMT_CONSTEVAL
-#  if ((FMT_GCC_VERSION >= 1000 || FMT_CLANG_VERSION >= 1101) &&         \
-       FMT_CPLUSPLUS >= 202002L && !defined(__apple_build_version__)) || \
-      (defined(__cpp_consteval) &&                                       \
-       (!FMT_MSC_VERSION || _MSC_FULL_VER >= 193030704))
-// consteval is broken in MSVC before VS2022 and Apple clang 13.
-#    define FMT_CONSTEVAL consteval
-#    define FMT_HAS_CONSTEVAL
-#  else
-#    define FMT_CONSTEVAL
-#  endif
-#endif
-
-#ifndef FMT_USE_NONTYPE_TEMPLATE_ARGS
-#  if defined(__cpp_nontype_template_args) &&                  \
-      ((FMT_GCC_VERSION >= 903 && FMT_CPLUSPLUS >= 201709L) || \
-       __cpp_nontype_template_args >= 201911L) &&              \
-      !defined(__NVCOMPILER)
-#    define FMT_USE_NONTYPE_TEMPLATE_ARGS 1
-#  else
-#    define FMT_USE_NONTYPE_TEMPLATE_ARGS 0
-#  endif
-#endif
-
-// Enable minimal optimizations for more compact code in debug mode.
-FMT_GCC_PRAGMA("GCC push_options")
-#if !defined(__OPTIMIZE__) && !defined(__NVCOMPILER)
-FMT_GCC_PRAGMA("GCC optimize(\"Og\")")
-#endif
-
-FMT_BEGIN_NAMESPACE
-FMT_MODULE_EXPORT_BEGIN
-
-// Implementations of enable_if_t and other metafunctions for older systems.
-template <bool B, typename T = void>
-using enable_if_t = typename std::enable_if<B, T>::type;
-template <bool B, typename T, typename F>
-using conditional_t = typename std::conditional<B, T, F>::type;
-template <bool B> using bool_constant = std::integral_constant<bool, B>;
-template <typename T>
-using remove_reference_t = typename std::remove_reference<T>::type;
-template <typename T>
-using remove_const_t = typename std::remove_const<T>::type;
-template <typename T>
-using remove_cvref_t = typename std::remove_cv<remove_reference_t<T>>::type;
-template <typename T> struct type_identity { using type = T; };
-template <typename T> using type_identity_t = typename type_identity<T>::type;
-template <typename T>
-using underlying_t = typename std::underlying_type<T>::type;
-
-template <typename...> struct disjunction : std::false_type {};
-template <typename P> struct disjunction<P> : P {};
-template <typename P1, typename... Pn>
-struct disjunction<P1, Pn...>
-    : conditional_t<bool(P1::value), P1, disjunction<Pn...>> {};
-
-template <typename...> struct conjunction : std::true_type {};
-template <typename P> struct conjunction<P> : P {};
-template <typename P1, typename... Pn>
-struct conjunction<P1, Pn...>
-    : conditional_t<bool(P1::value), conjunction<Pn...>, P1> {};
-
-struct monostate {
-  constexpr monostate() {}
-};
-
-// An enable_if helper to be used in template parameters which results in much
-// shorter symbols: https://godbolt.org/z/sWw4vP. Extra parentheses are needed
-// to workaround a bug in MSVC 2019 (see #1140 and #1186).
-#ifdef FMT_DOC
-#  define FMT_ENABLE_IF(...)
-#else
-#  define FMT_ENABLE_IF(...) enable_if_t<(__VA_ARGS__), int> = 0
-#endif
-
-FMT_BEGIN_DETAIL_NAMESPACE
-
-// Suppresses "unused variable" warnings with the method described in
-// https://herbsutter.com/2009/10/18/mailbag-shutting-up-compiler-warnings/.
-// (void)var does not work on many Intel compilers.
-template <typename... T> FMT_CONSTEXPR void ignore_unused(const T&...) {}
-
-constexpr FMT_INLINE auto is_constant_evaluated(
-    bool default_value = false) noexcept -> bool {
-#ifdef __cpp_lib_is_constant_evaluated
-  ignore_unused(default_value);
-  return std::is_constant_evaluated();
-#else
-  return default_value;
-#endif
-}
-
-// Suppresses "conditional expression is constant" warnings.
-template <typename T> constexpr FMT_INLINE auto const_check(T value) -> T {
-  return value;
-}
-
-FMT_NORETURN FMT_API void assert_fail(const char* file, int line,
-                                      const char* message);
-
-#ifndef FMT_ASSERT
-#  ifdef NDEBUG
-// FMT_ASSERT is not empty to avoid -Wempty-body.
-#    define FMT_ASSERT(condition, message) \
-      ::fmt::detail::ignore_unused((condition), (message))
-#  else
-#    define FMT_ASSERT(condition, message)                                    \
-      ((condition) /* void() fails with -Winvalid-constexpr on clang 4.0.1 */ \
-           ? (void)0                                                          \
-           : ::fmt::detail::assert_fail(__FILE__, __LINE__, (message)))
-#  endif
-#endif
-
-#if defined(FMT_USE_STRING_VIEW)
-template <typename Char> using std_string_view = std::basic_string_view<Char>;
-#elif defined(FMT_USE_EXPERIMENTAL_STRING_VIEW)
-template <typename Char>
-using std_string_view = std::experimental::basic_string_view<Char>;
-#else
-template <typename T> struct std_string_view {};
-#endif
-
-#ifdef FMT_USE_INT128
-// Do nothing.
-#elif defined(__SIZEOF_INT128__) && !defined(__NVCC__) && \
-    !(FMT_CLANG_VERSION && FMT_MSC_VERSION)
-#  define FMT_USE_INT128 1
-using int128_opt = __int128_t;  // An optional native 128-bit integer.
-using uint128_opt = __uint128_t;
-template <typename T> inline auto convert_for_visit(T value) -> T {
-  return value;
-}
-#else
-#  define FMT_USE_INT128 0
-#endif
-#if !FMT_USE_INT128
-enum class int128_opt {};
-enum class uint128_opt {};
-// Reduce template instantiations.
-template <typename T> auto convert_for_visit(T) -> monostate { return {}; }
-#endif
-
-// Casts a nonnegative integer to unsigned.
-template <typename Int>
-FMT_CONSTEXPR auto to_unsigned(Int value) ->
-    typename std::make_unsigned<Int>::type {
-  FMT_ASSERT(std::is_unsigned<Int>::value || value >= 0, "negative value");
-  return static_cast<typename std::make_unsigned<Int>::type>(value);
-}
-
-FMT_MSC_WARNING(suppress : 4566) constexpr unsigned char micro[] = "\u00B5";
-
-constexpr auto is_utf8() -> bool {
-  // Avoid buggy sign extensions in MSVC's constant evaluation mode (#2297).
-  using uchar = unsigned char;
-  return FMT_UNICODE || (sizeof(micro) == 3 && uchar(micro[0]) == 0xC2 &&
-                         uchar(micro[1]) == 0xB5);
-}
-FMT_END_DETAIL_NAMESPACE
-
-/**
-  An implementation of ``std::basic_string_view`` for pre-C++17. It provides a
-  subset of the API. ``fmt::basic_string_view`` is used for format strings even
-  if ``std::string_view`` is available to prevent issues when a library is
-  compiled with a different ``-std`` option than the client code (which is not
-  recommended).
- */
-template <typename Char> class basic_string_view {
- private:
-  const Char* data_;
-  size_t size_;
-
- public:
-  using value_type = Char;
-  using iterator = const Char*;
-
-  constexpr basic_string_view() noexcept : data_(nullptr), size_(0) {}
-
-  /** Constructs a string reference object from a C string and a size. */
-  constexpr basic_string_view(const Char* s, size_t count) noexcept
-      : data_(s), size_(count) {}
-
-  /**
-    \rst
-    Constructs a string reference object from a C string computing
-    the size with ``std::char_traits<Char>::length``.
-    \endrst
-   */
-  FMT_CONSTEXPR_CHAR_TRAITS
-  FMT_INLINE
-  basic_string_view(const Char* s)
-      : data_(s),
-        size_(detail::const_check(std::is_same<Char, char>::value &&
-                                  !detail::is_constant_evaluated(true))
-                  ? std::strlen(reinterpret_cast<const char*>(s))
-                  : std::char_traits<Char>::length(s)) {}
-
-  /** Constructs a string reference from a ``std::basic_string`` object. */
-  template <typename Traits, typename Alloc>
-  FMT_CONSTEXPR basic_string_view(
-      const std::basic_string<Char, Traits, Alloc>& s) noexcept
-      : data_(s.data()), size_(s.size()) {}
-
-  template <typename S, FMT_ENABLE_IF(std::is_same<
-                                      S, detail::std_string_view<Char>>::value)>
-  FMT_CONSTEXPR basic_string_view(S s) noexcept
-      : data_(s.data()), size_(s.size()) {}
-
-  /** Returns a pointer to the string data. */
-  constexpr auto data() const noexcept -> const Char* { return data_; }
-
-  /** Returns the string size. */
-  constexpr auto size() const noexcept -> size_t { return size_; }
-
-  constexpr auto begin() const noexcept -> iterator { return data_; }
-  constexpr auto end() const noexcept -> iterator { return data_ + size_; }
-
-  constexpr auto operator[](size_t pos) const noexcept -> const Char& {
-    return data_[pos];
-  }
-
-  FMT_CONSTEXPR void remove_prefix(size_t n) noexcept {
-    data_ += n;
-    size_ -= n;
-  }
-
-  // Lexicographically compare this string reference to other.
-  FMT_CONSTEXPR_CHAR_TRAITS auto compare(basic_string_view other) const -> int {
-    size_t str_size = size_ < other.size_ ? size_ : other.size_;
-    int result = std::char_traits<Char>::compare(data_, other.data_, str_size);
-    if (result == 0)
-      result = size_ == other.size_ ? 0 : (size_ < other.size_ ? -1 : 1);
-    return result;
-  }
-
-  FMT_CONSTEXPR_CHAR_TRAITS friend auto operator==(basic_string_view lhs,
-                                                   basic_string_view rhs)
-      -> bool {
-    return lhs.compare(rhs) == 0;
-  }
-  friend auto operator!=(basic_string_view lhs, basic_string_view rhs) -> bool {
-    return lhs.compare(rhs) != 0;
-  }
-  friend auto operator<(basic_string_view lhs, basic_string_view rhs) -> bool {
-    return lhs.compare(rhs) < 0;
-  }
-  friend auto operator<=(basic_string_view lhs, basic_string_view rhs) -> bool {
-    return lhs.compare(rhs) <= 0;
-  }
-  friend auto operator>(basic_string_view lhs, basic_string_view rhs) -> bool {
-    return lhs.compare(rhs) > 0;
-  }
-  friend auto operator>=(basic_string_view lhs, basic_string_view rhs) -> bool {
-    return lhs.compare(rhs) >= 0;
-  }
-};
-
-using string_view = basic_string_view<char>;
-
-/** Specifies if ``T`` is a character type. Can be specialized by users. */
-template <typename T> struct is_char : std::false_type {};
-template <> struct is_char<char> : std::true_type {};
-
-FMT_BEGIN_DETAIL_NAMESPACE
-
-// A base class for compile-time strings.
-struct compile_string {};
-
-template <typename S>
-struct is_compile_string : std::is_base_of<compile_string, S> {};
-
-// Returns a string view of `s`.
-template <typename Char, FMT_ENABLE_IF(is_char<Char>::value)>
-FMT_INLINE auto to_string_view(const Char* s) -> basic_string_view<Char> {
-  return s;
-}
-template <typename Char, typename Traits, typename Alloc>
-inline auto to_string_view(const std::basic_string<Char, Traits, Alloc>& s)
-    -> basic_string_view<Char> {
-  return s;
-}
-template <typename Char>
-constexpr auto to_string_view(basic_string_view<Char> s)
-    -> basic_string_view<Char> {
-  return s;
-}
-template <typename Char,
-          FMT_ENABLE_IF(!std::is_empty<std_string_view<Char>>::value)>
-inline auto to_string_view(std_string_view<Char> s) -> basic_string_view<Char> {
-  return s;
-}
-template <typename S, FMT_ENABLE_IF(is_compile_string<S>::value)>
-constexpr auto to_string_view(const S& s)
-    -> basic_string_view<typename S::char_type> {
-  return basic_string_view<typename S::char_type>(s);
-}
-void to_string_view(...);
-
-// Specifies whether S is a string type convertible to fmt::basic_string_view.
-// It should be a constexpr function but MSVC 2017 fails to compile it in
-// enable_if and MSVC 2015 fails to compile it as an alias template.
-// ADL invocation of to_string_view is DEPRECATED!
-template <typename S>
-struct is_string : std::is_class<decltype(to_string_view(std::declval<S>()))> {
-};
-
-template <typename S, typename = void> struct char_t_impl {};
-template <typename S> struct char_t_impl<S, enable_if_t<is_string<S>::value>> {
-  using result = decltype(to_string_view(std::declval<S>()));
-  using type = typename result::value_type;
-};
-
-enum class type {
-  none_type,
-  // Integer types should go first,
-  int_type,
-  uint_type,
-  long_long_type,
-  ulong_long_type,
-  int128_type,
-  uint128_type,
-  bool_type,
-  char_type,
-  last_integer_type = char_type,
-  // followed by floating-point types.
-  float_type,
-  double_type,
-  long_double_type,
-  last_numeric_type = long_double_type,
-  cstring_type,
-  string_type,
-  pointer_type,
-  custom_type
-};
-
-// Maps core type T to the corresponding type enum constant.
-template <typename T, typename Char>
-struct type_constant : std::integral_constant<type, type::custom_type> {};
-
-#define FMT_TYPE_CONSTANT(Type, constant) \
-  template <typename Char>                \
-  struct type_constant<Type, Char>        \
-      : std::integral_constant<type, type::constant> {}
-
-FMT_TYPE_CONSTANT(int, int_type);
-FMT_TYPE_CONSTANT(unsigned, uint_type);
-FMT_TYPE_CONSTANT(long long, long_long_type);
-FMT_TYPE_CONSTANT(unsigned long long, ulong_long_type);
-FMT_TYPE_CONSTANT(int128_opt, int128_type);
-FMT_TYPE_CONSTANT(uint128_opt, uint128_type);
-FMT_TYPE_CONSTANT(bool, bool_type);
-FMT_TYPE_CONSTANT(Char, char_type);
-FMT_TYPE_CONSTANT(float, float_type);
-FMT_TYPE_CONSTANT(double, double_type);
-FMT_TYPE_CONSTANT(long double, long_double_type);
-FMT_TYPE_CONSTANT(const Char*, cstring_type);
-FMT_TYPE_CONSTANT(basic_string_view<Char>, string_type);
-FMT_TYPE_CONSTANT(const void*, pointer_type);
-
-constexpr bool is_integral_type(type t) {
-  return t > type::none_type && t <= type::last_integer_type;
-}
-
-constexpr bool is_arithmetic_type(type t) {
-  return t > type::none_type && t <= type::last_numeric_type;
-}
-
-FMT_NORETURN FMT_API void throw_format_error(const char* message);
-
-struct error_handler {
-  constexpr error_handler() = default;
-  constexpr error_handler(const error_handler&) = default;
-
-  // This function is intentionally not constexpr to give a compile-time error.
-  FMT_NORETURN void on_error(const char* message) {
-    throw_format_error(message);
-  }
-};
-FMT_END_DETAIL_NAMESPACE
-
-/** String's character type. */
-template <typename S> using char_t = typename detail::char_t_impl<S>::type;
-
-/**
-  \rst
-  Parsing context consisting of a format string range being parsed and an
-  argument counter for automatic indexing.
-  You can use the ``format_parse_context`` type alias for ``char`` instead.
-  \endrst
- */
-template <typename Char, typename ErrorHandler = detail::error_handler>
-class basic_format_parse_context : private ErrorHandler {
- private:
-  basic_string_view<Char> format_str_;
-  int next_arg_id_;
-
-  FMT_CONSTEXPR void do_check_arg_id(int id);
-
- public:
-  using char_type = Char;
-  using iterator = typename basic_string_view<Char>::iterator;
-
-  explicit constexpr basic_format_parse_context(
-      basic_string_view<Char> format_str, ErrorHandler eh = {},
-      int next_arg_id = 0)
-      : ErrorHandler(eh), format_str_(format_str), next_arg_id_(next_arg_id) {}
-
-  /**
-    Returns an iterator to the beginning of the format string range being
-    parsed.
-   */
-  constexpr auto begin() const noexcept -> iterator {
-    return format_str_.begin();
-  }
-
-  /**
-    Returns an iterator past the end of the format string range being parsed.
-   */
-  constexpr auto end() const noexcept -> iterator { return format_str_.end(); }
-
-  /** Advances the begin iterator to ``it``. */
-  FMT_CONSTEXPR void advance_to(iterator it) {
-    format_str_.remove_prefix(detail::to_unsigned(it - begin()));
-  }
-
-  /**
-    Reports an error if using the manual argument indexing; otherwise returns
-    the next argument index and switches to the automatic indexing.
-   */
-  FMT_CONSTEXPR auto next_arg_id() -> int {
-    if (next_arg_id_ < 0) {
-      on_error("cannot switch from manual to automatic argument indexing");
-      return 0;
-    }
-    int id = next_arg_id_++;
-    do_check_arg_id(id);
-    return id;
-  }
-
-  /**
-    Reports an error if using the automatic argument indexing; otherwise
-    switches to the manual indexing.
-   */
-  FMT_CONSTEXPR void check_arg_id(int id) {
-    if (next_arg_id_ > 0) {
-      on_error("cannot switch from automatic to manual argument indexing");
-      return;
-    }
-    next_arg_id_ = -1;
-    do_check_arg_id(id);
-  }
-  FMT_CONSTEXPR void check_arg_id(basic_string_view<Char>) {}
-  FMT_CONSTEXPR void check_dynamic_spec(int arg_id);
-
-  FMT_CONSTEXPR void on_error(const char* message) {
-    ErrorHandler::on_error(message);
-  }
-
-  constexpr auto error_handler() const -> ErrorHandler { return *this; }
-};
-
-using format_parse_context = basic_format_parse_context<char>;
-
-FMT_BEGIN_DETAIL_NAMESPACE
-// A parse context with extra data used only in compile-time checks.
-template <typename Char, typename ErrorHandler = detail::error_handler>
-class compile_parse_context
-    : public basic_format_parse_context<Char, ErrorHandler> {
- private:
-  int num_args_;
-  const type* types_;
-  using base = basic_format_parse_context<Char, ErrorHandler>;
-
- public:
-  explicit FMT_CONSTEXPR compile_parse_context(
-      basic_string_view<Char> format_str, int num_args, const type* types,
-      ErrorHandler eh = {}, int next_arg_id = 0)
-      : base(format_str, eh, next_arg_id), num_args_(num_args), types_(types) {}
-
-  constexpr auto num_args() const -> int { return num_args_; }
-  constexpr auto arg_type(int id) const -> type { return types_[id]; }
-
-  FMT_CONSTEXPR auto next_arg_id() -> int {
-    int id = base::next_arg_id();
-    if (id >= num_args_) this->on_error("argument not found");
-    return id;
-  }
-
-  FMT_CONSTEXPR void check_arg_id(int id) {
-    base::check_arg_id(id);
-    if (id >= num_args_) this->on_error("argument not found");
-  }
-  using base::check_arg_id;
-
-  FMT_CONSTEXPR void check_dynamic_spec(int arg_id) {
-    if (arg_id < num_args_ && types_ && !is_integral_type(types_[arg_id]))
-      this->on_error("width/precision is not integer");
-  }
-};
-FMT_END_DETAIL_NAMESPACE
-
-template <typename Char, typename ErrorHandler>
-FMT_CONSTEXPR void
-basic_format_parse_context<Char, ErrorHandler>::do_check_arg_id(int id) {
-  // Argument id is only checked at compile-time during parsing because
-  // formatting has its own validation.
-  if (detail::is_constant_evaluated() && FMT_GCC_VERSION >= 1200) {
-    using context = detail::compile_parse_context<Char, ErrorHandler>;
-    if (id >= static_cast<context*>(this)->num_args())
-      on_error("argument not found");
-  }
-}
-
-template <typename Char, typename ErrorHandler>
-FMT_CONSTEXPR void
-basic_format_parse_context<Char, ErrorHandler>::check_dynamic_spec(int arg_id) {
-  if (detail::is_constant_evaluated()) {
-    using context = detail::compile_parse_context<Char, ErrorHandler>;
-    static_cast<context*>(this)->check_dynamic_spec(arg_id);
-  }
-}
-
-template <typename Context> class basic_format_arg;
-template <typename Context> class basic_format_args;
-template <typename Context> class dynamic_format_arg_store;
-
-// A formatter for objects of type T.
-template <typename T, typename Char = char, typename Enable = void>
-struct formatter {
-  // A deleted default constructor indicates a disabled formatter.
-  formatter() = delete;
-};
-
-// Specifies if T has an enabled formatter specialization. A type can be
-// formattable even if it doesn't have a formatter e.g. via a conversion.
-template <typename T, typename Context>
-using has_formatter =
-    std::is_constructible<typename Context::template formatter_type<T>>;
-
-// Checks whether T is a container with contiguous storage.
-template <typename T> struct is_contiguous : std::false_type {};
-template <typename Char>
-struct is_contiguous<std::basic_string<Char>> : std::true_type {};
-
-class appender;
-
-FMT_BEGIN_DETAIL_NAMESPACE
-
-template <typename Context, typename T>
-constexpr auto has_const_formatter_impl(T*)
-    -> decltype(typename Context::template formatter_type<T>().format(
-                    std::declval<const T&>(), std::declval<Context&>()),
-                true) {
-  return true;
-}
-template <typename Context>
-constexpr auto has_const_formatter_impl(...) -> bool {
-  return false;
-}
-template <typename T, typename Context>
-constexpr auto has_const_formatter() -> bool {
-  return has_const_formatter_impl<Context>(static_cast<T*>(nullptr));
-}
-
-// Extracts a reference to the container from back_insert_iterator.
-template <typename Container>
-inline auto get_container(std::back_insert_iterator<Container> it)
-    -> Container& {
-  using base = std::back_insert_iterator<Container>;
-  struct accessor : base {
-    accessor(base b) : base(b) {}
-    using base::container;
-  };
-  return *accessor(it).container;
-}
-
-template <typename Char, typename InputIt, typename OutputIt>
-FMT_CONSTEXPR auto copy_str(InputIt begin, InputIt end, OutputIt out)
-    -> OutputIt {
-  while (begin != end) *out++ = static_cast<Char>(*begin++);
-  return out;
-}
-
-template <typename Char, typename T, typename U,
-          FMT_ENABLE_IF(
-              std::is_same<remove_const_t<T>, U>::value&& is_char<U>::value)>
-FMT_CONSTEXPR auto copy_str(T* begin, T* end, U* out) -> U* {
-  if (is_constant_evaluated()) return copy_str<Char, T*, U*>(begin, end, out);
-  auto size = to_unsigned(end - begin);
-  memcpy(out, begin, size * sizeof(U));
-  return out + size;
-}
-
-/**
-  \rst
-  A contiguous memory buffer with an optional growing ability. It is an internal
-  class and shouldn't be used directly, only via `~fmt::basic_memory_buffer`.
-  \endrst
- */
-template <typename T> class buffer {
- private:
-  T* ptr_;
-  size_t size_;
-  size_t capacity_;
-
- protected:
-  // Don't initialize ptr_ since it is not accessed to save a few cycles.
-  FMT_MSC_WARNING(suppress : 26495)
-  buffer(size_t sz) noexcept : size_(sz), capacity_(sz) {}
-
-  FMT_CONSTEXPR20 buffer(T* p = nullptr, size_t sz = 0, size_t cap = 0) noexcept
-      : ptr_(p), size_(sz), capacity_(cap) {}
-
-  FMT_CONSTEXPR20 ~buffer() = default;
-  buffer(buffer&&) = default;
-
-  /** Sets the buffer data and capacity. */
-  FMT_CONSTEXPR void set(T* buf_data, size_t buf_capacity) noexcept {
-    ptr_ = buf_data;
-    capacity_ = buf_capacity;
-  }
-
-  /** Increases the buffer capacity to hold at least *capacity* elements. */
-  virtual FMT_CONSTEXPR20 void grow(size_t capacity) = 0;
-
- public:
-  using value_type = T;
-  using const_reference = const T&;
-
-  buffer(const buffer&) = delete;
-  void operator=(const buffer&) = delete;
-
-  auto begin() noexcept -> T* { return ptr_; }
-  auto end() noexcept -> T* { return ptr_ + size_; }
-
-  auto begin() const noexcept -> const T* { return ptr_; }
-  auto end() const noexcept -> const T* { return ptr_ + size_; }
-
-  /** Returns the size of this buffer. */
-  constexpr auto size() const noexcept -> size_t { return size_; }
-
-  /** Returns the capacity of this buffer. */
-  constexpr auto capacity() const noexcept -> size_t { return capacity_; }
-
-  /** Returns a pointer to the buffer data. */
-  FMT_CONSTEXPR auto data() noexcept -> T* { return ptr_; }
-
-  /** Returns a pointer to the buffer data. */
-  FMT_CONSTEXPR auto data() const noexcept -> const T* { return ptr_; }
-
-  /** Clears this buffer. */
-  void clear() { size_ = 0; }
-
-  // Tries resizing the buffer to contain *count* elements. If T is a POD type
-  // the new elements may not be initialized.
-  FMT_CONSTEXPR20 void try_resize(size_t count) {
-    try_reserve(count);
-    size_ = count <= capacity_ ? count : capacity_;
-  }
-
-  // Tries increasing the buffer capacity to *new_capacity*. It can increase the
-  // capacity by a smaller amount than requested but guarantees there is space
-  // for at least one additional element either by increasing the capacity or by
-  // flushing the buffer if it is full.
-  FMT_CONSTEXPR20 void try_reserve(size_t new_capacity) {
-    if (new_capacity > capacity_) grow(new_capacity);
-  }
-
-  FMT_CONSTEXPR20 void push_back(const T& value) {
-    try_reserve(size_ + 1);
-    ptr_[size_++] = value;
-  }
-
-  /** Appends data to the end of the buffer. */
-  template <typename U> void append(const U* begin, const U* end);
-
-  template <typename Idx> FMT_CONSTEXPR auto operator[](Idx index) -> T& {
-    return ptr_[index];
-  }
-  template <typename Idx>
-  FMT_CONSTEXPR auto operator[](Idx index) const -> const T& {
-    return ptr_[index];
-  }
-};
-
-struct buffer_traits {
-  explicit buffer_traits(size_t) {}
-  auto count() const -> size_t { return 0; }
-  auto limit(size_t size) -> size_t { return size; }
-};
-
-class fixed_buffer_traits {
- private:
-  size_t count_ = 0;
-  size_t limit_;
-
- public:
-  explicit fixed_buffer_traits(size_t limit) : limit_(limit) {}
-  auto count() const -> size_t { return count_; }
-  auto limit(size_t size) -> size_t {
-    size_t n = limit_ > count_ ? limit_ - count_ : 0;
-    count_ += size;
-    return size < n ? size : n;
-  }
-};
-
-// A buffer that writes to an output iterator when flushed.
-template <typename OutputIt, typename T, typename Traits = buffer_traits>
-class iterator_buffer final : public Traits, public buffer<T> {
- private:
-  OutputIt out_;
-  enum { buffer_size = 256 };
-  T data_[buffer_size];
-
- protected:
-  FMT_CONSTEXPR20 void grow(size_t) override {
-    if (this->size() == buffer_size) flush();
-  }
-
-  void flush() {
-    auto size = this->size();
-    this->clear();
-    out_ = copy_str<T>(data_, data_ + this->limit(size), out_);
-  }
-
- public:
-  explicit iterator_buffer(OutputIt out, size_t n = buffer_size)
-      : Traits(n), buffer<T>(data_, 0, buffer_size), out_(out) {}
-  iterator_buffer(iterator_buffer&& other)
-      : Traits(other), buffer<T>(data_, 0, buffer_size), out_(other.out_) {}
-  ~iterator_buffer() { flush(); }
-
-  auto out() -> OutputIt {
-    flush();
-    return out_;
-  }
-  auto count() const -> size_t { return Traits::count() + this->size(); }
-};
-
-template <typename T>
-class iterator_buffer<T*, T, fixed_buffer_traits> final
-    : public fixed_buffer_traits,
-      public buffer<T> {
- private:
-  T* out_;
-  enum { buffer_size = 256 };
-  T data_[buffer_size];
-
- protected:
-  FMT_CONSTEXPR20 void grow(size_t) override {
-    if (this->size() == this->capacity()) flush();
-  }
-
-  void flush() {
-    size_t n = this->limit(this->size());
-    if (this->data() == out_) {
-      out_ += n;
-      this->set(data_, buffer_size);
-    }
-    this->clear();
-  }
-
- public:
-  explicit iterator_buffer(T* out, size_t n = buffer_size)
-      : fixed_buffer_traits(n), buffer<T>(out, 0, n), out_(out) {}
-  iterator_buffer(iterator_buffer&& other)
-      : fixed_buffer_traits(other),
-        buffer<T>(std::move(other)),
-        out_(other.out_) {
-    if (this->data() != out_) {
-      this->set(data_, buffer_size);
-      this->clear();
-    }
-  }
-  ~iterator_buffer() { flush(); }
-
-  auto out() -> T* {
-    flush();
-    return out_;
-  }
-  auto count() const -> size_t {
-    return fixed_buffer_traits::count() + this->size();
-  }
-};
-
-template <typename T> class iterator_buffer<T*, T> final : public buffer<T> {
- protected:
-  FMT_CONSTEXPR20 void grow(size_t) override {}
-
- public:
-  explicit iterator_buffer(T* out, size_t = 0) : buffer<T>(out, 0, ~size_t()) {}
-
-  auto out() -> T* { return &*this->end(); }
-};
-
-// A buffer that writes to a container with the contiguous storage.
-template <typename Container>
-class iterator_buffer<std::back_insert_iterator<Container>,
-                      enable_if_t<is_contiguous<Container>::value,
-                                  typename Container::value_type>>
-    final : public buffer<typename Container::value_type> {
- private:
-  Container& container_;
-
- protected:
-  FMT_CONSTEXPR20 void grow(size_t capacity) override {
-    container_.resize(capacity);
-    this->set(&container_[0], capacity);
-  }
-
- public:
-  explicit iterator_buffer(Container& c)
-      : buffer<typename Container::value_type>(c.size()), container_(c) {}
-  explicit iterator_buffer(std::back_insert_iterator<Container> out, size_t = 0)
-      : iterator_buffer(get_container(out)) {}
-
-  auto out() -> std::back_insert_iterator<Container> {
-    return std::back_inserter(container_);
-  }
-};
-
-// A buffer that counts the number of code units written discarding the output.
-template <typename T = char> class counting_buffer final : public buffer<T> {
- private:
-  enum { buffer_size = 256 };
-  T data_[buffer_size];
-  size_t count_ = 0;
-
- protected:
-  FMT_CONSTEXPR20 void grow(size_t) override {
-    if (this->size() != buffer_size) return;
-    count_ += this->size();
-    this->clear();
-  }
-
- public:
-  counting_buffer() : buffer<T>(data_, 0, buffer_size) {}
-
-  auto count() -> size_t { return count_ + this->size(); }
-};
-
-template <typename T>
-using buffer_appender = conditional_t<std::is_same<T, char>::value, appender,
-                                      std::back_insert_iterator<buffer<T>>>;
-
-// Maps an output iterator to a buffer.
-template <typename T, typename OutputIt>
-auto get_buffer(OutputIt out) -> iterator_buffer<OutputIt, T> {
-  return iterator_buffer<OutputIt, T>(out);
-}
-
-template <typename Buffer>
-auto get_iterator(Buffer& buf) -> decltype(buf.out()) {
-  return buf.out();
-}
-template <typename T> auto get_iterator(buffer<T>& buf) -> buffer_appender<T> {
-  return buffer_appender<T>(buf);
-}
-
-template <typename T, typename Char = char, typename Enable = void>
-struct fallback_formatter {
-  fallback_formatter() = delete;
-};
-
-// Specifies if T has an enabled fallback_formatter specialization.
-template <typename T, typename Char>
-using has_fallback_formatter =
-#ifdef FMT_DEPRECATED_OSTREAM
-    std::is_constructible<fallback_formatter<T, Char>>;
-#else
-    std::false_type;
-#endif
-
-struct view {};
-
-template <typename Char, typename T> struct named_arg : view {
-  const Char* name;
-  const T& value;
-  named_arg(const Char* n, const T& v) : name(n), value(v) {}
-};
-
-template <typename Char> struct named_arg_info {
-  const Char* name;
-  int id;
-};
-
-template <typename T, typename Char, size_t NUM_ARGS, size_t NUM_NAMED_ARGS>
-struct arg_data {
-  // args_[0].named_args points to named_args_ to avoid bloating format_args.
-  // +1 to workaround a bug in gcc 7.5 that causes duplicated-branches warning.
-  T args_[1 + (NUM_ARGS != 0 ? NUM_ARGS : +1)];
-  named_arg_info<Char> named_args_[NUM_NAMED_ARGS];
-
-  template <typename... U>
-  arg_data(const U&... init) : args_{T(named_args_, NUM_NAMED_ARGS), init...} {}
-  arg_data(const arg_data& other) = delete;
-  auto args() const -> const T* { return args_ + 1; }
-  auto named_args() -> named_arg_info<Char>* { return named_args_; }
-};
-
-template <typename T, typename Char, size_t NUM_ARGS>
-struct arg_data<T, Char, NUM_ARGS, 0> {
-  // +1 to workaround a bug in gcc 7.5 that causes duplicated-branches warning.
-  T args_[NUM_ARGS != 0 ? NUM_ARGS : +1];
-
-  template <typename... U>
-  FMT_CONSTEXPR FMT_INLINE arg_data(const U&... init) : args_{init...} {}
-  FMT_CONSTEXPR FMT_INLINE auto args() const -> const T* { return args_; }
-  FMT_CONSTEXPR FMT_INLINE auto named_args() -> std::nullptr_t {
-    return nullptr;
-  }
-};
-
-template <typename Char>
-inline void init_named_args(named_arg_info<Char>*, int, int) {}
-
-template <typename T> struct is_named_arg : std::false_type {};
-template <typename T> struct is_statically_named_arg : std::false_type {};
-
-template <typename T, typename Char>
-struct is_named_arg<named_arg<Char, T>> : std::true_type {};
-
-template <typename Char, typename T, typename... Tail,
-          FMT_ENABLE_IF(!is_named_arg<T>::value)>
-void init_named_args(named_arg_info<Char>* named_args, int arg_count,
-                     int named_arg_count, const T&, const Tail&... args) {
-  init_named_args(named_args, arg_count + 1, named_arg_count, args...);
-}
-
-template <typename Char, typename T, typename... Tail,
-          FMT_ENABLE_IF(is_named_arg<T>::value)>
-void init_named_args(named_arg_info<Char>* named_args, int arg_count,
-                     int named_arg_count, const T& arg, const Tail&... args) {
-  named_args[named_arg_count++] = {arg.name, arg_count};
-  init_named_args(named_args, arg_count + 1, named_arg_count, args...);
-}
-
-template <typename... Args>
-FMT_CONSTEXPR FMT_INLINE void init_named_args(std::nullptr_t, int, int,
-                                              const Args&...) {}
-
-template <bool B = false> constexpr auto count() -> size_t { return B ? 1 : 0; }
-template <bool B1, bool B2, bool... Tail> constexpr auto count() -> size_t {
-  return (B1 ? 1 : 0) + count<B2, Tail...>();
-}
-
-template <typename... Args> constexpr auto count_named_args() -> size_t {
-  return count<is_named_arg<Args>::value...>();
-}
-
-template <typename... Args>
-constexpr auto count_statically_named_args() -> size_t {
-  return count<is_statically_named_arg<Args>::value...>();
-}
-
-struct unformattable {};
-struct unformattable_char : unformattable {};
-struct unformattable_const : unformattable {};
-struct unformattable_pointer : unformattable {};
-
-template <typename Char> struct string_value {
-  const Char* data;
-  size_t size;
-};
-
-template <typename Char> struct named_arg_value {
-  const named_arg_info<Char>* data;
-  size_t size;
-};
-
-template <typename Context> struct custom_value {
-  using parse_context = typename Context::parse_context_type;
-  void* value;
-  void (*format)(void* arg, parse_context& parse_ctx, Context& ctx);
-};
-
-// A formatting argument value.
-template <typename Context> class value {
- public:
-  using char_type = typename Context::char_type;
-
-  union {
-    monostate no_value;
-    int int_value;
-    unsigned uint_value;
-    long long long_long_value;
-    unsigned long long ulong_long_value;
-    int128_opt int128_value;
-    uint128_opt uint128_value;
-    bool bool_value;
-    char_type char_value;
-    float float_value;
-    double double_value;
-    long double long_double_value;
-    const void* pointer;
-    string_value<char_type> string;
-    custom_value<Context> custom;
-    named_arg_value<char_type> named_args;
-  };
-
-  constexpr FMT_INLINE value() : no_value() {}
-  constexpr FMT_INLINE value(int val) : int_value(val) {}
-  constexpr FMT_INLINE value(unsigned val) : uint_value(val) {}
-  constexpr FMT_INLINE value(long long val) : long_long_value(val) {}
-  constexpr FMT_INLINE value(unsigned long long val) : ulong_long_value(val) {}
-  FMT_INLINE value(int128_opt val) : int128_value(val) {}
-  FMT_INLINE value(uint128_opt val) : uint128_value(val) {}
-  constexpr FMT_INLINE value(float val) : float_value(val) {}
-  constexpr FMT_INLINE value(double val) : double_value(val) {}
-  FMT_INLINE value(long double val) : long_double_value(val) {}
-  constexpr FMT_INLINE value(bool val) : bool_value(val) {}
-  constexpr FMT_INLINE value(char_type val) : char_value(val) {}
-  FMT_CONSTEXPR FMT_INLINE value(const char_type* val) {
-    string.data = val;
-    if (is_constant_evaluated()) string.size = {};
-  }
-  FMT_CONSTEXPR FMT_INLINE value(basic_string_view<char_type> val) {
-    string.data = val.data();
-    string.size = val.size();
-  }
-  FMT_INLINE value(const void* val) : pointer(val) {}
-  FMT_INLINE value(const named_arg_info<char_type>* args, size_t size)
-      : named_args{args, size} {}
-
-  template <typename T> FMT_CONSTEXPR FMT_INLINE value(T& val) {
-    using value_type = remove_cvref_t<T>;
-    custom.value = const_cast<value_type*>(&val);
-    // Get the formatter type through the context to allow different contexts
-    // have different extension points, e.g. `formatter<T>` for `format` and
-    // `printf_formatter<T>` for `printf`.
-    custom.format = format_custom_arg<
-        value_type,
-        conditional_t<has_formatter<value_type, Context>::value,
-                      typename Context::template formatter_type<value_type>,
-                      fallback_formatter<value_type, char_type>>>;
-  }
-  value(unformattable);
-  value(unformattable_char);
-  value(unformattable_const);
-  value(unformattable_pointer);
-
- private:
-  // Formats an argument of a custom type, such as a user-defined class.
-  template <typename T, typename Formatter>
-  static void format_custom_arg(void* arg,
-                                typename Context::parse_context_type& parse_ctx,
-                                Context& ctx) {
-    auto f = Formatter();
-    parse_ctx.advance_to(f.parse(parse_ctx));
-    using qualified_type =
-        conditional_t<has_const_formatter<T, Context>(), const T, T>;
-    ctx.advance_to(f.format(*static_cast<qualified_type*>(arg), ctx));
-  }
-};
-
-template <typename Context, typename T>
-FMT_CONSTEXPR auto make_arg(T&& value) -> basic_format_arg<Context>;
-
-// To minimize the number of types we need to deal with, long is translated
-// either to int or to long long depending on its size.
-enum { long_short = sizeof(long) == sizeof(int) };
-using long_type = conditional_t<long_short, int, long long>;
-using ulong_type = conditional_t<long_short, unsigned, unsigned long long>;
-
-#ifdef __cpp_lib_byte
-inline auto format_as(std::byte b) -> unsigned char {
-  return static_cast<unsigned char>(b);
-}
-#endif
-
-template <typename T> struct has_format_as {
-  template <typename U, typename V = decltype(format_as(U())),
-            FMT_ENABLE_IF(std::is_enum<U>::value&& std::is_integral<V>::value)>
-  static auto check(U*) -> std::true_type;
-  static auto check(...) -> std::false_type;
-
-  enum { value = decltype(check(static_cast<T*>(nullptr)))::value };
-};
-
-// Maps formatting arguments to core types.
-// arg_mapper reports errors by returning unformattable instead of using
-// static_assert because it's used in the is_formattable trait.
-template <typename Context> struct arg_mapper {
-  using char_type = typename Context::char_type;
-
-  FMT_CONSTEXPR FMT_INLINE auto map(signed char val) -> int { return val; }
-  FMT_CONSTEXPR FMT_INLINE auto map(unsigned char val) -> unsigned {
-    return val;
-  }
-  FMT_CONSTEXPR FMT_INLINE auto map(short val) -> int { return val; }
-  FMT_CONSTEXPR FMT_INLINE auto map(unsigned short val) -> unsigned {
-    return val;
-  }
-  FMT_CONSTEXPR FMT_INLINE auto map(int val) -> int { return val; }
-  FMT_CONSTEXPR FMT_INLINE auto map(unsigned val) -> unsigned { return val; }
-  FMT_CONSTEXPR FMT_INLINE auto map(long val) -> long_type { return val; }
-  FMT_CONSTEXPR FMT_INLINE auto map(unsigned long val) -> ulong_type {
-    return val;
-  }
-  FMT_CONSTEXPR FMT_INLINE auto map(long long val) -> long long { return val; }
-  FMT_CONSTEXPR FMT_INLINE auto map(unsigned long long val)
-      -> unsigned long long {
-    return val;
-  }
-  FMT_CONSTEXPR FMT_INLINE auto map(int128_opt val) -> int128_opt {
-    return val;
-  }
-  FMT_CONSTEXPR FMT_INLINE auto map(uint128_opt val) -> uint128_opt {
-    return val;
-  }
-  FMT_CONSTEXPR FMT_INLINE auto map(bool val) -> bool { return val; }
-
-  template <typename T, FMT_ENABLE_IF(std::is_same<T, char>::value ||
-                                      std::is_same<T, char_type>::value)>
-  FMT_CONSTEXPR FMT_INLINE auto map(T val) -> char_type {
-    return val;
-  }
-  template <typename T, enable_if_t<(std::is_same<T, wchar_t>::value ||
-#ifdef __cpp_char8_t
-                                     std::is_same<T, char8_t>::value ||
-#endif
-                                     std::is_same<T, char16_t>::value ||
-                                     std::is_same<T, char32_t>::value) &&
-                                        !std::is_same<T, char_type>::value,
-                                    int> = 0>
-  FMT_CONSTEXPR FMT_INLINE auto map(T) -> unformattable_char {
-    return {};
-  }
-
-  FMT_CONSTEXPR FMT_INLINE auto map(float val) -> float { return val; }
-  FMT_CONSTEXPR FMT_INLINE auto map(double val) -> double { return val; }
-  FMT_CONSTEXPR FMT_INLINE auto map(long double val) -> long double {
-    return val;
-  }
-
-  FMT_CONSTEXPR FMT_INLINE auto map(char_type* val) -> const char_type* {
-    return val;
-  }
-  FMT_CONSTEXPR FMT_INLINE auto map(const char_type* val) -> const char_type* {
-    return val;
-  }
-  template <typename T,
-            FMT_ENABLE_IF(is_string<T>::value && !std::is_pointer<T>::value &&
-                          std::is_same<char_type, char_t<T>>::value)>
-  FMT_CONSTEXPR FMT_INLINE auto map(const T& val)
-      -> basic_string_view<char_type> {
-    return to_string_view(val);
-  }
-  template <typename T,
-            FMT_ENABLE_IF(is_string<T>::value && !std::is_pointer<T>::value &&
-                          !std::is_same<char_type, char_t<T>>::value)>
-  FMT_CONSTEXPR FMT_INLINE auto map(const T&) -> unformattable_char {
-    return {};
-  }
-  template <typename T,
-            FMT_ENABLE_IF(
-                std::is_convertible<T, basic_string_view<char_type>>::value &&
-                !is_string<T>::value && !has_formatter<T, Context>::value &&
-                !has_fallback_formatter<T, char_type>::value)>
-  FMT_CONSTEXPR FMT_INLINE auto map(const T& val)
-      -> basic_string_view<char_type> {
-    return basic_string_view<char_type>(val);
-  }
-  template <typename T,
-            FMT_ENABLE_IF(
-                std::is_convertible<T, std_string_view<char_type>>::value &&
-                !std::is_convertible<T, basic_string_view<char_type>>::value &&
-                !is_string<T>::value && !has_formatter<T, Context>::value &&
-                !has_fallback_formatter<T, char_type>::value)>
-  FMT_CONSTEXPR FMT_INLINE auto map(const T& val)
-      -> basic_string_view<char_type> {
-    return std_string_view<char_type>(val);
-  }
-
-  FMT_CONSTEXPR FMT_INLINE auto map(void* val) -> const void* { return val; }
-  FMT_CONSTEXPR FMT_INLINE auto map(const void* val) -> const void* {
-    return val;
-  }
-  FMT_CONSTEXPR FMT_INLINE auto map(std::nullptr_t val) -> const void* {
-    return val;
-  }
-
-  // We use SFINAE instead of a const T* parameter to avoid conflicting with
-  // the C array overload.
-  template <
-      typename T,
-      FMT_ENABLE_IF(
-          std::is_pointer<T>::value || std::is_member_pointer<T>::value ||
-          std::is_function<typename std::remove_pointer<T>::type>::value ||
-          (std::is_convertible<const T&, const void*>::value &&
-           !std::is_convertible<const T&, const char_type*>::value &&
-           !has_formatter<T, Context>::value))>
-  FMT_CONSTEXPR auto map(const T&) -> unformattable_pointer {
-    return {};
-  }
-
-  template <typename T, std::size_t N,
-            FMT_ENABLE_IF(!std::is_same<T, wchar_t>::value)>
-  FMT_CONSTEXPR FMT_INLINE auto map(const T (&values)[N]) -> const T (&)[N] {
-    return values;
-  }
-
-  template <typename T,
-            FMT_ENABLE_IF(
-                std::is_enum<T>::value&& std::is_convertible<T, int>::value &&
-                !has_format_as<T>::value && !has_formatter<T, Context>::value &&
-                !has_fallback_formatter<T, char_type>::value)>
-  FMT_DEPRECATED FMT_CONSTEXPR FMT_INLINE auto map(const T& val)
-      -> decltype(std::declval<arg_mapper>().map(
-          static_cast<underlying_t<T>>(val))) {
-    return map(static_cast<underlying_t<T>>(val));
-  }
-
-  template <typename T, FMT_ENABLE_IF(has_format_as<T>::value &&
-                                      !has_formatter<T, Context>::value)>
-  FMT_CONSTEXPR FMT_INLINE auto map(const T& val)
-      -> decltype(std::declval<arg_mapper>().map(format_as(T()))) {
-    return map(format_as(val));
-  }
-
-  template <typename T, typename U = remove_cvref_t<T>>
-  struct formattable
-      : bool_constant<has_const_formatter<U, Context>() ||
-                      !std::is_const<remove_reference_t<T>>::value ||
-                      has_fallback_formatter<U, char_type>::value> {};
-
-#if (FMT_MSC_VERSION != 0 && FMT_MSC_VERSION < 1910) || \
-    FMT_ICC_VERSION != 0 || defined(__NVCC__)
-  // Workaround a bug in MSVC and Intel (Issue 2746).
-  template <typename T> FMT_CONSTEXPR FMT_INLINE auto do_map(T&& val) -> T& {
-    return val;
-  }
-#else
-  template <typename T, FMT_ENABLE_IF(formattable<T>::value)>
-  FMT_CONSTEXPR FMT_INLINE auto do_map(T&& val) -> T& {
-    return val;
-  }
-  template <typename T, FMT_ENABLE_IF(!formattable<T>::value)>
-  FMT_CONSTEXPR FMT_INLINE auto do_map(T&&) -> unformattable_const {
-    return {};
-  }
-#endif
-
-  template <typename T, typename U = remove_cvref_t<T>,
-            FMT_ENABLE_IF(!is_string<U>::value && !is_char<U>::value &&
-                          !std::is_array<U>::value &&
-                          !std::is_pointer<U>::value &&
-                          !has_format_as<U>::value &&
-                          (has_formatter<U, Context>::value ||
-                           has_fallback_formatter<U, char_type>::value))>
-  FMT_CONSTEXPR FMT_INLINE auto map(T&& val)
-      -> decltype(this->do_map(std::forward<T>(val))) {
-    return do_map(std::forward<T>(val));
-  }
-
-  template <typename T, FMT_ENABLE_IF(is_named_arg<T>::value)>
-  FMT_CONSTEXPR FMT_INLINE auto map(const T& named_arg)
-      -> decltype(std::declval<arg_mapper>().map(named_arg.value)) {
-    return map(named_arg.value);
-  }
-
-  auto map(...) -> unformattable { return {}; }
-};
-
-// A type constant after applying arg_mapper<Context>.
-template <typename T, typename Context>
-using mapped_type_constant =
-    type_constant<decltype(arg_mapper<Context>().map(std::declval<const T&>())),
-                  typename Context::char_type>;
-
-enum { packed_arg_bits = 4 };
-// Maximum number of arguments with packed types.
-enum { max_packed_args = 62 / packed_arg_bits };
-enum : unsigned long long { is_unpacked_bit = 1ULL << 63 };
-enum : unsigned long long { has_named_args_bit = 1ULL << 62 };
-
-FMT_END_DETAIL_NAMESPACE
-
-// An output iterator that appends to a buffer.
-// It is used to reduce symbol sizes for the common case.
-class appender : public std::back_insert_iterator<detail::buffer<char>> {
-  using base = std::back_insert_iterator<detail::buffer<char>>;
-
-  template <typename T>
-  friend auto get_buffer(appender out) -> detail::buffer<char>& {
-    return detail::get_container(out);
-  }
-
- public:
-  using std::back_insert_iterator<detail::buffer<char>>::back_insert_iterator;
-  appender(base it) noexcept : base(it) {}
-  FMT_UNCHECKED_ITERATOR(appender);
-
-  auto operator++() noexcept -> appender& { return *this; }
-  auto operator++(int) noexcept -> appender { return *this; }
-};
-
-// A formatting argument. It is a trivially copyable/constructible type to
-// allow storage in basic_memory_buffer.
-template <typename Context> class basic_format_arg {
- private:
-  detail::value<Context> value_;
-  detail::type type_;
-
-  template <typename ContextType, typename T>
-  friend FMT_CONSTEXPR auto detail::make_arg(T&& value)
-      -> basic_format_arg<ContextType>;
-
-  template <typename Visitor, typename Ctx>
-  friend FMT_CONSTEXPR auto visit_format_arg(Visitor&& vis,
-                                             const basic_format_arg<Ctx>& arg)
-      -> decltype(vis(0));
-
-  friend class basic_format_args<Context>;
-  friend class dynamic_format_arg_store<Context>;
-
-  using char_type = typename Context::char_type;
-
-  template <typename T, typename Char, size_t NUM_ARGS, size_t NUM_NAMED_ARGS>
-  friend struct detail::arg_data;
-
-  basic_format_arg(const detail::named_arg_info<char_type>* args, size_t size)
-      : value_(args, size) {}
-
- public:
-  class handle {
-   public:
-    explicit handle(detail::custom_value<Context> custom) : custom_(custom) {}
-
-    void format(typename Context::parse_context_type& parse_ctx,
-                Context& ctx) const {
-      custom_.format(custom_.value, parse_ctx, ctx);
-    }
-
-   private:
-    detail::custom_value<Context> custom_;
-  };
-
-  constexpr basic_format_arg() : type_(detail::type::none_type) {}
-
-  constexpr explicit operator bool() const noexcept {
-    return type_ != detail::type::none_type;
-  }
-
-  auto type() const -> detail::type { return type_; }
-
-  auto is_integral() const -> bool { return detail::is_integral_type(type_); }
-  auto is_arithmetic() const -> bool {
-    return detail::is_arithmetic_type(type_);
-  }
-};
-
-/**
-  \rst
-  Visits an argument dispatching to the appropriate visit method based on
-  the argument type. For example, if the argument type is ``double`` then
-  ``vis(value)`` will be called with the value of type ``double``.
-  \endrst
- */
-template <typename Visitor, typename Context>
-FMT_CONSTEXPR FMT_INLINE auto visit_format_arg(
-    Visitor&& vis, const basic_format_arg<Context>& arg) -> decltype(vis(0)) {
-  switch (arg.type_) {
-  case detail::type::none_type:
-    break;
-  case detail::type::int_type:
-    return vis(arg.value_.int_value);
-  case detail::type::uint_type:
-    return vis(arg.value_.uint_value);
-  case detail::type::long_long_type:
-    return vis(arg.value_.long_long_value);
-  case detail::type::ulong_long_type:
-    return vis(arg.value_.ulong_long_value);
-  case detail::type::int128_type:
-    return vis(detail::convert_for_visit(arg.value_.int128_value));
-  case detail::type::uint128_type:
-    return vis(detail::convert_for_visit(arg.value_.uint128_value));
-  case detail::type::bool_type:
-    return vis(arg.value_.bool_value);
-  case detail::type::char_type:
-    return vis(arg.value_.char_value);
-  case detail::type::float_type:
-    return vis(arg.value_.float_value);
-  case detail::type::double_type:
-    return vis(arg.value_.double_value);
-  case detail::type::long_double_type:
-    return vis(arg.value_.long_double_value);
-  case detail::type::cstring_type:
-    return vis(arg.value_.string.data);
-  case detail::type::string_type:
-    using sv = basic_string_view<typename Context::char_type>;
-    return vis(sv(arg.value_.string.data, arg.value_.string.size));
-  case detail::type::pointer_type:
-    return vis(arg.value_.pointer);
-  case detail::type::custom_type:
-    return vis(typename basic_format_arg<Context>::handle(arg.value_.custom));
-  }
-  return vis(monostate());
-}
-
-FMT_BEGIN_DETAIL_NAMESPACE
-
-template <typename Char, typename InputIt>
-auto copy_str(InputIt begin, InputIt end, appender out) -> appender {
-  get_container(out).append(begin, end);
-  return out;
-}
-
-template <typename Char, typename R, typename OutputIt>
-FMT_CONSTEXPR auto copy_str(R&& rng, OutputIt out) -> OutputIt {
-  return detail::copy_str<Char>(rng.begin(), rng.end(), out);
-}
-
-#if FMT_GCC_VERSION && FMT_GCC_VERSION < 500
-// A workaround for gcc 4.8 to make void_t work in a SFINAE context.
-template <typename... Ts> struct void_t_impl { using type = void; };
-template <typename... Ts>
-using void_t = typename detail::void_t_impl<Ts...>::type;
-#else
-template <typename...> using void_t = void;
-#endif
-
-template <typename It, typename T, typename Enable = void>
-struct is_output_iterator : std::false_type {};
-
-template <typename It, typename T>
-struct is_output_iterator<
-    It, T,
-    void_t<typename std::iterator_traits<It>::iterator_category,
-           decltype(*std::declval<It>() = std::declval<T>())>>
-    : std::true_type {};
-
-template <typename OutputIt>
-struct is_back_insert_iterator : std::false_type {};
-template <typename Container>
-struct is_back_insert_iterator<std::back_insert_iterator<Container>>
-    : std::true_type {};
-
-template <typename OutputIt>
-struct is_contiguous_back_insert_iterator : std::false_type {};
-template <typename Container>
-struct is_contiguous_back_insert_iterator<std::back_insert_iterator<Container>>
-    : is_contiguous<Container> {};
-template <>
-struct is_contiguous_back_insert_iterator<appender> : std::true_type {};
-
-// A type-erased reference to an std::locale to avoid a heavy <locale> include.
-class locale_ref {
- private:
-  const void* locale_;  // A type-erased pointer to std::locale.
-
- public:
-  constexpr locale_ref() : locale_(nullptr) {}
-  template <typename Locale> explicit locale_ref(const Locale& loc);
-
-  explicit operator bool() const noexcept { return locale_ != nullptr; }
-
-  template <typename Locale> auto get() const -> Locale;
-};
-
-template <typename> constexpr auto encode_types() -> unsigned long long {
-  return 0;
-}
-
-template <typename Context, typename Arg, typename... Args>
-constexpr auto encode_types() -> unsigned long long {
-  return static_cast<unsigned>(mapped_type_constant<Arg, Context>::value) |
-         (encode_types<Context, Args...>() << packed_arg_bits);
-}
-
-template <typename Context, typename T>
-FMT_CONSTEXPR FMT_INLINE auto make_value(T&& val) -> value<Context> {
-  const auto& arg = arg_mapper<Context>().map(FMT_FORWARD(val));
-
-  constexpr bool formattable_char =
-      !std::is_same<decltype(arg), const unformattable_char&>::value;
-  static_assert(formattable_char, "Mixing character types is disallowed.");
-
-  constexpr bool formattable_const =
-      !std::is_same<decltype(arg), const unformattable_const&>::value;
-  static_assert(formattable_const, "Cannot format a const argument.");
-
-  // Formatting of arbitrary pointers is disallowed. If you want to output
-  // a pointer cast it to "void *" or "const void *". In particular, this
-  // forbids formatting of "[const] volatile char *" which is printed as bool
-  // by iostreams.
-  constexpr bool formattable_pointer =
-      !std::is_same<decltype(arg), const unformattable_pointer&>::value;
-  static_assert(formattable_pointer,
-                "Formatting of non-void pointers is disallowed.");
-
-  constexpr bool formattable =
-      !std::is_same<decltype(arg), const unformattable&>::value;
-  static_assert(
-      formattable,
-      "Cannot format an argument. To make type T formattable provide a "
-      "formatter<T> specialization: https://fmt.dev/latest/api.html#udt");
-  return {arg};
-}
-
-template <typename Context, typename T>
-FMT_CONSTEXPR auto make_arg(T&& value) -> basic_format_arg<Context> {
-  basic_format_arg<Context> arg;
-  arg.type_ = mapped_type_constant<T, Context>::value;
-  arg.value_ = make_value<Context>(value);
-  return arg;
-}
-
-// The type template parameter is there to avoid an ODR violation when using
-// a fallback formatter in one translation unit and an implicit conversion in
-// another (not recommended).
-template <bool IS_PACKED, typename Context, type, typename T,
-          FMT_ENABLE_IF(IS_PACKED)>
-FMT_CONSTEXPR FMT_INLINE auto make_arg(T&& val) -> value<Context> {
-  return make_value<Context>(val);
-}
-
-template <bool IS_PACKED, typename Context, type, typename T,
-          FMT_ENABLE_IF(!IS_PACKED)>
-FMT_CONSTEXPR inline auto make_arg(T&& value) -> basic_format_arg<Context> {
-  return make_arg<Context>(value);
-}
-FMT_END_DETAIL_NAMESPACE
-
-// Formatting context.
-template <typename OutputIt, typename Char> class basic_format_context {
- public:
-  /** The character type for the output. */
-  using char_type = Char;
-
- private:
-  OutputIt out_;
-  basic_format_args<basic_format_context> args_;
-  detail::locale_ref loc_;
-
- public:
-  using iterator = OutputIt;
-  using format_arg = basic_format_arg<basic_format_context>;
-  using parse_context_type = basic_format_parse_context<Char>;
-  template <typename T> using formatter_type = formatter<T, char_type>;
-
-  basic_format_context(basic_format_context&&) = default;
-  basic_format_context(const basic_format_context&) = delete;
-  void operator=(const basic_format_context&) = delete;
-  /**
-   Constructs a ``basic_format_context`` object. References to the arguments are
-   stored in the object so make sure they have appropriate lifetimes.
-   */
-  constexpr basic_format_context(
-      OutputIt out, basic_format_args<basic_format_context> ctx_args,
-      detail::locale_ref loc = detail::locale_ref())
-      : out_(out), args_(ctx_args), loc_(loc) {}
-
-  constexpr auto arg(int id) const -> format_arg { return args_.get(id); }
-  FMT_CONSTEXPR auto arg(basic_string_view<char_type> name) -> format_arg {
-    return args_.get(name);
-  }
-  FMT_CONSTEXPR auto arg_id(basic_string_view<char_type> name) -> int {
-    return args_.get_id(name);
-  }
-  auto args() const -> const basic_format_args<basic_format_context>& {
-    return args_;
-  }
-
-  FMT_CONSTEXPR auto error_handler() -> detail::error_handler { return {}; }
-  void on_error(const char* message) { error_handler().on_error(message); }
-
-  // Returns an iterator to the beginning of the output range.
-  FMT_CONSTEXPR auto out() -> iterator { return out_; }
-
-  // Advances the begin iterator to ``it``.
-  void advance_to(iterator it) {
-    if (!detail::is_back_insert_iterator<iterator>()) out_ = it;
-  }
-
-  FMT_CONSTEXPR auto locale() -> detail::locale_ref { return loc_; }
-};
-
-template <typename Char>
-using buffer_context =
-    basic_format_context<detail::buffer_appender<Char>, Char>;
-using format_context = buffer_context<char>;
-
-// Workaround an alias issue: https://stackoverflow.com/q/62767544/471164.
-#define FMT_BUFFER_CONTEXT(Char) \
-  basic_format_context<detail::buffer_appender<Char>, Char>
-
-template <typename T, typename Char = char>
-using is_formattable = bool_constant<
-    !std::is_base_of<detail::unformattable,
-                     decltype(detail::arg_mapper<buffer_context<Char>>().map(
-                         std::declval<T>()))>::value &&
-    !detail::has_fallback_formatter<T, Char>::value>;
-
-/**
-  \rst
-  An array of references to arguments. It can be implicitly converted into
-  `~fmt::basic_format_args` for passing into type-erased formatting functions
-  such as `~fmt::vformat`.
-  \endrst
- */
-template <typename Context, typename... Args>
-class format_arg_store
-#if FMT_GCC_VERSION && FMT_GCC_VERSION < 409
-    // Workaround a GCC template argument substitution bug.
-    : public basic_format_args<Context>
-#endif
-{
- private:
-  static const size_t num_args = sizeof...(Args);
-  static const size_t num_named_args = detail::count_named_args<Args...>();
-  static const bool is_packed = num_args <= detail::max_packed_args;
-
-  using value_type = conditional_t<is_packed, detail::value<Context>,
-                                   basic_format_arg<Context>>;
-
-  detail::arg_data<value_type, typename Context::char_type, num_args,
-                   num_named_args>
-      data_;
-
-  friend class basic_format_args<Context>;
-
-  static constexpr unsigned long long desc =
-      (is_packed ? detail::encode_types<Context, Args...>()
-                 : detail::is_unpacked_bit | num_args) |
-      (num_named_args != 0
-           ? static_cast<unsigned long long>(detail::has_named_args_bit)
-           : 0);
-
- public:
-  template <typename... T>
-  FMT_CONSTEXPR FMT_INLINE format_arg_store(T&&... args)
-      :
-#if FMT_GCC_VERSION && FMT_GCC_VERSION < 409
-        basic_format_args<Context>(*this),
-#endif
-        data_{detail::make_arg<
-            is_packed, Context,
-            detail::mapped_type_constant<remove_cvref_t<T>, Context>::value>(
-            FMT_FORWARD(args))...} {
-    detail::init_named_args(data_.named_args(), 0, 0, args...);
-  }
-};
-
-/**
-  \rst
-  Constructs a `~fmt::format_arg_store` object that contains references to
-  arguments and can be implicitly converted to `~fmt::format_args`. `Context`
-  can be omitted in which case it defaults to `~fmt::context`.
-  See `~fmt::arg` for lifetime considerations.
-  \endrst
- */
-template <typename Context = format_context, typename... Args>
-constexpr auto make_format_args(Args&&... args)
-    -> format_arg_store<Context, remove_cvref_t<Args>...> {
-  return {FMT_FORWARD(args)...};
-}
-
-/**
-  \rst
-  Returns a named argument to be used in a formatting function.
-  It should only be used in a call to a formatting function or
-  `dynamic_format_arg_store::push_back`.
-
-  **Example**::
-
-    fmt::print("Elapsed time: {s:.2f} seconds", fmt::arg("s", 1.23));
-  \endrst
- */
-template <typename Char, typename T>
-inline auto arg(const Char* name, const T& arg) -> detail::named_arg<Char, T> {
-  static_assert(!detail::is_named_arg<T>(), "nested named arguments");
-  return {name, arg};
-}
-
-/**
-  \rst
-  A view of a collection of formatting arguments. To avoid lifetime issues it
-  should only be used as a parameter type in type-erased functions such as
-  ``vformat``::
-
-    void vlog(string_view format_str, format_args args);  // OK
-    format_args args = make_format_args(42);  // Error: dangling reference
-  \endrst
- */
-template <typename Context> class basic_format_args {
- public:
-  using size_type = int;
-  using format_arg = basic_format_arg<Context>;
-
- private:
-  // A descriptor that contains information about formatting arguments.
-  // If the number of arguments is less or equal to max_packed_args then
-  // argument types are passed in the descriptor. This reduces binary code size
-  // per formatting function call.
-  unsigned long long desc_;
-  union {
-    // If is_packed() returns true then argument values are stored in values_;
-    // otherwise they are stored in args_. This is done to improve cache
-    // locality and reduce compiled code size since storing larger objects
-    // may require more code (at least on x86-64) even if the same amount of
-    // data is actually copied to stack. It saves ~10% on the bloat test.
-    const detail::value<Context>* values_;
-    const format_arg* args_;
-  };
-
-  constexpr auto is_packed() const -> bool {
-    return (desc_ & detail::is_unpacked_bit) == 0;
-  }
-  auto has_named_args() const -> bool {
-    return (desc_ & detail::has_named_args_bit) != 0;
-  }
-
-  FMT_CONSTEXPR auto type(int index) const -> detail::type {
-    int shift = index * detail::packed_arg_bits;
-    unsigned int mask = (1 << detail::packed_arg_bits) - 1;
-    return static_cast<detail::type>((desc_ >> shift) & mask);
-  }
-
-  constexpr FMT_INLINE basic_format_args(unsigned long long desc,
-                                         const detail::value<Context>* values)
-      : desc_(desc), values_(values) {}
-  constexpr basic_format_args(unsigned long long desc, const format_arg* args)
-      : desc_(desc), args_(args) {}
-
- public:
-  constexpr basic_format_args() : desc_(0), args_(nullptr) {}
-
-  /**
-   \rst
-   Constructs a `basic_format_args` object from `~fmt::format_arg_store`.
-   \endrst
-   */
-  template <typename... Args>
-  constexpr FMT_INLINE basic_format_args(
-      const format_arg_store<Context, Args...>& store)
-      : basic_format_args(format_arg_store<Context, Args...>::desc,
-                          store.data_.args()) {}
-
-  /**
-   \rst
-   Constructs a `basic_format_args` object from
-   `~fmt::dynamic_format_arg_store`.
-   \endrst
-   */
-  constexpr FMT_INLINE basic_format_args(
-      const dynamic_format_arg_store<Context>& store)
-      : basic_format_args(store.get_types(), store.data()) {}
-
-  /**
-   \rst
-   Constructs a `basic_format_args` object from a dynamic set of arguments.
-   \endrst
-   */
-  constexpr basic_format_args(const format_arg* args, int count)
-      : basic_format_args(detail::is_unpacked_bit | detail::to_unsigned(count),
-                          args) {}
-
-  /** Returns the argument with the specified id. */
-  FMT_CONSTEXPR auto get(int id) const -> format_arg {
-    format_arg arg;
-    if (!is_packed()) {
-      if (id < max_size()) arg = args_[id];
-      return arg;
-    }
-    if (id >= detail::max_packed_args) return arg;
-    arg.type_ = type(id);
-    if (arg.type_ == detail::type::none_type) return arg;
-    arg.value_ = values_[id];
-    return arg;
-  }
-
-  template <typename Char>
-  auto get(basic_string_view<Char> name) const -> format_arg {
-    int id = get_id(name);
-    return id >= 0 ? get(id) : format_arg();
-  }
-
-  template <typename Char>
-  auto get_id(basic_string_view<Char> name) const -> int {
-    if (!has_named_args()) return -1;
-    const auto& named_args =
-        (is_packed() ? values_[-1] : args_[-1].value_).named_args;
-    for (size_t i = 0; i < named_args.size; ++i) {
-      if (named_args.data[i].name == name) return named_args.data[i].id;
-    }
-    return -1;
-  }
-
-  auto max_size() const -> int {
-    unsigned long long max_packed = detail::max_packed_args;
-    return static_cast<int>(is_packed() ? max_packed
-                                        : desc_ & ~detail::is_unpacked_bit);
-  }
-};
-
-/** An alias to ``basic_format_args<format_context>``. */
-// A separate type would result in shorter symbols but break ABI compatibility
-// between clang and gcc on ARM (#1919).
-using format_args = basic_format_args<format_context>;
-
-// We cannot use enum classes as bit fields because of a gcc bug, so we put them
-// in namespaces instead (https://gcc.gnu.org/bugzilla/show_bug.cgi?id=61414).
-// Additionally, if an underlying type is specified, older gcc incorrectly warns
-// that the type is too small. Both bugs are fixed in gcc 9.3.
-#if FMT_GCC_VERSION && FMT_GCC_VERSION < 903
-#  define FMT_ENUM_UNDERLYING_TYPE(type)
-#else
-#  define FMT_ENUM_UNDERLYING_TYPE(type) : type
-#endif
-namespace align {
-enum type FMT_ENUM_UNDERLYING_TYPE(unsigned char){none, left, right, center,
-                                                  numeric};
-}
-using align_t = align::type;
-namespace sign {
-enum type FMT_ENUM_UNDERLYING_TYPE(unsigned char){none, minus, plus, space};
-}
-using sign_t = sign::type;
-
-FMT_BEGIN_DETAIL_NAMESPACE
-
-// Workaround an array initialization issue in gcc 4.8.
-template <typename Char> struct fill_t {
- private:
-  enum { max_size = 4 };
-  Char data_[max_size] = {Char(' '), Char(0), Char(0), Char(0)};
-  unsigned char size_ = 1;
-
- public:
-  FMT_CONSTEXPR void operator=(basic_string_view<Char> s) {
-    auto size = s.size();
-    if (size > max_size) return throw_format_error("invalid fill");
-    for (size_t i = 0; i < size; ++i) data_[i] = s[i];
-    size_ = static_cast<unsigned char>(size);
-  }
-
-  constexpr auto size() const -> size_t { return size_; }
-  constexpr auto data() const -> const Char* { return data_; }
-
-  FMT_CONSTEXPR auto operator[](size_t index) -> Char& { return data_[index]; }
-  FMT_CONSTEXPR auto operator[](size_t index) const -> const Char& {
-    return data_[index];
-  }
-};
-FMT_END_DETAIL_NAMESPACE
-
-enum class presentation_type : unsigned char {
-  none,
-  // Integer types should go first,
-  dec,             // 'd'
-  oct,             // 'o'
-  hex_lower,       // 'x'
-  hex_upper,       // 'X'
-  bin_lower,       // 'b'
-  bin_upper,       // 'B'
-  hexfloat_lower,  // 'a'
-  hexfloat_upper,  // 'A'
-  exp_lower,       // 'e'
-  exp_upper,       // 'E'
-  fixed_lower,     // 'f'
-  fixed_upper,     // 'F'
-  general_lower,   // 'g'
-  general_upper,   // 'G'
-  chr,             // 'c'
-  string,          // 's'
-  pointer,         // 'p'
-  debug            // '?'
-};
-
-// Format specifiers for built-in and string types.
-template <typename Char> struct basic_format_specs {
-  int width;
-  int precision;
-  presentation_type type;
-  align_t align : 4;
-  sign_t sign : 3;
-  bool alt : 1;  // Alternate form ('#').
-  bool localized : 1;
-  detail::fill_t<Char> fill;
-
-  constexpr basic_format_specs()
-      : width(0),
-        precision(-1),
-        type(presentation_type::none),
-        align(align::none),
-        sign(sign::none),
-        alt(false),
-        localized(false) {}
-};
-
-using format_specs = basic_format_specs<char>;
-
-FMT_BEGIN_DETAIL_NAMESPACE
-
-enum class arg_id_kind { none, index, name };
-
-// An argument reference.
-template <typename Char> struct arg_ref {
-  FMT_CONSTEXPR arg_ref() : kind(arg_id_kind::none), val() {}
-
-  FMT_CONSTEXPR explicit arg_ref(int index)
-      : kind(arg_id_kind::index), val(index) {}
-  FMT_CONSTEXPR explicit arg_ref(basic_string_view<Char> name)
-      : kind(arg_id_kind::name), val(name) {}
-
-  FMT_CONSTEXPR auto operator=(int idx) -> arg_ref& {
-    kind = arg_id_kind::index;
-    val.index = idx;
-    return *this;
-  }
-
-  arg_id_kind kind;
-  union value {
-    FMT_CONSTEXPR value(int id = 0) : index{id} {}
-    FMT_CONSTEXPR value(basic_string_view<Char> n) : name(n) {}
-
-    int index;
-    basic_string_view<Char> name;
-  } val;
-};
-
-// Format specifiers with width and precision resolved at formatting rather
-// than parsing time to allow re-using the same parsed specifiers with
-// different sets of arguments (precompilation of format strings).
-template <typename Char>
-struct dynamic_format_specs : basic_format_specs<Char> {
-  arg_ref<Char> width_ref;
-  arg_ref<Char> precision_ref;
-};
-
-struct auto_id {};
-
-// A format specifier handler that sets fields in basic_format_specs.
-template <typename Char> class specs_setter {
- protected:
-  basic_format_specs<Char>& specs_;
-
- public:
-  explicit FMT_CONSTEXPR specs_setter(basic_format_specs<Char>& specs)
-      : specs_(specs) {}
-
-  FMT_CONSTEXPR specs_setter(const specs_setter& other)
-      : specs_(other.specs_) {}
-
-  FMT_CONSTEXPR void on_align(align_t align) { specs_.align = align; }
-  FMT_CONSTEXPR void on_fill(basic_string_view<Char> fill) {
-    specs_.fill = fill;
-  }
-  FMT_CONSTEXPR void on_sign(sign_t s) { specs_.sign = s; }
-  FMT_CONSTEXPR void on_hash() { specs_.alt = true; }
-  FMT_CONSTEXPR void on_localized() { specs_.localized = true; }
-
-  FMT_CONSTEXPR void on_zero() {
-    if (specs_.align == align::none) specs_.align = align::numeric;
-    specs_.fill[0] = Char('0');
-  }
-
-  FMT_CONSTEXPR void on_width(int width) { specs_.width = width; }
-  FMT_CONSTEXPR void on_precision(int precision) {
-    specs_.precision = precision;
-  }
-  FMT_CONSTEXPR void end_precision() {}
-
-  FMT_CONSTEXPR void on_type(presentation_type type) { specs_.type = type; }
-};
-
-// Format spec handler that saves references to arguments representing dynamic
-// width and precision to be resolved at formatting time.
-template <typename ParseContext>
-class dynamic_specs_handler
-    : public specs_setter<typename ParseContext::char_type> {
- public:
-  using char_type = typename ParseContext::char_type;
-
-  FMT_CONSTEXPR dynamic_specs_handler(dynamic_format_specs<char_type>& specs,
-                                      ParseContext& ctx)
-      : specs_setter<char_type>(specs), specs_(specs), context_(ctx) {}
-
-  FMT_CONSTEXPR dynamic_specs_handler(const dynamic_specs_handler& other)
-      : specs_setter<char_type>(other),
-        specs_(other.specs_),
-        context_(other.context_) {}
-
-  template <typename Id> FMT_CONSTEXPR void on_dynamic_width(Id arg_id) {
-    specs_.width_ref = make_arg_ref(arg_id);
-  }
-
-  template <typename Id> FMT_CONSTEXPR void on_dynamic_precision(Id arg_id) {
-    specs_.precision_ref = make_arg_ref(arg_id);
-  }
-
-  FMT_CONSTEXPR void on_error(const char* message) {
-    context_.on_error(message);
-  }
-
- private:
-  dynamic_format_specs<char_type>& specs_;
-  ParseContext& context_;
-
-  using arg_ref_type = arg_ref<char_type>;
-
-  FMT_CONSTEXPR auto make_arg_ref(int arg_id) -> arg_ref_type {
-    context_.check_arg_id(arg_id);
-    context_.check_dynamic_spec(arg_id);
-    return arg_ref_type(arg_id);
-  }
-
-  FMT_CONSTEXPR auto make_arg_ref(auto_id) -> arg_ref_type {
-    int arg_id = context_.next_arg_id();
-    context_.check_dynamic_spec(arg_id);
-    return arg_ref_type(arg_id);
-  }
-
-  FMT_CONSTEXPR auto make_arg_ref(basic_string_view<char_type> arg_id)
-      -> arg_ref_type {
-    context_.check_arg_id(arg_id);
-    basic_string_view<char_type> format_str(
-        context_.begin(), to_unsigned(context_.end() - context_.begin()));
-    return arg_ref_type(arg_id);
-  }
-};
-
-template <typename Char> constexpr bool is_ascii_letter(Char c) {
-  return (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z');
-}
-
-// Converts a character to ASCII. Returns a number > 127 on conversion failure.
-template <typename Char, FMT_ENABLE_IF(std::is_integral<Char>::value)>
-constexpr auto to_ascii(Char c) -> Char {
-  return c;
-}
-template <typename Char, FMT_ENABLE_IF(std::is_enum<Char>::value)>
-constexpr auto to_ascii(Char c) -> underlying_t<Char> {
-  return c;
-}
-
-FMT_CONSTEXPR inline auto code_point_length_impl(char c) -> int {
-  return "\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\1\0\0\0\0\0\0\0\0\2\2\2\2\3\3\4"
-      [static_cast<unsigned char>(c) >> 3];
-}
-
-template <typename Char>
-FMT_CONSTEXPR auto code_point_length(const Char* begin) -> int {
-  if (const_check(sizeof(Char) != 1)) return 1;
-  int len = code_point_length_impl(static_cast<char>(*begin));
-
-  // Compute the pointer to the next character early so that the next
-  // iteration can start working on the next character. Neither Clang
-  // nor GCC figure out this reordering on their own.
-  return len + !len;
-}
-
-// Return the result via the out param to workaround gcc bug 77539.
-template <bool IS_CONSTEXPR, typename T, typename Ptr = const T*>
-FMT_CONSTEXPR auto find(Ptr first, Ptr last, T value, Ptr& out) -> bool {
-  for (out = first; out != last; ++out) {
-    if (*out == value) return true;
-  }
-  return false;
-}
-
-template <>
-inline auto find<false, char>(const char* first, const char* last, char value,
-                              const char*& out) -> bool {
-  out = static_cast<const char*>(
-      std::memchr(first, value, to_unsigned(last - first)));
-  return out != nullptr;
-}
-
-// Parses the range [begin, end) as an unsigned integer. This function assumes
-// that the range is non-empty and the first character is a digit.
-template <typename Char>
-FMT_CONSTEXPR auto parse_nonnegative_int(const Char*& begin, const Char* end,
-                                         int error_value) noexcept -> int {
-  FMT_ASSERT(begin != end && '0' <= *begin && *begin <= '9', "");
-  unsigned value = 0, prev = 0;
-  auto p = begin;
-  do {
-    prev = value;
-    value = value * 10 + unsigned(*p - '0');
-    ++p;
-  } while (p != end && '0' <= *p && *p <= '9');
-  auto num_digits = p - begin;
-  begin = p;
-  if (num_digits <= std::numeric_limits<int>::digits10)
-    return static_cast<int>(value);
-  // Check for overflow.
-  const unsigned max = to_unsigned((std::numeric_limits<int>::max)());
-  return num_digits == std::numeric_limits<int>::digits10 + 1 &&
-                 prev * 10ull + unsigned(p[-1] - '0') <= max
-             ? static_cast<int>(value)
-             : error_value;
-}
-
-// Parses fill and alignment.
-template <typename Char, typename Handler>
-FMT_CONSTEXPR auto parse_align(const Char* begin, const Char* end,
-                               Handler&& handler) -> const Char* {
-  FMT_ASSERT(begin != end, "");
-  auto align = align::none;
-  auto p = begin + code_point_length(begin);
-  if (end - p <= 0) p = begin;
-  for (;;) {
-    switch (to_ascii(*p)) {
-    case '<':
-      align = align::left;
-      break;
-    case '>':
-      align = align::right;
-      break;
-    case '^':
-      align = align::center;
-      break;
-    default:
-      break;
-    }
-    if (align != align::none) {
-      if (p != begin) {
-        auto c = *begin;
-        if (c == '{')
-          return handler.on_error("invalid fill character '{'"), begin;
-        handler.on_fill(basic_string_view<Char>(begin, to_unsigned(p - begin)));
-        begin = p + 1;
-      } else
-        ++begin;
-      handler.on_align(align);
-      break;
-    } else if (p == begin) {
-      break;
-    }
-    p = begin;
-  }
-  return begin;
-}
-
-template <typename Char> FMT_CONSTEXPR bool is_name_start(Char c) {
-  return ('a' <= c && c <= 'z') || ('A' <= c && c <= 'Z') || '_' == c;
-}
-
-template <typename Char, typename IDHandler>
-FMT_CONSTEXPR auto do_parse_arg_id(const Char* begin, const Char* end,
-                                   IDHandler&& handler) -> const Char* {
-  FMT_ASSERT(begin != end, "");
-  Char c = *begin;
-  if (c >= '0' && c <= '9') {
-    int index = 0;
-    if (c != '0')
-      index =
-          parse_nonnegative_int(begin, end, (std::numeric_limits<int>::max)());
-    else
-      ++begin;
-    if (begin == end || (*begin != '}' && *begin != ':'))
-      handler.on_error("invalid format string");
-    else
-      handler(index);
-    return begin;
-  }
-  if (!is_name_start(c)) {
-    handler.on_error("invalid format string");
-    return begin;
-  }
-  auto it = begin;
-  do {
-    ++it;
-  } while (it != end && (is_name_start(c = *it) || ('0' <= c && c <= '9')));
-  handler(basic_string_view<Char>(begin, to_unsigned(it - begin)));
-  return it;
-}
-
-template <typename Char, typename IDHandler>
-FMT_CONSTEXPR FMT_INLINE auto parse_arg_id(const Char* begin, const Char* end,
-                                           IDHandler&& handler) -> const Char* {
-  Char c = *begin;
-  if (c != '}' && c != ':') return do_parse_arg_id(begin, end, handler);
-  handler();
-  return begin;
-}
-
-template <typename Char, typename Handler>
-FMT_CONSTEXPR auto parse_width(const Char* begin, const Char* end,
-                               Handler&& handler) -> const Char* {
-  using detail::auto_id;
-  struct width_adapter {
-    Handler& handler;
-
-    FMT_CONSTEXPR void operator()() { handler.on_dynamic_width(auto_id()); }
-    FMT_CONSTEXPR void operator()(int id) { handler.on_dynamic_width(id); }
-    FMT_CONSTEXPR void operator()(basic_string_view<Char> id) {
-      handler.on_dynamic_width(id);
-    }
-    FMT_CONSTEXPR void on_error(const char* message) {
-      if (message) handler.on_error(message);
-    }
-  };
-
-  FMT_ASSERT(begin != end, "");
-  if ('0' <= *begin && *begin <= '9') {
-    int width = parse_nonnegative_int(begin, end, -1);
-    if (width != -1)
-      handler.on_width(width);
-    else
-      handler.on_error("number is too big");
-  } else if (*begin == '{') {
-    ++begin;
-    if (begin != end) begin = parse_arg_id(begin, end, width_adapter{handler});
-    if (begin == end || *begin != '}')
-      return handler.on_error("invalid format string"), begin;
-    ++begin;
-  }
-  return begin;
-}
-
-template <typename Char, typename Handler>
-FMT_CONSTEXPR auto parse_precision(const Char* begin, const Char* end,
-                                   Handler&& handler) -> const Char* {
-  using detail::auto_id;
-  struct precision_adapter {
-    Handler& handler;
-
-    FMT_CONSTEXPR void operator()() { handler.on_dynamic_precision(auto_id()); }
-    FMT_CONSTEXPR void operator()(int id) { handler.on_dynamic_precision(id); }
-    FMT_CONSTEXPR void operator()(basic_string_view<Char> id) {
-      handler.on_dynamic_precision(id);
-    }
-    FMT_CONSTEXPR void on_error(const char* message) {
-      if (message) handler.on_error(message);
-    }
-  };
-
-  ++begin;
-  auto c = begin != end ? *begin : Char();
-  if ('0' <= c && c <= '9') {
-    auto precision = parse_nonnegative_int(begin, end, -1);
-    if (precision != -1)
-      handler.on_precision(precision);
-    else
-      handler.on_error("number is too big");
-  } else if (c == '{') {
-    ++begin;
-    if (begin != end)
-      begin = parse_arg_id(begin, end, precision_adapter{handler});
-    if (begin == end || *begin++ != '}')
-      return handler.on_error("invalid format string"), begin;
-  } else {
-    return handler.on_error("missing precision specifier"), begin;
-  }
-  handler.end_precision();
-  return begin;
-}
-
-template <typename Char>
-FMT_CONSTEXPR auto parse_presentation_type(Char type) -> presentation_type {
-  switch (to_ascii(type)) {
-  case 'd':
-    return presentation_type::dec;
-  case 'o':
-    return presentation_type::oct;
-  case 'x':
-    return presentation_type::hex_lower;
-  case 'X':
-    return presentation_type::hex_upper;
-  case 'b':
-    return presentation_type::bin_lower;
-  case 'B':
-    return presentation_type::bin_upper;
-  case 'a':
-    return presentation_type::hexfloat_lower;
-  case 'A':
-    return presentation_type::hexfloat_upper;
-  case 'e':
-    return presentation_type::exp_lower;
-  case 'E':
-    return presentation_type::exp_upper;
-  case 'f':
-    return presentation_type::fixed_lower;
-  case 'F':
-    return presentation_type::fixed_upper;
-  case 'g':
-    return presentation_type::general_lower;
-  case 'G':
-    return presentation_type::general_upper;
-  case 'c':
-    return presentation_type::chr;
-  case 's':
-    return presentation_type::string;
-  case 'p':
-    return presentation_type::pointer;
-  case '?':
-    return presentation_type::debug;
-  default:
-    return presentation_type::none;
-  }
-}
-
-// Parses standard format specifiers and sends notifications about parsed
-// components to handler.
-template <typename Char, typename SpecHandler>
-FMT_CONSTEXPR FMT_INLINE auto parse_format_specs(const Char* begin,
-                                                 const Char* end,
-                                                 SpecHandler&& handler)
-    -> const Char* {
-  if (1 < end - begin && begin[1] == '}' && is_ascii_letter(*begin) &&
-      *begin != 'L') {
-    presentation_type type = parse_presentation_type(*begin++);
-    if (type == presentation_type::none)
-      handler.on_error("invalid type specifier");
-    handler.on_type(type);
-    return begin;
-  }
-
-  if (begin == end) return begin;
-
-  begin = parse_align(begin, end, handler);
-  if (begin == end) return begin;
-
-  // Parse sign.
-  switch (to_ascii(*begin)) {
-  case '+':
-    handler.on_sign(sign::plus);
-    ++begin;
-    break;
-  case '-':
-    handler.on_sign(sign::minus);
-    ++begin;
-    break;
-  case ' ':
-    handler.on_sign(sign::space);
-    ++begin;
-    break;
-  default:
-    break;
-  }
-  if (begin == end) return begin;
-
-  if (*begin == '#') {
-    handler.on_hash();
-    if (++begin == end) return begin;
-  }
-
-  // Parse zero flag.
-  if (*begin == '0') {
-    handler.on_zero();
-    if (++begin == end) return begin;
-  }
-
-  begin = parse_width(begin, end, handler);
-  if (begin == end) return begin;
-
-  // Parse precision.
-  if (*begin == '.') {
-    begin = parse_precision(begin, end, handler);
-    if (begin == end) return begin;
-  }
-
-  if (*begin == 'L') {
-    handler.on_localized();
-    ++begin;
-  }
-
-  // Parse type.
-  if (begin != end && *begin != '}') {
-    presentation_type type = parse_presentation_type(*begin++);
-    if (type == presentation_type::none)
-      handler.on_error("invalid type specifier");
-    handler.on_type(type);
-  }
-  return begin;
-}
-
-template <typename Char, typename Handler>
-FMT_CONSTEXPR auto parse_replacement_field(const Char* begin, const Char* end,
-                                           Handler&& handler) -> const Char* {
-  struct id_adapter {
-    Handler& handler;
-    int arg_id;
-
-    FMT_CONSTEXPR void operator()() { arg_id = handler.on_arg_id(); }
-    FMT_CONSTEXPR void operator()(int id) { arg_id = handler.on_arg_id(id); }
-    FMT_CONSTEXPR void operator()(basic_string_view<Char> id) {
-      arg_id = handler.on_arg_id(id);
-    }
-    FMT_CONSTEXPR void on_error(const char* message) {
-      if (message) handler.on_error(message);
-    }
-  };
-
-  ++begin;
-  if (begin == end) return handler.on_error("invalid format string"), end;
-  if (*begin == '}') {
-    handler.on_replacement_field(handler.on_arg_id(), begin);
-  } else if (*begin == '{') {
-    handler.on_text(begin, begin + 1);
-  } else {
-    auto adapter = id_adapter{handler, 0};
-    begin = parse_arg_id(begin, end, adapter);
-    Char c = begin != end ? *begin : Char();
-    if (c == '}') {
-      handler.on_replacement_field(adapter.arg_id, begin);
-    } else if (c == ':') {
-      begin = handler.on_format_specs(adapter.arg_id, begin + 1, end);
-      if (begin == end || *begin != '}')
-        return handler.on_error("unknown format specifier"), end;
-    } else {
-      return handler.on_error("missing '}' in format string"), end;
-    }
-  }
-  return begin + 1;
-}
-
-template <bool IS_CONSTEXPR, typename Char, typename Handler>
-FMT_CONSTEXPR FMT_INLINE void parse_format_string(
-    basic_string_view<Char> format_str, Handler&& handler) {
-  // Workaround a name-lookup bug in MSVC's modules implementation.
-  using detail::find;
-
-  auto begin = format_str.data();
-  auto end = begin + format_str.size();
-  if (end - begin < 32) {
-    // Use a simple loop instead of memchr for small strings.
-    const Char* p = begin;
-    while (p != end) {
-      auto c = *p++;
-      if (c == '{') {
-        handler.on_text(begin, p - 1);
-        begin = p = parse_replacement_field(p - 1, end, handler);
-      } else if (c == '}') {
-        if (p == end || *p != '}')
-          return handler.on_error("unmatched '}' in format string");
-        handler.on_text(begin, p);
-        begin = ++p;
-      }
-    }
-    handler.on_text(begin, end);
-    return;
-  }
-  struct writer {
-    FMT_CONSTEXPR void operator()(const Char* from, const Char* to) {
-      if (from == to) return;
-      for (;;) {
-        const Char* p = nullptr;
-        if (!find<IS_CONSTEXPR>(from, to, Char('}'), p))
-          return handler_.on_text(from, to);
-        ++p;
-        if (p == to || *p != '}')
-          return handler_.on_error("unmatched '}' in format string");
-        handler_.on_text(from, p);
-        from = p + 1;
-      }
-    }
-    Handler& handler_;
-  } write = {handler};
-  while (begin != end) {
-    // Doing two passes with memchr (one for '{' and another for '}') is up to
-    // 2.5x faster than the naive one-pass implementation on big format strings.
-    const Char* p = begin;
-    if (*begin != '{' && !find<IS_CONSTEXPR>(begin + 1, end, Char('{'), p))
-      return write(begin, end);
-    write(begin, p);
-    begin = parse_replacement_field(p, end, handler);
-  }
-}
-
-template <typename T, bool = is_named_arg<T>::value> struct strip_named_arg {
-  using type = T;
-};
-template <typename T> struct strip_named_arg<T, true> {
-  using type = remove_cvref_t<decltype(T::value)>;
-};
-
-template <typename T, typename ParseContext>
-FMT_CONSTEXPR auto parse_format_specs(ParseContext& ctx)
-    -> decltype(ctx.begin()) {
-  using char_type = typename ParseContext::char_type;
-  using context = buffer_context<char_type>;
-  using stripped_type = typename strip_named_arg<T>::type;
-  using mapped_type = conditional_t<
-      mapped_type_constant<T, context>::value != type::custom_type,
-      decltype(arg_mapper<context>().map(std::declval<const T&>())),
-      stripped_type>;
-  auto f = conditional_t<has_formatter<mapped_type, context>::value,
-                         formatter<mapped_type, char_type>,
-                         fallback_formatter<stripped_type, char_type>>();
-  return f.parse(ctx);
-}
-
-template <typename ErrorHandler>
-FMT_CONSTEXPR void check_int_type_spec(presentation_type type,
-                                       ErrorHandler&& eh) {
-  if (type > presentation_type::bin_upper && type != presentation_type::chr)
-    eh.on_error("invalid type specifier");
-}
-
-// Checks char specs and returns true if the type spec is char (and not int).
-template <typename Char, typename ErrorHandler = error_handler>
-FMT_CONSTEXPR auto check_char_specs(const basic_format_specs<Char>& specs,
-                                    ErrorHandler&& eh = {}) -> bool {
-  if (specs.type != presentation_type::none &&
-      specs.type != presentation_type::chr &&
-      specs.type != presentation_type::debug) {
-    check_int_type_spec(specs.type, eh);
-    return false;
-  }
-  if (specs.align == align::numeric || specs.sign != sign::none || specs.alt)
-    eh.on_error("invalid format specifier for char");
-  return true;
-}
-
-// A floating-point presentation format.
-enum class float_format : unsigned char {
-  general,  // General: exponent notation or fixed point based on magnitude.
-  exp,      // Exponent notation with the default precision of 6, e.g. 1.2e-3.
-  fixed,    // Fixed point with the default precision of 6, e.g. 0.0012.
-  hex
-};
-
-struct float_specs {
-  int precision;
-  float_format format : 8;
-  sign_t sign : 8;
-  bool upper : 1;
-  bool locale : 1;
-  bool binary32 : 1;
-  bool showpoint : 1;
-};
-
-template <typename ErrorHandler = error_handler, typename Char>
-FMT_CONSTEXPR auto parse_float_type_spec(const basic_format_specs<Char>& specs,
-                                         ErrorHandler&& eh = {})
-    -> float_specs {
-  auto result = float_specs();
-  result.showpoint = specs.alt;
-  result.locale = specs.localized;
-  switch (specs.type) {
-  case presentation_type::none:
-    result.format = float_format::general;
-    break;
-  case presentation_type::general_upper:
-    result.upper = true;
-    FMT_FALLTHROUGH;
-  case presentation_type::general_lower:
-    result.format = float_format::general;
-    break;
-  case presentation_type::exp_upper:
-    result.upper = true;
-    FMT_FALLTHROUGH;
-  case presentation_type::exp_lower:
-    result.format = float_format::exp;
-    result.showpoint |= specs.precision != 0;
-    break;
-  case presentation_type::fixed_upper:
-    result.upper = true;
-    FMT_FALLTHROUGH;
-  case presentation_type::fixed_lower:
-    result.format = float_format::fixed;
-    result.showpoint |= specs.precision != 0;
-    break;
-  case presentation_type::hexfloat_upper:
-    result.upper = true;
-    FMT_FALLTHROUGH;
-  case presentation_type::hexfloat_lower:
-    result.format = float_format::hex;
-    break;
-  default:
-    eh.on_error("invalid type specifier");
-    break;
-  }
-  return result;
-}
-
-template <typename ErrorHandler = error_handler>
-FMT_CONSTEXPR auto check_cstring_type_spec(presentation_type type,
-                                           ErrorHandler&& eh = {}) -> bool {
-  if (type == presentation_type::none || type == presentation_type::string ||
-      type == presentation_type::debug)
-    return true;
-  if (type != presentation_type::pointer) eh.on_error("invalid type specifier");
-  return false;
-}
-
-template <typename ErrorHandler = error_handler>
-FMT_CONSTEXPR void check_string_type_spec(presentation_type type,
-                                          ErrorHandler&& eh = {}) {
-  if (type != presentation_type::none && type != presentation_type::string &&
-      type != presentation_type::debug)
-    eh.on_error("invalid type specifier");
-}
-
-template <typename ErrorHandler>
-FMT_CONSTEXPR void check_pointer_type_spec(presentation_type type,
-                                           ErrorHandler&& eh) {
-  if (type != presentation_type::none && type != presentation_type::pointer)
-    eh.on_error("invalid type specifier");
-}
-
-// A parse_format_specs handler that checks if specifiers are consistent with
-// the argument type.
-template <typename Handler> class specs_checker : public Handler {
- private:
-  detail::type arg_type_;
-
-  FMT_CONSTEXPR void require_numeric_argument() {
-    if (!is_arithmetic_type(arg_type_))
-      this->on_error("format specifier requires numeric argument");
-  }
-
- public:
-  FMT_CONSTEXPR specs_checker(const Handler& handler, detail::type arg_type)
-      : Handler(handler), arg_type_(arg_type) {}
-
-  FMT_CONSTEXPR void on_align(align_t align) {
-    if (align == align::numeric) require_numeric_argument();
-    Handler::on_align(align);
-  }
-
-  FMT_CONSTEXPR void on_sign(sign_t s) {
-    require_numeric_argument();
-    if (is_integral_type(arg_type_) && arg_type_ != type::int_type &&
-        arg_type_ != type::long_long_type && arg_type_ != type::int128_type &&
-        arg_type_ != type::char_type) {
-      this->on_error("format specifier requires signed argument");
-    }
-    Handler::on_sign(s);
-  }
-
-  FMT_CONSTEXPR void on_hash() {
-    require_numeric_argument();
-    Handler::on_hash();
-  }
-
-  FMT_CONSTEXPR void on_localized() {
-    require_numeric_argument();
-    Handler::on_localized();
-  }
-
-  FMT_CONSTEXPR void on_zero() {
-    require_numeric_argument();
-    Handler::on_zero();
-  }
-
-  FMT_CONSTEXPR void end_precision() {
-    if (is_integral_type(arg_type_) || arg_type_ == type::pointer_type)
-      this->on_error("precision not allowed for this argument type");
-  }
-};
-
-constexpr int invalid_arg_index = -1;
-
-#if FMT_USE_NONTYPE_TEMPLATE_ARGS
-template <int N, typename T, typename... Args, typename Char>
-constexpr auto get_arg_index_by_name(basic_string_view<Char> name) -> int {
-  if constexpr (detail::is_statically_named_arg<T>()) {
-    if (name == T::name) return N;
-  }
-  if constexpr (sizeof...(Args) > 0)
-    return get_arg_index_by_name<N + 1, Args...>(name);
-  (void)name;  // Workaround an MSVC bug about "unused" parameter.
-  return invalid_arg_index;
-}
-#endif
-
-template <typename... Args, typename Char>
-FMT_CONSTEXPR auto get_arg_index_by_name(basic_string_view<Char> name) -> int {
-#if FMT_USE_NONTYPE_TEMPLATE_ARGS
-  if constexpr (sizeof...(Args) > 0)
-    return get_arg_index_by_name<0, Args...>(name);
-#endif
-  (void)name;
-  return invalid_arg_index;
-}
-
-template <typename Char, typename ErrorHandler, typename... Args>
-class format_string_checker {
- private:
-  // In the future basic_format_parse_context will replace compile_parse_context
-  // here and will use is_constant_evaluated and downcasting to access the data
-  // needed for compile-time checks: https://godbolt.org/z/GvWzcTjh1.
-  using parse_context_type = compile_parse_context<Char, ErrorHandler>;
-  static constexpr int num_args = sizeof...(Args);
-
-  // Format specifier parsing function.
-  using parse_func = const Char* (*)(parse_context_type&);
-
-  parse_context_type context_;
-  parse_func parse_funcs_[num_args > 0 ? static_cast<size_t>(num_args) : 1];
-  type types_[num_args > 0 ? static_cast<size_t>(num_args) : 1];
-
- public:
-  explicit FMT_CONSTEXPR format_string_checker(
-      basic_string_view<Char> format_str, ErrorHandler eh)
-      : context_(format_str, num_args, types_, eh),
-        parse_funcs_{&parse_format_specs<Args, parse_context_type>...},
-        types_{
-            mapped_type_constant<Args,
-                                 basic_format_context<Char*, Char>>::value...} {
-  }
-
-  FMT_CONSTEXPR void on_text(const Char*, const Char*) {}
-
-  FMT_CONSTEXPR auto on_arg_id() -> int { return context_.next_arg_id(); }
-  FMT_CONSTEXPR auto on_arg_id(int id) -> int {
-    return context_.check_arg_id(id), id;
-  }
-  FMT_CONSTEXPR auto on_arg_id(basic_string_view<Char> id) -> int {
-#if FMT_USE_NONTYPE_TEMPLATE_ARGS
-    auto index = get_arg_index_by_name<Args...>(id);
-    if (index == invalid_arg_index) on_error("named argument is not found");
-    return context_.check_arg_id(index), index;
-#else
-    (void)id;
-    on_error("compile-time checks for named arguments require C++20 support");
-    return 0;
-#endif
-  }
-
-  FMT_CONSTEXPR void on_replacement_field(int, const Char*) {}
-
-  FMT_CONSTEXPR auto on_format_specs(int id, const Char* begin, const Char*)
-      -> const Char* {
-    context_.advance_to(context_.begin() + (begin - &*context_.begin()));
-    // id >= 0 check is a workaround for gcc 10 bug (#2065).
-    return id >= 0 && id < num_args ? parse_funcs_[id](context_) : begin;
-  }
-
-  FMT_CONSTEXPR void on_error(const char* message) {
-    context_.on_error(message);
-  }
-};
-
-// Reports a compile-time error if S is not a valid format string.
-template <typename..., typename S, FMT_ENABLE_IF(!is_compile_string<S>::value)>
-FMT_INLINE void check_format_string(const S&) {
-#ifdef FMT_ENFORCE_COMPILE_STRING
-  static_assert(is_compile_string<S>::value,
-                "FMT_ENFORCE_COMPILE_STRING requires all format strings to use "
-                "FMT_STRING.");
-#endif
-}
-template <typename... Args, typename S,
-          FMT_ENABLE_IF(is_compile_string<S>::value)>
-void check_format_string(S format_str) {
-  FMT_CONSTEXPR auto s = basic_string_view<typename S::char_type>(format_str);
-  using checker = format_string_checker<typename S::char_type, error_handler,
-                                        remove_cvref_t<Args>...>;
-  FMT_CONSTEXPR bool invalid_format =
-      (parse_format_string<true>(s, checker(s, {})), true);
-  ignore_unused(invalid_format);
-}
-
-template <typename Char>
-void vformat_to(
-    buffer<Char>& buf, basic_string_view<Char> fmt,
-    basic_format_args<FMT_BUFFER_CONTEXT(type_identity_t<Char>)> args,
-    locale_ref loc = {});
-
-FMT_API void vprint_mojibake(std::FILE*, string_view, format_args);
-#ifndef _WIN32
-inline void vprint_mojibake(std::FILE*, string_view, format_args) {}
-#endif
-FMT_END_DETAIL_NAMESPACE
-
-// A formatter specialization for the core types corresponding to detail::type
-// constants.
-template <typename T, typename Char>
-struct formatter<T, Char,
-                 enable_if_t<detail::type_constant<T, Char>::value !=
-                             detail::type::custom_type>> {
- private:
-  detail::dynamic_format_specs<Char> specs_;
-
- public:
-  // Parses format specifiers stopping either at the end of the range or at the
-  // terminating '}'.
-  template <typename ParseContext>
-  FMT_CONSTEXPR auto parse(ParseContext& ctx) -> decltype(ctx.begin()) {
-    auto begin = ctx.begin(), end = ctx.end();
-    if (begin == end) return begin;
-    using handler_type = detail::dynamic_specs_handler<ParseContext>;
-    auto type = detail::type_constant<T, Char>::value;
-    auto checker =
-        detail::specs_checker<handler_type>(handler_type(specs_, ctx), type);
-    auto it = detail::parse_format_specs(begin, end, checker);
-    auto eh = ctx.error_handler();
-    switch (type) {
-    case detail::type::none_type:
-      FMT_ASSERT(false, "invalid argument type");
-      break;
-    case detail::type::bool_type:
-      if (specs_.type == presentation_type::none ||
-          specs_.type == presentation_type::string) {
-        break;
-      }
-      FMT_FALLTHROUGH;
-    case detail::type::int_type:
-    case detail::type::uint_type:
-    case detail::type::long_long_type:
-    case detail::type::ulong_long_type:
-    case detail::type::int128_type:
-    case detail::type::uint128_type:
-      detail::check_int_type_spec(specs_.type, eh);
-      break;
-    case detail::type::char_type:
-      detail::check_char_specs(specs_, eh);
-      break;
-    case detail::type::float_type:
-      if (detail::const_check(FMT_USE_FLOAT))
-        detail::parse_float_type_spec(specs_, eh);
-      else
-        FMT_ASSERT(false, "float support disabled");
-      break;
-    case detail::type::double_type:
-      if (detail::const_check(FMT_USE_DOUBLE))
-        detail::parse_float_type_spec(specs_, eh);
-      else
-        FMT_ASSERT(false, "double support disabled");
-      break;
-    case detail::type::long_double_type:
-      if (detail::const_check(FMT_USE_LONG_DOUBLE))
-        detail::parse_float_type_spec(specs_, eh);
-      else
-        FMT_ASSERT(false, "long double support disabled");
-      break;
-    case detail::type::cstring_type:
-      detail::check_cstring_type_spec(specs_.type, eh);
-      break;
-    case detail::type::string_type:
-      detail::check_string_type_spec(specs_.type, eh);
-      break;
-    case detail::type::pointer_type:
-      detail::check_pointer_type_spec(specs_.type, eh);
-      break;
-    case detail::type::custom_type:
-      // Custom format specifiers are checked in parse functions of
-      // formatter specializations.
-      break;
-    }
-    return it;
-  }
-
-  template <detail::type U = detail::type_constant<T, Char>::value,
-            enable_if_t<(U == detail::type::string_type ||
-                         U == detail::type::cstring_type ||
-                         U == detail::type::char_type),
-                        int> = 0>
-  FMT_CONSTEXPR void set_debug_format() {
-    specs_.type = presentation_type::debug;
-  }
-
-  template <typename FormatContext>
-  FMT_CONSTEXPR auto format(const T& val, FormatContext& ctx) const
-      -> decltype(ctx.out());
-};
-
-#define FMT_FORMAT_AS(Type, Base)                                        \
-  template <typename Char>                                               \
-  struct formatter<Type, Char> : formatter<Base, Char> {                 \
-    template <typename FormatContext>                                    \
-    auto format(Type const& val, FormatContext& ctx) const               \
-        -> decltype(ctx.out()) {                                         \
-      return formatter<Base, Char>::format(static_cast<Base>(val), ctx); \
-    }                                                                    \
-  }
-
-FMT_FORMAT_AS(signed char, int);
-FMT_FORMAT_AS(unsigned char, unsigned);
-FMT_FORMAT_AS(short, int);
-FMT_FORMAT_AS(unsigned short, unsigned);
-FMT_FORMAT_AS(long, long long);
-FMT_FORMAT_AS(unsigned long, unsigned long long);
-FMT_FORMAT_AS(Char*, const Char*);
-FMT_FORMAT_AS(std::basic_string<Char>, basic_string_view<Char>);
-FMT_FORMAT_AS(std::nullptr_t, const void*);
-FMT_FORMAT_AS(detail::std_string_view<Char>, basic_string_view<Char>);
-
-template <typename Char> struct basic_runtime { basic_string_view<Char> str; };
-
-/** A compile-time format string. */
-template <typename Char, typename... Args> class basic_format_string {
- private:
-  basic_string_view<Char> str_;
-
- public:
-  template <typename S,
-            FMT_ENABLE_IF(
-                std::is_convertible<const S&, basic_string_view<Char>>::value)>
-  FMT_CONSTEVAL FMT_INLINE basic_format_string(const S& s) : str_(s) {
-    static_assert(
-        detail::count<
-            (std::is_base_of<detail::view, remove_reference_t<Args>>::value &&
-             std::is_reference<Args>::value)...>() == 0,
-        "passing views as lvalues is disallowed");
-#ifdef FMT_HAS_CONSTEVAL
-    if constexpr (detail::count_named_args<Args...>() ==
-                  detail::count_statically_named_args<Args...>()) {
-      using checker = detail::format_string_checker<Char, detail::error_handler,
-                                                    remove_cvref_t<Args>...>;
-      detail::parse_format_string<true>(str_, checker(s, {}));
-    }
-#else
-    detail::check_format_string<Args...>(s);
-#endif
-  }
-  basic_format_string(basic_runtime<Char> r) : str_(r.str) {}
-
-  FMT_INLINE operator basic_string_view<Char>() const { return str_; }
-};
-
-#if FMT_GCC_VERSION && FMT_GCC_VERSION < 409
-// Workaround broken conversion on older gcc.
-template <typename...> using format_string = string_view;
-inline auto runtime(string_view s) -> string_view { return s; }
-#else
-template <typename... Args>
-using format_string = basic_format_string<char, type_identity_t<Args>...>;
-/**
-  \rst
-  Creates a runtime format string.
-
-  **Example**::
-
-    // Check format string at runtime instead of compile-time.
-    fmt::print(fmt::runtime("{:d}"), "I am not a number");
-  \endrst
- */
-inline auto runtime(string_view s) -> basic_runtime<char> { return {{s}}; }
-#endif
-
-FMT_API auto vformat(string_view fmt, format_args args) -> std::string;
-
-/**
-  \rst
-  Formats ``args`` according to specifications in ``fmt`` and returns the result
-  as a string.
-
-  **Example**::
-
-    #include <fmt/core.h>
-    std::string message = fmt::format("The answer is {}.", 42);
-  \endrst
-*/
-template <typename... T>
-FMT_NODISCARD FMT_INLINE auto format(format_string<T...> fmt, T&&... args)
-    -> std::string {
-  return vformat(fmt, fmt::make_format_args(args...));
-}
-
-/** Formats a string and writes the output to ``out``. */
-template <typename OutputIt,
-          FMT_ENABLE_IF(detail::is_output_iterator<OutputIt, char>::value)>
-auto vformat_to(OutputIt out, string_view fmt, format_args args) -> OutputIt {
-  using detail::get_buffer;
-  auto&& buf = get_buffer<char>(out);
-  detail::vformat_to(buf, fmt, args, {});
-  return detail::get_iterator(buf);
-}
-
-/**
- \rst
- Formats ``args`` according to specifications in ``fmt``, writes the result to
- the output iterator ``out`` and returns the iterator past the end of the output
- range. `format_to` does not append a terminating null character.
-
- **Example**::
-
-   auto out = std::vector<char>();
-   fmt::format_to(std::back_inserter(out), "{}", 42);
- \endrst
- */
-template <typename OutputIt, typename... T,
-          FMT_ENABLE_IF(detail::is_output_iterator<OutputIt, char>::value)>
-FMT_INLINE auto format_to(OutputIt out, format_string<T...> fmt, T&&... args)
-    -> OutputIt {
-  return vformat_to(out, fmt, fmt::make_format_args(args...));
-}
-
-template <typename OutputIt> struct format_to_n_result {
-  /** Iterator past the end of the output range. */
-  OutputIt out;
-  /** Total (not truncated) output size. */
-  size_t size;
-};
-
-template <typename OutputIt, typename... T,
-          FMT_ENABLE_IF(detail::is_output_iterator<OutputIt, char>::value)>
-auto vformat_to_n(OutputIt out, size_t n, string_view fmt, format_args args)
-    -> format_to_n_result<OutputIt> {
-  using traits = detail::fixed_buffer_traits;
-  auto buf = detail::iterator_buffer<OutputIt, char, traits>(out, n);
-  detail::vformat_to(buf, fmt, args, {});
-  return {buf.out(), buf.count()};
-}
-
-/**
-  \rst
-  Formats ``args`` according to specifications in ``fmt``, writes up to ``n``
-  characters of the result to the output iterator ``out`` and returns the total
-  (not truncated) output size and the iterator past the end of the output range.
-  `format_to_n` does not append a terminating null character.
-  \endrst
- */
-template <typename OutputIt, typename... T,
-          FMT_ENABLE_IF(detail::is_output_iterator<OutputIt, char>::value)>
-FMT_INLINE auto format_to_n(OutputIt out, size_t n, format_string<T...> fmt,
-                            T&&... args) -> format_to_n_result<OutputIt> {
-  return vformat_to_n(out, n, fmt, fmt::make_format_args(args...));
-}
-
-/** Returns the number of chars in the output of ``format(fmt, args...)``. */
-template <typename... T>
-FMT_NODISCARD FMT_INLINE auto formatted_size(format_string<T...> fmt,
-                                             T&&... args) -> size_t {
-  auto buf = detail::counting_buffer<>();
-  detail::vformat_to(buf, string_view(fmt), fmt::make_format_args(args...), {});
-  return buf.count();
-}
-
-FMT_API void vprint(string_view fmt, format_args args);
-FMT_API void vprint(std::FILE* f, string_view fmt, format_args args);
-
-/**
-  \rst
-  Formats ``args`` according to specifications in ``fmt`` and writes the output
-  to ``stdout``.
-
-  **Example**::
-
-    fmt::print("Elapsed time: {0:.2f} seconds", 1.23);
-  \endrst
- */
-template <typename... T>
-FMT_INLINE void print(format_string<T...> fmt, T&&... args) {
-  const auto& vargs = fmt::make_format_args(args...);
-  return detail::is_utf8() ? vprint(fmt, vargs)
-                           : detail::vprint_mojibake(stdout, fmt, vargs);
-}
-
-/**
-  \rst
-  Formats ``args`` according to specifications in ``fmt`` and writes the
-  output to the file ``f``.
-
-  **Example**::
-
-    fmt::print(stderr, "Don't {}!", "panic");
-  \endrst
- */
-template <typename... T>
-FMT_INLINE void print(std::FILE* f, format_string<T...> fmt, T&&... args) {
-  const auto& vargs = fmt::make_format_args(args...);
-  return detail::is_utf8() ? vprint(f, fmt, vargs)
-                           : detail::vprint_mojibake(f, fmt, vargs);
-}
-
-FMT_MODULE_EXPORT_END
-FMT_GCC_PRAGMA("GCC pop_options")
-FMT_END_NAMESPACE
-
-#ifdef FMT_HEADER_ONLY
-#  include "format.h"
-#endif
-#endif  // FMT_CORE_H_
diff --git a/Externals/fmt/include/fmt/format-inl.h b/Externals/fmt/include/fmt/format-inl.h
deleted file mode 100755
index 22b1ec8df0eb..000000000000
--- a/Externals/fmt/include/fmt/format-inl.h
+++ /dev/null
@@ -1,1723 +0,0 @@
-// Formatting library for C++ - implementation
-//
-// Copyright (c) 2012 - 2016, Victor Zverovich
-// All rights reserved.
-//
-// For the license information refer to format.h.
-
-#ifndef FMT_FORMAT_INL_H_
-#define FMT_FORMAT_INL_H_
-
-#include <algorithm>
-#include <cctype>
-#include <cerrno>  // errno
-#include <climits>
-#include <cmath>
-#include <cstdarg>
-#include <cstring>  // std::memmove
-#include <cwchar>
-#include <exception>
-
-#ifndef FMT_STATIC_THOUSANDS_SEPARATOR
-#  include <locale>
-#endif
-
-#ifdef _WIN32
-#  include <io.h>  // _isatty
-#endif
-
-#include "format.h"
-
-FMT_BEGIN_NAMESPACE
-namespace detail {
-
-FMT_FUNC void assert_fail(const char* file, int line, const char* message) {
-  // Use unchecked std::fprintf to avoid triggering another assertion when
-  // writing to stderr fails
-  std::fprintf(stderr, "%s:%d: assertion failed: %s", file, line, message);
-  // Chosen instead of std::abort to satisfy Clang in CUDA mode during device
-  // code pass.
-  std::terminate();
-}
-
-FMT_FUNC void throw_format_error(const char* message) {
-  FMT_THROW(format_error(message));
-}
-
-FMT_FUNC void format_error_code(detail::buffer<char>& out, int error_code,
-                                string_view message) noexcept {
-  // Report error code making sure that the output fits into
-  // inline_buffer_size to avoid dynamic memory allocation and potential
-  // bad_alloc.
-  out.try_resize(0);
-  static const char SEP[] = ": ";
-  static const char ERROR_STR[] = "error ";
-  // Subtract 2 to account for terminating null characters in SEP and ERROR_STR.
-  size_t error_code_size = sizeof(SEP) + sizeof(ERROR_STR) - 2;
-  auto abs_value = static_cast<uint32_or_64_or_128_t<int>>(error_code);
-  if (detail::is_negative(error_code)) {
-    abs_value = 0 - abs_value;
-    ++error_code_size;
-  }
-  error_code_size += detail::to_unsigned(detail::count_digits(abs_value));
-  auto it = buffer_appender<char>(out);
-  if (message.size() <= inline_buffer_size - error_code_size)
-    format_to(it, FMT_STRING("{}{}"), message, SEP);
-  format_to(it, FMT_STRING("{}{}"), ERROR_STR, error_code);
-  FMT_ASSERT(out.size() <= inline_buffer_size, "");
-}
-
-FMT_FUNC void report_error(format_func func, int error_code,
-                           const char* message) noexcept {
-  memory_buffer full_message;
-  func(full_message, error_code, message);
-  // Don't use fwrite_fully because the latter may throw.
-  if (std::fwrite(full_message.data(), full_message.size(), 1, stderr) > 0)
-    std::fputc('\n', stderr);
-}
-
-// A wrapper around fwrite that throws on error.
-inline void fwrite_fully(const void* ptr, size_t size, size_t count,
-                         FILE* stream) {
-  size_t written = std::fwrite(ptr, size, count, stream);
-  if (written < count)
-    FMT_THROW(system_error(errno, FMT_STRING("cannot write to file")));
-}
-
-#ifndef FMT_STATIC_THOUSANDS_SEPARATOR
-template <typename Locale>
-locale_ref::locale_ref(const Locale& loc) : locale_(&loc) {
-  static_assert(std::is_same<Locale, std::locale>::value, "");
-}
-
-template <typename Locale> Locale locale_ref::get() const {
-  static_assert(std::is_same<Locale, std::locale>::value, "");
-  return locale_ ? *static_cast<const std::locale*>(locale_) : std::locale();
-}
-
-template <typename Char>
-FMT_FUNC auto thousands_sep_impl(locale_ref loc) -> thousands_sep_result<Char> {
-  auto& facet = std::use_facet<std::numpunct<Char>>(loc.get<std::locale>());
-  auto grouping = facet.grouping();
-  auto thousands_sep = grouping.empty() ? Char() : facet.thousands_sep();
-  return {std::move(grouping), thousands_sep};
-}
-template <typename Char> FMT_FUNC Char decimal_point_impl(locale_ref loc) {
-  return std::use_facet<std::numpunct<Char>>(loc.get<std::locale>())
-      .decimal_point();
-}
-#else
-template <typename Char>
-FMT_FUNC auto thousands_sep_impl(locale_ref) -> thousands_sep_result<Char> {
-  return {"\03", FMT_STATIC_THOUSANDS_SEPARATOR};
-}
-template <typename Char> FMT_FUNC Char decimal_point_impl(locale_ref) {
-  return '.';
-}
-#endif
-}  // namespace detail
-
-#if !FMT_MSC_VERSION
-FMT_API FMT_FUNC format_error::~format_error() noexcept = default;
-#endif
-
-FMT_FUNC std::system_error vsystem_error(int error_code, string_view format_str,
-                                         format_args args) {
-  auto ec = std::error_code(error_code, std::generic_category());
-  return std::system_error(ec, vformat(format_str, args));
-}
-
-namespace detail {
-
-template <typename F> inline bool operator==(basic_fp<F> x, basic_fp<F> y) {
-  return x.f == y.f && x.e == y.e;
-}
-
-// Compilers should be able to optimize this into the ror instruction.
-FMT_CONSTEXPR inline uint32_t rotr(uint32_t n, uint32_t r) noexcept {
-  r &= 31;
-  return (n >> r) | (n << (32 - r));
-}
-FMT_CONSTEXPR inline uint64_t rotr(uint64_t n, uint32_t r) noexcept {
-  r &= 63;
-  return (n >> r) | (n << (64 - r));
-}
-
-// Computes 128-bit result of multiplication of two 64-bit unsigned integers.
-inline uint128_fallback umul128(uint64_t x, uint64_t y) noexcept {
-#if FMT_USE_INT128
-  auto p = static_cast<uint128_opt>(x) * static_cast<uint128_opt>(y);
-  return {static_cast<uint64_t>(p >> 64), static_cast<uint64_t>(p)};
-#elif defined(_MSC_VER) && defined(_M_X64)
-  auto result = uint128_fallback();
-  result.lo_ = _umul128(x, y, &result.hi_);
-  return result;
-#else
-  const uint64_t mask = static_cast<uint64_t>(max_value<uint32_t>());
-
-  uint64_t a = x >> 32;
-  uint64_t b = x & mask;
-  uint64_t c = y >> 32;
-  uint64_t d = y & mask;
-
-  uint64_t ac = a * c;
-  uint64_t bc = b * c;
-  uint64_t ad = a * d;
-  uint64_t bd = b * d;
-
-  uint64_t intermediate = (bd >> 32) + (ad & mask) + (bc & mask);
-
-  return {ac + (intermediate >> 32) + (ad >> 32) + (bc >> 32),
-          (intermediate << 32) + (bd & mask)};
-#endif
-}
-
-// Implementation of Dragonbox algorithm: https://github.com/jk-jeon/dragonbox.
-namespace dragonbox {
-// Computes upper 64 bits of multiplication of two 64-bit unsigned integers.
-inline uint64_t umul128_upper64(uint64_t x, uint64_t y) noexcept {
-#if FMT_USE_INT128
-  auto p = static_cast<uint128_opt>(x) * static_cast<uint128_opt>(y);
-  return static_cast<uint64_t>(p >> 64);
-#elif defined(_MSC_VER) && defined(_M_X64)
-  return __umulh(x, y);
-#else
-  return umul128(x, y).high();
-#endif
-}
-
-// Computes upper 128 bits of multiplication of a 64-bit unsigned integer and a
-// 128-bit unsigned integer.
-inline uint128_fallback umul192_upper128(uint64_t x,
-                                         uint128_fallback y) noexcept {
-  uint128_fallback r = umul128(x, y.high());
-  r += umul128_upper64(x, y.low());
-  return r;
-}
-
-// Computes upper 64 bits of multiplication of a 32-bit unsigned integer and a
-// 64-bit unsigned integer.
-inline uint64_t umul96_upper64(uint32_t x, uint64_t y) noexcept {
-  return umul128_upper64(static_cast<uint64_t>(x) << 32, y);
-}
-
-// Computes lower 128 bits of multiplication of a 64-bit unsigned integer and a
-// 128-bit unsigned integer.
-inline uint128_fallback umul192_lower128(uint64_t x,
-                                         uint128_fallback y) noexcept {
-  uint64_t high = x * y.high();
-  uint128_fallback high_low = umul128(x, y.low());
-  return {high + high_low.high(), high_low.low()};
-}
-
-// Computes lower 64 bits of multiplication of a 32-bit unsigned integer and a
-// 64-bit unsigned integer.
-inline uint64_t umul96_lower64(uint32_t x, uint64_t y) noexcept {
-  return x * y;
-}
-
-// Computes floor(log10(pow(2, e))) for e in [-2620, 2620] using the method from
-// https://fmt.dev/papers/Dragonbox.pdf#page=28, section 6.1.
-inline int floor_log10_pow2(int e) noexcept {
-  FMT_ASSERT(e <= 2620 && e >= -2620, "too large exponent");
-  static_assert((-1 >> 1) == -1, "right shift is not arithmetic");
-  return (e * 315653) >> 20;
-}
-
-// Various fast log computations.
-inline int floor_log2_pow10(int e) noexcept {
-  FMT_ASSERT(e <= 1233 && e >= -1233, "too large exponent");
-  return (e * 1741647) >> 19;
-}
-inline int floor_log10_pow2_minus_log10_4_over_3(int e) noexcept {
-  FMT_ASSERT(e <= 2936 && e >= -2985, "too large exponent");
-  return (e * 631305 - 261663) >> 21;
-}
-
-static constexpr struct {
-  uint32_t divisor;
-  int shift_amount;
-} div_small_pow10_infos[] = {{10, 16}, {100, 16}};
-
-// Replaces n by floor(n / pow(10, N)) returning true if and only if n is
-// divisible by pow(10, N).
-// Precondition: n <= pow(10, N + 1).
-template <int N>
-bool check_divisibility_and_divide_by_pow10(uint32_t& n) noexcept {
-  // The numbers below are chosen such that:
-  //   1. floor(n/d) = floor(nm / 2^k) where d=10 or d=100,
-  //   2. nm mod 2^k < m if and only if n is divisible by d,
-  // where m is magic_number, k is shift_amount
-  // and d is divisor.
-  //
-  // Item 1 is a common technique of replacing division by a constant with
-  // multiplication, see e.g. "Division by Invariant Integers Using
-  // Multiplication" by Granlund and Montgomery (1994). magic_number (m) is set
-  // to ceil(2^k/d) for large enough k.
-  // The idea for item 2 originates from Schubfach.
-  constexpr auto info = div_small_pow10_infos[N - 1];
-  FMT_ASSERT(n <= info.divisor * 10, "n is too large");
-  constexpr uint32_t magic_number =
-      (1u << info.shift_amount) / info.divisor + 1;
-  n *= magic_number;
-  const uint32_t comparison_mask = (1u << info.shift_amount) - 1;
-  bool result = (n & comparison_mask) < magic_number;
-  n >>= info.shift_amount;
-  return result;
-}
-
-// Computes floor(n / pow(10, N)) for small n and N.
-// Precondition: n <= pow(10, N + 1).
-template <int N> uint32_t small_division_by_pow10(uint32_t n) noexcept {
-  constexpr auto info = div_small_pow10_infos[N - 1];
-  FMT_ASSERT(n <= info.divisor * 10, "n is too large");
-  constexpr uint32_t magic_number =
-      (1u << info.shift_amount) / info.divisor + 1;
-  return (n * magic_number) >> info.shift_amount;
-}
-
-// Computes floor(n / 10^(kappa + 1)) (float)
-inline uint32_t divide_by_10_to_kappa_plus_1(uint32_t n) noexcept {
-  // 1374389535 = ceil(2^37/100)
-  return static_cast<uint32_t>((static_cast<uint64_t>(n) * 1374389535) >> 37);
-}
-// Computes floor(n / 10^(kappa + 1)) (double)
-inline uint64_t divide_by_10_to_kappa_plus_1(uint64_t n) noexcept {
-  // 2361183241434822607 = ceil(2^(64+7)/1000)
-  return umul128_upper64(n, 2361183241434822607ull) >> 7;
-}
-
-// Various subroutines using pow10 cache
-template <class T> struct cache_accessor;
-
-template <> struct cache_accessor<float> {
-  using carrier_uint = float_info<float>::carrier_uint;
-  using cache_entry_type = uint64_t;
-
-  static uint64_t get_cached_power(int k) noexcept {
-    FMT_ASSERT(k >= float_info<float>::min_k && k <= float_info<float>::max_k,
-               "k is out of range");
-    static constexpr const uint64_t pow10_significands[] = {
-        0x81ceb32c4b43fcf5, 0xa2425ff75e14fc32, 0xcad2f7f5359a3b3f,
-        0xfd87b5f28300ca0e, 0x9e74d1b791e07e49, 0xc612062576589ddb,
-        0xf79687aed3eec552, 0x9abe14cd44753b53, 0xc16d9a0095928a28,
-        0xf1c90080baf72cb2, 0x971da05074da7bef, 0xbce5086492111aeb,
-        0xec1e4a7db69561a6, 0x9392ee8e921d5d08, 0xb877aa3236a4b44a,
-        0xe69594bec44de15c, 0x901d7cf73ab0acda, 0xb424dc35095cd810,
-        0xe12e13424bb40e14, 0x8cbccc096f5088cc, 0xafebff0bcb24aaff,
-        0xdbe6fecebdedd5bf, 0x89705f4136b4a598, 0xabcc77118461cefd,
-        0xd6bf94d5e57a42bd, 0x8637bd05af6c69b6, 0xa7c5ac471b478424,
-        0xd1b71758e219652c, 0x83126e978d4fdf3c, 0xa3d70a3d70a3d70b,
-        0xcccccccccccccccd, 0x8000000000000000, 0xa000000000000000,
-        0xc800000000000000, 0xfa00000000000000, 0x9c40000000000000,
-        0xc350000000000000, 0xf424000000000000, 0x9896800000000000,
-        0xbebc200000000000, 0xee6b280000000000, 0x9502f90000000000,
-        0xba43b74000000000, 0xe8d4a51000000000, 0x9184e72a00000000,
-        0xb5e620f480000000, 0xe35fa931a0000000, 0x8e1bc9bf04000000,
-        0xb1a2bc2ec5000000, 0xde0b6b3a76400000, 0x8ac7230489e80000,
-        0xad78ebc5ac620000, 0xd8d726b7177a8000, 0x878678326eac9000,
-        0xa968163f0a57b400, 0xd3c21bcecceda100, 0x84595161401484a0,
-        0xa56fa5b99019a5c8, 0xcecb8f27f4200f3a, 0x813f3978f8940985,
-        0xa18f07d736b90be6, 0xc9f2c9cd04674edf, 0xfc6f7c4045812297,
-        0x9dc5ada82b70b59e, 0xc5371912364ce306, 0xf684df56c3e01bc7,
-        0x9a130b963a6c115d, 0xc097ce7bc90715b4, 0xf0bdc21abb48db21,
-        0x96769950b50d88f5, 0xbc143fa4e250eb32, 0xeb194f8e1ae525fe,
-        0x92efd1b8d0cf37bf, 0xb7abc627050305ae, 0xe596b7b0c643c71a,
-        0x8f7e32ce7bea5c70, 0xb35dbf821ae4f38c, 0xe0352f62a19e306f};
-    return pow10_significands[k - float_info<float>::min_k];
-  }
-
-  struct compute_mul_result {
-    carrier_uint result;
-    bool is_integer;
-  };
-  struct compute_mul_parity_result {
-    bool parity;
-    bool is_integer;
-  };
-
-  static compute_mul_result compute_mul(
-      carrier_uint u, const cache_entry_type& cache) noexcept {
-    auto r = umul96_upper64(u, cache);
-    return {static_cast<carrier_uint>(r >> 32),
-            static_cast<carrier_uint>(r) == 0};
-  }
-
-  static uint32_t compute_delta(const cache_entry_type& cache,
-                                int beta) noexcept {
-    return static_cast<uint32_t>(cache >> (64 - 1 - beta));
-  }
-
-  static compute_mul_parity_result compute_mul_parity(
-      carrier_uint two_f, const cache_entry_type& cache, int beta) noexcept {
-    FMT_ASSERT(beta >= 1, "");
-    FMT_ASSERT(beta < 64, "");
-
-    auto r = umul96_lower64(two_f, cache);
-    return {((r >> (64 - beta)) & 1) != 0,
-            static_cast<uint32_t>(r >> (32 - beta)) == 0};
-  }
-
-  static carrier_uint compute_left_endpoint_for_shorter_interval_case(
-      const cache_entry_type& cache, int beta) noexcept {
-    return static_cast<carrier_uint>(
-        (cache - (cache >> (num_significand_bits<float>() + 2))) >>
-        (64 - num_significand_bits<float>() - 1 - beta));
-  }
-
-  static carrier_uint compute_right_endpoint_for_shorter_interval_case(
-      const cache_entry_type& cache, int beta) noexcept {
-    return static_cast<carrier_uint>(
-        (cache + (cache >> (num_significand_bits<float>() + 1))) >>
-        (64 - num_significand_bits<float>() - 1 - beta));
-  }
-
-  static carrier_uint compute_round_up_for_shorter_interval_case(
-      const cache_entry_type& cache, int beta) noexcept {
-    return (static_cast<carrier_uint>(
-                cache >> (64 - num_significand_bits<float>() - 2 - beta)) +
-            1) /
-           2;
-  }
-};
-
-template <> struct cache_accessor<double> {
-  using carrier_uint = float_info<double>::carrier_uint;
-  using cache_entry_type = uint128_fallback;
-
-  static uint128_fallback get_cached_power(int k) noexcept {
-    FMT_ASSERT(k >= float_info<double>::min_k && k <= float_info<double>::max_k,
-               "k is out of range");
-
-    static constexpr const uint128_fallback pow10_significands[] = {
-#if FMT_USE_FULL_CACHE_DRAGONBOX
-      {0xff77b1fcbebcdc4f, 0x25e8e89c13bb0f7b},
-      {0x9faacf3df73609b1, 0x77b191618c54e9ad},
-      {0xc795830d75038c1d, 0xd59df5b9ef6a2418},
-      {0xf97ae3d0d2446f25, 0x4b0573286b44ad1e},
-      {0x9becce62836ac577, 0x4ee367f9430aec33},
-      {0xc2e801fb244576d5, 0x229c41f793cda740},
-      {0xf3a20279ed56d48a, 0x6b43527578c11110},
-      {0x9845418c345644d6, 0x830a13896b78aaaa},
-      {0xbe5691ef416bd60c, 0x23cc986bc656d554},
-      {0xedec366b11c6cb8f, 0x2cbfbe86b7ec8aa9},
-      {0x94b3a202eb1c3f39, 0x7bf7d71432f3d6aa},
-      {0xb9e08a83a5e34f07, 0xdaf5ccd93fb0cc54},
-      {0xe858ad248f5c22c9, 0xd1b3400f8f9cff69},
-      {0x91376c36d99995be, 0x23100809b9c21fa2},
-      {0xb58547448ffffb2d, 0xabd40a0c2832a78b},
-      {0xe2e69915b3fff9f9, 0x16c90c8f323f516d},
-      {0x8dd01fad907ffc3b, 0xae3da7d97f6792e4},
-      {0xb1442798f49ffb4a, 0x99cd11cfdf41779d},
-      {0xdd95317f31c7fa1d, 0x40405643d711d584},
-      {0x8a7d3eef7f1cfc52, 0x482835ea666b2573},
-      {0xad1c8eab5ee43b66, 0xda3243650005eed0},
-      {0xd863b256369d4a40, 0x90bed43e40076a83},
-      {0x873e4f75e2224e68, 0x5a7744a6e804a292},
-      {0xa90de3535aaae202, 0x711515d0a205cb37},
-      {0xd3515c2831559a83, 0x0d5a5b44ca873e04},
-      {0x8412d9991ed58091, 0xe858790afe9486c3},
-      {0xa5178fff668ae0b6, 0x626e974dbe39a873},
-      {0xce5d73ff402d98e3, 0xfb0a3d212dc81290},
-      {0x80fa687f881c7f8e, 0x7ce66634bc9d0b9a},
-      {0xa139029f6a239f72, 0x1c1fffc1ebc44e81},
-      {0xc987434744ac874e, 0xa327ffb266b56221},
-      {0xfbe9141915d7a922, 0x4bf1ff9f0062baa9},
-      {0x9d71ac8fada6c9b5, 0x6f773fc3603db4aa},
-      {0xc4ce17b399107c22, 0xcb550fb4384d21d4},
-      {0xf6019da07f549b2b, 0x7e2a53a146606a49},
-      {0x99c102844f94e0fb, 0x2eda7444cbfc426e},
-      {0xc0314325637a1939, 0xfa911155fefb5309},
-      {0xf03d93eebc589f88, 0x793555ab7eba27cb},
-      {0x96267c7535b763b5, 0x4bc1558b2f3458df},
-      {0xbbb01b9283253ca2, 0x9eb1aaedfb016f17},
-      {0xea9c227723ee8bcb, 0x465e15a979c1cadd},
-      {0x92a1958a7675175f, 0x0bfacd89ec191eca},
-      {0xb749faed14125d36, 0xcef980ec671f667c},
-      {0xe51c79a85916f484, 0x82b7e12780e7401b},
-      {0x8f31cc0937ae58d2, 0xd1b2ecb8b0908811},
-      {0xb2fe3f0b8599ef07, 0x861fa7e6dcb4aa16},
-      {0xdfbdcece67006ac9, 0x67a791e093e1d49b},
-      {0x8bd6a141006042bd, 0xe0c8bb2c5c6d24e1},
-      {0xaecc49914078536d, 0x58fae9f773886e19},
-      {0xda7f5bf590966848, 0xaf39a475506a899f},
-      {0x888f99797a5e012d, 0x6d8406c952429604},
-      {0xaab37fd7d8f58178, 0xc8e5087ba6d33b84},
-      {0xd5605fcdcf32e1d6, 0xfb1e4a9a90880a65},
-      {0x855c3be0a17fcd26, 0x5cf2eea09a550680},
-      {0xa6b34ad8c9dfc06f, 0xf42faa48c0ea481f},
-      {0xd0601d8efc57b08b, 0xf13b94daf124da27},
-      {0x823c12795db6ce57, 0x76c53d08d6b70859},
-      {0xa2cb1717b52481ed, 0x54768c4b0c64ca6f},
-      {0xcb7ddcdda26da268, 0xa9942f5dcf7dfd0a},
-      {0xfe5d54150b090b02, 0xd3f93b35435d7c4d},
-      {0x9efa548d26e5a6e1, 0xc47bc5014a1a6db0},
-      {0xc6b8e9b0709f109a, 0x359ab6419ca1091c},
-      {0xf867241c8cc6d4c0, 0xc30163d203c94b63},
-      {0x9b407691d7fc44f8, 0x79e0de63425dcf1e},
-      {0xc21094364dfb5636, 0x985915fc12f542e5},
-      {0xf294b943e17a2bc4, 0x3e6f5b7b17b2939e},
-      {0x979cf3ca6cec5b5a, 0xa705992ceecf9c43},
-      {0xbd8430bd08277231, 0x50c6ff782a838354},
-      {0xece53cec4a314ebd, 0xa4f8bf5635246429},
-      {0x940f4613ae5ed136, 0x871b7795e136be9a},
-      {0xb913179899f68584, 0x28e2557b59846e40},
-      {0xe757dd7ec07426e5, 0x331aeada2fe589d0},
-      {0x9096ea6f3848984f, 0x3ff0d2c85def7622},
-      {0xb4bca50b065abe63, 0x0fed077a756b53aa},
-      {0xe1ebce4dc7f16dfb, 0xd3e8495912c62895},
-      {0x8d3360f09cf6e4bd, 0x64712dd7abbbd95d},
-      {0xb080392cc4349dec, 0xbd8d794d96aacfb4},
-      {0xdca04777f541c567, 0xecf0d7a0fc5583a1},
-      {0x89e42caaf9491b60, 0xf41686c49db57245},
-      {0xac5d37d5b79b6239, 0x311c2875c522ced6},
-      {0xd77485cb25823ac7, 0x7d633293366b828c},
-      {0x86a8d39ef77164bc, 0xae5dff9c02033198},
-      {0xa8530886b54dbdeb, 0xd9f57f830283fdfd},
-      {0xd267caa862a12d66, 0xd072df63c324fd7c},
-      {0x8380dea93da4bc60, 0x4247cb9e59f71e6e},
-      {0xa46116538d0deb78, 0x52d9be85f074e609},
-      {0xcd795be870516656, 0x67902e276c921f8c},
-      {0x806bd9714632dff6, 0x00ba1cd8a3db53b7},
-      {0xa086cfcd97bf97f3, 0x80e8a40eccd228a5},
-      {0xc8a883c0fdaf7df0, 0x6122cd128006b2ce},
-      {0xfad2a4b13d1b5d6c, 0x796b805720085f82},
-      {0x9cc3a6eec6311a63, 0xcbe3303674053bb1},
-      {0xc3f490aa77bd60fc, 0xbedbfc4411068a9d},
-      {0xf4f1b4d515acb93b, 0xee92fb5515482d45},
-      {0x991711052d8bf3c5, 0x751bdd152d4d1c4b},
-      {0xbf5cd54678eef0b6, 0xd262d45a78a0635e},
-      {0xef340a98172aace4, 0x86fb897116c87c35},
-      {0x9580869f0e7aac0e, 0xd45d35e6ae3d4da1},
-      {0xbae0a846d2195712, 0x8974836059cca10a},
-      {0xe998d258869facd7, 0x2bd1a438703fc94c},
-      {0x91ff83775423cc06, 0x7b6306a34627ddd0},
-      {0xb67f6455292cbf08, 0x1a3bc84c17b1d543},
-      {0xe41f3d6a7377eeca, 0x20caba5f1d9e4a94},
-      {0x8e938662882af53e, 0x547eb47b7282ee9d},
-      {0xb23867fb2a35b28d, 0xe99e619a4f23aa44},
-      {0xdec681f9f4c31f31, 0x6405fa00e2ec94d5},
-      {0x8b3c113c38f9f37e, 0xde83bc408dd3dd05},
-      {0xae0b158b4738705e, 0x9624ab50b148d446},
-      {0xd98ddaee19068c76, 0x3badd624dd9b0958},
-      {0x87f8a8d4cfa417c9, 0xe54ca5d70a80e5d7},
-      {0xa9f6d30a038d1dbc, 0x5e9fcf4ccd211f4d},
-      {0xd47487cc8470652b, 0x7647c32000696720},
-      {0x84c8d4dfd2c63f3b, 0x29ecd9f40041e074},
-      {0xa5fb0a17c777cf09, 0xf468107100525891},
-      {0xcf79cc9db955c2cc, 0x7182148d4066eeb5},
-      {0x81ac1fe293d599bf, 0xc6f14cd848405531},
-      {0xa21727db38cb002f, 0xb8ada00e5a506a7d},
-      {0xca9cf1d206fdc03b, 0xa6d90811f0e4851d},
-      {0xfd442e4688bd304a, 0x908f4a166d1da664},
-      {0x9e4a9cec15763e2e, 0x9a598e4e043287ff},
-      {0xc5dd44271ad3cdba, 0x40eff1e1853f29fe},
-      {0xf7549530e188c128, 0xd12bee59e68ef47d},
-      {0x9a94dd3e8cf578b9, 0x82bb74f8301958cf},
-      {0xc13a148e3032d6e7, 0xe36a52363c1faf02},
-      {0xf18899b1bc3f8ca1, 0xdc44e6c3cb279ac2},
-      {0x96f5600f15a7b7e5, 0x29ab103a5ef8c0ba},
-      {0xbcb2b812db11a5de, 0x7415d448f6b6f0e8},
-      {0xebdf661791d60f56, 0x111b495b3464ad22},
-      {0x936b9fcebb25c995, 0xcab10dd900beec35},
-      {0xb84687c269ef3bfb, 0x3d5d514f40eea743},
-      {0xe65829b3046b0afa, 0x0cb4a5a3112a5113},
-      {0x8ff71a0fe2c2e6dc, 0x47f0e785eaba72ac},
-      {0xb3f4e093db73a093, 0x59ed216765690f57},
-      {0xe0f218b8d25088b8, 0x306869c13ec3532d},
-      {0x8c974f7383725573, 0x1e414218c73a13fc},
-      {0xafbd2350644eeacf, 0xe5d1929ef90898fb},
-      {0xdbac6c247d62a583, 0xdf45f746b74abf3a},
-      {0x894bc396ce5da772, 0x6b8bba8c328eb784},
-      {0xab9eb47c81f5114f, 0x066ea92f3f326565},
-      {0xd686619ba27255a2, 0xc80a537b0efefebe},
-      {0x8613fd0145877585, 0xbd06742ce95f5f37},
-      {0xa798fc4196e952e7, 0x2c48113823b73705},
-      {0xd17f3b51fca3a7a0, 0xf75a15862ca504c6},
-      {0x82ef85133de648c4, 0x9a984d73dbe722fc},
-      {0xa3ab66580d5fdaf5, 0xc13e60d0d2e0ebbb},
-      {0xcc963fee10b7d1b3, 0x318df905079926a9},
-      {0xffbbcfe994e5c61f, 0xfdf17746497f7053},
-      {0x9fd561f1fd0f9bd3, 0xfeb6ea8bedefa634},
-      {0xc7caba6e7c5382c8, 0xfe64a52ee96b8fc1},
-      {0xf9bd690a1b68637b, 0x3dfdce7aa3c673b1},
-      {0x9c1661a651213e2d, 0x06bea10ca65c084f},
-      {0xc31bfa0fe5698db8, 0x486e494fcff30a63},
-      {0xf3e2f893dec3f126, 0x5a89dba3c3efccfb},
-      {0x986ddb5c6b3a76b7, 0xf89629465a75e01d},
-      {0xbe89523386091465, 0xf6bbb397f1135824},
-      {0xee2ba6c0678b597f, 0x746aa07ded582e2d},
-      {0x94db483840b717ef, 0xa8c2a44eb4571cdd},
-      {0xba121a4650e4ddeb, 0x92f34d62616ce414},
-      {0xe896a0d7e51e1566, 0x77b020baf9c81d18},
-      {0x915e2486ef32cd60, 0x0ace1474dc1d122f},
-      {0xb5b5ada8aaff80b8, 0x0d819992132456bb},
-      {0xe3231912d5bf60e6, 0x10e1fff697ed6c6a},
-      {0x8df5efabc5979c8f, 0xca8d3ffa1ef463c2},
-      {0xb1736b96b6fd83b3, 0xbd308ff8a6b17cb3},
-      {0xddd0467c64bce4a0, 0xac7cb3f6d05ddbdf},
-      {0x8aa22c0dbef60ee4, 0x6bcdf07a423aa96c},
-      {0xad4ab7112eb3929d, 0x86c16c98d2c953c7},
-      {0xd89d64d57a607744, 0xe871c7bf077ba8b8},
-      {0x87625f056c7c4a8b, 0x11471cd764ad4973},
-      {0xa93af6c6c79b5d2d, 0xd598e40d3dd89bd0},
-      {0xd389b47879823479, 0x4aff1d108d4ec2c4},
-      {0x843610cb4bf160cb, 0xcedf722a585139bb},
-      {0xa54394fe1eedb8fe, 0xc2974eb4ee658829},
-      {0xce947a3da6a9273e, 0x733d226229feea33},
-      {0x811ccc668829b887, 0x0806357d5a3f5260},
-      {0xa163ff802a3426a8, 0xca07c2dcb0cf26f8},
-      {0xc9bcff6034c13052, 0xfc89b393dd02f0b6},
-      {0xfc2c3f3841f17c67, 0xbbac2078d443ace3},
-      {0x9d9ba7832936edc0, 0xd54b944b84aa4c0e},
-      {0xc5029163f384a931, 0x0a9e795e65d4df12},
-      {0xf64335bcf065d37d, 0x4d4617b5ff4a16d6},
-      {0x99ea0196163fa42e, 0x504bced1bf8e4e46},
-      {0xc06481fb9bcf8d39, 0xe45ec2862f71e1d7},
-      {0xf07da27a82c37088, 0x5d767327bb4e5a4d},
-      {0x964e858c91ba2655, 0x3a6a07f8d510f870},
-      {0xbbe226efb628afea, 0x890489f70a55368c},
-      {0xeadab0aba3b2dbe5, 0x2b45ac74ccea842f},
-      {0x92c8ae6b464fc96f, 0x3b0b8bc90012929e},
-      {0xb77ada0617e3bbcb, 0x09ce6ebb40173745},
-      {0xe55990879ddcaabd, 0xcc420a6a101d0516},
-      {0x8f57fa54c2a9eab6, 0x9fa946824a12232e},
-      {0xb32df8e9f3546564, 0x47939822dc96abfa},
-      {0xdff9772470297ebd, 0x59787e2b93bc56f8},
-      {0x8bfbea76c619ef36, 0x57eb4edb3c55b65b},
-      {0xaefae51477a06b03, 0xede622920b6b23f2},
-      {0xdab99e59958885c4, 0xe95fab368e45ecee},
-      {0x88b402f7fd75539b, 0x11dbcb0218ebb415},
-      {0xaae103b5fcd2a881, 0xd652bdc29f26a11a},
-      {0xd59944a37c0752a2, 0x4be76d3346f04960},
-      {0x857fcae62d8493a5, 0x6f70a4400c562ddc},
-      {0xa6dfbd9fb8e5b88e, 0xcb4ccd500f6bb953},
-      {0xd097ad07a71f26b2, 0x7e2000a41346a7a8},
-      {0x825ecc24c873782f, 0x8ed400668c0c28c9},
-      {0xa2f67f2dfa90563b, 0x728900802f0f32fb},
-      {0xcbb41ef979346bca, 0x4f2b40a03ad2ffba},
-      {0xfea126b7d78186bc, 0xe2f610c84987bfa9},
-      {0x9f24b832e6b0f436, 0x0dd9ca7d2df4d7ca},
-      {0xc6ede63fa05d3143, 0x91503d1c79720dbc},
-      {0xf8a95fcf88747d94, 0x75a44c6397ce912b},
-      {0x9b69dbe1b548ce7c, 0xc986afbe3ee11abb},
-      {0xc24452da229b021b, 0xfbe85badce996169},
-      {0xf2d56790ab41c2a2, 0xfae27299423fb9c4},
-      {0x97c560ba6b0919a5, 0xdccd879fc967d41b},
-      {0xbdb6b8e905cb600f, 0x5400e987bbc1c921},
-      {0xed246723473e3813, 0x290123e9aab23b69},
-      {0x9436c0760c86e30b, 0xf9a0b6720aaf6522},
-      {0xb94470938fa89bce, 0xf808e40e8d5b3e6a},
-      {0xe7958cb87392c2c2, 0xb60b1d1230b20e05},
-      {0x90bd77f3483bb9b9, 0xb1c6f22b5e6f48c3},
-      {0xb4ecd5f01a4aa828, 0x1e38aeb6360b1af4},
-      {0xe2280b6c20dd5232, 0x25c6da63c38de1b1},
-      {0x8d590723948a535f, 0x579c487e5a38ad0f},
-      {0xb0af48ec79ace837, 0x2d835a9df0c6d852},
-      {0xdcdb1b2798182244, 0xf8e431456cf88e66},
-      {0x8a08f0f8bf0f156b, 0x1b8e9ecb641b5900},
-      {0xac8b2d36eed2dac5, 0xe272467e3d222f40},
-      {0xd7adf884aa879177, 0x5b0ed81dcc6abb10},
-      {0x86ccbb52ea94baea, 0x98e947129fc2b4ea},
-      {0xa87fea27a539e9a5, 0x3f2398d747b36225},
-      {0xd29fe4b18e88640e, 0x8eec7f0d19a03aae},
-      {0x83a3eeeef9153e89, 0x1953cf68300424ad},
-      {0xa48ceaaab75a8e2b, 0x5fa8c3423c052dd8},
-      {0xcdb02555653131b6, 0x3792f412cb06794e},
-      {0x808e17555f3ebf11, 0xe2bbd88bbee40bd1},
-      {0xa0b19d2ab70e6ed6, 0x5b6aceaeae9d0ec5},
-      {0xc8de047564d20a8b, 0xf245825a5a445276},
-      {0xfb158592be068d2e, 0xeed6e2f0f0d56713},
-      {0x9ced737bb6c4183d, 0x55464dd69685606c},
-      {0xc428d05aa4751e4c, 0xaa97e14c3c26b887},
-      {0xf53304714d9265df, 0xd53dd99f4b3066a9},
-      {0x993fe2c6d07b7fab, 0xe546a8038efe402a},
-      {0xbf8fdb78849a5f96, 0xde98520472bdd034},
-      {0xef73d256a5c0f77c, 0x963e66858f6d4441},
-      {0x95a8637627989aad, 0xdde7001379a44aa9},
-      {0xbb127c53b17ec159, 0x5560c018580d5d53},
-      {0xe9d71b689dde71af, 0xaab8f01e6e10b4a7},
-      {0x9226712162ab070d, 0xcab3961304ca70e9},
-      {0xb6b00d69bb55c8d1, 0x3d607b97c5fd0d23},
-      {0xe45c10c42a2b3b05, 0x8cb89a7db77c506b},
-      {0x8eb98a7a9a5b04e3, 0x77f3608e92adb243},
-      {0xb267ed1940f1c61c, 0x55f038b237591ed4},
-      {0xdf01e85f912e37a3, 0x6b6c46dec52f6689},
-      {0x8b61313bbabce2c6, 0x2323ac4b3b3da016},
-      {0xae397d8aa96c1b77, 0xabec975e0a0d081b},
-      {0xd9c7dced53c72255, 0x96e7bd358c904a22},
-      {0x881cea14545c7575, 0x7e50d64177da2e55},
-      {0xaa242499697392d2, 0xdde50bd1d5d0b9ea},
-      {0xd4ad2dbfc3d07787, 0x955e4ec64b44e865},
-      {0x84ec3c97da624ab4, 0xbd5af13bef0b113f},
-      {0xa6274bbdd0fadd61, 0xecb1ad8aeacdd58f},
-      {0xcfb11ead453994ba, 0x67de18eda5814af3},
-      {0x81ceb32c4b43fcf4, 0x80eacf948770ced8},
-      {0xa2425ff75e14fc31, 0xa1258379a94d028e},
-      {0xcad2f7f5359a3b3e, 0x096ee45813a04331},
-      {0xfd87b5f28300ca0d, 0x8bca9d6e188853fd},
-      {0x9e74d1b791e07e48, 0x775ea264cf55347e},
-      {0xc612062576589dda, 0x95364afe032a819e},
-      {0xf79687aed3eec551, 0x3a83ddbd83f52205},
-      {0x9abe14cd44753b52, 0xc4926a9672793543},
-      {0xc16d9a0095928a27, 0x75b7053c0f178294},
-      {0xf1c90080baf72cb1, 0x5324c68b12dd6339},
-      {0x971da05074da7bee, 0xd3f6fc16ebca5e04},
-      {0xbce5086492111aea, 0x88f4bb1ca6bcf585},
-      {0xec1e4a7db69561a5, 0x2b31e9e3d06c32e6},
-      {0x9392ee8e921d5d07, 0x3aff322e62439fd0},
-      {0xb877aa3236a4b449, 0x09befeb9fad487c3},
-      {0xe69594bec44de15b, 0x4c2ebe687989a9b4},
-      {0x901d7cf73ab0acd9, 0x0f9d37014bf60a11},
-      {0xb424dc35095cd80f, 0x538484c19ef38c95},
-      {0xe12e13424bb40e13, 0x2865a5f206b06fba},
-      {0x8cbccc096f5088cb, 0xf93f87b7442e45d4},
-      {0xafebff0bcb24aafe, 0xf78f69a51539d749},
-      {0xdbe6fecebdedd5be, 0xb573440e5a884d1c},
-      {0x89705f4136b4a597, 0x31680a88f8953031},
-      {0xabcc77118461cefc, 0xfdc20d2b36ba7c3e},
-      {0xd6bf94d5e57a42bc, 0x3d32907604691b4d},
-      {0x8637bd05af6c69b5, 0xa63f9a49c2c1b110},
-      {0xa7c5ac471b478423, 0x0fcf80dc33721d54},
-      {0xd1b71758e219652b, 0xd3c36113404ea4a9},
-      {0x83126e978d4fdf3b, 0x645a1cac083126ea},
-      {0xa3d70a3d70a3d70a, 0x3d70a3d70a3d70a4},
-      {0xcccccccccccccccc, 0xcccccccccccccccd},
-      {0x8000000000000000, 0x0000000000000000},
-      {0xa000000000000000, 0x0000000000000000},
-      {0xc800000000000000, 0x0000000000000000},
-      {0xfa00000000000000, 0x0000000000000000},
-      {0x9c40000000000000, 0x0000000000000000},
-      {0xc350000000000000, 0x0000000000000000},
-      {0xf424000000000000, 0x0000000000000000},
-      {0x9896800000000000, 0x0000000000000000},
-      {0xbebc200000000000, 0x0000000000000000},
-      {0xee6b280000000000, 0x0000000000000000},
-      {0x9502f90000000000, 0x0000000000000000},
-      {0xba43b74000000000, 0x0000000000000000},
-      {0xe8d4a51000000000, 0x0000000000000000},
-      {0x9184e72a00000000, 0x0000000000000000},
-      {0xb5e620f480000000, 0x0000000000000000},
-      {0xe35fa931a0000000, 0x0000000000000000},
-      {0x8e1bc9bf04000000, 0x0000000000000000},
-      {0xb1a2bc2ec5000000, 0x0000000000000000},
-      {0xde0b6b3a76400000, 0x0000000000000000},
-      {0x8ac7230489e80000, 0x0000000000000000},
-      {0xad78ebc5ac620000, 0x0000000000000000},
-      {0xd8d726b7177a8000, 0x0000000000000000},
-      {0x878678326eac9000, 0x0000000000000000},
-      {0xa968163f0a57b400, 0x0000000000000000},
-      {0xd3c21bcecceda100, 0x0000000000000000},
-      {0x84595161401484a0, 0x0000000000000000},
-      {0xa56fa5b99019a5c8, 0x0000000000000000},
-      {0xcecb8f27f4200f3a, 0x0000000000000000},
-      {0x813f3978f8940984, 0x4000000000000000},
-      {0xa18f07d736b90be5, 0x5000000000000000},
-      {0xc9f2c9cd04674ede, 0xa400000000000000},
-      {0xfc6f7c4045812296, 0x4d00000000000000},
-      {0x9dc5ada82b70b59d, 0xf020000000000000},
-      {0xc5371912364ce305, 0x6c28000000000000},
-      {0xf684df56c3e01bc6, 0xc732000000000000},
-      {0x9a130b963a6c115c, 0x3c7f400000000000},
-      {0xc097ce7bc90715b3, 0x4b9f100000000000},
-      {0xf0bdc21abb48db20, 0x1e86d40000000000},
-      {0x96769950b50d88f4, 0x1314448000000000},
-      {0xbc143fa4e250eb31, 0x17d955a000000000},
-      {0xeb194f8e1ae525fd, 0x5dcfab0800000000},
-      {0x92efd1b8d0cf37be, 0x5aa1cae500000000},
-      {0xb7abc627050305ad, 0xf14a3d9e40000000},
-      {0xe596b7b0c643c719, 0x6d9ccd05d0000000},
-      {0x8f7e32ce7bea5c6f, 0xe4820023a2000000},
-      {0xb35dbf821ae4f38b, 0xdda2802c8a800000},
-      {0xe0352f62a19e306e, 0xd50b2037ad200000},
-      {0x8c213d9da502de45, 0x4526f422cc340000},
-      {0xaf298d050e4395d6, 0x9670b12b7f410000},
-      {0xdaf3f04651d47b4c, 0x3c0cdd765f114000},
-      {0x88d8762bf324cd0f, 0xa5880a69fb6ac800},
-      {0xab0e93b6efee0053, 0x8eea0d047a457a00},
-      {0xd5d238a4abe98068, 0x72a4904598d6d880},
-      {0x85a36366eb71f041, 0x47a6da2b7f864750},
-      {0xa70c3c40a64e6c51, 0x999090b65f67d924},
-      {0xd0cf4b50cfe20765, 0xfff4b4e3f741cf6d},
-      {0x82818f1281ed449f, 0xbff8f10e7a8921a5},
-      {0xa321f2d7226895c7, 0xaff72d52192b6a0e},
-      {0xcbea6f8ceb02bb39, 0x9bf4f8a69f764491},
-      {0xfee50b7025c36a08, 0x02f236d04753d5b5},
-      {0x9f4f2726179a2245, 0x01d762422c946591},
-      {0xc722f0ef9d80aad6, 0x424d3ad2b7b97ef6},
-      {0xf8ebad2b84e0d58b, 0xd2e0898765a7deb3},
-      {0x9b934c3b330c8577, 0x63cc55f49f88eb30},
-      {0xc2781f49ffcfa6d5, 0x3cbf6b71c76b25fc},
-      {0xf316271c7fc3908a, 0x8bef464e3945ef7b},
-      {0x97edd871cfda3a56, 0x97758bf0e3cbb5ad},
-      {0xbde94e8e43d0c8ec, 0x3d52eeed1cbea318},
-      {0xed63a231d4c4fb27, 0x4ca7aaa863ee4bde},
-      {0x945e455f24fb1cf8, 0x8fe8caa93e74ef6b},
-      {0xb975d6b6ee39e436, 0xb3e2fd538e122b45},
-      {0xe7d34c64a9c85d44, 0x60dbbca87196b617},
-      {0x90e40fbeea1d3a4a, 0xbc8955e946fe31ce},
-      {0xb51d13aea4a488dd, 0x6babab6398bdbe42},
-      {0xe264589a4dcdab14, 0xc696963c7eed2dd2},
-      {0x8d7eb76070a08aec, 0xfc1e1de5cf543ca3},
-      {0xb0de65388cc8ada8, 0x3b25a55f43294bcc},
-      {0xdd15fe86affad912, 0x49ef0eb713f39ebf},
-      {0x8a2dbf142dfcc7ab, 0x6e3569326c784338},
-      {0xacb92ed9397bf996, 0x49c2c37f07965405},
-      {0xd7e77a8f87daf7fb, 0xdc33745ec97be907},
-      {0x86f0ac99b4e8dafd, 0x69a028bb3ded71a4},
-      {0xa8acd7c0222311bc, 0xc40832ea0d68ce0d},
-      {0xd2d80db02aabd62b, 0xf50a3fa490c30191},
-      {0x83c7088e1aab65db, 0x792667c6da79e0fb},
-      {0xa4b8cab1a1563f52, 0x577001b891185939},
-      {0xcde6fd5e09abcf26, 0xed4c0226b55e6f87},
-      {0x80b05e5ac60b6178, 0x544f8158315b05b5},
-      {0xa0dc75f1778e39d6, 0x696361ae3db1c722},
-      {0xc913936dd571c84c, 0x03bc3a19cd1e38ea},
-      {0xfb5878494ace3a5f, 0x04ab48a04065c724},
-      {0x9d174b2dcec0e47b, 0x62eb0d64283f9c77},
-      {0xc45d1df942711d9a, 0x3ba5d0bd324f8395},
-      {0xf5746577930d6500, 0xca8f44ec7ee3647a},
-      {0x9968bf6abbe85f20, 0x7e998b13cf4e1ecc},
-      {0xbfc2ef456ae276e8, 0x9e3fedd8c321a67f},
-      {0xefb3ab16c59b14a2, 0xc5cfe94ef3ea101f},
-      {0x95d04aee3b80ece5, 0xbba1f1d158724a13},
-      {0xbb445da9ca61281f, 0x2a8a6e45ae8edc98},
-      {0xea1575143cf97226, 0xf52d09d71a3293be},
-      {0x924d692ca61be758, 0x593c2626705f9c57},
-      {0xb6e0c377cfa2e12e, 0x6f8b2fb00c77836d},
-      {0xe498f455c38b997a, 0x0b6dfb9c0f956448},
-      {0x8edf98b59a373fec, 0x4724bd4189bd5ead},
-      {0xb2977ee300c50fe7, 0x58edec91ec2cb658},
-      {0xdf3d5e9bc0f653e1, 0x2f2967b66737e3ee},
-      {0x8b865b215899f46c, 0xbd79e0d20082ee75},
-      {0xae67f1e9aec07187, 0xecd8590680a3aa12},
-      {0xda01ee641a708de9, 0xe80e6f4820cc9496},
-      {0x884134fe908658b2, 0x3109058d147fdcde},
-      {0xaa51823e34a7eede, 0xbd4b46f0599fd416},
-      {0xd4e5e2cdc1d1ea96, 0x6c9e18ac7007c91b},
-      {0x850fadc09923329e, 0x03e2cf6bc604ddb1},
-      {0xa6539930bf6bff45, 0x84db8346b786151d},
-      {0xcfe87f7cef46ff16, 0xe612641865679a64},
-      {0x81f14fae158c5f6e, 0x4fcb7e8f3f60c07f},
-      {0xa26da3999aef7749, 0xe3be5e330f38f09e},
-      {0xcb090c8001ab551c, 0x5cadf5bfd3072cc6},
-      {0xfdcb4fa002162a63, 0x73d9732fc7c8f7f7},
-      {0x9e9f11c4014dda7e, 0x2867e7fddcdd9afb},
-      {0xc646d63501a1511d, 0xb281e1fd541501b9},
-      {0xf7d88bc24209a565, 0x1f225a7ca91a4227},
-      {0x9ae757596946075f, 0x3375788de9b06959},
-      {0xc1a12d2fc3978937, 0x0052d6b1641c83af},
-      {0xf209787bb47d6b84, 0xc0678c5dbd23a49b},
-      {0x9745eb4d50ce6332, 0xf840b7ba963646e1},
-      {0xbd176620a501fbff, 0xb650e5a93bc3d899},
-      {0xec5d3fa8ce427aff, 0xa3e51f138ab4cebf},
-      {0x93ba47c980e98cdf, 0xc66f336c36b10138},
-      {0xb8a8d9bbe123f017, 0xb80b0047445d4185},
-      {0xe6d3102ad96cec1d, 0xa60dc059157491e6},
-      {0x9043ea1ac7e41392, 0x87c89837ad68db30},
-      {0xb454e4a179dd1877, 0x29babe4598c311fc},
-      {0xe16a1dc9d8545e94, 0xf4296dd6fef3d67b},
-      {0x8ce2529e2734bb1d, 0x1899e4a65f58660d},
-      {0xb01ae745b101e9e4, 0x5ec05dcff72e7f90},
-      {0xdc21a1171d42645d, 0x76707543f4fa1f74},
-      {0x899504ae72497eba, 0x6a06494a791c53a9},
-      {0xabfa45da0edbde69, 0x0487db9d17636893},
-      {0xd6f8d7509292d603, 0x45a9d2845d3c42b7},
-      {0x865b86925b9bc5c2, 0x0b8a2392ba45a9b3},
-      {0xa7f26836f282b732, 0x8e6cac7768d7141f},
-      {0xd1ef0244af2364ff, 0x3207d795430cd927},
-      {0x8335616aed761f1f, 0x7f44e6bd49e807b9},
-      {0xa402b9c5a8d3a6e7, 0x5f16206c9c6209a7},
-      {0xcd036837130890a1, 0x36dba887c37a8c10},
-      {0x802221226be55a64, 0xc2494954da2c978a},
-      {0xa02aa96b06deb0fd, 0xf2db9baa10b7bd6d},
-      {0xc83553c5c8965d3d, 0x6f92829494e5acc8},
-      {0xfa42a8b73abbf48c, 0xcb772339ba1f17fa},
-      {0x9c69a97284b578d7, 0xff2a760414536efc},
-      {0xc38413cf25e2d70d, 0xfef5138519684abb},
-      {0xf46518c2ef5b8cd1, 0x7eb258665fc25d6a},
-      {0x98bf2f79d5993802, 0xef2f773ffbd97a62},
-      {0xbeeefb584aff8603, 0xaafb550ffacfd8fb},
-      {0xeeaaba2e5dbf6784, 0x95ba2a53f983cf39},
-      {0x952ab45cfa97a0b2, 0xdd945a747bf26184},
-      {0xba756174393d88df, 0x94f971119aeef9e5},
-      {0xe912b9d1478ceb17, 0x7a37cd5601aab85e},
-      {0x91abb422ccb812ee, 0xac62e055c10ab33b},
-      {0xb616a12b7fe617aa, 0x577b986b314d600a},
-      {0xe39c49765fdf9d94, 0xed5a7e85fda0b80c},
-      {0x8e41ade9fbebc27d, 0x14588f13be847308},
-      {0xb1d219647ae6b31c, 0x596eb2d8ae258fc9},
-      {0xde469fbd99a05fe3, 0x6fca5f8ed9aef3bc},
-      {0x8aec23d680043bee, 0x25de7bb9480d5855},
-      {0xada72ccc20054ae9, 0xaf561aa79a10ae6b},
-      {0xd910f7ff28069da4, 0x1b2ba1518094da05},
-      {0x87aa9aff79042286, 0x90fb44d2f05d0843},
-      {0xa99541bf57452b28, 0x353a1607ac744a54},
-      {0xd3fa922f2d1675f2, 0x42889b8997915ce9},
-      {0x847c9b5d7c2e09b7, 0x69956135febada12},
-      {0xa59bc234db398c25, 0x43fab9837e699096},
-      {0xcf02b2c21207ef2e, 0x94f967e45e03f4bc},
-      {0x8161afb94b44f57d, 0x1d1be0eebac278f6},
-      {0xa1ba1ba79e1632dc, 0x6462d92a69731733},
-      {0xca28a291859bbf93, 0x7d7b8f7503cfdcff},
-      {0xfcb2cb35e702af78, 0x5cda735244c3d43f},
-      {0x9defbf01b061adab, 0x3a0888136afa64a8},
-      {0xc56baec21c7a1916, 0x088aaa1845b8fdd1},
-      {0xf6c69a72a3989f5b, 0x8aad549e57273d46},
-      {0x9a3c2087a63f6399, 0x36ac54e2f678864c},
-      {0xc0cb28a98fcf3c7f, 0x84576a1bb416a7de},
-      {0xf0fdf2d3f3c30b9f, 0x656d44a2a11c51d6},
-      {0x969eb7c47859e743, 0x9f644ae5a4b1b326},
-      {0xbc4665b596706114, 0x873d5d9f0dde1fef},
-      {0xeb57ff22fc0c7959, 0xa90cb506d155a7eb},
-      {0x9316ff75dd87cbd8, 0x09a7f12442d588f3},
-      {0xb7dcbf5354e9bece, 0x0c11ed6d538aeb30},
-      {0xe5d3ef282a242e81, 0x8f1668c8a86da5fb},
-      {0x8fa475791a569d10, 0xf96e017d694487bd},
-      {0xb38d92d760ec4455, 0x37c981dcc395a9ad},
-      {0xe070f78d3927556a, 0x85bbe253f47b1418},
-      {0x8c469ab843b89562, 0x93956d7478ccec8f},
-      {0xaf58416654a6babb, 0x387ac8d1970027b3},
-      {0xdb2e51bfe9d0696a, 0x06997b05fcc0319f},
-      {0x88fcf317f22241e2, 0x441fece3bdf81f04},
-      {0xab3c2fddeeaad25a, 0xd527e81cad7626c4},
-      {0xd60b3bd56a5586f1, 0x8a71e223d8d3b075},
-      {0x85c7056562757456, 0xf6872d5667844e4a},
-      {0xa738c6bebb12d16c, 0xb428f8ac016561dc},
-      {0xd106f86e69d785c7, 0xe13336d701beba53},
-      {0x82a45b450226b39c, 0xecc0024661173474},
-      {0xa34d721642b06084, 0x27f002d7f95d0191},
-      {0xcc20ce9bd35c78a5, 0x31ec038df7b441f5},
-      {0xff290242c83396ce, 0x7e67047175a15272},
-      {0x9f79a169bd203e41, 0x0f0062c6e984d387},
-      {0xc75809c42c684dd1, 0x52c07b78a3e60869},
-      {0xf92e0c3537826145, 0xa7709a56ccdf8a83},
-      {0x9bbcc7a142b17ccb, 0x88a66076400bb692},
-      {0xc2abf989935ddbfe, 0x6acff893d00ea436},
-      {0xf356f7ebf83552fe, 0x0583f6b8c4124d44},
-      {0x98165af37b2153de, 0xc3727a337a8b704b},
-      {0xbe1bf1b059e9a8d6, 0x744f18c0592e4c5d},
-      {0xeda2ee1c7064130c, 0x1162def06f79df74},
-      {0x9485d4d1c63e8be7, 0x8addcb5645ac2ba9},
-      {0xb9a74a0637ce2ee1, 0x6d953e2bd7173693},
-      {0xe8111c87c5c1ba99, 0xc8fa8db6ccdd0438},
-      {0x910ab1d4db9914a0, 0x1d9c9892400a22a3},
-      {0xb54d5e4a127f59c8, 0x2503beb6d00cab4c},
-      {0xe2a0b5dc971f303a, 0x2e44ae64840fd61e},
-      {0x8da471a9de737e24, 0x5ceaecfed289e5d3},
-      {0xb10d8e1456105dad, 0x7425a83e872c5f48},
-      {0xdd50f1996b947518, 0xd12f124e28f7771a},
-      {0x8a5296ffe33cc92f, 0x82bd6b70d99aaa70},
-      {0xace73cbfdc0bfb7b, 0x636cc64d1001550c},
-      {0xd8210befd30efa5a, 0x3c47f7e05401aa4f},
-      {0x8714a775e3e95c78, 0x65acfaec34810a72},
-      {0xa8d9d1535ce3b396, 0x7f1839a741a14d0e},
-      {0xd31045a8341ca07c, 0x1ede48111209a051},
-      {0x83ea2b892091e44d, 0x934aed0aab460433},
-      {0xa4e4b66b68b65d60, 0xf81da84d56178540},
-      {0xce1de40642e3f4b9, 0x36251260ab9d668f},
-      {0x80d2ae83e9ce78f3, 0xc1d72b7c6b42601a},
-      {0xa1075a24e4421730, 0xb24cf65b8612f820},
-      {0xc94930ae1d529cfc, 0xdee033f26797b628},
-      {0xfb9b7cd9a4a7443c, 0x169840ef017da3b2},
-      {0x9d412e0806e88aa5, 0x8e1f289560ee864f},
-      {0xc491798a08a2ad4e, 0xf1a6f2bab92a27e3},
-      {0xf5b5d7ec8acb58a2, 0xae10af696774b1dc},
-      {0x9991a6f3d6bf1765, 0xacca6da1e0a8ef2a},
-      {0xbff610b0cc6edd3f, 0x17fd090a58d32af4},
-      {0xeff394dcff8a948e, 0xddfc4b4cef07f5b1},
-      {0x95f83d0a1fb69cd9, 0x4abdaf101564f98f},
-      {0xbb764c4ca7a4440f, 0x9d6d1ad41abe37f2},
-      {0xea53df5fd18d5513, 0x84c86189216dc5ee},
-      {0x92746b9be2f8552c, 0x32fd3cf5b4e49bb5},
-      {0xb7118682dbb66a77, 0x3fbc8c33221dc2a2},
-      {0xe4d5e82392a40515, 0x0fabaf3feaa5334b},
-      {0x8f05b1163ba6832d, 0x29cb4d87f2a7400f},
-      {0xb2c71d5bca9023f8, 0x743e20e9ef511013},
-      {0xdf78e4b2bd342cf6, 0x914da9246b255417},
-      {0x8bab8eefb6409c1a, 0x1ad089b6c2f7548f},
-      {0xae9672aba3d0c320, 0xa184ac2473b529b2},
-      {0xda3c0f568cc4f3e8, 0xc9e5d72d90a2741f},
-      {0x8865899617fb1871, 0x7e2fa67c7a658893},
-      {0xaa7eebfb9df9de8d, 0xddbb901b98feeab8},
-      {0xd51ea6fa85785631, 0x552a74227f3ea566},
-      {0x8533285c936b35de, 0xd53a88958f872760},
-      {0xa67ff273b8460356, 0x8a892abaf368f138},
-      {0xd01fef10a657842c, 0x2d2b7569b0432d86},
-      {0x8213f56a67f6b29b, 0x9c3b29620e29fc74},
-      {0xa298f2c501f45f42, 0x8349f3ba91b47b90},
-      {0xcb3f2f7642717713, 0x241c70a936219a74},
-      {0xfe0efb53d30dd4d7, 0xed238cd383aa0111},
-      {0x9ec95d1463e8a506, 0xf4363804324a40ab},
-      {0xc67bb4597ce2ce48, 0xb143c6053edcd0d6},
-      {0xf81aa16fdc1b81da, 0xdd94b7868e94050b},
-      {0x9b10a4e5e9913128, 0xca7cf2b4191c8327},
-      {0xc1d4ce1f63f57d72, 0xfd1c2f611f63a3f1},
-      {0xf24a01a73cf2dccf, 0xbc633b39673c8ced},
-      {0x976e41088617ca01, 0xd5be0503e085d814},
-      {0xbd49d14aa79dbc82, 0x4b2d8644d8a74e19},
-      {0xec9c459d51852ba2, 0xddf8e7d60ed1219f},
-      {0x93e1ab8252f33b45, 0xcabb90e5c942b504},
-      {0xb8da1662e7b00a17, 0x3d6a751f3b936244},
-      {0xe7109bfba19c0c9d, 0x0cc512670a783ad5},
-      {0x906a617d450187e2, 0x27fb2b80668b24c6},
-      {0xb484f9dc9641e9da, 0xb1f9f660802dedf7},
-      {0xe1a63853bbd26451, 0x5e7873f8a0396974},
-      {0x8d07e33455637eb2, 0xdb0b487b6423e1e9},
-      {0xb049dc016abc5e5f, 0x91ce1a9a3d2cda63},
-      {0xdc5c5301c56b75f7, 0x7641a140cc7810fc},
-      {0x89b9b3e11b6329ba, 0xa9e904c87fcb0a9e},
-      {0xac2820d9623bf429, 0x546345fa9fbdcd45},
-      {0xd732290fbacaf133, 0xa97c177947ad4096},
-      {0x867f59a9d4bed6c0, 0x49ed8eabcccc485e},
-      {0xa81f301449ee8c70, 0x5c68f256bfff5a75},
-      {0xd226fc195c6a2f8c, 0x73832eec6fff3112},
-      {0x83585d8fd9c25db7, 0xc831fd53c5ff7eac},
-      {0xa42e74f3d032f525, 0xba3e7ca8b77f5e56},
-      {0xcd3a1230c43fb26f, 0x28ce1bd2e55f35ec},
-      {0x80444b5e7aa7cf85, 0x7980d163cf5b81b4},
-      {0xa0555e361951c366, 0xd7e105bcc3326220},
-      {0xc86ab5c39fa63440, 0x8dd9472bf3fefaa8},
-      {0xfa856334878fc150, 0xb14f98f6f0feb952},
-      {0x9c935e00d4b9d8d2, 0x6ed1bf9a569f33d4},
-      {0xc3b8358109e84f07, 0x0a862f80ec4700c9},
-      {0xf4a642e14c6262c8, 0xcd27bb612758c0fb},
-      {0x98e7e9cccfbd7dbd, 0x8038d51cb897789d},
-      {0xbf21e44003acdd2c, 0xe0470a63e6bd56c4},
-      {0xeeea5d5004981478, 0x1858ccfce06cac75},
-      {0x95527a5202df0ccb, 0x0f37801e0c43ebc9},
-      {0xbaa718e68396cffd, 0xd30560258f54e6bb},
-      {0xe950df20247c83fd, 0x47c6b82ef32a206a},
-      {0x91d28b7416cdd27e, 0x4cdc331d57fa5442},
-      {0xb6472e511c81471d, 0xe0133fe4adf8e953},
-      {0xe3d8f9e563a198e5, 0x58180fddd97723a7},
-      {0x8e679c2f5e44ff8f, 0x570f09eaa7ea7649},
-      {0xb201833b35d63f73, 0x2cd2cc6551e513db},
-      {0xde81e40a034bcf4f, 0xf8077f7ea65e58d2},
-      {0x8b112e86420f6191, 0xfb04afaf27faf783},
-      {0xadd57a27d29339f6, 0x79c5db9af1f9b564},
-      {0xd94ad8b1c7380874, 0x18375281ae7822bd},
-      {0x87cec76f1c830548, 0x8f2293910d0b15b6},
-      {0xa9c2794ae3a3c69a, 0xb2eb3875504ddb23},
-      {0xd433179d9c8cb841, 0x5fa60692a46151ec},
-      {0x849feec281d7f328, 0xdbc7c41ba6bcd334},
-      {0xa5c7ea73224deff3, 0x12b9b522906c0801},
-      {0xcf39e50feae16bef, 0xd768226b34870a01},
-      {0x81842f29f2cce375, 0xe6a1158300d46641},
-      {0xa1e53af46f801c53, 0x60495ae3c1097fd1},
-      {0xca5e89b18b602368, 0x385bb19cb14bdfc5},
-      {0xfcf62c1dee382c42, 0x46729e03dd9ed7b6},
-      {0x9e19db92b4e31ba9, 0x6c07a2c26a8346d2},
-      {0xc5a05277621be293, 0xc7098b7305241886},
-      { 0xf70867153aa2db38,
-        0xb8cbee4fc66d1ea8 }
-#else
-      {0xff77b1fcbebcdc4f, 0x25e8e89c13bb0f7b},
-      {0xce5d73ff402d98e3, 0xfb0a3d212dc81290},
-      {0xa6b34ad8c9dfc06f, 0xf42faa48c0ea481f},
-      {0x86a8d39ef77164bc, 0xae5dff9c02033198},
-      {0xd98ddaee19068c76, 0x3badd624dd9b0958},
-      {0xafbd2350644eeacf, 0xe5d1929ef90898fb},
-      {0x8df5efabc5979c8f, 0xca8d3ffa1ef463c2},
-      {0xe55990879ddcaabd, 0xcc420a6a101d0516},
-      {0xb94470938fa89bce, 0xf808e40e8d5b3e6a},
-      {0x95a8637627989aad, 0xdde7001379a44aa9},
-      {0xf1c90080baf72cb1, 0x5324c68b12dd6339},
-      {0xc350000000000000, 0x0000000000000000},
-      {0x9dc5ada82b70b59d, 0xf020000000000000},
-      {0xfee50b7025c36a08, 0x02f236d04753d5b5},
-      {0xcde6fd5e09abcf26, 0xed4c0226b55e6f87},
-      {0xa6539930bf6bff45, 0x84db8346b786151d},
-      {0x865b86925b9bc5c2, 0x0b8a2392ba45a9b3},
-      {0xd910f7ff28069da4, 0x1b2ba1518094da05},
-      {0xaf58416654a6babb, 0x387ac8d1970027b3},
-      {0x8da471a9de737e24, 0x5ceaecfed289e5d3},
-      {0xe4d5e82392a40515, 0x0fabaf3feaa5334b},
-      {0xb8da1662e7b00a17, 0x3d6a751f3b936244},
-      { 0x95527a5202df0ccb,
-        0x0f37801e0c43ebc9 }
-#endif
-    };
-
-#if FMT_USE_FULL_CACHE_DRAGONBOX
-    return pow10_significands[k - float_info<double>::min_k];
-#else
-    static constexpr const uint64_t powers_of_5_64[] = {
-        0x0000000000000001, 0x0000000000000005, 0x0000000000000019,
-        0x000000000000007d, 0x0000000000000271, 0x0000000000000c35,
-        0x0000000000003d09, 0x000000000001312d, 0x000000000005f5e1,
-        0x00000000001dcd65, 0x00000000009502f9, 0x0000000002e90edd,
-        0x000000000e8d4a51, 0x0000000048c27395, 0x000000016bcc41e9,
-        0x000000071afd498d, 0x0000002386f26fc1, 0x000000b1a2bc2ec5,
-        0x000003782dace9d9, 0x00001158e460913d, 0x000056bc75e2d631,
-        0x0001b1ae4d6e2ef5, 0x000878678326eac9, 0x002a5a058fc295ed,
-        0x00d3c21bcecceda1, 0x0422ca8b0a00a425, 0x14adf4b7320334b9};
-
-    static const int compression_ratio = 27;
-
-    // Compute base index.
-    int cache_index = (k - float_info<double>::min_k) / compression_ratio;
-    int kb = cache_index * compression_ratio + float_info<double>::min_k;
-    int offset = k - kb;
-
-    // Get base cache.
-    uint128_fallback base_cache = pow10_significands[cache_index];
-    if (offset == 0) return base_cache;
-
-    // Compute the required amount of bit-shift.
-    int alpha = floor_log2_pow10(kb + offset) - floor_log2_pow10(kb) - offset;
-    FMT_ASSERT(alpha > 0 && alpha < 64, "shifting error detected");
-
-    // Try to recover the real cache.
-    uint64_t pow5 = powers_of_5_64[offset];
-    uint128_fallback recovered_cache = umul128(base_cache.high(), pow5);
-    uint128_fallback middle_low = umul128(base_cache.low(), pow5);
-
-    recovered_cache += middle_low.high();
-
-    uint64_t high_to_middle = recovered_cache.high() << (64 - alpha);
-    uint64_t middle_to_low = recovered_cache.low() << (64 - alpha);
-
-    recovered_cache =
-        uint128_fallback{(recovered_cache.low() >> alpha) | high_to_middle,
-                         ((middle_low.low() >> alpha) | middle_to_low)};
-    FMT_ASSERT(recovered_cache.low() + 1 != 0, "");
-    return {recovered_cache.high(), recovered_cache.low() + 1};
-#endif
-  }
-
-  struct compute_mul_result {
-    carrier_uint result;
-    bool is_integer;
-  };
-  struct compute_mul_parity_result {
-    bool parity;
-    bool is_integer;
-  };
-
-  static compute_mul_result compute_mul(
-      carrier_uint u, const cache_entry_type& cache) noexcept {
-    auto r = umul192_upper128(u, cache);
-    return {r.high(), r.low() == 0};
-  }
-
-  static uint32_t compute_delta(cache_entry_type const& cache,
-                                int beta) noexcept {
-    return static_cast<uint32_t>(cache.high() >> (64 - 1 - beta));
-  }
-
-  static compute_mul_parity_result compute_mul_parity(
-      carrier_uint two_f, const cache_entry_type& cache, int beta) noexcept {
-    FMT_ASSERT(beta >= 1, "");
-    FMT_ASSERT(beta < 64, "");
-
-    auto r = umul192_lower128(two_f, cache);
-    return {((r.high() >> (64 - beta)) & 1) != 0,
-            ((r.high() << beta) | (r.low() >> (64 - beta))) == 0};
-  }
-
-  static carrier_uint compute_left_endpoint_for_shorter_interval_case(
-      const cache_entry_type& cache, int beta) noexcept {
-    return (cache.high() -
-            (cache.high() >> (num_significand_bits<double>() + 2))) >>
-           (64 - num_significand_bits<double>() - 1 - beta);
-  }
-
-  static carrier_uint compute_right_endpoint_for_shorter_interval_case(
-      const cache_entry_type& cache, int beta) noexcept {
-    return (cache.high() +
-            (cache.high() >> (num_significand_bits<double>() + 1))) >>
-           (64 - num_significand_bits<double>() - 1 - beta);
-  }
-
-  static carrier_uint compute_round_up_for_shorter_interval_case(
-      const cache_entry_type& cache, int beta) noexcept {
-    return ((cache.high() >> (64 - num_significand_bits<double>() - 2 - beta)) +
-            1) /
-           2;
-  }
-};
-
-// Various integer checks
-template <class T>
-bool is_left_endpoint_integer_shorter_interval(int exponent) noexcept {
-  const int case_shorter_interval_left_endpoint_lower_threshold = 2;
-  const int case_shorter_interval_left_endpoint_upper_threshold = 3;
-  return exponent >= case_shorter_interval_left_endpoint_lower_threshold &&
-         exponent <= case_shorter_interval_left_endpoint_upper_threshold;
-}
-
-// Remove trailing zeros from n and return the number of zeros removed (float)
-FMT_INLINE int remove_trailing_zeros(uint32_t& n) noexcept {
-  FMT_ASSERT(n != 0, "");
-  const uint32_t mod_inv_5 = 0xcccccccd;
-  const uint32_t mod_inv_25 = mod_inv_5 * mod_inv_5;
-
-  int s = 0;
-  while (true) {
-    auto q = rotr(n * mod_inv_25, 2);
-    if (q > max_value<uint32_t>() / 100) break;
-    n = q;
-    s += 2;
-  }
-  auto q = rotr(n * mod_inv_5, 1);
-  if (q <= max_value<uint32_t>() / 10) {
-    n = q;
-    s |= 1;
-  }
-
-  return s;
-}
-
-// Removes trailing zeros and returns the number of zeros removed (double)
-FMT_INLINE int remove_trailing_zeros(uint64_t& n) noexcept {
-  FMT_ASSERT(n != 0, "");
-
-  // This magic number is ceil(2^90 / 10^8).
-  constexpr uint64_t magic_number = 12379400392853802749ull;
-  auto nm = umul128(n, magic_number);
-
-  // Is n is divisible by 10^8?
-  if ((nm.high() & ((1ull << (90 - 64)) - 1)) == 0 && nm.low() < magic_number) {
-    // If yes, work with the quotient.
-    auto n32 = static_cast<uint32_t>(nm.high() >> (90 - 64));
-
-    const uint32_t mod_inv_5 = 0xcccccccd;
-    const uint32_t mod_inv_25 = mod_inv_5 * mod_inv_5;
-
-    int s = 8;
-    while (true) {
-      auto q = rotr(n32 * mod_inv_25, 2);
-      if (q > max_value<uint32_t>() / 100) break;
-      n32 = q;
-      s += 2;
-    }
-    auto q = rotr(n32 * mod_inv_5, 1);
-    if (q <= max_value<uint32_t>() / 10) {
-      n32 = q;
-      s |= 1;
-    }
-
-    n = n32;
-    return s;
-  }
-
-  // If n is not divisible by 10^8, work with n itself.
-  const uint64_t mod_inv_5 = 0xcccccccccccccccd;
-  const uint64_t mod_inv_25 = mod_inv_5 * mod_inv_5;
-
-  int s = 0;
-  while (true) {
-    auto q = rotr(n * mod_inv_25, 2);
-    if (q > max_value<uint64_t>() / 100) break;
-    n = q;
-    s += 2;
-  }
-  auto q = rotr(n * mod_inv_5, 1);
-  if (q <= max_value<uint64_t>() / 10) {
-    n = q;
-    s |= 1;
-  }
-
-  return s;
-}
-
-// The main algorithm for shorter interval case
-template <class T>
-FMT_INLINE decimal_fp<T> shorter_interval_case(int exponent) noexcept {
-  decimal_fp<T> ret_value;
-  // Compute k and beta
-  const int minus_k = floor_log10_pow2_minus_log10_4_over_3(exponent);
-  const int beta = exponent + floor_log2_pow10(-minus_k);
-
-  // Compute xi and zi
-  using cache_entry_type = typename cache_accessor<T>::cache_entry_type;
-  const cache_entry_type cache = cache_accessor<T>::get_cached_power(-minus_k);
-
-  auto xi = cache_accessor<T>::compute_left_endpoint_for_shorter_interval_case(
-      cache, beta);
-  auto zi = cache_accessor<T>::compute_right_endpoint_for_shorter_interval_case(
-      cache, beta);
-
-  // If the left endpoint is not an integer, increase it
-  if (!is_left_endpoint_integer_shorter_interval<T>(exponent)) ++xi;
-
-  // Try bigger divisor
-  ret_value.significand = zi / 10;
-
-  // If succeed, remove trailing zeros if necessary and return
-  if (ret_value.significand * 10 >= xi) {
-    ret_value.exponent = minus_k + 1;
-    ret_value.exponent += remove_trailing_zeros(ret_value.significand);
-    return ret_value;
-  }
-
-  // Otherwise, compute the round-up of y
-  ret_value.significand =
-      cache_accessor<T>::compute_round_up_for_shorter_interval_case(cache,
-                                                                    beta);
-  ret_value.exponent = minus_k;
-
-  // When tie occurs, choose one of them according to the rule
-  if (exponent >= float_info<T>::shorter_interval_tie_lower_threshold &&
-      exponent <= float_info<T>::shorter_interval_tie_upper_threshold) {
-    ret_value.significand = ret_value.significand % 2 == 0
-                                ? ret_value.significand
-                                : ret_value.significand - 1;
-  } else if (ret_value.significand < xi) {
-    ++ret_value.significand;
-  }
-  return ret_value;
-}
-
-template <typename T> decimal_fp<T> to_decimal(T x) noexcept {
-  // Step 1: integer promotion & Schubfach multiplier calculation.
-
-  using carrier_uint = typename float_info<T>::carrier_uint;
-  using cache_entry_type = typename cache_accessor<T>::cache_entry_type;
-  auto br = bit_cast<carrier_uint>(x);
-
-  // Extract significand bits and exponent bits.
-  const carrier_uint significand_mask =
-      (static_cast<carrier_uint>(1) << num_significand_bits<T>()) - 1;
-  carrier_uint significand = (br & significand_mask);
-  int exponent =
-      static_cast<int>((br & exponent_mask<T>()) >> num_significand_bits<T>());
-
-  if (exponent != 0) {  // Check if normal.
-    exponent -= exponent_bias<T>() + num_significand_bits<T>();
-
-    // Shorter interval case; proceed like Schubfach.
-    // In fact, when exponent == 1 and significand == 0, the interval is
-    // regular. However, it can be shown that the end-results are anyway same.
-    if (significand == 0) return shorter_interval_case<T>(exponent);
-
-    significand |= (static_cast<carrier_uint>(1) << num_significand_bits<T>());
-  } else {
-    // Subnormal case; the interval is always regular.
-    if (significand == 0) return {0, 0};
-    exponent =
-        std::numeric_limits<T>::min_exponent - num_significand_bits<T>() - 1;
-  }
-
-  const bool include_left_endpoint = (significand % 2 == 0);
-  const bool include_right_endpoint = include_left_endpoint;
-
-  // Compute k and beta.
-  const int minus_k = floor_log10_pow2(exponent) - float_info<T>::kappa;
-  const cache_entry_type cache = cache_accessor<T>::get_cached_power(-minus_k);
-  const int beta = exponent + floor_log2_pow10(-minus_k);
-
-  // Compute zi and deltai.
-  // 10^kappa <= deltai < 10^(kappa + 1)
-  const uint32_t deltai = cache_accessor<T>::compute_delta(cache, beta);
-  const carrier_uint two_fc = significand << 1;
-
-  // For the case of binary32, the result of integer check is not correct for
-  // 29711844 * 2^-82
-  // = 6.1442653300000000008655037797566933477355632930994033813476... * 10^-18
-  // and 29711844 * 2^-81
-  // = 1.2288530660000000001731007559513386695471126586198806762695... * 10^-17,
-  // and they are the unique counterexamples. However, since 29711844 is even,
-  // this does not cause any problem for the endpoints calculations; it can only
-  // cause a problem when we need to perform integer check for the center.
-  // Fortunately, with these inputs, that branch is never executed, so we are
-  // fine.
-  const typename cache_accessor<T>::compute_mul_result z_mul =
-      cache_accessor<T>::compute_mul((two_fc | 1) << beta, cache);
-
-  // Step 2: Try larger divisor; remove trailing zeros if necessary.
-
-  // Using an upper bound on zi, we might be able to optimize the division
-  // better than the compiler; we are computing zi / big_divisor here.
-  decimal_fp<T> ret_value;
-  ret_value.significand = divide_by_10_to_kappa_plus_1(z_mul.result);
-  uint32_t r = static_cast<uint32_t>(z_mul.result - float_info<T>::big_divisor *
-                                                        ret_value.significand);
-
-  if (r < deltai) {
-    // Exclude the right endpoint if necessary.
-    if (r == 0 && (z_mul.is_integer & !include_right_endpoint)) {
-      --ret_value.significand;
-      r = float_info<T>::big_divisor;
-      goto small_divisor_case_label;
-    }
-  } else if (r > deltai) {
-    goto small_divisor_case_label;
-  } else {
-    // r == deltai; compare fractional parts.
-    const typename cache_accessor<T>::compute_mul_parity_result x_mul =
-        cache_accessor<T>::compute_mul_parity(two_fc - 1, cache, beta);
-
-    if (!(x_mul.parity | (x_mul.is_integer & include_left_endpoint)))
-      goto small_divisor_case_label;
-  }
-  ret_value.exponent = minus_k + float_info<T>::kappa + 1;
-
-  // We may need to remove trailing zeros.
-  ret_value.exponent += remove_trailing_zeros(ret_value.significand);
-  return ret_value;
-
-  // Step 3: Find the significand with the smaller divisor.
-
-small_divisor_case_label:
-  ret_value.significand *= 10;
-  ret_value.exponent = minus_k + float_info<T>::kappa;
-
-  uint32_t dist = r - (deltai / 2) + (float_info<T>::small_divisor / 2);
-  const bool approx_y_parity =
-      ((dist ^ (float_info<T>::small_divisor / 2)) & 1) != 0;
-
-  // Is dist divisible by 10^kappa?
-  const bool divisible_by_small_divisor =
-      check_divisibility_and_divide_by_pow10<float_info<T>::kappa>(dist);
-
-  // Add dist / 10^kappa to the significand.
-  ret_value.significand += dist;
-
-  if (!divisible_by_small_divisor) return ret_value;
-
-  // Check z^(f) >= epsilon^(f).
-  // We have either yi == zi - epsiloni or yi == (zi - epsiloni) - 1,
-  // where yi == zi - epsiloni if and only if z^(f) >= epsilon^(f).
-  // Since there are only 2 possibilities, we only need to care about the
-  // parity. Also, zi and r should have the same parity since the divisor
-  // is an even number.
-  const auto y_mul = cache_accessor<T>::compute_mul_parity(two_fc, cache, beta);
-
-  // If z^(f) >= epsilon^(f), we might have a tie when z^(f) == epsilon^(f),
-  // or equivalently, when y is an integer.
-  if (y_mul.parity != approx_y_parity)
-    --ret_value.significand;
-  else if (y_mul.is_integer & (ret_value.significand % 2 != 0))
-    --ret_value.significand;
-  return ret_value;
-}
-}  // namespace dragonbox
-
-#ifdef _MSC_VER
-FMT_FUNC auto fmt_snprintf(char* buf, size_t size, const char* fmt, ...)
-    -> int {
-  auto args = va_list();
-  va_start(args, fmt);
-  int result = vsnprintf_s(buf, size, _TRUNCATE, fmt, args);
-  va_end(args);
-  return result;
-}
-#endif
-}  // namespace detail
-
-template <> struct formatter<detail::bigint> {
-  FMT_CONSTEXPR auto parse(format_parse_context& ctx)
-      -> format_parse_context::iterator {
-    return ctx.begin();
-  }
-
-  template <typename FormatContext>
-  auto format(const detail::bigint& n, FormatContext& ctx) const ->
-      typename FormatContext::iterator {
-    auto out = ctx.out();
-    bool first = true;
-    for (auto i = n.bigits_.size(); i > 0; --i) {
-      auto value = n.bigits_[i - 1u];
-      if (first) {
-        out = format_to(out, FMT_STRING("{:x}"), value);
-        first = false;
-        continue;
-      }
-      out = format_to(out, FMT_STRING("{:08x}"), value);
-    }
-    if (n.exp_ > 0)
-      out = format_to(out, FMT_STRING("p{}"),
-                      n.exp_ * detail::bigint::bigit_bits);
-    return out;
-  }
-};
-
-FMT_FUNC detail::utf8_to_utf16::utf8_to_utf16(string_view s) {
-  for_each_codepoint(s, [this](uint32_t cp, string_view) {
-    if (cp == invalid_code_point) FMT_THROW(std::runtime_error("invalid utf8"));
-    if (cp <= 0xFFFF) {
-      buffer_.push_back(static_cast<wchar_t>(cp));
-    } else {
-      cp -= 0x10000;
-      buffer_.push_back(static_cast<wchar_t>(0xD800 + (cp >> 10)));
-      buffer_.push_back(static_cast<wchar_t>(0xDC00 + (cp & 0x3FF)));
-    }
-    return true;
-  });
-  buffer_.push_back(0);
-}
-
-FMT_FUNC void format_system_error(detail::buffer<char>& out, int error_code,
-                                  const char* message) noexcept {
-  FMT_TRY {
-    auto ec = std::error_code(error_code, std::generic_category());
-    write(std::back_inserter(out), std::system_error(ec, message).what());
-    return;
-  }
-  FMT_CATCH(...) {}
-  format_error_code(out, error_code, message);
-}
-
-FMT_FUNC void report_system_error(int error_code,
-                                  const char* message) noexcept {
-  report_error(format_system_error, error_code, message);
-}
-
-FMT_FUNC std::string vformat(string_view fmt, format_args args) {
-  // Don't optimize the "{}" case to keep the binary size small and because it
-  // can be better optimized in fmt::format anyway.
-  auto buffer = memory_buffer();
-  detail::vformat_to(buffer, fmt, args);
-  return to_string(buffer);
-}
-
-namespace detail {
-#ifdef _WIN32
-using dword = conditional_t<sizeof(long) == 4, unsigned long, unsigned>;
-extern "C" __declspec(dllimport) int __stdcall WriteConsoleW(  //
-    void*, const void*, dword, dword*, void*);
-
-FMT_FUNC bool write_console(std::FILE* f, string_view text) {
-  auto fd = _fileno(f);
-  if (_isatty(fd)) {
-    detail::utf8_to_utf16 u16(string_view(text.data(), text.size()));
-    auto written = detail::dword();
-    if (detail::WriteConsoleW(reinterpret_cast<void*>(_get_osfhandle(fd)),
-                              u16.c_str(), static_cast<uint32_t>(u16.size()),
-                              &written, nullptr)) {
-      return true;
-    }
-  }
-  // We return false if the file descriptor was not TTY, or it was but
-  // SetConsoleW failed which can happen if the output has been redirected to
-  // NUL. In both cases when we return false, we should attempt to do regular
-  // write via fwrite or std::ostream::write.
-  return false;
-}
-#endif
-
-FMT_FUNC void print(std::FILE* f, string_view text) {
-#ifdef _WIN32
-  if (write_console(f, text)) return;
-#endif
-  detail::fwrite_fully(text.data(), 1, text.size(), f);
-}
-}  // namespace detail
-
-FMT_FUNC void vprint(std::FILE* f, string_view format_str, format_args args) {
-  memory_buffer buffer;
-  detail::vformat_to(buffer, format_str, args);
-  detail::print(f, {buffer.data(), buffer.size()});
-}
-
-#ifdef _WIN32
-// Print assuming legacy (non-Unicode) encoding.
-FMT_FUNC void detail::vprint_mojibake(std::FILE* f, string_view format_str,
-                                      format_args args) {
-  memory_buffer buffer;
-  detail::vformat_to(buffer, format_str,
-                     basic_format_args<buffer_context<char>>(args));
-  fwrite_fully(buffer.data(), 1, buffer.size(), f);
-}
-#endif
-
-FMT_FUNC void vprint(string_view format_str, format_args args) {
-  vprint(stdout, format_str, args);
-}
-
-namespace detail {
-
-struct singleton {
-  unsigned char upper;
-  unsigned char lower_count;
-};
-
-inline auto is_printable(uint16_t x, const singleton* singletons,
-                         size_t singletons_size,
-                         const unsigned char* singleton_lowers,
-                         const unsigned char* normal, size_t normal_size)
-    -> bool {
-  auto upper = x >> 8;
-  auto lower_start = 0;
-  for (size_t i = 0; i < singletons_size; ++i) {
-    auto s = singletons[i];
-    auto lower_end = lower_start + s.lower_count;
-    if (upper < s.upper) break;
-    if (upper == s.upper) {
-      for (auto j = lower_start; j < lower_end; ++j) {
-        if (singleton_lowers[j] == (x & 0xff)) return false;
-      }
-    }
-    lower_start = lower_end;
-  }
-
-  auto xsigned = static_cast<int>(x);
-  auto current = true;
-  for (size_t i = 0; i < normal_size; ++i) {
-    auto v = static_cast<int>(normal[i]);
-    auto len = (v & 0x80) != 0 ? (v & 0x7f) << 8 | normal[++i] : v;
-    xsigned -= len;
-    if (xsigned < 0) break;
-    current = !current;
-  }
-  return current;
-}
-
-// This code is generated by support/printable.py.
-FMT_FUNC auto is_printable(uint32_t cp) -> bool {
-  static constexpr singleton singletons0[] = {
-      {0x00, 1},  {0x03, 5},  {0x05, 6},  {0x06, 3},  {0x07, 6},  {0x08, 8},
-      {0x09, 17}, {0x0a, 28}, {0x0b, 25}, {0x0c, 20}, {0x0d, 16}, {0x0e, 13},
-      {0x0f, 4},  {0x10, 3},  {0x12, 18}, {0x13, 9},  {0x16, 1},  {0x17, 5},
-      {0x18, 2},  {0x19, 3},  {0x1a, 7},  {0x1c, 2},  {0x1d, 1},  {0x1f, 22},
-      {0x20, 3},  {0x2b, 3},  {0x2c, 2},  {0x2d, 11}, {0x2e, 1},  {0x30, 3},
-      {0x31, 2},  {0x32, 1},  {0xa7, 2},  {0xa9, 2},  {0xaa, 4},  {0xab, 8},
-      {0xfa, 2},  {0xfb, 5},  {0xfd, 4},  {0xfe, 3},  {0xff, 9},
-  };
-  static constexpr unsigned char singletons0_lower[] = {
-      0xad, 0x78, 0x79, 0x8b, 0x8d, 0xa2, 0x30, 0x57, 0x58, 0x8b, 0x8c, 0x90,
-      0x1c, 0x1d, 0xdd, 0x0e, 0x0f, 0x4b, 0x4c, 0xfb, 0xfc, 0x2e, 0x2f, 0x3f,
-      0x5c, 0x5d, 0x5f, 0xb5, 0xe2, 0x84, 0x8d, 0x8e, 0x91, 0x92, 0xa9, 0xb1,
-      0xba, 0xbb, 0xc5, 0xc6, 0xc9, 0xca, 0xde, 0xe4, 0xe5, 0xff, 0x00, 0x04,
-      0x11, 0x12, 0x29, 0x31, 0x34, 0x37, 0x3a, 0x3b, 0x3d, 0x49, 0x4a, 0x5d,
-      0x84, 0x8e, 0x92, 0xa9, 0xb1, 0xb4, 0xba, 0xbb, 0xc6, 0xca, 0xce, 0xcf,
-      0xe4, 0xe5, 0x00, 0x04, 0x0d, 0x0e, 0x11, 0x12, 0x29, 0x31, 0x34, 0x3a,
-      0x3b, 0x45, 0x46, 0x49, 0x4a, 0x5e, 0x64, 0x65, 0x84, 0x91, 0x9b, 0x9d,
-      0xc9, 0xce, 0xcf, 0x0d, 0x11, 0x29, 0x45, 0x49, 0x57, 0x64, 0x65, 0x8d,
-      0x91, 0xa9, 0xb4, 0xba, 0xbb, 0xc5, 0xc9, 0xdf, 0xe4, 0xe5, 0xf0, 0x0d,
-      0x11, 0x45, 0x49, 0x64, 0x65, 0x80, 0x84, 0xb2, 0xbc, 0xbe, 0xbf, 0xd5,
-      0xd7, 0xf0, 0xf1, 0x83, 0x85, 0x8b, 0xa4, 0xa6, 0xbe, 0xbf, 0xc5, 0xc7,
-      0xce, 0xcf, 0xda, 0xdb, 0x48, 0x98, 0xbd, 0xcd, 0xc6, 0xce, 0xcf, 0x49,
-      0x4e, 0x4f, 0x57, 0x59, 0x5e, 0x5f, 0x89, 0x8e, 0x8f, 0xb1, 0xb6, 0xb7,
-      0xbf, 0xc1, 0xc6, 0xc7, 0xd7, 0x11, 0x16, 0x17, 0x5b, 0x5c, 0xf6, 0xf7,
-      0xfe, 0xff, 0x80, 0x0d, 0x6d, 0x71, 0xde, 0xdf, 0x0e, 0x0f, 0x1f, 0x6e,
-      0x6f, 0x1c, 0x1d, 0x5f, 0x7d, 0x7e, 0xae, 0xaf, 0xbb, 0xbc, 0xfa, 0x16,
-      0x17, 0x1e, 0x1f, 0x46, 0x47, 0x4e, 0x4f, 0x58, 0x5a, 0x5c, 0x5e, 0x7e,
-      0x7f, 0xb5, 0xc5, 0xd4, 0xd5, 0xdc, 0xf0, 0xf1, 0xf5, 0x72, 0x73, 0x8f,
-      0x74, 0x75, 0x96, 0x2f, 0x5f, 0x26, 0x2e, 0x2f, 0xa7, 0xaf, 0xb7, 0xbf,
-      0xc7, 0xcf, 0xd7, 0xdf, 0x9a, 0x40, 0x97, 0x98, 0x30, 0x8f, 0x1f, 0xc0,
-      0xc1, 0xce, 0xff, 0x4e, 0x4f, 0x5a, 0x5b, 0x07, 0x08, 0x0f, 0x10, 0x27,
-      0x2f, 0xee, 0xef, 0x6e, 0x6f, 0x37, 0x3d, 0x3f, 0x42, 0x45, 0x90, 0x91,
-      0xfe, 0xff, 0x53, 0x67, 0x75, 0xc8, 0xc9, 0xd0, 0xd1, 0xd8, 0xd9, 0xe7,
-      0xfe, 0xff,
-  };
-  static constexpr singleton singletons1[] = {
-      {0x00, 6},  {0x01, 1}, {0x03, 1},  {0x04, 2}, {0x08, 8},  {0x09, 2},
-      {0x0a, 5},  {0x0b, 2}, {0x0e, 4},  {0x10, 1}, {0x11, 2},  {0x12, 5},
-      {0x13, 17}, {0x14, 1}, {0x15, 2},  {0x17, 2}, {0x19, 13}, {0x1c, 5},
-      {0x1d, 8},  {0x24, 1}, {0x6a, 3},  {0x6b, 2}, {0xbc, 2},  {0xd1, 2},
-      {0xd4, 12}, {0xd5, 9}, {0xd6, 2},  {0xd7, 2}, {0xda, 1},  {0xe0, 5},
-      {0xe1, 2},  {0xe8, 2}, {0xee, 32}, {0xf0, 4}, {0xf8, 2},  {0xf9, 2},
-      {0xfa, 2},  {0xfb, 1},
-  };
-  static constexpr unsigned char singletons1_lower[] = {
-      0x0c, 0x27, 0x3b, 0x3e, 0x4e, 0x4f, 0x8f, 0x9e, 0x9e, 0x9f, 0x06, 0x07,
-      0x09, 0x36, 0x3d, 0x3e, 0x56, 0xf3, 0xd0, 0xd1, 0x04, 0x14, 0x18, 0x36,
-      0x37, 0x56, 0x57, 0x7f, 0xaa, 0xae, 0xaf, 0xbd, 0x35, 0xe0, 0x12, 0x87,
-      0x89, 0x8e, 0x9e, 0x04, 0x0d, 0x0e, 0x11, 0x12, 0x29, 0x31, 0x34, 0x3a,
-      0x45, 0x46, 0x49, 0x4a, 0x4e, 0x4f, 0x64, 0x65, 0x5c, 0xb6, 0xb7, 0x1b,
-      0x1c, 0x07, 0x08, 0x0a, 0x0b, 0x14, 0x17, 0x36, 0x39, 0x3a, 0xa8, 0xa9,
-      0xd8, 0xd9, 0x09, 0x37, 0x90, 0x91, 0xa8, 0x07, 0x0a, 0x3b, 0x3e, 0x66,
-      0x69, 0x8f, 0x92, 0x6f, 0x5f, 0xee, 0xef, 0x5a, 0x62, 0x9a, 0x9b, 0x27,
-      0x28, 0x55, 0x9d, 0xa0, 0xa1, 0xa3, 0xa4, 0xa7, 0xa8, 0xad, 0xba, 0xbc,
-      0xc4, 0x06, 0x0b, 0x0c, 0x15, 0x1d, 0x3a, 0x3f, 0x45, 0x51, 0xa6, 0xa7,
-      0xcc, 0xcd, 0xa0, 0x07, 0x19, 0x1a, 0x22, 0x25, 0x3e, 0x3f, 0xc5, 0xc6,
-      0x04, 0x20, 0x23, 0x25, 0x26, 0x28, 0x33, 0x38, 0x3a, 0x48, 0x4a, 0x4c,
-      0x50, 0x53, 0x55, 0x56, 0x58, 0x5a, 0x5c, 0x5e, 0x60, 0x63, 0x65, 0x66,
-      0x6b, 0x73, 0x78, 0x7d, 0x7f, 0x8a, 0xa4, 0xaa, 0xaf, 0xb0, 0xc0, 0xd0,
-      0xae, 0xaf, 0x79, 0xcc, 0x6e, 0x6f, 0x93,
-  };
-  static constexpr unsigned char normal0[] = {
-      0x00, 0x20, 0x5f, 0x22, 0x82, 0xdf, 0x04, 0x82, 0x44, 0x08, 0x1b, 0x04,
-      0x06, 0x11, 0x81, 0xac, 0x0e, 0x80, 0xab, 0x35, 0x28, 0x0b, 0x80, 0xe0,
-      0x03, 0x19, 0x08, 0x01, 0x04, 0x2f, 0x04, 0x34, 0x04, 0x07, 0x03, 0x01,
-      0x07, 0x06, 0x07, 0x11, 0x0a, 0x50, 0x0f, 0x12, 0x07, 0x55, 0x07, 0x03,
-      0x04, 0x1c, 0x0a, 0x09, 0x03, 0x08, 0x03, 0x07, 0x03, 0x02, 0x03, 0x03,
-      0x03, 0x0c, 0x04, 0x05, 0x03, 0x0b, 0x06, 0x01, 0x0e, 0x15, 0x05, 0x3a,
-      0x03, 0x11, 0x07, 0x06, 0x05, 0x10, 0x07, 0x57, 0x07, 0x02, 0x07, 0x15,
-      0x0d, 0x50, 0x04, 0x43, 0x03, 0x2d, 0x03, 0x01, 0x04, 0x11, 0x06, 0x0f,
-      0x0c, 0x3a, 0x04, 0x1d, 0x25, 0x5f, 0x20, 0x6d, 0x04, 0x6a, 0x25, 0x80,
-      0xc8, 0x05, 0x82, 0xb0, 0x03, 0x1a, 0x06, 0x82, 0xfd, 0x03, 0x59, 0x07,
-      0x15, 0x0b, 0x17, 0x09, 0x14, 0x0c, 0x14, 0x0c, 0x6a, 0x06, 0x0a, 0x06,
-      0x1a, 0x06, 0x59, 0x07, 0x2b, 0x05, 0x46, 0x0a, 0x2c, 0x04, 0x0c, 0x04,
-      0x01, 0x03, 0x31, 0x0b, 0x2c, 0x04, 0x1a, 0x06, 0x0b, 0x03, 0x80, 0xac,
-      0x06, 0x0a, 0x06, 0x21, 0x3f, 0x4c, 0x04, 0x2d, 0x03, 0x74, 0x08, 0x3c,
-      0x03, 0x0f, 0x03, 0x3c, 0x07, 0x38, 0x08, 0x2b, 0x05, 0x82, 0xff, 0x11,
-      0x18, 0x08, 0x2f, 0x11, 0x2d, 0x03, 0x20, 0x10, 0x21, 0x0f, 0x80, 0x8c,
-      0x04, 0x82, 0x97, 0x19, 0x0b, 0x15, 0x88, 0x94, 0x05, 0x2f, 0x05, 0x3b,
-      0x07, 0x02, 0x0e, 0x18, 0x09, 0x80, 0xb3, 0x2d, 0x74, 0x0c, 0x80, 0xd6,
-      0x1a, 0x0c, 0x05, 0x80, 0xff, 0x05, 0x80, 0xdf, 0x0c, 0xee, 0x0d, 0x03,
-      0x84, 0x8d, 0x03, 0x37, 0x09, 0x81, 0x5c, 0x14, 0x80, 0xb8, 0x08, 0x80,
-      0xcb, 0x2a, 0x38, 0x03, 0x0a, 0x06, 0x38, 0x08, 0x46, 0x08, 0x0c, 0x06,
-      0x74, 0x0b, 0x1e, 0x03, 0x5a, 0x04, 0x59, 0x09, 0x80, 0x83, 0x18, 0x1c,
-      0x0a, 0x16, 0x09, 0x4c, 0x04, 0x80, 0x8a, 0x06, 0xab, 0xa4, 0x0c, 0x17,
-      0x04, 0x31, 0xa1, 0x04, 0x81, 0xda, 0x26, 0x07, 0x0c, 0x05, 0x05, 0x80,
-      0xa5, 0x11, 0x81, 0x6d, 0x10, 0x78, 0x28, 0x2a, 0x06, 0x4c, 0x04, 0x80,
-      0x8d, 0x04, 0x80, 0xbe, 0x03, 0x1b, 0x03, 0x0f, 0x0d,
-  };
-  static constexpr unsigned char normal1[] = {
-      0x5e, 0x22, 0x7b, 0x05, 0x03, 0x04, 0x2d, 0x03, 0x66, 0x03, 0x01, 0x2f,
-      0x2e, 0x80, 0x82, 0x1d, 0x03, 0x31, 0x0f, 0x1c, 0x04, 0x24, 0x09, 0x1e,
-      0x05, 0x2b, 0x05, 0x44, 0x04, 0x0e, 0x2a, 0x80, 0xaa, 0x06, 0x24, 0x04,
-      0x24, 0x04, 0x28, 0x08, 0x34, 0x0b, 0x01, 0x80, 0x90, 0x81, 0x37, 0x09,
-      0x16, 0x0a, 0x08, 0x80, 0x98, 0x39, 0x03, 0x63, 0x08, 0x09, 0x30, 0x16,
-      0x05, 0x21, 0x03, 0x1b, 0x05, 0x01, 0x40, 0x38, 0x04, 0x4b, 0x05, 0x2f,
-      0x04, 0x0a, 0x07, 0x09, 0x07, 0x40, 0x20, 0x27, 0x04, 0x0c, 0x09, 0x36,
-      0x03, 0x3a, 0x05, 0x1a, 0x07, 0x04, 0x0c, 0x07, 0x50, 0x49, 0x37, 0x33,
-      0x0d, 0x33, 0x07, 0x2e, 0x08, 0x0a, 0x81, 0x26, 0x52, 0x4e, 0x28, 0x08,
-      0x2a, 0x56, 0x1c, 0x14, 0x17, 0x09, 0x4e, 0x04, 0x1e, 0x0f, 0x43, 0x0e,
-      0x19, 0x07, 0x0a, 0x06, 0x48, 0x08, 0x27, 0x09, 0x75, 0x0b, 0x3f, 0x41,
-      0x2a, 0x06, 0x3b, 0x05, 0x0a, 0x06, 0x51, 0x06, 0x01, 0x05, 0x10, 0x03,
-      0x05, 0x80, 0x8b, 0x62, 0x1e, 0x48, 0x08, 0x0a, 0x80, 0xa6, 0x5e, 0x22,
-      0x45, 0x0b, 0x0a, 0x06, 0x0d, 0x13, 0x39, 0x07, 0x0a, 0x36, 0x2c, 0x04,
-      0x10, 0x80, 0xc0, 0x3c, 0x64, 0x53, 0x0c, 0x48, 0x09, 0x0a, 0x46, 0x45,
-      0x1b, 0x48, 0x08, 0x53, 0x1d, 0x39, 0x81, 0x07, 0x46, 0x0a, 0x1d, 0x03,
-      0x47, 0x49, 0x37, 0x03, 0x0e, 0x08, 0x0a, 0x06, 0x39, 0x07, 0x0a, 0x81,
-      0x36, 0x19, 0x80, 0xb7, 0x01, 0x0f, 0x32, 0x0d, 0x83, 0x9b, 0x66, 0x75,
-      0x0b, 0x80, 0xc4, 0x8a, 0xbc, 0x84, 0x2f, 0x8f, 0xd1, 0x82, 0x47, 0xa1,
-      0xb9, 0x82, 0x39, 0x07, 0x2a, 0x04, 0x02, 0x60, 0x26, 0x0a, 0x46, 0x0a,
-      0x28, 0x05, 0x13, 0x82, 0xb0, 0x5b, 0x65, 0x4b, 0x04, 0x39, 0x07, 0x11,
-      0x40, 0x05, 0x0b, 0x02, 0x0e, 0x97, 0xf8, 0x08, 0x84, 0xd6, 0x2a, 0x09,
-      0xa2, 0xf7, 0x81, 0x1f, 0x31, 0x03, 0x11, 0x04, 0x08, 0x81, 0x8c, 0x89,
-      0x04, 0x6b, 0x05, 0x0d, 0x03, 0x09, 0x07, 0x10, 0x93, 0x60, 0x80, 0xf6,
-      0x0a, 0x73, 0x08, 0x6e, 0x17, 0x46, 0x80, 0x9a, 0x14, 0x0c, 0x57, 0x09,
-      0x19, 0x80, 0x87, 0x81, 0x47, 0x03, 0x85, 0x42, 0x0f, 0x15, 0x85, 0x50,
-      0x2b, 0x80, 0xd5, 0x2d, 0x03, 0x1a, 0x04, 0x02, 0x81, 0x70, 0x3a, 0x05,
-      0x01, 0x85, 0x00, 0x80, 0xd7, 0x29, 0x4c, 0x04, 0x0a, 0x04, 0x02, 0x83,
-      0x11, 0x44, 0x4c, 0x3d, 0x80, 0xc2, 0x3c, 0x06, 0x01, 0x04, 0x55, 0x05,
-      0x1b, 0x34, 0x02, 0x81, 0x0e, 0x2c, 0x04, 0x64, 0x0c, 0x56, 0x0a, 0x80,
-      0xae, 0x38, 0x1d, 0x0d, 0x2c, 0x04, 0x09, 0x07, 0x02, 0x0e, 0x06, 0x80,
-      0x9a, 0x83, 0xd8, 0x08, 0x0d, 0x03, 0x0d, 0x03, 0x74, 0x0c, 0x59, 0x07,
-      0x0c, 0x14, 0x0c, 0x04, 0x38, 0x08, 0x0a, 0x06, 0x28, 0x08, 0x22, 0x4e,
-      0x81, 0x54, 0x0c, 0x15, 0x03, 0x03, 0x05, 0x07, 0x09, 0x19, 0x07, 0x07,
-      0x09, 0x03, 0x0d, 0x07, 0x29, 0x80, 0xcb, 0x25, 0x0a, 0x84, 0x06,
-  };
-  auto lower = static_cast<uint16_t>(cp);
-  if (cp < 0x10000) {
-    return is_printable(lower, singletons0,
-                        sizeof(singletons0) / sizeof(*singletons0),
-                        singletons0_lower, normal0, sizeof(normal0));
-  }
-  if (cp < 0x20000) {
-    return is_printable(lower, singletons1,
-                        sizeof(singletons1) / sizeof(*singletons1),
-                        singletons1_lower, normal1, sizeof(normal1));
-  }
-  if (0x2a6de <= cp && cp < 0x2a700) return false;
-  if (0x2b735 <= cp && cp < 0x2b740) return false;
-  if (0x2b81e <= cp && cp < 0x2b820) return false;
-  if (0x2cea2 <= cp && cp < 0x2ceb0) return false;
-  if (0x2ebe1 <= cp && cp < 0x2f800) return false;
-  if (0x2fa1e <= cp && cp < 0x30000) return false;
-  if (0x3134b <= cp && cp < 0xe0100) return false;
-  if (0xe01f0 <= cp && cp < 0x110000) return false;
-  return cp < 0x110000;
-}
-
-}  // namespace detail
-
-FMT_END_NAMESPACE
-
-#endif  // FMT_FORMAT_INL_H_
diff --git a/Externals/fmt/include/fmt/format.h b/Externals/fmt/include/fmt/format.h
deleted file mode 100755
index fef5a5dbf965..000000000000
--- a/Externals/fmt/include/fmt/format.h
+++ /dev/null
@@ -1,4217 +0,0 @@
-/*
-  Formatting library for C++
-
-  Copyright (c) 2012 - present, Victor Zverovich
-
-  Permission is hereby granted, free of charge, to any person obtaining
-  a copy of this software and associated documentation files (the
-  "Software"), to deal in the Software without restriction, including
-  without limitation the rights to use, copy, modify, merge, publish,
-  distribute, sublicense, and/or sell copies of the Software, and to
-  permit persons to whom the Software is furnished to do so, subject to
-  the following conditions:
-
-  The above copyright notice and this permission notice shall be
-  included in all copies or substantial portions of the Software.
-
-  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
-  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
-  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
-  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
-  LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
-  OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
-  WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
-
-  --- Optional exception to the license ---
-
-  As an exception, if, as a result of your compiling your source code, portions
-  of this Software are embedded into a machine-executable object form of such
-  source code, you may redistribute such embedded portions in such object form
-  without including the above copyright and permission notices.
- */
-
-#ifndef FMT_FORMAT_H_
-#define FMT_FORMAT_H_
-
-#include <cmath>         // std::signbit
-#include <cstdint>       // uint32_t
-#include <cstring>       // std::memcpy
-#include <limits>        // std::numeric_limits
-#include <memory>        // std::uninitialized_copy
-#include <stdexcept>     // std::runtime_error
-#include <system_error>  // std::system_error
-
-#ifdef __cpp_lib_bit_cast
-#  include <bit>  // std::bitcast
-#endif
-
-#include "core.h"
-
-#if FMT_GCC_VERSION
-#  define FMT_GCC_VISIBILITY_HIDDEN __attribute__((visibility("hidden")))
-#else
-#  define FMT_GCC_VISIBILITY_HIDDEN
-#endif
-
-#ifdef __NVCC__
-#  define FMT_CUDA_VERSION (__CUDACC_VER_MAJOR__ * 100 + __CUDACC_VER_MINOR__)
-#else
-#  define FMT_CUDA_VERSION 0
-#endif
-
-#ifdef __has_builtin
-#  define FMT_HAS_BUILTIN(x) __has_builtin(x)
-#else
-#  define FMT_HAS_BUILTIN(x) 0
-#endif
-
-#if FMT_GCC_VERSION || FMT_CLANG_VERSION
-#  define FMT_NOINLINE __attribute__((noinline))
-#else
-#  define FMT_NOINLINE
-#endif
-
-#if FMT_MSC_VERSION
-#  define FMT_MSC_DEFAULT = default
-#else
-#  define FMT_MSC_DEFAULT
-#endif
-
-#ifndef FMT_THROW
-#  if FMT_EXCEPTIONS
-#    if FMT_MSC_VERSION || defined(__NVCC__)
-FMT_BEGIN_NAMESPACE
-namespace detail {
-template <typename Exception> inline void do_throw(const Exception& x) {
-  // Silence unreachable code warnings in MSVC and NVCC because these
-  // are nearly impossible to fix in a generic code.
-  volatile bool b = true;
-  if (b) throw x;
-}
-}  // namespace detail
-FMT_END_NAMESPACE
-#      define FMT_THROW(x) detail::do_throw(x)
-#    else
-#      define FMT_THROW(x) throw x
-#    endif
-#  else
-#    define FMT_THROW(x)               \
-      do {                             \
-        FMT_ASSERT(false, (x).what()); \
-      } while (false)
-#  endif
-#endif
-
-#if FMT_EXCEPTIONS
-#  define FMT_TRY try
-#  define FMT_CATCH(x) catch (x)
-#else
-#  define FMT_TRY if (true)
-#  define FMT_CATCH(x) if (false)
-#endif
-
-#ifndef FMT_MAYBE_UNUSED
-#  if FMT_HAS_CPP17_ATTRIBUTE(maybe_unused)
-#    define FMT_MAYBE_UNUSED [[maybe_unused]]
-#  else
-#    define FMT_MAYBE_UNUSED
-#  endif
-#endif
-
-#ifndef FMT_USE_USER_DEFINED_LITERALS
-// EDG based compilers (Intel, NVIDIA, Elbrus, etc), GCC and MSVC support UDLs.
-#  if (FMT_HAS_FEATURE(cxx_user_literals) || FMT_GCC_VERSION >= 407 || \
-       FMT_MSC_VERSION >= 1900) &&                                     \
-      (!defined(__EDG_VERSION__) || __EDG_VERSION__ >= /* UDL feature */ 480)
-#    define FMT_USE_USER_DEFINED_LITERALS 1
-#  else
-#    define FMT_USE_USER_DEFINED_LITERALS 0
-#  endif
-#endif
-
-// Defining FMT_REDUCE_INT_INSTANTIATIONS to 1, will reduce the number of
-// integer formatter template instantiations to just one by only using the
-// largest integer type. This results in a reduction in binary size but will
-// cause a decrease in integer formatting performance.
-#if !defined(FMT_REDUCE_INT_INSTANTIATIONS)
-#  define FMT_REDUCE_INT_INSTANTIATIONS 0
-#endif
-
-// __builtin_clz is broken in clang with Microsoft CodeGen:
-// https://github.com/fmtlib/fmt/issues/519.
-#if !FMT_MSC_VERSION
-#  if FMT_HAS_BUILTIN(__builtin_clz) || FMT_GCC_VERSION || FMT_ICC_VERSION
-#    define FMT_BUILTIN_CLZ(n) __builtin_clz(n)
-#  endif
-#  if FMT_HAS_BUILTIN(__builtin_clzll) || FMT_GCC_VERSION || FMT_ICC_VERSION
-#    define FMT_BUILTIN_CLZLL(n) __builtin_clzll(n)
-#  endif
-#endif
-
-// __builtin_ctz is broken in Intel Compiler Classic on Windows:
-// https://github.com/fmtlib/fmt/issues/2510.
-#ifndef __ICL
-#  if FMT_HAS_BUILTIN(__builtin_ctz) || FMT_GCC_VERSION || FMT_ICC_VERSION || \
-      defined(__NVCOMPILER)
-#    define FMT_BUILTIN_CTZ(n) __builtin_ctz(n)
-#  endif
-#  if FMT_HAS_BUILTIN(__builtin_ctzll) || FMT_GCC_VERSION || \
-      FMT_ICC_VERSION || defined(__NVCOMPILER)
-#    define FMT_BUILTIN_CTZLL(n) __builtin_ctzll(n)
-#  endif
-#endif
-
-#if FMT_MSC_VERSION
-#  include <intrin.h>  // _BitScanReverse[64], _BitScanForward[64], _umul128
-#endif
-
-// Some compilers masquerade as both MSVC and GCC-likes or otherwise support
-// __builtin_clz and __builtin_clzll, so only define FMT_BUILTIN_CLZ using the
-// MSVC intrinsics if the clz and clzll builtins are not available.
-#if FMT_MSC_VERSION && !defined(FMT_BUILTIN_CLZLL) && \
-    !defined(FMT_BUILTIN_CTZLL)
-FMT_BEGIN_NAMESPACE
-namespace detail {
-// Avoid Clang with Microsoft CodeGen's -Wunknown-pragmas warning.
-#  if !defined(__clang__)
-#    pragma intrinsic(_BitScanForward)
-#    pragma intrinsic(_BitScanReverse)
-#    if defined(_WIN64)
-#      pragma intrinsic(_BitScanForward64)
-#      pragma intrinsic(_BitScanReverse64)
-#    endif
-#  endif
-
-inline auto clz(uint32_t x) -> int {
-  unsigned long r = 0;
-  _BitScanReverse(&r, x);
-  FMT_ASSERT(x != 0, "");
-  // Static analysis complains about using uninitialized data
-  // "r", but the only way that can happen is if "x" is 0,
-  // which the callers guarantee to not happen.
-  FMT_MSC_WARNING(suppress : 6102)
-  return 31 ^ static_cast<int>(r);
-}
-#  define FMT_BUILTIN_CLZ(n) detail::clz(n)
-
-inline auto clzll(uint64_t x) -> int {
-  unsigned long r = 0;
-#  ifdef _WIN64
-  _BitScanReverse64(&r, x);
-#  else
-  // Scan the high 32 bits.
-  if (_BitScanReverse(&r, static_cast<uint32_t>(x >> 32))) return 63 ^ (r + 32);
-  // Scan the low 32 bits.
-  _BitScanReverse(&r, static_cast<uint32_t>(x));
-#  endif
-  FMT_ASSERT(x != 0, "");
-  FMT_MSC_WARNING(suppress : 6102)  // Suppress a bogus static analysis warning.
-  return 63 ^ static_cast<int>(r);
-}
-#  define FMT_BUILTIN_CLZLL(n) detail::clzll(n)
-
-inline auto ctz(uint32_t x) -> int {
-  unsigned long r = 0;
-  _BitScanForward(&r, x);
-  FMT_ASSERT(x != 0, "");
-  FMT_MSC_WARNING(suppress : 6102)  // Suppress a bogus static analysis warning.
-  return static_cast<int>(r);
-}
-#  define FMT_BUILTIN_CTZ(n) detail::ctz(n)
-
-inline auto ctzll(uint64_t x) -> int {
-  unsigned long r = 0;
-  FMT_ASSERT(x != 0, "");
-  FMT_MSC_WARNING(suppress : 6102)  // Suppress a bogus static analysis warning.
-#  ifdef _WIN64
-  _BitScanForward64(&r, x);
-#  else
-  // Scan the low 32 bits.
-  if (_BitScanForward(&r, static_cast<uint32_t>(x))) return static_cast<int>(r);
-  // Scan the high 32 bits.
-  _BitScanForward(&r, static_cast<uint32_t>(x >> 32));
-  r += 32;
-#  endif
-  return static_cast<int>(r);
-}
-#  define FMT_BUILTIN_CTZLL(n) detail::ctzll(n)
-}  // namespace detail
-FMT_END_NAMESPACE
-#endif
-
-FMT_BEGIN_NAMESPACE
-namespace detail {
-
-FMT_CONSTEXPR inline void abort_fuzzing_if(bool condition) {
-  ignore_unused(condition);
-#ifdef FMT_FUZZ
-  if (condition) throw std::runtime_error("fuzzing limit reached");
-#endif
-}
-
-template <typename CharT, CharT... C> struct string_literal {
-  static constexpr CharT value[sizeof...(C)] = {C...};
-  constexpr operator basic_string_view<CharT>() const {
-    return {value, sizeof...(C)};
-  }
-};
-
-#if FMT_CPLUSPLUS < 201703L
-template <typename CharT, CharT... C>
-constexpr CharT string_literal<CharT, C...>::value[sizeof...(C)];
-#endif
-
-template <typename Streambuf> class formatbuf : public Streambuf {
- private:
-  using char_type = typename Streambuf::char_type;
-  using streamsize = decltype(std::declval<Streambuf>().sputn(nullptr, 0));
-  using int_type = typename Streambuf::int_type;
-  using traits_type = typename Streambuf::traits_type;
-
-  buffer<char_type>& buffer_;
-
- public:
-  explicit formatbuf(buffer<char_type>& buf) : buffer_(buf) {}
-
- protected:
-  // The put area is always empty. This makes the implementation simpler and has
-  // the advantage that the streambuf and the buffer are always in sync and
-  // sputc never writes into uninitialized memory. A disadvantage is that each
-  // call to sputc always results in a (virtual) call to overflow. There is no
-  // disadvantage here for sputn since this always results in a call to xsputn.
-
-  auto overflow(int_type ch) -> int_type override {
-    if (!traits_type::eq_int_type(ch, traits_type::eof()))
-      buffer_.push_back(static_cast<char_type>(ch));
-    return ch;
-  }
-
-  auto xsputn(const char_type* s, streamsize count) -> streamsize override {
-    buffer_.append(s, s + count);
-    return count;
-  }
-};
-
-// Implementation of std::bit_cast for pre-C++20.
-template <typename To, typename From, FMT_ENABLE_IF(sizeof(To) == sizeof(From))>
-FMT_CONSTEXPR20 auto bit_cast(const From& from) -> To {
-#ifdef __cpp_lib_bit_cast
-  if (is_constant_evaluated()) return std::bit_cast<To>(from);
-#endif
-  auto to = To();
-  // The cast suppresses a bogus -Wclass-memaccess on GCC.
-  std::memcpy(static_cast<void*>(&to), &from, sizeof(to));
-  return to;
-}
-
-inline auto is_big_endian() -> bool {
-#ifdef _WIN32
-  return false;
-#elif defined(__BIG_ENDIAN__)
-  return true;
-#elif defined(__BYTE_ORDER__) && defined(__ORDER_BIG_ENDIAN__)
-  return __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__;
-#else
-  struct bytes {
-    char data[sizeof(int)];
-  };
-  return bit_cast<bytes>(1).data[0] == 0;
-#endif
-}
-
-class uint128_fallback {
- private:
-  uint64_t lo_, hi_;
-
-  friend uint128_fallback umul128(uint64_t x, uint64_t y) noexcept;
-
- public:
-  constexpr uint128_fallback(uint64_t hi, uint64_t lo) : lo_(lo), hi_(hi) {}
-  constexpr uint128_fallback(uint64_t value = 0) : lo_(value), hi_(0) {}
-
-  constexpr uint64_t high() const noexcept { return hi_; }
-  constexpr uint64_t low() const noexcept { return lo_; }
-
-  template <typename T, FMT_ENABLE_IF(std::is_integral<T>::value)>
-  constexpr explicit operator T() const {
-    return static_cast<T>(lo_);
-  }
-
-  friend constexpr auto operator==(const uint128_fallback& lhs,
-                                   const uint128_fallback& rhs) -> bool {
-    return lhs.hi_ == rhs.hi_ && lhs.lo_ == rhs.lo_;
-  }
-  friend constexpr auto operator!=(const uint128_fallback& lhs,
-                                   const uint128_fallback& rhs) -> bool {
-    return !(lhs == rhs);
-  }
-  friend constexpr auto operator>(const uint128_fallback& lhs,
-                                  const uint128_fallback& rhs) -> bool {
-    return lhs.hi_ != rhs.hi_ ? lhs.hi_ > rhs.hi_ : lhs.lo_ > rhs.lo_;
-  }
-  friend constexpr auto operator|(const uint128_fallback& lhs,
-                                  const uint128_fallback& rhs)
-      -> uint128_fallback {
-    return {lhs.hi_ | rhs.hi_, lhs.lo_ | rhs.lo_};
-  }
-  friend constexpr auto operator&(const uint128_fallback& lhs,
-                                  const uint128_fallback& rhs)
-      -> uint128_fallback {
-    return {lhs.hi_ & rhs.hi_, lhs.lo_ & rhs.lo_};
-  }
-  friend auto operator+(const uint128_fallback& lhs,
-                        const uint128_fallback& rhs) -> uint128_fallback {
-    auto result = uint128_fallback(lhs);
-    result += rhs;
-    return result;
-  }
-  friend auto operator*(const uint128_fallback& lhs, uint32_t rhs)
-      -> uint128_fallback {
-    FMT_ASSERT(lhs.hi_ == 0, "");
-    uint64_t hi = (lhs.lo_ >> 32) * rhs;
-    uint64_t lo = (lhs.lo_ & ~uint32_t()) * rhs;
-    uint64_t new_lo = (hi << 32) + lo;
-    return {(hi >> 32) + (new_lo < lo ? 1 : 0), new_lo};
-  }
-  friend auto operator-(const uint128_fallback& lhs, uint64_t rhs)
-      -> uint128_fallback {
-    return {lhs.hi_ - (lhs.lo_ < rhs ? 1 : 0), lhs.lo_ - rhs};
-  }
-  FMT_CONSTEXPR auto operator>>(int shift) const -> uint128_fallback {
-    if (shift == 64) return {0, hi_};
-    if (shift > 64) return uint128_fallback(0, hi_) >> (shift - 64);
-    return {hi_ >> shift, (hi_ << (64 - shift)) | (lo_ >> shift)};
-  }
-  FMT_CONSTEXPR auto operator<<(int shift) const -> uint128_fallback {
-    if (shift == 64) return {lo_, 0};
-    if (shift > 64) return uint128_fallback(lo_, 0) << (shift - 64);
-    return {hi_ << shift | (lo_ >> (64 - shift)), (lo_ << shift)};
-  }
-  FMT_CONSTEXPR auto operator>>=(int shift) -> uint128_fallback& {
-    return *this = *this >> shift;
-  }
-  FMT_CONSTEXPR void operator+=(uint128_fallback n) {
-    uint64_t new_lo = lo_ + n.lo_;
-    uint64_t new_hi = hi_ + n.hi_ + (new_lo < lo_ ? 1 : 0);
-    FMT_ASSERT(new_hi >= hi_, "");
-    lo_ = new_lo;
-    hi_ = new_hi;
-  }
-
-  FMT_CONSTEXPR20 uint128_fallback& operator+=(uint64_t n) noexcept {
-    if (is_constant_evaluated()) {
-      lo_ += n;
-      hi_ += (lo_ < n ? 1 : 0);
-      return *this;
-    }
-#if FMT_HAS_BUILTIN(__builtin_addcll) && !defined(__ibmxl__)
-    unsigned long long carry;
-    lo_ = __builtin_addcll(lo_, n, 0, &carry);
-    hi_ += carry;
-#elif FMT_HAS_BUILTIN(__builtin_ia32_addcarryx_u64) && !defined(__ibmxl__)
-    unsigned long long result;
-    auto carry = __builtin_ia32_addcarryx_u64(0, lo_, n, &result);
-    lo_ = result;
-    hi_ += carry;
-#elif defined(_MSC_VER) && defined(_M_X64)
-    auto carry = _addcarry_u64(0, lo_, n, &lo_);
-    _addcarry_u64(carry, hi_, 0, &hi_);
-#else
-    lo_ += n;
-    hi_ += (lo_ < n ? 1 : 0);
-#endif
-    return *this;
-  }
-};
-
-using uint128_t = conditional_t<FMT_USE_INT128, uint128_opt, uint128_fallback>;
-
-#ifdef UINTPTR_MAX
-using uintptr_t = ::uintptr_t;
-#else
-using uintptr_t = uint128_t;
-#endif
-
-// Returns the largest possible value for type T. Same as
-// std::numeric_limits<T>::max() but shorter and not affected by the max macro.
-template <typename T> constexpr auto max_value() -> T {
-  return (std::numeric_limits<T>::max)();
-}
-template <typename T> constexpr auto num_bits() -> int {
-  return std::numeric_limits<T>::digits;
-}
-// std::numeric_limits<T>::digits may return 0 for 128-bit ints.
-template <> constexpr auto num_bits<int128_opt>() -> int { return 128; }
-template <> constexpr auto num_bits<uint128_t>() -> int { return 128; }
-
-// A heterogeneous bit_cast used for converting 96-bit long double to uint128_t
-// and 128-bit pointers to uint128_fallback.
-template <typename To, typename From, FMT_ENABLE_IF(sizeof(To) > sizeof(From))>
-inline auto bit_cast(const From& from) -> To {
-  constexpr auto size = static_cast<int>(sizeof(From) / sizeof(unsigned));
-  struct data_t {
-    unsigned value[static_cast<unsigned>(size)];
-  } data = bit_cast<data_t>(from);
-  auto result = To();
-  if (const_check(is_big_endian())) {
-    for (int i = 0; i < size; ++i)
-      result = (result << num_bits<unsigned>()) | data.value[i];
-  } else {
-    for (int i = size - 1; i >= 0; --i)
-      result = (result << num_bits<unsigned>()) | data.value[i];
-  }
-  return result;
-}
-
-FMT_INLINE void assume(bool condition) {
-  (void)condition;
-#if FMT_HAS_BUILTIN(__builtin_assume) && !FMT_ICC_VERSION
-  __builtin_assume(condition);
-#endif
-}
-
-// An approximation of iterator_t for pre-C++20 systems.
-template <typename T>
-using iterator_t = decltype(std::begin(std::declval<T&>()));
-template <typename T> using sentinel_t = decltype(std::end(std::declval<T&>()));
-
-// A workaround for std::string not having mutable data() until C++17.
-template <typename Char>
-inline auto get_data(std::basic_string<Char>& s) -> Char* {
-  return &s[0];
-}
-template <typename Container>
-inline auto get_data(Container& c) -> typename Container::value_type* {
-  return c.data();
-}
-
-#if defined(_SECURE_SCL) && _SECURE_SCL
-// Make a checked iterator to avoid MSVC warnings.
-template <typename T> using checked_ptr = stdext::checked_array_iterator<T*>;
-template <typename T>
-constexpr auto make_checked(T* p, size_t size) -> checked_ptr<T> {
-  return {p, size};
-}
-#else
-template <typename T> using checked_ptr = T*;
-template <typename T> constexpr auto make_checked(T* p, size_t) -> T* {
-  return p;
-}
-#endif
-
-// Attempts to reserve space for n extra characters in the output range.
-// Returns a pointer to the reserved range or a reference to it.
-template <typename Container, FMT_ENABLE_IF(is_contiguous<Container>::value)>
-#if FMT_CLANG_VERSION >= 307 && !FMT_ICC_VERSION
-__attribute__((no_sanitize("undefined")))
-#endif
-inline auto
-reserve(std::back_insert_iterator<Container> it, size_t n)
-    -> checked_ptr<typename Container::value_type> {
-  Container& c = get_container(it);
-  size_t size = c.size();
-  c.resize(size + n);
-  return make_checked(get_data(c) + size, n);
-}
-
-template <typename T>
-inline auto reserve(buffer_appender<T> it, size_t n) -> buffer_appender<T> {
-  buffer<T>& buf = get_container(it);
-  buf.try_reserve(buf.size() + n);
-  return it;
-}
-
-template <typename Iterator>
-constexpr auto reserve(Iterator& it, size_t) -> Iterator& {
-  return it;
-}
-
-template <typename OutputIt>
-using reserve_iterator =
-    remove_reference_t<decltype(reserve(std::declval<OutputIt&>(), 0))>;
-
-template <typename T, typename OutputIt>
-constexpr auto to_pointer(OutputIt, size_t) -> T* {
-  return nullptr;
-}
-template <typename T> auto to_pointer(buffer_appender<T> it, size_t n) -> T* {
-  buffer<T>& buf = get_container(it);
-  auto size = buf.size();
-  if (buf.capacity() < size + n) return nullptr;
-  buf.try_resize(size + n);
-  return buf.data() + size;
-}
-
-template <typename Container, FMT_ENABLE_IF(is_contiguous<Container>::value)>
-inline auto base_iterator(std::back_insert_iterator<Container>& it,
-                          checked_ptr<typename Container::value_type>)
-    -> std::back_insert_iterator<Container> {
-  return it;
-}
-
-template <typename Iterator>
-constexpr auto base_iterator(Iterator, Iterator it) -> Iterator {
-  return it;
-}
-
-// <algorithm> is spectacularly slow to compile in C++20 so use a simple fill_n
-// instead (#1998).
-template <typename OutputIt, typename Size, typename T>
-FMT_CONSTEXPR auto fill_n(OutputIt out, Size count, const T& value)
-    -> OutputIt {
-  for (Size i = 0; i < count; ++i) *out++ = value;
-  return out;
-}
-template <typename T, typename Size>
-FMT_CONSTEXPR20 auto fill_n(T* out, Size count, char value) -> T* {
-  if (is_constant_evaluated()) {
-    return fill_n<T*, Size, T>(out, count, value);
-  }
-  std::memset(out, value, to_unsigned(count));
-  return out + count;
-}
-
-#ifdef __cpp_char8_t
-using char8_type = char8_t;
-#else
-enum char8_type : unsigned char {};
-#endif
-
-template <typename OutChar, typename InputIt, typename OutputIt>
-FMT_CONSTEXPR FMT_NOINLINE auto copy_str_noinline(InputIt begin, InputIt end,
-                                                  OutputIt out) -> OutputIt {
-  return copy_str<OutChar>(begin, end, out);
-}
-
-// A public domain branchless UTF-8 decoder by Christopher Wellons:
-// https://github.com/skeeto/branchless-utf8
-/* Decode the next character, c, from s, reporting errors in e.
- *
- * Since this is a branchless decoder, four bytes will be read from the
- * buffer regardless of the actual length of the next character. This
- * means the buffer _must_ have at least three bytes of zero padding
- * following the end of the data stream.
- *
- * Errors are reported in e, which will be non-zero if the parsed
- * character was somehow invalid: invalid byte sequence, non-canonical
- * encoding, or a surrogate half.
- *
- * The function returns a pointer to the next character. When an error
- * occurs, this pointer will be a guess that depends on the particular
- * error, but it will always advance at least one byte.
- */
-FMT_CONSTEXPR inline auto utf8_decode(const char* s, uint32_t* c, int* e)
-    -> const char* {
-  constexpr const int masks[] = {0x00, 0x7f, 0x1f, 0x0f, 0x07};
-  constexpr const uint32_t mins[] = {4194304, 0, 128, 2048, 65536};
-  constexpr const int shiftc[] = {0, 18, 12, 6, 0};
-  constexpr const int shifte[] = {0, 6, 4, 2, 0};
-
-  int len = code_point_length_impl(*s);
-  // Compute the pointer to the next character early so that the next
-  // iteration can start working on the next character. Neither Clang
-  // nor GCC figure out this reordering on their own.
-  const char* next = s + len + !len;
-
-  using uchar = unsigned char;
-
-  // Assume a four-byte character and load four bytes. Unused bits are
-  // shifted out.
-  *c = uint32_t(uchar(s[0]) & masks[len]) << 18;
-  *c |= uint32_t(uchar(s[1]) & 0x3f) << 12;
-  *c |= uint32_t(uchar(s[2]) & 0x3f) << 6;
-  *c |= uint32_t(uchar(s[3]) & 0x3f) << 0;
-  *c >>= shiftc[len];
-
-  // Accumulate the various error conditions.
-  *e = (*c < mins[len]) << 6;       // non-canonical encoding
-  *e |= ((*c >> 11) == 0x1b) << 7;  // surrogate half?
-  *e |= (*c > 0x10FFFF) << 8;       // out of range?
-  *e |= (uchar(s[1]) & 0xc0) >> 2;
-  *e |= (uchar(s[2]) & 0xc0) >> 4;
-  *e |= uchar(s[3]) >> 6;
-  *e ^= 0x2a;  // top two bits of each tail byte correct?
-  *e >>= shifte[len];
-
-  return next;
-}
-
-constexpr uint32_t invalid_code_point = ~uint32_t();
-
-// Invokes f(cp, sv) for every code point cp in s with sv being the string view
-// corresponding to the code point. cp is invalid_code_point on error.
-template <typename F>
-FMT_CONSTEXPR void for_each_codepoint(string_view s, F f) {
-  auto decode = [f](const char* buf_ptr, const char* ptr) {
-    auto cp = uint32_t();
-    auto error = 0;
-    auto end = utf8_decode(buf_ptr, &cp, &error);
-    bool result = f(error ? invalid_code_point : cp,
-                    string_view(ptr, error ? 1 : to_unsigned(end - buf_ptr)));
-    return result ? (error ? buf_ptr + 1 : end) : nullptr;
-  };
-  auto p = s.data();
-  const size_t block_size = 4;  // utf8_decode always reads blocks of 4 chars.
-  if (s.size() >= block_size) {
-    for (auto end = p + s.size() - block_size + 1; p < end;) {
-      p = decode(p, p);
-      if (!p) return;
-    }
-  }
-  if (auto num_chars_left = s.data() + s.size() - p) {
-    char buf[2 * block_size - 1] = {};
-    copy_str<char>(p, p + num_chars_left, buf);
-    const char* buf_ptr = buf;
-    do {
-      auto end = decode(buf_ptr, p);
-      if (!end) return;
-      p += end - buf_ptr;
-      buf_ptr = end;
-    } while (buf_ptr - buf < num_chars_left);
-  }
-}
-
-template <typename Char>
-inline auto compute_width(basic_string_view<Char> s) -> size_t {
-  return s.size();
-}
-
-// Computes approximate display width of a UTF-8 string.
-FMT_CONSTEXPR inline size_t compute_width(string_view s) {
-  size_t num_code_points = 0;
-  // It is not a lambda for compatibility with C++14.
-  struct count_code_points {
-    size_t* count;
-    FMT_CONSTEXPR auto operator()(uint32_t cp, string_view) const -> bool {
-      *count += detail::to_unsigned(
-          1 +
-          (cp >= 0x1100 &&
-           (cp <= 0x115f ||  // Hangul Jamo init. consonants
-            cp == 0x2329 ||  // LEFT-POINTING ANGLE BRACKET
-            cp == 0x232a ||  // RIGHT-POINTING ANGLE BRACKET
-            // CJK ... Yi except IDEOGRAPHIC HALF FILL SPACE:
-            (cp >= 0x2e80 && cp <= 0xa4cf && cp != 0x303f) ||
-            (cp >= 0xac00 && cp <= 0xd7a3) ||    // Hangul Syllables
-            (cp >= 0xf900 && cp <= 0xfaff) ||    // CJK Compatibility Ideographs
-            (cp >= 0xfe10 && cp <= 0xfe19) ||    // Vertical Forms
-            (cp >= 0xfe30 && cp <= 0xfe6f) ||    // CJK Compatibility Forms
-            (cp >= 0xff00 && cp <= 0xff60) ||    // Fullwidth Forms
-            (cp >= 0xffe0 && cp <= 0xffe6) ||    // Fullwidth Forms
-            (cp >= 0x20000 && cp <= 0x2fffd) ||  // CJK
-            (cp >= 0x30000 && cp <= 0x3fffd) ||
-            // Miscellaneous Symbols and Pictographs + Emoticons:
-            (cp >= 0x1f300 && cp <= 0x1f64f) ||
-            // Supplemental Symbols and Pictographs:
-            (cp >= 0x1f900 && cp <= 0x1f9ff))));
-      return true;
-    }
-  };
-  for_each_codepoint(s, count_code_points{&num_code_points});
-  return num_code_points;
-}
-
-inline auto compute_width(basic_string_view<char8_type> s) -> size_t {
-  return compute_width(
-      string_view(reinterpret_cast<const char*>(s.data()), s.size()));
-}
-
-template <typename Char>
-inline auto code_point_index(basic_string_view<Char> s, size_t n) -> size_t {
-  size_t size = s.size();
-  return n < size ? n : size;
-}
-
-// Calculates the index of the nth code point in a UTF-8 string.
-inline auto code_point_index(string_view s, size_t n) -> size_t {
-  const char* data = s.data();
-  size_t num_code_points = 0;
-  for (size_t i = 0, size = s.size(); i != size; ++i) {
-    if ((data[i] & 0xc0) != 0x80 && ++num_code_points > n) return i;
-  }
-  return s.size();
-}
-
-inline auto code_point_index(basic_string_view<char8_type> s, size_t n)
-    -> size_t {
-  return code_point_index(
-      string_view(reinterpret_cast<const char*>(s.data()), s.size()), n);
-}
-
-#ifndef FMT_USE_FLOAT128
-#  ifdef __SIZEOF_FLOAT128__
-#    define FMT_USE_FLOAT128 1
-#  else
-#    define FMT_USE_FLOAT128 0
-#  endif
-#endif
-#if FMT_USE_FLOAT128
-using float128 = __float128;
-#else
-using float128 = void;
-#endif
-template <typename T> using is_float128 = std::is_same<T, float128>;
-
-template <typename T>
-using is_floating_point =
-    bool_constant<std::is_floating_point<T>::value || is_float128<T>::value>;
-
-template <typename T, bool = std::is_floating_point<T>::value>
-struct is_fast_float : bool_constant<std::numeric_limits<T>::is_iec559 &&
-                                     sizeof(T) <= sizeof(double)> {};
-template <typename T> struct is_fast_float<T, false> : std::false_type {};
-
-template <typename T>
-using is_double_double = bool_constant<std::numeric_limits<T>::digits == 106>;
-
-#ifndef FMT_USE_FULL_CACHE_DRAGONBOX
-#  define FMT_USE_FULL_CACHE_DRAGONBOX 0
-#endif
-
-template <typename T>
-template <typename U>
-void buffer<T>::append(const U* begin, const U* end) {
-  while (begin != end) {
-    auto count = to_unsigned(end - begin);
-    try_reserve(size_ + count);
-    auto free_cap = capacity_ - size_;
-    if (free_cap < count) count = free_cap;
-    std::uninitialized_copy_n(begin, count, make_checked(ptr_ + size_, count));
-    size_ += count;
-    begin += count;
-  }
-}
-
-template <typename T, typename Enable = void>
-struct is_locale : std::false_type {};
-template <typename T>
-struct is_locale<T, void_t<decltype(T::classic())>> : std::true_type {};
-}  // namespace detail
-
-FMT_MODULE_EXPORT_BEGIN
-
-// The number of characters to store in the basic_memory_buffer object itself
-// to avoid dynamic memory allocation.
-enum { inline_buffer_size = 500 };
-
-/**
-  \rst
-  A dynamically growing memory buffer for trivially copyable/constructible types
-  with the first ``SIZE`` elements stored in the object itself.
-
-  You can use the ``memory_buffer`` type alias for ``char`` instead.
-
-  **Example**::
-
-     auto out = fmt::memory_buffer();
-     format_to(std::back_inserter(out), "The answer is {}.", 42);
-
-  This will append the following output to the ``out`` object:
-
-  .. code-block:: none
-
-     The answer is 42.
-
-  The output can be converted to an ``std::string`` with ``to_string(out)``.
-  \endrst
- */
-template <typename T, size_t SIZE = inline_buffer_size,
-          typename Allocator = std::allocator<T>>
-class basic_memory_buffer final : public detail::buffer<T> {
- private:
-  T store_[SIZE];
-
-  // Don't inherit from Allocator avoid generating type_info for it.
-  Allocator alloc_;
-
-  // Deallocate memory allocated by the buffer.
-  FMT_CONSTEXPR20 void deallocate() {
-    T* data = this->data();
-    if (data != store_) alloc_.deallocate(data, this->capacity());
-  }
-
- protected:
-  FMT_CONSTEXPR20 void grow(size_t size) override;
-
- public:
-  using value_type = T;
-  using const_reference = const T&;
-
-  FMT_CONSTEXPR20 explicit basic_memory_buffer(
-      const Allocator& alloc = Allocator())
-      : alloc_(alloc) {
-    this->set(store_, SIZE);
-    if (detail::is_constant_evaluated()) detail::fill_n(store_, SIZE, T());
-  }
-  FMT_CONSTEXPR20 ~basic_memory_buffer() { deallocate(); }
-
- private:
-  // Move data from other to this buffer.
-  FMT_CONSTEXPR20 void move(basic_memory_buffer& other) {
-    alloc_ = std::move(other.alloc_);
-    T* data = other.data();
-    size_t size = other.size(), capacity = other.capacity();
-    if (data == other.store_) {
-      this->set(store_, capacity);
-      detail::copy_str<T>(other.store_, other.store_ + size,
-                          detail::make_checked(store_, capacity));
-    } else {
-      this->set(data, capacity);
-      // Set pointer to the inline array so that delete is not called
-      // when deallocating.
-      other.set(other.store_, 0);
-      other.clear();
-    }
-    this->resize(size);
-  }
-
- public:
-  /**
-    \rst
-    Constructs a :class:`fmt::basic_memory_buffer` object moving the content
-    of the other object to it.
-    \endrst
-   */
-  FMT_CONSTEXPR20 basic_memory_buffer(basic_memory_buffer&& other) noexcept {
-    move(other);
-  }
-
-  /**
-    \rst
-    Moves the content of the other ``basic_memory_buffer`` object to this one.
-    \endrst
-   */
-  auto operator=(basic_memory_buffer&& other) noexcept -> basic_memory_buffer& {
-    FMT_ASSERT(this != &other, "");
-    deallocate();
-    move(other);
-    return *this;
-  }
-
-  // Returns a copy of the allocator associated with this buffer.
-  auto get_allocator() const -> Allocator { return alloc_; }
-
-  /**
-    Resizes the buffer to contain *count* elements. If T is a POD type new
-    elements may not be initialized.
-   */
-  FMT_CONSTEXPR20 void resize(size_t count) { this->try_resize(count); }
-
-  /** Increases the buffer capacity to *new_capacity*. */
-  void reserve(size_t new_capacity) { this->try_reserve(new_capacity); }
-
-  // Directly append data into the buffer
-  using detail::buffer<T>::append;
-  template <typename ContiguousRange>
-  void append(const ContiguousRange& range) {
-    append(range.data(), range.data() + range.size());
-  }
-};
-
-template <typename T, size_t SIZE, typename Allocator>
-FMT_CONSTEXPR20 void basic_memory_buffer<T, SIZE, Allocator>::grow(
-    size_t size) {
-  detail::abort_fuzzing_if(size > 5000);
-  const size_t max_size = std::allocator_traits<Allocator>::max_size(alloc_);
-  size_t old_capacity = this->capacity();
-  size_t new_capacity = old_capacity + old_capacity / 2;
-  if (size > new_capacity)
-    new_capacity = size;
-  else if (new_capacity > max_size)
-    new_capacity = size > max_size ? size : max_size;
-  T* old_data = this->data();
-  T* new_data =
-      std::allocator_traits<Allocator>::allocate(alloc_, new_capacity);
-  // The following code doesn't throw, so the raw pointer above doesn't leak.
-  std::uninitialized_copy(old_data, old_data + this->size(),
-                          detail::make_checked(new_data, new_capacity));
-  this->set(new_data, new_capacity);
-  // deallocate must not throw according to the standard, but even if it does,
-  // the buffer already uses the new storage and will deallocate it in
-  // destructor.
-  if (old_data != store_) alloc_.deallocate(old_data, old_capacity);
-}
-
-using memory_buffer = basic_memory_buffer<char>;
-
-template <typename T, size_t SIZE, typename Allocator>
-struct is_contiguous<basic_memory_buffer<T, SIZE, Allocator>> : std::true_type {
-};
-
-namespace detail {
-#ifdef _WIN32
-FMT_API bool write_console(std::FILE* f, string_view text);
-#endif
-FMT_API void print(std::FILE*, string_view);
-}  // namespace detail
-
-/** A formatting error such as invalid format string. */
-FMT_CLASS_API
-class FMT_API format_error : public std::runtime_error {
- public:
-  explicit format_error(const char* message) : std::runtime_error(message) {}
-  explicit format_error(const std::string& message)
-      : std::runtime_error(message) {}
-  format_error(const format_error&) = default;
-  format_error& operator=(const format_error&) = default;
-  format_error(format_error&&) = default;
-  format_error& operator=(format_error&&) = default;
-  ~format_error() noexcept override FMT_MSC_DEFAULT;
-};
-
-namespace detail_exported {
-#if FMT_USE_NONTYPE_TEMPLATE_ARGS
-template <typename Char, size_t N> struct fixed_string {
-  constexpr fixed_string(const Char (&str)[N]) {
-    detail::copy_str<Char, const Char*, Char*>(static_cast<const Char*>(str),
-                                               str + N, data);
-  }
-  Char data[N] = {};
-};
-#endif
-
-// Converts a compile-time string to basic_string_view.
-template <typename Char, size_t N>
-constexpr auto compile_string_to_view(const Char (&s)[N])
-    -> basic_string_view<Char> {
-  // Remove trailing NUL character if needed. Won't be present if this is used
-  // with a raw character array (i.e. not defined as a string).
-  return {s, N - (std::char_traits<Char>::to_int_type(s[N - 1]) == 0 ? 1 : 0)};
-}
-template <typename Char>
-constexpr auto compile_string_to_view(detail::std_string_view<Char> s)
-    -> basic_string_view<Char> {
-  return {s.data(), s.size()};
-}
-}  // namespace detail_exported
-
-FMT_BEGIN_DETAIL_NAMESPACE
-
-template <typename T> struct is_integral : std::is_integral<T> {};
-template <> struct is_integral<int128_opt> : std::true_type {};
-template <> struct is_integral<uint128_t> : std::true_type {};
-
-template <typename T>
-using is_signed =
-    std::integral_constant<bool, std::numeric_limits<T>::is_signed ||
-                                     std::is_same<T, int128_opt>::value>;
-
-// Returns true if value is negative, false otherwise.
-// Same as `value < 0` but doesn't produce warnings if T is an unsigned type.
-template <typename T, FMT_ENABLE_IF(is_signed<T>::value)>
-constexpr auto is_negative(T value) -> bool {
-  return value < 0;
-}
-template <typename T, FMT_ENABLE_IF(!is_signed<T>::value)>
-constexpr auto is_negative(T) -> bool {
-  return false;
-}
-
-template <typename T>
-FMT_CONSTEXPR auto is_supported_floating_point(T) -> bool {
-  if (std::is_same<T, float>()) return FMT_USE_FLOAT;
-  if (std::is_same<T, double>()) return FMT_USE_DOUBLE;
-  if (std::is_same<T, long double>()) return FMT_USE_LONG_DOUBLE;
-  return true;
-}
-
-// Smallest of uint32_t, uint64_t, uint128_t that is large enough to
-// represent all values of an integral type T.
-template <typename T>
-using uint32_or_64_or_128_t =
-    conditional_t<num_bits<T>() <= 32 && !FMT_REDUCE_INT_INSTANTIATIONS,
-                  uint32_t,
-                  conditional_t<num_bits<T>() <= 64, uint64_t, uint128_t>>;
-template <typename T>
-using uint64_or_128_t = conditional_t<num_bits<T>() <= 64, uint64_t, uint128_t>;
-
-#define FMT_POWERS_OF_10(factor)                                             \
-  factor * 10, (factor)*100, (factor)*1000, (factor)*10000, (factor)*100000, \
-      (factor)*1000000, (factor)*10000000, (factor)*100000000,               \
-      (factor)*1000000000
-
-// Converts value in the range [0, 100) to a string.
-constexpr const char* digits2(size_t value) {
-  // GCC generates slightly better code when value is pointer-size.
-  return &"0001020304050607080910111213141516171819"
-         "2021222324252627282930313233343536373839"
-         "4041424344454647484950515253545556575859"
-         "6061626364656667686970717273747576777879"
-         "8081828384858687888990919293949596979899"[value * 2];
-}
-
-// Sign is a template parameter to workaround a bug in gcc 4.8.
-template <typename Char, typename Sign> constexpr Char sign(Sign s) {
-#if !FMT_GCC_VERSION || FMT_GCC_VERSION >= 604
-  static_assert(std::is_same<Sign, sign_t>::value, "");
-#endif
-  return static_cast<Char>("\0-+ "[s]);
-}
-
-template <typename T> FMT_CONSTEXPR auto count_digits_fallback(T n) -> int {
-  int count = 1;
-  for (;;) {
-    // Integer division is slow so do it for a group of four digits instead
-    // of for every digit. The idea comes from the talk by Alexandrescu
-    // "Three Optimization Tips for C++". See speed-test for a comparison.
-    if (n < 10) return count;
-    if (n < 100) return count + 1;
-    if (n < 1000) return count + 2;
-    if (n < 10000) return count + 3;
-    n /= 10000u;
-    count += 4;
-  }
-}
-#if FMT_USE_INT128
-FMT_CONSTEXPR inline auto count_digits(uint128_opt n) -> int {
-  return count_digits_fallback(n);
-}
-#endif
-
-#ifdef FMT_BUILTIN_CLZLL
-// It is a separate function rather than a part of count_digits to workaround
-// the lack of static constexpr in constexpr functions.
-inline auto do_count_digits(uint64_t n) -> int {
-  // This has comparable performance to the version by Kendall Willets
-  // (https://github.com/fmtlib/format-benchmark/blob/master/digits10)
-  // but uses smaller tables.
-  // Maps bsr(n) to ceil(log10(pow(2, bsr(n) + 1) - 1)).
-  static constexpr uint8_t bsr2log10[] = {
-      1,  1,  1,  2,  2,  2,  3,  3,  3,  4,  4,  4,  4,  5,  5,  5,
-      6,  6,  6,  7,  7,  7,  7,  8,  8,  8,  9,  9,  9,  10, 10, 10,
-      10, 11, 11, 11, 12, 12, 12, 13, 13, 13, 13, 14, 14, 14, 15, 15,
-      15, 16, 16, 16, 16, 17, 17, 17, 18, 18, 18, 19, 19, 19, 19, 20};
-  auto t = bsr2log10[FMT_BUILTIN_CLZLL(n | 1) ^ 63];
-  static constexpr const uint64_t zero_or_powers_of_10[] = {
-      0, 0, FMT_POWERS_OF_10(1U), FMT_POWERS_OF_10(1000000000ULL),
-      10000000000000000000ULL};
-  return t - (n < zero_or_powers_of_10[t]);
-}
-#endif
-
-// Returns the number of decimal digits in n. Leading zeros are not counted
-// except for n == 0 in which case count_digits returns 1.
-FMT_CONSTEXPR20 inline auto count_digits(uint64_t n) -> int {
-#ifdef FMT_BUILTIN_CLZLL
-  if (!is_constant_evaluated()) {
-    return do_count_digits(n);
-  }
-#endif
-  return count_digits_fallback(n);
-}
-
-// Counts the number of digits in n. BITS = log2(radix).
-template <int BITS, typename UInt>
-FMT_CONSTEXPR auto count_digits(UInt n) -> int {
-#ifdef FMT_BUILTIN_CLZ
-  if (!is_constant_evaluated() && num_bits<UInt>() == 32)
-    return (FMT_BUILTIN_CLZ(static_cast<uint32_t>(n) | 1) ^ 31) / BITS + 1;
-#endif
-  // Lambda avoids unreachable code warnings from NVHPC.
-  return [](UInt m) {
-    int num_digits = 0;
-    do {
-      ++num_digits;
-    } while ((m >>= BITS) != 0);
-    return num_digits;
-  }(n);
-}
-
-#ifdef FMT_BUILTIN_CLZ
-// It is a separate function rather than a part of count_digits to workaround
-// the lack of static constexpr in constexpr functions.
-FMT_INLINE auto do_count_digits(uint32_t n) -> int {
-// An optimization by Kendall Willets from https://bit.ly/3uOIQrB.
-// This increments the upper 32 bits (log10(T) - 1) when >= T is added.
-#  define FMT_INC(T) (((sizeof(#  T) - 1ull) << 32) - T)
-  static constexpr uint64_t table[] = {
-      FMT_INC(0),          FMT_INC(0),          FMT_INC(0),           // 8
-      FMT_INC(10),         FMT_INC(10),         FMT_INC(10),          // 64
-      FMT_INC(100),        FMT_INC(100),        FMT_INC(100),         // 512
-      FMT_INC(1000),       FMT_INC(1000),       FMT_INC(1000),        // 4096
-      FMT_INC(10000),      FMT_INC(10000),      FMT_INC(10000),       // 32k
-      FMT_INC(100000),     FMT_INC(100000),     FMT_INC(100000),      // 256k
-      FMT_INC(1000000),    FMT_INC(1000000),    FMT_INC(1000000),     // 2048k
-      FMT_INC(10000000),   FMT_INC(10000000),   FMT_INC(10000000),    // 16M
-      FMT_INC(100000000),  FMT_INC(100000000),  FMT_INC(100000000),   // 128M
-      FMT_INC(1000000000), FMT_INC(1000000000), FMT_INC(1000000000),  // 1024M
-      FMT_INC(1000000000), FMT_INC(1000000000)                        // 4B
-  };
-  auto inc = table[FMT_BUILTIN_CLZ(n | 1) ^ 31];
-  return static_cast<int>((n + inc) >> 32);
-}
-#endif
-
-// Optional version of count_digits for better performance on 32-bit platforms.
-FMT_CONSTEXPR20 inline auto count_digits(uint32_t n) -> int {
-#ifdef FMT_BUILTIN_CLZ
-  if (!is_constant_evaluated()) {
-    return do_count_digits(n);
-  }
-#endif
-  return count_digits_fallback(n);
-}
-
-template <typename Int> constexpr auto digits10() noexcept -> int {
-  return std::numeric_limits<Int>::digits10;
-}
-template <> constexpr auto digits10<int128_opt>() noexcept -> int { return 38; }
-template <> constexpr auto digits10<uint128_t>() noexcept -> int { return 38; }
-
-template <typename Char> struct thousands_sep_result {
-  std::string grouping;
-  Char thousands_sep;
-};
-
-template <typename Char>
-FMT_API auto thousands_sep_impl(locale_ref loc) -> thousands_sep_result<Char>;
-template <typename Char>
-inline auto thousands_sep(locale_ref loc) -> thousands_sep_result<Char> {
-  auto result = thousands_sep_impl<char>(loc);
-  return {result.grouping, Char(result.thousands_sep)};
-}
-template <>
-inline auto thousands_sep(locale_ref loc) -> thousands_sep_result<wchar_t> {
-  return thousands_sep_impl<wchar_t>(loc);
-}
-
-template <typename Char>
-FMT_API auto decimal_point_impl(locale_ref loc) -> Char;
-template <typename Char> inline auto decimal_point(locale_ref loc) -> Char {
-  return Char(decimal_point_impl<char>(loc));
-}
-template <> inline auto decimal_point(locale_ref loc) -> wchar_t {
-  return decimal_point_impl<wchar_t>(loc);
-}
-
-// Compares two characters for equality.
-template <typename Char> auto equal2(const Char* lhs, const char* rhs) -> bool {
-  return lhs[0] == Char(rhs[0]) && lhs[1] == Char(rhs[1]);
-}
-inline auto equal2(const char* lhs, const char* rhs) -> bool {
-  return memcmp(lhs, rhs, 2) == 0;
-}
-
-// Copies two characters from src to dst.
-template <typename Char>
-FMT_CONSTEXPR20 FMT_INLINE void copy2(Char* dst, const char* src) {
-  if (!is_constant_evaluated() && sizeof(Char) == sizeof(char)) {
-    memcpy(dst, src, 2);
-    return;
-  }
-  *dst++ = static_cast<Char>(*src++);
-  *dst = static_cast<Char>(*src);
-}
-
-template <typename Iterator> struct format_decimal_result {
-  Iterator begin;
-  Iterator end;
-};
-
-// Formats a decimal unsigned integer value writing into out pointing to a
-// buffer of specified size. The caller must ensure that the buffer is large
-// enough.
-template <typename Char, typename UInt>
-FMT_CONSTEXPR20 auto format_decimal(Char* out, UInt value, int size)
-    -> format_decimal_result<Char*> {
-  FMT_ASSERT(size >= count_digits(value), "invalid digit count");
-  out += size;
-  Char* end = out;
-  while (value >= 100) {
-    // Integer division is slow so do it for a group of two digits instead
-    // of for every digit. The idea comes from the talk by Alexandrescu
-    // "Three Optimization Tips for C++". See speed-test for a comparison.
-    out -= 2;
-    copy2(out, digits2(static_cast<size_t>(value % 100)));
-    value /= 100;
-  }
-  if (value < 10) {
-    *--out = static_cast<Char>('0' + value);
-    return {out, end};
-  }
-  out -= 2;
-  copy2(out, digits2(static_cast<size_t>(value)));
-  return {out, end};
-}
-
-template <typename Char, typename UInt, typename Iterator,
-          FMT_ENABLE_IF(!std::is_pointer<remove_cvref_t<Iterator>>::value)>
-FMT_CONSTEXPR inline auto format_decimal(Iterator out, UInt value, int size)
-    -> format_decimal_result<Iterator> {
-  // Buffer is large enough to hold all digits (digits10 + 1).
-  Char buffer[digits10<UInt>() + 1];
-  auto end = format_decimal(buffer, value, size).end;
-  return {out, detail::copy_str_noinline<Char>(buffer, end, out)};
-}
-
-template <unsigned BASE_BITS, typename Char, typename UInt>
-FMT_CONSTEXPR auto format_uint(Char* buffer, UInt value, int num_digits,
-                               bool upper = false) -> Char* {
-  buffer += num_digits;
-  Char* end = buffer;
-  do {
-    const char* digits = upper ? "0123456789ABCDEF" : "0123456789abcdef";
-    unsigned digit = static_cast<unsigned>(value & ((1 << BASE_BITS) - 1));
-    *--buffer = static_cast<Char>(BASE_BITS < 4 ? static_cast<char>('0' + digit)
-                                                : digits[digit]);
-  } while ((value >>= BASE_BITS) != 0);
-  return end;
-}
-
-template <unsigned BASE_BITS, typename Char, typename It, typename UInt>
-inline auto format_uint(It out, UInt value, int num_digits, bool upper = false)
-    -> It {
-  if (auto ptr = to_pointer<Char>(out, to_unsigned(num_digits))) {
-    format_uint<BASE_BITS>(ptr, value, num_digits, upper);
-    return out;
-  }
-  // Buffer should be large enough to hold all digits (digits / BASE_BITS + 1).
-  char buffer[num_bits<UInt>() / BASE_BITS + 1];
-  format_uint<BASE_BITS>(buffer, value, num_digits, upper);
-  return detail::copy_str_noinline<Char>(buffer, buffer + num_digits, out);
-}
-
-// A converter from UTF-8 to UTF-16.
-class utf8_to_utf16 {
- private:
-  basic_memory_buffer<wchar_t> buffer_;
-
- public:
-  FMT_API explicit utf8_to_utf16(string_view s);
-  operator basic_string_view<wchar_t>() const { return {&buffer_[0], size()}; }
-  auto size() const -> size_t { return buffer_.size() - 1; }
-  auto c_str() const -> const wchar_t* { return &buffer_[0]; }
-  auto str() const -> std::wstring { return {&buffer_[0], size()}; }
-};
-
-namespace dragonbox {
-
-// Type-specific information that Dragonbox uses.
-template <typename T, typename Enable = void> struct float_info;
-
-template <> struct float_info<float> {
-  using carrier_uint = uint32_t;
-  static const int exponent_bits = 8;
-  static const int kappa = 1;
-  static const int big_divisor = 100;
-  static const int small_divisor = 10;
-  static const int min_k = -31;
-  static const int max_k = 46;
-  static const int shorter_interval_tie_lower_threshold = -35;
-  static const int shorter_interval_tie_upper_threshold = -35;
-};
-
-template <> struct float_info<double> {
-  using carrier_uint = uint64_t;
-  static const int exponent_bits = 11;
-  static const int kappa = 2;
-  static const int big_divisor = 1000;
-  static const int small_divisor = 100;
-  static const int min_k = -292;
-  static const int max_k = 326;
-  static const int shorter_interval_tie_lower_threshold = -77;
-  static const int shorter_interval_tie_upper_threshold = -77;
-};
-
-// An 80- or 128-bit floating point number.
-template <typename T>
-struct float_info<T, enable_if_t<std::numeric_limits<T>::digits == 64 ||
-                                 std::numeric_limits<T>::digits == 113 ||
-                                 is_float128<T>::value>> {
-  using carrier_uint = detail::uint128_t;
-  static const int exponent_bits = 15;
-};
-
-// A double-double floating point number.
-template <typename T>
-struct float_info<T, enable_if_t<is_double_double<T>::value>> {
-  using carrier_uint = detail::uint128_t;
-};
-
-template <typename T> struct decimal_fp {
-  using significand_type = typename float_info<T>::carrier_uint;
-  significand_type significand;
-  int exponent;
-};
-
-template <typename T> FMT_API auto to_decimal(T x) noexcept -> decimal_fp<T>;
-}  // namespace dragonbox
-
-// Returns true iff Float has the implicit bit which is not stored.
-template <typename Float> constexpr bool has_implicit_bit() {
-  // An 80-bit FP number has a 64-bit significand an no implicit bit.
-  return std::numeric_limits<Float>::digits != 64;
-}
-
-// Returns the number of significand bits stored in Float. The implicit bit is
-// not counted since it is not stored.
-template <typename Float> constexpr int num_significand_bits() {
-  // std::numeric_limits may not support __float128.
-  return is_float128<Float>() ? 112
-                              : (std::numeric_limits<Float>::digits -
-                                 (has_implicit_bit<Float>() ? 1 : 0));
-}
-
-template <typename Float>
-constexpr auto exponent_mask() ->
-    typename dragonbox::float_info<Float>::carrier_uint {
-  using fmt_uint = typename dragonbox::float_info<Float>::carrier_uint;
-  return ((fmt_uint(1) << dragonbox::float_info<Float>::exponent_bits) - 1)
-         << num_significand_bits<Float>();
-}
-template <typename Float> constexpr auto exponent_bias() -> int {
-  // std::numeric_limits may not support __float128.
-  return is_float128<Float>() ? 16383
-                              : std::numeric_limits<Float>::max_exponent - 1;
-}
-
-// Writes the exponent exp in the form "[+-]d{2,3}" to buffer.
-template <typename Char, typename It>
-FMT_CONSTEXPR auto write_exponent(int exp, It it) -> It {
-  FMT_ASSERT(-10000 < exp && exp < 10000, "exponent out of range");
-  if (exp < 0) {
-    *it++ = static_cast<Char>('-');
-    exp = -exp;
-  } else {
-    *it++ = static_cast<Char>('+');
-  }
-  if (exp >= 100) {
-    const char* top = digits2(to_unsigned(exp / 100));
-    if (exp >= 1000) *it++ = static_cast<Char>(top[0]);
-    *it++ = static_cast<Char>(top[1]);
-    exp %= 100;
-  }
-  const char* d = digits2(to_unsigned(exp));
-  *it++ = static_cast<Char>(d[0]);
-  *it++ = static_cast<Char>(d[1]);
-  return it;
-}
-
-// A floating-point number f * pow(2, e) where F is an unsigned type.
-template <typename F> struct basic_fp {
-  F f;
-  int e;
-
-  static constexpr const int num_significand_bits =
-      static_cast<int>(sizeof(F) * num_bits<unsigned char>());
-
-  constexpr basic_fp() : f(0), e(0) {}
-  constexpr basic_fp(uint64_t f_val, int e_val) : f(f_val), e(e_val) {}
-
-  // Constructs fp from an IEEE754 floating-point number.
-  template <typename Float> FMT_CONSTEXPR basic_fp(Float n) { assign(n); }
-
-  // Assigns n to this and return true iff predecessor is closer than successor.
-  template <typename Float, FMT_ENABLE_IF(!is_double_double<Float>::value)>
-  FMT_CONSTEXPR auto assign(Float n) -> bool {
-    static_assert(std::numeric_limits<Float>::digits <= 113, "unsupported FP");
-    // Assume Float is in the format [sign][exponent][significand].
-    using carrier_uint = typename dragonbox::float_info<Float>::carrier_uint;
-    const auto num_float_significand_bits =
-        detail::num_significand_bits<Float>();
-    const auto implicit_bit = carrier_uint(1) << num_float_significand_bits;
-    const auto significand_mask = implicit_bit - 1;
-    auto u = bit_cast<carrier_uint>(n);
-    f = static_cast<F>(u & significand_mask);
-    auto biased_e = static_cast<int>((u & exponent_mask<Float>()) >>
-                                     num_float_significand_bits);
-    // The predecessor is closer if n is a normalized power of 2 (f == 0)
-    // other than the smallest normalized number (biased_e > 1).
-    auto is_predecessor_closer = f == 0 && biased_e > 1;
-    if (biased_e == 0)
-      biased_e = 1;  // Subnormals use biased exponent 1 (min exponent).
-    else if (has_implicit_bit<Float>())
-      f += static_cast<F>(implicit_bit);
-    e = biased_e - exponent_bias<Float>() - num_float_significand_bits;
-    if (!has_implicit_bit<Float>()) ++e;
-    return is_predecessor_closer;
-  }
-
-  template <typename Float, FMT_ENABLE_IF(is_double_double<Float>::value)>
-  FMT_CONSTEXPR auto assign(Float n) -> bool {
-    static_assert(std::numeric_limits<double>::is_iec559, "unsupported FP");
-    return assign(static_cast<double>(n));
-  }
-};
-
-using fp = basic_fp<unsigned long long>;
-
-// Normalizes the value converted from double and multiplied by (1 << SHIFT).
-template <int SHIFT = 0, typename F>
-FMT_CONSTEXPR basic_fp<F> normalize(basic_fp<F> value) {
-  // Handle subnormals.
-  const auto implicit_bit = F(1) << num_significand_bits<double>();
-  const auto shifted_implicit_bit = implicit_bit << SHIFT;
-  while ((value.f & shifted_implicit_bit) == 0) {
-    value.f <<= 1;
-    --value.e;
-  }
-  // Subtract 1 to account for hidden bit.
-  const auto offset = basic_fp<F>::num_significand_bits -
-                      num_significand_bits<double>() - SHIFT - 1;
-  value.f <<= offset;
-  value.e -= offset;
-  return value;
-}
-
-// Computes lhs * rhs / pow(2, 64) rounded to nearest with half-up tie breaking.
-FMT_CONSTEXPR inline uint64_t multiply(uint64_t lhs, uint64_t rhs) {
-#if FMT_USE_INT128
-  auto product = static_cast<__uint128_t>(lhs) * rhs;
-  auto f = static_cast<uint64_t>(product >> 64);
-  return (static_cast<uint64_t>(product) & (1ULL << 63)) != 0 ? f + 1 : f;
-#else
-  // Multiply 32-bit parts of significands.
-  uint64_t mask = (1ULL << 32) - 1;
-  uint64_t a = lhs >> 32, b = lhs & mask;
-  uint64_t c = rhs >> 32, d = rhs & mask;
-  uint64_t ac = a * c, bc = b * c, ad = a * d, bd = b * d;
-  // Compute mid 64-bit of result and round.
-  uint64_t mid = (bd >> 32) + (ad & mask) + (bc & mask) + (1U << 31);
-  return ac + (ad >> 32) + (bc >> 32) + (mid >> 32);
-#endif
-}
-
-FMT_CONSTEXPR inline fp operator*(fp x, fp y) {
-  return {multiply(x.f, y.f), x.e + y.e + 64};
-}
-
-template <typename T = void> struct basic_data {
-  // Normalized 64-bit significands of pow(10, k), for k = -348, -340, ..., 340.
-  // These are generated by support/compute-powers.py.
-  static constexpr uint64_t pow10_significands[87] = {
-      0xfa8fd5a0081c0288, 0xbaaee17fa23ebf76, 0x8b16fb203055ac76,
-      0xcf42894a5dce35ea, 0x9a6bb0aa55653b2d, 0xe61acf033d1a45df,
-      0xab70fe17c79ac6ca, 0xff77b1fcbebcdc4f, 0xbe5691ef416bd60c,
-      0x8dd01fad907ffc3c, 0xd3515c2831559a83, 0x9d71ac8fada6c9b5,
-      0xea9c227723ee8bcb, 0xaecc49914078536d, 0x823c12795db6ce57,
-      0xc21094364dfb5637, 0x9096ea6f3848984f, 0xd77485cb25823ac7,
-      0xa086cfcd97bf97f4, 0xef340a98172aace5, 0xb23867fb2a35b28e,
-      0x84c8d4dfd2c63f3b, 0xc5dd44271ad3cdba, 0x936b9fcebb25c996,
-      0xdbac6c247d62a584, 0xa3ab66580d5fdaf6, 0xf3e2f893dec3f126,
-      0xb5b5ada8aaff80b8, 0x87625f056c7c4a8b, 0xc9bcff6034c13053,
-      0x964e858c91ba2655, 0xdff9772470297ebd, 0xa6dfbd9fb8e5b88f,
-      0xf8a95fcf88747d94, 0xb94470938fa89bcf, 0x8a08f0f8bf0f156b,
-      0xcdb02555653131b6, 0x993fe2c6d07b7fac, 0xe45c10c42a2b3b06,
-      0xaa242499697392d3, 0xfd87b5f28300ca0e, 0xbce5086492111aeb,
-      0x8cbccc096f5088cc, 0xd1b71758e219652c, 0x9c40000000000000,
-      0xe8d4a51000000000, 0xad78ebc5ac620000, 0x813f3978f8940984,
-      0xc097ce7bc90715b3, 0x8f7e32ce7bea5c70, 0xd5d238a4abe98068,
-      0x9f4f2726179a2245, 0xed63a231d4c4fb27, 0xb0de65388cc8ada8,
-      0x83c7088e1aab65db, 0xc45d1df942711d9a, 0x924d692ca61be758,
-      0xda01ee641a708dea, 0xa26da3999aef774a, 0xf209787bb47d6b85,
-      0xb454e4a179dd1877, 0x865b86925b9bc5c2, 0xc83553c5c8965d3d,
-      0x952ab45cfa97a0b3, 0xde469fbd99a05fe3, 0xa59bc234db398c25,
-      0xf6c69a72a3989f5c, 0xb7dcbf5354e9bece, 0x88fcf317f22241e2,
-      0xcc20ce9bd35c78a5, 0x98165af37b2153df, 0xe2a0b5dc971f303a,
-      0xa8d9d1535ce3b396, 0xfb9b7cd9a4a7443c, 0xbb764c4ca7a44410,
-      0x8bab8eefb6409c1a, 0xd01fef10a657842c, 0x9b10a4e5e9913129,
-      0xe7109bfba19c0c9d, 0xac2820d9623bf429, 0x80444b5e7aa7cf85,
-      0xbf21e44003acdd2d, 0x8e679c2f5e44ff8f, 0xd433179d9c8cb841,
-      0x9e19db92b4e31ba9, 0xeb96bf6ebadf77d9, 0xaf87023b9bf0ee6b,
-  };
-
-#if FMT_GCC_VERSION && FMT_GCC_VERSION < 409
-#  pragma GCC diagnostic push
-#  pragma GCC diagnostic ignored "-Wnarrowing"
-#endif
-  // Binary exponents of pow(10, k), for k = -348, -340, ..., 340, corresponding
-  // to significands above.
-  static constexpr int16_t pow10_exponents[87] = {
-      -1220, -1193, -1166, -1140, -1113, -1087, -1060, -1034, -1007, -980, -954,
-      -927,  -901,  -874,  -847,  -821,  -794,  -768,  -741,  -715,  -688, -661,
-      -635,  -608,  -582,  -555,  -529,  -502,  -475,  -449,  -422,  -396, -369,
-      -343,  -316,  -289,  -263,  -236,  -210,  -183,  -157,  -130,  -103, -77,
-      -50,   -24,   3,     30,    56,    83,    109,   136,   162,   189,  216,
-      242,   269,   295,   322,   348,   375,   402,   428,   455,   481,  508,
-      534,   561,   588,   614,   641,   667,   694,   720,   747,   774,  800,
-      827,   853,   880,   907,   933,   960,   986,   1013,  1039,  1066};
-#if FMT_GCC_VERSION && FMT_GCC_VERSION < 409
-#  pragma GCC diagnostic pop
-#endif
-
-  static constexpr uint64_t power_of_10_64[20] = {
-      1, FMT_POWERS_OF_10(1ULL), FMT_POWERS_OF_10(1000000000ULL),
-      10000000000000000000ULL};
-};
-
-#if FMT_CPLUSPLUS < 201703L
-template <typename T> constexpr uint64_t basic_data<T>::pow10_significands[];
-template <typename T> constexpr int16_t basic_data<T>::pow10_exponents[];
-template <typename T> constexpr uint64_t basic_data<T>::power_of_10_64[];
-#endif
-
-// This is a struct rather than an alias to avoid shadowing warnings in gcc.
-struct data : basic_data<> {};
-
-// Returns a cached power of 10 `c_k = c_k.f * pow(2, c_k.e)` such that its
-// (binary) exponent satisfies `min_exponent <= c_k.e <= min_exponent + 28`.
-FMT_CONSTEXPR inline fp get_cached_power(int min_exponent,
-                                         int& pow10_exponent) {
-  const int shift = 32;
-  // log10(2) = 0x0.4d104d427de7fbcc...
-  const int64_t significand = 0x4d104d427de7fbcc;
-  int index = static_cast<int>(
-      ((min_exponent + fp::num_significand_bits - 1) * (significand >> shift) +
-       ((int64_t(1) << shift) - 1))  // ceil
-      >> 32                          // arithmetic shift
-  );
-  // Decimal exponent of the first (smallest) cached power of 10.
-  const int first_dec_exp = -348;
-  // Difference between 2 consecutive decimal exponents in cached powers of 10.
-  const int dec_exp_step = 8;
-  index = (index - first_dec_exp - 1) / dec_exp_step + 1;
-  pow10_exponent = first_dec_exp + index * dec_exp_step;
-  // Using *(x + index) instead of x[index] avoids an issue with some compilers
-  // using the EDG frontend (e.g. nvhpc/22.3 in C++17 mode).
-  return {*(data::pow10_significands + index),
-          *(data::pow10_exponents + index)};
-}
-
-#ifndef _MSC_VER
-#  define FMT_SNPRINTF snprintf
-#else
-FMT_API auto fmt_snprintf(char* buf, size_t size, const char* fmt, ...) -> int;
-#  define FMT_SNPRINTF fmt_snprintf
-#endif  // _MSC_VER
-
-// Formats a floating-point number with snprintf using the hexfloat format.
-template <typename T>
-auto snprintf_float(T value, int precision, float_specs specs,
-                    buffer<char>& buf) -> int {
-  // Buffer capacity must be non-zero, otherwise MSVC's vsnprintf_s will fail.
-  FMT_ASSERT(buf.capacity() > buf.size(), "empty buffer");
-  FMT_ASSERT(specs.format == float_format::hex, "");
-  static_assert(!std::is_same<T, float>::value, "");
-
-  // Build the format string.
-  char format[7];  // The longest format is "%#.*Le".
-  char* format_ptr = format;
-  *format_ptr++ = '%';
-  if (specs.showpoint) *format_ptr++ = '#';
-  if (precision >= 0) {
-    *format_ptr++ = '.';
-    *format_ptr++ = '*';
-  }
-  if (std::is_same<T, long double>()) *format_ptr++ = 'L';
-  *format_ptr++ = specs.upper ? 'A' : 'a';
-  *format_ptr = '\0';
-
-  // Format using snprintf.
-  auto offset = buf.size();
-  for (;;) {
-    auto begin = buf.data() + offset;
-    auto capacity = buf.capacity() - offset;
-    abort_fuzzing_if(precision > 100000);
-    // Suppress the warning about a nonliteral format string.
-    // Cannot use auto because of a bug in MinGW (#1532).
-    int (*snprintf_ptr)(char*, size_t, const char*, ...) = FMT_SNPRINTF;
-    int result = precision >= 0
-                     ? snprintf_ptr(begin, capacity, format, precision, value)
-                     : snprintf_ptr(begin, capacity, format, value);
-    if (result < 0) {
-      // The buffer will grow exponentially.
-      buf.try_reserve(buf.capacity() + 1);
-      continue;
-    }
-    auto size = to_unsigned(result);
-    // Size equal to capacity means that the last character was truncated.
-    if (size < capacity) {
-      buf.try_resize(size + offset);
-      return 0;
-    }
-    buf.try_reserve(size + offset + 1);  // Add 1 for the terminating '\0'.
-  }
-}
-
-template <typename T>
-using convert_float_result =
-    conditional_t<std::is_same<T, float>::value || sizeof(T) == sizeof(double),
-                  double, T>;
-
-template <typename T>
-constexpr auto convert_float(T value) -> convert_float_result<T> {
-  return static_cast<convert_float_result<T>>(value);
-}
-
-template <typename OutputIt, typename Char>
-FMT_NOINLINE FMT_CONSTEXPR auto fill(OutputIt it, size_t n,
-                                     const fill_t<Char>& fill) -> OutputIt {
-  auto fill_size = fill.size();
-  if (fill_size == 1) return detail::fill_n(it, n, fill[0]);
-  auto data = fill.data();
-  for (size_t i = 0; i < n; ++i)
-    it = copy_str<Char>(data, data + fill_size, it);
-  return it;
-}
-
-// Writes the output of f, padded according to format specifications in specs.
-// size: output size in code units.
-// width: output display width in (terminal) column positions.
-template <align::type align = align::left, typename OutputIt, typename Char,
-          typename F>
-FMT_CONSTEXPR auto write_padded(OutputIt out,
-                                const basic_format_specs<Char>& specs,
-                                size_t size, size_t width, F&& f) -> OutputIt {
-  static_assert(align == align::left || align == align::right, "");
-  unsigned spec_width = to_unsigned(specs.width);
-  size_t padding = spec_width > width ? spec_width - width : 0;
-  // Shifts are encoded as string literals because static constexpr is not
-  // supported in constexpr functions.
-  auto* shifts = align == align::left ? "\x1f\x1f\x00\x01" : "\x00\x1f\x00\x01";
-  size_t left_padding = padding >> shifts[specs.align];
-  size_t right_padding = padding - left_padding;
-  auto it = reserve(out, size + padding * specs.fill.size());
-  if (left_padding != 0) it = fill(it, left_padding, specs.fill);
-  it = f(it);
-  if (right_padding != 0) it = fill(it, right_padding, specs.fill);
-  return base_iterator(out, it);
-}
-
-template <align::type align = align::left, typename OutputIt, typename Char,
-          typename F>
-constexpr auto write_padded(OutputIt out, const basic_format_specs<Char>& specs,
-                            size_t size, F&& f) -> OutputIt {
-  return write_padded<align>(out, specs, size, size, f);
-}
-
-template <align::type align = align::left, typename Char, typename OutputIt>
-FMT_CONSTEXPR auto write_bytes(OutputIt out, string_view bytes,
-                               const basic_format_specs<Char>& specs)
-    -> OutputIt {
-  return write_padded<align>(
-      out, specs, bytes.size(), [bytes](reserve_iterator<OutputIt> it) {
-        const char* data = bytes.data();
-        return copy_str<Char>(data, data + bytes.size(), it);
-      });
-}
-
-template <typename Char, typename OutputIt, typename UIntPtr>
-auto write_ptr(OutputIt out, UIntPtr value,
-               const basic_format_specs<Char>* specs) -> OutputIt {
-  int num_digits = count_digits<4>(value);
-  auto size = to_unsigned(num_digits) + size_t(2);
-  auto write = [=](reserve_iterator<OutputIt> it) {
-    *it++ = static_cast<Char>('0');
-    *it++ = static_cast<Char>('x');
-    return format_uint<4, Char>(it, value, num_digits);
-  };
-  return specs ? write_padded<align::right>(out, *specs, size, write)
-               : base_iterator(out, write(reserve(out, size)));
-}
-
-// Returns true iff the code point cp is printable.
-FMT_API auto is_printable(uint32_t cp) -> bool;
-
-inline auto needs_escape(uint32_t cp) -> bool {
-  return cp < 0x20 || cp == 0x7f || cp == '"' || cp == '\\' ||
-         !is_printable(cp);
-}
-
-template <typename Char> struct find_escape_result {
-  const Char* begin;
-  const Char* end;
-  uint32_t cp;
-};
-
-template <typename Char>
-using make_unsigned_char =
-    typename conditional_t<std::is_integral<Char>::value,
-                           std::make_unsigned<Char>,
-                           type_identity<uint32_t>>::type;
-
-template <typename Char>
-auto find_escape(const Char* begin, const Char* end)
-    -> find_escape_result<Char> {
-  for (; begin != end; ++begin) {
-    uint32_t cp = static_cast<make_unsigned_char<Char>>(*begin);
-    if (const_check(sizeof(Char) == 1) && cp >= 0x80) continue;
-    if (needs_escape(cp)) return {begin, begin + 1, cp};
-  }
-  return {begin, nullptr, 0};
-}
-
-inline auto find_escape(const char* begin, const char* end)
-    -> find_escape_result<char> {
-  if (!is_utf8()) return find_escape<char>(begin, end);
-  auto result = find_escape_result<char>{end, nullptr, 0};
-  for_each_codepoint(string_view(begin, to_unsigned(end - begin)),
-                     [&](uint32_t cp, string_view sv) {
-                       if (needs_escape(cp)) {
-                         result = {sv.begin(), sv.end(), cp};
-                         return false;
-                       }
-                       return true;
-                     });
-  return result;
-}
-
-#define FMT_STRING_IMPL(s, base, explicit)                                    \
-  [] {                                                                        \
-    /* Use the hidden visibility as a workaround for a GCC bug (#1973). */    \
-    /* Use a macro-like name to avoid shadowing warnings. */                  \
-    struct FMT_GCC_VISIBILITY_HIDDEN FMT_COMPILE_STRING : base {              \
-      using char_type FMT_MAYBE_UNUSED = fmt::remove_cvref_t<decltype(s[0])>; \
-      FMT_MAYBE_UNUSED FMT_CONSTEXPR explicit                                 \
-      operator fmt::basic_string_view<char_type>() const {                    \
-        return fmt::detail_exported::compile_string_to_view<char_type>(s);    \
-      }                                                                       \
-    };                                                                        \
-    return FMT_COMPILE_STRING();                                              \
-  }()
-
-/**
-  \rst
-  Constructs a compile-time format string from a string literal *s*.
-
-  **Example**::
-
-    // A compile-time error because 'd' is an invalid specifier for strings.
-    std::string s = fmt::format(FMT_STRING("{:d}"), "foo");
-  \endrst
- */
-#define FMT_STRING(s) FMT_STRING_IMPL(s, fmt::detail::compile_string, )
-
-template <size_t width, typename Char, typename OutputIt>
-auto write_codepoint(OutputIt out, char prefix, uint32_t cp) -> OutputIt {
-  *out++ = static_cast<Char>('\\');
-  *out++ = static_cast<Char>(prefix);
-  Char buf[width];
-  fill_n(buf, width, static_cast<Char>('0'));
-  format_uint<4>(buf, cp, width);
-  return copy_str<Char>(buf, buf + width, out);
-}
-
-template <typename OutputIt, typename Char>
-auto write_escaped_cp(OutputIt out, const find_escape_result<Char>& escape)
-    -> OutputIt {
-  auto c = static_cast<Char>(escape.cp);
-  switch (escape.cp) {
-  case '\n':
-    *out++ = static_cast<Char>('\\');
-    c = static_cast<Char>('n');
-    break;
-  case '\r':
-    *out++ = static_cast<Char>('\\');
-    c = static_cast<Char>('r');
-    break;
-  case '\t':
-    *out++ = static_cast<Char>('\\');
-    c = static_cast<Char>('t');
-    break;
-  case '"':
-    FMT_FALLTHROUGH;
-  case '\'':
-    FMT_FALLTHROUGH;
-  case '\\':
-    *out++ = static_cast<Char>('\\');
-    break;
-  default:
-    if (is_utf8()) {
-      if (escape.cp < 0x100) {
-        return write_codepoint<2, Char>(out, 'x', escape.cp);
-      }
-      if (escape.cp < 0x10000) {
-        return write_codepoint<4, Char>(out, 'u', escape.cp);
-      }
-      if (escape.cp < 0x110000) {
-        return write_codepoint<8, Char>(out, 'U', escape.cp);
-      }
-    }
-    for (Char escape_char : basic_string_view<Char>(
-             escape.begin, to_unsigned(escape.end - escape.begin))) {
-      out = write_codepoint<2, Char>(out, 'x',
-                                     static_cast<uint32_t>(escape_char) & 0xFF);
-    }
-    return out;
-  }
-  *out++ = c;
-  return out;
-}
-
-template <typename Char, typename OutputIt>
-auto write_escaped_string(OutputIt out, basic_string_view<Char> str)
-    -> OutputIt {
-  *out++ = static_cast<Char>('"');
-  auto begin = str.begin(), end = str.end();
-  do {
-    auto escape = find_escape(begin, end);
-    out = copy_str<Char>(begin, escape.begin, out);
-    begin = escape.end;
-    if (!begin) break;
-    out = write_escaped_cp<OutputIt, Char>(out, escape);
-  } while (begin != end);
-  *out++ = static_cast<Char>('"');
-  return out;
-}
-
-template <typename Char, typename OutputIt>
-auto write_escaped_char(OutputIt out, Char v) -> OutputIt {
-  *out++ = static_cast<Char>('\'');
-  if ((needs_escape(static_cast<uint32_t>(v)) && v != static_cast<Char>('"')) ||
-      v == static_cast<Char>('\'')) {
-    out = write_escaped_cp(
-        out, find_escape_result<Char>{&v, &v + 1, static_cast<uint32_t>(v)});
-  } else {
-    *out++ = v;
-  }
-  *out++ = static_cast<Char>('\'');
-  return out;
-}
-
-template <typename Char, typename OutputIt>
-FMT_CONSTEXPR auto write_char(OutputIt out, Char value,
-                              const basic_format_specs<Char>& specs)
-    -> OutputIt {
-  bool is_debug = specs.type == presentation_type::debug;
-  return write_padded(out, specs, 1, [=](reserve_iterator<OutputIt> it) {
-    if (is_debug) return write_escaped_char(it, value);
-    *it++ = value;
-    return it;
-  });
-}
-template <typename Char, typename OutputIt>
-FMT_CONSTEXPR auto write(OutputIt out, Char value,
-                         const basic_format_specs<Char>& specs,
-                         locale_ref loc = {}) -> OutputIt {
-  return check_char_specs(specs)
-             ? write_char(out, value, specs)
-             : write(out, static_cast<int>(value), specs, loc);
-}
-
-// Data for write_int that doesn't depend on output iterator type. It is used to
-// avoid template code bloat.
-template <typename Char> struct write_int_data {
-  size_t size;
-  size_t padding;
-
-  FMT_CONSTEXPR write_int_data(int num_digits, unsigned prefix,
-                               const basic_format_specs<Char>& specs)
-      : size((prefix >> 24) + to_unsigned(num_digits)), padding(0) {
-    if (specs.align == align::numeric) {
-      auto width = to_unsigned(specs.width);
-      if (width > size) {
-        padding = width - size;
-        size = width;
-      }
-    } else if (specs.precision > num_digits) {
-      size = (prefix >> 24) + to_unsigned(specs.precision);
-      padding = to_unsigned(specs.precision - num_digits);
-    }
-  }
-};
-
-// Writes an integer in the format
-//   <left-padding><prefix><numeric-padding><digits><right-padding>
-// where <digits> are written by write_digits(it).
-// prefix contains chars in three lower bytes and the size in the fourth byte.
-template <typename OutputIt, typename Char, typename W>
-FMT_CONSTEXPR FMT_INLINE auto write_int(OutputIt out, int num_digits,
-                                        unsigned prefix,
-                                        const basic_format_specs<Char>& specs,
-                                        W write_digits) -> OutputIt {
-  // Slightly faster check for specs.width == 0 && specs.precision == -1.
-  if ((specs.width | (specs.precision + 1)) == 0) {
-    auto it = reserve(out, to_unsigned(num_digits) + (prefix >> 24));
-    if (prefix != 0) {
-      for (unsigned p = prefix & 0xffffff; p != 0; p >>= 8)
-        *it++ = static_cast<Char>(p & 0xff);
-    }
-    return base_iterator(out, write_digits(it));
-  }
-  auto data = write_int_data<Char>(num_digits, prefix, specs);
-  return write_padded<align::right>(
-      out, specs, data.size, [=](reserve_iterator<OutputIt> it) {
-        for (unsigned p = prefix & 0xffffff; p != 0; p >>= 8)
-          *it++ = static_cast<Char>(p & 0xff);
-        it = detail::fill_n(it, data.padding, static_cast<Char>('0'));
-        return write_digits(it);
-      });
-}
-
-template <typename Char> class digit_grouping {
- private:
-  thousands_sep_result<Char> sep_;
-
-  struct next_state {
-    std::string::const_iterator group;
-    int pos;
-  };
-  next_state initial_state() const { return {sep_.grouping.begin(), 0}; }
-
-  // Returns the next digit group separator position.
-  int next(next_state& state) const {
-    if (!sep_.thousands_sep) return max_value<int>();
-    if (state.group == sep_.grouping.end())
-      return state.pos += sep_.grouping.back();
-    if (*state.group <= 0 || *state.group == max_value<char>())
-      return max_value<int>();
-    state.pos += *state.group++;
-    return state.pos;
-  }
-
- public:
-  explicit digit_grouping(locale_ref loc, bool localized = true) {
-    if (localized)
-      sep_ = thousands_sep<Char>(loc);
-    else
-      sep_.thousands_sep = Char();
-  }
-  explicit digit_grouping(thousands_sep_result<Char> sep) : sep_(sep) {}
-
-  Char separator() const { return sep_.thousands_sep; }
-
-  int count_separators(int num_digits) const {
-    int count = 0;
-    auto state = initial_state();
-    while (num_digits > next(state)) ++count;
-    return count;
-  }
-
-  // Applies grouping to digits and write the output to out.
-  template <typename Out, typename C>
-  Out apply(Out out, basic_string_view<C> digits) const {
-    auto num_digits = static_cast<int>(digits.size());
-    auto separators = basic_memory_buffer<int>();
-    separators.push_back(0);
-    auto state = initial_state();
-    while (int i = next(state)) {
-      if (i >= num_digits) break;
-      separators.push_back(i);
-    }
-    for (int i = 0, sep_index = static_cast<int>(separators.size() - 1);
-         i < num_digits; ++i) {
-      if (num_digits - i == separators[sep_index]) {
-        *out++ = separator();
-        --sep_index;
-      }
-      *out++ = static_cast<Char>(digits[to_unsigned(i)]);
-    }
-    return out;
-  }
-};
-
-template <typename OutputIt, typename UInt, typename Char>
-auto write_int_localized(OutputIt out, UInt value, unsigned prefix,
-                         const basic_format_specs<Char>& specs,
-                         const digit_grouping<Char>& grouping) -> OutputIt {
-  static_assert(std::is_same<uint64_or_128_t<UInt>, UInt>::value, "");
-  int num_digits = count_digits(value);
-  char digits[40];
-  format_decimal(digits, value, num_digits);
-  unsigned size = to_unsigned((prefix != 0 ? 1 : 0) + num_digits +
-                              grouping.count_separators(num_digits));
-  return write_padded<align::right>(
-      out, specs, size, size, [&](reserve_iterator<OutputIt> it) {
-        if (prefix != 0) {
-          char sign = static_cast<char>(prefix);
-          *it++ = static_cast<Char>(sign);
-        }
-        return grouping.apply(it, string_view(digits, to_unsigned(num_digits)));
-      });
-}
-
-template <typename OutputIt, typename UInt, typename Char>
-auto write_int_localized(OutputIt& out, UInt value, unsigned prefix,
-                         const basic_format_specs<Char>& specs, locale_ref loc)
-    -> bool {
-  auto grouping = digit_grouping<Char>(loc);
-  out = write_int_localized(out, value, prefix, specs, grouping);
-  return true;
-}
-
-FMT_CONSTEXPR inline void prefix_append(unsigned& prefix, unsigned value) {
-  prefix |= prefix != 0 ? value << 8 : value;
-  prefix += (1u + (value > 0xff ? 1 : 0)) << 24;
-}
-
-template <typename UInt> struct write_int_arg {
-  UInt abs_value;
-  unsigned prefix;
-};
-
-template <typename T>
-FMT_CONSTEXPR auto make_write_int_arg(T value, sign_t sign)
-    -> write_int_arg<uint32_or_64_or_128_t<T>> {
-  auto prefix = 0u;
-  auto abs_value = static_cast<uint32_or_64_or_128_t<T>>(value);
-  if (is_negative(value)) {
-    prefix = 0x01000000 | '-';
-    abs_value = 0 - abs_value;
-  } else {
-    constexpr const unsigned prefixes[4] = {0, 0, 0x1000000u | '+',
-                                            0x1000000u | ' '};
-    prefix = prefixes[sign];
-  }
-  return {abs_value, prefix};
-}
-
-template <typename Char, typename OutputIt, typename T>
-FMT_CONSTEXPR FMT_INLINE auto write_int(OutputIt out, write_int_arg<T> arg,
-                                        const basic_format_specs<Char>& specs,
-                                        locale_ref loc) -> OutputIt {
-  static_assert(std::is_same<T, uint32_or_64_or_128_t<T>>::value, "");
-  auto abs_value = arg.abs_value;
-  auto prefix = arg.prefix;
-  switch (specs.type) {
-  case presentation_type::none:
-  case presentation_type::dec: {
-    if (specs.localized &&
-        write_int_localized(out, static_cast<uint64_or_128_t<T>>(abs_value),
-                            prefix, specs, loc)) {
-      return out;
-    }
-    auto num_digits = count_digits(abs_value);
-    return write_int(
-        out, num_digits, prefix, specs, [=](reserve_iterator<OutputIt> it) {
-          return format_decimal<Char>(it, abs_value, num_digits).end;
-        });
-  }
-  case presentation_type::hex_lower:
-  case presentation_type::hex_upper: {
-    bool upper = specs.type == presentation_type::hex_upper;
-    if (specs.alt)
-      prefix_append(prefix, unsigned(upper ? 'X' : 'x') << 8 | '0');
-    int num_digits = count_digits<4>(abs_value);
-    return write_int(
-        out, num_digits, prefix, specs, [=](reserve_iterator<OutputIt> it) {
-          return format_uint<4, Char>(it, abs_value, num_digits, upper);
-        });
-  }
-  case presentation_type::bin_lower:
-  case presentation_type::bin_upper: {
-    bool upper = specs.type == presentation_type::bin_upper;
-    if (specs.alt)
-      prefix_append(prefix, unsigned(upper ? 'B' : 'b') << 8 | '0');
-    int num_digits = count_digits<1>(abs_value);
-    return write_int(out, num_digits, prefix, specs,
-                     [=](reserve_iterator<OutputIt> it) {
-                       return format_uint<1, Char>(it, abs_value, num_digits);
-                     });
-  }
-  case presentation_type::oct: {
-    int num_digits = count_digits<3>(abs_value);
-    // Octal prefix '0' is counted as a digit, so only add it if precision
-    // is not greater than the number of digits.
-    if (specs.alt && specs.precision <= num_digits && abs_value != 0)
-      prefix_append(prefix, '0');
-    return write_int(out, num_digits, prefix, specs,
-                     [=](reserve_iterator<OutputIt> it) {
-                       return format_uint<3, Char>(it, abs_value, num_digits);
-                     });
-  }
-  case presentation_type::chr:
-    return write_char(out, static_cast<Char>(abs_value), specs);
-  default:
-    throw_format_error("invalid type specifier");
-  }
-  return out;
-}
-template <typename Char, typename OutputIt, typename T>
-FMT_CONSTEXPR FMT_NOINLINE auto write_int_noinline(
-    OutputIt out, write_int_arg<T> arg, const basic_format_specs<Char>& specs,
-    locale_ref loc) -> OutputIt {
-  return write_int(out, arg, specs, loc);
-}
-template <typename Char, typename OutputIt, typename T,
-          FMT_ENABLE_IF(is_integral<T>::value &&
-                        !std::is_same<T, bool>::value &&
-                        std::is_same<OutputIt, buffer_appender<Char>>::value)>
-FMT_CONSTEXPR FMT_INLINE auto write(OutputIt out, T value,
-                                    const basic_format_specs<Char>& specs,
-                                    locale_ref loc) -> OutputIt {
-  return write_int_noinline(out, make_write_int_arg(value, specs.sign), specs,
-                            loc);
-}
-// An inlined version of write used in format string compilation.
-template <typename Char, typename OutputIt, typename T,
-          FMT_ENABLE_IF(is_integral<T>::value &&
-                        !std::is_same<T, bool>::value &&
-                        !std::is_same<OutputIt, buffer_appender<Char>>::value)>
-FMT_CONSTEXPR FMT_INLINE auto write(OutputIt out, T value,
-                                    const basic_format_specs<Char>& specs,
-                                    locale_ref loc) -> OutputIt {
-  return write_int(out, make_write_int_arg(value, specs.sign), specs, loc);
-}
-
-// An output iterator that counts the number of objects written to it and
-// discards them.
-class counting_iterator {
- private:
-  size_t count_;
-
- public:
-  using iterator_category = std::output_iterator_tag;
-  using difference_type = std::ptrdiff_t;
-  using pointer = void;
-  using reference = void;
-  FMT_UNCHECKED_ITERATOR(counting_iterator);
-
-  struct value_type {
-    template <typename T> FMT_CONSTEXPR void operator=(const T&) {}
-  };
-
-  FMT_CONSTEXPR counting_iterator() : count_(0) {}
-
-  FMT_CONSTEXPR size_t count() const { return count_; }
-
-  FMT_CONSTEXPR counting_iterator& operator++() {
-    ++count_;
-    return *this;
-  }
-  FMT_CONSTEXPR counting_iterator operator++(int) {
-    auto it = *this;
-    ++*this;
-    return it;
-  }
-
-  FMT_CONSTEXPR friend counting_iterator operator+(counting_iterator it,
-                                                   difference_type n) {
-    it.count_ += static_cast<size_t>(n);
-    return it;
-  }
-
-  FMT_CONSTEXPR value_type operator*() const { return {}; }
-};
-
-template <typename Char, typename OutputIt>
-FMT_CONSTEXPR auto write(OutputIt out, basic_string_view<Char> s,
-                         const basic_format_specs<Char>& specs) -> OutputIt {
-  auto data = s.data();
-  auto size = s.size();
-  if (specs.precision >= 0 && to_unsigned(specs.precision) < size)
-    size = code_point_index(s, to_unsigned(specs.precision));
-  bool is_debug = specs.type == presentation_type::debug;
-  size_t width = 0;
-  if (specs.width != 0) {
-    if (is_debug)
-      width = write_escaped_string(counting_iterator{}, s).count();
-    else
-      width = compute_width(basic_string_view<Char>(data, size));
-  }
-  return write_padded(out, specs, size, width,
-                      [=](reserve_iterator<OutputIt> it) {
-                        if (is_debug) return write_escaped_string(it, s);
-                        return copy_str<Char>(data, data + size, it);
-                      });
-}
-template <typename Char, typename OutputIt>
-FMT_CONSTEXPR auto write(OutputIt out,
-                         basic_string_view<type_identity_t<Char>> s,
-                         const basic_format_specs<Char>& specs, locale_ref)
-    -> OutputIt {
-  check_string_type_spec(specs.type);
-  return write(out, s, specs);
-}
-template <typename Char, typename OutputIt>
-FMT_CONSTEXPR auto write(OutputIt out, const Char* s,
-                         const basic_format_specs<Char>& specs, locale_ref)
-    -> OutputIt {
-  return check_cstring_type_spec(specs.type)
-             ? write(out, basic_string_view<Char>(s), specs, {})
-             : write_ptr<Char>(out, bit_cast<uintptr_t>(s), &specs);
-}
-
-template <typename Char, typename OutputIt, typename T,
-          FMT_ENABLE_IF(is_integral<T>::value &&
-                        !std::is_same<T, bool>::value &&
-                        !std::is_same<T, Char>::value)>
-FMT_CONSTEXPR auto write(OutputIt out, T value) -> OutputIt {
-  auto abs_value = static_cast<uint32_or_64_or_128_t<T>>(value);
-  bool negative = is_negative(value);
-  // Don't do -abs_value since it trips unsigned-integer-overflow sanitizer.
-  if (negative) abs_value = ~abs_value + 1;
-  int num_digits = count_digits(abs_value);
-  auto size = (negative ? 1 : 0) + static_cast<size_t>(num_digits);
-  auto it = reserve(out, size);
-  if (auto ptr = to_pointer<Char>(it, size)) {
-    if (negative) *ptr++ = static_cast<Char>('-');
-    format_decimal<Char>(ptr, abs_value, num_digits);
-    return out;
-  }
-  if (negative) *it++ = static_cast<Char>('-');
-  it = format_decimal<Char>(it, abs_value, num_digits).end;
-  return base_iterator(out, it);
-}
-
-template <typename Char, typename OutputIt>
-FMT_CONSTEXPR20 auto write_nonfinite(OutputIt out, bool isnan,
-                                     basic_format_specs<Char> specs,
-                                     const float_specs& fspecs) -> OutputIt {
-  auto str =
-      isnan ? (fspecs.upper ? "NAN" : "nan") : (fspecs.upper ? "INF" : "inf");
-  constexpr size_t str_size = 3;
-  auto sign = fspecs.sign;
-  auto size = str_size + (sign ? 1 : 0);
-  // Replace '0'-padding with space for non-finite values.
-  const bool is_zero_fill =
-      specs.fill.size() == 1 && *specs.fill.data() == static_cast<Char>('0');
-  if (is_zero_fill) specs.fill[0] = static_cast<Char>(' ');
-  return write_padded(out, specs, size, [=](reserve_iterator<OutputIt> it) {
-    if (sign) *it++ = detail::sign<Char>(sign);
-    return copy_str<Char>(str, str + str_size, it);
-  });
-}
-
-// A decimal floating-point number significand * pow(10, exp).
-struct big_decimal_fp {
-  const char* significand;
-  int significand_size;
-  int exponent;
-};
-
-constexpr auto get_significand_size(const big_decimal_fp& f) -> int {
-  return f.significand_size;
-}
-template <typename T>
-inline auto get_significand_size(const dragonbox::decimal_fp<T>& f) -> int {
-  return count_digits(f.significand);
-}
-
-template <typename Char, typename OutputIt>
-constexpr auto write_significand(OutputIt out, const char* significand,
-                                 int significand_size) -> OutputIt {
-  return copy_str<Char>(significand, significand + significand_size, out);
-}
-template <typename Char, typename OutputIt, typename UInt>
-inline auto write_significand(OutputIt out, UInt significand,
-                              int significand_size) -> OutputIt {
-  return format_decimal<Char>(out, significand, significand_size).end;
-}
-template <typename Char, typename OutputIt, typename T, typename Grouping>
-FMT_CONSTEXPR20 auto write_significand(OutputIt out, T significand,
-                                       int significand_size, int exponent,
-                                       const Grouping& grouping) -> OutputIt {
-  if (!grouping.separator()) {
-    out = write_significand<Char>(out, significand, significand_size);
-    return detail::fill_n(out, exponent, static_cast<Char>('0'));
-  }
-  auto buffer = memory_buffer();
-  write_significand<char>(appender(buffer), significand, significand_size);
-  detail::fill_n(appender(buffer), exponent, '0');
-  return grouping.apply(out, string_view(buffer.data(), buffer.size()));
-}
-
-template <typename Char, typename UInt,
-          FMT_ENABLE_IF(std::is_integral<UInt>::value)>
-inline auto write_significand(Char* out, UInt significand, int significand_size,
-                              int integral_size, Char decimal_point) -> Char* {
-  if (!decimal_point)
-    return format_decimal(out, significand, significand_size).end;
-  out += significand_size + 1;
-  Char* end = out;
-  int floating_size = significand_size - integral_size;
-  for (int i = floating_size / 2; i > 0; --i) {
-    out -= 2;
-    copy2(out, digits2(static_cast<std::size_t>(significand % 100)));
-    significand /= 100;
-  }
-  if (floating_size % 2 != 0) {
-    *--out = static_cast<Char>('0' + significand % 10);
-    significand /= 10;
-  }
-  *--out = decimal_point;
-  format_decimal(out - integral_size, significand, integral_size);
-  return end;
-}
-
-template <typename OutputIt, typename UInt, typename Char,
-          FMT_ENABLE_IF(!std::is_pointer<remove_cvref_t<OutputIt>>::value)>
-inline auto write_significand(OutputIt out, UInt significand,
-                              int significand_size, int integral_size,
-                              Char decimal_point) -> OutputIt {
-  // Buffer is large enough to hold digits (digits10 + 1) and a decimal point.
-  Char buffer[digits10<UInt>() + 2];
-  auto end = write_significand(buffer, significand, significand_size,
-                               integral_size, decimal_point);
-  return detail::copy_str_noinline<Char>(buffer, end, out);
-}
-
-template <typename OutputIt, typename Char>
-FMT_CONSTEXPR auto write_significand(OutputIt out, const char* significand,
-                                     int significand_size, int integral_size,
-                                     Char decimal_point) -> OutputIt {
-  out = detail::copy_str_noinline<Char>(significand,
-                                        significand + integral_size, out);
-  if (!decimal_point) return out;
-  *out++ = decimal_point;
-  return detail::copy_str_noinline<Char>(significand + integral_size,
-                                         significand + significand_size, out);
-}
-
-template <typename OutputIt, typename Char, typename T, typename Grouping>
-FMT_CONSTEXPR20 auto write_significand(OutputIt out, T significand,
-                                       int significand_size, int integral_size,
-                                       Char decimal_point,
-                                       const Grouping& grouping) -> OutputIt {
-  if (!grouping.separator()) {
-    return write_significand(out, significand, significand_size, integral_size,
-                             decimal_point);
-  }
-  auto buffer = basic_memory_buffer<Char>();
-  write_significand(buffer_appender<Char>(buffer), significand,
-                    significand_size, integral_size, decimal_point);
-  grouping.apply(
-      out, basic_string_view<Char>(buffer.data(), to_unsigned(integral_size)));
-  return detail::copy_str_noinline<Char>(buffer.data() + integral_size,
-                                         buffer.end(), out);
-}
-
-template <typename OutputIt, typename DecimalFP, typename Char,
-          typename Grouping = digit_grouping<Char>>
-FMT_CONSTEXPR20 auto do_write_float(OutputIt out, const DecimalFP& f,
-                                    const basic_format_specs<Char>& specs,
-                                    float_specs fspecs, locale_ref loc)
-    -> OutputIt {
-  auto significand = f.significand;
-  int significand_size = get_significand_size(f);
-  const Char zero = static_cast<Char>('0');
-  auto sign = fspecs.sign;
-  size_t size = to_unsigned(significand_size) + (sign ? 1 : 0);
-  using iterator = reserve_iterator<OutputIt>;
-
-  Char decimal_point =
-      fspecs.locale ? detail::decimal_point<Char>(loc) : static_cast<Char>('.');
-
-  int output_exp = f.exponent + significand_size - 1;
-  auto use_exp_format = [=]() {
-    if (fspecs.format == float_format::exp) return true;
-    if (fspecs.format != float_format::general) return false;
-    // Use the fixed notation if the exponent is in [exp_lower, exp_upper),
-    // e.g. 0.0001 instead of 1e-04. Otherwise use the exponent notation.
-    const int exp_lower = -4, exp_upper = 16;
-    return output_exp < exp_lower ||
-           output_exp >= (fspecs.precision > 0 ? fspecs.precision : exp_upper);
-  };
-  if (use_exp_format()) {
-    int num_zeros = 0;
-    if (fspecs.showpoint) {
-      num_zeros = fspecs.precision - significand_size;
-      if (num_zeros < 0) num_zeros = 0;
-      size += to_unsigned(num_zeros);
-    } else if (significand_size == 1) {
-      decimal_point = Char();
-    }
-    auto abs_output_exp = output_exp >= 0 ? output_exp : -output_exp;
-    int exp_digits = 2;
-    if (abs_output_exp >= 100) exp_digits = abs_output_exp >= 1000 ? 4 : 3;
-
-    size += to_unsigned((decimal_point ? 1 : 0) + 2 + exp_digits);
-    char exp_char = fspecs.upper ? 'E' : 'e';
-    auto write = [=](iterator it) {
-      if (sign) *it++ = detail::sign<Char>(sign);
-      // Insert a decimal point after the first digit and add an exponent.
-      it = write_significand(it, significand, significand_size, 1,
-                             decimal_point);
-      if (num_zeros > 0) it = detail::fill_n(it, num_zeros, zero);
-      *it++ = static_cast<Char>(exp_char);
-      return write_exponent<Char>(output_exp, it);
-    };
-    return specs.width > 0 ? write_padded<align::right>(out, specs, size, write)
-                           : base_iterator(out, write(reserve(out, size)));
-  }
-
-  int exp = f.exponent + significand_size;
-  if (f.exponent >= 0) {
-    // 1234e5 -> 123400000[.0+]
-    size += to_unsigned(f.exponent);
-    int num_zeros = fspecs.precision - exp;
-    abort_fuzzing_if(num_zeros > 5000);
-    if (fspecs.showpoint) {
-      ++size;
-      if (num_zeros <= 0 && fspecs.format != float_format::fixed) num_zeros = 1;
-      if (num_zeros > 0) size += to_unsigned(num_zeros);
-    }
-    auto grouping = Grouping(loc, fspecs.locale);
-    size += to_unsigned(grouping.count_separators(exp));
-    return write_padded<align::right>(out, specs, size, [&](iterator it) {
-      if (sign) *it++ = detail::sign<Char>(sign);
-      it = write_significand<Char>(it, significand, significand_size,
-                                   f.exponent, grouping);
-      if (!fspecs.showpoint) return it;
-      *it++ = decimal_point;
-      return num_zeros > 0 ? detail::fill_n(it, num_zeros, zero) : it;
-    });
-  } else if (exp > 0) {
-    // 1234e-2 -> 12.34[0+]
-    int num_zeros = fspecs.showpoint ? fspecs.precision - significand_size : 0;
-    size += 1 + to_unsigned(num_zeros > 0 ? num_zeros : 0);
-    auto grouping = Grouping(loc, fspecs.locale);
-    size += to_unsigned(grouping.count_separators(significand_size));
-    return write_padded<align::right>(out, specs, size, [&](iterator it) {
-      if (sign) *it++ = detail::sign<Char>(sign);
-      it = write_significand(it, significand, significand_size, exp,
-                             decimal_point, grouping);
-      return num_zeros > 0 ? detail::fill_n(it, num_zeros, zero) : it;
-    });
-  }
-  // 1234e-6 -> 0.001234
-  int num_zeros = -exp;
-  if (significand_size == 0 && fspecs.precision >= 0 &&
-      fspecs.precision < num_zeros) {
-    num_zeros = fspecs.precision;
-  }
-  bool pointy = num_zeros != 0 || significand_size != 0 || fspecs.showpoint;
-  size += 1 + (pointy ? 1 : 0) + to_unsigned(num_zeros);
-  return write_padded<align::right>(out, specs, size, [&](iterator it) {
-    if (sign) *it++ = detail::sign<Char>(sign);
-    *it++ = zero;
-    if (!pointy) return it;
-    *it++ = decimal_point;
-    it = detail::fill_n(it, num_zeros, zero);
-    return write_significand<Char>(it, significand, significand_size);
-  });
-}
-
-template <typename Char> class fallback_digit_grouping {
- public:
-  constexpr fallback_digit_grouping(locale_ref, bool) {}
-
-  constexpr Char separator() const { return Char(); }
-
-  constexpr int count_separators(int) const { return 0; }
-
-  template <typename Out, typename C>
-  constexpr Out apply(Out out, basic_string_view<C>) const {
-    return out;
-  }
-};
-
-template <typename OutputIt, typename DecimalFP, typename Char>
-FMT_CONSTEXPR20 auto write_float(OutputIt out, const DecimalFP& f,
-                                 const basic_format_specs<Char>& specs,
-                                 float_specs fspecs, locale_ref loc)
-    -> OutputIt {
-  if (is_constant_evaluated()) {
-    return do_write_float<OutputIt, DecimalFP, Char,
-                          fallback_digit_grouping<Char>>(out, f, specs, fspecs,
-                                                         loc);
-  } else {
-    return do_write_float(out, f, specs, fspecs, loc);
-  }
-}
-
-template <typename T> constexpr bool isnan(T value) {
-  return !(value >= value);  // std::isnan doesn't support __float128.
-}
-
-template <typename T, typename Enable = void>
-struct has_isfinite : std::false_type {};
-
-template <typename T>
-struct has_isfinite<T, enable_if_t<sizeof(std::isfinite(T())) != 0>>
-    : std::true_type {};
-
-template <typename T, FMT_ENABLE_IF(std::is_floating_point<T>::value&&
-                                        has_isfinite<T>::value)>
-FMT_CONSTEXPR20 bool isfinite(T value) {
-  constexpr T inf = T(std::numeric_limits<double>::infinity());
-  if (is_constant_evaluated())
-    return !detail::isnan(value) && value != inf && value != -inf;
-  return std::isfinite(value);
-}
-template <typename T, FMT_ENABLE_IF(!has_isfinite<T>::value)>
-FMT_CONSTEXPR bool isfinite(T value) {
-  T inf = T(std::numeric_limits<double>::infinity());
-  // std::isfinite doesn't support __float128.
-  return !detail::isnan(value) && value != inf && value != -inf;
-}
-
-template <typename T, FMT_ENABLE_IF(is_floating_point<T>::value)>
-FMT_INLINE FMT_CONSTEXPR bool signbit(T value) {
-  if (is_constant_evaluated()) {
-#ifdef __cpp_if_constexpr
-    if constexpr (std::numeric_limits<double>::is_iec559) {
-      auto bits = detail::bit_cast<uint64_t>(static_cast<double>(value));
-      return (bits >> (num_bits<uint64_t>() - 1)) != 0;
-    }
-#endif
-  }
-  return std::signbit(static_cast<double>(value));
-}
-
-enum class round_direction { unknown, up, down };
-
-// Given the divisor (normally a power of 10), the remainder = v % divisor for
-// some number v and the error, returns whether v should be rounded up, down, or
-// whether the rounding direction can't be determined due to error.
-// error should be less than divisor / 2.
-FMT_CONSTEXPR inline round_direction get_round_direction(uint64_t divisor,
-                                                         uint64_t remainder,
-                                                         uint64_t error) {
-  FMT_ASSERT(remainder < divisor, "");  // divisor - remainder won't overflow.
-  FMT_ASSERT(error < divisor, "");      // divisor - error won't overflow.
-  FMT_ASSERT(error < divisor - error, "");  // error * 2 won't overflow.
-  // Round down if (remainder + error) * 2 <= divisor.
-  if (remainder <= divisor - remainder && error * 2 <= divisor - remainder * 2)
-    return round_direction::down;
-  // Round up if (remainder - error) * 2 >= divisor.
-  if (remainder >= error &&
-      remainder - error >= divisor - (remainder - error)) {
-    return round_direction::up;
-  }
-  return round_direction::unknown;
-}
-
-namespace digits {
-enum result {
-  more,  // Generate more digits.
-  done,  // Done generating digits.
-  error  // Digit generation cancelled due to an error.
-};
-}
-
-struct gen_digits_handler {
-  char* buf;
-  int size;
-  int precision;
-  int exp10;
-  bool fixed;
-
-  FMT_CONSTEXPR digits::result on_digit(char digit, uint64_t divisor,
-                                        uint64_t remainder, uint64_t error,
-                                        bool integral) {
-    FMT_ASSERT(remainder < divisor, "");
-    buf[size++] = digit;
-    if (!integral && error >= remainder) return digits::error;
-    if (size < precision) return digits::more;
-    if (!integral) {
-      // Check if error * 2 < divisor with overflow prevention.
-      // The check is not needed for the integral part because error = 1
-      // and divisor > (1 << 32) there.
-      if (error >= divisor || error >= divisor - error) return digits::error;
-    } else {
-      FMT_ASSERT(error == 1 && divisor > 2, "");
-    }
-    auto dir = get_round_direction(divisor, remainder, error);
-    if (dir != round_direction::up)
-      return dir == round_direction::down ? digits::done : digits::error;
-    ++buf[size - 1];
-    for (int i = size - 1; i > 0 && buf[i] > '9'; --i) {
-      buf[i] = '0';
-      ++buf[i - 1];
-    }
-    if (buf[0] > '9') {
-      buf[0] = '1';
-      if (fixed)
-        buf[size++] = '0';
-      else
-        ++exp10;
-    }
-    return digits::done;
-  }
-};
-
-inline FMT_CONSTEXPR20 void adjust_precision(int& precision, int exp10) {
-  // Adjust fixed precision by exponent because it is relative to decimal
-  // point.
-  if (exp10 > 0 && precision > max_value<int>() - exp10)
-    FMT_THROW(format_error("number is too big"));
-  precision += exp10;
-}
-
-// Generates output using the Grisu digit-gen algorithm.
-// error: the size of the region (lower, upper) outside of which numbers
-// definitely do not round to value (Delta in Grisu3).
-FMT_INLINE FMT_CONSTEXPR20 auto grisu_gen_digits(fp value, uint64_t error,
-                                                 int& exp,
-                                                 gen_digits_handler& handler)
-    -> digits::result {
-  const fp one(1ULL << -value.e, value.e);
-  // The integral part of scaled value (p1 in Grisu) = value / one. It cannot be
-  // zero because it contains a product of two 64-bit numbers with MSB set (due
-  // to normalization) - 1, shifted right by at most 60 bits.
-  auto integral = static_cast<uint32_t>(value.f >> -one.e);
-  FMT_ASSERT(integral != 0, "");
-  FMT_ASSERT(integral == value.f >> -one.e, "");
-  // The fractional part of scaled value (p2 in Grisu) c = value % one.
-  uint64_t fractional = value.f & (one.f - 1);
-  exp = count_digits(integral);  // kappa in Grisu.
-  // Non-fixed formats require at least one digit and no precision adjustment.
-  if (handler.fixed) {
-    adjust_precision(handler.precision, exp + handler.exp10);
-    // Check if precision is satisfied just by leading zeros, e.g.
-    // format("{:.2f}", 0.001) gives "0.00" without generating any digits.
-    if (handler.precision <= 0) {
-      if (handler.precision < 0) return digits::done;
-      // Divide by 10 to prevent overflow.
-      uint64_t divisor = data::power_of_10_64[exp - 1] << -one.e;
-      auto dir = get_round_direction(divisor, value.f / 10, error * 10);
-      if (dir == round_direction::unknown) return digits::error;
-      handler.buf[handler.size++] = dir == round_direction::up ? '1' : '0';
-      return digits::done;
-    }
-  }
-  // Generate digits for the integral part. This can produce up to 10 digits.
-  do {
-    uint32_t digit = 0;
-    auto divmod_integral = [&](uint32_t divisor) {
-      digit = integral / divisor;
-      integral %= divisor;
-    };
-    // This optimization by Milo Yip reduces the number of integer divisions by
-    // one per iteration.
-    switch (exp) {
-    case 10:
-      divmod_integral(1000000000);
-      break;
-    case 9:
-      divmod_integral(100000000);
-      break;
-    case 8:
-      divmod_integral(10000000);
-      break;
-    case 7:
-      divmod_integral(1000000);
-      break;
-    case 6:
-      divmod_integral(100000);
-      break;
-    case 5:
-      divmod_integral(10000);
-      break;
-    case 4:
-      divmod_integral(1000);
-      break;
-    case 3:
-      divmod_integral(100);
-      break;
-    case 2:
-      divmod_integral(10);
-      break;
-    case 1:
-      digit = integral;
-      integral = 0;
-      break;
-    default:
-      FMT_ASSERT(false, "invalid number of digits");
-    }
-    --exp;
-    auto remainder = (static_cast<uint64_t>(integral) << -one.e) + fractional;
-    auto result = handler.on_digit(static_cast<char>('0' + digit),
-                                   data::power_of_10_64[exp] << -one.e,
-                                   remainder, error, true);
-    if (result != digits::more) return result;
-  } while (exp > 0);
-  // Generate digits for the fractional part.
-  for (;;) {
-    fractional *= 10;
-    error *= 10;
-    char digit = static_cast<char>('0' + (fractional >> -one.e));
-    fractional &= one.f - 1;
-    --exp;
-    auto result = handler.on_digit(digit, one.f, fractional, error, false);
-    if (result != digits::more) return result;
-  }
-}
-
-class bigint {
- private:
-  // A bigint is stored as an array of bigits (big digits), with bigit at index
-  // 0 being the least significant one.
-  using bigit = uint32_t;
-  using double_bigit = uint64_t;
-  enum { bigits_capacity = 32 };
-  basic_memory_buffer<bigit, bigits_capacity> bigits_;
-  int exp_;
-
-  FMT_CONSTEXPR20 bigit operator[](int index) const {
-    return bigits_[to_unsigned(index)];
-  }
-  FMT_CONSTEXPR20 bigit& operator[](int index) {
-    return bigits_[to_unsigned(index)];
-  }
-
-  static constexpr const int bigit_bits = num_bits<bigit>();
-
-  friend struct formatter<bigint>;
-
-  FMT_CONSTEXPR20 void subtract_bigits(int index, bigit other, bigit& borrow) {
-    auto result = static_cast<double_bigit>((*this)[index]) - other - borrow;
-    (*this)[index] = static_cast<bigit>(result);
-    borrow = static_cast<bigit>(result >> (bigit_bits * 2 - 1));
-  }
-
-  FMT_CONSTEXPR20 void remove_leading_zeros() {
-    int num_bigits = static_cast<int>(bigits_.size()) - 1;
-    while (num_bigits > 0 && (*this)[num_bigits] == 0) --num_bigits;
-    bigits_.resize(to_unsigned(num_bigits + 1));
-  }
-
-  // Computes *this -= other assuming aligned bigints and *this >= other.
-  FMT_CONSTEXPR20 void subtract_aligned(const bigint& other) {
-    FMT_ASSERT(other.exp_ >= exp_, "unaligned bigints");
-    FMT_ASSERT(compare(*this, other) >= 0, "");
-    bigit borrow = 0;
-    int i = other.exp_ - exp_;
-    for (size_t j = 0, n = other.bigits_.size(); j != n; ++i, ++j)
-      subtract_bigits(i, other.bigits_[j], borrow);
-    while (borrow > 0) subtract_bigits(i, 0, borrow);
-    remove_leading_zeros();
-  }
-
-  FMT_CONSTEXPR20 void multiply(uint32_t value) {
-    const double_bigit wide_value = value;
-    bigit carry = 0;
-    for (size_t i = 0, n = bigits_.size(); i < n; ++i) {
-      double_bigit result = bigits_[i] * wide_value + carry;
-      bigits_[i] = static_cast<bigit>(result);
-      carry = static_cast<bigit>(result >> bigit_bits);
-    }
-    if (carry != 0) bigits_.push_back(carry);
-  }
-
-  template <typename UInt, FMT_ENABLE_IF(std::is_same<UInt, uint64_t>::value ||
-                                         std::is_same<UInt, uint128_t>::value)>
-  FMT_CONSTEXPR20 void multiply(UInt value) {
-    using half_uint =
-        conditional_t<std::is_same<UInt, uint128_t>::value, uint64_t, uint32_t>;
-    const int shift = num_bits<half_uint>() - bigit_bits;
-    const UInt lower = static_cast<half_uint>(value);
-    const UInt upper = value >> num_bits<half_uint>();
-    UInt carry = 0;
-    for (size_t i = 0, n = bigits_.size(); i < n; ++i) {
-      UInt result = lower * bigits_[i] + static_cast<bigit>(carry);
-      carry = (upper * bigits_[i] << shift) + (result >> bigit_bits) +
-              (carry >> bigit_bits);
-      bigits_[i] = static_cast<bigit>(result);
-    }
-    while (carry != 0) {
-      bigits_.push_back(static_cast<bigit>(carry));
-      carry >>= bigit_bits;
-    }
-  }
-
-  template <typename UInt, FMT_ENABLE_IF(std::is_same<UInt, uint64_t>::value ||
-                                         std::is_same<UInt, uint128_t>::value)>
-  FMT_CONSTEXPR20 void assign(UInt n) {
-    size_t num_bigits = 0;
-    do {
-      bigits_[num_bigits++] = static_cast<bigit>(n);
-      n >>= bigit_bits;
-    } while (n != 0);
-    bigits_.resize(num_bigits);
-    exp_ = 0;
-  }
-
- public:
-  FMT_CONSTEXPR20 bigint() : exp_(0) {}
-  explicit bigint(uint64_t n) { assign(n); }
-
-  bigint(const bigint&) = delete;
-  void operator=(const bigint&) = delete;
-
-  FMT_CONSTEXPR20 void assign(const bigint& other) {
-    auto size = other.bigits_.size();
-    bigits_.resize(size);
-    auto data = other.bigits_.data();
-    std::copy(data, data + size, make_checked(bigits_.data(), size));
-    exp_ = other.exp_;
-  }
-
-  template <typename Int> FMT_CONSTEXPR20 void operator=(Int n) {
-    FMT_ASSERT(n > 0, "");
-    assign(uint64_or_128_t<Int>(n));
-  }
-
-  FMT_CONSTEXPR20 int num_bigits() const {
-    return static_cast<int>(bigits_.size()) + exp_;
-  }
-
-  FMT_NOINLINE FMT_CONSTEXPR20 bigint& operator<<=(int shift) {
-    FMT_ASSERT(shift >= 0, "");
-    exp_ += shift / bigit_bits;
-    shift %= bigit_bits;
-    if (shift == 0) return *this;
-    bigit carry = 0;
-    for (size_t i = 0, n = bigits_.size(); i < n; ++i) {
-      bigit c = bigits_[i] >> (bigit_bits - shift);
-      bigits_[i] = (bigits_[i] << shift) + carry;
-      carry = c;
-    }
-    if (carry != 0) bigits_.push_back(carry);
-    return *this;
-  }
-
-  template <typename Int> FMT_CONSTEXPR20 bigint& operator*=(Int value) {
-    FMT_ASSERT(value > 0, "");
-    multiply(uint32_or_64_or_128_t<Int>(value));
-    return *this;
-  }
-
-  friend FMT_CONSTEXPR20 int compare(const bigint& lhs, const bigint& rhs) {
-    int num_lhs_bigits = lhs.num_bigits(), num_rhs_bigits = rhs.num_bigits();
-    if (num_lhs_bigits != num_rhs_bigits)
-      return num_lhs_bigits > num_rhs_bigits ? 1 : -1;
-    int i = static_cast<int>(lhs.bigits_.size()) - 1;
-    int j = static_cast<int>(rhs.bigits_.size()) - 1;
-    int end = i - j;
-    if (end < 0) end = 0;
-    for (; i >= end; --i, --j) {
-      bigit lhs_bigit = lhs[i], rhs_bigit = rhs[j];
-      if (lhs_bigit != rhs_bigit) return lhs_bigit > rhs_bigit ? 1 : -1;
-    }
-    if (i != j) return i > j ? 1 : -1;
-    return 0;
-  }
-
-  // Returns compare(lhs1 + lhs2, rhs).
-  friend FMT_CONSTEXPR20 int add_compare(const bigint& lhs1, const bigint& lhs2,
-                                         const bigint& rhs) {
-    auto minimum = [](int a, int b) { return a < b ? a : b; };
-    auto maximum = [](int a, int b) { return a > b ? a : b; };
-    int max_lhs_bigits = maximum(lhs1.num_bigits(), lhs2.num_bigits());
-    int num_rhs_bigits = rhs.num_bigits();
-    if (max_lhs_bigits + 1 < num_rhs_bigits) return -1;
-    if (max_lhs_bigits > num_rhs_bigits) return 1;
-    auto get_bigit = [](const bigint& n, int i) -> bigit {
-      return i >= n.exp_ && i < n.num_bigits() ? n[i - n.exp_] : 0;
-    };
-    double_bigit borrow = 0;
-    int min_exp = minimum(minimum(lhs1.exp_, lhs2.exp_), rhs.exp_);
-    for (int i = num_rhs_bigits - 1; i >= min_exp; --i) {
-      double_bigit sum =
-          static_cast<double_bigit>(get_bigit(lhs1, i)) + get_bigit(lhs2, i);
-      bigit rhs_bigit = get_bigit(rhs, i);
-      if (sum > rhs_bigit + borrow) return 1;
-      borrow = rhs_bigit + borrow - sum;
-      if (borrow > 1) return -1;
-      borrow <<= bigit_bits;
-    }
-    return borrow != 0 ? -1 : 0;
-  }
-
-  // Assigns pow(10, exp) to this bigint.
-  FMT_CONSTEXPR20 void assign_pow10(int exp) {
-    FMT_ASSERT(exp >= 0, "");
-    if (exp == 0) return *this = 1;
-    // Find the top bit.
-    int bitmask = 1;
-    while (exp >= bitmask) bitmask <<= 1;
-    bitmask >>= 1;
-    // pow(10, exp) = pow(5, exp) * pow(2, exp). First compute pow(5, exp) by
-    // repeated squaring and multiplication.
-    *this = 5;
-    bitmask >>= 1;
-    while (bitmask != 0) {
-      square();
-      if ((exp & bitmask) != 0) *this *= 5;
-      bitmask >>= 1;
-    }
-    *this <<= exp;  // Multiply by pow(2, exp) by shifting.
-  }
-
-  FMT_CONSTEXPR20 void square() {
-    int num_bigits = static_cast<int>(bigits_.size());
-    int num_result_bigits = 2 * num_bigits;
-    basic_memory_buffer<bigit, bigits_capacity> n(std::move(bigits_));
-    bigits_.resize(to_unsigned(num_result_bigits));
-    auto sum = uint128_t();
-    for (int bigit_index = 0; bigit_index < num_bigits; ++bigit_index) {
-      // Compute bigit at position bigit_index of the result by adding
-      // cross-product terms n[i] * n[j] such that i + j == bigit_index.
-      for (int i = 0, j = bigit_index; j >= 0; ++i, --j) {
-        // Most terms are multiplied twice which can be optimized in the future.
-        sum += static_cast<double_bigit>(n[i]) * n[j];
-      }
-      (*this)[bigit_index] = static_cast<bigit>(sum);
-      sum >>= num_bits<bigit>();  // Compute the carry.
-    }
-    // Do the same for the top half.
-    for (int bigit_index = num_bigits; bigit_index < num_result_bigits;
-         ++bigit_index) {
-      for (int j = num_bigits - 1, i = bigit_index - j; i < num_bigits;)
-        sum += static_cast<double_bigit>(n[i++]) * n[j--];
-      (*this)[bigit_index] = static_cast<bigit>(sum);
-      sum >>= num_bits<bigit>();
-    }
-    remove_leading_zeros();
-    exp_ *= 2;
-  }
-
-  // If this bigint has a bigger exponent than other, adds trailing zero to make
-  // exponents equal. This simplifies some operations such as subtraction.
-  FMT_CONSTEXPR20 void align(const bigint& other) {
-    int exp_difference = exp_ - other.exp_;
-    if (exp_difference <= 0) return;
-    int num_bigits = static_cast<int>(bigits_.size());
-    bigits_.resize(to_unsigned(num_bigits + exp_difference));
-    for (int i = num_bigits - 1, j = i + exp_difference; i >= 0; --i, --j)
-      bigits_[j] = bigits_[i];
-    std::uninitialized_fill_n(bigits_.data(), exp_difference, 0);
-    exp_ -= exp_difference;
-  }
-
-  // Divides this bignum by divisor, assigning the remainder to this and
-  // returning the quotient.
-  FMT_CONSTEXPR20 int divmod_assign(const bigint& divisor) {
-    FMT_ASSERT(this != &divisor, "");
-    if (compare(*this, divisor) < 0) return 0;
-    FMT_ASSERT(divisor.bigits_[divisor.bigits_.size() - 1u] != 0, "");
-    align(divisor);
-    int quotient = 0;
-    do {
-      subtract_aligned(divisor);
-      ++quotient;
-    } while (compare(*this, divisor) >= 0);
-    return quotient;
-  }
-};
-
-// format_dragon flags.
-enum dragon {
-  predecessor_closer = 1,
-  fixup = 2,  // Run fixup to correct exp10 which can be off by one.
-  fixed = 4,
-};
-
-// Formats a floating-point number using a variation of the Fixed-Precision
-// Positive Floating-Point Printout ((FPP)^2) algorithm by Steele & White:
-// https://fmt.dev/papers/p372-steele.pdf.
-FMT_CONSTEXPR20 inline void format_dragon(basic_fp<uint128_t> value,
-                                          unsigned flags, int num_digits,
-                                          buffer<char>& buf, int& exp10) {
-  bigint numerator;    // 2 * R in (FPP)^2.
-  bigint denominator;  // 2 * S in (FPP)^2.
-  // lower and upper are differences between value and corresponding boundaries.
-  bigint lower;             // (M^- in (FPP)^2).
-  bigint upper_store;       // upper's value if different from lower.
-  bigint* upper = nullptr;  // (M^+ in (FPP)^2).
-  // Shift numerator and denominator by an extra bit or two (if lower boundary
-  // is closer) to make lower and upper integers. This eliminates multiplication
-  // by 2 during later computations.
-  bool is_predecessor_closer = (flags & dragon::predecessor_closer) != 0;
-  int shift = is_predecessor_closer ? 2 : 1;
-  if (value.e >= 0) {
-    numerator = value.f;
-    numerator <<= value.e + shift;
-    lower = 1;
-    lower <<= value.e;
-    if (is_predecessor_closer) {
-      upper_store = 1;
-      upper_store <<= value.e + 1;
-      upper = &upper_store;
-    }
-    denominator.assign_pow10(exp10);
-    denominator <<= shift;
-  } else if (exp10 < 0) {
-    numerator.assign_pow10(-exp10);
-    lower.assign(numerator);
-    if (is_predecessor_closer) {
-      upper_store.assign(numerator);
-      upper_store <<= 1;
-      upper = &upper_store;
-    }
-    numerator *= value.f;
-    numerator <<= shift;
-    denominator = 1;
-    denominator <<= shift - value.e;
-  } else {
-    numerator = value.f;
-    numerator <<= shift;
-    denominator.assign_pow10(exp10);
-    denominator <<= shift - value.e;
-    lower = 1;
-    if (is_predecessor_closer) {
-      upper_store = 1ULL << 1;
-      upper = &upper_store;
-    }
-  }
-  int even = static_cast<int>((value.f & 1) == 0);
-  if (!upper) upper = &lower;
-  if ((flags & dragon::fixup) != 0) {
-    if (add_compare(numerator, *upper, denominator) + even <= 0) {
-      --exp10;
-      numerator *= 10;
-      if (num_digits < 0) {
-        lower *= 10;
-        if (upper != &lower) *upper *= 10;
-      }
-    }
-    if ((flags & dragon::fixed) != 0) adjust_precision(num_digits, exp10 + 1);
-  }
-  // Invariant: value == (numerator / denominator) * pow(10, exp10).
-  if (num_digits < 0) {
-    // Generate the shortest representation.
-    num_digits = 0;
-    char* data = buf.data();
-    for (;;) {
-      int digit = numerator.divmod_assign(denominator);
-      bool low = compare(numerator, lower) - even < 0;  // numerator <[=] lower.
-      // numerator + upper >[=] pow10:
-      bool high = add_compare(numerator, *upper, denominator) + even > 0;
-      data[num_digits++] = static_cast<char>('0' + digit);
-      if (low || high) {
-        if (!low) {
-          ++data[num_digits - 1];
-        } else if (high) {
-          int result = add_compare(numerator, numerator, denominator);
-          // Round half to even.
-          if (result > 0 || (result == 0 && (digit % 2) != 0))
-            ++data[num_digits - 1];
-        }
-        buf.try_resize(to_unsigned(num_digits));
-        exp10 -= num_digits - 1;
-        return;
-      }
-      numerator *= 10;
-      lower *= 10;
-      if (upper != &lower) *upper *= 10;
-    }
-  }
-  // Generate the given number of digits.
-  exp10 -= num_digits - 1;
-  if (num_digits == 0) {
-    denominator *= 10;
-    auto digit = add_compare(numerator, numerator, denominator) > 0 ? '1' : '0';
-    buf.push_back(digit);
-    return;
-  }
-  buf.try_resize(to_unsigned(num_digits));
-  for (int i = 0; i < num_digits - 1; ++i) {
-    int digit = numerator.divmod_assign(denominator);
-    buf[i] = static_cast<char>('0' + digit);
-    numerator *= 10;
-  }
-  int digit = numerator.divmod_assign(denominator);
-  auto result = add_compare(numerator, numerator, denominator);
-  if (result > 0 || (result == 0 && (digit % 2) != 0)) {
-    if (digit == 9) {
-      const auto overflow = '0' + 10;
-      buf[num_digits - 1] = overflow;
-      // Propagate the carry.
-      for (int i = num_digits - 1; i > 0 && buf[i] == overflow; --i) {
-        buf[i] = '0';
-        ++buf[i - 1];
-      }
-      if (buf[0] == overflow) {
-        buf[0] = '1';
-        ++exp10;
-      }
-      return;
-    }
-    ++digit;
-  }
-  buf[num_digits - 1] = static_cast<char>('0' + digit);
-}
-
-template <typename Float>
-FMT_CONSTEXPR20 auto format_float(Float value, int precision, float_specs specs,
-                                  buffer<char>& buf) -> int {
-  // float is passed as double to reduce the number of instantiations.
-  static_assert(!std::is_same<Float, float>::value, "");
-  FMT_ASSERT(value >= 0, "value is negative");
-  auto converted_value = convert_float(value);
-
-  const bool fixed = specs.format == float_format::fixed;
-  if (value <= 0) {  // <= instead of == to silence a warning.
-    if (precision <= 0 || !fixed) {
-      buf.push_back('0');
-      return 0;
-    }
-    buf.try_resize(to_unsigned(precision));
-    fill_n(buf.data(), precision, '0');
-    return -precision;
-  }
-
-  int exp = 0;
-  bool use_dragon = true;
-  unsigned dragon_flags = 0;
-  if (!is_fast_float<Float>()) {
-    const auto inv_log2_10 = 0.3010299956639812;  // 1 / log2(10)
-    using info = dragonbox::float_info<decltype(converted_value)>;
-    const auto f = basic_fp<typename info::carrier_uint>(converted_value);
-    // Compute exp, an approximate power of 10, such that
-    //   10^(exp - 1) <= value < 10^exp or 10^exp <= value < 10^(exp + 1).
-    // This is based on log10(value) == log2(value) / log2(10) and approximation
-    // of log2(value) by e + num_fraction_bits idea from double-conversion.
-    exp = static_cast<int>(
-        std::ceil((f.e + count_digits<1>(f.f) - 1) * inv_log2_10 - 1e-10));
-    dragon_flags = dragon::fixup;
-  } else if (!is_constant_evaluated() && precision < 0) {
-    // Use Dragonbox for the shortest format.
-    if (specs.binary32) {
-      auto dec = dragonbox::to_decimal(static_cast<float>(value));
-      write<char>(buffer_appender<char>(buf), dec.significand);
-      return dec.exponent;
-    }
-    auto dec = dragonbox::to_decimal(static_cast<double>(value));
-    write<char>(buffer_appender<char>(buf), dec.significand);
-    return dec.exponent;
-  } else {
-    // Use Grisu + Dragon4 for the given precision:
-    // https://www.cs.tufts.edu/~nr/cs257/archive/florian-loitsch/printf.pdf.
-    const int min_exp = -60;  // alpha in Grisu.
-    int cached_exp10 = 0;     // K in Grisu.
-    fp normalized = normalize(fp(converted_value));
-    const auto cached_pow = get_cached_power(
-        min_exp - (normalized.e + fp::num_significand_bits), cached_exp10);
-    normalized = normalized * cached_pow;
-    gen_digits_handler handler{buf.data(), 0, precision, -cached_exp10, fixed};
-    if (grisu_gen_digits(normalized, 1, exp, handler) != digits::error &&
-        !is_constant_evaluated()) {
-      exp += handler.exp10;
-      buf.try_resize(to_unsigned(handler.size));
-      use_dragon = false;
-    } else {
-      exp += handler.size - cached_exp10 - 1;
-      precision = handler.precision;
-    }
-  }
-  if (use_dragon) {
-    auto f = basic_fp<uint128_t>();
-    bool is_predecessor_closer = specs.binary32
-                                     ? f.assign(static_cast<float>(value))
-                                     : f.assign(converted_value);
-    if (is_predecessor_closer) dragon_flags |= dragon::predecessor_closer;
-    if (fixed) dragon_flags |= dragon::fixed;
-    // Limit precision to the maximum possible number of significant digits in
-    // an IEEE754 double because we don't need to generate zeros.
-    const int max_double_digits = 767;
-    if (precision > max_double_digits) precision = max_double_digits;
-    format_dragon(f, dragon_flags, precision, buf, exp);
-  }
-  if (!fixed && !specs.showpoint) {
-    // Remove trailing zeros.
-    auto num_digits = buf.size();
-    while (num_digits > 0 && buf[num_digits - 1] == '0') {
-      --num_digits;
-      ++exp;
-    }
-    buf.try_resize(num_digits);
-  }
-  return exp;
-}
-
-template <typename Char, typename OutputIt, typename T,
-          FMT_ENABLE_IF(is_floating_point<T>::value)>
-FMT_CONSTEXPR20 auto write(OutputIt out, T value,
-                           basic_format_specs<Char> specs, locale_ref loc = {})
-    -> OutputIt {
-  if (const_check(!is_supported_floating_point(value))) return out;
-  float_specs fspecs = parse_float_type_spec(specs);
-  fspecs.sign = specs.sign;
-  if (detail::signbit(value)) {  // value < 0 is false for NaN so use signbit.
-    fspecs.sign = sign::minus;
-    value = -value;
-  } else if (fspecs.sign == sign::minus) {
-    fspecs.sign = sign::none;
-  }
-
-  if (!detail::isfinite(value))
-    return write_nonfinite(out, detail::isnan(value), specs, fspecs);
-
-  if (specs.align == align::numeric && fspecs.sign) {
-    auto it = reserve(out, 1);
-    *it++ = detail::sign<Char>(fspecs.sign);
-    out = base_iterator(out, it);
-    fspecs.sign = sign::none;
-    if (specs.width != 0) --specs.width;
-  }
-
-  memory_buffer buffer;
-  if (fspecs.format == float_format::hex) {
-    if (fspecs.sign) buffer.push_back(detail::sign<char>(fspecs.sign));
-    snprintf_float(convert_float(value), specs.precision, fspecs, buffer);
-    return write_bytes<align::right>(out, {buffer.data(), buffer.size()},
-                                     specs);
-  }
-  int precision = specs.precision >= 0 || specs.type == presentation_type::none
-                      ? specs.precision
-                      : 6;
-  if (fspecs.format == float_format::exp) {
-    if (precision == max_value<int>())
-      throw_format_error("number is too big");
-    else
-      ++precision;
-  } else if (fspecs.format != float_format::fixed && precision == 0) {
-    precision = 1;
-  }
-  if (const_check(std::is_same<T, float>())) fspecs.binary32 = true;
-  int exp = format_float(convert_float(value), precision, fspecs, buffer);
-  fspecs.precision = precision;
-  auto f = big_decimal_fp{buffer.data(), static_cast<int>(buffer.size()), exp};
-  return write_float(out, f, specs, fspecs, loc);
-}
-
-template <typename Char, typename OutputIt, typename T,
-          FMT_ENABLE_IF(is_fast_float<T>::value)>
-FMT_CONSTEXPR20 auto write(OutputIt out, T value) -> OutputIt {
-  if (is_constant_evaluated())
-    return write(out, value, basic_format_specs<Char>());
-  if (const_check(!is_supported_floating_point(value))) return out;
-
-  auto fspecs = float_specs();
-  if (detail::signbit(value)) {
-    fspecs.sign = sign::minus;
-    value = -value;
-  }
-
-  constexpr auto specs = basic_format_specs<Char>();
-  using floaty = conditional_t<std::is_same<T, long double>::value, double, T>;
-  using fmt_uint = typename dragonbox::float_info<floaty>::carrier_uint;
-  fmt_uint mask = exponent_mask<floaty>();
-  if ((bit_cast<fmt_uint>(value) & mask) == mask)
-    return write_nonfinite(out, std::isnan(value), specs, fspecs);
-
-  auto dec = dragonbox::to_decimal(static_cast<floaty>(value));
-  return write_float(out, dec, specs, fspecs, {});
-}
-
-template <typename Char, typename OutputIt, typename T,
-          FMT_ENABLE_IF(is_floating_point<T>::value &&
-                        !is_fast_float<T>::value)>
-inline auto write(OutputIt out, T value) -> OutputIt {
-  return write(out, value, basic_format_specs<Char>());
-}
-
-template <typename Char, typename OutputIt>
-auto write(OutputIt out, monostate, basic_format_specs<Char> = {},
-           locale_ref = {}) -> OutputIt {
-  FMT_ASSERT(false, "");
-  return out;
-}
-
-template <typename Char, typename OutputIt>
-FMT_CONSTEXPR auto write(OutputIt out, basic_string_view<Char> value)
-    -> OutputIt {
-  auto it = reserve(out, value.size());
-  it = copy_str_noinline<Char>(value.begin(), value.end(), it);
-  return base_iterator(out, it);
-}
-
-template <typename Char, typename OutputIt, typename T,
-          FMT_ENABLE_IF(is_string<T>::value)>
-constexpr auto write(OutputIt out, const T& value) -> OutputIt {
-  return write<Char>(out, to_string_view(value));
-}
-
-// FMT_ENABLE_IF() condition separated to workaround an MSVC bug.
-template <
-    typename Char, typename OutputIt, typename T,
-    bool check =
-        std::is_enum<T>::value && !std::is_same<T, Char>::value &&
-        mapped_type_constant<T, basic_format_context<OutputIt, Char>>::value !=
-            type::custom_type,
-    FMT_ENABLE_IF(check)>
-FMT_CONSTEXPR auto write(OutputIt out, T value) -> OutputIt {
-  return write<Char>(out, static_cast<underlying_t<T>>(value));
-}
-
-template <typename Char, typename OutputIt, typename T,
-          FMT_ENABLE_IF(std::is_same<T, bool>::value)>
-FMT_CONSTEXPR auto write(OutputIt out, T value,
-                         const basic_format_specs<Char>& specs = {},
-                         locale_ref = {}) -> OutputIt {
-  return specs.type != presentation_type::none &&
-                 specs.type != presentation_type::string
-             ? write(out, value ? 1 : 0, specs, {})
-             : write_bytes(out, value ? "true" : "false", specs);
-}
-
-template <typename Char, typename OutputIt>
-FMT_CONSTEXPR auto write(OutputIt out, Char value) -> OutputIt {
-  auto it = reserve(out, 1);
-  *it++ = value;
-  return base_iterator(out, it);
-}
-
-template <typename Char, typename OutputIt>
-FMT_CONSTEXPR_CHAR_TRAITS auto write(OutputIt out, const Char* value)
-    -> OutputIt {
-  if (!value) {
-    throw_format_error("string pointer is null");
-  } else {
-    out = write(out, basic_string_view<Char>(value));
-  }
-  return out;
-}
-
-template <typename Char, typename OutputIt, typename T,
-          FMT_ENABLE_IF(std::is_same<T, void>::value)>
-auto write(OutputIt out, const T* value,
-           const basic_format_specs<Char>& specs = {}, locale_ref = {})
-    -> OutputIt {
-  check_pointer_type_spec(specs.type, error_handler());
-  return write_ptr<Char>(out, bit_cast<uintptr_t>(value), &specs);
-}
-
-// A write overload that handles implicit conversions.
-template <typename Char, typename OutputIt, typename T,
-          typename Context = basic_format_context<OutputIt, Char>>
-FMT_CONSTEXPR auto write(OutputIt out, const T& value) -> enable_if_t<
-    std::is_class<T>::value && !is_string<T>::value &&
-        !is_floating_point<T>::value && !std::is_same<T, Char>::value &&
-        !std::is_same<const T&,
-                      decltype(arg_mapper<Context>().map(value))>::value,
-    OutputIt> {
-  return write<Char>(out, arg_mapper<Context>().map(value));
-}
-
-template <typename Char, typename OutputIt, typename T,
-          typename Context = basic_format_context<OutputIt, Char>>
-FMT_CONSTEXPR auto write(OutputIt out, const T& value)
-    -> enable_if_t<mapped_type_constant<T, Context>::value == type::custom_type,
-                   OutputIt> {
-  using formatter_type =
-      conditional_t<has_formatter<T, Context>::value,
-                    typename Context::template formatter_type<T>,
-                    fallback_formatter<T, Char>>;
-  auto ctx = Context(out, {}, {});
-  return formatter_type().format(value, ctx);
-}
-
-// An argument visitor that formats the argument and writes it via the output
-// iterator. It's a class and not a generic lambda for compatibility with C++11.
-template <typename Char> struct default_arg_formatter {
-  using iterator = buffer_appender<Char>;
-  using context = buffer_context<Char>;
-
-  iterator out;
-  basic_format_args<context> args;
-  locale_ref loc;
-
-  template <typename T> auto operator()(T value) -> iterator {
-    return write<Char>(out, value);
-  }
-  auto operator()(typename basic_format_arg<context>::handle h) -> iterator {
-    basic_format_parse_context<Char> parse_ctx({});
-    context format_ctx(out, args, loc);
-    h.format(parse_ctx, format_ctx);
-    return format_ctx.out();
-  }
-};
-
-template <typename Char> struct arg_formatter {
-  using iterator = buffer_appender<Char>;
-  using context = buffer_context<Char>;
-
-  iterator out;
-  const basic_format_specs<Char>& specs;
-  locale_ref locale;
-
-  template <typename T>
-  FMT_CONSTEXPR FMT_INLINE auto operator()(T value) -> iterator {
-    return detail::write(out, value, specs, locale);
-  }
-  auto operator()(typename basic_format_arg<context>::handle) -> iterator {
-    // User-defined types are handled separately because they require access
-    // to the parse context.
-    return out;
-  }
-};
-
-template <typename Char> struct custom_formatter {
-  basic_format_parse_context<Char>& parse_ctx;
-  buffer_context<Char>& ctx;
-
-  void operator()(
-      typename basic_format_arg<buffer_context<Char>>::handle h) const {
-    h.format(parse_ctx, ctx);
-  }
-  template <typename T> void operator()(T) const {}
-};
-
-template <typename T>
-using is_integer =
-    bool_constant<is_integral<T>::value && !std::is_same<T, bool>::value &&
-                  !std::is_same<T, char>::value &&
-                  !std::is_same<T, wchar_t>::value>;
-
-template <typename ErrorHandler> class width_checker {
- public:
-  explicit FMT_CONSTEXPR width_checker(ErrorHandler& eh) : handler_(eh) {}
-
-  template <typename T, FMT_ENABLE_IF(is_integer<T>::value)>
-  FMT_CONSTEXPR auto operator()(T value) -> unsigned long long {
-    if (is_negative(value)) handler_.on_error("negative width");
-    return static_cast<unsigned long long>(value);
-  }
-
-  template <typename T, FMT_ENABLE_IF(!is_integer<T>::value)>
-  FMT_CONSTEXPR auto operator()(T) -> unsigned long long {
-    handler_.on_error("width is not integer");
-    return 0;
-  }
-
- private:
-  ErrorHandler& handler_;
-};
-
-template <typename ErrorHandler> class precision_checker {
- public:
-  explicit FMT_CONSTEXPR precision_checker(ErrorHandler& eh) : handler_(eh) {}
-
-  template <typename T, FMT_ENABLE_IF(is_integer<T>::value)>
-  FMT_CONSTEXPR auto operator()(T value) -> unsigned long long {
-    if (is_negative(value)) handler_.on_error("negative precision");
-    return static_cast<unsigned long long>(value);
-  }
-
-  template <typename T, FMT_ENABLE_IF(!is_integer<T>::value)>
-  FMT_CONSTEXPR auto operator()(T) -> unsigned long long {
-    handler_.on_error("precision is not integer");
-    return 0;
-  }
-
- private:
-  ErrorHandler& handler_;
-};
-
-template <template <typename> class Handler, typename FormatArg,
-          typename ErrorHandler>
-FMT_CONSTEXPR auto get_dynamic_spec(FormatArg arg, ErrorHandler eh) -> int {
-  unsigned long long value = visit_format_arg(Handler<ErrorHandler>(eh), arg);
-  if (value > to_unsigned(max_value<int>())) eh.on_error("number is too big");
-  return static_cast<int>(value);
-}
-
-template <typename Context, typename ID>
-FMT_CONSTEXPR auto get_arg(Context& ctx, ID id) ->
-    typename Context::format_arg {
-  auto arg = ctx.arg(id);
-  if (!arg) ctx.on_error("argument not found");
-  return arg;
-}
-
-// The standard format specifier handler with checking.
-template <typename Char> class specs_handler : public specs_setter<Char> {
- private:
-  basic_format_parse_context<Char>& parse_context_;
-  buffer_context<Char>& context_;
-
-  // This is only needed for compatibility with gcc 4.4.
-  using format_arg = basic_format_arg<buffer_context<Char>>;
-
-  FMT_CONSTEXPR auto get_arg(auto_id) -> format_arg {
-    return detail::get_arg(context_, parse_context_.next_arg_id());
-  }
-
-  FMT_CONSTEXPR auto get_arg(int arg_id) -> format_arg {
-    parse_context_.check_arg_id(arg_id);
-    return detail::get_arg(context_, arg_id);
-  }
-
-  FMT_CONSTEXPR auto get_arg(basic_string_view<Char> arg_id) -> format_arg {
-    parse_context_.check_arg_id(arg_id);
-    return detail::get_arg(context_, arg_id);
-  }
-
- public:
-  FMT_CONSTEXPR specs_handler(basic_format_specs<Char>& specs,
-                              basic_format_parse_context<Char>& parse_ctx,
-                              buffer_context<Char>& ctx)
-      : specs_setter<Char>(specs), parse_context_(parse_ctx), context_(ctx) {}
-
-  template <typename Id> FMT_CONSTEXPR void on_dynamic_width(Id arg_id) {
-    this->specs_.width = get_dynamic_spec<width_checker>(
-        get_arg(arg_id), context_.error_handler());
-  }
-
-  template <typename Id> FMT_CONSTEXPR void on_dynamic_precision(Id arg_id) {
-    this->specs_.precision = get_dynamic_spec<precision_checker>(
-        get_arg(arg_id), context_.error_handler());
-  }
-
-  void on_error(const char* message) { context_.on_error(message); }
-};
-
-template <template <typename> class Handler, typename Context>
-FMT_CONSTEXPR void handle_dynamic_spec(int& value,
-                                       arg_ref<typename Context::char_type> ref,
-                                       Context& ctx) {
-  switch (ref.kind) {
-  case arg_id_kind::none:
-    break;
-  case arg_id_kind::index:
-    value = detail::get_dynamic_spec<Handler>(ctx.arg(ref.val.index),
-                                              ctx.error_handler());
-    break;
-  case arg_id_kind::name:
-    value = detail::get_dynamic_spec<Handler>(ctx.arg(ref.val.name),
-                                              ctx.error_handler());
-    break;
-  }
-}
-
-#if FMT_USE_USER_DEFINED_LITERALS
-template <typename Char> struct udl_formatter {
-  basic_string_view<Char> str;
-
-  template <typename... T>
-  auto operator()(T&&... args) const -> std::basic_string<Char> {
-    return vformat(str, fmt::make_format_args<buffer_context<Char>>(args...));
-  }
-};
-
-#  if FMT_USE_NONTYPE_TEMPLATE_ARGS
-template <typename T, typename Char, size_t N,
-          fmt::detail_exported::fixed_string<Char, N> Str>
-struct statically_named_arg : view {
-  static constexpr auto name = Str.data;
-
-  const T& value;
-  statically_named_arg(const T& v) : value(v) {}
-};
-
-template <typename T, typename Char, size_t N,
-          fmt::detail_exported::fixed_string<Char, N> Str>
-struct is_named_arg<statically_named_arg<T, Char, N, Str>> : std::true_type {};
-
-template <typename T, typename Char, size_t N,
-          fmt::detail_exported::fixed_string<Char, N> Str>
-struct is_statically_named_arg<statically_named_arg<T, Char, N, Str>>
-    : std::true_type {};
-
-template <typename Char, size_t N,
-          fmt::detail_exported::fixed_string<Char, N> Str>
-struct udl_arg {
-  template <typename T> auto operator=(T&& value) const {
-    return statically_named_arg<T, Char, N, Str>(std::forward<T>(value));
-  }
-};
-#  else
-template <typename Char> struct udl_arg {
-  const Char* str;
-
-  template <typename T> auto operator=(T&& value) const -> named_arg<Char, T> {
-    return {str, std::forward<T>(value)};
-  }
-};
-#  endif
-#endif  // FMT_USE_USER_DEFINED_LITERALS
-
-template <typename Locale, typename Char>
-auto vformat(const Locale& loc, basic_string_view<Char> format_str,
-             basic_format_args<buffer_context<type_identity_t<Char>>> args)
-    -> std::basic_string<Char> {
-  basic_memory_buffer<Char> buffer;
-  detail::vformat_to(buffer, format_str, args, detail::locale_ref(loc));
-  return {buffer.data(), buffer.size()};
-}
-
-using format_func = void (*)(detail::buffer<char>&, int, const char*);
-
-FMT_API void format_error_code(buffer<char>& out, int error_code,
-                               string_view message) noexcept;
-
-FMT_API void report_error(format_func func, int error_code,
-                          const char* message) noexcept;
-FMT_END_DETAIL_NAMESPACE
-
-FMT_API auto vsystem_error(int error_code, string_view format_str,
-                           format_args args) -> std::system_error;
-
-/**
- \rst
- Constructs :class:`std::system_error` with a message formatted with
- ``fmt::format(fmt, args...)``.
-  *error_code* is a system error code as given by ``errno``.
-
- **Example**::
-
-   // This throws std::system_error with the description
-   //   cannot open file 'madeup': No such file or directory
-   // or similar (system message may vary).
-   const char* filename = "madeup";
-   std::FILE* file = std::fopen(filename, "r");
-   if (!file)
-     throw fmt::system_error(errno, "cannot open file '{}'", filename);
- \endrst
-*/
-template <typename... T>
-auto system_error(int error_code, format_string<T...> fmt, T&&... args)
-    -> std::system_error {
-  return vsystem_error(error_code, fmt, fmt::make_format_args(args...));
-}
-
-/**
-  \rst
-  Formats an error message for an error returned by an operating system or a
-  language runtime, for example a file opening error, and writes it to *out*.
-  The format is the same as the one used by ``std::system_error(ec, message)``
-  where ``ec`` is ``std::error_code(error_code, std::generic_category()})``.
-  It is implementation-defined but normally looks like:
-
-  .. parsed-literal::
-     *<message>*: *<system-message>*
-
-  where *<message>* is the passed message and *<system-message>* is the system
-  message corresponding to the error code.
-  *error_code* is a system error code as given by ``errno``.
-  \endrst
- */
-FMT_API void format_system_error(detail::buffer<char>& out, int error_code,
-                                 const char* message) noexcept;
-
-// Reports a system error without throwing an exception.
-// Can be used to report errors from destructors.
-FMT_API void report_system_error(int error_code, const char* message) noexcept;
-
-/** Fast integer formatter. */
-class format_int {
- private:
-  // Buffer should be large enough to hold all digits (digits10 + 1),
-  // a sign and a null character.
-  enum { buffer_size = std::numeric_limits<unsigned long long>::digits10 + 3 };
-  mutable char buffer_[buffer_size];
-  char* str_;
-
-  template <typename UInt> auto format_unsigned(UInt value) -> char* {
-    auto n = static_cast<detail::uint32_or_64_or_128_t<UInt>>(value);
-    return detail::format_decimal(buffer_, n, buffer_size - 1).begin;
-  }
-
-  template <typename Int> auto format_signed(Int value) -> char* {
-    auto abs_value = static_cast<detail::uint32_or_64_or_128_t<Int>>(value);
-    bool negative = value < 0;
-    if (negative) abs_value = 0 - abs_value;
-    auto begin = format_unsigned(abs_value);
-    if (negative) *--begin = '-';
-    return begin;
-  }
-
- public:
-  explicit format_int(int value) : str_(format_signed(value)) {}
-  explicit format_int(long value) : str_(format_signed(value)) {}
-  explicit format_int(long long value) : str_(format_signed(value)) {}
-  explicit format_int(unsigned value) : str_(format_unsigned(value)) {}
-  explicit format_int(unsigned long value) : str_(format_unsigned(value)) {}
-  explicit format_int(unsigned long long value)
-      : str_(format_unsigned(value)) {}
-
-  /** Returns the number of characters written to the output buffer. */
-  auto size() const -> size_t {
-    return detail::to_unsigned(buffer_ - str_ + buffer_size - 1);
-  }
-
-  /**
-    Returns a pointer to the output buffer content. No terminating null
-    character is appended.
-   */
-  auto data() const -> const char* { return str_; }
-
-  /**
-    Returns a pointer to the output buffer content with terminating null
-    character appended.
-   */
-  auto c_str() const -> const char* {
-    buffer_[buffer_size - 1] = '\0';
-    return str_;
-  }
-
-  /**
-    \rst
-    Returns the content of the output buffer as an ``std::string``.
-    \endrst
-   */
-  auto str() const -> std::string { return std::string(str_, size()); }
-};
-
-template <typename T, typename Char>
-template <typename FormatContext>
-FMT_CONSTEXPR FMT_INLINE auto
-formatter<T, Char,
-          enable_if_t<detail::type_constant<T, Char>::value !=
-                      detail::type::custom_type>>::format(const T& val,
-                                                          FormatContext& ctx)
-    const -> decltype(ctx.out()) {
-  if (specs_.width_ref.kind != detail::arg_id_kind::none ||
-      specs_.precision_ref.kind != detail::arg_id_kind::none) {
-    auto specs = specs_;
-    detail::handle_dynamic_spec<detail::width_checker>(specs.width,
-                                                       specs.width_ref, ctx);
-    detail::handle_dynamic_spec<detail::precision_checker>(
-        specs.precision, specs.precision_ref, ctx);
-    return detail::write<Char>(ctx.out(), val, specs, ctx.locale());
-  }
-  return detail::write<Char>(ctx.out(), val, specs_, ctx.locale());
-}
-
-template <typename Char>
-struct formatter<void*, Char> : formatter<const void*, Char> {
-  template <typename FormatContext>
-  auto format(void* val, FormatContext& ctx) const -> decltype(ctx.out()) {
-    return formatter<const void*, Char>::format(val, ctx);
-  }
-};
-
-template <typename Char, size_t N>
-struct formatter<Char[N], Char> : formatter<basic_string_view<Char>, Char> {
-  template <typename FormatContext>
-  FMT_CONSTEXPR auto format(const Char* val, FormatContext& ctx) const
-      -> decltype(ctx.out()) {
-    return formatter<basic_string_view<Char>, Char>::format(val, ctx);
-  }
-};
-
-// A formatter for types known only at run time such as variant alternatives.
-//
-// Usage:
-//   using variant = std::variant<int, std::string>;
-//   template <>
-//   struct formatter<variant>: dynamic_formatter<> {
-//     auto format(const variant& v, format_context& ctx) {
-//       return visit([&](const auto& val) {
-//           return dynamic_formatter<>::format(val, ctx);
-//       }, v);
-//     }
-//   };
-template <typename Char = char> class dynamic_formatter {
- private:
-  detail::dynamic_format_specs<Char> specs_;
-  const Char* format_str_;
-
-  struct null_handler : detail::error_handler {
-    void on_align(align_t) {}
-    void on_sign(sign_t) {}
-    void on_hash() {}
-  };
-
-  template <typename Context> void handle_specs(Context& ctx) {
-    detail::handle_dynamic_spec<detail::width_checker>(specs_.width,
-                                                       specs_.width_ref, ctx);
-    detail::handle_dynamic_spec<detail::precision_checker>(
-        specs_.precision, specs_.precision_ref, ctx);
-  }
-
- public:
-  template <typename ParseContext>
-  FMT_CONSTEXPR auto parse(ParseContext& ctx) -> decltype(ctx.begin()) {
-    format_str_ = ctx.begin();
-    // Checks are deferred to formatting time when the argument type is known.
-    detail::dynamic_specs_handler<ParseContext> handler(specs_, ctx);
-    return detail::parse_format_specs(ctx.begin(), ctx.end(), handler);
-  }
-
-  template <typename T, typename FormatContext>
-  auto format(const T& val, FormatContext& ctx) -> decltype(ctx.out()) {
-    handle_specs(ctx);
-    detail::specs_checker<null_handler> checker(
-        null_handler(), detail::mapped_type_constant<T, FormatContext>::value);
-    checker.on_align(specs_.align);
-    if (specs_.sign != sign::none) checker.on_sign(specs_.sign);
-    if (specs_.alt) checker.on_hash();
-    if (specs_.precision >= 0) checker.end_precision();
-    return detail::write<Char>(ctx.out(), val, specs_, ctx.locale());
-  }
-};
-
-/**
-  \rst
-  Converts ``p`` to ``const void*`` for pointer formatting.
-
-  **Example**::
-
-    auto s = fmt::format("{}", fmt::ptr(p));
-  \endrst
- */
-template <typename T> auto ptr(T p) -> const void* {
-  static_assert(std::is_pointer<T>::value, "");
-  return detail::bit_cast<const void*>(p);
-}
-template <typename T> auto ptr(const std::unique_ptr<T>& p) -> const void* {
-  return p.get();
-}
-template <typename T> auto ptr(const std::shared_ptr<T>& p) -> const void* {
-  return p.get();
-}
-
-/**
-  \rst
-  Converts ``e`` to the underlying type.
-
-  **Example**::
-
-    enum class color { red, green, blue };
-    auto s = fmt::format("{}", fmt::underlying(color::red));
-  \endrst
- */
-template <typename Enum>
-constexpr auto underlying(Enum e) noexcept -> underlying_t<Enum> {
-  return static_cast<underlying_t<Enum>>(e);
-}
-
-namespace enums {
-template <typename Enum, FMT_ENABLE_IF(std::is_enum<Enum>::value)>
-constexpr auto format_as(Enum e) noexcept -> underlying_t<Enum> {
-  return static_cast<underlying_t<Enum>>(e);
-}
-}  // namespace enums
-
-class bytes {
- private:
-  string_view data_;
-  friend struct formatter<bytes>;
-
- public:
-  explicit bytes(string_view data) : data_(data) {}
-};
-
-template <> struct formatter<bytes> {
- private:
-  detail::dynamic_format_specs<char> specs_;
-
- public:
-  template <typename ParseContext>
-  FMT_CONSTEXPR auto parse(ParseContext& ctx) -> decltype(ctx.begin()) {
-    using handler_type = detail::dynamic_specs_handler<ParseContext>;
-    detail::specs_checker<handler_type> handler(handler_type(specs_, ctx),
-                                                detail::type::string_type);
-    auto it = parse_format_specs(ctx.begin(), ctx.end(), handler);
-    detail::check_string_type_spec(specs_.type, ctx.error_handler());
-    return it;
-  }
-
-  template <typename FormatContext>
-  auto format(bytes b, FormatContext& ctx) -> decltype(ctx.out()) {
-    detail::handle_dynamic_spec<detail::width_checker>(specs_.width,
-                                                       specs_.width_ref, ctx);
-    detail::handle_dynamic_spec<detail::precision_checker>(
-        specs_.precision, specs_.precision_ref, ctx);
-    return detail::write_bytes(ctx.out(), b.data_, specs_);
-  }
-};
-
-// group_digits_view is not derived from view because it copies the argument.
-template <typename T> struct group_digits_view { T value; };
-
-/**
-  \rst
-  Returns a view that formats an integer value using ',' as a locale-independent
-  thousands separator.
-
-  **Example**::
-
-    fmt::print("{}", fmt::group_digits(12345));
-    // Output: "12,345"
-  \endrst
- */
-template <typename T> auto group_digits(T value) -> group_digits_view<T> {
-  return {value};
-}
-
-template <typename T> struct formatter<group_digits_view<T>> : formatter<T> {
- private:
-  detail::dynamic_format_specs<char> specs_;
-
- public:
-  template <typename ParseContext>
-  FMT_CONSTEXPR auto parse(ParseContext& ctx) -> decltype(ctx.begin()) {
-    using handler_type = detail::dynamic_specs_handler<ParseContext>;
-    detail::specs_checker<handler_type> handler(handler_type(specs_, ctx),
-                                                detail::type::int_type);
-    auto it = parse_format_specs(ctx.begin(), ctx.end(), handler);
-    detail::check_string_type_spec(specs_.type, ctx.error_handler());
-    return it;
-  }
-
-  template <typename FormatContext>
-  auto format(group_digits_view<T> t, FormatContext& ctx)
-      -> decltype(ctx.out()) {
-    detail::handle_dynamic_spec<detail::width_checker>(specs_.width,
-                                                       specs_.width_ref, ctx);
-    detail::handle_dynamic_spec<detail::precision_checker>(
-        specs_.precision, specs_.precision_ref, ctx);
-    return detail::write_int_localized(
-        ctx.out(), static_cast<detail::uint64_or_128_t<T>>(t.value), 0, specs_,
-        detail::digit_grouping<char>({"\3", ','}));
-  }
-};
-
-template <typename It, typename Sentinel, typename Char = char>
-struct join_view : detail::view {
-  It begin;
-  Sentinel end;
-  basic_string_view<Char> sep;
-
-  join_view(It b, Sentinel e, basic_string_view<Char> s)
-      : begin(b), end(e), sep(s) {}
-};
-
-template <typename It, typename Sentinel, typename Char>
-struct formatter<join_view<It, Sentinel, Char>, Char> {
- private:
-  using value_type =
-#ifdef __cpp_lib_ranges
-      std::iter_value_t<It>;
-#else
-      typename std::iterator_traits<It>::value_type;
-#endif
-  using context = buffer_context<Char>;
-  using mapper = detail::arg_mapper<context>;
-
-  template <typename T, FMT_ENABLE_IF(has_formatter<T, context>::value)>
-  static auto map(const T& value) -> const T& {
-    return value;
-  }
-  template <typename T, FMT_ENABLE_IF(!has_formatter<T, context>::value)>
-  static auto map(const T& value) -> decltype(mapper().map(value)) {
-    return mapper().map(value);
-  }
-
-  using formatter_type =
-      conditional_t<is_formattable<value_type, Char>::value,
-                    formatter<remove_cvref_t<decltype(map(
-                                  std::declval<const value_type&>()))>,
-                              Char>,
-                    detail::fallback_formatter<value_type, Char>>;
-
-  formatter_type value_formatter_;
-
- public:
-  template <typename ParseContext>
-  FMT_CONSTEXPR auto parse(ParseContext& ctx) -> decltype(ctx.begin()) {
-    return value_formatter_.parse(ctx);
-  }
-
-  template <typename FormatContext>
-  auto format(const join_view<It, Sentinel, Char>& value,
-              FormatContext& ctx) const -> decltype(ctx.out()) {
-    auto it = value.begin;
-    auto out = ctx.out();
-    if (it != value.end) {
-      out = value_formatter_.format(map(*it), ctx);
-      ++it;
-      while (it != value.end) {
-        out = detail::copy_str<Char>(value.sep.begin(), value.sep.end(), out);
-        ctx.advance_to(out);
-        out = value_formatter_.format(map(*it), ctx);
-        ++it;
-      }
-    }
-    return out;
-  }
-};
-
-/**
-  Returns a view that formats the iterator range `[begin, end)` with elements
-  separated by `sep`.
- */
-template <typename It, typename Sentinel>
-auto join(It begin, Sentinel end, string_view sep) -> join_view<It, Sentinel> {
-  return {begin, end, sep};
-}
-
-/**
-  \rst
-  Returns a view that formats `range` with elements separated by `sep`.
-
-  **Example**::
-
-    std::vector<int> v = {1, 2, 3};
-    fmt::print("{}", fmt::join(v, ", "));
-    // Output: "1, 2, 3"
-
-  ``fmt::join`` applies passed format specifiers to the range elements::
-
-    fmt::print("{:02}", fmt::join(v, ", "));
-    // Output: "01, 02, 03"
-  \endrst
- */
-template <typename Range>
-auto join(Range&& range, string_view sep)
-    -> join_view<detail::iterator_t<Range>, detail::sentinel_t<Range>> {
-  return join(std::begin(range), std::end(range), sep);
-}
-
-/**
-  \rst
-  Converts *value* to ``std::string`` using the default format for type *T*.
-
-  **Example**::
-
-    #include <fmt/format.h>
-
-    std::string answer = fmt::to_string(42);
-  \endrst
- */
-template <typename T, FMT_ENABLE_IF(!std::is_integral<T>::value)>
-inline auto to_string(const T& value) -> std::string {
-  auto result = std::string();
-  detail::write<char>(std::back_inserter(result), value);
-  return result;
-}
-
-template <typename T, FMT_ENABLE_IF(std::is_integral<T>::value)>
-FMT_NODISCARD inline auto to_string(T value) -> std::string {
-  // The buffer should be large enough to store the number including the sign
-  // or "false" for bool.
-  constexpr int max_size = detail::digits10<T>() + 2;
-  char buffer[max_size > 5 ? static_cast<unsigned>(max_size) : 5];
-  char* begin = buffer;
-  return std::string(begin, detail::write<char>(begin, value));
-}
-
-template <typename Char, size_t SIZE>
-FMT_NODISCARD auto to_string(const basic_memory_buffer<Char, SIZE>& buf)
-    -> std::basic_string<Char> {
-  auto size = buf.size();
-  detail::assume(size < std::basic_string<Char>().max_size());
-  return std::basic_string<Char>(buf.data(), size);
-}
-
-FMT_BEGIN_DETAIL_NAMESPACE
-
-template <typename Char>
-void vformat_to(
-    buffer<Char>& buf, basic_string_view<Char> fmt,
-    basic_format_args<FMT_BUFFER_CONTEXT(type_identity_t<Char>)> args,
-    locale_ref loc) {
-  // workaround for msvc bug regarding name-lookup in module
-  // link names into function scope
-  using detail::arg_formatter;
-  using detail::buffer_appender;
-  using detail::custom_formatter;
-  using detail::default_arg_formatter;
-  using detail::get_arg;
-  using detail::locale_ref;
-  using detail::parse_format_specs;
-  using detail::specs_checker;
-  using detail::specs_handler;
-  using detail::to_unsigned;
-  using detail::type;
-  using detail::write;
-  auto out = buffer_appender<Char>(buf);
-  if (fmt.size() == 2 && equal2(fmt.data(), "{}")) {
-    auto arg = args.get(0);
-    if (!arg) error_handler().on_error("argument not found");
-    visit_format_arg(default_arg_formatter<Char>{out, args, loc}, arg);
-    return;
-  }
-
-  struct format_handler : error_handler {
-    basic_format_parse_context<Char> parse_context;
-    buffer_context<Char> context;
-
-    format_handler(buffer_appender<Char> p_out, basic_string_view<Char> str,
-                   basic_format_args<buffer_context<Char>> p_args,
-                   locale_ref p_loc)
-        : parse_context(str), context(p_out, p_args, p_loc) {}
-
-    void on_text(const Char* begin, const Char* end) {
-      auto text = basic_string_view<Char>(begin, to_unsigned(end - begin));
-      context.advance_to(write<Char>(context.out(), text));
-    }
-
-    FMT_CONSTEXPR auto on_arg_id() -> int {
-      return parse_context.next_arg_id();
-    }
-    FMT_CONSTEXPR auto on_arg_id(int id) -> int {
-      return parse_context.check_arg_id(id), id;
-    }
-    FMT_CONSTEXPR auto on_arg_id(basic_string_view<Char> id) -> int {
-      int arg_id = context.arg_id(id);
-      if (arg_id < 0) on_error("argument not found");
-      return arg_id;
-    }
-
-    FMT_INLINE void on_replacement_field(int id, const Char*) {
-      auto arg = get_arg(context, id);
-      context.advance_to(visit_format_arg(
-          default_arg_formatter<Char>{context.out(), context.args(),
-                                      context.locale()},
-          arg));
-    }
-
-    auto on_format_specs(int id, const Char* begin, const Char* end)
-        -> const Char* {
-      auto arg = get_arg(context, id);
-      if (arg.type() == type::custom_type) {
-        parse_context.advance_to(parse_context.begin() +
-                                 (begin - &*parse_context.begin()));
-        visit_format_arg(custom_formatter<Char>{parse_context, context}, arg);
-        return parse_context.begin();
-      }
-      auto specs = basic_format_specs<Char>();
-      specs_checker<specs_handler<Char>> handler(
-          specs_handler<Char>(specs, parse_context, context), arg.type());
-      begin = parse_format_specs(begin, end, handler);
-      if (begin == end || *begin != '}')
-        on_error("missing '}' in format string");
-      auto f = arg_formatter<Char>{context.out(), specs, context.locale()};
-      context.advance_to(visit_format_arg(f, arg));
-      return begin;
-    }
-  };
-  detail::parse_format_string<false>(fmt, format_handler(out, fmt, args, loc));
-}
-
-#ifndef FMT_HEADER_ONLY
-extern template FMT_API auto thousands_sep_impl<char>(locale_ref)
-    -> thousands_sep_result<char>;
-extern template FMT_API auto thousands_sep_impl<wchar_t>(locale_ref)
-    -> thousands_sep_result<wchar_t>;
-extern template FMT_API auto decimal_point_impl(locale_ref) -> char;
-extern template FMT_API auto decimal_point_impl(locale_ref) -> wchar_t;
-#endif  // FMT_HEADER_ONLY
-
-FMT_END_DETAIL_NAMESPACE
-
-#if FMT_USE_USER_DEFINED_LITERALS
-inline namespace literals {
-/**
-  \rst
-  User-defined literal equivalent of :func:`fmt::arg`.
-
-  **Example**::
-
-    using namespace fmt::literals;
-    fmt::print("Elapsed time: {s:.2f} seconds", "s"_a=1.23);
-  \endrst
- */
-#  if FMT_USE_NONTYPE_TEMPLATE_ARGS
-template <detail_exported::fixed_string Str> constexpr auto operator""_a() {
-  using char_t = remove_cvref_t<decltype(Str.data[0])>;
-  return detail::udl_arg<char_t, sizeof(Str.data) / sizeof(char_t), Str>();
-}
-#  else
-constexpr auto operator"" _a(const char* s, size_t) -> detail::udl_arg<char> {
-  return {s};
-}
-#  endif
-}  // namespace literals
-#endif  // FMT_USE_USER_DEFINED_LITERALS
-
-template <typename Locale, FMT_ENABLE_IF(detail::is_locale<Locale>::value)>
-inline auto vformat(const Locale& loc, string_view fmt, format_args args)
-    -> std::string {
-  return detail::vformat(loc, fmt, args);
-}
-
-template <typename Locale, typename... T,
-          FMT_ENABLE_IF(detail::is_locale<Locale>::value)>
-inline auto format(const Locale& loc, format_string<T...> fmt, T&&... args)
-    -> std::string {
-  return vformat(loc, string_view(fmt), fmt::make_format_args(args...));
-}
-
-template <typename OutputIt, typename Locale,
-          FMT_ENABLE_IF(detail::is_output_iterator<OutputIt, char>::value&&
-                            detail::is_locale<Locale>::value)>
-auto vformat_to(OutputIt out, const Locale& loc, string_view fmt,
-                format_args args) -> OutputIt {
-  using detail::get_buffer;
-  auto&& buf = get_buffer<char>(out);
-  detail::vformat_to(buf, fmt, args, detail::locale_ref(loc));
-  return detail::get_iterator(buf);
-}
-
-template <typename OutputIt, typename Locale, typename... T,
-          FMT_ENABLE_IF(detail::is_output_iterator<OutputIt, char>::value&&
-                            detail::is_locale<Locale>::value)>
-FMT_INLINE auto format_to(OutputIt out, const Locale& loc,
-                          format_string<T...> fmt, T&&... args) -> OutputIt {
-  return vformat_to(out, loc, fmt, fmt::make_format_args(args...));
-}
-
-FMT_MODULE_EXPORT_END
-FMT_END_NAMESPACE
-
-#ifdef FMT_HEADER_ONLY
-#  define FMT_FUNC inline
-#  include "format-inl.h"
-#else
-#  define FMT_FUNC
-#endif
-
-#endif  // FMT_FORMAT_H_
diff --git a/Externals/fmt/include/fmt/os.h b/Externals/fmt/include/fmt/os.h
deleted file mode 100644
index d82be1125a4b..000000000000
--- a/Externals/fmt/include/fmt/os.h
+++ /dev/null
@@ -1,478 +0,0 @@
-// Formatting library for C++ - optional OS-specific functionality
-//
-// Copyright (c) 2012 - present, Victor Zverovich
-// All rights reserved.
-//
-// For the license information refer to format.h.
-
-#ifndef FMT_OS_H_
-#define FMT_OS_H_
-
-#include <cerrno>
-#include <cstddef>
-#include <cstdio>
-#include <system_error>  // std::system_error
-
-#if defined __APPLE__ || defined(__FreeBSD__)
-#  include <xlocale.h>  // for LC_NUMERIC_MASK on OS X
-#endif
-
-#include "format.h"
-
-#ifndef FMT_USE_FCNTL
-// UWP doesn't provide _pipe.
-#  if FMT_HAS_INCLUDE("winapifamily.h")
-#    include <winapifamily.h>
-#  endif
-#  if (FMT_HAS_INCLUDE(<fcntl.h>) || defined(__APPLE__) || \
-       defined(__linux__)) &&                              \
-      (!defined(WINAPI_FAMILY) ||                          \
-       (WINAPI_FAMILY == WINAPI_FAMILY_DESKTOP_APP))
-#    include <fcntl.h>  // for O_RDONLY
-#    define FMT_USE_FCNTL 1
-#  else
-#    define FMT_USE_FCNTL 0
-#  endif
-#endif
-
-#ifndef FMT_POSIX
-#  if defined(_WIN32) && !defined(__MINGW32__)
-// Fix warnings about deprecated symbols.
-#    define FMT_POSIX(call) _##call
-#  else
-#    define FMT_POSIX(call) call
-#  endif
-#endif
-
-// Calls to system functions are wrapped in FMT_SYSTEM for testability.
-#ifdef FMT_SYSTEM
-#  define FMT_POSIX_CALL(call) FMT_SYSTEM(call)
-#else
-#  define FMT_SYSTEM(call) ::call
-#  ifdef _WIN32
-// Fix warnings about deprecated symbols.
-#    define FMT_POSIX_CALL(call) ::_##call
-#  else
-#    define FMT_POSIX_CALL(call) ::call
-#  endif
-#endif
-
-// Retries the expression while it evaluates to error_result and errno
-// equals to EINTR.
-#ifndef _WIN32
-#  define FMT_RETRY_VAL(result, expression, error_result) \
-    do {                                                  \
-      (result) = (expression);                            \
-    } while ((result) == (error_result) && errno == EINTR)
-#else
-#  define FMT_RETRY_VAL(result, expression, error_result) result = (expression)
-#endif
-
-#define FMT_RETRY(result, expression) FMT_RETRY_VAL(result, expression, -1)
-
-FMT_BEGIN_NAMESPACE
-FMT_MODULE_EXPORT_BEGIN
-
-/**
-  \rst
-  A reference to a null-terminated string. It can be constructed from a C
-  string or ``std::string``.
-
-  You can use one of the following type aliases for common character types:
-
-  +---------------+-----------------------------+
-  | Type          | Definition                  |
-  +===============+=============================+
-  | cstring_view  | basic_cstring_view<char>    |
-  +---------------+-----------------------------+
-  | wcstring_view | basic_cstring_view<wchar_t> |
-  +---------------+-----------------------------+
-
-  This class is most useful as a parameter type to allow passing
-  different types of strings to a function, for example::
-
-    template <typename... Args>
-    std::string format(cstring_view format_str, const Args & ... args);
-
-    format("{}", 42);
-    format(std::string("{}"), 42);
-  \endrst
- */
-template <typename Char> class basic_cstring_view {
- private:
-  const Char* data_;
-
- public:
-  /** Constructs a string reference object from a C string. */
-  basic_cstring_view(const Char* s) : data_(s) {}
-
-  /**
-    \rst
-    Constructs a string reference from an ``std::string`` object.
-    \endrst
-   */
-  basic_cstring_view(const std::basic_string<Char>& s) : data_(s.c_str()) {}
-
-  /** Returns the pointer to a C string. */
-  const Char* c_str() const { return data_; }
-};
-
-using cstring_view = basic_cstring_view<char>;
-using wcstring_view = basic_cstring_view<wchar_t>;
-
-template <typename Char> struct formatter<std::error_code, Char> {
-  template <typename ParseContext>
-  FMT_CONSTEXPR auto parse(ParseContext& ctx) -> decltype(ctx.begin()) {
-    return ctx.begin();
-  }
-
-  template <typename FormatContext>
-  FMT_CONSTEXPR auto format(const std::error_code& ec, FormatContext& ctx) const
-      -> decltype(ctx.out()) {
-    auto out = ctx.out();
-    out = detail::write_bytes(out, ec.category().name(),
-                              basic_format_specs<Char>());
-    out = detail::write<Char>(out, Char(':'));
-    out = detail::write<Char>(out, ec.value());
-    return out;
-  }
-};
-
-#ifdef _WIN32
-FMT_API const std::error_category& system_category() noexcept;
-
-FMT_BEGIN_DETAIL_NAMESPACE
-// A converter from UTF-16 to UTF-8.
-// It is only provided for Windows since other systems support UTF-8 natively.
-class utf16_to_utf8 {
- private:
-  memory_buffer buffer_;
-
- public:
-  utf16_to_utf8() {}
-  FMT_API explicit utf16_to_utf8(basic_string_view<wchar_t> s);
-  operator string_view() const { return string_view(&buffer_[0], size()); }
-  size_t size() const { return buffer_.size() - 1; }
-  const char* c_str() const { return &buffer_[0]; }
-  std::string str() const { return std::string(&buffer_[0], size()); }
-
-  // Performs conversion returning a system error code instead of
-  // throwing exception on conversion error. This method may still throw
-  // in case of memory allocation error.
-  FMT_API int convert(basic_string_view<wchar_t> s);
-};
-
-FMT_API void format_windows_error(buffer<char>& out, int error_code,
-                                  const char* message) noexcept;
-FMT_END_DETAIL_NAMESPACE
-
-FMT_API std::system_error vwindows_error(int error_code, string_view format_str,
-                                         format_args args);
-
-/**
- \rst
- Constructs a :class:`std::system_error` object with the description
- of the form
-
- .. parsed-literal::
-   *<message>*: *<system-message>*
-
- where *<message>* is the formatted message and *<system-message>* is the
- system message corresponding to the error code.
- *error_code* is a Windows error code as given by ``GetLastError``.
- If *error_code* is not a valid error code such as -1, the system message
- will look like "error -1".
-
- **Example**::
-
-   // This throws a system_error with the description
-   //   cannot open file 'madeup': The system cannot find the file specified.
-   // or similar (system message may vary).
-   const char *filename = "madeup";
-   LPOFSTRUCT of = LPOFSTRUCT();
-   HFILE file = OpenFile(filename, &of, OF_READ);
-   if (file == HFILE_ERROR) {
-     throw fmt::windows_error(GetLastError(),
-                              "cannot open file '{}'", filename);
-   }
- \endrst
-*/
-template <typename... Args>
-std::system_error windows_error(int error_code, string_view message,
-                                const Args&... args) {
-  return vwindows_error(error_code, message, fmt::make_format_args(args...));
-}
-
-// Reports a Windows error without throwing an exception.
-// Can be used to report errors from destructors.
-FMT_API void report_windows_error(int error_code, const char* message) noexcept;
-#else
-inline const std::error_category& system_category() noexcept {
-  return std::system_category();
-}
-#endif  // _WIN32
-
-// std::system is not available on some platforms such as iOS (#2248).
-#ifdef __OSX__
-template <typename S, typename... Args, typename Char = char_t<S>>
-void say(const S& format_str, Args&&... args) {
-  std::system(format("say \"{}\"", format(format_str, args...)).c_str());
-}
-#endif
-
-// A buffered file.
-class buffered_file {
- private:
-  FILE* file_;
-
-  friend class file;
-
-  explicit buffered_file(FILE* f) : file_(f) {}
-
- public:
-  buffered_file(const buffered_file&) = delete;
-  void operator=(const buffered_file&) = delete;
-
-  // Constructs a buffered_file object which doesn't represent any file.
-  buffered_file() noexcept : file_(nullptr) {}
-
-  // Destroys the object closing the file it represents if any.
-  FMT_API ~buffered_file() noexcept;
-
- public:
-  buffered_file(buffered_file&& other) noexcept : file_(other.file_) {
-    other.file_ = nullptr;
-  }
-
-  buffered_file& operator=(buffered_file&& other) {
-    close();
-    file_ = other.file_;
-    other.file_ = nullptr;
-    return *this;
-  }
-
-  // Opens a file.
-  FMT_API buffered_file(cstring_view filename, cstring_view mode);
-
-  // Closes the file.
-  FMT_API void close();
-
-  // Returns the pointer to a FILE object representing this file.
-  FILE* get() const noexcept { return file_; }
-
-  FMT_API int descriptor() const;
-
-  void vprint(string_view format_str, format_args args) {
-    fmt::vprint(file_, format_str, args);
-  }
-
-  template <typename... Args>
-  inline void print(string_view format_str, const Args&... args) {
-    vprint(format_str, fmt::make_format_args(args...));
-  }
-};
-
-#if FMT_USE_FCNTL
-// A file. Closed file is represented by a file object with descriptor -1.
-// Methods that are not declared with noexcept may throw
-// fmt::system_error in case of failure. Note that some errors such as
-// closing the file multiple times will cause a crash on Windows rather
-// than an exception. You can get standard behavior by overriding the
-// invalid parameter handler with _set_invalid_parameter_handler.
-class FMT_API file {
- private:
-  int fd_;  // File descriptor.
-
-  // Constructs a file object with a given descriptor.
-  explicit file(int fd) : fd_(fd) {}
-
- public:
-  // Possible values for the oflag argument to the constructor.
-  enum {
-    RDONLY = FMT_POSIX(O_RDONLY),  // Open for reading only.
-    WRONLY = FMT_POSIX(O_WRONLY),  // Open for writing only.
-    RDWR = FMT_POSIX(O_RDWR),      // Open for reading and writing.
-    CREATE = FMT_POSIX(O_CREAT),   // Create if the file doesn't exist.
-    APPEND = FMT_POSIX(O_APPEND),  // Open in append mode.
-    TRUNC = FMT_POSIX(O_TRUNC)     // Truncate the content of the file.
-  };
-
-  // Constructs a file object which doesn't represent any file.
-  file() noexcept : fd_(-1) {}
-
-  // Opens a file and constructs a file object representing this file.
-  file(cstring_view path, int oflag);
-
- public:
-  file(const file&) = delete;
-  void operator=(const file&) = delete;
-
-  file(file&& other) noexcept : fd_(other.fd_) { other.fd_ = -1; }
-
-  // Move assignment is not noexcept because close may throw.
-  file& operator=(file&& other) {
-    close();
-    fd_ = other.fd_;
-    other.fd_ = -1;
-    return *this;
-  }
-
-  // Destroys the object closing the file it represents if any.
-  ~file() noexcept;
-
-  // Returns the file descriptor.
-  int descriptor() const noexcept { return fd_; }
-
-  // Closes the file.
-  void close();
-
-  // Returns the file size. The size has signed type for consistency with
-  // stat::st_size.
-  long long size() const;
-
-  // Attempts to read count bytes from the file into the specified buffer.
-  size_t read(void* buffer, size_t count);
-
-  // Attempts to write count bytes from the specified buffer to the file.
-  size_t write(const void* buffer, size_t count);
-
-  // Duplicates a file descriptor with the dup function and returns
-  // the duplicate as a file object.
-  static file dup(int fd);
-
-  // Makes fd be the copy of this file descriptor, closing fd first if
-  // necessary.
-  void dup2(int fd);
-
-  // Makes fd be the copy of this file descriptor, closing fd first if
-  // necessary.
-  void dup2(int fd, std::error_code& ec) noexcept;
-
-  // Creates a pipe setting up read_end and write_end file objects for reading
-  // and writing respectively.
-  static void pipe(file& read_end, file& write_end);
-
-  // Creates a buffered_file object associated with this file and detaches
-  // this file object from the file.
-  buffered_file fdopen(const char* mode);
-};
-
-// Returns the memory page size.
-long getpagesize();
-
-FMT_BEGIN_DETAIL_NAMESPACE
-
-struct buffer_size {
-  buffer_size() = default;
-  size_t value = 0;
-  buffer_size operator=(size_t val) const {
-    auto bs = buffer_size();
-    bs.value = val;
-    return bs;
-  }
-};
-
-struct ostream_params {
-  int oflag = file::WRONLY | file::CREATE | file::TRUNC;
-  size_t buffer_size = BUFSIZ > 32768 ? BUFSIZ : 32768;
-
-  ostream_params() {}
-
-  template <typename... T>
-  ostream_params(T... params, int new_oflag) : ostream_params(params...) {
-    oflag = new_oflag;
-  }
-
-  template <typename... T>
-  ostream_params(T... params, detail::buffer_size bs)
-      : ostream_params(params...) {
-    this->buffer_size = bs.value;
-  }
-
-// Intel has a bug that results in failure to deduce a constructor
-// for empty parameter packs.
-#  if defined(__INTEL_COMPILER) && __INTEL_COMPILER < 2000
-  ostream_params(int new_oflag) : oflag(new_oflag) {}
-  ostream_params(detail::buffer_size bs) : buffer_size(bs.value) {}
-#  endif
-};
-
-FMT_END_DETAIL_NAMESPACE
-
-// Added {} below to work around default constructor error known to
-// occur in Xcode versions 7.2.1 and 8.2.1.
-constexpr detail::buffer_size buffer_size{};
-
-/** A fast output stream which is not thread-safe. */
-class FMT_API ostream final : private detail::buffer<char> {
- private:
-  file file_;
-
-  void grow(size_t) override;
-
-  ostream(cstring_view path, const detail::ostream_params& params)
-      : file_(path, params.oflag) {
-    set(new char[params.buffer_size], params.buffer_size);
-  }
-
- public:
-  ostream(ostream&& other)
-      : detail::buffer<char>(other.data(), other.size(), other.capacity()),
-        file_(std::move(other.file_)) {
-    other.clear();
-    other.set(nullptr, 0);
-  }
-  ~ostream() {
-    flush();
-    delete[] data();
-  }
-
-  void flush() {
-    if (size() == 0) return;
-    file_.write(data(), size());
-    clear();
-  }
-
-  template <typename... T>
-  friend ostream output_file(cstring_view path, T... params);
-
-  void close() {
-    flush();
-    file_.close();
-  }
-
-  /**
-    Formats ``args`` according to specifications in ``fmt`` and writes the
-    output to the file.
-   */
-  template <typename... T> void print(format_string<T...> fmt, T&&... args) {
-    vformat_to(detail::buffer_appender<char>(*this), fmt,
-               fmt::make_format_args(args...));
-  }
-};
-
-/**
-  \rst
-  Opens a file for writing. Supported parameters passed in *params*:
-
-  * ``<integer>``: Flags passed to `open
-    <https://pubs.opengroup.org/onlinepubs/007904875/functions/open.html>`_
-    (``file::WRONLY | file::CREATE | file::TRUNC`` by default)
-  * ``buffer_size=<integer>``: Output buffer size
-
-  **Example**::
-
-    auto out = fmt::output_file("guide.txt");
-    out.print("Don't {}", "Panic");
-  \endrst
- */
-template <typename... T>
-inline ostream output_file(cstring_view path, T... params) {
-  return {path, detail::ostream_params(params...)};
-}
-#endif  // FMT_USE_FCNTL
-
-FMT_MODULE_EXPORT_END
-FMT_END_NAMESPACE
-
-#endif  // FMT_OS_H_
diff --git a/Externals/fmt/include/fmt/ostream.h b/Externals/fmt/include/fmt/ostream.h
deleted file mode 100755
index c3cdd4a61b2c..000000000000
--- a/Externals/fmt/include/fmt/ostream.h
+++ /dev/null
@@ -1,237 +0,0 @@
-// Formatting library for C++ - std::ostream support
-//
-// Copyright (c) 2012 - present, Victor Zverovich
-// All rights reserved.
-//
-// For the license information refer to format.h.
-
-#ifndef FMT_OSTREAM_H_
-#define FMT_OSTREAM_H_
-
-#include <fstream>
-#include <ostream>
-#if defined(_WIN32) && defined(__GLIBCXX__)
-#  include <ext/stdio_filebuf.h>
-#  include <ext/stdio_sync_filebuf.h>
-#elif defined(_WIN32) && defined(_LIBCPP_VERSION)
-#  include <__std_stream>
-#endif
-
-#include "format.h"
-
-FMT_BEGIN_NAMESPACE
-
-template <typename OutputIt, typename Char> class basic_printf_context;
-
-namespace detail {
-
-// Checks if T has a user-defined operator<<.
-template <typename T, typename Char, typename Enable = void>
-class is_streamable {
- private:
-  template <typename U>
-  static auto test(int)
-      -> bool_constant<sizeof(std::declval<std::basic_ostream<Char>&>()
-                              << std::declval<U>()) != 0>;
-
-  template <typename> static auto test(...) -> std::false_type;
-
-  using result = decltype(test<T>(0));
-
- public:
-  is_streamable() = default;
-
-  static const bool value = result::value;
-};
-
-// Formatting of built-in types and arrays is intentionally disabled because
-// it's handled by standard (non-ostream) formatters.
-template <typename T, typename Char>
-struct is_streamable<
-    T, Char,
-    enable_if_t<
-        std::is_arithmetic<T>::value || std::is_array<T>::value ||
-        std::is_pointer<T>::value || std::is_same<T, char8_type>::value ||
-        std::is_convertible<T, fmt::basic_string_view<Char>>::value ||
-        std::is_same<T, std_string_view<Char>>::value ||
-        (std::is_convertible<T, int>::value && !std::is_enum<T>::value)>>
-    : std::false_type {};
-
-// Generate a unique explicit instantion in every translation unit using a tag
-// type in an anonymous namespace.
-namespace {
-struct file_access_tag {};
-}  // namespace
-template <class Tag, class BufType, FILE* BufType::*FileMemberPtr>
-class file_access {
-  friend auto get_file(BufType& obj) -> FILE* { return obj.*FileMemberPtr; }
-};
-
-#if FMT_MSC_VERSION
-template class file_access<file_access_tag, std::filebuf,
-                           &std::filebuf::_Myfile>;
-auto get_file(std::filebuf&) -> FILE*;
-#elif defined(_WIN32) && defined(_LIBCPP_VERSION)
-template class file_access<file_access_tag, std::__stdoutbuf<char>,
-                           &std::__stdoutbuf<char>::__file_>;
-auto get_file(std::__stdoutbuf<char>&) -> FILE*;
-#endif
-
-inline bool write_ostream_unicode(std::ostream& os, fmt::string_view data) {
-#if FMT_MSC_VERSION
-  if (auto* buf = dynamic_cast<std::filebuf*>(os.rdbuf()))
-    if (FILE* f = get_file(*buf)) return write_console(f, data);
-#elif defined(_WIN32) && defined(__GLIBCXX__)
-  auto* rdbuf = os.rdbuf();
-  FILE* c_file;
-  if (auto* fbuf = dynamic_cast<__gnu_cxx::stdio_sync_filebuf<char>*>(rdbuf))
-    c_file = fbuf->file();
-  else if (auto* fbuf = dynamic_cast<__gnu_cxx::stdio_filebuf<char>*>(rdbuf))
-    c_file = fbuf->file();
-  else
-    return false;
-  if (c_file) return write_console(c_file, data);
-#elif defined(_WIN32) && defined(_LIBCPP_VERSION)
-  if (auto* buf = dynamic_cast<std::__stdoutbuf<char>*>(os.rdbuf()))
-    if (FILE* f = get_file(*buf)) return write_console(f, data);
-#else
-  ignore_unused(os, data);
-#endif
-  return false;
-}
-inline bool write_ostream_unicode(std::wostream&,
-                                  fmt::basic_string_view<wchar_t>) {
-  return false;
-}
-
-// Write the content of buf to os.
-// It is a separate function rather than a part of vprint to simplify testing.
-template <typename Char>
-void write_buffer(std::basic_ostream<Char>& os, buffer<Char>& buf) {
-  const Char* buf_data = buf.data();
-  using unsigned_streamsize = std::make_unsigned<std::streamsize>::type;
-  unsigned_streamsize size = buf.size();
-  unsigned_streamsize max_size = to_unsigned(max_value<std::streamsize>());
-  do {
-    unsigned_streamsize n = size <= max_size ? size : max_size;
-    os.write(buf_data, static_cast<std::streamsize>(n));
-    buf_data += n;
-    size -= n;
-  } while (size != 0);
-}
-
-template <typename Char, typename T>
-void format_value(buffer<Char>& buf, const T& value,
-                  locale_ref loc = locale_ref()) {
-  auto&& format_buf = formatbuf<std::basic_streambuf<Char>>(buf);
-  auto&& output = std::basic_ostream<Char>(&format_buf);
-#if !defined(FMT_STATIC_THOUSANDS_SEPARATOR)
-  if (loc) output.imbue(loc.get<std::locale>());
-#endif
-  output << value;
-  output.exceptions(std::ios_base::failbit | std::ios_base::badbit);
-}
-
-template <typename T> struct streamed_view { const T& value; };
-
-}  // namespace detail
-
-// Formats an object of type T that has an overloaded ostream operator<<.
-template <typename Char>
-struct basic_ostream_formatter : formatter<basic_string_view<Char>, Char> {
-  void set_debug_format() = delete;
-
-  template <typename T, typename OutputIt>
-  auto format(const T& value, basic_format_context<OutputIt, Char>& ctx) const
-      -> OutputIt {
-    auto buffer = basic_memory_buffer<Char>();
-    format_value(buffer, value, ctx.locale());
-    return formatter<basic_string_view<Char>, Char>::format(
-        {buffer.data(), buffer.size()}, ctx);
-  }
-};
-
-using ostream_formatter = basic_ostream_formatter<char>;
-
-template <typename T, typename Char>
-struct formatter<detail::streamed_view<T>, Char>
-    : basic_ostream_formatter<Char> {
-  template <typename OutputIt>
-  auto format(detail::streamed_view<T> view,
-              basic_format_context<OutputIt, Char>& ctx) const -> OutputIt {
-    return basic_ostream_formatter<Char>::format(view.value, ctx);
-  }
-};
-
-/**
-  \rst
-  Returns a view that formats `value` via an ostream ``operator<<``.
-
-  **Example**::
-
-    fmt::print("Current thread id: {}\n",
-               fmt::streamed(std::this_thread::get_id()));
-  \endrst
- */
-template <typename T>
-auto streamed(const T& value) -> detail::streamed_view<T> {
-  return {value};
-}
-
-namespace detail {
-
-// Formats an object of type T that has an overloaded ostream operator<<.
-template <typename T, typename Char>
-struct fallback_formatter<T, Char, enable_if_t<is_streamable<T, Char>::value>>
-    : basic_ostream_formatter<Char> {
-  using basic_ostream_formatter<Char>::format;
-};
-
-inline void vprint_directly(std::ostream& os, string_view format_str,
-                            format_args args) {
-  auto buffer = memory_buffer();
-  detail::vformat_to(buffer, format_str, args);
-  detail::write_buffer(os, buffer);
-}
-
-}  // namespace detail
-
-FMT_MODULE_EXPORT template <typename Char>
-void vprint(std::basic_ostream<Char>& os,
-            basic_string_view<type_identity_t<Char>> format_str,
-            basic_format_args<buffer_context<type_identity_t<Char>>> args) {
-  auto buffer = basic_memory_buffer<Char>();
-  detail::vformat_to(buffer, format_str, args);
-  if (detail::write_ostream_unicode(os, {buffer.data(), buffer.size()})) return;
-  detail::write_buffer(os, buffer);
-}
-
-/**
-  \rst
-  Prints formatted data to the stream *os*.
-
-  **Example**::
-
-    fmt::print(cerr, "Don't {}!", "panic");
-  \endrst
- */
-FMT_MODULE_EXPORT template <typename... T>
-void print(std::ostream& os, format_string<T...> fmt, T&&... args) {
-  const auto& vargs = fmt::make_format_args(args...);
-  if (detail::is_utf8())
-    vprint(os, fmt, vargs);
-  else
-    detail::vprint_directly(os, fmt, vargs);
-}
-
-FMT_MODULE_EXPORT
-template <typename... Args>
-void print(std::wostream& os,
-           basic_format_string<wchar_t, type_identity_t<Args>...> fmt,
-           Args&&... args) {
-  vprint(os, fmt, fmt::make_format_args<buffer_context<wchar_t>>(args...));
-}
-
-FMT_END_NAMESPACE
-
-#endif  // FMT_OSTREAM_H_
diff --git a/Externals/fmt/include/fmt/printf.h b/Externals/fmt/include/fmt/printf.h
deleted file mode 100755
index 70a592dc26dd..000000000000
--- a/Externals/fmt/include/fmt/printf.h
+++ /dev/null
@@ -1,640 +0,0 @@
-// Formatting library for C++ - legacy printf implementation
-//
-// Copyright (c) 2012 - 2016, Victor Zverovich
-// All rights reserved.
-//
-// For the license information refer to format.h.
-
-#ifndef FMT_PRINTF_H_
-#define FMT_PRINTF_H_
-
-#include <algorithm>  // std::max
-#include <limits>     // std::numeric_limits
-
-#include "format.h"
-
-FMT_BEGIN_NAMESPACE
-FMT_MODULE_EXPORT_BEGIN
-
-template <typename T> struct printf_formatter { printf_formatter() = delete; };
-
-template <typename Char>
-class basic_printf_parse_context : public basic_format_parse_context<Char> {
-  using basic_format_parse_context<Char>::basic_format_parse_context;
-};
-
-template <typename OutputIt, typename Char> class basic_printf_context {
- private:
-  OutputIt out_;
-  basic_format_args<basic_printf_context> args_;
-
- public:
-  using char_type = Char;
-  using format_arg = basic_format_arg<basic_printf_context>;
-  using parse_context_type = basic_printf_parse_context<Char>;
-  template <typename T> using formatter_type = printf_formatter<T>;
-
-  /**
-    \rst
-    Constructs a ``printf_context`` object. References to the arguments are
-    stored in the context object so make sure they have appropriate lifetimes.
-    \endrst
-   */
-  basic_printf_context(OutputIt out,
-                       basic_format_args<basic_printf_context> args)
-      : out_(out), args_(args) {}
-
-  OutputIt out() { return out_; }
-  void advance_to(OutputIt it) { out_ = it; }
-
-  detail::locale_ref locale() { return {}; }
-
-  format_arg arg(int id) const { return args_.get(id); }
-
-  FMT_CONSTEXPR void on_error(const char* message) {
-    detail::error_handler().on_error(message);
-  }
-};
-
-FMT_BEGIN_DETAIL_NAMESPACE
-
-// Checks if a value fits in int - used to avoid warnings about comparing
-// signed and unsigned integers.
-template <bool IsSigned> struct int_checker {
-  template <typename T> static bool fits_in_int(T value) {
-    unsigned max = max_value<int>();
-    return value <= max;
-  }
-  static bool fits_in_int(bool) { return true; }
-};
-
-template <> struct int_checker<true> {
-  template <typename T> static bool fits_in_int(T value) {
-    return value >= (std::numeric_limits<int>::min)() &&
-           value <= max_value<int>();
-  }
-  static bool fits_in_int(int) { return true; }
-};
-
-class printf_precision_handler {
- public:
-  template <typename T, FMT_ENABLE_IF(std::is_integral<T>::value)>
-  int operator()(T value) {
-    if (!int_checker<std::numeric_limits<T>::is_signed>::fits_in_int(value))
-      FMT_THROW(format_error("number is too big"));
-    return (std::max)(static_cast<int>(value), 0);
-  }
-
-  template <typename T, FMT_ENABLE_IF(!std::is_integral<T>::value)>
-  int operator()(T) {
-    FMT_THROW(format_error("precision is not integer"));
-    return 0;
-  }
-};
-
-// An argument visitor that returns true iff arg is a zero integer.
-class is_zero_int {
- public:
-  template <typename T, FMT_ENABLE_IF(std::is_integral<T>::value)>
-  bool operator()(T value) {
-    return value == 0;
-  }
-
-  template <typename T, FMT_ENABLE_IF(!std::is_integral<T>::value)>
-  bool operator()(T) {
-    return false;
-  }
-};
-
-template <typename T> struct make_unsigned_or_bool : std::make_unsigned<T> {};
-
-template <> struct make_unsigned_or_bool<bool> { using type = bool; };
-
-template <typename T, typename Context> class arg_converter {
- private:
-  using char_type = typename Context::char_type;
-
-  basic_format_arg<Context>& arg_;
-  char_type type_;
-
- public:
-  arg_converter(basic_format_arg<Context>& arg, char_type type)
-      : arg_(arg), type_(type) {}
-
-  void operator()(bool value) {
-    if (type_ != 's') operator()<bool>(value);
-  }
-
-  template <typename U, FMT_ENABLE_IF(std::is_integral<U>::value)>
-  void operator()(U value) {
-    bool is_signed = type_ == 'd' || type_ == 'i';
-    using target_type = conditional_t<std::is_same<T, void>::value, U, T>;
-    if (const_check(sizeof(target_type) <= sizeof(int))) {
-      // Extra casts are used to silence warnings.
-      if (is_signed) {
-        arg_ = detail::make_arg<Context>(
-            static_cast<int>(static_cast<target_type>(value)));
-      } else {
-        using unsigned_type = typename make_unsigned_or_bool<target_type>::type;
-        arg_ = detail::make_arg<Context>(
-            static_cast<unsigned>(static_cast<unsigned_type>(value)));
-      }
-    } else {
-      if (is_signed) {
-        // glibc's printf doesn't sign extend arguments of smaller types:
-        //   std::printf("%lld", -42);  // prints "4294967254"
-        // but we don't have to do the same because it's a UB.
-        arg_ = detail::make_arg<Context>(static_cast<long long>(value));
-      } else {
-        arg_ = detail::make_arg<Context>(
-            static_cast<typename make_unsigned_or_bool<U>::type>(value));
-      }
-    }
-  }
-
-  template <typename U, FMT_ENABLE_IF(!std::is_integral<U>::value)>
-  void operator()(U) {}  // No conversion needed for non-integral types.
-};
-
-// Converts an integer argument to T for printf, if T is an integral type.
-// If T is void, the argument is converted to corresponding signed or unsigned
-// type depending on the type specifier: 'd' and 'i' - signed, other -
-// unsigned).
-template <typename T, typename Context, typename Char>
-void convert_arg(basic_format_arg<Context>& arg, Char type) {
-  visit_format_arg(arg_converter<T, Context>(arg, type), arg);
-}
-
-// Converts an integer argument to char for printf.
-template <typename Context> class char_converter {
- private:
-  basic_format_arg<Context>& arg_;
-
- public:
-  explicit char_converter(basic_format_arg<Context>& arg) : arg_(arg) {}
-
-  template <typename T, FMT_ENABLE_IF(std::is_integral<T>::value)>
-  void operator()(T value) {
-    arg_ = detail::make_arg<Context>(
-        static_cast<typename Context::char_type>(value));
-  }
-
-  template <typename T, FMT_ENABLE_IF(!std::is_integral<T>::value)>
-  void operator()(T) {}  // No conversion needed for non-integral types.
-};
-
-// An argument visitor that return a pointer to a C string if argument is a
-// string or null otherwise.
-template <typename Char> struct get_cstring {
-  template <typename T> const Char* operator()(T) { return nullptr; }
-  const Char* operator()(const Char* s) { return s; }
-};
-
-// Checks if an argument is a valid printf width specifier and sets
-// left alignment if it is negative.
-template <typename Char> class printf_width_handler {
- private:
-  using format_specs = basic_format_specs<Char>;
-
-  format_specs& specs_;
-
- public:
-  explicit printf_width_handler(format_specs& specs) : specs_(specs) {}
-
-  template <typename T, FMT_ENABLE_IF(std::is_integral<T>::value)>
-  unsigned operator()(T value) {
-    auto width = static_cast<uint32_or_64_or_128_t<T>>(value);
-    if (detail::is_negative(value)) {
-      specs_.align = align::left;
-      width = 0 - width;
-    }
-    unsigned int_max = max_value<int>();
-    if (width > int_max) FMT_THROW(format_error("number is too big"));
-    return static_cast<unsigned>(width);
-  }
-
-  template <typename T, FMT_ENABLE_IF(!std::is_integral<T>::value)>
-  unsigned operator()(T) {
-    FMT_THROW(format_error("width is not integer"));
-    return 0;
-  }
-};
-
-// The ``printf`` argument formatter.
-template <typename OutputIt, typename Char>
-class printf_arg_formatter : public arg_formatter<Char> {
- private:
-  using base = arg_formatter<Char>;
-  using context_type = basic_printf_context<OutputIt, Char>;
-  using format_specs = basic_format_specs<Char>;
-
-  context_type& context_;
-
-  OutputIt write_null_pointer(bool is_string = false) {
-    auto s = this->specs;
-    s.type = presentation_type::none;
-    return write_bytes(this->out, is_string ? "(null)" : "(nil)", s);
-  }
-
- public:
-  printf_arg_formatter(OutputIt iter, format_specs& s, context_type& ctx)
-      : base{iter, s, locale_ref()}, context_(ctx) {}
-
-  OutputIt operator()(monostate value) { return base::operator()(value); }
-
-  template <typename T, FMT_ENABLE_IF(detail::is_integral<T>::value)>
-  OutputIt operator()(T value) {
-    // MSVC2013 fails to compile separate overloads for bool and Char so use
-    // std::is_same instead.
-    if (std::is_same<T, Char>::value) {
-      format_specs fmt_specs = this->specs;
-      if (fmt_specs.type != presentation_type::none &&
-          fmt_specs.type != presentation_type::chr) {
-        return (*this)(static_cast<int>(value));
-      }
-      fmt_specs.sign = sign::none;
-      fmt_specs.alt = false;
-      fmt_specs.fill[0] = ' ';  // Ignore '0' flag for char types.
-      // align::numeric needs to be overwritten here since the '0' flag is
-      // ignored for non-numeric types
-      if (fmt_specs.align == align::none || fmt_specs.align == align::numeric)
-        fmt_specs.align = align::right;
-      return write<Char>(this->out, static_cast<Char>(value), fmt_specs);
-    }
-    return base::operator()(value);
-  }
-
-  template <typename T, FMT_ENABLE_IF(std::is_floating_point<T>::value)>
-  OutputIt operator()(T value) {
-    return base::operator()(value);
-  }
-
-  /** Formats a null-terminated C string. */
-  OutputIt operator()(const char* value) {
-    if (value) return base::operator()(value);
-    return write_null_pointer(this->specs.type != presentation_type::pointer);
-  }
-
-  /** Formats a null-terminated wide C string. */
-  OutputIt operator()(const wchar_t* value) {
-    if (value) return base::operator()(value);
-    return write_null_pointer(this->specs.type != presentation_type::pointer);
-  }
-
-  OutputIt operator()(basic_string_view<Char> value) {
-    return base::operator()(value);
-  }
-
-  /** Formats a pointer. */
-  OutputIt operator()(const void* value) {
-    return value ? base::operator()(value) : write_null_pointer();
-  }
-
-  /** Formats an argument of a custom (user-defined) type. */
-  OutputIt operator()(typename basic_format_arg<context_type>::handle handle) {
-    auto parse_ctx =
-        basic_printf_parse_context<Char>(basic_string_view<Char>());
-    handle.format(parse_ctx, context_);
-    return this->out;
-  }
-};
-
-template <typename Char>
-void parse_flags(basic_format_specs<Char>& specs, const Char*& it,
-                 const Char* end) {
-  for (; it != end; ++it) {
-    switch (*it) {
-    case '-':
-      specs.align = align::left;
-      break;
-    case '+':
-      specs.sign = sign::plus;
-      break;
-    case '0':
-      specs.fill[0] = '0';
-      break;
-    case ' ':
-      if (specs.sign != sign::plus) {
-        specs.sign = sign::space;
-      }
-      break;
-    case '#':
-      specs.alt = true;
-      break;
-    default:
-      return;
-    }
-  }
-}
-
-template <typename Char, typename GetArg>
-int parse_header(const Char*& it, const Char* end,
-                 basic_format_specs<Char>& specs, GetArg get_arg) {
-  int arg_index = -1;
-  Char c = *it;
-  if (c >= '0' && c <= '9') {
-    // Parse an argument index (if followed by '$') or a width possibly
-    // preceded with '0' flag(s).
-    int value = parse_nonnegative_int(it, end, -1);
-    if (it != end && *it == '$') {  // value is an argument index
-      ++it;
-      arg_index = value != -1 ? value : max_value<int>();
-    } else {
-      if (c == '0') specs.fill[0] = '0';
-      if (value != 0) {
-        // Nonzero value means that we parsed width and don't need to
-        // parse it or flags again, so return now.
-        if (value == -1) FMT_THROW(format_error("number is too big"));
-        specs.width = value;
-        return arg_index;
-      }
-    }
-  }
-  parse_flags(specs, it, end);
-  // Parse width.
-  if (it != end) {
-    if (*it >= '0' && *it <= '9') {
-      specs.width = parse_nonnegative_int(it, end, -1);
-      if (specs.width == -1) FMT_THROW(format_error("number is too big"));
-    } else if (*it == '*') {
-      ++it;
-      specs.width = static_cast<int>(visit_format_arg(
-          detail::printf_width_handler<Char>(specs), get_arg(-1)));
-    }
-  }
-  return arg_index;
-}
-
-template <typename Char, typename Context>
-void vprintf(buffer<Char>& buf, basic_string_view<Char> format,
-             basic_format_args<Context> args) {
-  using OutputIt = buffer_appender<Char>;
-  auto out = OutputIt(buf);
-  auto context = basic_printf_context<OutputIt, Char>(out, args);
-  auto parse_ctx = basic_printf_parse_context<Char>(format);
-
-  // Returns the argument with specified index or, if arg_index is -1, the next
-  // argument.
-  auto get_arg = [&](int arg_index) {
-    if (arg_index < 0)
-      arg_index = parse_ctx.next_arg_id();
-    else
-      parse_ctx.check_arg_id(--arg_index);
-    return detail::get_arg(context, arg_index);
-  };
-
-  const Char* start = parse_ctx.begin();
-  const Char* end = parse_ctx.end();
-  auto it = start;
-  while (it != end) {
-    if (!detail::find<false, Char>(it, end, '%', it)) {
-      it = end;  // detail::find leaves it == nullptr if it doesn't find '%'
-      break;
-    }
-    Char c = *it++;
-    if (it != end && *it == c) {
-      out = detail::write(
-          out, basic_string_view<Char>(start, detail::to_unsigned(it - start)));
-      start = ++it;
-      continue;
-    }
-    out = detail::write(out, basic_string_view<Char>(
-                                 start, detail::to_unsigned(it - 1 - start)));
-
-    basic_format_specs<Char> specs;
-    specs.align = align::right;
-
-    // Parse argument index, flags and width.
-    int arg_index = parse_header(it, end, specs, get_arg);
-    if (arg_index == 0) parse_ctx.on_error("argument not found");
-
-    // Parse precision.
-    if (it != end && *it == '.') {
-      ++it;
-      c = it != end ? *it : 0;
-      if ('0' <= c && c <= '9') {
-        specs.precision = parse_nonnegative_int(it, end, 0);
-      } else if (c == '*') {
-        ++it;
-        specs.precision = static_cast<int>(
-            visit_format_arg(detail::printf_precision_handler(), get_arg(-1)));
-      } else {
-        specs.precision = 0;
-      }
-    }
-
-    auto arg = get_arg(arg_index);
-    // For d, i, o, u, x, and X conversion specifiers, if a precision is
-    // specified, the '0' flag is ignored
-    if (specs.precision >= 0 && arg.is_integral())
-      specs.fill[0] =
-          ' ';  // Ignore '0' flag for non-numeric types or if '-' present.
-    if (specs.precision >= 0 && arg.type() == detail::type::cstring_type) {
-      auto str = visit_format_arg(detail::get_cstring<Char>(), arg);
-      auto str_end = str + specs.precision;
-      auto nul = std::find(str, str_end, Char());
-      arg = detail::make_arg<basic_printf_context<OutputIt, Char>>(
-          basic_string_view<Char>(
-              str, detail::to_unsigned(nul != str_end ? nul - str
-                                                      : specs.precision)));
-    }
-    if (specs.alt && visit_format_arg(detail::is_zero_int(), arg))
-      specs.alt = false;
-    if (specs.fill[0] == '0') {
-      if (arg.is_arithmetic() && specs.align != align::left)
-        specs.align = align::numeric;
-      else
-        specs.fill[0] = ' ';  // Ignore '0' flag for non-numeric types or if '-'
-                              // flag is also present.
-    }
-
-    // Parse length and convert the argument to the required type.
-    c = it != end ? *it++ : 0;
-    Char t = it != end ? *it : 0;
-    using detail::convert_arg;
-    switch (c) {
-    case 'h':
-      if (t == 'h') {
-        ++it;
-        t = it != end ? *it : 0;
-        convert_arg<signed char>(arg, t);
-      } else {
-        convert_arg<short>(arg, t);
-      }
-      break;
-    case 'l':
-      if (t == 'l') {
-        ++it;
-        t = it != end ? *it : 0;
-        convert_arg<long long>(arg, t);
-      } else {
-        convert_arg<long>(arg, t);
-      }
-      break;
-    case 'j':
-      convert_arg<intmax_t>(arg, t);
-      break;
-    case 'z':
-      convert_arg<size_t>(arg, t);
-      break;
-    case 't':
-      convert_arg<std::ptrdiff_t>(arg, t);
-      break;
-    case 'L':
-      // printf produces garbage when 'L' is omitted for long double, no
-      // need to do the same.
-      break;
-    default:
-      --it;
-      convert_arg<void>(arg, c);
-    }
-
-    // Parse type.
-    if (it == end) FMT_THROW(format_error("invalid format string"));
-    char type = static_cast<char>(*it++);
-    if (arg.is_integral()) {
-      // Normalize type.
-      switch (type) {
-      case 'i':
-      case 'u':
-        type = 'd';
-        break;
-      case 'c':
-        visit_format_arg(
-            detail::char_converter<basic_printf_context<OutputIt, Char>>(arg),
-            arg);
-        break;
-      }
-    }
-    specs.type = parse_presentation_type(type);
-    if (specs.type == presentation_type::none)
-      parse_ctx.on_error("invalid type specifier");
-
-    start = it;
-
-    // Format argument.
-    out = visit_format_arg(
-        detail::printf_arg_formatter<OutputIt, Char>(out, specs, context), arg);
-  }
-  detail::write(out, basic_string_view<Char>(start, to_unsigned(it - start)));
-}
-FMT_END_DETAIL_NAMESPACE
-
-template <typename Char>
-using basic_printf_context_t =
-    basic_printf_context<detail::buffer_appender<Char>, Char>;
-
-using printf_context = basic_printf_context_t<char>;
-using wprintf_context = basic_printf_context_t<wchar_t>;
-
-using printf_args = basic_format_args<printf_context>;
-using wprintf_args = basic_format_args<wprintf_context>;
-
-/**
-  \rst
-  Constructs an `~fmt::format_arg_store` object that contains references to
-  arguments and can be implicitly converted to `~fmt::printf_args`.
-  \endrst
- */
-template <typename... T>
-inline auto make_printf_args(const T&... args)
-    -> format_arg_store<printf_context, T...> {
-  return {args...};
-}
-
-/**
-  \rst
-  Constructs an `~fmt::format_arg_store` object that contains references to
-  arguments and can be implicitly converted to `~fmt::wprintf_args`.
-  \endrst
- */
-template <typename... T>
-inline auto make_wprintf_args(const T&... args)
-    -> format_arg_store<wprintf_context, T...> {
-  return {args...};
-}
-
-template <typename S, typename Char = char_t<S>>
-inline auto vsprintf(
-    const S& fmt,
-    basic_format_args<basic_printf_context_t<type_identity_t<Char>>> args)
-    -> std::basic_string<Char> {
-  basic_memory_buffer<Char> buffer;
-  vprintf(buffer, detail::to_string_view(fmt), args);
-  return to_string(buffer);
-}
-
-/**
-  \rst
-  Formats arguments and returns the result as a string.
-
-  **Example**::
-
-    std::string message = fmt::sprintf("The answer is %d", 42);
-  \endrst
-*/
-template <typename S, typename... T,
-          typename Char = enable_if_t<detail::is_string<S>::value, char_t<S>>>
-inline auto sprintf(const S& fmt, const T&... args) -> std::basic_string<Char> {
-  using context = basic_printf_context_t<Char>;
-  return vsprintf(detail::to_string_view(fmt),
-                  fmt::make_format_args<context>(args...));
-}
-
-template <typename S, typename Char = char_t<S>>
-inline auto vfprintf(
-    std::FILE* f, const S& fmt,
-    basic_format_args<basic_printf_context_t<type_identity_t<Char>>> args)
-    -> int {
-  basic_memory_buffer<Char> buffer;
-  vprintf(buffer, detail::to_string_view(fmt), args);
-  size_t size = buffer.size();
-  return std::fwrite(buffer.data(), sizeof(Char), size, f) < size
-             ? -1
-             : static_cast<int>(size);
-}
-
-/**
-  \rst
-  Prints formatted data to the file *f*.
-
-  **Example**::
-
-    fmt::fprintf(stderr, "Don't %s!", "panic");
-  \endrst
- */
-template <typename S, typename... T, typename Char = char_t<S>>
-inline auto fprintf(std::FILE* f, const S& fmt, const T&... args) -> int {
-  using context = basic_printf_context_t<Char>;
-  return vfprintf(f, detail::to_string_view(fmt),
-                  fmt::make_format_args<context>(args...));
-}
-
-template <typename S, typename Char = char_t<S>>
-inline auto vprintf(
-    const S& fmt,
-    basic_format_args<basic_printf_context_t<type_identity_t<Char>>> args)
-    -> int {
-  return vfprintf(stdout, detail::to_string_view(fmt), args);
-}
-
-/**
-  \rst
-  Prints formatted data to ``stdout``.
-
-  **Example**::
-
-    fmt::printf("Elapsed time: %.2f seconds", 1.23);
-  \endrst
- */
-template <typename S, typename... T, FMT_ENABLE_IF(detail::is_string<S>::value)>
-inline auto printf(const S& fmt, const T&... args) -> int {
-  return vprintf(
-      detail::to_string_view(fmt),
-      fmt::make_format_args<basic_printf_context_t<char_t<S>>>(args...));
-}
-
-FMT_MODULE_EXPORT_END
-FMT_END_NAMESPACE
-
-#endif  // FMT_PRINTF_H_
diff --git a/Externals/fmt/include/fmt/ranges.h b/Externals/fmt/include/fmt/ranges.h
deleted file mode 100755
index dea7d60dd6bb..000000000000
--- a/Externals/fmt/include/fmt/ranges.h
+++ /dev/null
@@ -1,722 +0,0 @@
-// Formatting library for C++ - experimental range support
-//
-// Copyright (c) 2012 - present, Victor Zverovich
-// All rights reserved.
-//
-// For the license information refer to format.h.
-//
-// Copyright (c) 2018 - present, Remotion (Igor Schulz)
-// All Rights Reserved
-// {fmt} support for ranges, containers and types tuple interface.
-
-#ifndef FMT_RANGES_H_
-#define FMT_RANGES_H_
-
-#include <initializer_list>
-#include <tuple>
-#include <type_traits>
-
-#include "format.h"
-
-FMT_BEGIN_NAMESPACE
-
-namespace detail {
-
-template <typename RangeT, typename OutputIterator>
-OutputIterator copy(const RangeT& range, OutputIterator out) {
-  for (auto it = range.begin(), end = range.end(); it != end; ++it)
-    *out++ = *it;
-  return out;
-}
-
-template <typename OutputIterator>
-OutputIterator copy(const char* str, OutputIterator out) {
-  while (*str) *out++ = *str++;
-  return out;
-}
-
-template <typename OutputIterator>
-OutputIterator copy(char ch, OutputIterator out) {
-  *out++ = ch;
-  return out;
-}
-
-template <typename OutputIterator>
-OutputIterator copy(wchar_t ch, OutputIterator out) {
-  *out++ = ch;
-  return out;
-}
-
-// Returns true if T has a std::string-like interface, like std::string_view.
-template <typename T> class is_std_string_like {
-  template <typename U>
-  static auto check(U* p)
-      -> decltype((void)p->find('a'), p->length(), (void)p->data(), int());
-  template <typename> static void check(...);
-
- public:
-  static constexpr const bool value =
-      is_string<T>::value ||
-      std::is_convertible<T, std_string_view<char>>::value ||
-      !std::is_void<decltype(check<T>(nullptr))>::value;
-};
-
-template <typename Char>
-struct is_std_string_like<fmt::basic_string_view<Char>> : std::true_type {};
-
-template <typename T> class is_map {
-  template <typename U> static auto check(U*) -> typename U::mapped_type;
-  template <typename> static void check(...);
-
- public:
-#ifdef FMT_FORMAT_MAP_AS_LIST
-  static constexpr const bool value = false;
-#else
-  static constexpr const bool value =
-      !std::is_void<decltype(check<T>(nullptr))>::value;
-#endif
-};
-
-template <typename T> class is_set {
-  template <typename U> static auto check(U*) -> typename U::key_type;
-  template <typename> static void check(...);
-
- public:
-#ifdef FMT_FORMAT_SET_AS_LIST
-  static constexpr const bool value = false;
-#else
-  static constexpr const bool value =
-      !std::is_void<decltype(check<T>(nullptr))>::value && !is_map<T>::value;
-#endif
-};
-
-template <typename... Ts> struct conditional_helper {};
-
-template <typename T, typename _ = void> struct is_range_ : std::false_type {};
-
-#if !FMT_MSC_VERSION || FMT_MSC_VERSION > 1800
-
-#  define FMT_DECLTYPE_RETURN(val)  \
-    ->decltype(val) { return val; } \
-    static_assert(                  \
-        true, "")  // This makes it so that a semicolon is required after the
-                   // macro, which helps clang-format handle the formatting.
-
-// C array overload
-template <typename T, std::size_t N>
-auto range_begin(const T (&arr)[N]) -> const T* {
-  return arr;
-}
-template <typename T, std::size_t N>
-auto range_end(const T (&arr)[N]) -> const T* {
-  return arr + N;
-}
-
-template <typename T, typename Enable = void>
-struct has_member_fn_begin_end_t : std::false_type {};
-
-template <typename T>
-struct has_member_fn_begin_end_t<T, void_t<decltype(std::declval<T>().begin()),
-                                           decltype(std::declval<T>().end())>>
-    : std::true_type {};
-
-// Member function overload
-template <typename T>
-auto range_begin(T&& rng) FMT_DECLTYPE_RETURN(static_cast<T&&>(rng).begin());
-template <typename T>
-auto range_end(T&& rng) FMT_DECLTYPE_RETURN(static_cast<T&&>(rng).end());
-
-// ADL overload. Only participates in overload resolution if member functions
-// are not found.
-template <typename T>
-auto range_begin(T&& rng)
-    -> enable_if_t<!has_member_fn_begin_end_t<T&&>::value,
-                   decltype(begin(static_cast<T&&>(rng)))> {
-  return begin(static_cast<T&&>(rng));
-}
-template <typename T>
-auto range_end(T&& rng) -> enable_if_t<!has_member_fn_begin_end_t<T&&>::value,
-                                       decltype(end(static_cast<T&&>(rng)))> {
-  return end(static_cast<T&&>(rng));
-}
-
-template <typename T, typename Enable = void>
-struct has_const_begin_end : std::false_type {};
-template <typename T, typename Enable = void>
-struct has_mutable_begin_end : std::false_type {};
-
-template <typename T>
-struct has_const_begin_end<
-    T,
-    void_t<
-        decltype(detail::range_begin(std::declval<const remove_cvref_t<T>&>())),
-        decltype(detail::range_end(std::declval<const remove_cvref_t<T>&>()))>>
-    : std::true_type {};
-
-template <typename T>
-struct has_mutable_begin_end<
-    T, void_t<decltype(detail::range_begin(std::declval<T>())),
-              decltype(detail::range_end(std::declval<T>())),
-              enable_if_t<std::is_copy_constructible<T>::value>>>
-    : std::true_type {};
-
-template <typename T>
-struct is_range_<T, void>
-    : std::integral_constant<bool, (has_const_begin_end<T>::value ||
-                                    has_mutable_begin_end<T>::value)> {};
-#  undef FMT_DECLTYPE_RETURN
-#endif
-
-// tuple_size and tuple_element check.
-template <typename T> class is_tuple_like_ {
-  template <typename U>
-  static auto check(U* p) -> decltype(std::tuple_size<U>::value, int());
-  template <typename> static void check(...);
-
- public:
-  static constexpr const bool value =
-      !std::is_void<decltype(check<T>(nullptr))>::value;
-};
-
-// Check for integer_sequence
-#if defined(__cpp_lib_integer_sequence) || FMT_MSC_VERSION >= 1900
-template <typename T, T... N>
-using integer_sequence = std::integer_sequence<T, N...>;
-template <size_t... N> using index_sequence = std::index_sequence<N...>;
-template <size_t N> using make_index_sequence = std::make_index_sequence<N>;
-#else
-template <typename T, T... N> struct integer_sequence {
-  using value_type = T;
-
-  static FMT_CONSTEXPR size_t size() { return sizeof...(N); }
-};
-
-template <size_t... N> using index_sequence = integer_sequence<size_t, N...>;
-
-template <typename T, size_t N, T... Ns>
-struct make_integer_sequence : make_integer_sequence<T, N - 1, N - 1, Ns...> {};
-template <typename T, T... Ns>
-struct make_integer_sequence<T, 0, Ns...> : integer_sequence<T, Ns...> {};
-
-template <size_t N>
-using make_index_sequence = make_integer_sequence<size_t, N>;
-#endif
-
-template <typename T>
-using tuple_index_sequence = make_index_sequence<std::tuple_size<T>::value>;
-
-template <typename T, typename C, bool = is_tuple_like_<T>::value>
-class is_tuple_formattable_ {
- public:
-  static constexpr const bool value = false;
-};
-template <typename T, typename C> class is_tuple_formattable_<T, C, true> {
-  template <std::size_t... I>
-  static std::true_type check2(index_sequence<I...>,
-                               integer_sequence<bool, (I == I)...>);
-  static std::false_type check2(...);
-  template <std::size_t... I>
-  static decltype(check2(
-      index_sequence<I...>{},
-      integer_sequence<
-          bool, (is_formattable<typename std::tuple_element<I, T>::type,
-                                C>::value)...>{})) check(index_sequence<I...>);
-
- public:
-  static constexpr const bool value =
-      decltype(check(tuple_index_sequence<T>{}))::value;
-};
-
-template <class Tuple, class F, size_t... Is>
-void for_each(index_sequence<Is...>, Tuple&& tup, F&& f) noexcept {
-  using std::get;
-  // using free function get<I>(T) now.
-  const int _[] = {0, ((void)f(get<Is>(tup)), 0)...};
-  (void)_;  // blocks warnings
-}
-
-template <class T>
-FMT_CONSTEXPR make_index_sequence<std::tuple_size<T>::value> get_indexes(
-    T const&) {
-  return {};
-}
-
-template <class Tuple, class F> void for_each(Tuple&& tup, F&& f) {
-  const auto indexes = get_indexes(tup);
-  for_each(indexes, std::forward<Tuple>(tup), std::forward<F>(f));
-}
-
-#if FMT_MSC_VERSION && FMT_MSC_VERSION < 1920
-// Older MSVC doesn't get the reference type correctly for arrays.
-template <typename R> struct range_reference_type_impl {
-  using type = decltype(*detail::range_begin(std::declval<R&>()));
-};
-
-template <typename T, std::size_t N> struct range_reference_type_impl<T[N]> {
-  using type = T&;
-};
-
-template <typename T>
-using range_reference_type = typename range_reference_type_impl<T>::type;
-#else
-template <typename Range>
-using range_reference_type =
-    decltype(*detail::range_begin(std::declval<Range&>()));
-#endif
-
-// We don't use the Range's value_type for anything, but we do need the Range's
-// reference type, with cv-ref stripped.
-template <typename Range>
-using uncvref_type = remove_cvref_t<range_reference_type<Range>>;
-
-template <typename Range>
-using uncvref_first_type =
-    remove_cvref_t<decltype(std::declval<range_reference_type<Range>>().first)>;
-
-template <typename Range>
-using uncvref_second_type = remove_cvref_t<
-    decltype(std::declval<range_reference_type<Range>>().second)>;
-
-template <typename OutputIt> OutputIt write_delimiter(OutputIt out) {
-  *out++ = ',';
-  *out++ = ' ';
-  return out;
-}
-
-template <typename Char, typename OutputIt>
-auto write_range_entry(OutputIt out, basic_string_view<Char> str) -> OutputIt {
-  return write_escaped_string(out, str);
-}
-
-template <typename Char, typename OutputIt, typename T,
-          FMT_ENABLE_IF(std::is_convertible<T, std_string_view<char>>::value)>
-inline auto write_range_entry(OutputIt out, const T& str) -> OutputIt {
-  auto sv = std_string_view<Char>(str);
-  return write_range_entry<Char>(out, basic_string_view<Char>(sv));
-}
-
-template <typename Char, typename OutputIt, typename Arg,
-          FMT_ENABLE_IF(std::is_same<Arg, Char>::value)>
-OutputIt write_range_entry(OutputIt out, const Arg v) {
-  return write_escaped_char(out, v);
-}
-
-template <
-    typename Char, typename OutputIt, typename Arg,
-    FMT_ENABLE_IF(!is_std_string_like<typename std::decay<Arg>::type>::value &&
-                  !std::is_same<Arg, Char>::value)>
-OutputIt write_range_entry(OutputIt out, const Arg& v) {
-  return write<Char>(out, v);
-}
-
-}  // namespace detail
-
-template <typename T> struct is_tuple_like {
-  static constexpr const bool value =
-      detail::is_tuple_like_<T>::value && !detail::is_range_<T>::value;
-};
-
-template <typename T, typename C> struct is_tuple_formattable {
-  static constexpr const bool value =
-      detail::is_tuple_formattable_<T, C>::value;
-};
-
-template <typename TupleT, typename Char>
-struct formatter<TupleT, Char,
-                 enable_if_t<fmt::is_tuple_like<TupleT>::value &&
-                             fmt::is_tuple_formattable<TupleT, Char>::value>> {
- private:
-  basic_string_view<Char> separator_ = detail::string_literal<Char, ',', ' '>{};
-  basic_string_view<Char> opening_bracket_ =
-      detail::string_literal<Char, '('>{};
-  basic_string_view<Char> closing_bracket_ =
-      detail::string_literal<Char, ')'>{};
-
-  // C++11 generic lambda for format().
-  template <typename FormatContext> struct format_each {
-    template <typename T> void operator()(const T& v) {
-      if (i > 0) out = detail::copy_str<Char>(separator, out);
-      out = detail::write_range_entry<Char>(out, v);
-      ++i;
-    }
-    int i;
-    typename FormatContext::iterator& out;
-    basic_string_view<Char> separator;
-  };
-
- public:
-  FMT_CONSTEXPR formatter() {}
-
-  FMT_CONSTEXPR void set_separator(basic_string_view<Char> sep) {
-    separator_ = sep;
-  }
-
-  FMT_CONSTEXPR void set_brackets(basic_string_view<Char> open,
-                                  basic_string_view<Char> close) {
-    opening_bracket_ = open;
-    closing_bracket_ = close;
-  }
-
-  template <typename ParseContext>
-  FMT_CONSTEXPR auto parse(ParseContext& ctx) -> decltype(ctx.begin()) {
-    return ctx.begin();
-  }
-
-  template <typename FormatContext = format_context>
-  auto format(const TupleT& values, FormatContext& ctx) const
-      -> decltype(ctx.out()) {
-    auto out = ctx.out();
-    out = detail::copy_str<Char>(opening_bracket_, out);
-    detail::for_each(values, format_each<FormatContext>{0, out, separator_});
-    out = detail::copy_str<Char>(closing_bracket_, out);
-    return out;
-  }
-};
-
-template <typename T, typename Char> struct is_range {
-  static constexpr const bool value =
-      detail::is_range_<T>::value && !detail::is_std_string_like<T>::value &&
-      !std::is_convertible<T, std::basic_string<Char>>::value &&
-      !std::is_convertible<T, detail::std_string_view<Char>>::value;
-};
-
-namespace detail {
-template <typename Context> struct range_mapper {
-  using mapper = arg_mapper<Context>;
-
-  template <typename T,
-            FMT_ENABLE_IF(has_formatter<remove_cvref_t<T>, Context>::value)>
-  static auto map(T&& value) -> T&& {
-    return static_cast<T&&>(value);
-  }
-  template <typename T,
-            FMT_ENABLE_IF(!has_formatter<remove_cvref_t<T>, Context>::value)>
-  static auto map(T&& value)
-      -> decltype(mapper().map(static_cast<T&&>(value))) {
-    return mapper().map(static_cast<T&&>(value));
-  }
-};
-
-template <typename Char, typename Element>
-using range_formatter_type = conditional_t<
-    is_formattable<Element, Char>::value,
-    formatter<remove_cvref_t<decltype(range_mapper<buffer_context<Char>>{}.map(
-                  std::declval<Element>()))>,
-              Char>,
-    fallback_formatter<Element, Char>>;
-
-template <typename R>
-using maybe_const_range =
-    conditional_t<has_const_begin_end<R>::value, const R, R>;
-
-// Workaround a bug in MSVC 2015 and earlier.
-#if !FMT_MSC_VERSION || FMT_MSC_VERSION >= 1910
-template <typename R, typename Char>
-struct is_formattable_delayed
-    : disjunction<
-          is_formattable<uncvref_type<maybe_const_range<R>>, Char>,
-          has_fallback_formatter<uncvref_type<maybe_const_range<R>>, Char>> {};
-#endif
-
-}  // namespace detail
-
-template <typename T, typename Char, typename Enable = void>
-struct range_formatter;
-
-template <typename T, typename Char>
-struct range_formatter<
-    T, Char,
-    enable_if_t<conjunction<
-        std::is_same<T, remove_cvref_t<T>>,
-        disjunction<is_formattable<T, Char>,
-                    detail::has_fallback_formatter<T, Char>>>::value>> {
- private:
-  detail::range_formatter_type<Char, T> underlying_;
-  bool custom_specs_ = false;
-  basic_string_view<Char> separator_ = detail::string_literal<Char, ',', ' '>{};
-  basic_string_view<Char> opening_bracket_ =
-      detail::string_literal<Char, '['>{};
-  basic_string_view<Char> closing_bracket_ =
-      detail::string_literal<Char, ']'>{};
-
-  template <class U>
-  FMT_CONSTEXPR static auto maybe_set_debug_format(U& u, int)
-      -> decltype(u.set_debug_format()) {
-    u.set_debug_format();
-  }
-
-  template <class U>
-  FMT_CONSTEXPR static void maybe_set_debug_format(U&, ...) {}
-
-  FMT_CONSTEXPR void maybe_set_debug_format() {
-    maybe_set_debug_format(underlying_, 0);
-  }
-
- public:
-  FMT_CONSTEXPR range_formatter() {}
-
-  FMT_CONSTEXPR auto underlying() -> detail::range_formatter_type<Char, T>& {
-    return underlying_;
-  }
-
-  FMT_CONSTEXPR void set_separator(basic_string_view<Char> sep) {
-    separator_ = sep;
-  }
-
-  FMT_CONSTEXPR void set_brackets(basic_string_view<Char> open,
-                                  basic_string_view<Char> close) {
-    opening_bracket_ = open;
-    closing_bracket_ = close;
-  }
-
-  template <typename ParseContext>
-  FMT_CONSTEXPR auto parse(ParseContext& ctx) -> decltype(ctx.begin()) {
-    auto it = ctx.begin();
-    auto end = ctx.end();
-    if (it == end || *it == '}') {
-      maybe_set_debug_format();
-      return it;
-    }
-
-    if (*it == 'n') {
-      set_brackets({}, {});
-      ++it;
-    }
-
-    if (*it == '}') {
-      maybe_set_debug_format();
-      return it;
-    }
-
-    if (*it != ':')
-      FMT_THROW(format_error("no other top-level range formatters supported"));
-
-    custom_specs_ = true;
-    ++it;
-    ctx.advance_to(it);
-    return underlying_.parse(ctx);
-  }
-
-  template <typename R, class FormatContext>
-  auto format(R&& range, FormatContext& ctx) const -> decltype(ctx.out()) {
-    detail::range_mapper<buffer_context<Char>> mapper;
-    auto out = ctx.out();
-    out = detail::copy_str<Char>(opening_bracket_, out);
-    int i = 0;
-    auto it = detail::range_begin(range);
-    auto end = detail::range_end(range);
-    for (; it != end; ++it) {
-      if (i > 0) out = detail::copy_str<Char>(separator_, out);
-      ;
-      ctx.advance_to(out);
-      out = underlying_.format(mapper.map(*it), ctx);
-      ++i;
-    }
-    out = detail::copy_str<Char>(closing_bracket_, out);
-    return out;
-  }
-};
-
-enum class range_format { disabled, map, set, sequence, string, debug_string };
-
-namespace detail {
-template <typename T> struct range_format_kind_ {
-  static constexpr auto value = std::is_same<range_reference_type<T>, T>::value
-                                    ? range_format::disabled
-                                : is_map<T>::value ? range_format::map
-                                : is_set<T>::value ? range_format::set
-                                                   : range_format::sequence;
-};
-
-template <range_format K, typename R, typename Char, typename Enable = void>
-struct range_default_formatter;
-
-template <range_format K>
-using range_format_constant = std::integral_constant<range_format, K>;
-
-template <range_format K, typename R, typename Char>
-struct range_default_formatter<
-    K, R, Char,
-    enable_if_t<(K == range_format::sequence || K == range_format::map ||
-                 K == range_format::set)>> {
-  using range_type = detail::maybe_const_range<R>;
-  range_formatter<detail::uncvref_type<range_type>, Char> underlying_;
-
-  FMT_CONSTEXPR range_default_formatter() { init(range_format_constant<K>()); }
-
-  FMT_CONSTEXPR void init(range_format_constant<range_format::set>) {
-    underlying_.set_brackets(detail::string_literal<Char, '{'>{},
-                             detail::string_literal<Char, '}'>{});
-  }
-
-  FMT_CONSTEXPR void init(range_format_constant<range_format::map>) {
-    underlying_.set_brackets(detail::string_literal<Char, '{'>{},
-                             detail::string_literal<Char, '}'>{});
-    underlying_.underlying().set_brackets({}, {});
-    underlying_.underlying().set_separator(
-        detail::string_literal<Char, ':', ' '>{});
-  }
-
-  FMT_CONSTEXPR void init(range_format_constant<range_format::sequence>) {}
-
-  template <typename ParseContext>
-  FMT_CONSTEXPR auto parse(ParseContext& ctx) -> decltype(ctx.begin()) {
-    return underlying_.parse(ctx);
-  }
-
-  template <typename FormatContext>
-  auto format(range_type& range, FormatContext& ctx) const
-      -> decltype(ctx.out()) {
-    return underlying_.format(range, ctx);
-  }
-};
-}  // namespace detail
-
-template <typename T, typename Char, typename Enable = void>
-struct range_format_kind
-    : conditional_t<
-          is_range<T, Char>::value, detail::range_format_kind_<T>,
-          std::integral_constant<range_format, range_format::disabled>> {};
-
-template <typename R, typename Char>
-struct formatter<
-    R, Char,
-    enable_if_t<conjunction<bool_constant<range_format_kind<R, Char>::value !=
-                                          range_format::disabled>
-// Workaround a bug in MSVC 2015 and earlier.
-#if !FMT_MSC_VERSION || FMT_MSC_VERSION >= 1910
-                            ,
-                            detail::is_formattable_delayed<R, Char>
-#endif
-                            >::value>>
-    : detail::range_default_formatter<range_format_kind<R, Char>::value, R,
-                                      Char> {
-};
-
-template <typename Char, typename... T> struct tuple_join_view : detail::view {
-  const std::tuple<T...>& tuple;
-  basic_string_view<Char> sep;
-
-  tuple_join_view(const std::tuple<T...>& t, basic_string_view<Char> s)
-      : tuple(t), sep{s} {}
-};
-
-template <typename Char, typename... T>
-using tuple_arg_join = tuple_join_view<Char, T...>;
-
-// Define FMT_TUPLE_JOIN_SPECIFIERS to enable experimental format specifiers
-// support in tuple_join. It is disabled by default because of issues with
-// the dynamic width and precision.
-#ifndef FMT_TUPLE_JOIN_SPECIFIERS
-#  define FMT_TUPLE_JOIN_SPECIFIERS 0
-#endif
-
-template <typename Char, typename... T>
-struct formatter<tuple_join_view<Char, T...>, Char> {
-  template <typename ParseContext>
-  FMT_CONSTEXPR auto parse(ParseContext& ctx) -> decltype(ctx.begin()) {
-    return do_parse(ctx, std::integral_constant<size_t, sizeof...(T)>());
-  }
-
-  template <typename FormatContext>
-  auto format(const tuple_join_view<Char, T...>& value,
-              FormatContext& ctx) const -> typename FormatContext::iterator {
-    return do_format(value, ctx,
-                     std::integral_constant<size_t, sizeof...(T)>());
-  }
-
- private:
-  std::tuple<formatter<typename std::decay<T>::type, Char>...> formatters_;
-
-  template <typename ParseContext>
-  FMT_CONSTEXPR auto do_parse(ParseContext& ctx,
-                              std::integral_constant<size_t, 0>)
-      -> decltype(ctx.begin()) {
-    return ctx.begin();
-  }
-
-  template <typename ParseContext, size_t N>
-  FMT_CONSTEXPR auto do_parse(ParseContext& ctx,
-                              std::integral_constant<size_t, N>)
-      -> decltype(ctx.begin()) {
-    auto end = ctx.begin();
-#if FMT_TUPLE_JOIN_SPECIFIERS
-    end = std::get<sizeof...(T) - N>(formatters_).parse(ctx);
-    if (N > 1) {
-      auto end1 = do_parse(ctx, std::integral_constant<size_t, N - 1>());
-      if (end != end1)
-        FMT_THROW(format_error("incompatible format specs for tuple elements"));
-    }
-#endif
-    return end;
-  }
-
-  template <typename FormatContext>
-  auto do_format(const tuple_join_view<Char, T...>&, FormatContext& ctx,
-                 std::integral_constant<size_t, 0>) const ->
-      typename FormatContext::iterator {
-    return ctx.out();
-  }
-
-  template <typename FormatContext, size_t N>
-  auto do_format(const tuple_join_view<Char, T...>& value, FormatContext& ctx,
-                 std::integral_constant<size_t, N>) const ->
-      typename FormatContext::iterator {
-    auto out = std::get<sizeof...(T) - N>(formatters_)
-                   .format(std::get<sizeof...(T) - N>(value.tuple), ctx);
-    if (N > 1) {
-      out = std::copy(value.sep.begin(), value.sep.end(), out);
-      ctx.advance_to(out);
-      return do_format(value, ctx, std::integral_constant<size_t, N - 1>());
-    }
-    return out;
-  }
-};
-
-FMT_MODULE_EXPORT_BEGIN
-
-/**
-  \rst
-  Returns an object that formats `tuple` with elements separated by `sep`.
-
-  **Example**::
-
-    std::tuple<int, char> t = {1, 'a'};
-    fmt::print("{}", fmt::join(t, ", "));
-    // Output: "1, a"
-  \endrst
- */
-template <typename... T>
-FMT_CONSTEXPR auto join(const std::tuple<T...>& tuple, string_view sep)
-    -> tuple_join_view<char, T...> {
-  return {tuple, sep};
-}
-
-template <typename... T>
-FMT_CONSTEXPR auto join(const std::tuple<T...>& tuple,
-                        basic_string_view<wchar_t> sep)
-    -> tuple_join_view<wchar_t, T...> {
-  return {tuple, sep};
-}
-
-/**
-  \rst
-  Returns an object that formats `initializer_list` with elements separated by
-  `sep`.
-
-  **Example**::
-
-    fmt::print("{}", fmt::join({1, 2, 3}, ", "));
-    // Output: "1, 2, 3"
-  \endrst
- */
-template <typename T>
-auto join(std::initializer_list<T> list, string_view sep)
-    -> join_view<const T*, const T*> {
-  return join(std::begin(list), std::end(list), sep);
-}
-
-FMT_MODULE_EXPORT_END
-FMT_END_NAMESPACE
-
-#endif  // FMT_RANGES_H_
diff --git a/Externals/fmt/include/fmt/std.h b/Externals/fmt/include/fmt/std.h
deleted file mode 100644
index 41d2b2838b6d..000000000000
--- a/Externals/fmt/include/fmt/std.h
+++ /dev/null
@@ -1,171 +0,0 @@
-// Formatting library for C++ - formatters for standard library types
-//
-// Copyright (c) 2012 - present, Victor Zverovich
-// All rights reserved.
-//
-// For the license information refer to format.h.
-
-#ifndef FMT_STD_H_
-#define FMT_STD_H_
-
-#include <thread>
-#include <type_traits>
-#include <utility>
-
-#include "ostream.h"
-
-#if FMT_HAS_INCLUDE(<version>)
-#  include <version>
-#endif
-// Checking FMT_CPLUSPLUS for warning suppression in MSVC.
-#if FMT_CPLUSPLUS >= 201703L
-#  if FMT_HAS_INCLUDE(<filesystem>)
-#    include <filesystem>
-#  endif
-#  if FMT_HAS_INCLUDE(<variant>)
-#    include <variant>
-#  endif
-#endif
-
-#ifdef __cpp_lib_filesystem
-FMT_BEGIN_NAMESPACE
-
-namespace detail {
-
-template <typename Char>
-void write_escaped_path(basic_memory_buffer<Char>& quoted,
-                        const std::filesystem::path& p) {
-  write_escaped_string<Char>(std::back_inserter(quoted), p.string<Char>());
-}
-#  ifdef _WIN32
-template <>
-inline void write_escaped_path<char>(basic_memory_buffer<char>& quoted,
-                                     const std::filesystem::path& p) {
-  auto s = p.u8string();
-  write_escaped_string<char>(
-      std::back_inserter(quoted),
-      string_view(reinterpret_cast<const char*>(s.c_str()), s.size()));
-}
-#  endif
-template <>
-inline void write_escaped_path<std::filesystem::path::value_type>(
-    basic_memory_buffer<std::filesystem::path::value_type>& quoted,
-    const std::filesystem::path& p) {
-  write_escaped_string<std::filesystem::path::value_type>(
-      std::back_inserter(quoted), p.native());
-}
-
-}  // namespace detail
-
-template <typename Char>
-struct formatter<std::filesystem::path, Char>
-    : formatter<basic_string_view<Char>> {
-  template <typename FormatContext>
-  auto format(const std::filesystem::path& p, FormatContext& ctx) const ->
-      typename FormatContext::iterator {
-    basic_memory_buffer<Char> quoted;
-    detail::write_escaped_path(quoted, p);
-    return formatter<basic_string_view<Char>>::format(
-        basic_string_view<Char>(quoted.data(), quoted.size()), ctx);
-  }
-};
-FMT_END_NAMESPACE
-#endif
-
-FMT_BEGIN_NAMESPACE
-template <typename Char>
-struct formatter<std::thread::id, Char> : basic_ostream_formatter<Char> {};
-FMT_END_NAMESPACE
-
-#ifdef __cpp_lib_variant
-FMT_BEGIN_NAMESPACE
-template <typename Char> struct formatter<std::monostate, Char> {
-  template <typename ParseContext>
-  FMT_CONSTEXPR auto parse(ParseContext& ctx) -> decltype(ctx.begin()) {
-    return ctx.begin();
-  }
-
-  template <typename FormatContext>
-  auto format(const std::monostate&, FormatContext& ctx) const
-      -> decltype(ctx.out()) {
-    auto out = ctx.out();
-    out = detail::write<Char>(out, "monostate");
-    return out;
-  }
-};
-
-namespace detail {
-
-template <typename T>
-using variant_index_sequence =
-    std::make_index_sequence<std::variant_size<T>::value>;
-
-// variant_size and variant_alternative check.
-template <typename T, typename U = void>
-struct is_variant_like_ : std::false_type {};
-template <typename T>
-struct is_variant_like_<T, std::void_t<decltype(std::variant_size<T>::value)>>
-    : std::true_type {};
-
-// formattable element check
-template <typename T, typename C> class is_variant_formattable_ {
-  template <std::size_t... I>
-  static std::conjunction<
-      is_formattable<std::variant_alternative_t<I, T>, C>...>
-      check(std::index_sequence<I...>);
-
- public:
-  static constexpr const bool value =
-      decltype(check(variant_index_sequence<T>{}))::value;
-};
-
-template <typename Char, typename OutputIt, typename T>
-auto write_variant_alternative(OutputIt out, const T& v) -> OutputIt {
-  if constexpr (is_string<T>::value)
-    return write_escaped_string<Char>(out, detail::to_string_view(v));
-  else if constexpr (std::is_same_v<T, Char>)
-    return write_escaped_char(out, v);
-  else
-    return write<Char>(out, v);
-}
-
-}  // namespace detail
-
-template <typename T> struct is_variant_like {
-  static constexpr const bool value = detail::is_variant_like_<T>::value;
-};
-
-template <typename T, typename C> struct is_variant_formattable {
-  static constexpr const bool value =
-      detail::is_variant_formattable_<T, C>::value;
-};
-
-template <typename Variant, typename Char>
-struct formatter<
-    Variant, Char,
-    std::enable_if_t<std::conjunction_v<
-        is_variant_like<Variant>, is_variant_formattable<Variant, Char>>>> {
-  template <typename ParseContext>
-  FMT_CONSTEXPR auto parse(ParseContext& ctx) -> decltype(ctx.begin()) {
-    return ctx.begin();
-  }
-
-  template <typename FormatContext>
-  auto format(const Variant& value, FormatContext& ctx) const
-      -> decltype(ctx.out()) {
-    auto out = ctx.out();
-
-    out = detail::write<Char>(out, "variant(");
-    std::visit(
-        [&](const auto& v) {
-          out = detail::write_variant_alternative<Char>(out, v);
-        },
-        value);
-    *out++ = ')';
-    return out;
-  }
-};
-FMT_END_NAMESPACE
-#endif
-
-#endif  // FMT_STD_H_
diff --git a/Externals/fmt/include/fmt/xchar.h b/Externals/fmt/include/fmt/xchar.h
deleted file mode 100644
index 3b5bc15ca0a1..000000000000
--- a/Externals/fmt/include/fmt/xchar.h
+++ /dev/null
@@ -1,229 +0,0 @@
-// Formatting library for C++ - optional wchar_t and exotic character support
-//
-// Copyright (c) 2012 - present, Victor Zverovich
-// All rights reserved.
-//
-// For the license information refer to format.h.
-
-#ifndef FMT_XCHAR_H_
-#define FMT_XCHAR_H_
-
-#include <cwchar>
-
-#include "format.h"
-
-FMT_BEGIN_NAMESPACE
-namespace detail {
-template <typename T>
-using is_exotic_char = bool_constant<!std::is_same<T, char>::value>;
-}
-
-FMT_MODULE_EXPORT_BEGIN
-
-using wstring_view = basic_string_view<wchar_t>;
-using wformat_parse_context = basic_format_parse_context<wchar_t>;
-using wformat_context = buffer_context<wchar_t>;
-using wformat_args = basic_format_args<wformat_context>;
-using wmemory_buffer = basic_memory_buffer<wchar_t>;
-
-#if FMT_GCC_VERSION && FMT_GCC_VERSION < 409
-// Workaround broken conversion on older gcc.
-template <typename... Args> using wformat_string = wstring_view;
-inline auto runtime(wstring_view s) -> wstring_view { return s; }
-#else
-template <typename... Args>
-using wformat_string = basic_format_string<wchar_t, type_identity_t<Args>...>;
-inline auto runtime(wstring_view s) -> basic_runtime<wchar_t> { return {{s}}; }
-#endif
-
-template <> struct is_char<wchar_t> : std::true_type {};
-template <> struct is_char<detail::char8_type> : std::true_type {};
-template <> struct is_char<char16_t> : std::true_type {};
-template <> struct is_char<char32_t> : std::true_type {};
-
-template <typename... Args>
-constexpr format_arg_store<wformat_context, Args...> make_wformat_args(
-    const Args&... args) {
-  return {args...};
-}
-
-inline namespace literals {
-#if FMT_USE_USER_DEFINED_LITERALS && !FMT_USE_NONTYPE_TEMPLATE_ARGS
-constexpr detail::udl_arg<wchar_t> operator"" _a(const wchar_t* s, size_t) {
-  return {s};
-}
-#endif
-}  // namespace literals
-
-template <typename It, typename Sentinel>
-auto join(It begin, Sentinel end, wstring_view sep)
-    -> join_view<It, Sentinel, wchar_t> {
-  return {begin, end, sep};
-}
-
-template <typename Range>
-auto join(Range&& range, wstring_view sep)
-    -> join_view<detail::iterator_t<Range>, detail::sentinel_t<Range>,
-                 wchar_t> {
-  return join(std::begin(range), std::end(range), sep);
-}
-
-template <typename T>
-auto join(std::initializer_list<T> list, wstring_view sep)
-    -> join_view<const T*, const T*, wchar_t> {
-  return join(std::begin(list), std::end(list), sep);
-}
-
-template <typename Char, FMT_ENABLE_IF(!std::is_same<Char, char>::value)>
-auto vformat(basic_string_view<Char> format_str,
-             basic_format_args<buffer_context<type_identity_t<Char>>> args)
-    -> std::basic_string<Char> {
-  basic_memory_buffer<Char> buffer;
-  detail::vformat_to(buffer, format_str, args);
-  return to_string(buffer);
-}
-
-template <typename... T>
-auto format(wformat_string<T...> fmt, T&&... args) -> std::wstring {
-  return vformat(fmt::wstring_view(fmt), fmt::make_wformat_args(args...));
-}
-
-// Pass char_t as a default template parameter instead of using
-// std::basic_string<char_t<S>> to reduce the symbol size.
-template <typename S, typename... Args, typename Char = char_t<S>,
-          FMT_ENABLE_IF(!std::is_same<Char, char>::value &&
-                        !std::is_same<Char, wchar_t>::value)>
-auto format(const S& format_str, Args&&... args) -> std::basic_string<Char> {
-  return vformat(detail::to_string_view(format_str),
-                 fmt::make_format_args<buffer_context<Char>>(args...));
-}
-
-template <typename Locale, typename S, typename Char = char_t<S>,
-          FMT_ENABLE_IF(detail::is_locale<Locale>::value&&
-                            detail::is_exotic_char<Char>::value)>
-inline auto vformat(
-    const Locale& loc, const S& format_str,
-    basic_format_args<buffer_context<type_identity_t<Char>>> args)
-    -> std::basic_string<Char> {
-  return detail::vformat(loc, detail::to_string_view(format_str), args);
-}
-
-template <typename Locale, typename S, typename... Args,
-          typename Char = char_t<S>,
-          FMT_ENABLE_IF(detail::is_locale<Locale>::value&&
-                            detail::is_exotic_char<Char>::value)>
-inline auto format(const Locale& loc, const S& format_str, Args&&... args)
-    -> std::basic_string<Char> {
-  return detail::vformat(loc, detail::to_string_view(format_str),
-                         fmt::make_format_args<buffer_context<Char>>(args...));
-}
-
-template <typename OutputIt, typename S, typename Char = char_t<S>,
-          FMT_ENABLE_IF(detail::is_output_iterator<OutputIt, Char>::value&&
-                            detail::is_exotic_char<Char>::value)>
-auto vformat_to(OutputIt out, const S& format_str,
-                basic_format_args<buffer_context<type_identity_t<Char>>> args)
-    -> OutputIt {
-  auto&& buf = detail::get_buffer<Char>(out);
-  detail::vformat_to(buf, detail::to_string_view(format_str), args);
-  return detail::get_iterator(buf);
-}
-
-template <typename OutputIt, typename S, typename... Args,
-          typename Char = char_t<S>,
-          FMT_ENABLE_IF(detail::is_output_iterator<OutputIt, Char>::value&&
-                            detail::is_exotic_char<Char>::value)>
-inline auto format_to(OutputIt out, const S& fmt, Args&&... args) -> OutputIt {
-  return vformat_to(out, detail::to_string_view(fmt),
-                    fmt::make_format_args<buffer_context<Char>>(args...));
-}
-
-template <typename Locale, typename S, typename OutputIt, typename... Args,
-          typename Char = char_t<S>,
-          FMT_ENABLE_IF(detail::is_output_iterator<OutputIt, Char>::value&&
-                            detail::is_locale<Locale>::value&&
-                                detail::is_exotic_char<Char>::value)>
-inline auto vformat_to(
-    OutputIt out, const Locale& loc, const S& format_str,
-    basic_format_args<buffer_context<type_identity_t<Char>>> args) -> OutputIt {
-  auto&& buf = detail::get_buffer<Char>(out);
-  vformat_to(buf, detail::to_string_view(format_str), args,
-             detail::locale_ref(loc));
-  return detail::get_iterator(buf);
-}
-
-template <
-    typename OutputIt, typename Locale, typename S, typename... Args,
-    typename Char = char_t<S>,
-    bool enable = detail::is_output_iterator<OutputIt, Char>::value&&
-        detail::is_locale<Locale>::value&& detail::is_exotic_char<Char>::value>
-inline auto format_to(OutputIt out, const Locale& loc, const S& format_str,
-                      Args&&... args) ->
-    typename std::enable_if<enable, OutputIt>::type {
-  return vformat_to(out, loc, to_string_view(format_str),
-                    fmt::make_format_args<buffer_context<Char>>(args...));
-}
-
-template <typename OutputIt, typename Char, typename... Args,
-          FMT_ENABLE_IF(detail::is_output_iterator<OutputIt, Char>::value&&
-                            detail::is_exotic_char<Char>::value)>
-inline auto vformat_to_n(
-    OutputIt out, size_t n, basic_string_view<Char> format_str,
-    basic_format_args<buffer_context<type_identity_t<Char>>> args)
-    -> format_to_n_result<OutputIt> {
-  detail::iterator_buffer<OutputIt, Char, detail::fixed_buffer_traits> buf(out,
-                                                                           n);
-  detail::vformat_to(buf, format_str, args);
-  return {buf.out(), buf.count()};
-}
-
-template <typename OutputIt, typename S, typename... Args,
-          typename Char = char_t<S>,
-          FMT_ENABLE_IF(detail::is_output_iterator<OutputIt, Char>::value&&
-                            detail::is_exotic_char<Char>::value)>
-inline auto format_to_n(OutputIt out, size_t n, const S& fmt,
-                        const Args&... args) -> format_to_n_result<OutputIt> {
-  return vformat_to_n(out, n, detail::to_string_view(fmt),
-                      fmt::make_format_args<buffer_context<Char>>(args...));
-}
-
-template <typename S, typename... Args, typename Char = char_t<S>,
-          FMT_ENABLE_IF(detail::is_exotic_char<Char>::value)>
-inline auto formatted_size(const S& fmt, Args&&... args) -> size_t {
-  detail::counting_buffer<Char> buf;
-  detail::vformat_to(buf, detail::to_string_view(fmt),
-                     fmt::make_format_args<buffer_context<Char>>(args...));
-  return buf.count();
-}
-
-inline void vprint(std::FILE* f, wstring_view fmt, wformat_args args) {
-  wmemory_buffer buffer;
-  detail::vformat_to(buffer, fmt, args);
-  buffer.push_back(L'\0');
-  if (std::fputws(buffer.data(), f) == -1)
-    FMT_THROW(system_error(errno, FMT_STRING("cannot write to file")));
-}
-
-inline void vprint(wstring_view fmt, wformat_args args) {
-  vprint(stdout, fmt, args);
-}
-
-template <typename... T>
-void print(std::FILE* f, wformat_string<T...> fmt, T&&... args) {
-  return vprint(f, wstring_view(fmt), fmt::make_wformat_args(args...));
-}
-
-template <typename... T> void print(wformat_string<T...> fmt, T&&... args) {
-  return vprint(wstring_view(fmt), fmt::make_wformat_args(args...));
-}
-
-/**
-  Converts *value* to ``std::wstring`` using the default format for type *T*.
- */
-template <typename T> inline auto to_wstring(const T& value) -> std::wstring {
-  return format(FMT_STRING(L"{}"), value);
-}
-FMT_MODULE_EXPORT_END
-FMT_END_NAMESPACE
-
-#endif  // FMT_XCHAR_H_
diff --git a/Externals/fmt/src/fmt.cc b/Externals/fmt/src/fmt.cc
deleted file mode 100644
index 80e77e26af86..000000000000
--- a/Externals/fmt/src/fmt.cc
+++ /dev/null
@@ -1,99 +0,0 @@
-module;
-#ifndef __cpp_modules
-#  error Module not supported.
-#endif
-
-// put all implementation-provided headers into the global module fragment
-// to prevent attachment to this module
-#if !defined(_CRT_SECURE_NO_WARNINGS) && defined(_MSC_VER)
-#  define _CRT_SECURE_NO_WARNINGS
-#endif
-#if !defined(WIN32_LEAN_AND_MEAN) && defined(_WIN32)
-#  define WIN32_LEAN_AND_MEAN
-#endif
-
-#include <algorithm>
-#include <cctype>
-#include <cerrno>
-#include <chrono>
-#include <climits>
-#include <clocale>
-#include <cmath>
-#include <cstdarg>
-#include <cstddef>
-#include <cstdint>
-#include <cstdio>
-#include <cstdlib>
-#include <cstring>
-#include <ctime>
-#include <cwchar>
-#include <exception>
-#include <functional>
-#include <iterator>
-#include <limits>
-#include <locale>
-#include <memory>
-#include <ostream>
-#include <sstream>
-#include <stdexcept>
-#include <string>
-#include <string_view>
-#include <system_error>
-#include <type_traits>
-#include <utility>
-#include <vector>
-
-#if _MSC_VER
-#  include <intrin.h>
-#endif
-#if defined __APPLE__ || defined(__FreeBSD__)
-#  include <xlocale.h>
-#endif
-#if __has_include(<winapifamily.h>)
-#  include <winapifamily.h>
-#endif
-#if (__has_include(<fcntl.h>) || defined(__APPLE__) || \
-     defined(__linux__)) &&                            \
-    (!defined(WINAPI_FAMILY) || (WINAPI_FAMILY == WINAPI_FAMILY_DESKTOP_APP))
-#  include <fcntl.h>
-#  include <sys/stat.h>
-#  include <sys/types.h>
-#  ifndef _WIN32
-#    include <unistd.h>
-#  else
-#    include <io.h>
-#  endif
-#endif
-#ifdef _WIN32
-#  include <windows.h>
-#endif
-
-export module fmt;
-
-#define FMT_MODULE_EXPORT export
-#define FMT_MODULE_EXPORT_BEGIN export {
-#define FMT_MODULE_EXPORT_END }
-#define FMT_BEGIN_DETAIL_NAMESPACE \
-  }                                \
-  namespace detail {
-#define FMT_END_DETAIL_NAMESPACE \
-  }                              \
-  export {
-// all library-provided declarations and definitions
-// must be in the module purview to be exported
-#include "fmt/args.h"
-#include "fmt/chrono.h"
-#include "fmt/color.h"
-#include "fmt/compile.h"
-#include "fmt/format.h"
-#include "fmt/os.h"
-#include "fmt/printf.h"
-#include "fmt/xchar.h"
-
-// gcc doesn't yet implement private module fragments
-#if !FMT_GCC_VERSION
-module : private;
-#endif
-
-#include "format.cc"
-#include "os.cc"
diff --git a/Externals/fmt/src/format.cc b/Externals/fmt/src/format.cc
deleted file mode 100755
index 99b7e9dd4713..000000000000
--- a/Externals/fmt/src/format.cc
+++ /dev/null
@@ -1,47 +0,0 @@
-// Formatting library for C++
-//
-// Copyright (c) 2012 - 2016, Victor Zverovich
-// All rights reserved.
-//
-// For the license information refer to format.h.
-
-#include "fmt/format-inl.h"
-
-FMT_BEGIN_NAMESPACE
-namespace detail {
-
-template FMT_API auto dragonbox::to_decimal(float x) noexcept
-    -> dragonbox::decimal_fp<float>;
-template FMT_API auto dragonbox::to_decimal(double x) noexcept
-    -> dragonbox::decimal_fp<double>;
-
-#ifndef FMT_STATIC_THOUSANDS_SEPARATOR
-template FMT_API locale_ref::locale_ref(const std::locale& loc);
-template FMT_API auto locale_ref::get<std::locale>() const -> std::locale;
-#endif
-
-// Explicit instantiations for char.
-
-template FMT_API auto thousands_sep_impl(locale_ref)
-    -> thousands_sep_result<char>;
-template FMT_API auto decimal_point_impl(locale_ref) -> char;
-
-template FMT_API void buffer<char>::append(const char*, const char*);
-
-// DEPRECATED!
-// There is no correspondent extern template in format.h because of
-// incompatibility between clang and gcc (#2377).
-template FMT_API void vformat_to(buffer<char>&, string_view,
-                                 basic_format_args<FMT_BUFFER_CONTEXT(char)>,
-                                 locale_ref);
-
-// Explicit instantiations for wchar_t.
-
-template FMT_API auto thousands_sep_impl(locale_ref)
-    -> thousands_sep_result<wchar_t>;
-template FMT_API auto decimal_point_impl(locale_ref) -> wchar_t;
-
-template FMT_API void buffer<wchar_t>::append(const wchar_t*, const wchar_t*);
-
-}  // namespace detail
-FMT_END_NAMESPACE
diff --git a/Externals/fmt/src/os.cc b/Externals/fmt/src/os.cc
deleted file mode 100644
index f388ead0191b..000000000000
--- a/Externals/fmt/src/os.cc
+++ /dev/null
@@ -1,361 +0,0 @@
-// Formatting library for C++ - optional OS-specific functionality
-//
-// Copyright (c) 2012 - 2016, Victor Zverovich
-// All rights reserved.
-//
-// For the license information refer to format.h.
-
-// Disable bogus MSVC warnings.
-#if !defined(_CRT_SECURE_NO_WARNINGS) && defined(_MSC_VER)
-#  define _CRT_SECURE_NO_WARNINGS
-#endif
-
-#include "fmt/os.h"
-
-#include <climits>
-
-#if FMT_USE_FCNTL
-#  include <sys/stat.h>
-#  include <sys/types.h>
-
-#  ifndef _WIN32
-#    include <unistd.h>
-#  else
-#    ifndef WIN32_LEAN_AND_MEAN
-#      define WIN32_LEAN_AND_MEAN
-#    endif
-#    include <io.h>
-
-#    ifndef S_IRUSR
-#      define S_IRUSR _S_IREAD
-#    endif
-#    ifndef S_IWUSR
-#      define S_IWUSR _S_IWRITE
-#    endif
-#    ifndef S_IRGRP
-#      define S_IRGRP 0
-#    endif
-#    ifndef S_IWGRP
-#      define S_IWGRP 0
-#    endif
-#    ifndef S_IROTH
-#      define S_IROTH 0
-#    endif
-#    ifndef S_IWOTH
-#      define S_IWOTH 0
-#    endif
-#  endif  // _WIN32
-#endif    // FMT_USE_FCNTL
-
-#ifdef _WIN32
-#  include <windows.h>
-#endif
-
-namespace {
-#ifdef _WIN32
-// Return type of read and write functions.
-using rwresult = int;
-
-// On Windows the count argument to read and write is unsigned, so convert
-// it from size_t preventing integer overflow.
-inline unsigned convert_rwcount(std::size_t count) {
-  return count <= UINT_MAX ? static_cast<unsigned>(count) : UINT_MAX;
-}
-#elif FMT_USE_FCNTL
-// Return type of read and write functions.
-using rwresult = ssize_t;
-
-inline std::size_t convert_rwcount(std::size_t count) { return count; }
-#endif
-}  // namespace
-
-FMT_BEGIN_NAMESPACE
-
-#ifdef _WIN32
-detail::utf16_to_utf8::utf16_to_utf8(basic_string_view<wchar_t> s) {
-  if (int error_code = convert(s)) {
-    FMT_THROW(windows_error(error_code,
-                            "cannot convert string from UTF-16 to UTF-8"));
-  }
-}
-
-int detail::utf16_to_utf8::convert(basic_string_view<wchar_t> s) {
-  if (s.size() > INT_MAX) return ERROR_INVALID_PARAMETER;
-  int s_size = static_cast<int>(s.size());
-  if (s_size == 0) {
-    // WideCharToMultiByte does not support zero length, handle separately.
-    buffer_.resize(1);
-    buffer_[0] = 0;
-    return 0;
-  }
-
-  int length = WideCharToMultiByte(CP_UTF8, 0, s.data(), s_size, nullptr, 0,
-                                   nullptr, nullptr);
-  if (length == 0) return GetLastError();
-  buffer_.resize(length + 1);
-  length = WideCharToMultiByte(CP_UTF8, 0, s.data(), s_size, &buffer_[0],
-                               length, nullptr, nullptr);
-  if (length == 0) return GetLastError();
-  buffer_[length] = 0;
-  return 0;
-}
-
-namespace detail {
-
-class system_message {
-  system_message(const system_message&) = delete;
-  void operator=(const system_message&) = delete;
-
-  unsigned long result_;
-  wchar_t* message_;
-
-  static bool is_whitespace(wchar_t c) noexcept {
-    return c == L' ' || c == L'\n' || c == L'\r' || c == L'\t' || c == L'\0';
-  }
-
- public:
-  explicit system_message(unsigned long error_code)
-      : result_(0), message_(nullptr) {
-    result_ = FormatMessageW(
-        FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM |
-            FORMAT_MESSAGE_IGNORE_INSERTS,
-        nullptr, error_code, MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
-        reinterpret_cast<wchar_t*>(&message_), 0, nullptr);
-    if (result_ != 0) {
-      while (result_ != 0 && is_whitespace(message_[result_ - 1])) {
-        --result_;
-      }
-    }
-  }
-  ~system_message() { LocalFree(message_); }
-  explicit operator bool() const noexcept { return result_ != 0; }
-  operator basic_string_view<wchar_t>() const noexcept {
-    return basic_string_view<wchar_t>(message_, result_);
-  }
-};
-
-class utf8_system_category final : public std::error_category {
- public:
-  const char* name() const noexcept override { return "system"; }
-  std::string message(int error_code) const override {
-    system_message msg(error_code);
-    if (msg) {
-      utf16_to_utf8 utf8_message;
-      if (utf8_message.convert(msg) == ERROR_SUCCESS) {
-        return utf8_message.str();
-      }
-    }
-    return "unknown error";
-  }
-};
-
-}  // namespace detail
-
-FMT_API const std::error_category& system_category() noexcept {
-  static const detail::utf8_system_category category;
-  return category;
-}
-
-std::system_error vwindows_error(int err_code, string_view format_str,
-                                 format_args args) {
-  auto ec = std::error_code(err_code, system_category());
-  return std::system_error(ec, vformat(format_str, args));
-}
-
-void detail::format_windows_error(detail::buffer<char>& out, int error_code,
-                                  const char* message) noexcept {
-  FMT_TRY {
-    system_message msg(error_code);
-    if (msg) {
-      utf16_to_utf8 utf8_message;
-      if (utf8_message.convert(msg) == ERROR_SUCCESS) {
-        fmt::format_to(buffer_appender<char>(out), "{}: {}", message, utf8_message);
-        return;
-      }
-    }
-  }
-  FMT_CATCH(...) {}
-  format_error_code(out, error_code, message);
-}
-
-void report_windows_error(int error_code, const char* message) noexcept {
-  report_error(detail::format_windows_error, error_code, message);
-}
-#endif  // _WIN32
-
-buffered_file::~buffered_file() noexcept {
-  if (file_ && FMT_SYSTEM(fclose(file_)) != 0)
-    report_system_error(errno, "cannot close file");
-}
-
-buffered_file::buffered_file(cstring_view filename, cstring_view mode) {
-  FMT_RETRY_VAL(file_, FMT_SYSTEM(fopen(filename.c_str(), mode.c_str())),
-                nullptr);
-  if (!file_)
-    FMT_THROW(system_error(errno, "cannot open file {}", filename.c_str()));
-}
-
-void buffered_file::close() {
-  if (!file_) return;
-  int result = FMT_SYSTEM(fclose(file_));
-  file_ = nullptr;
-  if (result != 0) FMT_THROW(system_error(errno, "cannot close file"));
-}
-
-int buffered_file::descriptor() const {
-  int fd = FMT_POSIX_CALL(fileno(file_));
-  if (fd == -1) FMT_THROW(system_error(errno, "cannot get file descriptor"));
-  return fd;
-}
-
-#if FMT_USE_FCNTL
-file::file(cstring_view path, int oflag) {
-#  ifdef _WIN32
-  using mode_t = int;
-#  endif
-  constexpr mode_t mode =
-      S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP | S_IROTH | S_IWOTH;
-#  if defined(_WIN32) && !defined(__MINGW32__)
-  fd_ = -1;
-  FMT_POSIX_CALL(sopen_s(&fd_, path.c_str(), oflag, _SH_DENYNO, mode));
-#  else
-  FMT_RETRY(fd_, FMT_POSIX_CALL(open(path.c_str(), oflag, mode)));
-#  endif
-  if (fd_ == -1)
-    FMT_THROW(system_error(errno, "cannot open file {}", path.c_str()));
-}
-
-file::~file() noexcept {
-  // Don't retry close in case of EINTR!
-  // See http://linux.derkeiler.com/Mailing-Lists/Kernel/2005-09/3000.html
-  if (fd_ != -1 && FMT_POSIX_CALL(close(fd_)) != 0)
-    report_system_error(errno, "cannot close file");
-}
-
-void file::close() {
-  if (fd_ == -1) return;
-  // Don't retry close in case of EINTR!
-  // See http://linux.derkeiler.com/Mailing-Lists/Kernel/2005-09/3000.html
-  int result = FMT_POSIX_CALL(close(fd_));
-  fd_ = -1;
-  if (result != 0) FMT_THROW(system_error(errno, "cannot close file"));
-}
-
-long long file::size() const {
-#  ifdef _WIN32
-  // Use GetFileSize instead of GetFileSizeEx for the case when _WIN32_WINNT
-  // is less than 0x0500 as is the case with some default MinGW builds.
-  // Both functions support large file sizes.
-  DWORD size_upper = 0;
-  HANDLE handle = reinterpret_cast<HANDLE>(_get_osfhandle(fd_));
-  DWORD size_lower = FMT_SYSTEM(GetFileSize(handle, &size_upper));
-  if (size_lower == INVALID_FILE_SIZE) {
-    DWORD error = GetLastError();
-    if (error != NO_ERROR)
-      FMT_THROW(windows_error(GetLastError(), "cannot get file size"));
-  }
-  unsigned long long long_size = size_upper;
-  return (long_size << sizeof(DWORD) * CHAR_BIT) | size_lower;
-#  else
-  using Stat = struct stat;
-  Stat file_stat = Stat();
-  if (FMT_POSIX_CALL(fstat(fd_, &file_stat)) == -1)
-    FMT_THROW(system_error(errno, "cannot get file attributes"));
-  static_assert(sizeof(long long) >= sizeof(file_stat.st_size),
-                "return type of file::size is not large enough");
-  return file_stat.st_size;
-#  endif
-}
-
-std::size_t file::read(void* buffer, std::size_t count) {
-  rwresult result = 0;
-  FMT_RETRY(result, FMT_POSIX_CALL(read(fd_, buffer, convert_rwcount(count))));
-  if (result < 0) FMT_THROW(system_error(errno, "cannot read from file"));
-  return detail::to_unsigned(result);
-}
-
-std::size_t file::write(const void* buffer, std::size_t count) {
-  rwresult result = 0;
-  FMT_RETRY(result, FMT_POSIX_CALL(write(fd_, buffer, convert_rwcount(count))));
-  if (result < 0) FMT_THROW(system_error(errno, "cannot write to file"));
-  return detail::to_unsigned(result);
-}
-
-file file::dup(int fd) {
-  // Don't retry as dup doesn't return EINTR.
-  // http://pubs.opengroup.org/onlinepubs/009695399/functions/dup.html
-  int new_fd = FMT_POSIX_CALL(dup(fd));
-  if (new_fd == -1)
-    FMT_THROW(system_error(errno, "cannot duplicate file descriptor {}", fd));
-  return file(new_fd);
-}
-
-void file::dup2(int fd) {
-  int result = 0;
-  FMT_RETRY(result, FMT_POSIX_CALL(dup2(fd_, fd)));
-  if (result == -1) {
-    FMT_THROW(system_error(errno, "cannot duplicate file descriptor {} to {}",
-                           fd_, fd));
-  }
-}
-
-void file::dup2(int fd, std::error_code& ec) noexcept {
-  int result = 0;
-  FMT_RETRY(result, FMT_POSIX_CALL(dup2(fd_, fd)));
-  if (result == -1) ec = std::error_code(errno, std::generic_category());
-}
-
-void file::pipe(file& read_end, file& write_end) {
-  // Close the descriptors first to make sure that assignments don't throw
-  // and there are no leaks.
-  read_end.close();
-  write_end.close();
-  int fds[2] = {};
-#  ifdef _WIN32
-  // Make the default pipe capacity same as on Linux 2.6.11+.
-  enum { DEFAULT_CAPACITY = 65536 };
-  int result = FMT_POSIX_CALL(pipe(fds, DEFAULT_CAPACITY, _O_BINARY));
-#  else
-  // Don't retry as the pipe function doesn't return EINTR.
-  // http://pubs.opengroup.org/onlinepubs/009696799/functions/pipe.html
-  int result = FMT_POSIX_CALL(pipe(fds));
-#  endif
-  if (result != 0) FMT_THROW(system_error(errno, "cannot create pipe"));
-  // The following assignments don't throw because read_fd and write_fd
-  // are closed.
-  read_end = file(fds[0]);
-  write_end = file(fds[1]);
-}
-
-buffered_file file::fdopen(const char* mode) {
-// Don't retry as fdopen doesn't return EINTR.
-#  if defined(__MINGW32__) && defined(_POSIX_)
-  FILE* f = ::fdopen(fd_, mode);
-#  else
-  FILE* f = FMT_POSIX_CALL(fdopen(fd_, mode));
-#  endif
-  if (!f)
-    FMT_THROW(
-        system_error(errno, "cannot associate stream with file descriptor"));
-  buffered_file bf(f);
-  fd_ = -1;
-  return bf;
-}
-
-long getpagesize() {
-#  ifdef _WIN32
-  SYSTEM_INFO si;
-  GetSystemInfo(&si);
-  return si.dwPageSize;
-#  else
-  long size = FMT_POSIX_CALL(sysconf(_SC_PAGESIZE));
-  if (size < 0) FMT_THROW(system_error(errno, "cannot get memory page size"));
-  return size;
-#  endif
-}
-
-FMT_API void ostream::grow(size_t) {
-  if (this->size() == this->capacity()) flush();
-}
-#endif  // FMT_USE_FCNTL
-FMT_END_NAMESPACE
diff --git a/Externals/fmt/support/Android.mk b/Externals/fmt/support/Android.mk
deleted file mode 100755
index 84a3e32f0718..000000000000
--- a/Externals/fmt/support/Android.mk
+++ /dev/null
@@ -1,15 +0,0 @@
-LOCAL_PATH := $(call my-dir)
-include $(CLEAR_VARS)
-
-LOCAL_MODULE := fmt_static
-LOCAL_MODULE_FILENAME := libfmt
-
-LOCAL_SRC_FILES := ../src/format.cc
-
-LOCAL_C_INCLUDES := $(LOCAL_PATH)
-LOCAL_EXPORT_C_INCLUDES := $(LOCAL_PATH)
-
-LOCAL_CFLAGS += -std=c++11 -fexceptions
-
-include $(BUILD_STATIC_LIBRARY)
-
diff --git a/Externals/fmt/support/AndroidManifest.xml b/Externals/fmt/support/AndroidManifest.xml
deleted file mode 100755
index b5281fee181e..000000000000
--- a/Externals/fmt/support/AndroidManifest.xml
+++ /dev/null
@@ -1 +0,0 @@
-<manifest package="net.fmtlib" />
diff --git a/Externals/fmt/support/C++.sublime-syntax b/Externals/fmt/support/C++.sublime-syntax
deleted file mode 100644
index 9dfb5cbe4324..000000000000
--- a/Externals/fmt/support/C++.sublime-syntax
+++ /dev/null
@@ -1,2061 +0,0 @@
-%YAML 1.2
----
-# http://www.sublimetext.com/docs/3/syntax.html
-name: C++ (fmt)
-comment: I don't think anyone uses .hp. .cp tends to be paired with .h. (I could be wrong. :) -- chris
-file_extensions:
-  - cpp
-  - cc
-  - cp
-  - cxx
-  - c++
-  - C
-  - h
-  - hh
-  - hpp
-  - hxx
-  - h++
-  - inl
-  - ipp
-first_line_match: '-\*- C\+\+ -\*-'
-scope: source.c++
-variables:
-  identifier: \b[[:alpha:]_][[:alnum:]_]*\b # upper and lowercase
-  macro_identifier: \b[[:upper:]_][[:upper:][:digit:]_]{2,}\b # only uppercase, at least 3 chars
-  path_lookahead: '(?:::\s*)?(?:{{identifier}}\s*::\s*)*(?:template\s+)?{{identifier}}'
-  operator_method_name: '\boperator\s*(?:[-+*/%^&|~!=<>]|[-+*/%^&|=!<>]=|<<=?|>>=?|&&|\|\||\+\+|--|,|->\*?|\(\)|\[\]|""\s*{{identifier}})'
-  casts: 'const_cast|dynamic_cast|reinterpret_cast|static_cast'
-  operator_keywords: 'and|and_eq|bitand|bitor|compl|not|not_eq|or|or_eq|xor|xor_eq|noexcept'
-  control_keywords: 'break|case|catch|continue|default|do|else|for|goto|if|_Pragma|return|switch|throw|try|while'
-  memory_operators: 'new|delete'
-  basic_types: 'asm|__asm__|auto|bool|_Bool|char|_Complex|double|float|_Imaginary|int|long|short|signed|unsigned|void'
-  before_tag: 'struct|union|enum\s+class|enum\s+struct|enum|class'
-  declspec: '__declspec\(\s*\w+(?:\([^)]+\))?\s*\)'
-  storage_classes: 'static|export|extern|friend|explicit|virtual|register|thread_local'
-  type_qualifier: 'const|constexpr|mutable|typename|volatile'
-  compiler_directive: 'inline|restrict|__restrict__|__restrict'
-  visibility_modifiers: 'private|protected|public'
-  other_keywords: 'typedef|nullptr|{{visibility_modifiers}}|static_assert|sizeof|using|typeid|alignof|alignas|namespace|template'
-  modifiers: '{{storage_classes}}|{{type_qualifier}}|{{compiler_directive}}'
-  non_angle_brackets: '(?=<<|<=)'
-
-  regular: '[^(){}&;*^%=<>-]*'
-  paren_open: (?:\(
-  paren_close: '\))?'
-  generic_open: (?:<
-  generic_close: '>)?'
-  balance_parentheses: '{{regular}}{{paren_open}}{{regular}}{{paren_close}}{{regular}}'
-  generic_lookahead: <{{regular}}{{generic_open}}{{regular}}{{generic_open}}{{regular}}{{generic_close}}\s*{{generic_close}}{{balance_parentheses}}>
-
-  data_structures_forward_decl_lookahead: '(\s+{{macro_identifier}})*\s*(:\s*({{path_lookahead}}|{{visibility_modifiers}}|,|\s|<[^;]*>)+)?;'
-  non_func_keywords: 'if|for|switch|while|decltype|sizeof|__declspec|__attribute__|typeid|alignof|alignas|static_assert'
-
-  format_spec: |-
-    (?x:
-      (?:.? [<>=^])?     # fill align
-      [ +-]?             # sign
-      \#?                # alternate form
-      # technically, octal and hexadecimal integers are also supported as 'width', but rarely used
-      \d*                # width
-      ,?                 # thousands separator
-      (?:\.\d+)?         # precision
-      [bcdeEfFgGnosxX%]? # type
-    )
-
-contexts:
-  main:
-    - include: preprocessor-global
-    - include: global
-
-  #############################################################################
-  # Reusable contexts
-  #
-  # The follow contexts are currently constructed to be reused in the
-  # Objetive-C++ syntax. They are specifically constructed to not push into
-  # sub-contexts, which ensures that Objective-C++ code isn't accidentally
-  # lexed as plain C++.
-  #
-  # The "unique-*" contexts are additions that C++ makes over C, and thus can
-  # be directly reused in Objective-C++ along with contexts from Objective-C
-  # and C.
-  #############################################################################
-
-  unique-late-expressions:
-    # This is highlighted after all of the other control keywords
-    # to allow operator overloading to be lexed properly
-    - match: \boperator\b
-      scope: keyword.control.c++
-
-  unique-modifiers:
-    - match: \b({{modifiers}})\b
-      scope: storage.modifier.c++
-
-  unique-variables:
-    - match: \bthis\b
-      scope: variable.language.c++
-    # common C++ instance var naming idiom -- fMemberName
-    - match: '\b(f|m)[[:upper:]]\w*\b'
-      scope: variable.other.readwrite.member.c++
-    # common C++ instance var naming idiom -- m_member_name
-    - match: '\bm_[[:alnum:]_]+\b'
-      scope: variable.other.readwrite.member.c++
-
-  unique-constants:
-    - match: \bnullptr\b
-      scope: constant.language.c++
-
-  unique-keywords:
-    - match: \busing\b
-      scope: keyword.control.c++
-    - match: \bbreak\b
-      scope: keyword.control.flow.break.c++
-    - match: \bcontinue\b
-      scope: keyword.control.flow.continue.c++
-    - match: \bgoto\b
-      scope: keyword.control.flow.goto.c++
-    - match: \breturn\b
-      scope: keyword.control.flow.return.c++
-    - match: \bthrow\b
-      scope: keyword.control.flow.throw.c++
-    - match: \b({{control_keywords}})\b
-      scope: keyword.control.c++
-    - match: '\bdelete\b(\s*\[\])?|\bnew\b(?!])'
-      scope: keyword.control.c++
-    - match: \b({{operator_keywords}})\b
-      scope: keyword.operator.word.c++
-
-  unique-types:
-    - match: \b(char16_t|char32_t|wchar_t|nullptr_t)\b
-      scope: storage.type.c++
-    - match: \bclass\b
-      scope: storage.type.c++
-
-  unique-strings:
-    - match: '((?:L|u8|u|U)?R)("([^\(\)\\ ]{0,16})\()'
-      captures:
-        1: storage.type.string.c++
-        2: punctuation.definition.string.begin.c++
-      push:
-        - meta_scope: string.quoted.double.c++
-        - match: '\)\3"'
-          scope: punctuation.definition.string.end.c++
-          pop: true
-        - match: '\{\{|\}\}'
-          scope: constant.character.escape.c++
-        - include: formatting-syntax
-
-  unique-numbers:
-    - match: |-
-        (?x)
-        (?:
-        # floats
-          (?:
-          (?:\b\d(?:[\d']*\d)?\.\d(?:[\d']*\d)?|\B\.\d(?:[\d']*\d)?)(?:[Ee][+-]?\d(?:[\d']*\d)?)?(?:[fFlL]|(?:i[fl]?|h|min|[mun]?s|_\w*))?\b
-          |
-          (?:\b\d(?:[\d']*\d)?\.)(?:\B|(?:[fFlL]|(?:i[fl]?|h|min|[mun]?s|_\w*))\b|(?:[Ee][+-]?\d(?:[\d']*\d)?)(?:[fFlL]|(?:i[fl]?|h|min|[mun]?s|_\w*))?\b)
-          |
-          \b\d(?:[\d']*\d)?(?:[Ee][+-]?\d(?:[\d']*\d)?)(?:[fFlL]|(?:i[fl]?|h|min|[mun]?s|_\w*))?\b
-          )
-        |
-        # ints
-          \b(?:
-          (?:
-          # dec
-          [1-9](?:[\d']*\d)?
-          |
-          # oct
-          0(?:[0-7']*[0-7])?
-          |
-          # hex
-          0[Xx][\da-fA-F](?:[\da-fA-F']*[\da-fA-F])?
-          |
-          # bin
-          0[Bb][01](?:[01']*[01])?
-          )
-          # int suffixes
-          (?:(?:l{1,2}|L{1,2})[uU]?|[uU](?:l{0,2}|L{0,2})|(?:i[fl]?|h|min|[mun]?s|_\w*))?)\b
-        )
-        (?!\.) # Number must not be followed by a decimal point
-      scope: constant.numeric.c++
-
-  identifiers:
-    - match: '{{identifier}}\s*(::)\s*'
-      captures:
-        1: punctuation.accessor.c++
-    - match: '(?:(::)\s*)?{{identifier}}'
-      captures:
-        1: punctuation.accessor.c++
-
-  function-specifiers:
-    - match: \b(const|final|noexcept|override)\b
-      scope: storage.modifier.c++
-
-  #############################################################################
-  # The following are C++-specific contexts that should not be reused. This is
-  # because they push into subcontexts and use variables that are C++-specific.
-  #############################################################################
-
-  ## Common context layout
-
-  global:
-    - match: '(?=\btemplate\b)'
-      push:
-        - include: template
-        - match: (?=\S)
-          set: global-modifier
-    - include: namespace
-    - include: keywords-angle-brackets
-    - match: '(?={{path_lookahead}}\s*<)'
-      push: global-modifier
-    # Take care of comments just before a function definition.
-    - match: /\*
-      scope: punctuation.definition.comment.c
-      push:
-        - - match: \s*(?=\w)
-            set: global-modifier
-          - match: ""
-            pop: true
-        - - meta_scope: comment.block.c
-          - match: \*/
-            scope: punctuation.definition.comment.c
-            pop: true
-    - include: early-expressions
-    - match: ^\s*\b(extern)(?=\s+"C(\+\+)?")
-      scope: storage.modifier.c++
-      push:
-        - include: comments
-        - include: strings
-        - match: '\{'
-          scope: punctuation.section.block.begin.c++
-          set:
-            - meta_scope: meta.extern-c.c++
-            - match: '^\s*(#\s*ifdef)\s*__cplusplus\s*'
-              scope: meta.preprocessor.c++
-              captures:
-                1: keyword.control.import.c++
-              set:
-                - match: '\}'
-                  scope: punctuation.section.block.end.c++
-                  pop: true
-                - include: preprocessor-global
-                - include: global
-            - match: '\}'
-              scope: punctuation.section.block.end.c++
-              pop: true
-            - include: preprocessor-global
-            - include: global
-        - match: (?=\S)
-          set: global-modifier
-    - match: ^\s*(?=\w)
-      push: global-modifier
-    - include: late-expressions
-
-  statements:
-    - include: preprocessor-statements
-    - include: scope:source.c#label
-    - include: expressions
-
-  expressions:
-    - include: early-expressions
-    - include: late-expressions
-
-  early-expressions:
-    - include: early-expressions-before-generic-type
-    - include: generic-type
-    - include: early-expressions-after-generic-type
-
-  early-expressions-before-generic-type:
-    - include: preprocessor-expressions
-    - include: comments
-    - include: case-default
-    - include: typedef
-    - include: keywords-angle-brackets
-    - include: keywords-parens
-    - include: keywords
-    - include: numbers
-    # Prevent a '<' from getting scoped as the start of another template
-    # parameter list, if in reality a less-than-or-equals sign is meant.
-    - match: <=
-      scope: keyword.operator.comparison.c
-
-  early-expressions-after-generic-type:
-    - include: members-arrow
-    - include: operators
-    - include: members-dot
-    - include: strings
-    - include: parens
-    - include: brackets
-    - include: block
-    - include: variables
-    - include: constants
-    - match: ','
-      scope: punctuation.separator.c++
-    - match: '\)|\}'
-      scope: invalid.illegal.stray-bracket-end.c++
-
-  expressions-minus-generic-type:
-    - include: early-expressions-before-generic-type
-    - include: angle-brackets
-    - include: early-expressions-after-generic-type
-    - include: late-expressions
-
-  expressions-minus-generic-type-function-call:
-    - include: early-expressions-before-generic-type
-    - include: angle-brackets
-    - include: early-expressions-after-generic-type
-    - include: late-expressions-before-function-call
-    - include: identifiers
-    - match: ';'
-      scope: punctuation.terminator.c++
-
-  late-expressions:
-    - include: late-expressions-before-function-call
-    - include: function-call
-    - include: identifiers
-    - match: ';'
-      scope: punctuation.terminator.c++
-
-  late-expressions-before-function-call:
-    - include: unique-late-expressions
-    - include: modifiers-parens
-    - include: modifiers
-    - include: types
-
-  expressions-minus-function-call:
-    - include: early-expressions
-    - include: late-expressions-before-function-call
-    - include: identifiers
-    - match: ';'
-      scope: punctuation.terminator.c++
-
-  comments:
-    - include: scope:source.c#comments
-
-  operators:
-    - include: scope:source.c#operators
-
-  modifiers:
-    - include: unique-modifiers
-    - include: scope:source.c#modifiers
-
-  variables:
-    - include: unique-variables
-    - include: scope:source.c#variables
-
-  constants:
-    - include: unique-constants
-    - include: scope:source.c#constants
-
-  keywords:
-    - include: unique-keywords
-    - include: scope:source.c#keywords
-
-  types:
-    - include: unique-types
-    - include: types-parens
-    - include: scope:source.c#types
-
-  strings:
-    - include: unique-strings
-    - match: '(L|u8|u|U)?(")'
-      captures:
-        1: storage.type.string.c++
-        2: punctuation.definition.string.begin.c++
-      push:
-        - meta_scope: string.quoted.double.c++
-        - match: '"'
-          scope: punctuation.definition.string.end.c++
-          pop: true
-        - include: scope:source.c#string_escaped_char
-        - match: |-
-            (?x)%
-              (\d+\$)?                                      # field (argument #)
-              [#0\- +']*                                    # flags
-              [,;:_]?                                       # separator character (AltiVec)
-              ((-?\d+)|\*(-?\d+\$)?)?                       # minimum field width
-              (\.((-?\d+)|\*(-?\d+\$)?)?)?                  # precision
-              (hh|h|ll|l|j|t|z|q|L|vh|vl|v|hv|hl)?          # length modifier
-              (\[[^\]]+\]|[am]s|[diouxXDOUeEfFgGaACcSspn%]) # conversion type
-          scope: constant.other.placeholder.c++
-        - match: '\{\{|\}\}'
-          scope: constant.character.escape.c++
-        - include: formatting-syntax
-    - include: scope:source.c#strings
-
-  formatting-syntax:
-    # https://docs.python.org/3.6/library/string.html#formatstrings
-    - match: |- # simple form
-        (?x)
-        (\{)
-          (?: [\w.\[\]]+)?             # field_name
-          (   ! [ars])?                # conversion
-          (   : (?:{{format_spec}}|    # format_spec OR
-                   [^}%]*%.[^}]*)      # any format-like string
-          )?
-        (\})
-      scope: constant.other.placeholder.c++
-      captures:
-        1: punctuation.definition.placeholder.begin.c++
-        2: storage.modifier.c++onversion.c++
-        3: constant.other.format-spec.c++
-        4: punctuation.definition.placeholder.end.c++
-    - match: \{(?=[^\}"']+\{[^"']*\}) # complex (nested) form
-      scope: punctuation.definition.placeholder.begin.c++
-      push:
-        - meta_scope: constant.other.placeholder.c++
-        - match: \}
-          scope: punctuation.definition.placeholder.end.c++
-          pop: true
-        - match: '[\w.\[\]]+'
-        - match: '![ars]'
-          scope: storage.modifier.conversion.c++
-        - match: ':'
-          push:
-            - meta_scope: meta.format-spec.c++ constant.other.format-spec.c++
-            - match: (?=\})
-              pop: true
-            - include: formatting-syntax
-
-  numbers:
-    - include: unique-numbers
-    - include: scope:source.c#numbers
-
-  ## C++-specific contexts
-
-  case-default:
-    - match: '\b(default|case)\b'
-      scope: keyword.control.c++
-      push:
-        - match: (?=[);,])
-          pop: true
-        - match: ':'
-          scope: punctuation.separator.c++
-          pop: true
-        - include: expressions
-
-  modifiers-parens:
-    - match: '\b(alignas)\b\s*(\()'
-      captures:
-        1: storage.modifier.c++
-        2: meta.group.c++ punctuation.section.group.begin.c++
-      push:
-        - meta_content_scope: meta.group.c++
-        - match: '\)'
-          scope: meta.group.c++ punctuation.section.group.end.c++
-          pop: true
-        - include: expressions
-    - match: \b(__attribute__)\s*(\(\()
-      captures:
-        1: storage.modifier.c++
-        2: meta.group.c++ punctuation.section.group.begin.c++
-      push :
-        - meta_scope: meta.attribute.c++
-        - meta_content_scope: meta.group.c++
-        - include: parens
-        - include: strings
-        - match: \)\)
-          scope: meta.group.c++ punctuation.section.group.end.c++
-          pop: true
-    - match: \b(__declspec)(\()
-      captures:
-        1: storage.modifier.c++
-        2: meta.group.c++ punctuation.section.group.begin.c++
-      push:
-        - meta_content_scope: meta.group.c++
-        - match: '\)'
-          scope: meta.group.c++ punctuation.section.group.end.c++
-          pop: true
-        - match: '\b(align|allocate|code_seg|deprecated|property|uuid)\b\s*(\()'
-          captures:
-            1: storage.modifier.c++
-            2: meta.group.c++ punctuation.section.group.begin.c++
-          push:
-            - meta_content_scope: meta.group.c++
-            - match: '\)'
-              scope: meta.group.c++ punctuation.section.group.end.c++
-              pop: true
-            - include: numbers
-            - include: strings
-            - match: \b(get|put)\b
-              scope: variable.parameter.c++
-            - match: ','
-              scope: punctuation.separator.c++
-            - match: '='
-              scope: keyword.operator.assignment.c++
-        - match: '\b(appdomain|deprecated|dllimport|dllexport|jintrinsic|naked|noalias|noinline|noreturn|nothrow|novtable|process|restrict|safebuffers|selectany|thread)\b'
-          scope: constant.other.c++
-
-  types-parens:
-    - match: '\b(decltype)\b\s*(\()'
-      captures:
-        1: storage.type.c++
-        2: meta.group.c++ punctuation.section.group.begin.c++
-      push:
-        - meta_content_scope: meta.group.c++
-        - match: '\)'
-          scope: meta.group.c++ punctuation.section.group.end.c++
-          pop: true
-        - include: expressions
-
-  keywords-angle-brackets:
-    - match: \b({{casts}})\b\s*
-      scope: keyword.operator.word.cast.c++
-      push:
-        - match: '>'
-          scope: punctuation.section.generic.end.c++
-          pop: true
-        - match: '<'
-          scope: punctuation.section.generic.begin.c++
-          push:
-            - match: '(?=>)'
-              pop: true
-            - include: expressions-minus-generic-type-function-call
-
-  keywords-parens:
-    - match: '\b(alignof|typeid|static_assert|sizeof)\b\s*(\()'
-      captures:
-        1: keyword.operator.word.c++
-        2: meta.group.c++ punctuation.section.group.begin.c++
-      push:
-        - meta_content_scope: meta.group.c++
-        - match: '\)'
-          scope: meta.group.c++ punctuation.section.group.end.c++
-          pop: true
-        - include: expressions
-
-  namespace:
-    - match: '\b(using)\s+(namespace)\s+(?={{path_lookahead}})'
-      captures:
-        1: keyword.control.c++
-        2: keyword.control.c++
-      push:
-        - include: identifiers
-        - match: ''
-          pop: true
-    - match: '\b(namespace)\s+(?=({{path_lookahead}})?(?!\s*[;,]))'
-      scope: meta.namespace.c++
-      captures:
-        1: keyword.control.c++
-      push:
-        - meta_content_scope: meta.namespace.c++ entity.name.namespace.c++
-        - include: identifiers
-        - match: ''
-          set:
-            - meta_scope: meta.namespace.c++
-            - include: comments
-            - match: '='
-              scope: keyword.operator.alias.c++
-            - match: '(?=;)'
-              pop: true
-            - match: '\}'
-              scope: meta.block.c++ punctuation.section.block.end.c++
-              pop: true
-            - match: '\{'
-              scope: punctuation.section.block.begin.c++
-              push:
-                - meta_scope: meta.block.c++
-                - match: '(?=\})'
-                  pop: true
-                - include: preprocessor-global
-                - include: global
-            - include: expressions
-
-  template-common:
-    # Exit the template scope if we hit some basic invalid characters. This
-    # helps when a user is in the middle of typing their template types and
-    # prevents re-highlighting the whole file until the next > is found.
-    - match: (?=[{};])
-      pop: true
-    - include: expressions
-
-  template:
-    - match: \btemplate\b
-      scope: storage.type.template.c++
-      push:
-        - meta_scope: meta.template.c++
-        # Explicitly include comments here at the top, in order to NOT match the
-        # \S lookahead in the case of comments.
-        - include: comments
-        - match: <
-          scope: punctuation.section.generic.begin.c++
-          set:
-            - meta_content_scope: meta.template.c++
-            - match: '>'
-              scope: meta.template.c++ punctuation.section.generic.end.c++
-              pop: true
-            - match: \.{3}
-              scope: keyword.operator.variadic.c++
-            - match: \b(typename|{{before_tag}})\b
-              scope: storage.type.c++
-            - include: template # include template here for nested templates
-            - include: template-common
-        - match: (?=\S)
-          set:
-            - meta_content_scope: meta.template.c++
-            - match: \b({{before_tag}})\b
-              scope: storage.type.c++
-            - include: template-common
-
-  generic-type:
-    - match: '(?=(?!template){{path_lookahead}}\s*{{generic_lookahead}}\s*\()'
-      push:
-        - meta_scope: meta.function-call.c++
-        - match: \btemplate\b
-          scope: storage.type.template.c++
-        - match: '(?:(::)\s*)?{{identifier}}\s*(::)\s*'
-          captures:
-            1: punctuation.accessor.double-colon.c++
-            2: punctuation.accessor.double-colon.c++
-        - match: (?:(::)\s*)?({{identifier}})\s*(<)
-          captures:
-            1: punctuation.accessor.double-colon.c++
-            2: variable.function.c++
-            3: punctuation.section.generic.begin.c++
-          push:
-            - match: '>'
-              scope: punctuation.section.generic.end.c++
-              pop: true
-            - include: expressions-minus-generic-type-function-call
-        - match: (?:(::)\s*)?({{identifier}})\s*(\()
-          captures:
-            1: punctuation.accessor.double-colon.c++
-            2: variable.function.c++
-            3: punctuation.section.group.begin.c++
-          set:
-            - meta_scope: meta.function-call.c++
-            - meta_content_scope: meta.group.c++
-            - match: '\)'
-              scope: meta.group.c++ punctuation.section.group.end.c++
-              pop: true
-            - include: expressions
-        - include: angle-brackets
-        - match: '\('
-          scope: meta.group.c++ punctuation.section.group.begin.c++
-          set:
-            - meta_scope: meta.function-call.c++
-            - meta_content_scope: meta.group.c++
-            - match: '\)'
-              scope: meta.group.c++ punctuation.section.group.end.c++
-              pop: true
-            - include: expressions
-    - match: '(?=(?!template){{path_lookahead}}\s*{{generic_lookahead}})'
-      push:
-        - include: identifiers
-        - match: '<'
-          scope: punctuation.section.generic.begin.c++
-          set:
-            - match: '>'
-              scope: punctuation.section.generic.end.c++
-              pop: true
-            - include: expressions-minus-generic-type-function-call
-
-  angle-brackets:
-    - match: '<(?!<)'
-      scope: punctuation.section.generic.begin.c++
-      push:
-        - match: '>'
-          scope: punctuation.section.generic.end.c++
-          pop: true
-        - include: expressions-minus-generic-type-function-call
-
-  block:
-    - match: '\{'
-      scope: punctuation.section.block.begin.c++
-      push:
-        - meta_scope: meta.block.c++
-        - match: (?=^\s*#\s*(elif|else|endif)\b)
-          pop: true
-        - match: '\}'
-          scope: punctuation.section.block.end.c++
-          pop: true
-        - include: statements
-
-  function-call:
-    - match: (?={{path_lookahead}}\s*\()
-      push:
-        - meta_scope: meta.function-call.c++
-        - include: scope:source.c#c99
-        - match: '(?:(::)\s*)?{{identifier}}\s*(::)\s*'
-          scope: variable.function.c++
-          captures:
-            1: punctuation.accessor.c++
-            2: punctuation.accessor.c++
-        - match: '(?:(::)\s*)?{{identifier}}'
-          scope: variable.function.c++
-          captures:
-            1: punctuation.accessor.c++
-        - match: '\('
-          scope: meta.group.c++ punctuation.section.group.begin.c++
-          set:
-            - meta_content_scope: meta.function-call.c++ meta.group.c++
-            - match: '\)'
-              scope: meta.function-call.c++ meta.group.c++ punctuation.section.group.end.c++
-              pop: true
-            - include: expressions
-
-  members-inside-function-call:
-    - meta_content_scope: meta.method-call.c++ meta.group.c++
-    - match: \)
-      scope: meta.method-call.c++ meta.group.c++ punctuation.section.group.end.c++
-      pop: true
-    - include: expressions
-
-  members-after-accessor-junction:
-    # After we've seen an accessor (dot or arrow), this context decides what
-    # kind of entity we're accessing.
-    - include: comments
-    - match: \btemplate\b
-      scope: meta.method-call.c++ storage.type.template.c++
-      # Guaranteed to be a template member function call after we match this
-      set:
-        - meta_content_scope: meta.method-call.c++
-        - include: comments
-        - match: '{{identifier}}'
-          scope: variable.function.member.c++
-          set:
-            - meta_content_scope: meta.method-call.c++
-            - match: \(
-              scope: meta.group.c++ punctuation.section.group.begin.c++
-              set: members-inside-function-call
-            - include: comments
-            - include: angle-brackets
-            - match: (?=\S) # safety pop
-              pop: true
-        - match: (?=\S) # safety pop
-          pop: true
-    # Operator overloading
-    - match: '({{operator_method_name}})\s*(\()'
-      captures:
-        0: meta.method-call.c++
-        1: variable.function.member.c++
-        2: meta.group.c++ punctuation.section.group.begin.c++
-      set: members-inside-function-call
-    # Non-templated member function call
-    - match: (~?{{identifier}})\s*(\()
-      captures:
-        0: meta.method-call.c++
-        1: variable.function.member.c++
-        2: meta.group.c++ punctuation.section.group.begin.c++
-      set: members-inside-function-call
-    # Templated member function call
-    - match: (~?{{identifier}})\s*(?={{generic_lookahead}})
-      captures:
-        1: variable.function.member.c++
-      set:
-        - meta_scope: meta.method-call.c++
-        - match: <
-          scope: punctuation.section.generic.begin.c++
-          set:
-            - meta_content_scope: meta.method-call.c++
-            - match: '>'
-              scope: punctuation.section.generic.end.c++
-              set:
-                - meta_content_scope: meta.method-call.c++
-                - include: comments
-                - match: \(
-                  scope: punctuation.section.group.begin.c++
-                  set: members-inside-function-call
-                - match: (?=\S) # safety pop
-                  pop: true
-            - include: expressions
-    # Explicit base-class access
-    - match: ({{identifier}})\s*(::)
-      captures:
-        1: variable.other.base-class.c++
-        2: punctuation.accessor.double-colon.c++
-      set: members-after-accessor-junction # reset
-    # Just a regular member variable
-    - match: '{{identifier}}'
-      scope: variable.other.readwrite.member.c++
-      pop: true
-
-  members-dot:
-    - include: scope:source.c#access-illegal
-    # No lookahead required because members-dot goes after operators in the
-    # early-expressions-after-generic-type context. This means triple dots
-    # (i.e. "..." or "variadic") is attempted first.
-    - match: \.
-      scope: punctuation.accessor.dot.c++
-      push: members-after-accessor-junction
-
-  members-arrow:
-    # This needs to be before operators in the
-    # early-expressions-after-generic-type context because otherwise the "->"
-    # from the C language will match.
-    - match: ->
-      scope: punctuation.accessor.arrow.c++
-      push: members-after-accessor-junction
-
-  typedef:
-    - match: \btypedef\b
-      scope: storage.type.c++
-      push:
-        - match: ({{identifier}})?\s*(?=;)
-          captures:
-            1: entity.name.type.typedef.c++
-          pop: true
-        - match: \b(struct)\s+({{identifier}})\b
-          captures:
-            1: storage.type.c++
-        - include: expressions-minus-generic-type
-
-  parens:
-    - match: \(
-      scope: punctuation.section.group.begin.c++
-      push:
-        - meta_scope: meta.group.c++
-        - match: \)
-          scope: punctuation.section.group.end.c++
-          pop: true
-        - include: expressions
-
-  brackets:
-    - match: \[
-      scope: punctuation.section.brackets.begin.c++
-      push:
-        - meta_scope: meta.brackets.c++
-        - match: \]
-          scope: punctuation.section.brackets.end.c++
-          pop: true
-        - include: expressions
-
-  function-trailing-return-type:
-    - match: '{{non_angle_brackets}}'
-      pop: true
-    - include: angle-brackets
-    - include: types
-    - include: modifiers-parens
-    - include: modifiers
-    - include: identifiers
-    - match: \*|&
-      scope: keyword.operator.c++
-    - include: function-trailing-return-type-parens
-    - match: '(?=\S)'
-      pop: true
-
-  function-trailing-return-type-parens:
-    - match: \(
-      scope: punctuation.section.group.begin.c++
-      push:
-        - meta_scope: meta.group.c++
-        - match: \)
-          scope: punctuation.section.group.end.c++
-          pop: true
-        - include: function-trailing-return-type
-
-  ## Detection of function and data structure definitions at the global level
-
-  global-modifier:
-    - include: comments
-    - include: modifiers-parens
-    - include: modifiers
-    # Constructors and destructors don't have a type
-    - match: '(?={{path_lookahead}}\s*::\s*{{identifier}}\s*(\(|$))'
-      set:
-        - meta_content_scope: meta.function.c++ entity.name.function.constructor.c++
-        - include: identifiers
-        - match: '(?=[^\w\s])'
-          set: function-definition-params
-    - match: '(?={{path_lookahead}}\s*::\s*~{{identifier}}\s*(\(|$))'
-      set:
-        - meta_content_scope: meta.function.c++ entity.name.function.destructor.c++
-        - include: identifiers
-        - match: '~{{identifier}}'
-        - match: '(?=[^\w\s])'
-          set: function-definition-params
-    # If we see a path ending in :: before a newline, we don't know if it is
-    # a constructor or destructor, or a long return type, so we are just going
-    # to treat it like a regular function. Most likely it is a constructor,
-    # since it doesn't seem most developers would create such a long typename.
-    - match: '(?={{path_lookahead}}\s*::\s*$)'
-      set:
-        - meta_content_scope: meta.function.c++ entity.name.function.c++
-        - include: identifiers
-        - match: '~{{identifier}}'
-        - match: '(?=[^\w\s])'
-          set: function-definition-params
-    - include: unique-strings
-    - match: '(?=\S)'
-      set: global-type
-
-  global-type:
-    - include: comments
-    - match: \*|&
-      scope: keyword.operator.c++
-    - match: '(?=\b({{control_keywords}}|{{operator_keywords}}|{{casts}}|{{memory_operators}}|{{other_keywords}}|operator)\b)'
-      pop: true
-    - match: '(?=\s)'
-      set: global-maybe-function
-    # If a class/struct/enum followed by a name that is not a macro or declspec
-    # then this is likely a return type of a function. This is uncommon.
-    - match: |-
-        (?x:
-          ({{before_tag}})
-          \s+
-          (?=
-            (?![[:upper:][:digit:]_]+\b|__declspec|{{before_tag}})
-            {{path_lookahead}}
-            (\s+{{identifier}}\s*\(|\s*[*&])
-          )
-        )
-      captures:
-        1: storage.type.c++
-      set:
-        - include: identifiers
-        - match: ''
-          set: global-maybe-function
-    # The previous match handles return types of struct/enum/etc from a func,
-    # there this one exits the context to allow matching an actual struct/class
-    - match: '(?=\b({{before_tag}})\b)'
-      set: data-structures
-    - match: '(?=\b({{casts}})\b\s*<)'
-      pop: true
-    - match: '{{non_angle_brackets}}'
-      pop: true
-    - include: angle-brackets
-    - include: types
-    # Allow a macro call
-    - match: '({{identifier}})\s*(\()(?=[^\)]+\))'
-      captures:
-        1: variable.function.c++
-        2: meta.group.c++ punctuation.section.group.begin.c++
-      push:
-        - meta_scope: meta.function-call.c++
-        - meta_content_scope: meta.group.c++
-        - match: '\)'
-          scope: meta.group.c++ punctuation.section.group.end.c++
-          pop: true
-        - include: expressions
-    - match: '(?={{path_lookahead}}\s*\()'
-      set:
-        - include: function-call
-        - match: ''
-          pop: true
-    - include: variables
-    - include: constants
-    - include: identifiers
-    - match: (?=\W)
-      pop: true
-
-  global-maybe-function:
-    - include: comments
-    # Consume pointer info, macros and any type info that was offset by macros
-    - match: \*|&
-      scope: keyword.operator.c++
-    - match: '(?=\b({{control_keywords}}|{{operator_keywords}}|{{casts}}|{{memory_operators}}|{{other_keywords}})\b)'
-      pop: true
-    - match: '\b({{type_qualifier}})\b'
-      scope: storage.modifier.c++
-    - match: '{{non_angle_brackets}}'
-      pop: true
-    - include: angle-brackets
-    - include: types
-    - include: modifiers-parens
-    - include: modifiers
-    # All uppercase identifier just before a newline is most likely a macro
-    - match: '[[:upper:][:digit:]_]+\s*$'
-    # Operator overloading
-    - match: '(?=({{path_lookahead}}\s*(?:{{generic_lookahead}})?::\s*)?{{operator_method_name}}\s*(\(|$))'
-      set:
-        - meta_content_scope: meta.function.c++ entity.name.function.c++
-        - include: identifiers
-        - match: '(?=\s*(\(|$))'
-          set: function-definition-params
-    # Identifier that is not the function name - likely a macro or type
-    - match: '(?={{path_lookahead}}([ \t]+|[*&])(?!\s*(<|::|\(|$)))'
-      push:
-        - include: identifiers
-        - match: ''
-          pop: true
-    # Real function definition
-    - match: '(?={{path_lookahead}}({{generic_lookahead}}({{path_lookahead}})?)\s*(\(|$))'
-      set: [function-definition-params, global-function-identifier-generic]
-    - match: '(?={{path_lookahead}}\s*(\(|$))'
-      set: [function-definition-params, global-function-identifier]
-    - match: '(?={{path_lookahead}}\s*::\s*$)'
-      set: [function-definition-params, global-function-identifier]
-    - match: '(?=\S)'
-      pop: true
-
-  global-function-identifier-generic:
-    - include: angle-brackets
-    - match: '::'
-      scope: punctuation.accessor.c++
-    - match: '(?={{identifier}}<.*>\s*\()'
-      push:
-        - meta_content_scope: entity.name.function.c++
-        - include: identifiers
-        - match: '(?=<)'
-          pop: true
-    - match: '(?={{identifier}}\s*\()'
-      push:
-        - meta_content_scope: entity.name.function.c++
-        - include: identifiers
-        - match: ''
-          pop: true
-    - match: '(?=\()'
-      pop: true
-
-  global-function-identifier:
-    - meta_content_scope: entity.name.function.c++
-    - include: identifiers
-    - match: '(?=\S)'
-      pop: true
-
-  function-definition-params:
-    - meta_content_scope: meta.function.c++
-    - include: comments
-    - match: '(?=\()'
-      set:
-        - match: \(
-          scope: meta.function.parameters.c++ meta.group.c++ punctuation.section.group.begin.c++
-          set:
-            - meta_content_scope: meta.function.parameters.c++ meta.group.c++
-            - match : \)
-              scope: punctuation.section.group.end.c++
-              set: function-definition-continue
-            - match: '\bvoid\b'
-              scope: storage.type.c++
-            - match: '{{identifier}}(?=\s*(\[|,|\)|=))'
-              scope: variable.parameter.c++
-            - match: '='
-              scope: keyword.operator.assignment.c++
-              push:
-                - match: '(?=,|\))'
-                  pop: true
-                - include: expressions-minus-generic-type
-                - include: scope:source.c#preprocessor-line-continuation
-            - include: expressions-minus-generic-type
-            - include: scope:source.c#preprocessor-line-continuation
-    - match: (?=\S)
-      pop: true
-
-  function-definition-continue:
-    - meta_content_scope: meta.function.c++
-    - include: comments
-    - match: '(?=;)'
-      pop: true
-    - match: '->'
-      scope: punctuation.separator.c++
-      set: function-definition-trailing-return
-    - include: function-specifiers
-    - match: '='
-      scope: keyword.operator.assignment.c++
-    - match: '&'
-      scope: keyword.operator.c++
-    - match: \b0\b
-      scope: constant.numeric.c++
-    - match: \b(default|delete)\b
-      scope: storage.modifier.c++
-    - match: '(?=\{)'
-      set: function-definition-body
-    - match: '(?=\S)'
-      pop: true
-
-  function-definition-trailing-return:
-    - include: comments
-    - match: '(?=;)'
-      pop: true
-    - match: '(?=\{)'
-      set: function-definition-body
-    - include: function-specifiers
-    - include: function-trailing-return-type
-
-  function-definition-body:
-    - meta_content_scope: meta.function.c++ meta.block.c++
-    - match: '\{'
-      scope: punctuation.section.block.begin.c++
-      set:
-        - meta_content_scope: meta.function.c++ meta.block.c++
-        - match: '\}'
-          scope: meta.function.c++ meta.block.c++ punctuation.section.block.end.c++
-          pop: true
-        - match: (?=^\s*#\s*(elif|else|endif)\b)
-          pop: true
-        - match: '(?=({{before_tag}})([^(;]+$|.*\{))'
-          push: data-structures
-        - include: statements
-
-  ## Data structures including classes, structs, unions and enums
-
-  data-structures:
-    - match: '\bclass\b'
-      scope: storage.type.c++
-      set: data-structures-class-definition
-    # Detect variable type definitions using struct/enum/union followed by a tag
-    - match: '\b({{before_tag}})(?=\s+{{path_lookahead}}\s+{{path_lookahead}}\s*[=;\[])'
-      scope: storage.type.c++
-    - match: '\bstruct\b'
-      scope: storage.type.c++
-      set: data-structures-struct-definition
-    - match: '\benum(\s+(class|struct))?\b'
-      scope: storage.type.c++
-      set: data-structures-enum-definition
-    - match: '\bunion\b'
-      scope: storage.type.c++
-      set: data-structures-union-definition
-    - match: '(?=\S)'
-      pop: true
-
-  preprocessor-workaround-eat-macro-before-identifier:
-    # Handle macros so they aren't matched as the class name
-    - match: ({{macro_identifier}})(?=\s+~?{{identifier}})
-      captures:
-        1: meta.assumed-macro.c
-
-  data-structures-class-definition:
-    - meta_scope: meta.class.c++
-    - include: data-structures-definition-common-begin
-    - match: '{{identifier}}(?={{data_structures_forward_decl_lookahead}})'
-      scope: entity.name.class.forward-decl.c++
-      set: data-structures-class-definition-after-identifier
-    - match: '{{identifier}}'
-      scope: entity.name.class.c++
-      set: data-structures-class-definition-after-identifier
-    - match: '(?=[:{])'
-      set: data-structures-class-definition-after-identifier
-    - match: '(?=;)'
-      pop: true
-
-  data-structures-class-definition-after-identifier:
-    - meta_content_scope: meta.class.c++
-    - include: data-structures-definition-common-begin
-    # No matching of identifiers since they should all be macros at this point
-    - include: data-structures-definition-common-end
-    - match: '\{'
-      scope: meta.block.c++ punctuation.section.block.begin.c++
-      set:
-        - meta_content_scope: meta.class.c++ meta.block.c++
-        - match: '\}'
-          scope: meta.class.c++ meta.block.c++ punctuation.section.block.end.c++
-          pop: true
-        - include: data-structures-body
-
-  data-structures-struct-definition:
-    - meta_scope: meta.struct.c++
-    - include: data-structures-definition-common-begin
-    - match: '{{identifier}}(?={{data_structures_forward_decl_lookahead}})'
-      scope: entity.name.struct.forward-decl.c++
-      set: data-structures-struct-definition-after-identifier
-    - match: '{{identifier}}'
-      scope: entity.name.struct.c++
-      set: data-structures-struct-definition-after-identifier
-    - match: '(?=[:{])'
-      set: data-structures-struct-definition-after-identifier
-    - match: '(?=;)'
-      pop: true
-
-  data-structures-struct-definition-after-identifier:
-    - meta_content_scope: meta.struct.c++
-    - include: data-structures-definition-common-begin
-    # No matching of identifiers since they should all be macros at this point
-    - include: data-structures-definition-common-end
-    - match: '\{'
-      scope: meta.block.c++ punctuation.section.block.begin.c++
-      set:
-        - meta_content_scope: meta.struct.c++ meta.block.c++
-        - match: '\}'
-          scope: meta.struct.c++ meta.block.c++ punctuation.section.block.end.c++
-          pop: true
-        - include: data-structures-body
-
-  data-structures-enum-definition:
-    - meta_scope: meta.enum.c++
-    - include: data-structures-definition-common-begin
-    - match: '{{identifier}}(?={{data_structures_forward_decl_lookahead}})'
-      scope: entity.name.enum.forward-decl.c++
-      set: data-structures-enum-definition-after-identifier
-    - match: '{{identifier}}'
-      scope: entity.name.enum.c++
-      set: data-structures-enum-definition-after-identifier
-    - match: '(?=[:{])'
-      set: data-structures-enum-definition-after-identifier
-    - match: '(?=;)'
-      pop: true
-
-  data-structures-enum-definition-after-identifier:
-    - meta_content_scope: meta.enum.c++
-    - include: data-structures-definition-common-begin
-    # No matching of identifiers since they should all be macros at this point
-    - include: data-structures-definition-common-end
-    - match: '\{'
-      scope: meta.block.c++ punctuation.section.block.begin.c++
-      set:
-        - meta_content_scope: meta.enum.c++ meta.block.c++
-        # Enums don't support methods so we have a simplified body
-        - match: '\}'
-          scope: meta.enum.c++ meta.block.c++ punctuation.section.block.end.c++
-          pop: true
-        - include: statements
-
-  data-structures-union-definition:
-    - meta_scope: meta.union.c++
-    - include: data-structures-definition-common-begin
-    - match: '{{identifier}}(?={{data_structures_forward_decl_lookahead}})'
-      scope: entity.name.union.forward-decl.c++
-      set: data-structures-union-definition-after-identifier
-    - match: '{{identifier}}'
-      scope: entity.name.union.c++
-      set: data-structures-union-definition-after-identifier
-    - match: '(?=[{])'
-      set: data-structures-union-definition-after-identifier
-    - match: '(?=;)'
-      pop: true
-
-  data-structures-union-definition-after-identifier:
-    - meta_content_scope: meta.union.c++
-    - include: data-structures-definition-common-begin
-    # No matching of identifiers since they should all be macros at this point
-    # Unions don't support base classes
-    - include: angle-brackets
-    - match: '\{'
-      scope: meta.block.c++ punctuation.section.block.begin.c++
-      set:
-        - meta_content_scope: meta.union.c++ meta.block.c++
-        - match: '\}'
-          scope: meta.union.c++ meta.block.c++ punctuation.section.block.end.c++
-          pop: true
-        - include: data-structures-body
-    - match: '(?=;)'
-      pop: true
-
-  data-structures-definition-common-begin:
-    - include: comments
-    - match: '(?=\b(?:{{before_tag}}|{{control_keywords}})\b)'
-      pop: true
-    - include: preprocessor-other
-    - include: modifiers-parens
-    - include: modifiers
-    - include: preprocessor-workaround-eat-macro-before-identifier
-
-  data-structures-definition-common-end:
-    - include: angle-brackets
-    - match: \bfinal\b
-      scope: storage.modifier.c++
-    - match: ':'
-      scope: punctuation.separator.c++
-      push:
-        - include: comments
-        - include: preprocessor-other
-        - include: modifiers-parens
-        - include: modifiers
-        - match: '\b(virtual|{{visibility_modifiers}})\b'
-          scope: storage.modifier.c++
-        - match: (?={{path_lookahead}})
-          push:
-            - meta_scope: entity.other.inherited-class.c++
-            - include: identifiers
-            - match: ''
-              pop: true
-        - include: angle-brackets
-        - match: ','
-          scope: punctuation.separator.c++
-        - match: (?=\{|;)
-          pop: true
-    - match: '(?=;)'
-      pop: true
-
-  data-structures-body:
-    - include: preprocessor-data-structures
-    - match: '(?=\btemplate\b)'
-      push:
-        - include: template
-        - match: (?=\S)
-          set: data-structures-modifier
-    - include: typedef
-    - match: \b({{visibility_modifiers}})\s*(:)(?!:)
-      captures:
-        1: storage.modifier.c++
-        2: punctuation.section.class.c++
-    - match: '^\s*(?=(?:~?\w+|::))'
-      push: data-structures-modifier
-    - include: expressions-minus-generic-type
-
-  data-structures-modifier:
-    - match: '\bfriend\b'
-      scope: storage.modifier.c++
-      push:
-        - match: (?=;)
-          pop: true
-        - match: '\{'
-          scope: punctuation.section.block.begin.c++
-          set:
-            - meta_scope: meta.block.c++
-            - match: '\}'
-              scope: punctuation.section.block.end.c++
-              pop: true
-            - include: statements
-        - match: '\b({{before_tag}})\b'
-          scope: storage.type.c++
-        - include: expressions-minus-function-call
-    - include: comments
-    - include: modifiers-parens
-    - include: modifiers
-    - match: '\bstatic_assert(?=\s*\()'
-      scope: meta.static-assert.c++ keyword.operator.word.c++
-      push:
-        - match: '\('
-          scope: meta.group.c++ punctuation.section.group.begin.c++
-          set:
-            - meta_content_scope: meta.function-call.c++ meta.group.c++
-            - match: '\)'
-              scope: meta.function-call.c++ meta.group.c++ punctuation.section.group.end.c++
-              pop: true
-            - include: expressions
-    # Destructor
-    - match: '(?:{{identifier}}\s*(::)\s*)?~{{identifier}}(?=\s*(\(|$))'
-      scope: meta.method.destructor.c++ entity.name.function.destructor.c++
-      captures:
-        1: punctuation.accessor.c++
-      set: method-definition-params
-    # It's a macro, not a constructor if there is no type in the first param
-    - match: '({{identifier}})\s*(\()(?=\s*(?!void){{identifier}}\s*[),])'
-      captures:
-        1: variable.function.c++
-        2: meta.group.c++ punctuation.section.group.begin.c++
-      push:
-        - meta_scope: meta.function-call.c++
-        - meta_content_scope: meta.group.c++
-        - match: '\)'
-          scope: meta.group.c++ punctuation.section.group.end.c++
-          pop: true
-        - include: expressions
-    # Constructor
-    - include: preprocessor-workaround-eat-macro-before-identifier
-    - match: '((?!{{before_tag}}|template){{identifier}})(?=\s*\()'
-      scope: meta.method.constructor.c++ entity.name.function.constructor.c++
-      set: method-definition-params
-    # Long form constructor
-    - match: '({{identifier}}\s*(::)\s*{{identifier}})(?=\s*\()'
-      captures:
-        1: meta.method.constructor.c++ entity.name.function.constructor.c++
-        2: punctuation.accessor.c++
-      push: method-definition-params
-    - match: '(?=\S)'
-      set: data-structures-type
-
-  data-structures-type:
-    - include: comments
-    - match: \*|&
-      scope: keyword.operator.c++
-      # Cast methods
-    - match: '(operator)\s+({{identifier}})(?=\s*(\(|$))'
-      captures:
-        1: keyword.control.c++
-        2: meta.method.c++ entity.name.function.c++
-      set: method-definition-params
-    - match: '(?=\b({{control_keywords}}|{{operator_keywords}}|{{casts}}|{{memory_operators}}|{{other_keywords}}|operator)\b)'
-      pop: true
-    - match: '(?=\s)'
-      set: data-structures-maybe-method
-    # If a class/struct/enum followed by a name that is not a macro or declspec
-    # then this is likely a return type of a function. This is uncommon.
-    - match: |-
-        (?x:
-          ({{before_tag}})
-          \s+
-          (?=
-            (?![[:upper:][:digit:]_]+\b|__declspec|{{before_tag}})
-            {{path_lookahead}}
-            (\s+{{identifier}}\s*\(|\s*[*&])
-          )
-        )
-      captures:
-        1: storage.type.c++
-      set:
-        - include: identifiers
-        - match: ''
-          set: data-structures-maybe-method
-    # The previous match handles return types of struct/enum/etc from a func,
-    # there this one exits the context to allow matching an actual struct/class
-    - match: '(?=\b({{before_tag}})\b)'
-      set: data-structures
-    - match: '(?=\b({{casts}})\b\s*<)'
-      pop: true
-    - match: '{{non_angle_brackets}}'
-      pop: true
-    - include: angle-brackets
-    - include: types
-    - include: variables
-    - include: constants
-    - include: identifiers
-    - match: (?=[&*])
-      set: data-structures-maybe-method
-    - match: (?=\W)
-      pop: true
-
-  data-structures-maybe-method:
-    - include: comments
-    # Consume pointer info, macros and any type info that was offset by macros
-    - match: \*|&
-      scope: keyword.operator.c++
-    - match: '(?=\b({{control_keywords}}|{{operator_keywords}}|{{casts}}|{{memory_operators}}|{{other_keywords}})\b)'
-      pop: true
-    - match: '\b({{type_qualifier}})\b'
-      scope: storage.modifier.c++
-    - match: '{{non_angle_brackets}}'
-      pop: true
-    - include: angle-brackets
-    - include: types
-    - include: modifiers-parens
-    - include: modifiers
-    # Operator overloading
-    - match: '{{operator_method_name}}(?=\s*(\(|$))'
-      scope: meta.method.c++ entity.name.function.c++
-      set: method-definition-params
-    # Identifier that is not the function name - likely a macro or type
-    - match: '(?={{path_lookahead}}([ \t]+|[*&])(?!\s*(<|::|\()))'
-      push:
-        - include: identifiers
-        - match: ''
-          pop: true
-    # Real function definition
-    - match: '(?={{path_lookahead}}({{generic_lookahead}})\s*(\())'
-      set: [method-definition-params, data-structures-function-identifier-generic]
-    - match: '(?={{path_lookahead}}\s*(\())'
-      set: [method-definition-params, data-structures-function-identifier]
-    - match: '(?={{path_lookahead}}\s*::\s*$)'
-      set: [method-definition-params, data-structures-function-identifier]
-    - match: '(?=\S)'
-      pop: true
-
-  data-structures-function-identifier-generic:
-    - include: angle-brackets
-    - match: '(?={{identifier}})'
-      push:
-        - meta_content_scope: entity.name.function.c++
-        - include: identifiers
-        - match: '(?=<)'
-          pop: true
-    - match: '(?=\()'
-      pop: true
-
-  data-structures-function-identifier:
-    - meta_content_scope: entity.name.function.c++
-    - include: identifiers
-    - match: '(?=\S)'
-      pop: true
-
-  method-definition-params:
-    - meta_content_scope: meta.method.c++
-    - include: comments
-    - match: '(?=\()'
-      set:
-        - match: \(
-          scope: meta.method.parameters.c++ meta.group.c++ punctuation.section.group.begin.c++
-          set:
-            - meta_content_scope: meta.method.parameters.c++ meta.group.c++
-            - match : \)
-              scope: punctuation.section.group.end.c++
-              set: method-definition-continue
-            - match: '\bvoid\b'
-              scope: storage.type.c++
-            - match: '{{identifier}}(?=\s*(\[|,|\)|=))'
-              scope: variable.parameter.c++
-            - match: '='
-              scope: keyword.operator.assignment.c++
-              push:
-                - match: '(?=,|\))'
-                  pop: true
-                - include: expressions-minus-generic-type
-            - include: expressions-minus-generic-type
-    - match: '(?=\S)'
-      pop: true
-
-  method-definition-continue:
-    - meta_content_scope: meta.method.c++
-    - include: comments
-    - match: '(?=;)'
-      pop: true
-    - match: '->'
-      scope: punctuation.separator.c++
-      set: method-definition-trailing-return
-    - include: function-specifiers
-    - match: '='
-      scope: keyword.operator.assignment.c++
-    - match: '&'
-      scope: keyword.operator.c++
-    - match: \b0\b
-      scope: constant.numeric.c++
-    - match: \b(default|delete)\b
-      scope: storage.modifier.c++
-    - match: '(?=:)'
-      set:
-        - match: ':'
-          scope: punctuation.separator.initializer-list.c++
-          set:
-            - meta_scope: meta.method.constructor.initializer-list.c++
-            - match: '{{identifier}}'
-              scope: variable.other.readwrite.member.c++
-              push:
-                - match: \(
-                  scope: meta.group.c++ punctuation.section.group.begin.c++
-                  set:
-                    - meta_content_scope: meta.group.c++
-                    - match: \)
-                      scope: meta.group.c++ punctuation.section.group.end.c++
-                      pop: true
-                    - include: expressions
-                - match: \{
-                  scope: meta.group.c++ punctuation.section.group.begin.c++
-                  set:
-                    - meta_content_scope: meta.group.c++
-                    - match: \}
-                      scope: meta.group.c++ punctuation.section.group.end.c++
-                      pop: true
-                    - include: expressions
-                - include: comments
-            - match: (?=\{|;)
-              set: method-definition-continue
-            - include: expressions
-    - match: '(?=\{)'
-      set: method-definition-body
-    - match: '(?=\S)'
-      pop: true
-
-  method-definition-trailing-return:
-    - include: comments
-    - match: '(?=;)'
-      pop: true
-    - match: '(?=\{)'
-      set: method-definition-body
-    - include: function-specifiers
-    - include: function-trailing-return-type
-
-  method-definition-body:
-    - meta_content_scope: meta.method.c++ meta.block.c++
-    - match: '\{'
-      scope: punctuation.section.block.begin.c++
-      set:
-        - meta_content_scope: meta.method.c++ meta.block.c++
-        - match: '\}'
-          scope: meta.method.c++ meta.block.c++ punctuation.section.block.end.c++
-          pop: true
-        - match: (?=^\s*#\s*(elif|else|endif)\b)
-          pop: true
-        - match: '(?=({{before_tag}})([^(;]+$|.*\{))'
-          push: data-structures
-        - include: statements
-
-  ## Preprocessor for data-structures
-
-  preprocessor-data-structures:
-    - include: preprocessor-rule-enabled-data-structures
-    - include: preprocessor-rule-disabled-data-structures
-    - include: preprocessor-practical-workarounds
-
-  preprocessor-rule-disabled-data-structures:
-    - match: ^\s*((#if)\s+(0))\b
-      captures:
-        1: meta.preprocessor.c++
-        2: keyword.control.import.c++
-        3: constant.numeric.preprocessor.c++
-      push:
-        - match: ^\s*(#\s*endif)\b
-          captures:
-            1: meta.preprocessor.c++ keyword.control.import.c++
-          pop: true
-        - match: ^\s*(#\s*else)\b
-          captures:
-            1: meta.preprocessor.c++ keyword.control.import.else.c++
-          push:
-            - match: (?=^\s*#\s*endif\b)
-              pop: true
-            - include: negated-block
-            - include: data-structures-body
-        - match: ""
-          push:
-            - meta_scope: comment.block.preprocessor.if-branch.c++
-            - match: (?=^\s*#\s*(else|endif)\b)
-              pop: true
-            - include: scope:source.c#preprocessor-disabled
-
-  preprocessor-rule-enabled-data-structures:
-    - match: ^\s*((#if)\s+(0*1))\b
-      captures:
-        1: meta.preprocessor.c++
-        2: keyword.control.import.c++
-        3: constant.numeric.preprocessor.c++
-      push:
-        - match: ^\s*(#\s*endif)\b
-          captures:
-            1: meta.preprocessor.c++ keyword.control.import.c++
-          pop: true
-        - match: ^\s*(#\s*else)\b
-          captures:
-            1: meta.preprocessor.c++ keyword.control.import.else.c++
-          push:
-            - meta_content_scope: comment.block.preprocessor.else-branch.c++
-            - match: (?=^\s*#\s*endif\b)
-              pop: true
-            - include: scope:source.c#preprocessor-disabled
-        - match: ""
-          push:
-            - match: (?=^\s*#\s*(else|endif)\b)
-              pop: true
-            - include: negated-block
-            - include: data-structures-body
-
-  ## Preprocessor for global
-
-  preprocessor-global:
-    - include: preprocessor-rule-enabled-global
-    - include: preprocessor-rule-disabled-global
-    - include: preprocessor-rule-other-global
-
-  preprocessor-statements:
-    - include: preprocessor-rule-enabled-statements
-    - include: preprocessor-rule-disabled-statements
-    - include: preprocessor-rule-other-statements
-
-  preprocessor-expressions:
-    - include: scope:source.c#incomplete-inc
-    - include: preprocessor-macro-define
-    - include: scope:source.c#pragma-mark
-    - include: preprocessor-other
-
-  preprocessor-rule-disabled-global:
-    - match: ^\s*((#if)\s+(0))\b
-      captures:
-        1: meta.preprocessor.c++
-        2: keyword.control.import.c++
-        3: constant.numeric.preprocessor.c++
-      push:
-        - match: ^\s*(#\s*endif)\b
-          captures:
-            1: meta.preprocessor.c++ keyword.control.import.c++
-          pop: true
-        - match: ^\s*(#\s*else)\b
-          captures:
-            1: meta.preprocessor.c++ keyword.control.import.else.c++
-          push:
-            - match: (?=^\s*#\s*endif\b)
-              pop: true
-            - include: preprocessor-global
-            - include: negated-block
-            - include: global
-        - match: ""
-          push:
-            - meta_scope: comment.block.preprocessor.if-branch.c++
-            - match: (?=^\s*#\s*(else|endif)\b)
-              pop: true
-            - include: scope:source.c#preprocessor-disabled
-
-  preprocessor-rule-enabled-global:
-    - match: ^\s*((#if)\s+(0*1))\b
-      captures:
-        1: meta.preprocessor.c++
-        2: keyword.control.import.c++
-        3: constant.numeric.preprocessor.c++
-      push:
-        - match: ^\s*(#\s*endif)\b
-          captures:
-            1: meta.preprocessor.c++ keyword.control.import.c++
-          pop: true
-        - match: ^\s*(#\s*else)\b
-          captures:
-            1: meta.preprocessor.c++ keyword.control.import.else.c++
-          push:
-            - meta_content_scope: comment.block.preprocessor.else-branch.c++
-            - match: (?=^\s*#\s*endif\b)
-              pop: true
-            - include: scope:source.c#preprocessor-disabled
-        - match: ""
-          push:
-            - match: (?=^\s*#\s*(else|endif)\b)
-              pop: true
-            - include: preprocessor-global
-            - include: negated-block
-            - include: global
-
-  preprocessor-rule-other-global:
-    - match: ^\s*(#\s*(?:if|ifdef|ifndef))\b
-      captures:
-        1: keyword.control.import.c++
-      push:
-        - meta_scope: meta.preprocessor.c++
-        - include: scope:source.c#preprocessor-line-continuation
-        - include: scope:source.c#preprocessor-comments
-        - match: \bdefined\b
-          scope: keyword.control.c++
-        # Enter a new scope where all elif/else branches have their
-        # contexts popped by a subsequent elif/else/endif. This ensures that
-        # preprocessor branches don't push multiple meta.block scopes on
-        # the stack, thus messing up the "global" context's detection of
-        # functions.
-        - match: $\n
-          set: preprocessor-if-branch-global
-
-  # These gymnastics here ensure that we are properly handling scope even
-  # when the preprocessor is used to create different scope beginnings, such
-  # as a different if/while condition
-  preprocessor-if-branch-global:
-    - match: ^\s*(#\s*endif)\b
-      captures:
-        1: meta.preprocessor.c++ keyword.control.import.c++
-      pop: true
-    - match: (?=^\s*#\s*(elif|else)\b)
-      push: preprocessor-elif-else-branch-global
-    - match: \{
-      scope: punctuation.section.block.begin.c++
-      set: preprocessor-block-if-branch-global
-    - include: preprocessor-global
-    - include: negated-block
-    - include: global
-
-  preprocessor-block-if-branch-global:
-    - meta_scope: meta.block.c++
-    - match: ^\s*(#\s*endif)\b
-      captures:
-        1: meta.preprocessor.c++ keyword.control.import.c++
-      set: preprocessor-block-finish-global
-    - match: (?=^\s*#\s*(elif|else)\b)
-      push: preprocessor-elif-else-branch-global
-    - match: \}
-      scope: punctuation.section.block.end.c++
-      set: preprocessor-if-branch-global
-    - include: statements
-
-  preprocessor-block-finish-global:
-    - meta_scope: meta.block.c++
-    - match: ^\s*(#\s*(?:if|ifdef|ifndef))\b
-      captures:
-        1: meta.preprocessor.c++ keyword.control.import.c++
-      set: preprocessor-block-finish-if-branch-global
-    - match: \}
-      scope: punctuation.section.block.end.c++
-      pop: true
-    - include: statements
-
-  preprocessor-block-finish-if-branch-global:
-    - match: ^\s*(#\s*endif)\b
-      captures:
-        1: keyword.control.import.c++
-      pop: true
-    - match: \}
-      scope: punctuation.section.block.end.c++
-      set: preprocessor-if-branch-global
-    - include: statements
-
-  preprocessor-elif-else-branch-global:
-    - match: (?=^\s*#\s*(endif)\b)
-      pop: true
-    - include: preprocessor-global
-    - include: negated-block
-    - include: global
-
-  ## Preprocessor for statements
-
-  preprocessor-rule-disabled-statements:
-    - match: ^\s*((#if)\s+(0))\b
-      captures:
-        1: meta.preprocessor.c++
-        2: keyword.control.import.c++
-        3: constant.numeric.preprocessor.c++
-      push:
-        - match: ^\s*(#\s*endif)\b
-          captures:
-            1: meta.preprocessor.c++ keyword.control.import.c++
-          pop: true
-        - match: ^\s*(#\s*else)\b
-          captures:
-            1: meta.preprocessor.c++ keyword.control.import.else.c++
-          push:
-            - match: (?=^\s*#\s*endif\b)
-              pop: true
-            - include: negated-block
-            - include: statements
-        - match: ""
-          push:
-            - meta_scope: comment.block.preprocessor.if-branch.c++
-            - match: (?=^\s*#\s*(else|endif)\b)
-              pop: true
-            - include: scope:source.c#preprocessor-disabled
-
-  preprocessor-rule-enabled-statements:
-    - match: ^\s*((#if)\s+(0*1))\b
-      captures:
-        1: meta.preprocessor.c++
-        2: keyword.control.import.c++
-        3: constant.numeric.preprocessor.c++
-      push:
-        - match: ^\s*(#\s*endif)\b
-          captures:
-            1: meta.preprocessor.c++ keyword.control.import.c++
-          pop: true
-        - match: ^\s*(#\s*else)\b
-          captures:
-            1: meta.preprocessor.c++ keyword.control.import.else.c++
-          push:
-            - meta_content_scope: comment.block.preprocessor.else-branch.c++
-            - match: (?=^\s*#\s*endif\b)
-              pop: true
-            - include: scope:source.c#preprocessor-disabled
-        - match: ""
-          push:
-            - match: (?=^\s*#\s*(else|endif)\b)
-              pop: true
-            - include: negated-block
-            - include: statements
-
-  preprocessor-rule-other-statements:
-    - match: ^\s*(#\s*(?:if|ifdef|ifndef))\b
-      captures:
-        1: keyword.control.import.c++
-      push:
-        - meta_scope: meta.preprocessor.c++
-        - include: scope:source.c#preprocessor-line-continuation
-        - include: scope:source.c#preprocessor-comments
-        - match: \bdefined\b
-          scope: keyword.control.c++
-        # Enter a new scope where all elif/else branches have their
-        # contexts popped by a subsequent elif/else/endif. This ensures that
-        # preprocessor branches don't push multiple meta.block scopes on
-        # the stack, thus messing up the "global" context's detection of
-        # functions.
-        - match: $\n
-          set: preprocessor-if-branch-statements
-
-  # These gymnastics here ensure that we are properly handling scope even
-  # when the preprocessor is used to create different scope beginnings, such
-  # as a different if/while condition
-  preprocessor-if-branch-statements:
-    - match: ^\s*(#\s*endif)\b
-      captures:
-        1: meta.preprocessor.c++ keyword.control.import.c++
-      pop: true
-    - match: (?=^\s*#\s*(elif|else)\b)
-      push: preprocessor-elif-else-branch-statements
-    - match: \{
-      scope: punctuation.section.block.begin.c++
-      set: preprocessor-block-if-branch-statements
-    - match: (?=(?!{{non_func_keywords}}){{path_lookahead}}\s*\()
-      set: preprocessor-if-branch-function-call
-    - include: negated-block
-    - include: statements
-
-  preprocessor-if-branch-function-call:
-    - meta_content_scope: meta.function-call.c++
-    - include: scope:source.c#c99
-    - match: '(?:(::)\s*)?{{identifier}}\s*(::)\s*'
-      scope: variable.function.c++
-      captures:
-        1: punctuation.accessor.c++
-        2: punctuation.accessor.c++
-    - match: '(?:(::)\s*)?{{identifier}}'
-      scope: variable.function.c++
-      captures:
-        1: punctuation.accessor.c++
-    - match: '\('
-      scope: meta.group.c++ punctuation.section.group.begin.c++
-      set: preprocessor-if-branch-function-call-arguments
-
-  preprocessor-if-branch-function-call-arguments:
-    - meta_content_scope: meta.function-call.c++ meta.group.c++
-    - match : \)
-      scope: meta.function-call.c++ meta.group.c++ punctuation.section.group.end.c++
-      set: preprocessor-if-branch-statements
-    - match: ^\s*(#\s*(?:elif|else))\b
-      captures:
-        1: meta.preprocessor.c++ keyword.control.import.c++
-      set: preprocessor-if-branch-statements
-    - match: ^\s*(#\s*endif)\b
-      captures:
-        1: meta.preprocessor.c++ keyword.control.import.c++
-      set: preprocessor-if-branch-function-call-arguments-finish
-    - include: expressions
-
-  preprocessor-if-branch-function-call-arguments-finish:
-    - meta_content_scope: meta.function-call.c++ meta.group.c++
-    - match: \)
-      scope: meta.function-call.c++ meta.group.c++ punctuation.section.group.end.c++
-      pop: true
-    - include: expressions
-
-  preprocessor-block-if-branch-statements:
-    - meta_scope: meta.block.c++
-    - match: ^\s*(#\s*endif)\b
-      captures:
-        1: meta.preprocessor.c++ keyword.control.import.c++
-      set: preprocessor-block-finish-statements
-    - match: (?=^\s*#\s*(elif|else)\b)
-      push: preprocessor-elif-else-branch-statements
-    - match: \}
-      scope: punctuation.section.block.end.c++
-      set: preprocessor-if-branch-statements
-    - include: statements
-
-  preprocessor-block-finish-statements:
-    - meta_scope: meta.block.c++
-    - match: ^\s*(#\s*(?:if|ifdef|ifndef))\b
-      captures:
-        1: meta.preprocessor.c++ keyword.control.import.c++
-      set: preprocessor-block-finish-if-branch-statements
-    - match: \}
-      scope: punctuation.section.block.end.c++
-      pop: true
-    - include: statements
-
-  preprocessor-block-finish-if-branch-statements:
-    - match: ^\s*(#\s*endif)\b
-      captures:
-        1: keyword.control.import.c++
-      pop: true
-    - match: \}
-      scope: meta.block.c++ punctuation.section.block.end.c++
-      set: preprocessor-if-branch-statements
-    - include: statements
-
-  preprocessor-elif-else-branch-statements:
-    - match: (?=^\s*#\s*endif\b)
-      pop: true
-    - include: negated-block
-    - include: statements
-
-  ## Preprocessor other
-
-  negated-block:
-    - match: '\}'
-      scope: punctuation.section.block.end.c++
-      push:
-        - match: '\{'
-          scope: punctuation.section.block.begin.c++
-          pop: true
-        - match: (?=^\s*#\s*(elif|else|endif)\b)
-          pop: true
-        - include: statements
-
-  preprocessor-macro-define:
-    - match: ^\s*(\#\s*define)\b
-      captures:
-        1: meta.preprocessor.macro.c++ keyword.control.import.define.c++
-      push:
-        - meta_content_scope: meta.preprocessor.macro.c++
-        - include: scope:source.c#preprocessor-line-continuation
-        - include: scope:source.c#preprocessor-line-ending
-        - include: scope:source.c#preprocessor-comments
-        - match: '({{identifier}})(?=\()'
-          scope: entity.name.function.preprocessor.c++
-          set:
-            - match: '\('
-              scope: punctuation.section.group.begin.c++
-              set: preprocessor-macro-params
-        - match: '{{identifier}}'
-          scope: entity.name.constant.preprocessor.c++
-          set: preprocessor-macro-definition
-
-  preprocessor-macro-params:
-    - meta_scope: meta.preprocessor.macro.parameters.c++ meta.group.c++
-    - match: '{{identifier}}'
-      scope: variable.parameter.c++
-    - match: \)
-      scope: punctuation.section.group.end.c++
-      set: preprocessor-macro-definition
-    - match: ','
-      scope: punctuation.separator.c++
-      push:
-        - match: '{{identifier}}'
-          scope: variable.parameter.c++
-          pop: true
-        - include: scope:source.c#preprocessor-line-continuation
-        - include: scope:source.c#preprocessor-comments
-        - match: '\.\.\.'
-          scope: keyword.operator.variadic.c++
-        - match: '(?=\))'
-          pop: true
-        - match: (/\*).*(\*/)
-          scope: comment.block.c++
-          captures:
-            1: punctuation.definition.comment.c++
-            2: punctuation.definition.comment.c++
-        - match: '\S+'
-          scope: invalid.illegal.unexpected-character.c++
-    - include: scope:source.c#preprocessor-line-continuation
-    - include: scope:source.c#preprocessor-comments
-    - match: '\.\.\.'
-      scope: keyword.operator.variadic.c++
-    - match: (/\*).*(\*/)
-      scope: comment.block.c++
-      captures:
-        1: punctuation.definition.comment.c++
-        2: punctuation.definition.comment.c++
-    - match: $\n
-      scope: invalid.illegal.unexpected-end-of-line.c++
-
-  preprocessor-macro-definition:
-    - meta_content_scope: meta.preprocessor.macro.c++
-    - include: scope:source.c#preprocessor-line-continuation
-    - include: scope:source.c#preprocessor-line-ending
-    - include: scope:source.c#preprocessor-comments
-    # Don't define blocks in define statements
-    - match: '\{'
-      scope: punctuation.section.block.begin.c++
-    - match: '\}'
-      scope: punctuation.section.block.end.c++
-    - include: expressions
-
-  preprocessor-practical-workarounds:
-    - include: preprocessor-convention-ignore-uppercase-ident-lines
-    - include: scope:source.c#preprocessor-convention-ignore-uppercase-calls-without-semicolon
-
-  preprocessor-convention-ignore-uppercase-ident-lines:
-    - match: ^(\s*{{macro_identifier}})+\s*$
-      scope: meta.assumed-macro.c++
-      push:
-        # It's possible that we are dealing with a function return type on its own line, and the
-        # name of the function is on the subsequent line.
-        - match: '(?={{path_lookahead}}({{generic_lookahead}}({{path_lookahead}})?)\s*\()'
-          set: [function-definition-params, global-function-identifier-generic]
-        - match: '(?={{path_lookahead}}\s*\()'
-          set: [function-definition-params, global-function-identifier]
-        - match: ^
-          pop: true
-
-  preprocessor-other:
-    - match: ^\s*(#\s*(?:if|ifdef|ifndef|elif|else|line|pragma|undef))\b
-      captures:
-        1: keyword.control.import.c++
-      push:
-        - meta_scope: meta.preprocessor.c++
-        - include: scope:source.c#preprocessor-line-continuation
-        - include: scope:source.c#preprocessor-line-ending
-        - include: scope:source.c#preprocessor-comments
-        - match: \bdefined\b
-          scope: keyword.control.c++
-    - match: ^\s*(#\s*endif)\b
-      captures:
-        1: meta.preprocessor.c++ keyword.control.import.c++
-    - match: ^\s*(#\s*(?:error|warning))\b
-      captures:
-        1: keyword.control.import.error.c++
-      push:
-        - meta_scope: meta.preprocessor.diagnostic.c++
-        - include: scope:source.c#preprocessor-line-continuation
-        - include: scope:source.c#preprocessor-line-ending
-        - include: scope:source.c#preprocessor-comments
-        - include: strings
-        - match: '\S+'
-          scope: string.unquoted.c++
-    - match: ^\s*(#\s*(?:include|include_next|import))\b
-      captures:
-        1: keyword.control.import.include.c++
-      push:
-        - meta_scope: meta.preprocessor.include.c++
-        - include: scope:source.c#preprocessor-line-continuation
-        - include: scope:source.c#preprocessor-line-ending
-        - include: scope:source.c#preprocessor-comments
-        - match: '"'
-          scope: punctuation.definition.string.begin.c++
-          push:
-            - meta_scope: string.quoted.double.include.c++
-            - match: '"'
-              scope: punctuation.definition.string.end.c++
-              pop: true
-        - match: <
-          scope: punctuation.definition.string.begin.c++
-          push:
-            - meta_scope: string.quoted.other.lt-gt.include.c++
-            - match: '>'
-              scope: punctuation.definition.string.end.c++
-              pop: true
-    - include: preprocessor-practical-workarounds
diff --git a/Externals/fmt/support/README b/Externals/fmt/support/README
deleted file mode 100755
index 468f5485d9e4..000000000000
--- a/Externals/fmt/support/README
+++ /dev/null
@@ -1,4 +0,0 @@
-This directory contains build support files such as
-
-* CMake modules
-* Build scripts
diff --git a/Externals/fmt/support/Vagrantfile b/Externals/fmt/support/Vagrantfile
deleted file mode 100644
index f6b5f9366259..000000000000
--- a/Externals/fmt/support/Vagrantfile
+++ /dev/null
@@ -1,20 +0,0 @@
-# -*- mode: ruby -*-
-# vi: set ft=ruby :
-
-# A vagrant config for testing against gcc-4.8.
-Vagrant.configure("2") do |config|
-  config.vm.box = "ubuntu/xenial64"
-  config.disksize.size = '15GB'
-
-  config.vm.provider "virtualbox" do |vb|
-    vb.memory = "4096"
-  end
-
-  config.vm.provision "shell", inline: <<-SHELL
-    apt-get update
-    apt-get install -y g++ make wget git
-    wget -q https://github.com/Kitware/CMake/releases/download/v3.14.4/cmake-3.14.4-Linux-x86_64.tar.gz
-    tar xzf cmake-3.14.4-Linux-x86_64.tar.gz
-    ln -s `pwd`/cmake-3.14.4-Linux-x86_64/bin/cmake /usr/local/bin
-  SHELL
-end
diff --git a/Externals/fmt/support/bazel/.bazelrc b/Externals/fmt/support/bazel/.bazelrc
deleted file mode 100644
index 583cbbd220fe..000000000000
--- a/Externals/fmt/support/bazel/.bazelrc
+++ /dev/null
@@ -1 +0,0 @@
-build --symlink_prefix=/ # Out of source build
diff --git a/Externals/fmt/support/bazel/.bazelversion b/Externals/fmt/support/bazel/.bazelversion
deleted file mode 100644
index ac14c3dfaa86..000000000000
--- a/Externals/fmt/support/bazel/.bazelversion
+++ /dev/null
@@ -1 +0,0 @@
-5.1.1
diff --git a/Externals/fmt/support/bazel/BUILD.bazel b/Externals/fmt/support/bazel/BUILD.bazel
deleted file mode 100644
index 085765890261..000000000000
--- a/Externals/fmt/support/bazel/BUILD.bazel
+++ /dev/null
@@ -1,28 +0,0 @@
-cc_library(
-    name = "fmt",
-    srcs = [
-        #"src/fmt.cc", # No C++ module support
-        "src/format.cc",
-        "src/os.cc",
-    ],
-    hdrs = [
-        "include/fmt/args.h",
-        "include/fmt/chrono.h",
-        "include/fmt/color.h",
-        "include/fmt/compile.h",
-        "include/fmt/core.h",
-        "include/fmt/format-inl.h",
-        "include/fmt/format.h",
-        "include/fmt/os.h",
-        "include/fmt/ostream.h",
-        "include/fmt/printf.h",
-        "include/fmt/ranges.h",
-        "include/fmt/std.h",
-        "include/fmt/xchar.h",
-    ],
-    includes = [
-        "include",        
-    ],
-    strip_include_prefix = "include",
-    visibility = ["//visibility:public"],
-)
diff --git a/Externals/fmt/support/bazel/README.md b/Externals/fmt/support/bazel/README.md
deleted file mode 100644
index 44af620c10ee..000000000000
--- a/Externals/fmt/support/bazel/README.md
+++ /dev/null
@@ -1,73 +0,0 @@
-# Bazel support
-
-To get [Bazel](https://bazel.build/) working with {fmt} you can copy the files `BUILD.bazel`, `WORKSPACE.bazel`, `.bazelrc`, and `.bazelversion` from this folder (`support/bazel`) to the root folder of this project. This way {fmt} gets bazelized and can be used with Bazel (e.g. doing a `bazel build //...` on {fmt}). 
-
-## Using {fmt} as a dependency
-
-The following minimal example shows how to use {fmt} as a dependency within a Bazel project.
-
-The following file structure is assumed:
-
-```
-example
-├── BUILD.bazel
-├── main.cpp
-└── WORKSPACE.bazel
-```
-
-*main.cpp*:
-
-```c++
-#include "fmt/core.h"
-
-int main() {
-  fmt::print("The answer is {}\n", 42);
-}
-```
-
-The expected output of this example is `The answer is 42`.
-
-*WORKSPACE.bazel*:
-
-```python
-load("@bazel_tools//tools/build_defs/repo:git.bzl", "git_repository")
-
-git_repository(
-    name = "fmt",
-    branch = "master",
-    remote = "https://github.com/fmtlib/fmt",
-    patch_cmds = [
-        "mv support/bazel/.bazelrc .bazelrc",
-        "mv support/bazel/.bazelversion .bazelversion",
-        "mv support/bazel/BUILD.bazel BUILD.bazel",
-        "mv support/bazel/WORKSPACE.bazel WORKSPACE.bazel",
-    ],
-    # Windows-related patch commands are only needed in the case MSYS2 is not installed.
-    # More details about the installation process of MSYS2 on Windows systems can be found here:
-    # https://docs.bazel.build/versions/main/install-windows.html#installing-compilers-and-language-runtimes
-    # Even if MSYS2 is installed the Windows related patch commands can still be used.
-    patch_cmds_win = [
-        "Move-Item -Path support/bazel/.bazelrc -Destination .bazelrc",
-        "Move-Item -Path support/bazel/.bazelversion -Destination .bazelversion",
-        "Move-Item -Path support/bazel/BUILD.bazel -Destination BUILD.bazel",
-        "Move-Item -Path support/bazel/WORKSPACE.bazel -Destination WORKSPACE.bazel",
-    ],
-)
-```
-
-In the *WORKSPACE* file, the {fmt} GitHub repository is fetched. Using the attribute `patch_cmds` the  files `BUILD.bazel`, `WORKSPACE.bazel`, `.bazelrc`, and `.bazelversion` are moved to the root of the {fmt} repository. This way the {fmt} repository is recognized as a bazelized workspace. 
-
-*BUILD.bazel*:
-
-```python
-cc_binary(
-    name = "Demo",
-    srcs = ["main.cpp"],
-    deps = ["@fmt"],
-)
-```
-
-The *BUILD* file defines a binary named `Demo` that has a dependency to {fmt}.
-
-To execute the binary you can run `bazel run //:Demo`.
-
diff --git a/Externals/fmt/support/bazel/WORKSPACE.bazel b/Externals/fmt/support/bazel/WORKSPACE.bazel
deleted file mode 100644
index 5be77811bd11..000000000000
--- a/Externals/fmt/support/bazel/WORKSPACE.bazel
+++ /dev/null
@@ -1 +0,0 @@
-workspace(name = "fmt")
diff --git a/Externals/fmt/support/build-docs.py b/Externals/fmt/support/build-docs.py
deleted file mode 100644
index f1395cd6cd59..000000000000
--- a/Externals/fmt/support/build-docs.py
+++ /dev/null
@@ -1,58 +0,0 @@
-#!/usr/bin/env python
-# Build the documentation in CI.
-
-from __future__ import print_function
-import errno, os, shutil, subprocess, sys, urllib
-from subprocess import call, check_call, Popen, PIPE, STDOUT
-
-def rmtree_if_exists(dir):
-    try:
-        shutil.rmtree(dir)
-    except OSError as e:
-        if e.errno == errno.ENOENT:
-            pass
-
-# Build the docs.
-fmt_dir = os.path.dirname(os.path.dirname(os.path.realpath(__file__)))
-sys.path.insert(0, os.path.join(fmt_dir, 'doc'))
-import build
-build.create_build_env()
-html_dir = build.build_docs()
-
-repo = 'fmtlib.github.io'
-branch = os.environ['GITHUB_REF']
-is_ci = 'CI' in os.environ
-if is_ci and branch != 'refs/heads/master':
-    print('Branch: ' + branch)
-    exit(0) # Ignore non-master branches
-if is_ci and 'KEY' not in os.environ:
-    # Don't update the repo if building in CI from an account that doesn't have
-    # push access.
-    print('Skipping update of ' + repo)
-    exit(0)
-
-# Clone the fmtlib.github.io repo.
-rmtree_if_exists(repo)
-git_url = 'https://github.com/' if is_ci else 'git@github.com:'
-check_call(['git', 'clone', git_url + 'fmtlib/{}.git'.format(repo)])
-
-# Copy docs to the repo.
-target_dir = os.path.join(repo, 'dev')
-rmtree_if_exists(target_dir)
-shutil.copytree(html_dir, target_dir, ignore=shutil.ignore_patterns('.*'))
-if is_ci:
-    check_call(['git', 'config', '--global', 'user.name', 'fmtbot'])
-    check_call(['git', 'config', '--global', 'user.email', 'viz@fmt.dev'])
-
-# Push docs to GitHub pages.
-check_call(['git', 'add', '--all'], cwd=repo)
-if call(['git', 'diff-index', '--quiet', 'HEAD'], cwd=repo):
-    check_call(['git', 'commit', '-m', 'Update documentation'], cwd=repo)
-    cmd = 'git push'
-    if is_ci:
-        cmd += ' https://$KEY@github.com/fmtlib/fmtlib.github.io.git master'
-    p = Popen(cmd, shell=True, stdout=PIPE, stderr=STDOUT, cwd=repo)
-    # Print the output without the key.
-    print(p.communicate()[0].decode('utf-8').replace(os.environ['KEY'], '$KEY'))
-    if p.returncode != 0:
-        raise subprocess.CalledProcessError(p.returncode, cmd)
diff --git a/Externals/fmt/support/build.gradle b/Externals/fmt/support/build.gradle
deleted file mode 100755
index 8d18da6bc691..000000000000
--- a/Externals/fmt/support/build.gradle
+++ /dev/null
@@ -1,132 +0,0 @@
-import java.nio.file.Paths
-
-// General gradle arguments for root project
-buildscript {    
-    repositories {
-        google()
-        jcenter()
-    }
-    dependencies {
-        //
-        // https://developer.android.com/studio/releases/gradle-plugin#updating-gradle
-        //
-        // Notice that 4.0.0 here is the version of [Android Gradle Plugin]
-        // Accroding to URL above you will need Gradle 6.1 or higher
-        //
-        classpath "com.android.tools.build:gradle:4.1.1"
-    }
-}
-repositories {
-    google()
-    jcenter()
-}
-
-// Project's root where CMakeLists.txt exists: rootDir/support/.cxx -> rootDir
-def rootDir = Paths.get(project.buildDir.getParent()).getParent()
-println("rootDir: ${rootDir}")
-
-// Output: Shared library (.so) for Android 
-apply plugin: "com.android.library"
-android {
-    compileSdkVersion 25    // Android 7.0
-
-    // Target ABI
-    //  - This option controls target platform of module
-    //  - The platform might be limited by compiler's support
-    //    some can work with Clang(default), but some can work only with GCC...
-    //    if bad, both toolchains might not support it
-    splits {
-        abi {
-            enable true
-            // Specify platforms for Application
-            reset()
-            include  "arm64-v8a", "armeabi-v7a", "x86_64"
-        }
-    }
-    ndkVersion "21.3.6528147" // ANDROID_NDK_HOME is deprecated. Be explicit
-
-    defaultConfig {
-        minSdkVersion 21    // Android 5.0+
-        targetSdkVersion 25 // Follow Compile SDK
-        versionCode 34      // Follow release count
-        versionName "7.1.2" // Follow Official version
-        
-        externalNativeBuild {
-            cmake {
-                arguments "-DANDROID_STL=c++_shared"    // Specify Android STL
-                arguments "-DBUILD_SHARED_LIBS=true"    // Build shared object
-                arguments "-DFMT_TEST=false"            // Skip test
-                arguments "-DFMT_DOC=false"             // Skip document
-                cppFlags  "-std=c++17"
-                targets   "fmt"
-            }
-        }
-        println(externalNativeBuild.cmake.cppFlags)
-        println(externalNativeBuild.cmake.arguments)
-    }
-
-    // External Native build
-    //  - Use existing CMakeList.txt
-    //  - Give path to CMake. This gradle file should be 
-    //    neighbor of the top level cmake
-    externalNativeBuild {
-        cmake {
-            version "3.10.0+"
-            path "${rootDir}/CMakeLists.txt"
-            // buildStagingDirectory "./build"  // Custom path for cmake output
-        }
-    }
-    
-    sourceSets{
-        // Android Manifest for Gradle
-        main {
-            manifest.srcFile "AndroidManifest.xml"
-        }
-    }
-
-    // https://developer.android.com/studio/build/native-dependencies#build_system_configuration
-    buildFeatures {
-        prefab true
-        prefabPublishing true
-    }
-    prefab {
-        fmt {
-            headers "${rootDir}/include"
-        }
-    }
-}
-
-assemble.doLast
-{
-    // Instead of `ninja install`, Gradle will deploy the files.
-    // We are doing this since FMT is dependent to the ANDROID_STL after build
-    copy {
-        from "build/intermediates/cmake"
-        into "${rootDir}/libs"
-    }
-    // Copy debug binaries
-    copy {
-        from "${rootDir}/libs/debug/obj"
-        into "${rootDir}/libs/debug"
-    }
-    // Copy Release binaries
-    copy {
-        from "${rootDir}/libs/release/obj"
-        into "${rootDir}/libs/release"
-    }
-    // Remove empty directory
-    delete "${rootDir}/libs/debug/obj"
-    delete "${rootDir}/libs/release/obj"
-
-    // Copy AAR files. Notice that the aar is named after the folder of this script.
-    copy {
-        from "build/outputs/aar/support-release.aar"
-        into "${rootDir}/libs"
-        rename "support-release.aar", "fmt-release.aar"
-    }
-    copy {
-        from "build/outputs/aar/support-debug.aar"
-        into "${rootDir}/libs"
-        rename "support-debug.aar", "fmt-debug.aar"
-    }
-}
diff --git a/Externals/fmt/support/cmake/FindSetEnv.cmake b/Externals/fmt/support/cmake/FindSetEnv.cmake
deleted file mode 100755
index 4e2da5408ac3..000000000000
--- a/Externals/fmt/support/cmake/FindSetEnv.cmake
+++ /dev/null
@@ -1,7 +0,0 @@
-# A CMake script to find SetEnv.cmd.
-
-find_program(WINSDK_SETENV NAMES SetEnv.cmd
-  PATHS "[HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Microsoft SDKs\\Windows;CurrentInstallFolder]/bin")
-if (WINSDK_SETENV AND PRINT_PATH)
-  execute_process(COMMAND ${CMAKE_COMMAND} -E echo "${WINSDK_SETENV}")
-endif ()
diff --git a/Externals/fmt/support/cmake/JoinPaths.cmake b/Externals/fmt/support/cmake/JoinPaths.cmake
deleted file mode 100644
index 32d6d6685c06..000000000000
--- a/Externals/fmt/support/cmake/JoinPaths.cmake
+++ /dev/null
@@ -1,26 +0,0 @@
-# This module provides function for joining paths
-# known from from most languages
-#
-# Original license:
-# SPDX-License-Identifier: (MIT OR CC0-1.0)
-# Explicit permission given to distribute this module under
-# the terms of the project as described in /LICENSE.rst.
-# Copyright 2020 Jan Tojnar
-# https://github.com/jtojnar/cmake-snips
-#
-# Modelled after Python’s os.path.join
-# https://docs.python.org/3.7/library/os.path.html#os.path.join
-# Windows not supported
-function(join_paths joined_path first_path_segment)
-    set(temp_path "${first_path_segment}")
-    foreach(current_segment IN LISTS ARGN)
-        if(NOT ("${current_segment}" STREQUAL ""))
-            if(IS_ABSOLUTE "${current_segment}")
-                set(temp_path "${current_segment}")
-            else()
-                set(temp_path "${temp_path}/${current_segment}")
-            endif()
-        endif()
-    endforeach()
-    set(${joined_path} "${temp_path}" PARENT_SCOPE)
-endfunction()
diff --git a/Externals/fmt/support/cmake/cxx14.cmake b/Externals/fmt/support/cmake/cxx14.cmake
deleted file mode 100755
index deb1e26fb7ba..000000000000
--- a/Externals/fmt/support/cmake/cxx14.cmake
+++ /dev/null
@@ -1,54 +0,0 @@
-# C++14 feature support detection
-
-include(CheckCXXCompilerFlag)
-function (fmt_check_cxx_compiler_flag flag result)
-  if (NOT MSVC)
-    check_cxx_compiler_flag("${flag}" ${result})
-  endif ()
-endfunction ()
-
-if (NOT CMAKE_CXX_STANDARD)
-  set(CMAKE_CXX_STANDARD 11)
-endif()
-message(STATUS "CXX_STANDARD: ${CMAKE_CXX_STANDARD}")
-
-if (CMAKE_CXX_STANDARD EQUAL 20)
-  fmt_check_cxx_compiler_flag(-std=c++20 has_std_20_flag)
-  fmt_check_cxx_compiler_flag(-std=c++2a has_std_2a_flag)
-
-  if (has_std_20_flag)
-    set(CXX_STANDARD_FLAG -std=c++20)
-  elseif (has_std_2a_flag)
-    set(CXX_STANDARD_FLAG -std=c++2a)
-  endif ()
-
-elseif (CMAKE_CXX_STANDARD EQUAL 17)
-  fmt_check_cxx_compiler_flag(-std=c++17 has_std_17_flag)
-  fmt_check_cxx_compiler_flag(-std=c++1z has_std_1z_flag)
-
-  if (has_std_17_flag)
-    set(CXX_STANDARD_FLAG -std=c++17)
-  elseif (has_std_1z_flag)
-    set(CXX_STANDARD_FLAG -std=c++1z)
-  endif ()
-
-elseif (CMAKE_CXX_STANDARD EQUAL 14)
-  fmt_check_cxx_compiler_flag(-std=c++14 has_std_14_flag)
-  fmt_check_cxx_compiler_flag(-std=c++1y has_std_1y_flag)
-
-  if (has_std_14_flag)
-    set(CXX_STANDARD_FLAG -std=c++14)
-  elseif (has_std_1y_flag)
-    set(CXX_STANDARD_FLAG -std=c++1y)
-  endif ()
-
-elseif (CMAKE_CXX_STANDARD EQUAL 11)
-  fmt_check_cxx_compiler_flag(-std=c++11 has_std_11_flag)
-  fmt_check_cxx_compiler_flag(-std=c++0x has_std_0x_flag)
-
-  if (has_std_11_flag)
-    set(CXX_STANDARD_FLAG -std=c++11)
-  elseif (has_std_0x_flag)
-    set(CXX_STANDARD_FLAG -std=c++0x)
-  endif ()
-endif ()
diff --git a/Externals/fmt/support/cmake/fmt-config.cmake.in b/Externals/fmt/support/cmake/fmt-config.cmake.in
deleted file mode 100755
index bc1684f245c4..000000000000
--- a/Externals/fmt/support/cmake/fmt-config.cmake.in
+++ /dev/null
@@ -1,7 +0,0 @@
-@PACKAGE_INIT@
-
-if (NOT TARGET fmt::fmt)
-  include(${CMAKE_CURRENT_LIST_DIR}/@targets_export_name@.cmake)
-endif ()
-
-check_required_components(fmt)
diff --git a/Externals/fmt/support/cmake/fmt.pc.in b/Externals/fmt/support/cmake/fmt.pc.in
deleted file mode 100755
index 29976a8af0b2..000000000000
--- a/Externals/fmt/support/cmake/fmt.pc.in
+++ /dev/null
@@ -1,11 +0,0 @@
-prefix=@CMAKE_INSTALL_PREFIX@
-exec_prefix=@CMAKE_INSTALL_PREFIX@
-libdir=@libdir_for_pc_file@
-includedir=@includedir_for_pc_file@
-
-Name: fmt
-Description: A modern formatting library
-Version: @FMT_VERSION@
-Libs: -L${libdir} -l@FMT_LIB_NAME@
-Cflags: -I${includedir}
-
diff --git a/Externals/fmt/support/compute-powers.py b/Externals/fmt/support/compute-powers.py
deleted file mode 100755
index 601063d4248f..000000000000
--- a/Externals/fmt/support/compute-powers.py
+++ /dev/null
@@ -1,53 +0,0 @@
-#!/usr/bin/env python
-# Compute 10 ** exp with exp in the range [min_exponent, max_exponent] and print
-# normalized (with most-significant bit equal to 1) significands in hexadecimal.
-
-from __future__ import print_function
-
-min_exponent = -348
-max_exponent = 340
-step = 8
-significand_size = 64
-exp_offset = 2000
-
-class fp:
-    pass
-
-powers = []
-for i, exp in enumerate(range(min_exponent, max_exponent + 1, step)):
-    result = fp()
-    n = 10 ** exp if exp >= 0 else 2 ** exp_offset / 10 ** -exp
-    k = significand_size + 1
-    # Convert to binary and round.
-    binary = '{:b}'.format(n)
-    result.f = (int('{:0<{}}'.format(binary[:k], k), 2) + 1) / 2
-    result.e = len(binary) - (exp_offset if exp < 0 else 0) - significand_size
-    powers.append(result)
-    # Sanity check.
-    exp_offset10 = 400
-    actual = result.f * 10 ** exp_offset10
-    if result.e > 0:
-        actual *= 2 ** result.e
-    else:
-        for j in range(-result.e):
-            actual /= 2
-    expected = 10 ** (exp_offset10 + exp)
-    precision = len('{}'.format(expected)) - len('{}'.format(actual - expected))
-    if precision < 19:
-        print('low precision:', precision)
-        exit(1)
-
-print('Significands:', end='')
-for i, fp in enumerate(powers):
-    if i % 3 == 0:
-        print(end='\n ')
-    print(' {:0<#16x}'.format(fp.f, ), end=',')
-
-print('\n\nExponents:', end='')
-for i, fp in enumerate(powers):
-    if i % 11 == 0:
-        print(end='\n ')
-    print(' {:5}'.format(fp.e), end=',')
-
-print('\n\nMax exponent difference:',
-      max([x.e - powers[i - 1].e for i, x in enumerate(powers)][1:]))
diff --git a/Externals/fmt/support/docopt.py b/Externals/fmt/support/docopt.py
deleted file mode 100755
index 2e43f7cef819..000000000000
--- a/Externals/fmt/support/docopt.py
+++ /dev/null
@@ -1,581 +0,0 @@
-"""Pythonic command-line interface parser that will make you smile.
-
- * http://docopt.org
- * Repository and issue-tracker: https://github.com/docopt/docopt
- * Licensed under terms of MIT license (see LICENSE-MIT)
- * Copyright (c) 2013 Vladimir Keleshev, vladimir@keleshev.com
-
-"""
-import sys
-import re
-
-
-__all__ = ['docopt']
-__version__ = '0.6.1'
-
-
-class DocoptLanguageError(Exception):
-
-    """Error in construction of usage-message by developer."""
-
-
-class DocoptExit(SystemExit):
-
-    """Exit in case user invoked program with incorrect arguments."""
-
-    usage = ''
-
-    def __init__(self, message=''):
-        SystemExit.__init__(self, (message + '\n' + self.usage).strip())
-
-
-class Pattern(object):
-
-    def __eq__(self, other):
-        return repr(self) == repr(other)
-
-    def __hash__(self):
-        return hash(repr(self))
-
-    def fix(self):
-        self.fix_identities()
-        self.fix_repeating_arguments()
-        return self
-
-    def fix_identities(self, uniq=None):
-        """Make pattern-tree tips point to same object if they are equal."""
-        if not hasattr(self, 'children'):
-            return self
-        uniq = list(set(self.flat())) if uniq is None else uniq
-        for i, child in enumerate(self.children):
-            if not hasattr(child, 'children'):
-                assert child in uniq
-                self.children[i] = uniq[uniq.index(child)]
-            else:
-                child.fix_identities(uniq)
-
-    def fix_repeating_arguments(self):
-        """Fix elements that should accumulate/increment values."""
-        either = [list(child.children) for child in transform(self).children]
-        for case in either:
-            for e in [child for child in case if case.count(child) > 1]:
-                if type(e) is Argument or type(e) is Option and e.argcount:
-                    if e.value is None:
-                        e.value = []
-                    elif type(e.value) is not list:
-                        e.value = e.value.split()
-                if type(e) is Command or type(e) is Option and e.argcount == 0:
-                    e.value = 0
-        return self
-
-
-def transform(pattern):
-    """Expand pattern into an (almost) equivalent one, but with single Either.
-
-    Example: ((-a | -b) (-c | -d)) => (-a -c | -a -d | -b -c | -b -d)
-    Quirks: [-a] => (-a), (-a...) => (-a -a)
-
-    """
-    result = []
-    groups = [[pattern]]
-    while groups:
-        children = groups.pop(0)
-        parents = [Required, Optional, OptionsShortcut, Either, OneOrMore]
-        if any(t in map(type, children) for t in parents):
-            child = [c for c in children if type(c) in parents][0]
-            children.remove(child)
-            if type(child) is Either:
-                for c in child.children:
-                    groups.append([c] + children)
-            elif type(child) is OneOrMore:
-                groups.append(child.children * 2 + children)
-            else:
-                groups.append(child.children + children)
-        else:
-            result.append(children)
-    return Either(*[Required(*e) for e in result])
-
-
-class LeafPattern(Pattern):
-
-    """Leaf/terminal node of a pattern tree."""
-
-    def __init__(self, name, value=None):
-        self.name, self.value = name, value
-
-    def __repr__(self):
-        return '%s(%r, %r)' % (self.__class__.__name__, self.name, self.value)
-
-    def flat(self, *types):
-        return [self] if not types or type(self) in types else []
-
-    def match(self, left, collected=None):
-        collected = [] if collected is None else collected
-        pos, match = self.single_match(left)
-        if match is None:
-            return False, left, collected
-        left_ = left[:pos] + left[pos + 1:]
-        same_name = [a for a in collected if a.name == self.name]
-        if type(self.value) in (int, list):
-            if type(self.value) is int:
-                increment = 1
-            else:
-                increment = ([match.value] if type(match.value) is str
-                             else match.value)
-            if not same_name:
-                match.value = increment
-                return True, left_, collected + [match]
-            same_name[0].value += increment
-            return True, left_, collected
-        return True, left_, collected + [match]
-
-
-class BranchPattern(Pattern):
-
-    """Branch/inner node of a pattern tree."""
-
-    def __init__(self, *children):
-        self.children = list(children)
-
-    def __repr__(self):
-        return '%s(%s)' % (self.__class__.__name__,
-                           ', '.join(repr(a) for a in self.children))
-
-    def flat(self, *types):
-        if type(self) in types:
-            return [self]
-        return sum([child.flat(*types) for child in self.children], [])
-
-
-class Argument(LeafPattern):
-
-    def single_match(self, left):
-        for n, pattern in enumerate(left):
-            if type(pattern) is Argument:
-                return n, Argument(self.name, pattern.value)
-        return None, None
-
-    @classmethod
-    def parse(class_, source):
-        name = re.findall('(<\S*?>)', source)[0]
-        value = re.findall('\[default: (.*)\]', source, flags=re.I)
-        return class_(name, value[0] if value else None)
-
-
-class Command(Argument):
-
-    def __init__(self, name, value=False):
-        self.name, self.value = name, value
-
-    def single_match(self, left):
-        for n, pattern in enumerate(left):
-            if type(pattern) is Argument:
-                if pattern.value == self.name:
-                    return n, Command(self.name, True)
-                else:
-                    break
-        return None, None
-
-
-class Option(LeafPattern):
-
-    def __init__(self, short=None, long=None, argcount=0, value=False):
-        assert argcount in (0, 1)
-        self.short, self.long, self.argcount = short, long, argcount
-        self.value = None if value is False and argcount else value
-
-    @classmethod
-    def parse(class_, option_description):
-        short, long, argcount, value = None, None, 0, False
-        options, _, description = option_description.strip().partition('  ')
-        options = options.replace(',', ' ').replace('=', ' ')
-        for s in options.split():
-            if s.startswith('--'):
-                long = s
-            elif s.startswith('-'):
-                short = s
-            else:
-                argcount = 1
-        if argcount:
-            matched = re.findall('\[default: (.*)\]', description, flags=re.I)
-            value = matched[0] if matched else None
-        return class_(short, long, argcount, value)
-
-    def single_match(self, left):
-        for n, pattern in enumerate(left):
-            if self.name == pattern.name:
-                return n, pattern
-        return None, None
-
-    @property
-    def name(self):
-        return self.long or self.short
-
-    def __repr__(self):
-        return 'Option(%r, %r, %r, %r)' % (self.short, self.long,
-                                           self.argcount, self.value)
-
-
-class Required(BranchPattern):
-
-    def match(self, left, collected=None):
-        collected = [] if collected is None else collected
-        l = left
-        c = collected
-        for pattern in self.children:
-            matched, l, c = pattern.match(l, c)
-            if not matched:
-                return False, left, collected
-        return True, l, c
-
-
-class Optional(BranchPattern):
-
-    def match(self, left, collected=None):
-        collected = [] if collected is None else collected
-        for pattern in self.children:
-            m, left, collected = pattern.match(left, collected)
-        return True, left, collected
-
-
-class OptionsShortcut(Optional):
-
-    """Marker/placeholder for [options] shortcut."""
-
-
-class OneOrMore(BranchPattern):
-
-    def match(self, left, collected=None):
-        assert len(self.children) == 1
-        collected = [] if collected is None else collected
-        l = left
-        c = collected
-        l_ = None
-        matched = True
-        times = 0
-        while matched:
-            # could it be that something didn't match but changed l or c?
-            matched, l, c = self.children[0].match(l, c)
-            times += 1 if matched else 0
-            if l_ == l:
-                break
-            l_ = l
-        if times >= 1:
-            return True, l, c
-        return False, left, collected
-
-
-class Either(BranchPattern):
-
-    def match(self, left, collected=None):
-        collected = [] if collected is None else collected
-        outcomes = []
-        for pattern in self.children:
-            matched, _, _ = outcome = pattern.match(left, collected)
-            if matched:
-                outcomes.append(outcome)
-        if outcomes:
-            return min(outcomes, key=lambda outcome: len(outcome[1]))
-        return False, left, collected
-
-
-class Tokens(list):
-
-    def __init__(self, source, error=DocoptExit):
-        self += source.split() if hasattr(source, 'split') else source
-        self.error = error
-
-    @staticmethod
-    def from_pattern(source):
-        source = re.sub(r'([\[\]\(\)\|]|\.\.\.)', r' \1 ', source)
-        source = [s for s in re.split('\s+|(\S*<.*?>)', source) if s]
-        return Tokens(source, error=DocoptLanguageError)
-
-    def move(self):
-        return self.pop(0) if len(self) else None
-
-    def current(self):
-        return self[0] if len(self) else None
-
-
-def parse_long(tokens, options):
-    """long ::= '--' chars [ ( ' ' | '=' ) chars ] ;"""
-    long, eq, value = tokens.move().partition('=')
-    assert long.startswith('--')
-    value = None if eq == value == '' else value
-    similar = [o for o in options if o.long == long]
-    if tokens.error is DocoptExit and similar == []:  # if no exact match
-        similar = [o for o in options if o.long and o.long.startswith(long)]
-    if len(similar) > 1:  # might be simply specified ambiguously 2+ times?
-        raise tokens.error('%s is not a unique prefix: %s?' %
-                           (long, ', '.join(o.long for o in similar)))
-    elif len(similar) < 1:
-        argcount = 1 if eq == '=' else 0
-        o = Option(None, long, argcount)
-        options.append(o)
-        if tokens.error is DocoptExit:
-            o = Option(None, long, argcount, value if argcount else True)
-    else:
-        o = Option(similar[0].short, similar[0].long,
-                   similar[0].argcount, similar[0].value)
-        if o.argcount == 0:
-            if value is not None:
-                raise tokens.error('%s must not have an argument' % o.long)
-        else:
-            if value is None:
-                if tokens.current() in [None, '--']:
-                    raise tokens.error('%s requires argument' % o.long)
-                value = tokens.move()
-        if tokens.error is DocoptExit:
-            o.value = value if value is not None else True
-    return [o]
-
-
-def parse_shorts(tokens, options):
-    """shorts ::= '-' ( chars )* [ [ ' ' ] chars ] ;"""
-    token = tokens.move()
-    assert token.startswith('-') and not token.startswith('--')
-    left = token.lstrip('-')
-    parsed = []
-    while left != '':
-        short, left = '-' + left[0], left[1:]
-        similar = [o for o in options if o.short == short]
-        if len(similar) > 1:
-            raise tokens.error('%s is specified ambiguously %d times' %
-                               (short, len(similar)))
-        elif len(similar) < 1:
-            o = Option(short, None, 0)
-            options.append(o)
-            if tokens.error is DocoptExit:
-                o = Option(short, None, 0, True)
-        else:  # why copying is necessary here?
-            o = Option(short, similar[0].long,
-                       similar[0].argcount, similar[0].value)
-            value = None
-            if o.argcount != 0:
-                if left == '':
-                    if tokens.current() in [None, '--']:
-                        raise tokens.error('%s requires argument' % short)
-                    value = tokens.move()
-                else:
-                    value = left
-                    left = ''
-            if tokens.error is DocoptExit:
-                o.value = value if value is not None else True
-        parsed.append(o)
-    return parsed
-
-
-def parse_pattern(source, options):
-    tokens = Tokens.from_pattern(source)
-    result = parse_expr(tokens, options)
-    if tokens.current() is not None:
-        raise tokens.error('unexpected ending: %r' % ' '.join(tokens))
-    return Required(*result)
-
-
-def parse_expr(tokens, options):
-    """expr ::= seq ( '|' seq )* ;"""
-    seq = parse_seq(tokens, options)
-    if tokens.current() != '|':
-        return seq
-    result = [Required(*seq)] if len(seq) > 1 else seq
-    while tokens.current() == '|':
-        tokens.move()
-        seq = parse_seq(tokens, options)
-        result += [Required(*seq)] if len(seq) > 1 else seq
-    return [Either(*result)] if len(result) > 1 else result
-
-
-def parse_seq(tokens, options):
-    """seq ::= ( atom [ '...' ] )* ;"""
-    result = []
-    while tokens.current() not in [None, ']', ')', '|']:
-        atom = parse_atom(tokens, options)
-        if tokens.current() == '...':
-            atom = [OneOrMore(*atom)]
-            tokens.move()
-        result += atom
-    return result
-
-
-def parse_atom(tokens, options):
-    """atom ::= '(' expr ')' | '[' expr ']' | 'options'
-             | long | shorts | argument | command ;
-    """
-    token = tokens.current()
-    result = []
-    if token in '([':
-        tokens.move()
-        matching, pattern = {'(': [')', Required], '[': [']', Optional]}[token]
-        result = pattern(*parse_expr(tokens, options))
-        if tokens.move() != matching:
-            raise tokens.error("unmatched '%s'" % token)
-        return [result]
-    elif token == 'options':
-        tokens.move()
-        return [OptionsShortcut()]
-    elif token.startswith('--') and token != '--':
-        return parse_long(tokens, options)
-    elif token.startswith('-') and token not in ('-', '--'):
-        return parse_shorts(tokens, options)
-    elif token.startswith('<') and token.endswith('>') or token.isupper():
-        return [Argument(tokens.move())]
-    else:
-        return [Command(tokens.move())]
-
-
-def parse_argv(tokens, options, options_first=False):
-    """Parse command-line argument vector.
-
-    If options_first:
-        argv ::= [ long | shorts ]* [ argument ]* [ '--' [ argument ]* ] ;
-    else:
-        argv ::= [ long | shorts | argument ]* [ '--' [ argument ]* ] ;
-
-    """
-    parsed = []
-    while tokens.current() is not None:
-        if tokens.current() == '--':
-            return parsed + [Argument(None, v) for v in tokens]
-        elif tokens.current().startswith('--'):
-            parsed += parse_long(tokens, options)
-        elif tokens.current().startswith('-') and tokens.current() != '-':
-            parsed += parse_shorts(tokens, options)
-        elif options_first:
-            return parsed + [Argument(None, v) for v in tokens]
-        else:
-            parsed.append(Argument(None, tokens.move()))
-    return parsed
-
-
-def parse_defaults(doc):
-    defaults = []
-    for s in parse_section('options:', doc):
-        # FIXME corner case "bla: options: --foo"
-        _, _, s = s.partition(':')  # get rid of "options:"
-        split = re.split('\n[ \t]*(-\S+?)', '\n' + s)[1:]
-        split = [s1 + s2 for s1, s2 in zip(split[::2], split[1::2])]
-        options = [Option.parse(s) for s in split if s.startswith('-')]
-        defaults += options
-    return defaults
-
-
-def parse_section(name, source):
-    pattern = re.compile('^([^\n]*' + name + '[^\n]*\n?(?:[ \t].*?(?:\n|$))*)',
-                         re.IGNORECASE | re.MULTILINE)
-    return [s.strip() for s in pattern.findall(source)]
-
-
-def formal_usage(section):
-    _, _, section = section.partition(':')  # drop "usage:"
-    pu = section.split()
-    return '( ' + ' '.join(') | (' if s == pu[0] else s for s in pu[1:]) + ' )'
-
-
-def extras(help, version, options, doc):
-    if help and any((o.name in ('-h', '--help')) and o.value for o in options):
-        print(doc.strip("\n"))
-        sys.exit()
-    if version and any(o.name == '--version' and o.value for o in options):
-        print(version)
-        sys.exit()
-
-
-class Dict(dict):
-    def __repr__(self):
-        return '{%s}' % ',\n '.join('%r: %r' % i for i in sorted(self.items()))
-
-
-def docopt(doc, argv=None, help=True, version=None, options_first=False):
-    """Parse `argv` based on command-line interface described in `doc`.
-
-    `docopt` creates your command-line interface based on its
-    description that you pass as `doc`. Such description can contain
-    --options, <positional-argument>, commands, which could be
-    [optional], (required), (mutually | exclusive) or repeated...
-
-    Parameters
-    ----------
-    doc : str
-        Description of your command-line interface.
-    argv : list of str, optional
-        Argument vector to be parsed. sys.argv[1:] is used if not
-        provided.
-    help : bool (default: True)
-        Set to False to disable automatic help on -h or --help
-        options.
-    version : any object
-        If passed, the object will be printed if --version is in
-        `argv`.
-    options_first : bool (default: False)
-        Set to True to require options precede positional arguments,
-        i.e. to forbid options and positional arguments intermix.
-
-    Returns
-    -------
-    args : dict
-        A dictionary, where keys are names of command-line elements
-        such as e.g. "--verbose" and "<path>", and values are the
-        parsed values of those elements.
-
-    Example
-    -------
-    >>> from docopt import docopt
-    >>> doc = '''
-    ... Usage:
-    ...     my_program tcp <host> <port> [--timeout=<seconds>]
-    ...     my_program serial <port> [--baud=<n>] [--timeout=<seconds>]
-    ...     my_program (-h | --help | --version)
-    ...
-    ... Options:
-    ...     -h, --help  Show this screen and exit.
-    ...     --baud=<n>  Baudrate [default: 9600]
-    ... '''
-    >>> argv = ['tcp', '127.0.0.1', '80', '--timeout', '30']
-    >>> docopt(doc, argv)
-    {'--baud': '9600',
-     '--help': False,
-     '--timeout': '30',
-     '--version': False,
-     '<host>': '127.0.0.1',
-     '<port>': '80',
-     'serial': False,
-     'tcp': True}
-
-    See also
-    --------
-    * For video introduction see http://docopt.org
-    * Full documentation is available in README.rst as well as online
-      at https://github.com/docopt/docopt#readme
-
-    """
-    argv = sys.argv[1:] if argv is None else argv
-
-    usage_sections = parse_section('usage:', doc)
-    if len(usage_sections) == 0:
-        raise DocoptLanguageError('"usage:" (case-insensitive) not found.')
-    if len(usage_sections) > 1:
-        raise DocoptLanguageError('More than one "usage:" (case-insensitive).')
-    DocoptExit.usage = usage_sections[0]
-
-    options = parse_defaults(doc)
-    pattern = parse_pattern(formal_usage(DocoptExit.usage), options)
-    # [default] syntax for argument is disabled
-    #for a in pattern.flat(Argument):
-    #    same_name = [d for d in arguments if d.name == a.name]
-    #    if same_name:
-    #        a.value = same_name[0].value
-    argv = parse_argv(Tokens(argv), list(options), options_first)
-    pattern_options = set(pattern.flat(Option))
-    for options_shortcut in pattern.flat(OptionsShortcut):
-        doc_options = parse_defaults(doc)
-        options_shortcut.children = list(set(doc_options) - pattern_options)
-        #if any_options:
-        #    options_shortcut.children += [Option(o.short, o.long, o.argcount)
-        #                    for o in argv if type(o) is Option]
-    extras(help, version, argv, doc)
-    matched, left, collected = pattern.fix().match(argv)
-    if matched and left == []:  # better error message if left?
-        return Dict((a.name, a.value) for a in (pattern.flat() + collected))
-    raise DocoptExit()
diff --git a/Externals/fmt/support/manage.py b/Externals/fmt/support/manage.py
deleted file mode 100755
index d2afcee92de5..000000000000
--- a/Externals/fmt/support/manage.py
+++ /dev/null
@@ -1,303 +0,0 @@
-#!/usr/bin/env python3
-
-"""Manage site and releases.
-
-Usage:
-  manage.py release [<branch>]
-  manage.py site
-
-For the release command $FMT_TOKEN should contain a GitHub personal access token
-obtained from https://github.com/settings/tokens.
-"""
-
-from __future__ import print_function
-import datetime, docopt, errno, fileinput, json, os
-import re, requests, shutil, sys, tempfile
-from contextlib import contextmanager
-from distutils.version import LooseVersion
-from subprocess import check_call
-
-
-class Git:
-    def __init__(self, dir):
-        self.dir = dir
-
-    def call(self, method, args, **kwargs):
-        return check_call(['git', method] + list(args), **kwargs)
-
-    def add(self, *args):
-        return self.call('add', args, cwd=self.dir)
-
-    def checkout(self, *args):
-        return self.call('checkout', args, cwd=self.dir)
-
-    def clean(self, *args):
-        return self.call('clean', args, cwd=self.dir)
-
-    def clone(self, *args):
-        return self.call('clone', list(args) + [self.dir])
-
-    def commit(self, *args):
-        return self.call('commit', args, cwd=self.dir)
-
-    def pull(self, *args):
-        return self.call('pull', args, cwd=self.dir)
-
-    def push(self, *args):
-        return self.call('push', args, cwd=self.dir)
-
-    def reset(self, *args):
-        return self.call('reset', args, cwd=self.dir)
-
-    def update(self, *args):
-        clone = not os.path.exists(self.dir)
-        if clone:
-            self.clone(*args)
-        return clone
-
-
-def clean_checkout(repo, branch):
-    repo.clean('-f', '-d')
-    repo.reset('--hard')
-    repo.checkout(branch)
-
-
-class Runner:
-    def __init__(self, cwd):
-        self.cwd = cwd
-
-    def __call__(self, *args, **kwargs):
-        kwargs['cwd'] = kwargs.get('cwd', self.cwd)
-        check_call(args, **kwargs)
-
-
-def create_build_env():
-    """Create a build environment."""
-    class Env:
-        pass
-    env = Env()
-
-    # Import the documentation build module.
-    env.fmt_dir = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))
-    sys.path.insert(0, os.path.join(env.fmt_dir, 'doc'))
-    import build
-
-    env.build_dir = 'build'
-    env.versions = build.versions
-
-    # Virtualenv and repos are cached to speed up builds.
-    build.create_build_env(os.path.join(env.build_dir, 'virtualenv'))
-
-    env.fmt_repo = Git(os.path.join(env.build_dir, 'fmt'))
-    return env
-
-
-@contextmanager
-def rewrite(filename):
-    class Buffer:
-        pass
-    buffer = Buffer()
-    if not os.path.exists(filename):
-        buffer.data = ''
-        yield buffer
-        return
-    with open(filename) as f:
-        buffer.data = f.read()
-    yield buffer
-    with open(filename, 'w') as f:
-        f.write(buffer.data)
-
-
-fmt_repo_url = 'git@github.com:fmtlib/fmt'
-
-
-def update_site(env):
-    env.fmt_repo.update(fmt_repo_url)
-
-    doc_repo = Git(os.path.join(env.build_dir, 'fmtlib.github.io'))
-    doc_repo.update('git@github.com:fmtlib/fmtlib.github.io')
-
-    for version in env.versions:
-        clean_checkout(env.fmt_repo, version)
-        target_doc_dir = os.path.join(env.fmt_repo.dir, 'doc')
-        # Remove the old theme.
-        for entry in os.listdir(target_doc_dir):
-            path = os.path.join(target_doc_dir, entry)
-            if os.path.isdir(path):
-                shutil.rmtree(path)
-        # Copy the new theme.
-        for entry in ['_static', '_templates', 'basic-bootstrap', 'bootstrap',
-                      'conf.py', 'fmt.less']:
-            src = os.path.join(env.fmt_dir, 'doc', entry)
-            dst = os.path.join(target_doc_dir, entry)
-            copy = shutil.copytree if os.path.isdir(src) else shutil.copyfile
-            copy(src, dst)
-        # Rename index to contents.
-        contents = os.path.join(target_doc_dir, 'contents.rst')
-        if not os.path.exists(contents):
-            os.rename(os.path.join(target_doc_dir, 'index.rst'), contents)
-        # Fix issues in reference.rst/api.rst.
-        for filename in ['reference.rst', 'api.rst', 'index.rst']:
-            pattern = re.compile('doxygenfunction.. (bin|oct|hexu|hex)$', re.M)
-            with rewrite(os.path.join(target_doc_dir, filename)) as b:
-                b.data = b.data.replace('std::ostream &', 'std::ostream&')
-                b.data = re.sub(pattern, r'doxygenfunction:: \1(int)', b.data)
-                b.data = b.data.replace('std::FILE*', 'std::FILE *')
-                b.data = b.data.replace('unsigned int', 'unsigned')
-                #b.data = b.data.replace('operator""_', 'operator"" _')
-                b.data = b.data.replace(
-                    'format_to_n(OutputIt, size_t, string_view, Args&&',
-                    'format_to_n(OutputIt, size_t, const S&, const Args&')
-                b.data = b.data.replace(
-                    'format_to_n(OutputIt, std::size_t, string_view, Args&&',
-                    'format_to_n(OutputIt, std::size_t, const S&, const Args&')
-                if version == ('3.0.2'):
-                    b.data = b.data.replace(
-                        'fprintf(std::ostream&', 'fprintf(std::ostream &')
-                if version == ('5.3.0'):
-                    b.data = b.data.replace(
-                        'format_to(OutputIt, const S&, const Args&...)',
-                        'format_to(OutputIt, const S &, const Args &...)')
-                if version.startswith('5.') or version.startswith('6.'):
-                    b.data = b.data.replace(', size_t', ', std::size_t')
-                if version.startswith('7.'):
-                    b.data = b.data.replace(', std::size_t', ', size_t')
-                    b.data = b.data.replace('join(It, It', 'join(It, Sentinel')
-                if version.startswith('7.1.'):
-                    b.data = b.data.replace(', std::size_t', ', size_t')
-                    b.data = b.data.replace('join(It, It', 'join(It, Sentinel')
-                    b.data = b.data.replace(
-                        'fmt::format_to(OutputIt, const S&, Args&&...)',
-                        'fmt::format_to(OutputIt, const S&, Args&&...) -> ' +
-                        'typename std::enable_if<enable, OutputIt>::type')
-                b.data = b.data.replace('aa long', 'a long')
-                b.data = b.data.replace('serveral', 'several')
-                if version.startswith('6.2.'):
-                    b.data = b.data.replace(
-                        'vformat(const S&, basic_format_args<' +
-                        'buffer_context<Char>>)',
-                        'vformat(const S&, basic_format_args<' +
-                        'buffer_context<type_identity_t<Char>>>)')
-        # Fix a broken link in index.rst.
-        index = os.path.join(target_doc_dir, 'index.rst')
-        with rewrite(index) as b:
-            b.data = b.data.replace(
-                'doc/latest/index.html#format-string-syntax', 'syntax.html')
-        # Fix issues in syntax.rst.
-        index = os.path.join(target_doc_dir, 'syntax.rst')
-        with rewrite(index) as b:
-            b.data = b.data.replace(
-                '..productionlist:: sf\n', '.. productionlist:: sf\n ')
-            b.data = b.data.replace('Examples:\n', 'Examples::\n')
-        # Build the docs.
-        html_dir = os.path.join(env.build_dir, 'html')
-        if os.path.exists(html_dir):
-            shutil.rmtree(html_dir)
-        include_dir = env.fmt_repo.dir
-        if LooseVersion(version) >= LooseVersion('5.0.0'):
-            include_dir = os.path.join(include_dir, 'include', 'fmt')
-        elif LooseVersion(version) >= LooseVersion('3.0.0'):
-            include_dir = os.path.join(include_dir, 'fmt')
-        import build
-        build.build_docs(version, doc_dir=target_doc_dir,
-                         include_dir=include_dir, work_dir=env.build_dir)
-        shutil.rmtree(os.path.join(html_dir, '.doctrees'))
-        # Create symlinks for older versions.
-        for link, target in {'index': 'contents', 'api': 'reference'}.items():
-            link = os.path.join(html_dir, link) + '.html'
-            target += '.html'
-            if os.path.exists(os.path.join(html_dir, target)) and \
-               not os.path.exists(link):
-                os.symlink(target, link)
-        # Copy docs to the website.
-        version_doc_dir = os.path.join(doc_repo.dir, version)
-        try:
-            shutil.rmtree(version_doc_dir)
-        except OSError as e:
-            if e.errno != errno.ENOENT:
-                raise
-        shutil.move(html_dir, version_doc_dir)
-
-
-def release(args):
-    env = create_build_env()
-    fmt_repo = env.fmt_repo
-
-    branch = args.get('<branch>')
-    if branch is None:
-        branch = 'master'
-    if not fmt_repo.update('-b', branch, fmt_repo_url):
-        clean_checkout(fmt_repo, branch)
-
-    # Convert changelog from RST to GitHub-flavored Markdown and get the
-    # version.
-    changelog = 'ChangeLog.rst'
-    changelog_path = os.path.join(fmt_repo.dir, changelog)
-    import rst2md
-    changes, version = rst2md.convert(changelog_path)
-    cmakelists = 'CMakeLists.txt'
-    for line in fileinput.input(os.path.join(fmt_repo.dir, cmakelists),
-                                inplace=True):
-        prefix = 'set(FMT_VERSION '
-        if line.startswith(prefix):
-            line = prefix + version + ')\n'
-        sys.stdout.write(line)
-
-    # Update the version in the changelog.
-    title_len = 0
-    for line in fileinput.input(changelog_path, inplace=True):
-        if line.startswith(version + ' - TBD'):
-            line = version + ' - ' + datetime.date.today().isoformat()
-            title_len = len(line)
-            line += '\n'
-        elif title_len:
-            line = '-' * title_len + '\n'
-            title_len = 0
-        sys.stdout.write(line)
-
-    # Add the version to the build script.
-    script = os.path.join('doc', 'build.py')
-    script_path = os.path.join(fmt_repo.dir, script)
-    for line in fileinput.input(script_path, inplace=True):
-      m = re.match(r'( *versions = )\[(.+)\]', line)
-      if m:
-        line = '{}[{}, \'{}\']\n'.format(m.group(1), m.group(2), version)
-      sys.stdout.write(line)
-
-    fmt_repo.checkout('-B', 'release')
-    fmt_repo.add(changelog, cmakelists, script)
-    fmt_repo.commit('-m', 'Update version')
-
-    # Build the docs and package.
-    run = Runner(fmt_repo.dir)
-    run('cmake', '.')
-    run('make', 'doc', 'package_source')
-    update_site(env)
-
-    # Create a release on GitHub.
-    fmt_repo.push('origin', 'release')
-    auth_headers = {'Authorization': 'token ' + os.getenv('FMT_TOKEN')}
-    r = requests.post('https://api.github.com/repos/fmtlib/fmt/releases',
-                      headers=auth_headers,
-                      data=json.dumps({'tag_name': version,
-                                       'target_commitish': 'release',
-                                       'body': changes, 'draft': True}))
-    if r.status_code != 201:
-        raise Exception('Failed to create a release ' + str(r))
-    id = r.json()['id']
-    uploads_url = 'https://uploads.github.com/repos/fmtlib/fmt/releases'
-    package = 'fmt-{}.zip'.format(version)
-    r = requests.post(
-        '{}/{}/assets?name={}'.format(uploads_url, id, package),
-        headers={'Content-Type': 'application/zip'} | auth_headers,
-        data=open('build/fmt/' + package, 'rb'))
-    if r.status_code != 201:
-        raise Exception('Failed to upload an asset ' + str(r))
-
-
-if __name__ == '__main__':
-    args = docopt.docopt(__doc__)
-    if args.get('release'):
-        release(args)
-    elif args.get('site'):
-        update_site(create_build_env())
diff --git a/Externals/fmt/support/printable.py b/Externals/fmt/support/printable.py
deleted file mode 100644
index 8fa86b30017a..000000000000
--- a/Externals/fmt/support/printable.py
+++ /dev/null
@@ -1,201 +0,0 @@
-#!/usr/bin/env python3
-
-# This script is based on
-# https://github.com/rust-lang/rust/blob/master/library/core/src/unicode/printable.py
-# distributed under https://github.com/rust-lang/rust/blob/master/LICENSE-MIT.
-
-# This script uses the following Unicode tables:
-# - UnicodeData.txt
-
-
-from collections import namedtuple
-import csv
-import os
-import subprocess
-
-NUM_CODEPOINTS=0x110000
-
-def to_ranges(iter):
-    current = None
-    for i in iter:
-        if current is None or i != current[1] or i in (0x10000, 0x20000):
-            if current is not None:
-                yield tuple(current)
-            current = [i, i + 1]
-        else:
-            current[1] += 1
-    if current is not None:
-        yield tuple(current)
-
-def get_escaped(codepoints):
-    for c in codepoints:
-        if (c.class_ or "Cn") in "Cc Cf Cs Co Cn Zl Zp Zs".split() and c.value != ord(' '):
-            yield c.value
-
-def get_file(f):
-    try:
-        return open(os.path.basename(f))
-    except FileNotFoundError:
-        subprocess.run(["curl", "-O", f], check=True)
-        return open(os.path.basename(f))
-
-Codepoint = namedtuple('Codepoint', 'value class_')
-
-def get_codepoints(f):
-    r = csv.reader(f, delimiter=";")
-    prev_codepoint = 0
-    class_first = None
-    for row in r:
-        codepoint = int(row[0], 16)
-        name = row[1]
-        class_ = row[2]
-
-        if class_first is not None:
-            if not name.endswith("Last>"):
-                raise ValueError("Missing Last after First")
-
-        for c in range(prev_codepoint + 1, codepoint):
-            yield Codepoint(c, class_first)
-
-        class_first = None
-        if name.endswith("First>"):
-            class_first = class_
-
-        yield Codepoint(codepoint, class_)
-        prev_codepoint = codepoint
-
-    if class_first is not None:
-        raise ValueError("Missing Last after First")
-
-    for c in range(prev_codepoint + 1, NUM_CODEPOINTS):
-        yield Codepoint(c, None)
-
-def compress_singletons(singletons):
-    uppers = [] # (upper, # items in lowers)
-    lowers = []
-
-    for i in singletons:
-        upper = i >> 8
-        lower = i & 0xff
-        if len(uppers) == 0 or uppers[-1][0] != upper:
-            uppers.append((upper, 1))
-        else:
-            upper, count = uppers[-1]
-            uppers[-1] = upper, count + 1
-        lowers.append(lower)
-
-    return uppers, lowers
-
-def compress_normal(normal):
-    # lengths 0x00..0x7f are encoded as 00, 01, ..., 7e, 7f
-    # lengths 0x80..0x7fff are encoded as 80 80, 80 81, ..., ff fe, ff ff
-    compressed = [] # [truelen, (truelenaux), falselen, (falselenaux)]
-
-    prev_start = 0
-    for start, count in normal:
-        truelen = start - prev_start
-        falselen = count
-        prev_start = start + count
-
-        assert truelen < 0x8000 and falselen < 0x8000
-        entry = []
-        if truelen > 0x7f:
-            entry.append(0x80 | (truelen >> 8))
-            entry.append(truelen & 0xff)
-        else:
-            entry.append(truelen & 0x7f)
-        if falselen > 0x7f:
-            entry.append(0x80 | (falselen >> 8))
-            entry.append(falselen & 0xff)
-        else:
-            entry.append(falselen & 0x7f)
-
-        compressed.append(entry)
-
-    return compressed
-
-def print_singletons(uppers, lowers, uppersname, lowersname):
-    print("  static constexpr singleton {}[] = {{".format(uppersname))
-    for u, c in uppers:
-        print("    {{{:#04x}, {}}},".format(u, c))
-    print("  };")
-    print("  static constexpr unsigned char {}[] = {{".format(lowersname))
-    for i in range(0, len(lowers), 8):
-        print("    {}".format(" ".join("{:#04x},".format(l) for l in lowers[i:i+8])))
-    print("  };")
-
-def print_normal(normal, normalname):
-    print("  static constexpr unsigned char {}[] = {{".format(normalname))
-    for v in normal:
-        print("    {}".format(" ".join("{:#04x},".format(i) for i in v)))
-    print("  };")
-
-def main():
-    file = get_file("https://www.unicode.org/Public/UNIDATA/UnicodeData.txt")
-
-    codepoints = get_codepoints(file)
-
-    CUTOFF=0x10000
-    singletons0 = []
-    singletons1 = []
-    normal0 = []
-    normal1 = []
-    extra = []
-
-    for a, b in to_ranges(get_escaped(codepoints)):
-        if a > 2 * CUTOFF:
-            extra.append((a, b - a))
-        elif a == b - 1:
-            if a & CUTOFF:
-                singletons1.append(a & ~CUTOFF)
-            else:
-                singletons0.append(a)
-        elif a == b - 2:
-            if a & CUTOFF:
-                singletons1.append(a & ~CUTOFF)
-                singletons1.append((a + 1) & ~CUTOFF)
-            else:
-                singletons0.append(a)
-                singletons0.append(a + 1)
-        else:
-            if a >= 2 * CUTOFF:
-                extra.append((a, b - a))
-            elif a & CUTOFF:
-                normal1.append((a & ~CUTOFF, b - a))
-            else:
-                normal0.append((a, b - a))
-
-    singletons0u, singletons0l = compress_singletons(singletons0)
-    singletons1u, singletons1l = compress_singletons(singletons1)
-    normal0 = compress_normal(normal0)
-    normal1 = compress_normal(normal1)
-
-    print("""\
-FMT_FUNC auto is_printable(uint32_t cp) -> bool {\
-""")
-    print_singletons(singletons0u, singletons0l, 'singletons0', 'singletons0_lower')
-    print_singletons(singletons1u, singletons1l, 'singletons1', 'singletons1_lower')
-    print_normal(normal0, 'normal0')
-    print_normal(normal1, 'normal1')
-    print("""\
-  auto lower = static_cast<uint16_t>(cp);
-  if (cp < 0x10000) {
-    return is_printable(lower, singletons0,
-                        sizeof(singletons0) / sizeof(*singletons0),
-                        singletons0_lower, normal0, sizeof(normal0));
-  }
-  if (cp < 0x20000) {
-    return is_printable(lower, singletons1,
-                        sizeof(singletons1) / sizeof(*singletons1),
-                        singletons1_lower, normal1, sizeof(normal1));
-  }\
-""")
-    for a, b in extra:
-        print("  if (0x{:x} <= cp && cp < 0x{:x}) return false;".format(a, a + b))
-    print("""\
-  return cp < 0x{:x};
-}}\
-""".format(NUM_CODEPOINTS))
-
-if __name__ == '__main__':
-    main()
diff --git a/Externals/fmt/support/rst2md.py b/Externals/fmt/support/rst2md.py
deleted file mode 100755
index 3f072007dae0..000000000000
--- a/Externals/fmt/support/rst2md.py
+++ /dev/null
@@ -1,159 +0,0 @@
-#!/usr/bin/env python
-# reStructuredText (RST) to GitHub-flavored Markdown converter
-
-import re, sys
-from docutils import core, nodes, writers
-
-
-def is_github_ref(node):
-    return re.match('https://github.com/.*/(issues|pull)/.*', node['refuri'])
-
-
-class Translator(nodes.NodeVisitor):
-    def __init__(self, document):
-        nodes.NodeVisitor.__init__(self, document)
-        self.output = ''
-        self.indent = 0
-        self.preserve_newlines = False
-
-    def write(self, text):
-        self.output += text.replace('\n', '\n' + ' ' * self.indent)
-
-    def visit_document(self, node):
-        pass
-
-    def depart_document(self, node):
-        pass
-
-    def visit_section(self, node):
-        pass
-
-    def depart_section(self, node):
-        # Skip all sections except the first one.
-        raise nodes.StopTraversal
-
-    def visit_title(self, node):
-        self.version = re.match(r'(\d+\.\d+\.\d+).*', node.children[0]).group(1)
-        raise nodes.SkipChildren
-
-    def visit_title_reference(self, node):
-        raise Exception(node)
-
-    def depart_title(self, node):
-        pass
-
-    def visit_Text(self, node):
-        if not self.preserve_newlines:
-            node = node.replace('\n', ' ')
-        self.write(node)
-
-    def depart_Text(self, node):
-        pass
-
-    def visit_bullet_list(self, node):
-        pass
-
-    def depart_bullet_list(self, node):
-        pass
-
-    def visit_list_item(self, node):
-        self.write('* ')
-        self.indent += 2
-
-    def depart_list_item(self, node):
-        self.indent -= 2
-        self.write('\n\n')
-
-    def visit_paragraph(self, node):
-        self.write('\n\n')
-
-    def depart_paragraph(self, node):
-        pass
-
-    def visit_reference(self, node):
-        if not is_github_ref(node):
-            self.write('[')
-
-    def depart_reference(self, node):
-        if not is_github_ref(node):
-            self.write('](' + node['refuri'] + ')')
-
-    def visit_target(self, node):
-        pass
-
-    def depart_target(self, node):
-        pass
-
-    def visit_literal(self, node):
-        self.write('`')
-
-    def depart_literal(self, node):
-        self.write('`')
-
-    def visit_literal_block(self, node):
-        self.write('\n\n```')
-        if 'c++' in node['classes']:
-            self.write('c++')
-        self.write('\n')
-        self.preserve_newlines = True
-
-    def depart_literal_block(self, node):
-        self.write('\n```\n')
-        self.preserve_newlines = False
-
-    def visit_inline(self, node):
-        pass
-
-    def depart_inline(self, node):
-        pass
-
-    def visit_image(self, node):
-        self.write('![](' + node['uri'] + ')')
-
-    def depart_image(self, node):
-        pass
-
-    def write_row(self, row, widths):
-        for i, entry in enumerate(row):
-            text = entry[0][0] if len(entry) > 0 else ''
-            if i != 0:
-                self.write('|')
-            self.write('{:{}}'.format(text, widths[i]))
-        self.write('\n')
-
-    def visit_table(self, node):
-        table = node.children[0]
-        colspecs = table[:-2]
-        thead = table[-2]
-        tbody = table[-1]
-        widths = [int(cs['colwidth']) for cs in colspecs]
-        sep = '|'.join(['-' * w for w in widths]) + '\n'
-        self.write('\n\n')
-        self.write_row(thead[0], widths)
-        self.write(sep)
-        for row in tbody:
-            self.write_row(row, widths)
-        raise nodes.SkipChildren
-
-    def depart_table(self, node):
-        pass
-
-class MDWriter(writers.Writer):
-    """GitHub-flavored markdown writer"""
-
-    supported = ('md',)
-    """Formats this writer supports."""
-
-    def translate(self):
-        translator = Translator(self.document)
-        self.document.walkabout(translator)
-        self.output = (translator.output, translator.version)
-
-
-def convert(rst_path):
-    """Converts RST file to Markdown."""
-    return core.publish_file(source_path=rst_path, writer=MDWriter())
-
-
-if __name__ == '__main__':
-    convert(sys.argv[1])
diff --git a/Externals/fmt/support/rtd/conf.py b/Externals/fmt/support/rtd/conf.py
deleted file mode 100755
index 124fb9d4c84c..000000000000
--- a/Externals/fmt/support/rtd/conf.py
+++ /dev/null
@@ -1,7 +0,0 @@
-# Sphinx configuration for readthedocs.
-
-import os, sys
-
-master_doc = 'index'
-html_theme = 'theme'
-html_theme_path = ["."]
diff --git a/Externals/fmt/support/rtd/index.rst b/Externals/fmt/support/rtd/index.rst
deleted file mode 100755
index 7c88322f6246..000000000000
--- a/Externals/fmt/support/rtd/index.rst
+++ /dev/null
@@ -1,2 +0,0 @@
-If you are not redirected automatically, follow the
-`link to the fmt documentation <https://fmt.dev/latest/>`_.
diff --git a/Externals/fmt/support/rtd/theme/layout.html b/Externals/fmt/support/rtd/theme/layout.html
deleted file mode 100755
index 29ebc55bb42e..000000000000
--- a/Externals/fmt/support/rtd/theme/layout.html
+++ /dev/null
@@ -1,17 +0,0 @@
-{% extends "basic/layout.html" %}
-
-{% block extrahead %}
-<meta charset="UTF-8">
-<meta http-equiv="refresh" content="1;url=https://fmt.dev/latest/">
-<script type="text/javascript">
-    window.location.href = "https://fmt.dev/latest/"
-</script>
-<title>Page Redirection</title>
-{% endblock %}
-
-{% block document %}
-If you are not redirected automatically, follow the <a href='https://fmt.dev/latest/'>link to the fmt documentation</a>.
-{% endblock %}
-
-{% block footer %}
-{% endblock %}
diff --git a/Externals/fmt/support/rtd/theme/theme.conf b/Externals/fmt/support/rtd/theme/theme.conf
deleted file mode 100755
index 89e03bbdac5e..000000000000
--- a/Externals/fmt/support/rtd/theme/theme.conf
+++ /dev/null
@@ -1,2 +0,0 @@
-[theme]
-inherit = basic
