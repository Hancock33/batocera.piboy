diff -Naur duckstation-51041e47f70123eda41d999701f5651830a0a95e.orig/src/duckstation-libretro/CMakeLists.txt duckstation-51041e47f70123eda41d999701f5651830a0a95e/src/duckstation-libretro/CMakeLists.txt
--- duckstation-51041e47f70123eda41d999701f5651830a0a95e.orig/src/duckstation-libretro/CMakeLists.txt	1970-01-01 01:00:00.000000000 +0100
+++ duckstation-51041e47f70123eda41d999701f5651830a0a95e/src/duckstation-libretro/CMakeLists.txt	2022-01-12 18:30:18.000000000 +0000
@@ -0,0 +1,51 @@
+add_library(swanstation_libretro SHARED
+  libretro_audio_stream.cpp
+  libretro_audio_stream.h
+  libretro_game_settings.cpp
+  libretro_game_settings.h
+  libretro_host_display.cpp
+  libretro_host_display.h
+  libretro_host_interface.cpp
+  libretro_host_interface.h
+  libretro_opengl_host_display.cpp
+  libretro_opengl_host_display.h
+  libretro_settings_interface.cpp
+  libretro_settings_interface.h
+  libretro_vulkan_host_display.cpp
+  libretro_vulkan_host_display.h
+  main.cpp
+)
+
+if(WIN32)
+  target_sources(swanstation_libretro PRIVATE
+    libretro_d3d11_host_display.cpp
+    libretro_d3d11_host_display.h
+  )
+endif()
+
+target_link_libraries(swanstation_libretro PRIVATE core common glad scmversion vulkan-loader)
+
+# Stuff from frontend-common
+target_sources(swanstation_libretro PRIVATE
+  ../frontend-common/game_settings.cpp
+  ../frontend-common/game_settings.h
+)
+target_link_libraries(swanstation_libretro PRIVATE simpleini)
+
+# no lib prefix
+set_target_properties(swanstation_libretro PROPERTIES PREFIX "")
+
+# drop in the build directory
+set_target_properties(swanstation_libretro PROPERTIES RUNTIME_OUTPUT_DIRECTORY "${CMAKE_BINARY_DIR}")
+set_target_properties(swanstation_libretro PROPERTIES LIBRARY_OUTPUT_DIRECTORY "${CMAKE_BINARY_DIR}")
+
+# work around .sln issue of hardcoded config directories
+if(WIN32)
+  set_target_properties(swanstation_libretro PROPERTIES RUNTIME_OUTPUT_DIRECTORY_DEBUG "${CMAKE_BINARY_DIR}")
+  set_target_properties(swanstation_libretro PROPERTIES RUNTIME_OUTPUT_DIRECTORY_RELEASE "${CMAKE_BINARY_DIR}")
+endif()
+
+# for android, suffix _android
+if(ANDROID)
+  set_target_properties(swanstation_libretro PROPERTIES OUTPUT_NAME "swanstation_libretro_android")
+endif()
diff -Naur duckstation-51041e47f70123eda41d999701f5651830a0a95e.orig/src/duckstation-libretro/duckstation-libretro.vcxproj duckstation-51041e47f70123eda41d999701f5651830a0a95e/src/duckstation-libretro/duckstation-libretro.vcxproj
--- duckstation-51041e47f70123eda41d999701f5651830a0a95e.orig/src/duckstation-libretro/duckstation-libretro.vcxproj	1970-01-01 01:00:00.000000000 +0100
+++ duckstation-51041e47f70123eda41d999701f5651830a0a95e/src/duckstation-libretro/duckstation-libretro.vcxproj	2022-01-12 18:30:18.000000000 +0000
@@ -0,0 +1,582 @@
+﻿<?xml version="1.0" encoding="utf-8"?>
+<Project DefaultTargets="Build" ToolsVersion="15.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+  <ItemGroup Label="ProjectConfigurations">
+    <ProjectConfiguration Include="DebugFast|ARM64">
+      <Configuration>DebugFast</Configuration>
+      <Platform>ARM64</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="DebugFast|Win32">
+      <Configuration>DebugFast</Configuration>
+      <Platform>Win32</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="DebugFast|x64">
+      <Configuration>DebugFast</Configuration>
+      <Platform>x64</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Debug|ARM64">
+      <Configuration>Debug</Configuration>
+      <Platform>ARM64</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Debug|Win32">
+      <Configuration>Debug</Configuration>
+      <Platform>Win32</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Debug|x64">
+      <Configuration>Debug</Configuration>
+      <Platform>x64</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="ReleaseLTCG|ARM64">
+      <Configuration>ReleaseLTCG</Configuration>
+      <Platform>ARM64</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="ReleaseLTCG|Win32">
+      <Configuration>ReleaseLTCG</Configuration>
+      <Platform>Win32</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="ReleaseLTCG|x64">
+      <Configuration>ReleaseLTCG</Configuration>
+      <Platform>x64</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Release|ARM64">
+      <Configuration>Release</Configuration>
+      <Platform>ARM64</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Release|Win32">
+      <Configuration>Release</Configuration>
+      <Platform>Win32</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Release|x64">
+      <Configuration>Release</Configuration>
+      <Platform>x64</Platform>
+    </ProjectConfiguration>
+  </ItemGroup>
+  <ItemGroup>
+    <ProjectReference Include="..\..\dep\vulkan-loader\vulkan-loader.vcxproj">
+      <Project>{9c8ddeb0-2b8f-4f5f-ba86-127cdf27f035}</Project>
+    </ProjectReference>
+    <ProjectReference Include="..\common\common.vcxproj">
+      <Project>{ee054e08-3799-4a59-a422-18259c105ffd}</Project>
+    </ProjectReference>
+    <ProjectReference Include="..\core\core.vcxproj">
+      <Project>{868b98c8-65a1-494b-8346-250a73a48c0a}</Project>
+    </ProjectReference>
+    <ProjectReference Include="..\frontend-common\frontend-common.vcxproj">
+      <Project>{6245dec8-d2da-47ee-a373-cbd6fcf3ece6}</Project>
+    </ProjectReference>
+    <ProjectReference Include="..\scmversion\scmversion.vcxproj">
+      <Project>{075ced82-6a20-46df-94c7-9624ac9ddbeb}</Project>
+    </ProjectReference>
+  </ItemGroup>
+  <ItemGroup>
+    <ClCompile Include="libretro_d3d11_host_display.cpp" />
+    <ClCompile Include="libretro_audio_stream.cpp" />
+    <ClCompile Include="libretro_game_settings.cpp" />
+    <ClCompile Include="libretro_host_display.cpp" />
+    <ClCompile Include="libretro_host_interface.cpp" />
+    <ClCompile Include="libretro_settings_interface.cpp" />
+    <ClCompile Include="libretro_vulkan_host_display.cpp" />
+    <ClCompile Include="main.cpp" />
+    <ClCompile Include="libretro_opengl_host_display.cpp" />
+  </ItemGroup>
+  <ItemGroup>
+    <ClInclude Include="libretro_d3d11_host_display.h" />
+    <ClInclude Include="libretro_audio_stream.h" />
+    <ClInclude Include="libretro_game_settings.h" />
+    <ClInclude Include="libretro_host_display.h" />
+    <ClInclude Include="libretro_host_interface.h" />
+    <ClInclude Include="libretro_settings_interface.h" />
+    <ClInclude Include="libretro_opengl_host_display.h" />
+    <ClInclude Include="libretro_vulkan_host_display.h" />
+  </ItemGroup>
+  <PropertyGroup Label="Globals">
+    <ProjectGuid>{9D206548-DE8F-4D9D-A561-C7E5CD7A20DF}</ProjectGuid>
+    <Keyword>Win32Proj</Keyword>
+    <RootNamespace>duckstation-libretro</RootNamespace>
+    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
+  </PropertyGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
+    <ConfigurationType>DynamicLibrary</ConfigurationType>
+    <UseDebugLibraries>true</UseDebugLibraries>
+    <PlatformToolset>v142</PlatformToolset>
+    <CharacterSet>NotSet</CharacterSet>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
+    <ConfigurationType>DynamicLibrary</ConfigurationType>
+    <UseDebugLibraries>true</UseDebugLibraries>
+    <PlatformToolset>v142</PlatformToolset>
+    <CharacterSet>NotSet</CharacterSet>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'" Label="Configuration">
+    <ConfigurationType>DynamicLibrary</ConfigurationType>
+    <UseDebugLibraries>true</UseDebugLibraries>
+    <PlatformToolset>v142</PlatformToolset>
+    <CharacterSet>NotSet</CharacterSet>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='DebugFast|Win32'" Label="Configuration">
+    <ConfigurationType>DynamicLibrary</ConfigurationType>
+    <UseDebugLibraries>true</UseDebugLibraries>
+    <PlatformToolset>v142</PlatformToolset>
+    <CharacterSet>NotSet</CharacterSet>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='DebugFast|x64'" Label="Configuration">
+    <ConfigurationType>DynamicLibrary</ConfigurationType>
+    <UseDebugLibraries>true</UseDebugLibraries>
+    <PlatformToolset>v142</PlatformToolset>
+    <CharacterSet>NotSet</CharacterSet>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='DebugFast|ARM64'" Label="Configuration">
+    <ConfigurationType>DynamicLibrary</ConfigurationType>
+    <UseDebugLibraries>true</UseDebugLibraries>
+    <PlatformToolset>v142</PlatformToolset>
+    <CharacterSet>NotSet</CharacterSet>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
+    <ConfigurationType>DynamicLibrary</ConfigurationType>
+    <UseDebugLibraries>false</UseDebugLibraries>
+    <PlatformToolset>v142</PlatformToolset>
+    <WholeProgramOptimization>true</WholeProgramOptimization>
+    <CharacterSet>NotSet</CharacterSet>
+    <SpectreMitigation>false</SpectreMitigation>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='ReleaseLTCG|Win32'" Label="Configuration">
+    <ConfigurationType>DynamicLibrary</ConfigurationType>
+    <UseDebugLibraries>false</UseDebugLibraries>
+    <PlatformToolset>v142</PlatformToolset>
+    <WholeProgramOptimization>true</WholeProgramOptimization>
+    <CharacterSet>NotSet</CharacterSet>
+    <SpectreMitigation>false</SpectreMitigation>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
+    <ConfigurationType>DynamicLibrary</ConfigurationType>
+    <UseDebugLibraries>false</UseDebugLibraries>
+    <PlatformToolset>v142</PlatformToolset>
+    <WholeProgramOptimization>true</WholeProgramOptimization>
+    <CharacterSet>NotSet</CharacterSet>
+    <SpectreMitigation>false</SpectreMitigation>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'" Label="Configuration">
+    <ConfigurationType>DynamicLibrary</ConfigurationType>
+    <UseDebugLibraries>false</UseDebugLibraries>
+    <PlatformToolset>v142</PlatformToolset>
+    <WholeProgramOptimization>true</WholeProgramOptimization>
+    <CharacterSet>NotSet</CharacterSet>
+    <SpectreMitigation>false</SpectreMitigation>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='ReleaseLTCG|x64'" Label="Configuration">
+    <ConfigurationType>DynamicLibrary</ConfigurationType>
+    <UseDebugLibraries>false</UseDebugLibraries>
+    <PlatformToolset>v142</PlatformToolset>
+    <WholeProgramOptimization>true</WholeProgramOptimization>
+    <CharacterSet>NotSet</CharacterSet>
+    <SpectreMitigation>false</SpectreMitigation>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='ReleaseLTCG|ARM64'" Label="Configuration">
+    <ConfigurationType>DynamicLibrary</ConfigurationType>
+    <UseDebugLibraries>false</UseDebugLibraries>
+    <PlatformToolset>v142</PlatformToolset>
+    <WholeProgramOptimization>true</WholeProgramOptimization>
+    <CharacterSet>NotSet</CharacterSet>
+    <SpectreMitigation>false</SpectreMitigation>
+  </PropertyGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
+  <ImportGroup Label="ExtensionSettings">
+  </ImportGroup>
+  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="PropertySheets">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'" Label="PropertySheets">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='DebugFast|Win32'" Label="PropertySheets">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='DebugFast|x64'" Label="PropertySheets">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='DebugFast|ARM64'" Label="PropertySheets">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='ReleaseLTCG|Win32'" Label="PropertySheets">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="PropertySheets">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'" Label="PropertySheets">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='ReleaseLTCG|x64'" Label="PropertySheets">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='ReleaseLTCG|ARM64'" Label="PropertySheets">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <PropertyGroup Label="UserMacros" />
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
+    <LinkIncremental>true</LinkIncremental>
+    <OutDir>$(SolutionDir)bin\$(Platform)\</OutDir>
+    <IntDir>$(SolutionDir)build\$(ProjectName)-$(Platform)-$(Configuration)\</IntDir>
+    <TargetName>$(ProjectName)-$(Platform)-$(Configuration)</TargetName>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <IntDir>$(SolutionDir)build\$(ProjectName)-$(Platform)-$(Configuration)\</IntDir>
+    <TargetName>$(ProjectName)-$(Platform)-$(Configuration)</TargetName>
+    <LinkIncremental>true</LinkIncremental>
+    <OutDir>$(SolutionDir)bin\$(Platform)\</OutDir>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'">
+    <IntDir>$(SolutionDir)build\$(ProjectName)-$(Platform)-$(Configuration)\</IntDir>
+    <TargetName>$(ProjectName)-$(Platform)-$(Configuration)</TargetName>
+    <LinkIncremental>true</LinkIncremental>
+    <OutDir>$(SolutionDir)bin\$(Platform)\</OutDir>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='DebugFast|Win32'">
+    <LinkIncremental>true</LinkIncremental>
+    <OutDir>$(SolutionDir)bin\$(Platform)\</OutDir>
+    <IntDir>$(SolutionDir)build\$(ProjectName)-$(Platform)-$(Configuration)\</IntDir>
+    <TargetName>$(ProjectName)-$(Platform)-$(Configuration)</TargetName>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='DebugFast|x64'">
+    <IntDir>$(SolutionDir)build\$(ProjectName)-$(Platform)-$(Configuration)\</IntDir>
+    <TargetName>$(ProjectName)-$(Platform)-$(Configuration)</TargetName>
+    <LinkIncremental>true</LinkIncremental>
+    <OutDir>$(SolutionDir)bin\$(Platform)\</OutDir>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='DebugFast|ARM64'">
+    <IntDir>$(SolutionDir)build\$(ProjectName)-$(Platform)-$(Configuration)\</IntDir>
+    <TargetName>$(ProjectName)-$(Platform)-$(Configuration)</TargetName>
+    <LinkIncremental>true</LinkIncremental>
+    <OutDir>$(SolutionDir)bin\$(Platform)\</OutDir>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
+    <OutDir>$(SolutionDir)bin\$(Platform)\</OutDir>
+    <IntDir>$(SolutionDir)build\$(ProjectName)-$(Platform)-$(Configuration)\</IntDir>
+    <TargetName>$(ProjectName)-$(Platform)-$(Configuration)</TargetName>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='ReleaseLTCG|Win32'">
+    <LinkIncremental>false</LinkIncremental>
+    <OutDir>$(SolutionDir)bin\$(Platform)\</OutDir>
+    <IntDir>$(SolutionDir)build\$(ProjectName)-$(Platform)-$(Configuration)\</IntDir>
+    <TargetName>$(ProjectName)-$(Platform)-$(Configuration)</TargetName>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
+    <IntDir>$(SolutionDir)build\$(ProjectName)-$(Platform)-$(Configuration)\</IntDir>
+    <TargetName>$(ProjectName)-$(Platform)-$(Configuration)</TargetName>
+    <OutDir>$(SolutionDir)bin\$(Platform)\</OutDir>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'">
+    <IntDir>$(SolutionDir)build\$(ProjectName)-$(Platform)-$(Configuration)\</IntDir>
+    <TargetName>$(ProjectName)-$(Platform)-$(Configuration)</TargetName>
+    <OutDir>$(SolutionDir)bin\$(Platform)\</OutDir>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='ReleaseLTCG|x64'">
+    <IntDir>$(SolutionDir)build\$(ProjectName)-$(Platform)-$(Configuration)\</IntDir>
+    <TargetName>$(ProjectName)-$(Platform)-$(Configuration)</TargetName>
+    <LinkIncremental>false</LinkIncremental>
+    <OutDir>$(SolutionDir)bin\$(Platform)\</OutDir>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='ReleaseLTCG|ARM64'">
+    <IntDir>$(SolutionDir)build\$(ProjectName)-$(Platform)-$(Configuration)\</IntDir>
+    <TargetName>$(ProjectName)-$(Platform)-$(Configuration)</TargetName>
+    <LinkIncremental>false</LinkIncremental>
+    <OutDir>$(SolutionDir)bin\$(Platform)\</OutDir>
+  </PropertyGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
+    <ClCompile>
+      <PrecompiledHeader>
+      </PrecompiledHeader>
+      <WarningLevel>Level4</WarningLevel>
+      <Optimization>Disabled</Optimization>
+      <PreprocessorDefinitions>_CRT_SECURE_NO_WARNINGS;WIN32;_DEBUG;_CONSOLE;_LIB;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <SDLCheck>true</SDLCheck>
+      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
+      <AdditionalIncludeDirectories>$(SolutionDir)dep\imgui\include;$(SolutionDir)dep\glad\include;$(SolutionDir)dep\vulkan-loader\include;$(SolutionDir)dep\libretro-common\include;$(SolutionDir)src;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
+      <MultiProcessorCompilation>true</MultiProcessorCompilation>
+      <MinimalRebuild>false</MinimalRebuild>
+      <LanguageStandard>stdcpp17</LanguageStandard>
+      <ConformanceMode>true</ConformanceMode>
+      <AdditionalOptions>/Zo /utf-8 %(AdditionalOptions)</AdditionalOptions>
+    </ClCompile>
+    <Link>
+      <SubSystem>Windows</SubSystem>
+      <GenerateDebugInformation>true</GenerateDebugInformation>
+      <AdditionalDependencies>d3d11.lib;dxgi.lib;%(AdditionalDependencies)</AdditionalDependencies>
+    </Link>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <ClCompile>
+      <PrecompiledHeader>
+      </PrecompiledHeader>
+      <WarningLevel>Level4</WarningLevel>
+      <Optimization>Disabled</Optimization>
+      <PreprocessorDefinitions>_CRT_SECURE_NO_WARNINGS;WIN32;_DEBUG;_CONSOLE;_LIB;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <SDLCheck>true</SDLCheck>
+      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
+      <AdditionalIncludeDirectories>$(SolutionDir)dep\imgui\include;$(SolutionDir)dep\glad\include;$(SolutionDir)dep\vulkan-loader\include;$(SolutionDir)dep\libretro-common\include;$(SolutionDir)src;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
+      <MultiProcessorCompilation>true</MultiProcessorCompilation>
+      <MinimalRebuild>false</MinimalRebuild>
+      <LanguageStandard>stdcpp17</LanguageStandard>
+      <ConformanceMode>true</ConformanceMode>
+      <AdditionalOptions>/Zo /utf-8 %(AdditionalOptions)</AdditionalOptions>
+    </ClCompile>
+    <Link>
+      <SubSystem>Windows</SubSystem>
+      <GenerateDebugInformation>true</GenerateDebugInformation>
+      <AdditionalDependencies>d3d11.lib;dxgi.lib;%(AdditionalDependencies)</AdditionalDependencies>
+    </Link>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'">
+    <ClCompile>
+      <PrecompiledHeader>
+      </PrecompiledHeader>
+      <WarningLevel>Level4</WarningLevel>
+      <Optimization>Disabled</Optimization>
+      <PreprocessorDefinitions>_CRT_SECURE_NO_WARNINGS;WIN32;_DEBUG;_CONSOLE;_LIB;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <SDLCheck>true</SDLCheck>
+      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
+      <AdditionalIncludeDirectories>$(SolutionDir)dep\imgui\include;$(SolutionDir)dep\glad\include;$(SolutionDir)dep\vulkan-loader\include;$(SolutionDir)dep\libretro-common\include;$(SolutionDir)src;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
+      <MultiProcessorCompilation>true</MultiProcessorCompilation>
+      <MinimalRebuild>false</MinimalRebuild>
+      <LanguageStandard>stdcpp17</LanguageStandard>
+      <ConformanceMode>true</ConformanceMode>
+      <AdditionalOptions>/Zo /utf-8 %(AdditionalOptions)</AdditionalOptions>
+    </ClCompile>
+    <Link>
+      <SubSystem>Windows</SubSystem>
+      <GenerateDebugInformation>true</GenerateDebugInformation>
+      <AdditionalDependencies>d3d11.lib;dxgi.lib;%(AdditionalDependencies)</AdditionalDependencies>
+    </Link>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='DebugFast|Win32'">
+    <ClCompile>
+      <PrecompiledHeader>
+      </PrecompiledHeader>
+      <WarningLevel>Level4</WarningLevel>
+      <Optimization>Disabled</Optimization>
+      <PreprocessorDefinitions>_ITERATOR_DEBUG_LEVEL=1;_CRT_SECURE_NO_WARNINGS;WIN32;_DEBUGFAST;_DEBUG;_CONSOLE;_LIB;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <SDLCheck>true</SDLCheck>
+      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
+      <AdditionalIncludeDirectories>$(SolutionDir)dep\imgui\include;$(SolutionDir)dep\glad\include;$(SolutionDir)dep\vulkan-loader\include;$(SolutionDir)dep\libretro-common\include;$(SolutionDir)src;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
+      <BasicRuntimeChecks>Default</BasicRuntimeChecks>
+      <MultiProcessorCompilation>true</MultiProcessorCompilation>
+      <MinimalRebuild>false</MinimalRebuild>
+      <LanguageStandard>stdcpp17</LanguageStandard>
+      <SupportJustMyCode>false</SupportJustMyCode>
+      <InlineFunctionExpansion>OnlyExplicitInline</InlineFunctionExpansion>
+      <ConformanceMode>true</ConformanceMode>
+      <AdditionalOptions>/Zo /utf-8 %(AdditionalOptions)</AdditionalOptions>
+    </ClCompile>
+    <Link>
+      <SubSystem>Windows</SubSystem>
+      <GenerateDebugInformation>true</GenerateDebugInformation>
+      <AdditionalDependencies>d3d11.lib;dxgi.lib;%(AdditionalDependencies)</AdditionalDependencies>
+    </Link>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='DebugFast|x64'">
+    <ClCompile>
+      <PrecompiledHeader>
+      </PrecompiledHeader>
+      <WarningLevel>Level4</WarningLevel>
+      <Optimization>Disabled</Optimization>
+      <PreprocessorDefinitions>_ITERATOR_DEBUG_LEVEL=1;_CRT_SECURE_NO_WARNINGS;WIN32;_DEBUGFAST;_DEBUG;_CONSOLE;_LIB;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <SDLCheck>true</SDLCheck>
+      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
+      <AdditionalIncludeDirectories>$(SolutionDir)dep\imgui\include;$(SolutionDir)dep\glad\include;$(SolutionDir)dep\vulkan-loader\include;$(SolutionDir)dep\libretro-common\include;$(SolutionDir)src;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
+      <BasicRuntimeChecks>Default</BasicRuntimeChecks>
+      <MultiProcessorCompilation>true</MultiProcessorCompilation>
+      <MinimalRebuild>false</MinimalRebuild>
+      <LanguageStandard>stdcpp17</LanguageStandard>
+      <SupportJustMyCode>false</SupportJustMyCode>
+      <InlineFunctionExpansion>OnlyExplicitInline</InlineFunctionExpansion>
+      <ConformanceMode>true</ConformanceMode>
+      <AdditionalOptions>/Zo /utf-8 %(AdditionalOptions)</AdditionalOptions>
+    </ClCompile>
+    <Link>
+      <SubSystem>Windows</SubSystem>
+      <GenerateDebugInformation>true</GenerateDebugInformation>
+      <AdditionalDependencies>d3d11.lib;dxgi.lib;%(AdditionalDependencies)</AdditionalDependencies>
+    </Link>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='DebugFast|ARM64'">
+    <ClCompile>
+      <PrecompiledHeader>
+      </PrecompiledHeader>
+      <WarningLevel>Level4</WarningLevel>
+      <Optimization>Disabled</Optimization>
+      <PreprocessorDefinitions>_ITERATOR_DEBUG_LEVEL=1;_CRT_SECURE_NO_WARNINGS;WIN32;_DEBUGFAST;_DEBUG;_CONSOLE;_LIB;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <SDLCheck>true</SDLCheck>
+      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
+      <AdditionalIncludeDirectories>$(SolutionDir)dep\imgui\include;$(SolutionDir)dep\glad\include;$(SolutionDir)dep\vulkan-loader\include;$(SolutionDir)dep\libretro-common\include;$(SolutionDir)src;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
+      <BasicRuntimeChecks>Default</BasicRuntimeChecks>
+      <MultiProcessorCompilation>true</MultiProcessorCompilation>
+      <MinimalRebuild>false</MinimalRebuild>
+      <LanguageStandard>stdcpp17</LanguageStandard>
+      <SupportJustMyCode>false</SupportJustMyCode>
+      <InlineFunctionExpansion>OnlyExplicitInline</InlineFunctionExpansion>
+      <ConformanceMode>true</ConformanceMode>
+      <AdditionalOptions>/Zo /utf-8 %(AdditionalOptions)</AdditionalOptions>
+    </ClCompile>
+    <Link>
+      <SubSystem>Windows</SubSystem>
+      <GenerateDebugInformation>true</GenerateDebugInformation>
+      <AdditionalDependencies>d3d11.lib;dxgi.lib;%(AdditionalDependencies)</AdditionalDependencies>
+    </Link>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
+    <ClCompile>
+      <WarningLevel>Level4</WarningLevel>
+      <PrecompiledHeader>
+      </PrecompiledHeader>
+      <Optimization>MaxSpeed</Optimization>
+      <IntrinsicFunctions>true</IntrinsicFunctions>
+      <PreprocessorDefinitions>_CRT_SECURE_NO_WARNINGS;WIN32;NDEBUG;_CONSOLE;_LIB;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <AdditionalIncludeDirectories>$(SolutionDir)dep\imgui\include;$(SolutionDir)dep\glad\include;$(SolutionDir)dep\vulkan-loader\include;$(SolutionDir)dep\libretro-common\include;$(SolutionDir)src;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
+      <MultiProcessorCompilation>true</MultiProcessorCompilation>
+      <WholeProgramOptimization>false</WholeProgramOptimization>
+      <LanguageStandard>stdcpp17</LanguageStandard>
+      <ConformanceMode>true</ConformanceMode>
+      <AdditionalOptions>/Zo /utf-8 %(AdditionalOptions)</AdditionalOptions>
+    </ClCompile>
+    <Link>
+      <SubSystem>Windows</SubSystem>
+      <GenerateDebugInformation>true</GenerateDebugInformation>
+      <EnableCOMDATFolding>true</EnableCOMDATFolding>
+      <OptimizeReferences>true</OptimizeReferences>
+      <AdditionalDependencies>d3d11.lib;dxgi.lib;%(AdditionalDependencies)</AdditionalDependencies>
+      <LinkTimeCodeGeneration>Default</LinkTimeCodeGeneration>
+    </Link>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='ReleaseLTCG|Win32'">
+    <ClCompile>
+      <WarningLevel>Level4</WarningLevel>
+      <PrecompiledHeader>
+      </PrecompiledHeader>
+      <Optimization>MaxSpeed</Optimization>
+      <IntrinsicFunctions>true</IntrinsicFunctions>
+      <PreprocessorDefinitions>_CRT_SECURE_NO_WARNINGS;WIN32;NDEBUG;_CONSOLE;_LIB;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <AdditionalIncludeDirectories>$(SolutionDir)dep\imgui\include;$(SolutionDir)dep\glad\include;$(SolutionDir)dep\vulkan-loader\include;$(SolutionDir)dep\libretro-common\include;$(SolutionDir)src;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
+      <MultiProcessorCompilation>true</MultiProcessorCompilation>
+      <WholeProgramOptimization>true</WholeProgramOptimization>
+      <LanguageStandard>stdcpp17</LanguageStandard>
+      <OmitFramePointers>true</OmitFramePointers>
+      <ConformanceMode>true</ConformanceMode>
+      <AdditionalOptions>/Zo /utf-8 %(AdditionalOptions)</AdditionalOptions>
+    </ClCompile>
+    <Link>
+      <SubSystem>Windows</SubSystem>
+      <GenerateDebugInformation>true</GenerateDebugInformation>
+      <EnableCOMDATFolding>true</EnableCOMDATFolding>
+      <OptimizeReferences>true</OptimizeReferences>
+      <AdditionalDependencies>d3d11.lib;dxgi.lib;%(AdditionalDependencies)</AdditionalDependencies>
+      <LinkTimeCodeGeneration>UseLinkTimeCodeGeneration</LinkTimeCodeGeneration>
+    </Link>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
+    <ClCompile>
+      <WarningLevel>Level4</WarningLevel>
+      <PrecompiledHeader>
+      </PrecompiledHeader>
+      <Optimization>MaxSpeed</Optimization>
+      <IntrinsicFunctions>true</IntrinsicFunctions>
+      <PreprocessorDefinitions>_CRT_SECURE_NO_WARNINGS;WIN32;NDEBUG;_CONSOLE;_LIB;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <AdditionalIncludeDirectories>$(SolutionDir)dep\imgui\include;$(SolutionDir)dep\glad\include;$(SolutionDir)dep\vulkan-loader\include;$(SolutionDir)dep\libretro-common\include;$(SolutionDir)src;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
+      <MultiProcessorCompilation>true</MultiProcessorCompilation>
+      <WholeProgramOptimization>false</WholeProgramOptimization>
+      <LanguageStandard>stdcpp17</LanguageStandard>
+      <ConformanceMode>true</ConformanceMode>
+      <AdditionalOptions>/Zo /utf-8 %(AdditionalOptions)</AdditionalOptions>
+    </ClCompile>
+    <Link>
+      <SubSystem>Windows</SubSystem>
+      <GenerateDebugInformation>true</GenerateDebugInformation>
+      <EnableCOMDATFolding>true</EnableCOMDATFolding>
+      <OptimizeReferences>true</OptimizeReferences>
+      <AdditionalDependencies>d3d11.lib;dxgi.lib;%(AdditionalDependencies)</AdditionalDependencies>
+      <LinkTimeCodeGeneration>Default</LinkTimeCodeGeneration>
+    </Link>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'">
+    <ClCompile>
+      <WarningLevel>Level4</WarningLevel>
+      <PrecompiledHeader>
+      </PrecompiledHeader>
+      <Optimization>MaxSpeed</Optimization>
+      <IntrinsicFunctions>true</IntrinsicFunctions>
+      <PreprocessorDefinitions>_CRT_SECURE_NO_WARNINGS;WIN32;NDEBUG;_CONSOLE;_LIB;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <AdditionalIncludeDirectories>$(SolutionDir)dep\imgui\include;$(SolutionDir)dep\glad\include;$(SolutionDir)dep\vulkan-loader\include;$(SolutionDir)dep\libretro-common\include;$(SolutionDir)src;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
+      <MultiProcessorCompilation>true</MultiProcessorCompilation>
+      <WholeProgramOptimization>false</WholeProgramOptimization>
+      <LanguageStandard>stdcpp17</LanguageStandard>
+      <ConformanceMode>true</ConformanceMode>
+      <AdditionalOptions>/Zo /utf-8 %(AdditionalOptions)</AdditionalOptions>
+    </ClCompile>
+    <Link>
+      <SubSystem>Windows</SubSystem>
+      <GenerateDebugInformation>true</GenerateDebugInformation>
+      <EnableCOMDATFolding>true</EnableCOMDATFolding>
+      <OptimizeReferences>true</OptimizeReferences>
+      <AdditionalDependencies>d3d11.lib;dxgi.lib;%(AdditionalDependencies)</AdditionalDependencies>
+      <LinkTimeCodeGeneration>Default</LinkTimeCodeGeneration>
+    </Link>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='ReleaseLTCG|x64'">
+    <ClCompile>
+      <WarningLevel>Level4</WarningLevel>
+      <PrecompiledHeader>
+      </PrecompiledHeader>
+      <Optimization>MaxSpeed</Optimization>
+      <IntrinsicFunctions>true</IntrinsicFunctions>
+      <PreprocessorDefinitions>_CRT_SECURE_NO_WARNINGS;WIN32;NDEBUG;_CONSOLE;_LIB;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <AdditionalIncludeDirectories>$(SolutionDir)dep\imgui\include;$(SolutionDir)dep\glad\include;$(SolutionDir)dep\vulkan-loader\include;$(SolutionDir)dep\libretro-common\include;$(SolutionDir)src;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
+      <MultiProcessorCompilation>true</MultiProcessorCompilation>
+      <WholeProgramOptimization>true</WholeProgramOptimization>
+      <LanguageStandard>stdcpp17</LanguageStandard>
+      <OmitFramePointers>true</OmitFramePointers>
+      <ConformanceMode>true</ConformanceMode>
+      <AdditionalOptions>/Zo /utf-8 %(AdditionalOptions)</AdditionalOptions>
+    </ClCompile>
+    <Link>
+      <SubSystem>Windows</SubSystem>
+      <GenerateDebugInformation>true</GenerateDebugInformation>
+      <EnableCOMDATFolding>true</EnableCOMDATFolding>
+      <OptimizeReferences>true</OptimizeReferences>
+      <AdditionalDependencies>d3d11.lib;dxgi.lib;%(AdditionalDependencies)</AdditionalDependencies>
+      <LinkTimeCodeGeneration>UseLinkTimeCodeGeneration</LinkTimeCodeGeneration>
+    </Link>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='ReleaseLTCG|ARM64'">
+    <ClCompile>
+      <WarningLevel>Level4</WarningLevel>
+      <PrecompiledHeader>
+      </PrecompiledHeader>
+      <Optimization>MaxSpeed</Optimization>
+      <IntrinsicFunctions>true</IntrinsicFunctions>
+      <PreprocessorDefinitions>_CRT_SECURE_NO_WARNINGS;WIN32;NDEBUG;_CONSOLE;_LIB;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <AdditionalIncludeDirectories>$(SolutionDir)dep\imgui\include;$(SolutionDir)dep\glad\include;$(SolutionDir)dep\vulkan-loader\include;$(SolutionDir)dep\libretro-common\include;$(SolutionDir)src;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
+      <MultiProcessorCompilation>true</MultiProcessorCompilation>
+      <WholeProgramOptimization>true</WholeProgramOptimization>
+      <LanguageStandard>stdcpp17</LanguageStandard>
+      <OmitFramePointers>true</OmitFramePointers>
+      <ConformanceMode>true</ConformanceMode>
+      <AdditionalOptions>/Zo /utf-8 %(AdditionalOptions)</AdditionalOptions>
+    </ClCompile>
+    <Link>
+      <SubSystem>Windows</SubSystem>
+      <GenerateDebugInformation>true</GenerateDebugInformation>
+      <EnableCOMDATFolding>true</EnableCOMDATFolding>
+      <OptimizeReferences>true</OptimizeReferences>
+      <AdditionalDependencies>d3d11.lib;dxgi.lib;%(AdditionalDependencies)</AdditionalDependencies>
+      <LinkTimeCodeGeneration>UseLinkTimeCodeGeneration</LinkTimeCodeGeneration>
+    </Link>
+  </ItemDefinitionGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
+  <ImportGroup Label="ExtensionTargets">
+  </ImportGroup>
+</Project>
\ No newline at end of file
diff -Naur duckstation-51041e47f70123eda41d999701f5651830a0a95e.orig/src/duckstation-libretro/duckstation-libretro.vcxproj.filters duckstation-51041e47f70123eda41d999701f5651830a0a95e/src/duckstation-libretro/duckstation-libretro.vcxproj.filters
--- duckstation-51041e47f70123eda41d999701f5651830a0a95e.orig/src/duckstation-libretro/duckstation-libretro.vcxproj.filters	1970-01-01 01:00:00.000000000 +0100
+++ duckstation-51041e47f70123eda41d999701f5651830a0a95e/src/duckstation-libretro/duckstation-libretro.vcxproj.filters	2022-01-12 18:30:18.000000000 +0000
@@ -0,0 +1,24 @@
+﻿<?xml version="1.0" encoding="utf-8"?>
+<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+  <ItemGroup>
+    <ClCompile Include="libretro_host_interface.cpp" />
+    <ClCompile Include="libretro_audio_stream.cpp" />
+    <ClCompile Include="libretro_host_display.cpp" />
+    <ClCompile Include="main.cpp" />
+    <ClCompile Include="libretro_settings_interface.cpp" />
+    <ClCompile Include="libretro_opengl_host_display.cpp" />
+    <ClCompile Include="libretro_d3d11_host_display.cpp" />
+    <ClCompile Include="libretro_vulkan_host_display.cpp" />
+    <ClCompile Include="libretro_game_settings.cpp" />
+  </ItemGroup>
+  <ItemGroup>
+    <ClInclude Include="libretro_host_interface.h" />
+    <ClInclude Include="libretro_audio_stream.h" />
+    <ClInclude Include="libretro_host_display.h" />
+    <ClInclude Include="libretro_settings_interface.h" />
+    <ClInclude Include="libretro_opengl_host_display.h" />
+    <ClInclude Include="libretro_d3d11_host_display.h" />
+    <ClInclude Include="libretro_vulkan_host_display.h" />
+    <ClInclude Include="libretro_game_settings.h" />
+  </ItemGroup>
+</Project>
\ No newline at end of file
diff -Naur duckstation-51041e47f70123eda41d999701f5651830a0a95e.orig/src/duckstation-libretro/libretro_audio_stream.cpp duckstation-51041e47f70123eda41d999701f5651830a0a95e/src/duckstation-libretro/libretro_audio_stream.cpp
--- duckstation-51041e47f70123eda41d999701f5651830a0a95e.orig/src/duckstation-libretro/libretro_audio_stream.cpp	1970-01-01 01:00:00.000000000 +0100
+++ duckstation-51041e47f70123eda41d999701f5651830a0a95e/src/duckstation-libretro/libretro_audio_stream.cpp	2022-01-12 18:30:18.000000000 +0000
@@ -0,0 +1,29 @@
+#include "libretro_audio_stream.h"
+#include "libretro_host_interface.h"
+
+LibretroAudioStream::LibretroAudioStream() = default;
+
+LibretroAudioStream::~LibretroAudioStream() = default;
+
+bool LibretroAudioStream::OpenDevice()
+{
+  return true;
+}
+
+void LibretroAudioStream::PauseDevice(bool paused) {}
+
+void LibretroAudioStream::CloseDevice() {}
+
+void LibretroAudioStream::FramesAvailable()
+{
+  for (;;)
+  {
+    const u32 num_samples = m_buffer.GetContiguousSize();
+    if (num_samples == 0)
+      break;
+
+    const u32 num_frames = num_samples / m_channels;
+    g_retro_audio_sample_batch_callback(m_buffer.GetReadPointer(), num_frames);
+    m_buffer.Remove(num_samples);
+  }
+}
diff -Naur duckstation-51041e47f70123eda41d999701f5651830a0a95e.orig/src/duckstation-libretro/libretro_audio_stream.h duckstation-51041e47f70123eda41d999701f5651830a0a95e/src/duckstation-libretro/libretro_audio_stream.h
--- duckstation-51041e47f70123eda41d999701f5651830a0a95e.orig/src/duckstation-libretro/libretro_audio_stream.h	1970-01-01 01:00:00.000000000 +0100
+++ duckstation-51041e47f70123eda41d999701f5651830a0a95e/src/duckstation-libretro/libretro_audio_stream.h	2022-01-12 18:30:18.000000000 +0000
@@ -0,0 +1,17 @@
+#pragma once
+#include "common/audio_stream.h"
+#include <cstdint>
+#include <vector>
+
+class LibretroAudioStream final : public AudioStream
+{
+public:
+  LibretroAudioStream();
+  ~LibretroAudioStream();
+
+protected:
+  bool OpenDevice() override;
+  void PauseDevice(bool paused) override;
+  void CloseDevice() override;
+  void FramesAvailable() override;
+};
diff -Naur duckstation-51041e47f70123eda41d999701f5651830a0a95e.orig/src/duckstation-libretro/libretro_core_options.h duckstation-51041e47f70123eda41d999701f5651830a0a95e/src/duckstation-libretro/libretro_core_options.h
--- duckstation-51041e47f70123eda41d999701f5651830a0a95e.orig/src/duckstation-libretro/libretro_core_options.h	1970-01-01 01:00:00.000000000 +0100
+++ duckstation-51041e47f70123eda41d999701f5651830a0a95e/src/duckstation-libretro/libretro_core_options.h	2022-01-12 18:30:18.000000000 +0000
@@ -0,0 +1,3367 @@
+#ifndef LIBRETRO_CORE_OPTIONS_H__
+#define LIBRETRO_CORE_OPTIONS_H__
+
+#include <stdlib.h>
+#include <string.h>
+
+#include "libretro.h"
+#include "retro_inline.h"
+
+#ifndef HAVE_NO_LANGEXTRA
+#include "libretro_core_options_intl.h"
+#endif
+
+/*
+ ********************************
+ * VERSION: 2.0
+ ********************************
+ *
+ * - 2.0: Add support for core options v2 interface
+ * - 1.3: Move translations to libretro_core_options_intl.h
+ *        - libretro_core_options_intl.h includes BOM and utf-8
+ *          fix for MSVC 2010-2013
+ *        - Added HAVE_NO_LANGEXTRA flag to disable translations
+ *          on platforms/compilers without BOM support
+ * - 1.2: Use core options v1 interface when
+ *        RETRO_ENVIRONMENT_GET_CORE_OPTIONS_VERSION is >= 1
+ *        (previously required RETRO_ENVIRONMENT_GET_CORE_OPTIONS_VERSION == 1)
+ * - 1.1: Support generation of core options v0 retro_core_option_value
+ *        arrays containing options with a single value
+ * - 1.0: First commit
+*/
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/*
+ ********************************
+ * Core Option Definitions
+ ********************************
+*/
+
+/* RETRO_LANGUAGE_ENGLISH */
+
+/* Default language:
+ * - All other languages must include the same keys and values
+ * - Will be used as a fallback in the event that frontend language
+ *   is not available
+ * - Will be used as a fallback for any missing entries in
+ *   frontend language definition */
+
+struct retro_core_option_v2_category option_cats_us[] = {
+   {
+      "console",
+      "Console Settings",
+      "Settings which control behavior of the various elements of the console."
+   },
+   {
+      "advanced",
+      "Advanced Settings",
+      "Settings which control internal emulator behavior. Use with care."
+   },
+   {
+      "enhancement",
+      "Enhancement Settings",
+      "Settings which control graphical rendering and enhancements."
+   },
+   {
+      "display",
+      "Display Settings",
+      "Settings which control how the image is displayed on the screen."
+   },
+   {
+      "port",
+      "Port Settings",
+      "Settings which control controller and memory card behavior."
+   },
+   { NULL, NULL, NULL },
+};
+
+struct retro_core_option_v2_definition option_defs_us[] = {
+   {
+      "duckstation_Console.Region",
+      "Console Region",
+      NULL,
+      "Determines which region/hardware to emulate. Auto-Detect will use the region of the disc inserted.",
+      NULL,
+      "console",
+      {
+         { "Auto",   "Auto-Detect" },
+         { "NTSC-J", "NTSC-J (Japan)" },
+         { "NTSC-U", "NTSC-U (US, Canada)" },
+         { "PAL",    "PAL (Europe, Australia)" },
+         { NULL, NULL },
+      },
+      "Auto"
+   },
+   {
+      "duckstation_BIOS.PathNTSCJ",
+      "NTSC-J BIOS (Restart)",
+      NULL,
+      "Select which standard BIOS to use for NTSC-J.",
+      NULL,
+      "console",
+      {
+         { "scph5500.bin", "SCPH5500" },
+         { "psxonpsp660.bin", "PSP" },
+         { "ps1_rom.bin", "PS3" },
+         { NULL, NULL },
+      },
+      "scph5500.bin"
+   },
+   {
+      "duckstation_BIOS.PathNTSCU",
+      "NTSC-U BIOS (Restart)",
+      NULL,
+      "Select which standard BIOS to use for NTSC-U.",
+      NULL,
+      "console",
+      {
+         { "scph5501.bin", "SCPH5501" },
+         { "psxonpsp660.bin", "PSP" },
+         { "ps1_rom.bin", "PS3" },
+         { NULL, NULL },
+      },
+      "scph5501.bin"
+   },
+   {
+      "duckstation_BIOS.PathPAL",
+      "PAL BIOS (Restart)",
+      NULL,
+      "Select which standard BIOS to use for PAL.",
+      NULL,
+      "console",
+      {
+         { "scph5502.bin", "SCPH5502" },
+         { "psxonpsp660.bin", "PSP" },
+         { "ps1_rom.bin", "PS3" },
+         { NULL, NULL },
+      },
+      "scph5502.bin"
+   },
+   {
+      "duckstation_BIOS.PatchFastBoot",
+      "Fast Boot",
+      NULL,
+      "Skips the BIOS shell/intro, booting directly into the game. Usually safe to enable, but some games break.",
+      NULL,
+      "console",
+      {
+         { "true",  "Enabled" },
+         { "false", "Disabled" },
+         { NULL, NULL },
+      },
+      "false"
+   },
+   {
+      "duckstation_CDROM.RegionCheck",
+      "CD-ROM Region Check",
+      NULL,
+      "Prevents discs from incorrect regions being read by the emulator. Usually safe to disable.",
+      NULL,
+      "console",
+      {
+         { "true",  "Enabled" },
+         { "false", "Disabled" },
+         { NULL, NULL },
+      },
+      "false"
+   },
+   {
+      "duckstation_CDROM.ReadThread",
+      "CD-ROM Read Thread",
+      NULL,
+      "Reads CD-ROM sectors ahead asynchronously, reducing the risk of frame time spikes.",
+      NULL,
+      "console",
+      {
+         { "true",  "Enabled" },
+         { "false", "Disabled" },
+         { NULL, NULL },
+      },
+      "true"
+   },
+   {
+      "duckstation_CDROM.LoadImagePatches",
+      "Apply Image Patches",
+      NULL,
+      "Automatically applies patches to disc images when they are present in the same directory. Currently only PPF "
+      "patches are supported with this option. Requires the core to be restarted to apply.",
+      NULL,
+      "console",
+      {
+         { "true",  "Enabled" },
+         { "false", "Disabled" },
+         { NULL, NULL },
+      },
+      "false"
+   },
+   {
+      "duckstation_CDROM.LoadImageToRAM",
+      "Preload CD-ROM Image To RAM",
+      NULL,
+      "Loads the disc image to RAM before starting emulation. May reduce hitching if you are running off a network share, "
+      "at a cost of a greater startup time. As libretro provides no way to draw overlays, the emulator will appear to "
+      "lock up while the image is preloaded.",
+      NULL,
+      "console",
+      {
+         { "true",  "Enabled" },
+         { "false", "Disabled" },
+         { NULL, NULL },
+      },
+      "false"
+   },
+   {
+      "duckstation_CDROM.MuteCDAudio",
+      "Mute CD Audio",
+      NULL,
+      "Forcibly mutes both CD-DA and XA audio from the CD-ROM. Can be used to disable background music in some games.",
+      NULL,
+      "console",
+      {
+         { "true",  "Enabled" },
+         { "false", "Disabled" },
+         { NULL, NULL },
+      },
+      "false"
+   },
+   {
+      "duckstation_CDROM.ReadSpeedup",
+      "CD-ROM Read Speedup",
+      NULL,
+      "Speeds up CD-ROM reads by the specified factor. Only applies to double-speed reads, and is ignored when audio "
+      "is playing. May improve loading speeds in some games, at the cost of breaking others.",
+      NULL,
+      "console",
+      {
+         { "1",  "None (Double Speed)" },
+         { "2",  "2x (Quad Speed)" },
+         { "3",  "3x (6x Speed)" },
+         { "4",  "4x (8x Speed)" },
+         { "5",  "5x (10x Speed)" },
+         { "6",  "6x (12x Speed)" },
+         { "7",  "7x (14x Speed)" },
+         { "8",  "8x (16x Speed)" },
+         { "9",  "9x (18x Speed)" },
+         { "10", "10x (20x Speed)" },
+         { NULL, NULL },
+      },
+      "1"
+   },
+   {
+      "duckstation_CDROM.SeekSpeedup",
+      "CD-ROM Seek Speedup",
+      NULL,
+      "Speeds up CD-ROM seeks by the specified factor. May improve loading speeds in some game, at "
+      "the cost of breaking others.",
+      NULL,
+      "console",
+      {
+         { "0",  "Infinite/Instantaneous" },
+         { "1",  "None (Double Speed)" },
+         { "2",  "2x (Quad Speed)" },
+         { "3",  "3x (6x Speed)" },
+         { "4",  "4x (8x Speed)" },
+         { "5",  "5x (10x Speed)" },
+         { "6",  "6x (12x Speed)" },
+         { "7",  "7x (14x Speed)" },
+         { "8",  "8x (16x Speed)" },
+         { "9",  "9x (18x Speed)" },
+         { "10", "10x (20x Speed)" },
+         { NULL, NULL },
+      },
+      "1"
+   },
+   {
+      "duckstation_CPU.ExecutionMode",
+      "CPU Execution Mode",
+      NULL,
+      "Which mode to use for CPU emulation. Recompiler provides the best performance.",
+      NULL,
+      "console",
+      {
+         { "Interpreter",      NULL },
+         { "CachedInterpreter", "Cached Interpreter" },
+         { "Recompiler",       NULL },
+         { NULL, NULL },
+      },
+      "Recompiler"
+   },
+   {
+      "duckstation_CDROM.ReadaheadSectors",
+      "CD-ROM Async Readahead",
+      NULL,
+      "Determines how far the CD-ROM thread will read ahead. Can reduce hitches on slow storage "
+      "mediums or with compressed games.",
+      NULL,
+      "advanced",
+      {
+         { "0",   "Disabled (Synchronous)" },
+         { "1",   "1 Sector (7KB / 2ms)" },
+         { "2",  "2 Sectors (13KB / 4ms)" },
+         { "3",  "3 Sectors (20KB / 6ms)" },
+         { "4",  "4 Sectors (27KB / 8ms)" },
+         { "5",  "5 Sectors (33KB / 10ms)" },
+         { "6",  "6 Sectors (40KB / 12ms)" },
+         { "7",  "7 Sectors (47KB / 14ms)" },
+         { "8",  "8 Sectors (53KB / 16ms)" },
+         { "9",  "9 Sectors (60KB / 18ms)" },
+         { "10",  "10 Sectors (67KB / 20ms)" },
+         { "11",  "11 Sectors (73KB / 22ms)" },
+         { "12",  "12 Sectors (80KB / 24ms)" },
+         { "13",  "13 Sectors (87KB / 26ms)" },
+         { "14",  "14 Sectors (93KB / 28ms)" },
+         { "15",  "15 Sectors (100KB / 30ms)" },
+         { "16",  "16 Sectors (107KB / 32ms)" },
+         { "17",  "17 Sectors (113KB / 34ms)" },
+         { "18",  "18 Sectors (120KB / 36ms)" },
+         { "19", "19 Sectors (127KB / 38ms)" },
+         { "20", "20 Sectors (133KB / 40ms)" },
+         { "21", "21 Sectors (140KB / 42ms)" },
+         { "22",  "22 Sectors (147KB / 44ms)" },
+         { "23",  "23 Sectors (153KB / 46ms)" },
+         { "24",  "24 Sectors (160KB / 48ms)" },
+         { "25",  "25 Sectors (167KB / 50ms)" },
+         { "26",  "26 Sectors (173KB / 52ms)" },
+         { "27",  "27 Sectors (180KB / 54ms)" },
+         { "28",  "28 Sectors (187KB / 56ms)" },
+         { "29", "29 Sectors (193KB / 58ms)" },
+         { "30",  "30 Sectors (200KB / 60ms)" },
+         { "31",  "31 Sectors (207KB / 62ms)" },
+         { "32", "32 Sectors (213KB / 64ms)" },
+         { NULL, NULL },
+      },
+      "8"
+   },
+   {
+      "duckstation_CPU.Overclock",
+      "CPU Overclocking",
+      NULL,
+      "Runs the emulated CPU faster or slower than native speed, which can improve framerates in some games. Will break "
+      "other games and increase system requirements, use with caution.",
+      NULL,
+      "advanced",
+      {
+         { "25",   "25%" },
+         { "50",   "50%" },
+         { "100",  "100% (Default)" },
+         { "125",  "125%" },
+         { "150",  "150%" },
+         { "175",  "175%" },
+         { "200",  "200%" },
+         { "225",  "225%" },
+         { "250",  "250%" },
+         { "275",  "275%" },
+         { "300",  "300%" },
+         { "350",  "350%" },
+         { "400",  "400%" },
+         { "450",  "450%" },
+         { "500",  "500%" },
+         { "600",  "600%" },
+         { "700",  "700%" },
+         { "800",  "800%" },
+         { "900",  "900%" },
+         { "1000", "1000%" },
+         { NULL, NULL },
+      },
+      "100"
+   },
+   {
+      "duckstation_GPU.Renderer",
+      "GPU Renderer",
+      NULL,
+      "Which renderer to use to emulate the GPU.",
+      NULL,
+      "enhancement",
+      {
+         { "Auto", "Hardware (Auto)" },
+#ifdef WIN32
+         { "D3D11", "Hardware (D3D11)" },
+#endif
+         { "OpenGL", "Hardware (OpenGL)" },
+         { "Vulkan", "Hardware (Vulkan)" },
+         { "Software", "Software" },
+         { NULL, NULL },
+      },
+#ifdef WIN32
+      "D3D11"
+#else
+      "Auto"
+#endif
+   },
+   {
+      "duckstation_GPU.ResolutionScale",
+      "Internal Resolution Scale",
+      NULL,
+      "Scales internal VRAM resolution by the specified multiplier for the hardware renderer. Larger values are slower. "
+      " Some games require 1x VRAM resolution or they will have rendering issues.",
+      NULL,
+      "enhancement",
+      {
+         { "1",  "1x" },
+         { "2",  "2x" },
+         { "3",  "3x (for 720p)" },
+         { "4",  "4x" },
+         { "5",  "5x (for 1080p)" },
+         { "6",  "6x (for 1440p)" },
+         { "7",  "7x" },
+         { "8",  "8x" },
+         { "9",  "9x (for 4K)" },
+         { "10", "10x" },
+         { "11", "11x" },
+         { "12", "12x" },
+         { "13", "13x" },
+         { "14", "14x" },
+         { "15", "15x" },
+         { "16", "16x" },
+         { NULL, NULL },
+      },
+      "1"
+   },
+   {
+      "duckstation_GPU.ResolutionSoftScale",
+      "Enhanced Resolution (Software)",
+      NULL,
+      "Renders in double resolution at the cost of lower performance.",
+      NULL,
+      "enhancement",
+      {
+         { "1",  "Disabled" },
+#ifndef ANDROID
+         { "2",  "Enabled" },
+#endif
+         { NULL, NULL },
+      },
+      "1"
+   },
+   {
+      "duckstation_GPU.UseThread",
+      "Threaded Rendering (Software)",
+      NULL,
+      "Uses a second thread for drawing graphics. Currently only available for the software renderer.",
+      NULL,
+      "enhancement",
+      {
+         { "true",  "Enabled" },
+         { "false", "Disabled" },
+         { NULL, NULL },
+      },
+      "true"
+   },
+   {
+      "duckstation_GPU.UseSoftwareRendererForReadbacks",
+      "Use Software Renderer For Readbacks",
+      NULL,
+      "Runs the software renderer in parallel for VRAM readbacks. On some systems, this may "
+      "result in greater performance when using graphical enhancements with the hardware renderer.",
+      NULL,
+      "enhancement",
+      {
+         { "true",  "Enabled" },
+         { "false", "Disabled" },
+         { NULL, NULL },
+      },
+      "false"
+   },
+   {
+      "duckstation_GPU.MSAA",
+      "Multisample Antialiasing",
+      NULL,
+      "Uses multisample antialiasing for rendering 3D objects. Can smooth out jagged edges on polygons at a lower "
+      "cost to performance compared to increasing the resolution scale, but may be more likely to cause rendering "
+      "errors in some games.",
+      NULL,
+      "enhancement",
+      {
+         { "1",       "Disabled" },
+         { "2",       "2x MSAA" },
+         { "4",       "4x MSAA" },
+         { "8",       "8x MSAA" },
+         { "16",      "16x MSAA" },
+         { "32",      "32x MSAA" },
+         { "2-ssaa",  "2x SSAA" },
+         { "4-ssaa",  "4x SSAA" },
+         { "8-ssaa",  "8x SSAA" },
+         { "16-ssaa", "16x SSAA" },
+         { "32-ssaa", "32x SSAA" },
+         { NULL, NULL },
+      },
+      "1"
+   },
+   {
+      "duckstation_GPU.TrueColor",
+      "True Color Rendering",
+      NULL,
+      "Disables dithering and uses the full 8 bits per channel of color information. May break rendering in some games.",
+      NULL,
+      "enhancement",
+      {
+         { "true",  "Enabled" },
+         { "false", "Disabled" },
+         { NULL, NULL },
+      },
+      "false"
+   },
+   {
+      "duckstation_GPU.ScaledDithering",
+      "Scaled Dithering",
+      NULL,
+      "Scales the dithering pattern with the internal rendering resolution, making it less noticeable. Usually safe to enable.",
+      NULL,
+      "enhancement",
+      {
+         { "true",  "Enabled" },
+         { "false", "Disabled" },
+         { NULL, NULL },
+      },
+      "true"
+   },
+   {
+      "duckstation_GPU.DisableInterlacing",
+      "Disable Interlacing",
+      NULL,
+      "Disables interlaced rendering and display in the GPU. Some games can render in 480p this way, but others will break.",
+      NULL,
+      "enhancement",
+      {
+         { "true",  "Enabled" },
+         { "false", "Disabled" },
+         { NULL, NULL },
+      },
+      "true"
+   },
+   {
+      "duckstation_GPU.ForceNTSCTimings",
+      "Force NTSC Timings",
+      NULL,
+      "Forces PAL games to run at NTSC timings, i.e. 60hz. Some PAL games will run at their \"normal\" speeds, while others will break.",
+      NULL,
+      "enhancement",
+      {
+         { "true",  "Enabled" },
+         { "false", "Disabled" },
+         { NULL, NULL },
+      },
+      "false"
+   },
+   {
+      "duckstation_Display.Force4_3For24Bit",
+      "Force 4:3 For 24-Bit Display",
+      NULL,
+      "Switches back to 4:3 display aspect ratio when displaying 24-bit content, usually FMVs.",
+      NULL,
+      "enhancement",
+      {
+         { "true",  "Enabled" },
+         { "false", "Disabled" },
+         { NULL, NULL },
+      },
+      "false"
+   },
+   {
+      "duckstation_GPU.ChromaSmoothing24Bit",
+      "Chroma Smoothing For 24-Bit Display",
+      NULL,
+      "Smooths out blockyness between colour transitions in 24-bit content, usually FMVs. Only applies to the hardware renderers.",
+      NULL,
+      "enhancement",
+      {
+         { "true",  "Enabled" },
+         { "false", "Disabled" },
+         { NULL, NULL },
+      },
+      "false"
+   },
+   {
+      "duckstation_GPU.TextureFilter",
+      "Texture Filtering",
+      NULL,
+      "Smooths out the blockyness of magnified textures on 3D object by using bilinear filtering. Will have a "
+      "greater effect on higher resolution scales. Only applies to the hardware renderers.",
+      NULL,
+      "enhancement",
+      {
+         { "Nearest",          "Nearest-Neighbor" },
+         { "Bilinear",         "Bilinear" },
+         { "BilinearBinAlpha", "Bilinear (No Edge Blending)" },
+         { "JINC2",            "JINC2" },
+         { "JINC2BinAlpha",    "JINC2 (No Edge Blending)" },
+         { "xBR",              "xBR" },
+         { "xBRBinAlpha",      "xBR (No Edge Blending)" },
+         { NULL, NULL },
+      },
+      "Nearest"
+   },
+   {
+      "duckstation_GPU.WidescreenHack",
+      "Widescreen Hack",
+      NULL,
+      "Increases the field of view from 4:3 to the chosen display aspect ratio in 3D games. For 2D games, or games which "
+      "use pre-rendered backgrounds, this enhancement will not work as expected.",
+      NULL,
+      "enhancement",
+      {
+         { "true",  "Enabled" },
+         { "false", "Disabled" },
+         { NULL, NULL },
+      },
+      "false"
+   },
+   {
+      "duckstation_GPU.PGXPEnable",
+      "PGXP Geometry Correction",
+      NULL,
+      "Reduces \"wobbly\" polygons by attempting to preserve the fractional component through memory transfers. Only "
+      "works with the hardware renderers, and may not be compatible with all games.",
+      NULL,
+      "enhancement",
+      {
+         { "true",  "Enabled" },
+         { "false", "Disabled" },
+         { NULL, NULL },
+      },
+      "false"
+   },
+   {
+      "duckstation_GPU.PGXPCulling",
+      "PGXP Culling Correction",
+      NULL,
+      "Increases the precision of polygon culling, reducing the number of holes in geometry. Requires geometry correction enabled.",
+      NULL,
+      "enhancement",
+      {
+         { "true",  "Enabled" },
+         { "false", "Disabled" },
+         { NULL, NULL },
+      },
+      "true"
+   },
+   {
+      "duckstation_GPU.PGXPTextureCorrection",
+      "PGXP Texture Correction",
+      NULL,
+      "Uses perspective-correct interpolation for texture coordinates and colors, straightening out warped textures. "
+      "Requires geometry correction enabled.",
+      NULL,
+      "enhancement",
+      {
+         { "true",  "Enabled" },
+         { "false", "Disabled" },
+         { NULL, NULL },
+      },
+      "true"
+   },
+   {
+      "duckstation_GPU.PGXPDepthBuffer",
+      "PGXP Depth Buffer",
+      NULL,
+      "Attempts to reduce polygon Z-fighting by testing pixels against the depth values from PGXP. Low compatibility, "
+      "but can work well in some games. Requires geometry correction enabled.",
+      NULL,
+      "enhancement",
+      {
+         { "true",  "Enabled" },
+         { "false", "Disabled" },
+         { NULL, NULL },
+      },
+      "false"
+   },
+   {
+      "duckstation_GPU.PGXPVertexCache",
+      "PGXP Vertex Cache",
+      NULL,
+      "Uses screen coordinates as a fallback when tracking vertices through memory fails. May improve PGXP compatibility.",
+      NULL,
+      "enhancement",
+      {
+         { "true",  "Enabled" },
+         { "false", "Disabled" },
+         { NULL, NULL },
+      },
+      "false"
+   },
+   {
+      "duckstation_GPU.PGXPCPU",
+      "PGXP CPU Mode",
+      NULL,
+      "Tries to track vertex manipulation through the CPU. Some games require this option for PGXP to be effective. "
+      "Very slow, and incompatible with the recompiler.",
+      NULL,
+      "enhancement",
+      {
+         { "true",  "Enabled" },
+         { "false", "Disabled" },
+         { NULL, NULL },
+      },
+      "false"
+   },
+   {
+      "duckstation_Display.AspectRatio",
+      "Aspect Ratio",
+      NULL,
+      "Sets the core-provided aspect ratio.",
+      NULL,
+      "display",
+      {
+         { "Auto",           "Auto (Game Native)" },
+         { "4:3",            "4:3" },
+         { "16:9",           "16:9" },
+         { "16:10",          "16:10" },
+         { "19:9",           "19:9" },
+         { "21:9",           "21:9" },
+         { "32:9",           "32:9" },
+         { "8:7",            "8:7" },
+         { "5:4",            "5:4" },
+         { "3:2",            "3:2" },
+         { "2:1 (VRAM 1:1)", "2:1 (VRAM 1:1)" },
+         { "1:1",            "1:1" },
+         { "PAR 1:1",        "PAR 1:1" },
+         { NULL, NULL },
+      },
+      "Auto"
+   },
+   {
+      "duckstation_Display.CropMode",
+      "Crop Mode",
+      NULL,
+      "Changes how much of the image is cropped. Some games display garbage in the overscan area which is typically hidden.",
+      NULL,
+      "display",
+      {
+         { "None",     "None" },
+         { "Overscan", "Only Overscan Area" },
+         { "Borders",  "All Borders" },
+         { NULL, NULL },
+      },
+      "Borders"
+   },
+   {
+      "duckstation_Display.LinearFiltering",
+      "Linear Upscaling",
+      NULL,
+      "Uses bilinear texture filtering when displaying the console's framebuffer to the screen. Disabling filtering will produce "
+      "a sharper, blockier/pixelated image. Enabling will smooth out the image. This option will be less noticable the higher "
+      "the resolution scale.",
+      NULL,
+      "display",
+      {
+         { "true",  "Enabled" },
+         { "false", "Disabled" },
+         { NULL, NULL },
+      },
+      "true"
+   },
+   {
+      "duckstation_GPU.DownsampleMode",
+      "Downsampling",
+      NULL,
+      "Downsamples the rendered image prior to displaying it. Can improve overall image quality in mixed 2D/3D games, but "
+      "should be disabled for pure 3D games. Only applies to the hardware renderers.",
+      NULL,
+      "display",
+      {
+         { "Disabled", NULL },
+         { "Box",      "Box (Downsample 3D/Smooth All)" },
+         { "Adaptive", "Adaptive (Preserve 3D/Smooth 2D)" },
+         { NULL, NULL },
+      },
+      "Disabled"
+   },
+   {
+      "duckstation_Main.LoadDevicesFromSaveStates",
+      "Load Devices From Save States",
+      NULL,
+      "Sets whether the contents of devices and memory cards will be loaded when a save state is loaded.",
+      NULL,
+      "port",
+      {
+         { "true",  "Enabled" },
+         { "false", "Disabled" },
+         { NULL, NULL },
+      },
+      "false"
+   },
+   {
+      "duckstation_MemoryCards.Card1Type",
+      "Memory Card 1 Type",
+      NULL,
+      "Sets the type of memory card for Slot 1. Restart core when switching to Libretro from other formats. "
+      "Libretro (.srm) and PerGameTitle (.mcd) saves have internally identical formats and can be converted " 
+      "between one another via renaming the extension and removing/adding the slot number (_1)",
+      NULL,
+      "port",
+      {
+         { "None",         "No Memory Card" },
+         { "Libretro",     NULL },
+         { "Shared",       "Shared Between All Games" },
+         { "PerGame",      "Separate Card Per Game (Game Code)" },
+         { "PerGameTitle", "Separate Card Per Game (Game Title)" },
+         { NULL, NULL },
+      },
+      "Libretro"
+   },
+   {
+      "duckstation_MemoryCards.Card2Type",
+      "Memory Card 2 Type",
+      NULL,
+      "Sets the type of memory card for Slot 2.",
+      NULL,
+      "port",
+      {
+         { "None",         "No Memory Card" },
+         { "Shared",       "Shared Between All Games" },
+         { "PerGame",      "Separate Card Per Game (Game Code)" },
+         { "PerGameTitle", "Separate Card Per Game (Game Title)" },
+         { NULL, NULL },
+      },
+      "None"
+   },
+   {
+      "duckstation_MemoryCards.UsePlaylistTitle",
+      "Use Single Card For Playlist",
+      NULL,
+      "When using a playlist (m3u) and per-game (title) memory cards, a single memory card "
+      "will be used for all discs. If unchecked, a separate card will be used for each disc.",
+      NULL,
+      "port",
+      {
+         { "true",  "Enabled" },
+         { "false", "Disabled" },
+         { NULL, NULL },
+      },
+      "true"
+   },
+   {
+      "duckstation_ControllerPorts.MultitapMode",
+      "Multitap Mode",
+      NULL,
+      "Sets the mode for the multitap.",
+      NULL,
+      "port",
+      {
+         { "Disabled",  NULL },
+         { "Port1Only", "Enable on Port 1 Only" },
+         { "Port2Only", "Enable on Port 2 Only" },
+         { "BothPorts", "Enable on Ports 1 and 2" },
+         { NULL, NULL },
+      },
+      "Disabled"
+   },
+   {
+      "duckstation_Controller1.ForceAnalogOnReset",
+      "Controller 1 Force Analog Mode on Reset",
+      NULL,
+      "Forces analog mode in Analog Controller (DualShock) at start/reset. May cause issues with some games. Only use "
+      "this option for games that support analog mode but do not automatically enable it themselves. When disabled, analog "
+      "mode can be toggled by pressing and holding L1+R1+L3+R3.",
+      NULL,
+      "port",
+      {
+         { "true",  "Enabled" },
+         { "false", "Disabled" },
+         { NULL, NULL },
+      },
+      "false"
+   },
+   {
+      "duckstation_Controller1.AnalogDPadInDigitalMode",
+      "Controller 1 Use Analog Sticks for D-Pad in Digital Mode",
+      NULL,
+      "Allows you to use the analog sticks to control the d-pad in digital mode, as well as the buttons.",
+      NULL,
+      "port",
+      {
+         { "true",  "Enabled" },
+         { "false", "Disabled" },
+         { NULL, NULL },
+      },
+      "true"
+   },
+   {
+      "duckstation_Controller1.AxisScale",
+      "Controller 1 Analog Axis Scale",
+      NULL,
+      "Sets the analog stick axis scaling factor.",
+      NULL,
+      "port",
+      {
+         { "1.00f", "1.00" },
+         { "1.40f", "1.40" },
+         { NULL, NULL },
+      },
+      "1.00f"
+   },
+   {
+      "duckstation_Controller1.VibrationBias",
+      "Controller 1 Vibration Bias",
+      NULL,
+      "Applies an offset to vibration intensities, higher values will make smaller vibrations more noticable.",
+      NULL,
+      "port",
+      {
+         { "0", NULL },
+         { "1", NULL },
+         { "2", NULL },
+         { "3", NULL },
+         { "4", NULL },
+         { "5", NULL },
+         { "6", NULL },
+         { "7", NULL },
+         { "8", NULL },
+         { "9", NULL },
+         { "10", NULL },
+         { "11", NULL },
+         { "12", NULL },
+         { "13", NULL },
+         { "14", NULL },
+         { "15", NULL },
+         { "16", NULL },
+         { "17", NULL },
+         { "18", NULL },
+         { "19", NULL },
+         { "20", NULL },
+         { "21", NULL },
+         { "22", NULL },
+         { "23", NULL },
+         { "24", NULL },
+         { "25", NULL },
+         { "26", NULL },
+         { "27", NULL },
+         { "28", NULL },
+         { "29", NULL },
+         { "30", NULL },
+         { "31", NULL },
+         { "32", NULL },
+         { "33", NULL },
+         { "34", NULL },
+         { "35", NULL },
+         { "36", NULL },
+         { "37", NULL },
+         { "38", NULL },
+         { "39", NULL },
+         { "40", NULL },
+         { "41", NULL },
+         { "42", NULL },
+         { "43", NULL },
+         { "44", NULL },
+         { "45", NULL },
+         { "46", NULL },
+         { "47", NULL },
+         { "48", NULL },
+         { "49", NULL },
+         { "50", NULL },
+         { "51", NULL },
+         { "52", NULL },
+         { "53", NULL },
+         { "54", NULL },
+         { "55", NULL },
+         { "56", NULL },
+         { "57", NULL },
+         { "58", NULL },
+         { "59", NULL },
+         { "60", NULL },
+         { "61", NULL },
+         { "62", NULL },
+         { "63", NULL },
+         { "64", NULL },
+         { "65", NULL },
+         { "66", NULL },
+         { "67", NULL },
+         { "68", NULL },
+         { "69", NULL },
+         { "70", NULL },
+         { "71", NULL },
+         { "72", NULL },
+         { "73", NULL },
+         { "74", NULL },
+         { "75", NULL },
+         { "76", NULL },
+         { "77", NULL },
+         { "78", NULL },
+         { "79", NULL },
+         { "80", NULL },
+         { "81", NULL },
+         { "82", NULL },
+         { "83", NULL },
+         { "84", NULL },
+         { "85", NULL },
+         { "86", NULL },
+         { "87", NULL },
+         { "88", NULL },
+         { "89", NULL },
+         { "90", NULL },
+         { "91", NULL },
+         { "92", NULL },
+         { "93", NULL },
+         { "94", NULL },
+         { "95", NULL },
+         { "96", NULL },
+         { "97", NULL },
+         { "98", NULL },
+         { "99", NULL },
+         { "100", NULL },
+         { "101", NULL },
+         { "102", NULL },
+         { "103", NULL },
+         { "104", NULL },
+         { "105", NULL },
+         { "106", NULL },
+         { "107", NULL },
+         { "108", NULL },
+         { "109", NULL },
+         { "110", NULL },
+         { "111", NULL },
+         { "112", NULL },
+         { "113", NULL },
+         { "114", NULL },
+         { "115", NULL },
+         { "116", NULL },
+         { "117", NULL },
+         { "118", NULL },
+         { "119", NULL },
+         { "120", NULL },
+         { "121", NULL },
+         { "122", NULL },
+         { "123", NULL },
+         { "124", NULL },
+         { "125", NULL },
+         { "126", NULL },
+         { NULL, NULL },
+      },
+      "8"
+   },
+   {
+      "duckstation_Controller1.XScale", 
+      "Controller 1 Lightgun X Scale",
+      NULL,
+      "Scales X coordinates relative to the center of the screen.",
+      NULL,
+     "port",
+     {
+         { "0.02", NULL },
+         { "0.04", NULL },
+         { "0.06", NULL },
+         { "0.08", NULL },
+         { "0.10", NULL },
+         { "0.12", NULL },
+         { "0.14", NULL },
+         { "0.16", NULL },
+         { "0.18", NULL },
+         { "0.20", NULL },
+         { "0.22", NULL },
+         { "0.24", NULL },
+         { "0.26", NULL },
+         { "0.28", NULL },
+         { "0.30", NULL },
+         { "0.32", NULL },
+         { "0.34", NULL },
+         { "0.36", NULL },
+         { "0.38", NULL },
+         { "0.40", NULL },
+         { "0.42", NULL },
+         { "0.44", NULL },
+         { "0.46", NULL },
+         { "0.48", NULL },
+         { "0.50", NULL },
+         { "0.52", NULL },
+         { "0.54", NULL },
+         { "0.56", NULL },
+         { "0.58", NULL },
+         { "0.60", NULL },
+         { "0.62", NULL },
+         { "0.64", NULL },
+         { "0.66", NULL },
+         { "0.68", NULL },
+         { "0.70", NULL },
+         { "0.72", NULL },
+         { "0.74", NULL },
+         { "0.76", NULL },
+         { "0.78", NULL },
+         { "0.80", NULL },
+         { "0.82", NULL },
+         { "0.84", NULL },
+         { "0.86", NULL },
+         { "0.88", NULL },
+         { "0.90", NULL },
+         { "0.92", NULL },
+         { "0.94", NULL },
+         { "0.96", NULL },
+         { "0.98", NULL },
+         { "1.00", NULL },
+         { "1.02", NULL },
+         { "1.04", NULL },
+         { "1.06", NULL },
+         { "1.08", NULL },
+         { "1.10", NULL },
+         { "1.12", NULL },
+         { "1.14", NULL },
+         { "1.16", NULL },
+         { "1.18", NULL },
+         { "1.20", NULL },
+         { "1.22", NULL },
+         { "1.24", NULL },
+         { "1.26", NULL },
+         { "1.28", NULL },
+         { "1.30", NULL },
+         { "1.32", NULL },
+         { "1.34", NULL },
+         { "1.36", NULL },
+         { "1.38", NULL },
+         { "1.40", NULL },
+         { "1.42", NULL },
+         { "1.44", NULL },
+         { "1.46", NULL },
+         { "1.48", NULL },
+         { "1.50", NULL },
+         { "1.52", NULL },
+         { "1.54", NULL },
+         { "1.56", NULL },
+         { "1.58", NULL },
+         { "1.60", NULL },
+         { "1.62", NULL },
+         { "1.64", NULL },
+         { "1.66", NULL },
+         { "1.68", NULL },
+         { "1.70", NULL },
+         { "1.72", NULL },
+         { "1.74", NULL },
+         { "1.76", NULL },
+         { "1.78", NULL },
+         { "1.80", NULL },
+         { "1.82", NULL },
+         { "1.84", NULL },
+         { "1.86", NULL },
+         { "1.88", NULL },
+         { "1.90", NULL },
+         { "1.92", NULL },
+         { "1.94", NULL },
+         { "1.96", NULL },
+         { "1.98", NULL },
+         { NULL, NULL },
+       },
+       "1.00"
+   },
+   {
+      "duckstation_Controller2.ForceAnalogOnReset",
+      "Controller 2 Force Analog Mode on Reset",
+      NULL,
+      "Forces analog mode in Analog Controller (DualShock) at start/reset. May cause issues with some games. Only use "
+      "this option for games that support analog mode but do not automatically enable it themselves. When disabled, analog "
+      "mode can be toggled by pressing and holding L1+R1+L3+R3.",
+      NULL,
+      "port",
+      {
+         { "true",  "Enabled" },
+         { "false", "Disabled" },
+         { NULL, NULL },
+      },
+      "false"
+   },
+   {
+      "duckstation_Controller2.AnalogDPadInDigitalMode",
+      "Controller 2 Use Analog Sticks for D-Pad in Digital Mode",
+      NULL,
+      "Allows you to use the analog sticks to control the d-pad in digital mode, as well as the buttons.",
+      NULL,
+      "port",
+      {
+         { "true",  "Enabled" },
+         { "false", "Disabled" },
+         { NULL, NULL },
+      },
+      "true"
+   },
+   {
+      "duckstation_Controller2.AxisScale",
+      "Controller 2 Analog Axis Scale",
+      NULL,
+      "Sets the analog stick axis scaling factor.",
+      NULL,
+      "port",
+      {
+         { "1.00f", "1.00" }, 
+         { "1.40f", "1.40" },
+         { NULL, NULL },
+      },
+      "1.00f"
+   },
+   {
+      "duckstation_Controller2.VibrationBias",
+      "Controller 2 Vibration Bias",
+      NULL,
+      "Applies an offset to vibration intensities, higher values will make smaller vibrations more noticable.",
+      NULL,
+      "port",
+      {
+         { "0", NULL },
+         { "1", NULL },
+         { "2", NULL },
+         { "3", NULL },
+         { "4", NULL },
+         { "5", NULL },
+         { "6", NULL },
+         { "7", NULL },
+         { "8", NULL },
+         { "9", NULL },
+         { "10", NULL },
+         { "11", NULL },
+         { "12", NULL },
+         { "13", NULL },
+         { "14", NULL },
+         { "15", NULL },
+         { "16", NULL },
+         { "17", NULL },
+         { "18", NULL },
+         { "19", NULL },
+         { "20", NULL },
+         { "21", NULL },
+         { "22", NULL },
+         { "23", NULL },
+         { "24", NULL },
+         { "25", NULL },
+         { "26", NULL },
+         { "27", NULL },
+         { "28", NULL },
+         { "29", NULL },
+         { "30", NULL },
+         { "31", NULL },
+         { "32", NULL },
+         { "33", NULL },
+         { "34", NULL },
+         { "35", NULL },
+         { "36", NULL },
+         { "37", NULL },
+         { "38", NULL },
+         { "39", NULL },
+         { "40", NULL },
+         { "41", NULL },
+         { "42", NULL },
+         { "43", NULL },
+         { "44", NULL },
+         { "45", NULL },
+         { "46", NULL },
+         { "47", NULL },
+         { "48", NULL },
+         { "49", NULL },
+         { "50", NULL },
+         { "51", NULL },
+         { "52", NULL },
+         { "53", NULL },
+         { "54", NULL },
+         { "55", NULL },
+         { "56", NULL },
+         { "57", NULL },
+         { "58", NULL },
+         { "59", NULL },
+         { "60", NULL },
+         { "61", NULL },
+         { "62", NULL },
+         { "63", NULL },
+         { "64", NULL },
+         { "65", NULL },
+         { "66", NULL },
+         { "67", NULL },
+         { "68", NULL },
+         { "69", NULL },
+         { "70", NULL },
+         { "71", NULL },
+         { "72", NULL },
+         { "73", NULL },
+         { "74", NULL },
+         { "75", NULL },
+         { "76", NULL },
+         { "77", NULL },
+         { "78", NULL },
+         { "79", NULL },
+         { "80", NULL },
+         { "81", NULL },
+         { "82", NULL },
+         { "83", NULL },
+         { "84", NULL },
+         { "85", NULL },
+         { "86", NULL },
+         { "87", NULL },
+         { "88", NULL },
+         { "89", NULL },
+         { "90", NULL },
+         { "91", NULL },
+         { "92", NULL },
+         { "93", NULL },
+         { "94", NULL },
+         { "95", NULL },
+         { "96", NULL },
+         { "97", NULL },
+         { "98", NULL },
+         { "99", NULL },
+         { "100", NULL },
+         { "101", NULL },
+         { "102", NULL },
+         { "103", NULL },
+         { "104", NULL },
+         { "105", NULL },
+         { "106", NULL },
+         { "107", NULL },
+         { "108", NULL },
+         { "109", NULL },
+         { "110", NULL },
+         { "111", NULL },
+         { "112", NULL },
+         { "113", NULL },
+         { "114", NULL },
+         { "115", NULL },
+         { "116", NULL },
+         { "117", NULL },
+         { "118", NULL },
+         { "119", NULL },
+         { "120", NULL },
+         { "121", NULL },
+         { "122", NULL },
+         { "123", NULL },
+         { "124", NULL },
+         { "125", NULL },
+         { "126", NULL },
+         { NULL, NULL },
+      },
+      "8"
+   },
+   {
+      "duckstation_Controller2.XScale", 
+      "Controller 2 Lightgun X Scale",
+      NULL,
+      "Scales X coordinates relative to the center of the screen.",
+      NULL,
+     "port",
+     {
+         { "0.02", NULL },
+         { "0.04", NULL },
+         { "0.06", NULL },
+         { "0.08", NULL },
+         { "0.10", NULL },
+         { "0.12", NULL },
+         { "0.14", NULL },
+         { "0.16", NULL },
+         { "0.18", NULL },
+         { "0.20", NULL },
+         { "0.22", NULL },
+         { "0.24", NULL },
+         { "0.26", NULL },
+         { "0.28", NULL },
+         { "0.30", NULL },
+         { "0.32", NULL },
+         { "0.34", NULL },
+         { "0.36", NULL },
+         { "0.38", NULL },
+         { "0.40", NULL },
+         { "0.42", NULL },
+         { "0.44", NULL },
+         { "0.46", NULL },
+         { "0.48", NULL },
+         { "0.50", NULL },
+         { "0.52", NULL },
+         { "0.54", NULL },
+         { "0.56", NULL },
+         { "0.58", NULL },
+         { "0.60", NULL },
+         { "0.62", NULL },
+         { "0.64", NULL },
+         { "0.66", NULL },
+         { "0.68", NULL },
+         { "0.70", NULL },
+         { "0.72", NULL },
+         { "0.74", NULL },
+         { "0.76", NULL },
+         { "0.78", NULL },
+         { "0.80", NULL },
+         { "0.82", NULL },
+         { "0.84", NULL },
+         { "0.86", NULL },
+         { "0.88", NULL },
+         { "0.90", NULL },
+         { "0.92", NULL },
+         { "0.94", NULL },
+         { "0.96", NULL },
+         { "0.98", NULL },
+         { "1.00", NULL },
+         { "1.02", NULL },
+         { "1.04", NULL },
+         { "1.06", NULL },
+         { "1.08", NULL },
+         { "1.10", NULL },
+         { "1.12", NULL },
+         { "1.14", NULL },
+         { "1.16", NULL },
+         { "1.18", NULL },
+         { "1.20", NULL },
+         { "1.22", NULL },
+         { "1.24", NULL },
+         { "1.26", NULL },
+         { "1.28", NULL },
+         { "1.30", NULL },
+         { "1.32", NULL },
+         { "1.34", NULL },
+         { "1.36", NULL },
+         { "1.38", NULL },
+         { "1.40", NULL },
+         { "1.42", NULL },
+         { "1.44", NULL },
+         { "1.46", NULL },
+         { "1.48", NULL },
+         { "1.50", NULL },
+         { "1.52", NULL },
+         { "1.54", NULL },
+         { "1.56", NULL },
+         { "1.58", NULL },
+         { "1.60", NULL },
+         { "1.62", NULL },
+         { "1.64", NULL },
+         { "1.66", NULL },
+         { "1.68", NULL },
+         { "1.70", NULL },
+         { "1.72", NULL },
+         { "1.74", NULL },
+         { "1.76", NULL },
+         { "1.78", NULL },
+         { "1.80", NULL },
+         { "1.82", NULL },
+         { "1.84", NULL },
+         { "1.86", NULL },
+         { "1.88", NULL },
+         { "1.90", NULL },
+         { "1.92", NULL },
+         { "1.94", NULL },
+         { "1.96", NULL },
+         { "1.98", NULL },
+         { NULL, NULL },
+       },
+       "1.00"
+   },
+   {
+      "duckstation_Controller3.ForceAnalogOnReset",
+      "Controller 3 Force Analog Mode on Reset",
+      NULL,
+      "Forces analog mode in Analog Controller (DualShock) at start/reset. May cause issues with some games. Only use "
+      "this option for games that support analog mode but do not automatically enable it themselves. When disabled, analog "
+      "mode can be toggled by pressing and holding L1+R1+L3+R3.",
+      NULL,
+      "port",
+      {
+         { "true",  "Enabled" },
+         { "false", "Disabled" },
+         { NULL, NULL },
+      },
+      "false"
+   },
+   {
+      "duckstation_Controller3.AnalogDPadInDigitalMode",
+      "Controller 3 Use Analog Sticks for D-Pad in Digital Mode",
+      NULL,
+      "Allows you to use the analog sticks to control the d-pad in digital mode, as well as the buttons.",
+      NULL,
+      "port",
+      {
+         { "true",  "Enabled" },
+         { "false", "Disabled" },
+         { NULL, NULL },
+      },
+      "true"
+   },
+   {
+      "duckstation_Controller3.AxisScale",
+      "Controller 3 Analog Axis Scale",
+      NULL,
+      "Sets the analog stick axis scaling factor.",
+      NULL,
+      "port",
+      {
+         { "1.00f", "1.00" }, 
+         { "1.40f", "1.40" },
+         { NULL, NULL },
+      },
+      "1.00f"
+   },
+   {
+      "duckstation_Controller3.VibrationBias",
+      "Controller 3 Vibration Bias",
+      NULL,
+      "Applies an offset to vibration intensities, higher values will make smaller vibrations more noticable.",
+      NULL,
+      "port",
+      {
+         { "0", NULL },
+         { "1", NULL },
+         { "2", NULL },
+         { "3", NULL },
+         { "4", NULL },
+         { "5", NULL },
+         { "6", NULL },
+         { "7", NULL },
+         { "8", NULL },
+         { "9", NULL },
+         { "10", NULL },
+         { "11", NULL },
+         { "12", NULL },
+         { "13", NULL },
+         { "14", NULL },
+         { "15", NULL },
+         { "16", NULL },
+         { "17", NULL },
+         { "18", NULL },
+         { "19", NULL },
+         { "20", NULL },
+         { "21", NULL },
+         { "22", NULL },
+         { "23", NULL },
+         { "24", NULL },
+         { "25", NULL },
+         { "26", NULL },
+         { "27", NULL },
+         { "28", NULL },
+         { "29", NULL },
+         { "30", NULL },
+         { "31", NULL },
+         { "32", NULL },
+         { "33", NULL },
+         { "34", NULL },
+         { "35", NULL },
+         { "36", NULL },
+         { "37", NULL },
+         { "38", NULL },
+         { "39", NULL },
+         { "40", NULL },
+         { "41", NULL },
+         { "42", NULL },
+         { "43", NULL },
+         { "44", NULL },
+         { "45", NULL },
+         { "46", NULL },
+         { "47", NULL },
+         { "48", NULL },
+         { "49", NULL },
+         { "50", NULL },
+         { "51", NULL },
+         { "52", NULL },
+         { "53", NULL },
+         { "54", NULL },
+         { "55", NULL },
+         { "56", NULL },
+         { "57", NULL },
+         { "58", NULL },
+         { "59", NULL },
+         { "60", NULL },
+         { "61", NULL },
+         { "62", NULL },
+         { "63", NULL },
+         { "64", NULL },
+         { "65", NULL },
+         { "66", NULL },
+         { "67", NULL },
+         { "68", NULL },
+         { "69", NULL },
+         { "70", NULL },
+         { "71", NULL },
+         { "72", NULL },
+         { "73", NULL },
+         { "74", NULL },
+         { "75", NULL },
+         { "76", NULL },
+         { "77", NULL },
+         { "78", NULL },
+         { "79", NULL },
+         { "80", NULL },
+         { "81", NULL },
+         { "82", NULL },
+         { "83", NULL },
+         { "84", NULL },
+         { "85", NULL },
+         { "86", NULL },
+         { "87", NULL },
+         { "88", NULL },
+         { "89", NULL },
+         { "90", NULL },
+         { "91", NULL },
+         { "92", NULL },
+         { "93", NULL },
+         { "94", NULL },
+         { "95", NULL },
+         { "96", NULL },
+         { "97", NULL },
+         { "98", NULL },
+         { "99", NULL },
+         { "100", NULL },
+         { "101", NULL },
+         { "102", NULL },
+         { "103", NULL },
+         { "104", NULL },
+         { "105", NULL },
+         { "106", NULL },
+         { "107", NULL },
+         { "108", NULL },
+         { "109", NULL },
+         { "110", NULL },
+         { "111", NULL },
+         { "112", NULL },
+         { "113", NULL },
+         { "114", NULL },
+         { "115", NULL },
+         { "116", NULL },
+         { "117", NULL },
+         { "118", NULL },
+         { "119", NULL },
+         { "120", NULL },
+         { "121", NULL },
+         { "122", NULL },
+         { "123", NULL },
+         { "124", NULL },
+         { "125", NULL },
+         { "126", NULL },
+         { NULL, NULL },
+      },
+      "8"
+   },
+   {
+      "duckstation_Controller4.ForceAnalogOnReset",
+      "Controller 4 Force Analog Mode on Reset",
+      NULL,
+      "Forces analog mode in Analog Controller (DualShock) at start/reset. May cause issues with some games. Only use "
+      "this option for games that support analog mode but do not automatically enable it themselves. When disabled, analog "
+      "mode can be toggled by pressing and holding L1+R1+L3+R3.",
+      NULL,
+      "port",
+      {
+         { "true",  "Enabled" },
+         { "false", "Disabled" },
+         { NULL, NULL },
+      },
+      "false"
+   },
+   {
+      "duckstation_Controller4.AnalogDPadInDigitalMode",
+      "Controller 4 Use Analog Sticks for D-Pad in Digital Mode",
+      NULL,
+      "Allows you to use the analog sticks to control the d-pad in digital mode, as well as the buttons.",
+      NULL,
+      "port",
+      {
+         { "true",  "Enabled" },
+         { "false", "Disabled" },
+         { NULL, NULL },
+      },
+      "true"
+   },
+   {
+      "duckstation_Controller4.AxisScale",
+      "Controller 4 Analog Axis Scale",
+      NULL,
+      "Sets the analog stick axis scaling factor.",
+      NULL,
+      "port",
+      {
+         { "1.00f", "1.00" }, 
+         { "1.40f", "1.40" },
+         { NULL, NULL },
+      },
+      "1.00f"
+   },
+   {
+      "duckstation_Controller4.VibrationBias",
+      "Controller 4 Vibration Bias",
+      NULL,
+      "Applies an offset to vibration intensities, higher values will make smaller vibrations more noticable.",
+      NULL,
+      "port",
+      {
+         { "0", NULL },
+         { "1", NULL },
+         { "2", NULL },
+         { "3", NULL },
+         { "4", NULL },
+         { "5", NULL },
+         { "6", NULL },
+         { "7", NULL },
+         { "8", NULL },
+         { "9", NULL },
+         { "10", NULL },
+         { "11", NULL },
+         { "12", NULL },
+         { "13", NULL },
+         { "14", NULL },
+         { "15", NULL },
+         { "16", NULL },
+         { "17", NULL },
+         { "18", NULL },
+         { "19", NULL },
+         { "20", NULL },
+         { "21", NULL },
+         { "22", NULL },
+         { "23", NULL },
+         { "24", NULL },
+         { "25", NULL },
+         { "26", NULL },
+         { "27", NULL },
+         { "28", NULL },
+         { "29", NULL },
+         { "30", NULL },
+         { "31", NULL },
+         { "32", NULL },
+         { "33", NULL },
+         { "34", NULL },
+         { "35", NULL },
+         { "36", NULL },
+         { "37", NULL },
+         { "38", NULL },
+         { "39", NULL },
+         { "40", NULL },
+         { "41", NULL },
+         { "42", NULL },
+         { "43", NULL },
+         { "44", NULL },
+         { "45", NULL },
+         { "46", NULL },
+         { "47", NULL },
+         { "48", NULL },
+         { "49", NULL },
+         { "50", NULL },
+         { "51", NULL },
+         { "52", NULL },
+         { "53", NULL },
+         { "54", NULL },
+         { "55", NULL },
+         { "56", NULL },
+         { "57", NULL },
+         { "58", NULL },
+         { "59", NULL },
+         { "60", NULL },
+         { "61", NULL },
+         { "62", NULL },
+         { "63", NULL },
+         { "64", NULL },
+         { "65", NULL },
+         { "66", NULL },
+         { "67", NULL },
+         { "68", NULL },
+         { "69", NULL },
+         { "70", NULL },
+         { "71", NULL },
+         { "72", NULL },
+         { "73", NULL },
+         { "74", NULL },
+         { "75", NULL },
+         { "76", NULL },
+         { "77", NULL },
+         { "78", NULL },
+         { "79", NULL },
+         { "80", NULL },
+         { "81", NULL },
+         { "82", NULL },
+         { "83", NULL },
+         { "84", NULL },
+         { "85", NULL },
+         { "86", NULL },
+         { "87", NULL },
+         { "88", NULL },
+         { "89", NULL },
+         { "90", NULL },
+         { "91", NULL },
+         { "92", NULL },
+         { "93", NULL },
+         { "94", NULL },
+         { "95", NULL },
+         { "96", NULL },
+         { "97", NULL },
+         { "98", NULL },
+         { "99", NULL },
+         { "100", NULL },
+         { "101", NULL },
+         { "102", NULL },
+         { "103", NULL },
+         { "104", NULL },
+         { "105", NULL },
+         { "106", NULL },
+         { "107", NULL },
+         { "108", NULL },
+         { "109", NULL },
+         { "110", NULL },
+         { "111", NULL },
+         { "112", NULL },
+         { "113", NULL },
+         { "114", NULL },
+         { "115", NULL },
+         { "116", NULL },
+         { "117", NULL },
+         { "118", NULL },
+         { "119", NULL },
+         { "120", NULL },
+         { "121", NULL },
+         { "122", NULL },
+         { "123", NULL },
+         { "124", NULL },
+         { "125", NULL },
+         { "126", NULL },
+         { NULL, NULL },
+      },
+      "8"
+   },
+   {
+      "duckstation_Controller5.ForceAnalogOnReset",
+      "Controller 5 Force Analog Mode on Reset",
+      NULL,
+      "Forces analog mode in Analog Controller (DualShock) at start/reset. May cause issues with some games. Only use "
+      "this option for games that support analog mode but do not automatically enable it themselves. When disabled, analog "
+      "mode can be toggled by pressing and holding L1+R1+L3+R3.",
+      NULL,
+      "port",
+      {
+         { "true",  "Enabled" },
+         { "false", "Disabled" },
+         { NULL, NULL },
+      },
+      "false"
+   },
+   {
+      "duckstation_Controller5.AnalogDPadInDigitalMode",
+      "Controller 5 Use Analog Sticks for D-Pad in Digital Mode",
+      NULL,
+      "Allows you to use the analog sticks to control the d-pad in digital mode, as well as the buttons.",
+      NULL,
+      "port",
+      {
+         { "true",  "Enabled" },
+         { "false", "Disabled" },
+         { NULL, NULL },
+      },
+      "true"
+   },
+   {
+      "duckstation_Controller5.AxisScale",
+      "Controller 5 Analog Axis Scale",
+      NULL,
+      "Sets the analog stick axis scaling factor.",
+      NULL,
+      "port",
+      {
+         { "1.00f", "1.00" },
+         { "1.40f", "1.40" },
+         { NULL, NULL },
+      },
+      "1.00f"
+   },
+   {
+      "duckstation_Controller5.VibrationBias",
+      "Controller 5 Vibration Bias",
+      NULL,
+      "Applies an offset to vibration intensities, higher values will make smaller vibrations more noticable.",
+      NULL,
+      "port",
+      {
+         { "0", NULL },
+         { "1", NULL },
+         { "2", NULL },
+         { "3", NULL },
+         { "4", NULL },
+         { "5", NULL },
+         { "6", NULL },
+         { "7", NULL },
+         { "8", NULL },
+         { "9", NULL },
+         { "10", NULL },
+         { "11", NULL },
+         { "12", NULL },
+         { "13", NULL },
+         { "14", NULL },
+         { "15", NULL },
+         { "16", NULL },
+         { "17", NULL },
+         { "18", NULL },
+         { "19", NULL },
+         { "20", NULL },
+         { "21", NULL },
+         { "22", NULL },
+         { "23", NULL },
+         { "24", NULL },
+         { "25", NULL },
+         { "26", NULL },
+         { "27", NULL },
+         { "28", NULL },
+         { "29", NULL },
+         { "30", NULL },
+         { "31", NULL },
+         { "32", NULL },
+         { "33", NULL },
+         { "34", NULL },
+         { "35", NULL },
+         { "36", NULL },
+         { "37", NULL },
+         { "38", NULL },
+         { "39", NULL },
+         { "40", NULL },
+         { "41", NULL },
+         { "42", NULL },
+         { "43", NULL },
+         { "44", NULL },
+         { "45", NULL },
+         { "46", NULL },
+         { "47", NULL },
+         { "48", NULL },
+         { "49", NULL },
+         { "50", NULL },
+         { "51", NULL },
+         { "52", NULL },
+         { "53", NULL },
+         { "54", NULL },
+         { "55", NULL },
+         { "56", NULL },
+         { "57", NULL },
+         { "58", NULL },
+         { "59", NULL },
+         { "60", NULL },
+         { "61", NULL },
+         { "62", NULL },
+         { "63", NULL },
+         { "64", NULL },
+         { "65", NULL },
+         { "66", NULL },
+         { "67", NULL },
+         { "68", NULL },
+         { "69", NULL },
+         { "70", NULL },
+         { "71", NULL },
+         { "72", NULL },
+         { "73", NULL },
+         { "74", NULL },
+         { "75", NULL },
+         { "76", NULL },
+         { "77", NULL },
+         { "78", NULL },
+         { "79", NULL },
+         { "80", NULL },
+         { "81", NULL },
+         { "82", NULL },
+         { "83", NULL },
+         { "84", NULL },
+         { "85", NULL },
+         { "86", NULL },
+         { "87", NULL },
+         { "88", NULL },
+         { "89", NULL },
+         { "90", NULL },
+         { "91", NULL },
+         { "92", NULL },
+         { "93", NULL },
+         { "94", NULL },
+         { "95", NULL },
+         { "96", NULL },
+         { "97", NULL },
+         { "98", NULL },
+         { "99", NULL },
+         { "100", NULL },
+         { "101", NULL },
+         { "102", NULL },
+         { "103", NULL },
+         { "104", NULL },
+         { "105", NULL },
+         { "106", NULL },
+         { "107", NULL },
+         { "108", NULL },
+         { "109", NULL },
+         { "110", NULL },
+         { "111", NULL },
+         { "112", NULL },
+         { "113", NULL },
+         { "114", NULL },
+         { "115", NULL },
+         { "116", NULL },
+         { "117", NULL },
+         { "118", NULL },
+         { "119", NULL },
+         { "120", NULL },
+         { "121", NULL },
+         { "122", NULL },
+         { "123", NULL },
+         { "124", NULL },
+         { "125", NULL },
+         { "126", NULL },
+         { NULL, NULL },
+      },
+      "8"
+   },
+   {
+      "duckstation_Controller6.ForceAnalogOnReset",
+      "Controller 6 Force Analog Mode on Reset",
+      NULL,
+      "Forces analog mode in Analog Controller (DualShock) at start/reset. May cause issues with some games. Only use "
+      "this option for games that support analog mode but do not automatically enable it themselves. When disabled, analog "
+      "mode can be toggled by pressing and holding L1+R1+L3+R3.",
+      NULL,
+      "port",
+      {
+         { "true",  "Enabled" },
+         { "false", "Disabled" },
+         { NULL, NULL },
+      },
+      "false"
+   },
+   {
+      "duckstation_Controller6.AnalogDPadInDigitalMode",
+      "Controller 6 Use Analog Sticks for D-Pad in Digital Mode",
+      NULL,
+      "Allows you to use the analog sticks to control the d-pad in digital mode, as well as the buttons.",
+      NULL,
+      "port",
+      {
+         { "true",  "Enabled" },
+         { "false", "Disabled" },
+         { NULL, NULL },
+      },
+      "true"
+   },
+   {
+      "duckstation_Controller6.AxisScale",
+      "Controller 6 Analog Axis Scale",
+      NULL,
+      "Sets the analog stick axis scaling factor.",
+      NULL,
+      "port",
+      {
+         { "1.00f", "1.00" },
+         { "1.40f", "1.40" },
+         { NULL, NULL },
+      },
+      "1.00f"
+   },
+   {
+      "duckstation_Controller6.VibrationBias",
+      "Controller 6 Vibration Bias",
+      NULL,
+      "Applies an offset to vibration intensities, higher values will make smaller vibrations more noticable.",
+      NULL,
+      "port",
+      {
+         { "0", NULL },
+         { "1", NULL },
+         { "2", NULL },
+         { "3", NULL },
+         { "4", NULL },
+         { "5", NULL },
+         { "6", NULL },
+         { "7", NULL },
+         { "8", NULL },
+         { "9", NULL },
+         { "10", NULL },
+         { "11", NULL },
+         { "12", NULL },
+         { "13", NULL },
+         { "14", NULL },
+         { "15", NULL },
+         { "16", NULL },
+         { "17", NULL },
+         { "18", NULL },
+         { "19", NULL },
+         { "20", NULL },
+         { "21", NULL },
+         { "22", NULL },
+         { "23", NULL },
+         { "24", NULL },
+         { "25", NULL },
+         { "26", NULL },
+         { "27", NULL },
+         { "28", NULL },
+         { "29", NULL },
+         { "30", NULL },
+         { "31", NULL },
+         { "32", NULL },
+         { "33", NULL },
+         { "34", NULL },
+         { "35", NULL },
+         { "36", NULL },
+         { "37", NULL },
+         { "38", NULL },
+         { "39", NULL },
+         { "40", NULL },
+         { "41", NULL },
+         { "42", NULL },
+         { "43", NULL },
+         { "44", NULL },
+         { "45", NULL },
+         { "46", NULL },
+         { "47", NULL },
+         { "48", NULL },
+         { "49", NULL },
+         { "50", NULL },
+         { "51", NULL },
+         { "52", NULL },
+         { "53", NULL },
+         { "54", NULL },
+         { "55", NULL },
+         { "56", NULL },
+         { "57", NULL },
+         { "58", NULL },
+         { "59", NULL },
+         { "60", NULL },
+         { "61", NULL },
+         { "62", NULL },
+         { "63", NULL },
+         { "64", NULL },
+         { "65", NULL },
+         { "66", NULL },
+         { "67", NULL },
+         { "68", NULL },
+         { "69", NULL },
+         { "70", NULL },
+         { "71", NULL },
+         { "72", NULL },
+         { "73", NULL },
+         { "74", NULL },
+         { "75", NULL },
+         { "76", NULL },
+         { "77", NULL },
+         { "78", NULL },
+         { "79", NULL },
+         { "80", NULL },
+         { "81", NULL },
+         { "82", NULL },
+         { "83", NULL },
+         { "84", NULL },
+         { "85", NULL },
+         { "86", NULL },
+         { "87", NULL },
+         { "88", NULL },
+         { "89", NULL },
+         { "90", NULL },
+         { "91", NULL },
+         { "92", NULL },
+         { "93", NULL },
+         { "94", NULL },
+         { "95", NULL },
+         { "96", NULL },
+         { "97", NULL },
+         { "98", NULL },
+         { "99", NULL },
+         { "100", NULL },
+         { "101", NULL },
+         { "102", NULL },
+         { "103", NULL },
+         { "104", NULL },
+         { "105", NULL },
+         { "106", NULL },
+         { "107", NULL },
+         { "108", NULL },
+         { "109", NULL },
+         { "110", NULL },
+         { "111", NULL },
+         { "112", NULL },
+         { "113", NULL },
+         { "114", NULL },
+         { "115", NULL },
+         { "116", NULL },
+         { "117", NULL },
+         { "118", NULL },
+         { "119", NULL },
+         { "120", NULL },
+         { "121", NULL },
+         { "122", NULL },
+         { "123", NULL },
+         { "124", NULL },
+         { "125", NULL },
+         { "126", NULL },
+         { NULL, NULL },
+      },
+      "8"
+   },
+   {
+      "duckstation_Controller7.ForceAnalogOnReset",
+      "Controller 7 Force Analog Mode on Reset",
+      NULL,
+      "Forces analog mode in Analog Controller (DualShock) at start/reset. May cause issues with some games. Only use "
+      "this option for games that support analog mode but do not automatically enable it themselves. When disabled, analog "
+      "mode can be toggled by pressing and holding L1+R1+L3+R3.",
+      NULL,
+      "port",
+      {
+         { "true",  "Enabled" },
+         { "false", "Disabled" },
+         { NULL, NULL },
+      },
+      "false"
+   },
+   {
+      "duckstation_Controller7.AnalogDPadInDigitalMode",
+      "Controller 7 Use Analog Sticks for D-Pad in Digital Mode",
+      NULL,
+      "Allows you to use the analog sticks to control the d-pad in digital mode, as well as the buttons.",
+      NULL,
+      "port",
+      {
+         { "true",  "Enabled" },
+         { "false", "Disabled" },
+         { NULL, NULL },
+      },
+      "true"
+   },
+   {
+      "duckstation_Controller7.AxisScale",
+      "Controller 7 Analog Axis Scale",
+      NULL,
+      "Sets the analog stick axis scaling factor.",
+      NULL,
+      "port",
+      {
+         { "1.00f", "1.00" },
+         { "1.40f", "1.40" },
+         { NULL, NULL },
+      },
+      "1.00f"
+   },
+   {
+      "duckstation_Controller7.VibrationBias",
+      "Controller 7 Vibration Bias",
+      NULL,
+      "Applies an offset to vibration intensities, higher values will make smaller vibrations more noticable.",
+      NULL,
+      "port",
+      {
+         { "0", NULL },
+         { "1", NULL },
+         { "2", NULL },
+         { "3", NULL },
+         { "4", NULL },
+         { "5", NULL },
+         { "6", NULL },
+         { "7", NULL },
+         { "8", NULL },
+         { "9", NULL },
+         { "10", NULL },
+         { "11", NULL },
+         { "12", NULL },
+         { "13", NULL },
+         { "14", NULL },
+         { "15", NULL },
+         { "16", NULL },
+         { "17", NULL },
+         { "18", NULL },
+         { "19", NULL },
+         { "20", NULL },
+         { "21", NULL },
+         { "22", NULL },
+         { "23", NULL },
+         { "24", NULL },
+         { "25", NULL },
+         { "26", NULL },
+         { "27", NULL },
+         { "28", NULL },
+         { "29", NULL },
+         { "30", NULL },
+         { "31", NULL },
+         { "32", NULL },
+         { "33", NULL },
+         { "34", NULL },
+         { "35", NULL },
+         { "36", NULL },
+         { "37", NULL },
+         { "38", NULL },
+         { "39", NULL },
+         { "40", NULL },
+         { "41", NULL },
+         { "42", NULL },
+         { "43", NULL },
+         { "44", NULL },
+         { "45", NULL },
+         { "46", NULL },
+         { "47", NULL },
+         { "48", NULL },
+         { "49", NULL },
+         { "50", NULL },
+         { "51", NULL },
+         { "52", NULL },
+         { "53", NULL },
+         { "54", NULL },
+         { "55", NULL },
+         { "56", NULL },
+         { "57", NULL },
+         { "58", NULL },
+         { "59", NULL },
+         { "60", NULL },
+         { "61", NULL },
+         { "62", NULL },
+         { "63", NULL },
+         { "64", NULL },
+         { "65", NULL },
+         { "66", NULL },
+         { "67", NULL },
+         { "68", NULL },
+         { "69", NULL },
+         { "70", NULL },
+         { "71", NULL },
+         { "72", NULL },
+         { "73", NULL },
+         { "74", NULL },
+         { "75", NULL },
+         { "76", NULL },
+         { "77", NULL },
+         { "78", NULL },
+         { "79", NULL },
+         { "80", NULL },
+         { "81", NULL },
+         { "82", NULL },
+         { "83", NULL },
+         { "84", NULL },
+         { "85", NULL },
+         { "86", NULL },
+         { "87", NULL },
+         { "88", NULL },
+         { "89", NULL },
+         { "90", NULL },
+         { "91", NULL },
+         { "92", NULL },
+         { "93", NULL },
+         { "94", NULL },
+         { "95", NULL },
+         { "96", NULL },
+         { "97", NULL },
+         { "98", NULL },
+         { "99", NULL },
+         { "100", NULL },
+         { "101", NULL },
+         { "102", NULL },
+         { "103", NULL },
+         { "104", NULL },
+         { "105", NULL },
+         { "106", NULL },
+         { "107", NULL },
+         { "108", NULL },
+         { "109", NULL },
+         { "110", NULL },
+         { "111", NULL },
+         { "112", NULL },
+         { "113", NULL },
+         { "114", NULL },
+         { "115", NULL },
+         { "116", NULL },
+         { "117", NULL },
+         { "118", NULL },
+         { "119", NULL },
+         { "120", NULL },
+         { "121", NULL },
+         { "122", NULL },
+         { "123", NULL },
+         { "124", NULL },
+         { "125", NULL },
+         { "126", NULL },
+         { NULL, NULL },
+      },
+      "8"
+   },
+   {
+      "duckstation_Controller8.ForceAnalogOnReset",
+      "Controller 8 Force Analog Mode on Reset",
+      NULL,
+      "Forces analog mode in Analog Controller (DualShock) at start/reset. May cause issues with some games. Only use "
+      "this option for games that support analog mode but do not automatically enable it themselves. When disabled, analog "
+      "mode can be toggled by pressing and holding L1+R1+L3+R3.",
+      NULL,
+      "port",
+      {
+         { "true",  "Enabled" },
+         { "false", "Disabled" },
+         { NULL, NULL },
+      },
+      "false"
+   },
+   {
+      "duckstation_Controller8.AnalogDPadInDigitalMode",
+      "Controller 8 Use Analog Sticks for D-Pad in Digital Mode",
+      NULL,
+      "Allows you to use the analog sticks to control the d-pad in digital mode, as well as the buttons.",
+      NULL,
+      "port",
+      {
+         { "true",  "Enabled" },
+         { "false", "Disabled" },
+         { NULL, NULL },
+      },
+      "true"
+   },
+   {
+      "duckstation_Controller8.AxisScale",
+      "Controller 8 Analog Axis Scale",
+      NULL,
+      "Sets the analog stick axis scaling factor.",
+      NULL,
+      "port",
+      {
+         { "1.00f", "1.00" },
+         { "1.40f", "1.40" },
+         { NULL, NULL },
+      },
+      "1.00f"
+   },
+   {
+      "duckstation_Controller8.VibrationBias",
+      "Controller 8 Vibration Bias",
+      NULL,
+      "Applies an offset to vibration intensities, higher values will make smaller vibrations more noticable.",
+      NULL,
+      "port",
+      {
+         { "0", NULL },
+         { "1", NULL },
+         { "2", NULL },
+         { "3", NULL },
+         { "4", NULL },
+         { "5", NULL },
+         { "6", NULL },
+         { "7", NULL },
+         { "8", NULL },
+         { "9", NULL },
+         { "10", NULL },
+         { "11", NULL },
+         { "12", NULL },
+         { "13", NULL },
+         { "14", NULL },
+         { "15", NULL },
+         { "16", NULL },
+         { "17", NULL },
+         { "18", NULL },
+         { "19", NULL },
+         { "20", NULL },
+         { "21", NULL },
+         { "22", NULL },
+         { "23", NULL },
+         { "24", NULL },
+         { "25", NULL },
+         { "26", NULL },
+         { "27", NULL },
+         { "28", NULL },
+         { "29", NULL },
+         { "30", NULL },
+         { "31", NULL },
+         { "32", NULL },
+         { "33", NULL },
+         { "34", NULL },
+         { "35", NULL },
+         { "36", NULL },
+         { "37", NULL },
+         { "38", NULL },
+         { "39", NULL },
+         { "40", NULL },
+         { "41", NULL },
+         { "42", NULL },
+         { "43", NULL },
+         { "44", NULL },
+         { "45", NULL },
+         { "46", NULL },
+         { "47", NULL },
+         { "48", NULL },
+         { "49", NULL },
+         { "50", NULL },
+         { "51", NULL },
+         { "52", NULL },
+         { "53", NULL },
+         { "54", NULL },
+         { "55", NULL },
+         { "56", NULL },
+         { "57", NULL },
+         { "58", NULL },
+         { "59", NULL },
+         { "60", NULL },
+         { "61", NULL },
+         { "62", NULL },
+         { "63", NULL },
+         { "64", NULL },
+         { "65", NULL },
+         { "66", NULL },
+         { "67", NULL },
+         { "68", NULL },
+         { "69", NULL },
+         { "70", NULL },
+         { "71", NULL },
+         { "72", NULL },
+         { "73", NULL },
+         { "74", NULL },
+         { "75", NULL },
+         { "76", NULL },
+         { "77", NULL },
+         { "78", NULL },
+         { "79", NULL },
+         { "80", NULL },
+         { "81", NULL },
+         { "82", NULL },
+         { "83", NULL },
+         { "84", NULL },
+         { "85", NULL },
+         { "86", NULL },
+         { "87", NULL },
+         { "88", NULL },
+         { "89", NULL },
+         { "90", NULL },
+         { "91", NULL },
+         { "92", NULL },
+         { "93", NULL },
+         { "94", NULL },
+         { "95", NULL },
+         { "96", NULL },
+         { "97", NULL },
+         { "98", NULL },
+         { "99", NULL },
+         { "100", NULL },
+         { "101", NULL },
+         { "102", NULL },
+         { "103", NULL },
+         { "104", NULL },
+         { "105", NULL },
+         { "106", NULL },
+         { "107", NULL },
+         { "108", NULL },
+         { "109", NULL },
+         { "110", NULL },
+         { "111", NULL },
+         { "112", NULL },
+         { "113", NULL },
+         { "114", NULL },
+         { "115", NULL },
+         { "116", NULL },
+         { "117", NULL },
+         { "118", NULL },
+         { "119", NULL },
+         { "120", NULL },
+         { "121", NULL },
+         { "122", NULL },
+         { "123", NULL },
+         { "124", NULL },
+         { "125", NULL },
+         { "126", NULL },
+         { NULL, NULL },
+      },
+      "8"
+   },
+   {
+      "duckstation_Display.ShowOSDMessages",
+      "Display OSD Messages",
+      NULL,
+      "Shows on-screen messages generated by the core.",
+      NULL,
+      "display",
+      {
+         { "true",  "Enabled" },
+         { "false", "Disabled" },
+         { NULL, NULL },
+      },
+      "true"
+   },
+   {
+      "duckstation_Main.ApplyGameSettings",
+      "Apply Compatibility Settings",
+      NULL,
+      "Automatically disables enhancements on games which are incompatible.",
+      NULL,
+      "advanced",
+      {
+         { "true",  "Enabled" },
+         { "false", "Disabled" },
+         { NULL, NULL },
+      },
+      "true"
+   },
+   {
+      "duckstation_Logging.LogLevel",
+      "Log Level",
+      NULL,
+      "Sets the level of information logged by the core.",
+      NULL,
+      "advanced",
+      {
+         { "None",    "None" },
+         { "Error",   "Error" },
+         { "Warning", "Warning" },
+         { "Perf",    "Performance" },
+         { "Success", "Success" },
+         { "Info",    "Information" },
+         { "Dev",     "Developer" },
+         { "Profile", "Profile" },
+         { "Debug",   "Debug" },
+         { "Trace",   "Trace" },
+         { NULL, NULL },
+      },
+      "Info"
+   },
+   {
+      "duckstation_CPU.RecompilerICache",
+      "CPU Recompiler ICache",
+      NULL,
+      "Determines whether the CPU's instruction cache is simulated in the recompiler. Improves accuracy at a small cost "
+      "to performance. If games are running too fast, try enabling this option.",
+      NULL,
+      "advanced",
+      {
+         { "true",  "Enabled" },
+         { "false", "Disabled" },
+         { NULL, NULL },
+      },
+      "false"
+   },
+   {
+      "duckstation_CPU.RecompilerBlockLinking",
+      "CPU Recompiler Block Linking",
+      NULL,
+      "Enables the generated code to directly jump between blocks without going through the "
+      "dispatcher. Provides a measurable speed boost.",
+      NULL,
+      "advanced",
+      {
+         { "true",  "Enabled" },
+         { "false", "Disabled" },
+         { NULL, NULL },
+      },
+      "true"
+   },
+   {
+      "duckstation_CPU.FastmemMode",
+      "CPU Recompiler Fast Memory Access",
+      NULL,
+      "Uses page faults to determine hardware memory accesses at runtime. Can provide a significant performance "
+      "improvement in some games, but make the core more difficult to debug.",
+      NULL,
+      "advanced",
+      {
+         {"Disabled", "Disabled (Slower)"},
+         {"LUT",      "LUT (Faster)"},
+#if defined(CPU_X64) || defined(CPU_AARCH64)
+         {"MMap",     "MMap (Hardware, Fastest, 64-Bit Only)"},
+#endif
+         { NULL, NULL },
+      },
+      "LUT"
+   },
+   {
+      "duckstation_CPU.FastmemRewrite",
+      "CPU Recompiler Fast Memory Access Rewrite",
+      NULL,
+      "Enables rewrites when CPU Recompiler Fast Memory Access is enabled. Can provide a measurable speed boost, "
+      "but may cause the core to segfault on certain platforms.",
+      NULL,
+      "advanced",
+      {
+         { "true",  "Enabled" },
+         { "false", "Disabled" },
+         { NULL, NULL },
+      },
+      "false"
+   },
+   {
+      "duckstation_Debug.ShowVRAM",
+      "Show VRAM",
+      NULL,
+      "Shows the entirety of the console's VRAM instead of the display area (debugging feature).",
+      NULL,
+      "advanced",
+      {
+         { "true",  "Enabled" },
+         { "false", "Disabled" },
+         { NULL, NULL },
+      },
+      "false"
+   },
+   {
+      "duckstation_Display.ActiveStartOffset",
+      "Display Active Start Offset",
+      NULL,
+      "Pads or crops off lines from the left of the displayed image.",
+      NULL,
+      "display",
+      {
+         { "-30", NULL },
+         { "-29", NULL },
+         { "-28", NULL },
+         { "-27", NULL },
+         { "-26", NULL },
+         { "-25", NULL },
+         { "-24", NULL },
+         { "-23", NULL },
+         { "-22", NULL },
+         { "-21", NULL },
+         { "-20", NULL },
+         { "-19", NULL },
+         { "-18", NULL },
+         { "-17", NULL },
+         { "-16", NULL },
+         { "-15", NULL },
+         { "-14", NULL },
+         { "-13", NULL },
+         { "-12", NULL },
+         { "-11", NULL },
+         { "-10", NULL },
+         { "-9",  NULL },
+         { "-8",  NULL },
+         { "-7",  NULL },
+         { "-6",  NULL },
+         { "-5",  NULL },
+         { "-4",  NULL },
+         { "-3",  NULL },
+         { "-2",  NULL },
+         { "-1",  NULL },
+         { "0",   NULL },
+         { "1",   NULL },
+         { "2",   NULL },
+         { "3",   NULL },
+         { "4",   NULL },
+         { "5",   NULL },
+         { "6",   NULL },
+         { "7",   NULL },
+         { "8",   NULL },
+         { "9",   NULL },
+         { "10",  NULL },
+         { "11",  NULL },
+         { "12",  NULL },
+         { "13",  NULL },
+         { "14",  NULL },
+         { "15",  NULL },
+         { "16",  NULL },
+         { "17",  NULL },
+         { "18",  NULL },
+         { "19",  NULL },
+         { "20",  NULL },
+         { "21",  NULL },
+         { "22",  NULL },
+         { "23",  NULL },
+         { "24",  NULL },
+         { "25",  NULL },
+         { "26",  NULL },
+         { "27",  NULL },
+         { "28",  NULL },
+         { "29",  NULL },
+         { "30",  NULL },
+         { NULL,  NULL },
+      },
+      "0"
+   },
+   {
+      "duckstation_Display.ActiveEndOffset",
+      "Display Active End Offset",
+      NULL,
+      "Pads or crops off lines from the right of the displayed image.",
+      NULL,
+      "display",
+      {
+         { "-30", NULL },
+         { "-29", NULL },
+         { "-28", NULL },
+         { "-27", NULL },
+         { "-26", NULL },
+         { "-25", NULL },
+         { "-24", NULL },
+         { "-23", NULL },
+         { "-22", NULL },
+         { "-21", NULL },
+         { "-20", NULL },
+         { "-19", NULL },
+         { "-18", NULL },
+         { "-17", NULL },
+         { "-16", NULL },
+         { "-15", NULL },
+         { "-14", NULL },
+         { "-13", NULL },
+         { "-12", NULL },
+         { "-11", NULL },
+         { "-10", NULL },
+         { "-9",  NULL },
+         { "-8",  NULL },
+         { "-7",  NULL },
+         { "-6",  NULL },
+         { "-5",  NULL },
+         { "-4",  NULL },
+         { "-3",  NULL },
+         { "-2",  NULL },
+         { "-1",  NULL },
+         { "0",   NULL },
+         { "1",   NULL },
+         { "2",   NULL },
+         { "3",   NULL },
+         { "4",   NULL },
+         { "5",   NULL },
+         { "6",   NULL },
+         { "7",   NULL },
+         { "8",   NULL },
+         { "9",   NULL },
+         { "10",  NULL },
+         { "11",  NULL },
+         { "12",  NULL },
+         { "13",  NULL },
+         { "14",  NULL },
+         { "15",  NULL },
+         { "16",  NULL },
+         { "17",  NULL },
+         { "18",  NULL },
+         { "19",  NULL },
+         { "20",  NULL },
+         { "21",  NULL },
+         { "22",  NULL },
+         { "23",  NULL },
+         { "24",  NULL },
+         { "25",  NULL },
+         { "26",  NULL },
+         { "27",  NULL },
+         { "28",  NULL },
+         { "29",  NULL },
+         { "30",  NULL },
+         { NULL,  NULL },
+      },
+      "0"
+   },
+   {
+      "duckstation_Display.LineStartOffset",
+      "Display Line Start Offset",
+      NULL,
+      "Pads or crops off lines from the top of the displayed image.",
+      NULL,
+      "display",
+      {
+         { "-30", NULL },
+         { "-29", NULL },
+         { "-28", NULL },
+         { "-27", NULL },
+         { "-26", NULL },
+         { "-25", NULL },
+         { "-24", NULL },
+         { "-23", NULL },
+         { "-22", NULL },
+         { "-21", NULL },
+         { "-20", NULL },
+         { "-19", NULL },
+         { "-18", NULL },
+         { "-17", NULL },
+         { "-16", NULL },
+         { "-15", NULL },
+         { "-14", NULL },
+         { "-13", NULL },
+         { "-12", NULL },
+         { "-11", NULL },
+         { "-10", NULL },
+         { "-9",  NULL },
+         { "-8",  NULL },
+         { "-7",  NULL },
+         { "-6",  NULL },
+         { "-5",  NULL },
+         { "-4",  NULL },
+         { "-3",  NULL },
+         { "-2",  NULL },
+         { "-1",  NULL },
+         { "0",   NULL },
+         { "1",   NULL },
+         { "2",   NULL },
+         { "3",   NULL },
+         { "4",   NULL },
+         { "5",   NULL },
+         { "6",   NULL },
+         { "7",   NULL },
+         { "8",   NULL },
+         { "9",   NULL },
+         { "10",  NULL },
+         { "11",  NULL },
+         { "12",  NULL },
+         { "13",  NULL },
+         { "14",  NULL },
+         { "15",  NULL },
+         { "16",  NULL },
+         { "17",  NULL },
+         { "18",  NULL },
+         { "19",  NULL },
+         { "20",  NULL },
+         { "21",  NULL },
+         { "22",  NULL },
+         { "23",  NULL },
+         { "24",  NULL },
+         { "25",  NULL },
+         { "26",  NULL },
+         { "27",  NULL },
+         { "28",  NULL },
+         { "29",  NULL },
+         { "30",  NULL },
+         { NULL,  NULL },
+      },
+      "0"
+   },
+   {
+      "duckstation_Display.LineEndOffset",
+      "Display Line End Offset",
+      NULL,
+      "Pads or crops off lines from the bottom of the displayed image.",
+      NULL,
+      "display",
+      {
+         { "-30", NULL },
+         { "-29", NULL },
+         { "-28", NULL },
+         { "-27", NULL },
+         { "-26", NULL },
+         { "-25", NULL },
+         { "-24", NULL },
+         { "-23", NULL },
+         { "-22", NULL },
+         { "-21", NULL },
+         { "-20", NULL },
+         { "-19", NULL },
+         { "-18", NULL },
+         { "-17", NULL },
+         { "-16", NULL },
+         { "-15", NULL },
+         { "-14", NULL },
+         { "-13", NULL },
+         { "-12", NULL },
+         { "-11", NULL },
+         { "-10", NULL },
+         { "-9",  NULL },
+         { "-8",  NULL },
+         { "-7",  NULL },
+         { "-6",  NULL },
+         { "-5",  NULL },
+         { "-4",  NULL },
+         { "-3",  NULL },
+         { "-2",  NULL },
+         { "-1",  NULL },
+         { "0",   NULL },
+         { "1",   NULL },
+         { "2",   NULL },
+         { "3",   NULL },
+         { "4",   NULL },
+         { "5",   NULL },
+         { "6",   NULL },
+         { "7",   NULL },
+         { "8",   NULL },
+         { "9",   NULL },
+         { "10",  NULL },
+         { "11",  NULL },
+         { "12",  NULL },
+         { "13",  NULL },
+         { "14",  NULL },
+         { "15",  NULL },
+         { "16",  NULL },
+         { "17",  NULL },
+         { "18",  NULL },
+         { "19",  NULL },
+         { "20",  NULL },
+         { "21",  NULL },
+         { "22",  NULL },
+         { "23",  NULL },
+         { "24",  NULL },
+         { "25",  NULL },
+         { "26",  NULL },
+         { "27",  NULL },
+         { "28",  NULL },
+         { "29",  NULL },
+         { "30",  NULL },
+         { NULL,  NULL },
+      },
+      "0"
+   },
+   {
+      "duckstation_GPU.PGXPPreserveProjFP",
+      "PGXP Preserve Projection Precision",
+      NULL,
+      "Enables additional precision for PGXP. May improve visuals in some games but break others.",
+      NULL,
+      "enhancement",
+      {
+         { "true",  "Enabled" },
+         { "false", "Disabled" },
+         { NULL, NULL },
+      },
+      "false"
+   },
+   {
+      "duckstation_GPU.PGXPTolerance",
+      "PGXP Geometry Tolerance",
+      NULL,
+      "Ignores precise positions if the difference exceeds this threshold.",
+      NULL,
+      "enhancement",
+      {
+         {"-1.0", "None"},
+         {"0.5",  "0.5 pixels"},
+         {"1.0",  "1.0 pixels"},
+         {"1.5",  "1.5 pixels"},
+         {"2.0",  "2.0 pixels"},
+         {"2.5",  "2.5 pixels"},
+         {"3.0",  "3.0 pixels"},
+         {"3.5",  "3.5 pixels"},
+         {"4.0",  "4.0 pixels"},
+         {"4.5",  "4.5 pixels"},
+         {"5.0",  "5.0 pixels"},
+         {"5.5",  "5.5 pixels"},
+         {"6.0",  "6.0 pixels"},
+         {"6.5",  "6.5 pixels"},
+         {"7.0",  "7.0 pixels"},
+         {"7.5",  "7.5 pixels"},
+         {"8.0",  "8.0 pixels"},
+         {"8.5",  "8.5 pixels"},
+         {"9.0",  "9.0 pixels"},
+         {"9.5",  "9.0 pixels"},
+         {"10.0", "10.0 pixels"},
+         { NULL, NULL },
+      },
+      "-1.0"
+   },
+   {
+      "duckstation_Main.RunaheadFrameCount",
+      "Internal Run-Ahead",
+      NULL,
+      "Simulates the system ahead of time and rolls back/replays to reduce input lag. Has very high system "
+      "requirements.",
+      NULL,
+      "advanced",
+      {
+         {"0", "0 Frames (Disabled)"},
+         {"1", "1 Frame"},
+         {"2", "2 Frames"},
+         {"3", "3 Frames"},
+         {"4", "4 Frames"},
+         {"5", "5 Frames"},
+         {"6", "6 Frames"},
+         {"7", "7 Frames"},
+         {"8", "8 Frames"},
+         {"9", "9 Frames"},
+         {"10", "10 Frames"},
+         { NULL, NULL },
+      },
+      "0"
+   },
+   {
+      "duckstation_Console.Enable8MBRAM",
+      "Enable 8MB RAM (Dev Console)",
+      NULL,
+      "Enabled an additional 6MB of RAM, usually present on dev consoles. Games have to use a "
+      "larger heap size for this additional RAM to be usable, and may break games which rely "
+      "on memory mirroring, so it should only be used with compatible mods.",
+      NULL,
+      "advanced",
+      {
+         { "true",  "Enabled" },
+         { "false", "Disabled" },
+         { NULL, NULL },
+      },
+      "false"
+   },
+   { NULL, NULL, NULL, NULL, NULL, NULL, {{0}}, NULL },
+};
+
+struct retro_core_options_v2 options_us = {
+   option_cats_us,
+   option_defs_us
+};
+
+/*
+ ********************************
+ * Language Mapping
+ ********************************
+*/
+
+#ifndef HAVE_NO_LANGEXTRA
+struct retro_core_options_v2 *options_intl[RETRO_LANGUAGE_LAST] = {
+   &options_us,    /* RETRO_LANGUAGE_ENGLISH */
+   NULL,           /* RETRO_LANGUAGE_JAPANESE */
+   NULL,           /* RETRO_LANGUAGE_FRENCH */
+   NULL,           /* RETRO_LANGUAGE_SPANISH */
+   NULL,           /* RETRO_LANGUAGE_GERMAN */
+   NULL,           /* RETRO_LANGUAGE_ITALIAN */
+   NULL,           /* RETRO_LANGUAGE_DUTCH */
+   NULL,           /* RETRO_LANGUAGE_PORTUGUESE_BRAZIL */
+   NULL,           /* RETRO_LANGUAGE_PORTUGUESE_PORTUGAL */
+   NULL,           /* RETRO_LANGUAGE_RUSSIAN */
+   NULL,           /* RETRO_LANGUAGE_KOREAN */
+   NULL,           /* RETRO_LANGUAGE_CHINESE_TRADITIONAL */
+   NULL,           /* RETRO_LANGUAGE_CHINESE_SIMPLIFIED */
+   NULL,           /* RETRO_LANGUAGE_ESPERANTO */
+   NULL,           /* RETRO_LANGUAGE_POLISH */
+   NULL,           /* RETRO_LANGUAGE_VIETNAMESE */
+   NULL,           /* RETRO_LANGUAGE_ARABIC */
+   NULL,           /* RETRO_LANGUAGE_GREEK */
+   NULL,           /* RETRO_LANGUAGE_TURKISH */
+};
+#endif
+
+/*
+ ********************************
+ * Functions
+ ********************************
+*/
+
+/* Handles configuration/setting of core options.
+ * Should be called as early as possible - ideally inside
+ * retro_set_environment(), and no later than retro_load_game()
+ * > We place the function body in the header to avoid the
+ *   necessity of adding more .c files (i.e. want this to
+ *   be as painless as possible for core devs)
+ */
+
+static INLINE void libretro_set_core_options(retro_environment_t g_retro_environment_callback,
+      bool *categories_supported)
+{
+   unsigned version  = 0;
+#ifndef HAVE_NO_LANGEXTRA
+   unsigned language = 0;
+#endif
+
+   if (!g_retro_environment_callback || !categories_supported)
+      return;
+
+   *categories_supported = false;
+
+   if (!g_retro_environment_callback(RETRO_ENVIRONMENT_GET_CORE_OPTIONS_VERSION, &version))
+      version = 0;
+
+   if (version >= 2)
+   {
+#ifndef HAVE_NO_LANGEXTRA
+      struct retro_core_options_v2_intl core_options_intl;
+
+      core_options_intl.us    = &options_us;
+      core_options_intl.local = NULL;
+
+      if (g_retro_environment_callback(RETRO_ENVIRONMENT_GET_LANGUAGE, &language) &&
+          (language < RETRO_LANGUAGE_LAST) && (language != RETRO_LANGUAGE_ENGLISH))
+         core_options_intl.local = options_intl[language];
+
+      *categories_supported = g_retro_environment_callback(RETRO_ENVIRONMENT_SET_CORE_OPTIONS_V2_INTL,
+            &core_options_intl);
+#else
+      *categories_supported = g_retro_environment_callback(RETRO_ENVIRONMENT_SET_CORE_OPTIONS_V2,
+            &options_us);
+#endif
+   }
+   else
+   {
+      size_t i, j;
+      size_t option_index              = 0;
+      size_t num_options               = 0;
+      struct retro_core_option_definition
+            *option_v1_defs_us         = NULL;
+#ifndef HAVE_NO_LANGEXTRA
+      size_t num_options_intl          = 0;
+      struct retro_core_option_v2_definition
+            *option_defs_intl          = NULL;
+      struct retro_core_option_definition
+            *option_v1_defs_intl       = NULL;
+      struct retro_core_options_intl
+            core_options_v1_intl;
+#endif
+      struct retro_variable *variables = NULL;
+      char **values_buf                = NULL;
+
+      /* Determine total number of options */
+      while (true)
+      {
+         if (option_defs_us[num_options].key)
+            num_options++;
+         else
+            break;
+      }
+
+      if (version >= 1)
+      {
+         /* Allocate US array */
+         option_v1_defs_us = (struct retro_core_option_definition *)
+               calloc(num_options + 1, sizeof(struct retro_core_option_definition));
+
+         /* Copy parameters from option_defs_us array */
+         for (i = 0; i < num_options; i++)
+         {
+            struct retro_core_option_v2_definition *option_def_us = &option_defs_us[i];
+            struct retro_core_option_value *option_values         = option_def_us->values;
+            struct retro_core_option_definition *option_v1_def_us = &option_v1_defs_us[i];
+            struct retro_core_option_value *option_v1_values      = option_v1_def_us->values;
+
+            option_v1_def_us->key           = option_def_us->key;
+            option_v1_def_us->desc          = option_def_us->desc;
+            option_v1_def_us->info          = option_def_us->info;
+            option_v1_def_us->default_value = option_def_us->default_value;
+
+            /* Values must be copied individually... */
+            while (option_values->value)
+            {
+               option_v1_values->value = option_values->value;
+               option_v1_values->label = option_values->label;
+
+               option_values++;
+               option_v1_values++;
+            }
+         }
+
+#ifndef HAVE_NO_LANGEXTRA
+         if (g_retro_environment_callback(RETRO_ENVIRONMENT_GET_LANGUAGE, &language) &&
+             (language < RETRO_LANGUAGE_LAST) && (language != RETRO_LANGUAGE_ENGLISH) &&
+             options_intl[language])
+            option_defs_intl = options_intl[language]->definitions;
+
+         if (option_defs_intl)
+         {
+            /* Determine number of intl options */
+            while (true)
+            {
+               if (option_defs_intl[num_options_intl].key)
+                  num_options_intl++;
+               else
+                  break;
+            }
+
+            /* Allocate intl array */
+            option_v1_defs_intl = (struct retro_core_option_definition *)
+                  calloc(num_options_intl + 1, sizeof(struct retro_core_option_definition));
+
+            /* Copy parameters from option_defs_intl array */
+            for (i = 0; i < num_options_intl; i++)
+            {
+               struct retro_core_option_v2_definition *option_def_intl = &option_defs_intl[i];
+               struct retro_core_option_value *option_values           = option_def_intl->values;
+               struct retro_core_option_definition *option_v1_def_intl = &option_v1_defs_intl[i];
+               struct retro_core_option_value *option_v1_values        = option_v1_def_intl->values;
+
+               option_v1_def_intl->key           = option_def_intl->key;
+               option_v1_def_intl->desc          = option_def_intl->desc;
+               option_v1_def_intl->info          = option_def_intl->info;
+               option_v1_def_intl->default_value = option_def_intl->default_value;
+
+               /* Values must be copied individually... */
+               while (option_values->value)
+               {
+                  option_v1_values->value = option_values->value;
+                  option_v1_values->label = option_values->label;
+
+                  option_values++;
+                  option_v1_values++;
+               }
+            }
+         }
+
+         core_options_v1_intl.us    = option_v1_defs_us;
+         core_options_v1_intl.local = option_v1_defs_intl;
+
+         g_retro_environment_callback(RETRO_ENVIRONMENT_SET_CORE_OPTIONS_INTL, &core_options_v1_intl);
+#else
+         g_retro_environment_callback(RETRO_ENVIRONMENT_SET_CORE_OPTIONS, option_v1_defs_us);
+#endif
+      }
+      else
+      {
+         /* Allocate arrays */
+         variables  = (struct retro_variable *)calloc(num_options + 1,
+               sizeof(struct retro_variable));
+         values_buf = (char **)calloc(num_options, sizeof(char *));
+
+         if (!variables || !values_buf)
+            goto error;
+
+         /* Copy parameters from option_defs_us array */
+         for (i = 0; i < num_options; i++)
+         {
+            const char *key                        = option_defs_us[i].key;
+            const char *desc                       = option_defs_us[i].desc;
+            const char *default_value              = option_defs_us[i].default_value;
+            struct retro_core_option_value *values = option_defs_us[i].values;
+            size_t buf_len                         = 3;
+            size_t default_index                   = 0;
+
+            values_buf[i] = NULL;
+
+            if (desc)
+            {
+               size_t num_values = 0;
+
+               /* Determine number of values */
+               while (true)
+               {
+                  if (values[num_values].value)
+                  {
+                     /* Check if this is the default value */
+                     if (default_value)
+                        if (strcmp(values[num_values].value, default_value) == 0)
+                           default_index = num_values;
+
+                     buf_len += strlen(values[num_values].value);
+                     num_values++;
+                  }
+                  else
+                     break;
+               }
+
+               /* Build values string */
+               if (num_values > 0)
+               {
+                  buf_len += num_values - 1;
+                  buf_len += strlen(desc);
+
+                  values_buf[i] = (char *)calloc(buf_len, sizeof(char));
+                  if (!values_buf[i])
+                     goto error;
+
+                  strcpy(values_buf[i], desc);
+                  strcat(values_buf[i], "; ");
+
+                  /* Default value goes first */
+                  strcat(values_buf[i], values[default_index].value);
+
+                  /* Add remaining values */
+                  for (j = 0; j < num_values; j++)
+                  {
+                     if (j != default_index)
+                     {
+                        strcat(values_buf[i], "|");
+                        strcat(values_buf[i], values[j].value);
+                     }
+                  }
+               }
+            }
+
+            variables[option_index].key   = key;
+            variables[option_index].value = values_buf[i];
+            option_index++;
+         }
+
+         /* Set variables */
+         g_retro_environment_callback(RETRO_ENVIRONMENT_SET_VARIABLES, variables);
+      }
+
+error:
+      /* Clean up */
+
+      if (option_v1_defs_us)
+      {
+         free(option_v1_defs_us);
+         option_v1_defs_us = NULL;
+      }
+
+#ifndef HAVE_NO_LANGEXTRA
+      if (option_v1_defs_intl)
+      {
+         free(option_v1_defs_intl);
+         option_v1_defs_intl = NULL;
+      }
+#endif
+
+      if (values_buf)
+      {
+         for (i = 0; i < num_options; i++)
+         {
+            if (values_buf[i])
+            {
+               free(values_buf[i]);
+               values_buf[i] = NULL;
+            }
+         }
+
+         free(values_buf);
+         values_buf = NULL;
+      }
+
+      if (variables)
+      {
+         free(variables);
+         variables = NULL;
+      }
+   }
+}
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
diff -Naur duckstation-51041e47f70123eda41d999701f5651830a0a95e.orig/src/duckstation-libretro/libretro_core_options_intl.h duckstation-51041e47f70123eda41d999701f5651830a0a95e/src/duckstation-libretro/libretro_core_options_intl.h
--- duckstation-51041e47f70123eda41d999701f5651830a0a95e.orig/src/duckstation-libretro/libretro_core_options_intl.h	1970-01-01 01:00:00.000000000 +0100
+++ duckstation-51041e47f70123eda41d999701f5651830a0a95e/src/duckstation-libretro/libretro_core_options_intl.h	2022-01-12 18:30:18.000000000 +0000
@@ -0,0 +1,80 @@
+﻿#ifndef LIBRETRO_CORE_OPTIONS_INTL_H__
+#define LIBRETRO_CORE_OPTIONS_INTL_H__
+
+#if defined(_MSC_VER) && (_MSC_VER >= 1500 && _MSC_VER < 1900)
+/* https://support.microsoft.com/en-us/kb/980263 */
+#pragma execution_character_set("utf-8")
+#pragma warning(disable:4566)
+#endif
+
+#include "libretro.h"
+
+/*
+ ********************************
+ * VERSION: 1.3
+ ********************************
+ *
+ * - 1.3: Move translations to libretro_core_options_intl.h
+ *        - libretro_core_options_intl.h includes BOM and utf-8
+ *          fix for MSVC 2010-2013
+ *        - Added HAVE_NO_LANGEXTRA flag to disable translations
+ *          on platforms/compilers without BOM support
+ * - 1.2: Use core options v1 interface when
+ *        RETRO_ENVIRONMENT_GET_CORE_OPTIONS_VERSION is >= 1
+ *        (previously required RETRO_ENVIRONMENT_GET_CORE_OPTIONS_VERSION == 1)
+ * - 1.1: Support generation of core options v0 retro_core_option_value
+ *        arrays containing options with a single value
+ * - 1.0: First commit
+*/
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/*
+ ********************************
+ * Core Option Definitions
+ ********************************
+*/
+
+/* RETRO_LANGUAGE_JAPANESE */
+
+/* RETRO_LANGUAGE_FRENCH */
+
+/* RETRO_LANGUAGE_SPANISH */
+
+/* RETRO_LANGUAGE_GERMAN */
+
+/* RETRO_LANGUAGE_ITALIAN */
+
+/* RETRO_LANGUAGE_DUTCH */
+
+/* RETRO_LANGUAGE_PORTUGUESE_BRAZIL */
+
+/* RETRO_LANGUAGE_PORTUGUESE_PORTUGAL */
+
+/* RETRO_LANGUAGE_RUSSIAN */
+
+/* RETRO_LANGUAGE_KOREAN */
+
+/* RETRO_LANGUAGE_CHINESE_TRADITIONAL */
+
+/* RETRO_LANGUAGE_CHINESE_SIMPLIFIED */
+
+/* RETRO_LANGUAGE_ESPERANTO */
+
+/* RETRO_LANGUAGE_POLISH */
+
+/* RETRO_LANGUAGE_VIETNAMESE */
+
+/* RETRO_LANGUAGE_ARABIC */
+
+/* RETRO_LANGUAGE_GREEK */
+
+/* RETRO_LANGUAGE_TURKISH */
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
diff -Naur duckstation-51041e47f70123eda41d999701f5651830a0a95e.orig/src/duckstation-libretro/libretro_d3d11_host_display.cpp duckstation-51041e47f70123eda41d999701f5651830a0a95e/src/duckstation-libretro/libretro_d3d11_host_display.cpp
--- duckstation-51041e47f70123eda41d999701f5651830a0a95e.orig/src/duckstation-libretro/libretro_d3d11_host_display.cpp	1970-01-01 01:00:00.000000000 +0100
+++ duckstation-51041e47f70123eda41d999701f5651830a0a95e/src/duckstation-libretro/libretro_d3d11_host_display.cpp	2022-01-12 18:30:18.000000000 +0000
@@ -0,0 +1,512 @@
+#include "libretro_d3d11_host_display.h"
+#include "common/align.h"
+#include "common/assert.h"
+#include "common/d3d11/shader_cache.h"
+#include "common/d3d11/shader_compiler.h"
+#include "common/log.h"
+#include "common/string_util.h"
+#include "core/host_interface.h"
+#include "core/settings.h"
+#include "core/shader_cache_version.h"
+#include "frontend-common/display_ps.hlsl.h"
+#include "frontend-common/display_ps_alpha.hlsl.h"
+#include "frontend-common/display_vs.hlsl.h"
+#include "libretro_host_interface.h"
+#include <array>
+Log_SetChannel(LibretroD3D11HostDisplay);
+
+#define HAVE_D3D11
+#include "libretro_d3d.h"
+
+class LibretroD3D11HostDisplayTexture : public HostDisplayTexture
+{
+public:
+  LibretroD3D11HostDisplayTexture(D3D11::Texture texture, HostDisplayPixelFormat format, bool dynamic)
+    : m_texture(std::move(texture)), m_format(format), m_dynamic(dynamic)
+  {
+  }
+  ~LibretroD3D11HostDisplayTexture() override = default;
+
+  void* GetHandle() const override { return m_texture.GetD3DSRV(); }
+  u32 GetWidth() const override { return m_texture.GetWidth(); }
+  u32 GetHeight() const override { return m_texture.GetHeight(); }
+  u32 GetLayers() const override { return 1; }
+  u32 GetLevels() const override { return m_texture.GetLevels(); }
+  u32 GetSamples() const override { return m_texture.GetSamples(); }
+  HostDisplayPixelFormat GetFormat() const override { return m_format; }
+
+  ALWAYS_INLINE ID3D11Texture2D* GetD3DTexture() const { return m_texture.GetD3DTexture(); }
+  ALWAYS_INLINE ID3D11ShaderResourceView* GetD3DSRV() const { return m_texture.GetD3DSRV(); }
+  ALWAYS_INLINE ID3D11ShaderResourceView* const* GetD3DSRVArray() const { return m_texture.GetD3DSRVArray(); }
+  ALWAYS_INLINE bool IsDynamic() const { return m_dynamic; }
+
+private:
+  D3D11::Texture m_texture;
+  HostDisplayPixelFormat m_format;
+  bool m_dynamic;
+};
+
+LibretroD3D11HostDisplay::LibretroD3D11HostDisplay() = default;
+
+LibretroD3D11HostDisplay::~LibretroD3D11HostDisplay()
+{
+  AssertMsg(!m_context, "Context should have been destroyed by now");
+}
+
+HostDisplay::RenderAPI LibretroD3D11HostDisplay::GetRenderAPI() const
+{
+  return HostDisplay::RenderAPI::D3D11;
+}
+
+void* LibretroD3D11HostDisplay::GetRenderDevice() const
+{
+  return m_device.Get();
+}
+
+void* LibretroD3D11HostDisplay::GetRenderContext() const
+{
+  return m_context.Get();
+}
+
+bool LibretroD3D11HostDisplay::HasRenderDevice() const
+{
+  return static_cast<bool>(m_device);
+}
+
+bool LibretroD3D11HostDisplay::HasRenderSurface() const
+{
+  return true;
+}
+
+static constexpr std::array<DXGI_FORMAT, static_cast<u32>(HostDisplayPixelFormat::Count)>
+  s_display_pixel_format_mapping = {{DXGI_FORMAT_UNKNOWN, DXGI_FORMAT_R8G8B8A8_UNORM, DXGI_FORMAT_B8G8R8A8_UNORM,
+                                     DXGI_FORMAT_B5G6R5_UNORM, DXGI_FORMAT_B5G5R5A1_UNORM}};
+
+std::unique_ptr<HostDisplayTexture> LibretroD3D11HostDisplay::CreateTexture(u32 width, u32 height, u32 layers,
+                                                                            u32 levels, u32 samples,
+                                                                            HostDisplayPixelFormat format,
+                                                                            const void* data, u32 data_stride,
+                                                                            bool dynamic /* = false */)
+{
+  if (layers != 1)
+    return {};
+
+  D3D11::Texture tex;
+  if (!tex.Create(m_device.Get(), width, height, levels, samples,
+                  s_display_pixel_format_mapping[static_cast<u32>(format)], D3D11_BIND_SHADER_RESOURCE, data,
+                  data_stride, dynamic))
+  {
+    return {};
+  }
+
+  return std::make_unique<LibretroD3D11HostDisplayTexture>(std::move(tex), format, dynamic);
+}
+
+void LibretroD3D11HostDisplay::UpdateTexture(HostDisplayTexture* texture, u32 x, u32 y, u32 width, u32 height,
+                                             const void* texture_data, u32 texture_data_stride)
+{
+  LibretroD3D11HostDisplayTexture* d3d11_texture = static_cast<LibretroD3D11HostDisplayTexture*>(texture);
+  if (!d3d11_texture->IsDynamic())
+  {
+    const CD3D11_BOX dst_box(x, y, 0, x + width, y + height, 1);
+    m_context->UpdateSubresource(d3d11_texture->GetD3DTexture(), 0, &dst_box, texture_data, texture_data_stride,
+                                 texture_data_stride * height);
+  }
+  else
+  {
+    D3D11_MAPPED_SUBRESOURCE sr;
+    HRESULT hr = m_context->Map(d3d11_texture->GetD3DTexture(), 0, D3D11_MAP_WRITE_DISCARD, 0, &sr);
+    if (FAILED(hr))
+      Panic("Failed to map dynamic host display texture");
+
+    char* dst_ptr = static_cast<char*>(sr.pData) + (y * sr.RowPitch) + (x * sizeof(u32));
+    const char* src_ptr = static_cast<const char*>(texture_data);
+    if (sr.RowPitch == texture_data_stride)
+    {
+      std::memcpy(dst_ptr, src_ptr, texture_data_stride * height);
+    }
+    else
+    {
+      for (u32 row = 0; row < height; row++)
+      {
+        std::memcpy(dst_ptr, src_ptr, width * sizeof(u32));
+        src_ptr += texture_data_stride;
+        dst_ptr += sr.RowPitch;
+      }
+    }
+
+    m_context->Unmap(d3d11_texture->GetD3DTexture(), 0);
+  }
+}
+
+bool LibretroD3D11HostDisplay::DownloadTexture(const void* texture_handle, HostDisplayPixelFormat texture_format, u32 x,
+                                               u32 y, u32 width, u32 height, void* out_data, u32 out_data_stride)
+{
+  ID3D11ShaderResourceView* srv =
+    const_cast<ID3D11ShaderResourceView*>(static_cast<const ID3D11ShaderResourceView*>(texture_handle));
+  ComPtr<ID3D11Resource> srv_resource;
+  D3D11_SHADER_RESOURCE_VIEW_DESC srv_desc;
+  srv->GetResource(srv_resource.GetAddressOf());
+  srv->GetDesc(&srv_desc);
+
+  if (!m_readback_staging_texture.EnsureSize(m_context.Get(), width, height, srv_desc.Format, false))
+    return false;
+
+  m_readback_staging_texture.CopyFromTexture(m_context.Get(), srv_resource.Get(), 0, x, y, 0, 0, width, height);
+
+  if (srv_desc.Format == DXGI_FORMAT_B5G6R5_UNORM || srv_desc.Format == DXGI_FORMAT_B5G5R5A1_UNORM)
+  {
+    return m_readback_staging_texture.ReadPixels<u16>(m_context.Get(), 0, 0, width, height, out_data_stride,
+                                                      static_cast<u16*>(out_data));
+  }
+  else
+  {
+    return m_readback_staging_texture.ReadPixels<u32>(m_context.Get(), 0, 0, width, height, out_data_stride,
+                                                      static_cast<u32*>(out_data));
+  }
+}
+
+bool LibretroD3D11HostDisplay::SupportsDisplayPixelFormat(HostDisplayPixelFormat format) const
+{
+  const DXGI_FORMAT dfmt = s_display_pixel_format_mapping[static_cast<u32>(format)];
+  if (dfmt == DXGI_FORMAT_UNKNOWN)
+    return false;
+
+  UINT support = 0;
+  const UINT required = D3D11_FORMAT_SUPPORT_TEXTURE2D | D3D11_FORMAT_SUPPORT_SHADER_SAMPLE;
+  return (SUCCEEDED(m_device->CheckFormatSupport(dfmt, &support)) && ((support & required) == required));
+}
+
+bool LibretroD3D11HostDisplay::BeginSetDisplayPixels(HostDisplayPixelFormat format, u32 width, u32 height,
+                                                     void** out_buffer, u32* out_pitch)
+{
+  ClearDisplayTexture();
+
+  const DXGI_FORMAT dxgi_format = s_display_pixel_format_mapping[static_cast<u32>(format)];
+  if (m_display_pixels_texture.GetWidth() < width || m_display_pixels_texture.GetHeight() < height ||
+      m_display_pixels_texture.GetFormat() != dxgi_format)
+  {
+    if (!m_display_pixels_texture.Create(m_device.Get(), width, height, 1, 1, dxgi_format, D3D11_BIND_SHADER_RESOURCE,
+                                         nullptr, 0, true))
+    {
+      return false;
+    }
+  }
+
+  D3D11_MAPPED_SUBRESOURCE sr;
+  HRESULT hr = m_context->Map(m_display_pixels_texture.GetD3DTexture(), 0, D3D11_MAP_WRITE_DISCARD, 0, &sr);
+  if (FAILED(hr))
+  {
+    Log_ErrorPrintf("Map pixels texture failed: %08X", hr);
+    return false;
+  }
+
+  *out_buffer = sr.pData;
+  *out_pitch = sr.RowPitch;
+
+  SetDisplayTexture(m_display_pixels_texture.GetD3DSRV(), format, m_display_pixels_texture.GetWidth(),
+                    m_display_pixels_texture.GetHeight(), 0, 0, static_cast<u32>(width), static_cast<u32>(height));
+  return true;
+}
+
+void LibretroD3D11HostDisplay::EndSetDisplayPixels()
+{
+  m_context->Unmap(m_display_pixels_texture.GetD3DTexture(), 0);
+}
+
+void LibretroD3D11HostDisplay::SetVSync(bool enabled)
+{
+  // The libretro frontend controls this.
+  Log_DevPrintf("Ignoring SetVSync(%u)", BoolToUInt32(enabled));
+}
+
+bool LibretroD3D11HostDisplay::RequestHardwareRendererContext(retro_hw_render_callback* cb)
+{
+  cb->cache_context = false;
+  cb->bottom_left_origin = false;
+  cb->context_type = RETRO_HW_CONTEXT_DIRECT3D;
+  cb->version_major = 11;
+  cb->version_minor = 0;
+
+  return g_retro_environment_callback(RETRO_ENVIRONMENT_SET_HW_RENDER, cb);
+}
+
+bool LibretroD3D11HostDisplay::CreateRenderDevice(const WindowInfo& wi, std::string_view adapter_name,
+                                                  bool debug_device, bool threaded_presentation)
+{
+  retro_hw_render_interface* ri = nullptr;
+  if (!g_retro_environment_callback(RETRO_ENVIRONMENT_GET_HW_RENDER_INTERFACE, &ri))
+  {
+    Log_ErrorPrint("Failed to get HW render interface");
+    return false;
+  }
+  else if (ri->interface_type != RETRO_HW_RENDER_INTERFACE_D3D11 ||
+           ri->interface_version != RETRO_HW_RENDER_INTERFACE_D3D11_VERSION)
+  {
+    Log_ErrorPrintf("Unexpected HW interface - type %u version %u", static_cast<unsigned>(ri->interface_type),
+                    static_cast<unsigned>(ri->interface_version));
+    return false;
+  }
+
+  const retro_hw_render_interface_d3d11* d3d11_ri = reinterpret_cast<const retro_hw_render_interface_d3d11*>(ri);
+  if (!d3d11_ri->device || !d3d11_ri->context)
+  {
+    Log_ErrorPrintf("Missing D3D device or context");
+    return false;
+  }
+
+  m_device = d3d11_ri->device;
+  m_context = d3d11_ri->context;
+  return true;
+}
+
+bool LibretroD3D11HostDisplay::InitializeRenderDevice(std::string_view shader_cache_directory, bool debug_device,
+                                                      bool threaded_presentation)
+{
+  if (!CreateResources())
+    return false;
+
+  return true;
+}
+
+void LibretroD3D11HostDisplay::DestroyRenderDevice()
+{
+  ClearSoftwareCursor();
+  DestroyResources();
+  DestroyRenderSurface();
+  m_context.Reset();
+  m_device.Reset();
+}
+
+bool LibretroD3D11HostDisplay::MakeRenderContextCurrent()
+{
+  return true;
+}
+
+bool LibretroD3D11HostDisplay::DoneRenderContextCurrent()
+{
+  return true;
+}
+
+void LibretroD3D11HostDisplay::ResizeRenderWindow(s32 new_window_width, s32 new_window_height)
+{
+  m_window_info.surface_width = static_cast<u32>(new_window_width);
+  m_window_info.surface_height = static_cast<u32>(new_window_height);
+}
+
+bool LibretroD3D11HostDisplay::ChangeRenderWindow(const WindowInfo& new_wi)
+{
+  // Check that the device hasn't changed.
+  retro_hw_render_interface* ri = nullptr;
+  if (!g_retro_environment_callback(RETRO_ENVIRONMENT_GET_HW_RENDER_INTERFACE, &ri))
+  {
+    Log_ErrorPrint("Failed to get HW render interface");
+    return false;
+  }
+  else if (ri->interface_type != RETRO_HW_RENDER_INTERFACE_D3D11 ||
+           ri->interface_version != RETRO_HW_RENDER_INTERFACE_D3D11_VERSION)
+  {
+    Log_ErrorPrintf("Unexpected HW interface - type %u version %u", static_cast<unsigned>(ri->interface_type),
+                    static_cast<unsigned>(ri->interface_version));
+    return false;
+  }
+
+  const retro_hw_render_interface_d3d11* d3d11_ri = reinterpret_cast<const retro_hw_render_interface_d3d11*>(ri);
+  if (d3d11_ri->device != m_device.Get() || d3d11_ri->context != m_context.Get())
+  {
+    Log_ErrorPrintf("D3D device/context changed outside our control");
+    return false;
+  }
+
+  m_window_info = new_wi;
+  return true;
+}
+
+void LibretroD3D11HostDisplay::DestroyRenderSurface() {}
+
+bool LibretroD3D11HostDisplay::SetPostProcessingChain(const std::string_view& config)
+{
+  return false;
+}
+
+bool LibretroD3D11HostDisplay::SupportsFullscreen() const
+{
+  return false;
+}
+
+bool LibretroD3D11HostDisplay::IsFullscreen()
+{
+  return false;
+}
+
+bool LibretroD3D11HostDisplay::SetFullscreen(bool fullscreen, u32 width, u32 height, float refresh_rate)
+{
+  return false;
+}
+
+bool LibretroD3D11HostDisplay::CreateResources()
+{
+  HRESULT hr;
+
+  m_display_vertex_shader =
+    D3D11::ShaderCompiler::CreateVertexShader(m_device.Get(), s_display_vs_bytecode, sizeof(s_display_vs_bytecode));
+  m_display_pixel_shader =
+    D3D11::ShaderCompiler::CreatePixelShader(m_device.Get(), s_display_ps_bytecode, sizeof(s_display_ps_bytecode));
+  m_display_alpha_pixel_shader = D3D11::ShaderCompiler::CreatePixelShader(m_device.Get(), s_display_ps_alpha_bytecode,
+                                                                          sizeof(s_display_ps_alpha_bytecode));
+  if (!m_display_vertex_shader || !m_display_pixel_shader || !m_display_alpha_pixel_shader)
+    return false;
+
+  if (!m_display_uniform_buffer.Create(m_device.Get(), D3D11_BIND_CONSTANT_BUFFER, DISPLAY_UNIFORM_BUFFER_SIZE))
+    return false;
+
+  CD3D11_RASTERIZER_DESC rasterizer_desc = CD3D11_RASTERIZER_DESC(CD3D11_DEFAULT());
+  rasterizer_desc.CullMode = D3D11_CULL_NONE;
+  hr = m_device->CreateRasterizerState(&rasterizer_desc, m_display_rasterizer_state.GetAddressOf());
+  if (FAILED(hr))
+    return false;
+
+  CD3D11_DEPTH_STENCIL_DESC depth_stencil_desc = CD3D11_DEPTH_STENCIL_DESC(CD3D11_DEFAULT());
+  depth_stencil_desc.DepthEnable = FALSE;
+  depth_stencil_desc.DepthWriteMask = D3D11_DEPTH_WRITE_MASK_ZERO;
+  hr = m_device->CreateDepthStencilState(&depth_stencil_desc, m_display_depth_stencil_state.GetAddressOf());
+  if (FAILED(hr))
+    return false;
+
+  CD3D11_BLEND_DESC blend_desc = CD3D11_BLEND_DESC(CD3D11_DEFAULT());
+  hr = m_device->CreateBlendState(&blend_desc, m_display_blend_state.GetAddressOf());
+  if (FAILED(hr))
+    return false;
+
+  blend_desc.RenderTarget[0] = {TRUE,
+                                D3D11_BLEND_SRC_ALPHA,
+                                D3D11_BLEND_INV_SRC_ALPHA,
+                                D3D11_BLEND_OP_ADD,
+                                D3D11_BLEND_ONE,
+                                D3D11_BLEND_ZERO,
+                                D3D11_BLEND_OP_ADD,
+                                D3D11_COLOR_WRITE_ENABLE_ALL};
+  hr = m_device->CreateBlendState(&blend_desc, m_software_cursor_blend_state.GetAddressOf());
+  if (FAILED(hr))
+    return false;
+
+  CD3D11_SAMPLER_DESC sampler_desc = CD3D11_SAMPLER_DESC(CD3D11_DEFAULT());
+  sampler_desc.Filter = D3D11_FILTER_MIN_MAG_MIP_POINT;
+  hr = m_device->CreateSamplerState(&sampler_desc, m_point_sampler.GetAddressOf());
+  if (FAILED(hr))
+    return false;
+
+  sampler_desc.Filter = D3D11_FILTER_MIN_MAG_LINEAR_MIP_POINT;
+  hr = m_device->CreateSamplerState(&sampler_desc, m_linear_sampler.GetAddressOf());
+  if (FAILED(hr))
+    return false;
+
+  return true;
+}
+
+void LibretroD3D11HostDisplay::DestroyResources()
+{
+  m_framebuffer.Destroy();
+  m_display_uniform_buffer.Release();
+  m_linear_sampler.Reset();
+  m_point_sampler.Reset();
+  m_display_alpha_pixel_shader.Reset();
+  m_display_pixel_shader.Reset();
+  m_display_vertex_shader.Reset();
+  m_display_blend_state.Reset();
+  m_display_depth_stencil_state.Reset();
+  m_display_rasterizer_state.Reset();
+}
+
+bool LibretroD3D11HostDisplay::CreateImGuiContext()
+{
+  return false;
+}
+
+void LibretroD3D11HostDisplay::DestroyImGuiContext() {}
+
+bool LibretroD3D11HostDisplay::UpdateImGuiFontTexture()
+{
+  return false;
+}
+
+bool LibretroD3D11HostDisplay::Render()
+{
+  const u32 resolution_scale = g_libretro_host_interface.GetResolutionScale();
+  const u32 display_width = static_cast<u32>(m_display_width) * resolution_scale;
+  const u32 display_height = static_cast<u32>(m_display_height) * resolution_scale;
+  if (!CheckFramebufferSize(display_width, display_height))
+    return false;
+
+  // Ensure we're not currently bound.
+  ID3D11ShaderResourceView* null_srv = nullptr;
+  m_context->PSSetShaderResources(0, 1, &null_srv);
+  m_context->OMSetRenderTargets(1u, m_framebuffer.GetD3DRTVArray(), nullptr);
+
+  if (HasDisplayTexture())
+  {
+    const auto [left, top, width, height] = CalculateDrawRect(display_width, display_height, 0, false);
+    RenderDisplay(left, top, width, height, m_display_texture_handle, m_display_texture_width, m_display_texture_height,
+                  m_display_texture_view_x, m_display_texture_view_y, m_display_texture_view_width,
+                  m_display_texture_view_height, m_display_linear_filtering);
+  }
+
+  // NOTE: libretro frontend expects the data bound to PS SRV slot 0.
+  m_context->OMSetRenderTargets(0, nullptr, nullptr);
+  m_context->PSSetShaderResources(0, 1, m_framebuffer.GetD3DSRVArray());
+  g_retro_video_refresh_callback(RETRO_HW_FRAME_BUFFER_VALID, display_width, display_height, 0);
+  return true;
+}
+
+bool LibretroD3D11HostDisplay::RenderScreenshot(u32 width, u32 height, std::vector<u32>* out_pixels, u32* out_stride,
+                                                HostDisplayPixelFormat* out_format)
+{
+  return false;
+}
+
+void LibretroD3D11HostDisplay::RenderDisplay(s32 left, s32 top, s32 width, s32 height, void* texture_handle,
+                                             u32 texture_width, s32 texture_height, s32 texture_view_x,
+                                             s32 texture_view_y, s32 texture_view_width, s32 texture_view_height,
+                                             bool linear_filter)
+{
+  m_context->IASetPrimitiveTopology(D3D11_PRIMITIVE_TOPOLOGY_TRIANGLELIST);
+  m_context->VSSetShader(m_display_vertex_shader.Get(), nullptr, 0);
+  m_context->PSSetShader(m_display_pixel_shader.Get(), nullptr, 0);
+  m_context->PSSetShaderResources(0, 1, reinterpret_cast<ID3D11ShaderResourceView**>(&texture_handle));
+  m_context->PSSetSamplers(0, 1, linear_filter ? m_linear_sampler.GetAddressOf() : m_point_sampler.GetAddressOf());
+
+  const float position_adjust = m_display_linear_filtering ? 0.5f : 0.0f;
+  const float size_adjust = m_display_linear_filtering ? 1.0f : 0.0f;
+  const float uniforms[4] = {
+    (static_cast<float>(texture_view_x) + position_adjust) / static_cast<float>(texture_width),
+    (static_cast<float>(texture_view_y) + position_adjust) / static_cast<float>(texture_height),
+    (static_cast<float>(texture_view_width) - size_adjust) / static_cast<float>(texture_width),
+    (static_cast<float>(texture_view_height) - size_adjust) / static_cast<float>(texture_height)};
+  const auto map = m_display_uniform_buffer.Map(m_context.Get(), m_display_uniform_buffer.GetSize(), sizeof(uniforms));
+  std::memcpy(map.pointer, uniforms, sizeof(uniforms));
+  m_display_uniform_buffer.Unmap(m_context.Get(), sizeof(uniforms));
+  m_context->VSSetConstantBuffers(0, 1, m_display_uniform_buffer.GetD3DBufferArray());
+
+  const CD3D11_VIEWPORT vp(static_cast<float>(left), static_cast<float>(top), static_cast<float>(width),
+                           static_cast<float>(height));
+  m_context->RSSetViewports(1, &vp);
+  m_context->RSSetState(m_display_rasterizer_state.Get());
+  m_context->OMSetDepthStencilState(m_display_depth_stencil_state.Get(), 0);
+  m_context->OMSetBlendState(m_display_blend_state.Get(), nullptr, 0xFFFFFFFFu);
+
+  m_context->Draw(3, 0);
+}
+
+HostDisplay::AdapterAndModeList LibretroD3D11HostDisplay::GetAdapterAndModeList()
+{
+  return {};
+}
+
+bool LibretroD3D11HostDisplay::CheckFramebufferSize(u32 width, u32 height)
+{
+  if (m_framebuffer.GetWidth() == width && m_framebuffer.GetHeight() == height)
+    return true;
+
+  return m_framebuffer.Create(m_device.Get(), width, height, 1, 1, DXGI_FORMAT_R8G8B8A8_UNORM,
+                              D3D11_BIND_SHADER_RESOURCE | D3D11_BIND_RENDER_TARGET);
+}
diff -Naur duckstation-51041e47f70123eda41d999701f5651830a0a95e.orig/src/duckstation-libretro/libretro_d3d11_host_display.h duckstation-51041e47f70123eda41d999701f5651830a0a95e/src/duckstation-libretro/libretro_d3d11_host_display.h
--- duckstation-51041e47f70123eda41d999701f5651830a0a95e.orig/src/duckstation-libretro/libretro_d3d11_host_display.h	1970-01-01 01:00:00.000000000 +0100
+++ duckstation-51041e47f70123eda41d999701f5651830a0a95e/src/duckstation-libretro/libretro_d3d11_host_display.h	2022-01-12 18:30:18.000000000 +0000
@@ -0,0 +1,100 @@
+#pragma once
+#include "common/d3d11/staging_texture.h"
+#include "common/d3d11/stream_buffer.h"
+#include "common/d3d11/texture.h"
+#include "core/host_display.h"
+#include "libretro.h"
+
+class LibretroD3D11HostDisplay final : public HostDisplay
+{
+public:
+  LibretroD3D11HostDisplay();
+  ~LibretroD3D11HostDisplay();
+
+  static bool RequestHardwareRendererContext(retro_hw_render_callback* cb);
+
+  RenderAPI GetRenderAPI() const override;
+  void* GetRenderDevice() const override;
+  void* GetRenderContext() const override;
+
+  bool HasRenderDevice() const override;
+  bool HasRenderSurface() const override;
+
+  bool CreateRenderDevice(const WindowInfo& wi, std::string_view adapter_name, bool debug_device,
+                          bool threaded_presentation) override;
+  bool InitializeRenderDevice(std::string_view shader_cache_directory, bool debug_device,
+                              bool threaded_presentation) override;
+  void DestroyRenderDevice() override;
+
+  bool MakeRenderContextCurrent() override;
+  bool DoneRenderContextCurrent() override;
+  
+  void ResizeRenderWindow(s32 new_window_width, s32 new_window_height) override;
+
+  bool ChangeRenderWindow(const WindowInfo& new_wi) override;
+
+  bool SupportsFullscreen() const override;
+  bool IsFullscreen() override;
+  bool SetFullscreen(bool fullscreen, u32 width, u32 height, float refresh_rate) override;
+  AdapterAndModeList GetAdapterAndModeList() override;
+  void DestroyRenderSurface() override;
+
+  bool SetPostProcessingChain(const std::string_view& config) override;
+
+  std::unique_ptr<HostDisplayTexture> CreateTexture(u32 width, u32 height, u32 layers, u32 levels, u32 samples,
+                                                    HostDisplayPixelFormat format, const void* data, u32 data_stride,
+                                                    bool dynamic = false) override;
+  void UpdateTexture(HostDisplayTexture* texture, u32 x, u32 y, u32 width, u32 height, const void* texture_data,
+                     u32 texture_data_stride) override;
+  bool DownloadTexture(const void* texture_handle, HostDisplayPixelFormat texture_format, u32 x, u32 y, u32 width,
+                       u32 height, void* out_data, u32 out_data_stride) override;
+  bool SupportsDisplayPixelFormat(HostDisplayPixelFormat format) const override;
+  bool BeginSetDisplayPixels(HostDisplayPixelFormat format, u32 width, u32 height, void** out_buffer,
+                             u32* out_pitch) override;
+  void EndSetDisplayPixels() override;
+
+  void SetVSync(bool enabled) override;
+
+  bool Render() override;
+  bool RenderScreenshot(u32 width, u32 height, std::vector<u32>* out_pixels, u32* out_stride,
+                        HostDisplayPixelFormat* out_format) override;
+
+protected:
+  static constexpr u32 DISPLAY_UNIFORM_BUFFER_SIZE = 16;
+
+  bool CreateResources() override;
+  void DestroyResources() override;
+
+  bool CreateImGuiContext() override;
+  void DestroyImGuiContext() override;
+  bool UpdateImGuiFontTexture() override;
+
+  void RenderDisplay(s32 left, s32 top, s32 width, s32 height, void* texture_handle, u32 texture_width,
+                     s32 texture_height, s32 texture_view_x, s32 texture_view_y, s32 texture_view_width,
+                     s32 texture_view_height, bool linear_filter);
+
+private:
+  template<typename T>
+  using ComPtr = Microsoft::WRL::ComPtr<T>;
+
+  bool CheckFramebufferSize(u32 width, u32 height);
+
+  ComPtr<ID3D11Device> m_device;
+  ComPtr<ID3D11DeviceContext> m_context;
+
+  ComPtr<ID3D11RasterizerState> m_display_rasterizer_state;
+  ComPtr<ID3D11DepthStencilState> m_display_depth_stencil_state;
+  ComPtr<ID3D11BlendState> m_display_blend_state;
+  ComPtr<ID3D11BlendState> m_software_cursor_blend_state;
+  ComPtr<ID3D11VertexShader> m_display_vertex_shader;
+  ComPtr<ID3D11PixelShader> m_display_pixel_shader;
+  ComPtr<ID3D11PixelShader> m_display_alpha_pixel_shader;
+  ComPtr<ID3D11SamplerState> m_point_sampler;
+  ComPtr<ID3D11SamplerState> m_linear_sampler;
+
+  D3D11::Texture m_display_pixels_texture;
+  D3D11::StreamBuffer m_display_uniform_buffer;
+  D3D11::AutoStagingTexture m_readback_staging_texture;
+
+  D3D11::Texture m_framebuffer;
+};
diff -Naur duckstation-51041e47f70123eda41d999701f5651830a0a95e.orig/src/duckstation-libretro/libretro_d3d.h duckstation-51041e47f70123eda41d999701f5651830a0a95e/src/duckstation-libretro/libretro_d3d.h
--- duckstation-51041e47f70123eda41d999701f5651830a0a95e.orig/src/duckstation-libretro/libretro_d3d.h	1970-01-01 01:00:00.000000000 +0100
+++ duckstation-51041e47f70123eda41d999701f5651830a0a95e/src/duckstation-libretro/libretro_d3d.h	2022-01-12 18:30:18.000000000 +0000
@@ -0,0 +1,59 @@
+/* Copyright (C) 2010-2020 The RetroArch team
+ *
+ * ---------------------------------------------------------------------------------------------
+ * The following license statement only applies to this libretro API header (libretro_d3d.h)
+ * ---------------------------------------------------------------------------------------------
+ *
+ * Permission is hereby granted, free of charge,
+ * to any person obtaining a copy of this software and associated documentation files (the
+ * "Software"),
+ * to deal in the Software without restriction, including without limitation the rights to
+ * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software,
+ * and to permit persons to whom the Software is furnished to do so, subject to the following
+ * conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in all copies or
+ * substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
+ * INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
+ * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY,
+ * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+#ifndef LIBRETRO_DIRECT3D_H__
+#define LIBRETRO_DIRECT3D_H__
+
+#include "libretro.h"
+
+#ifdef HAVE_D3D11
+
+#include <d3d11.h>
+#include <d3dcompiler.h>
+
+#define RETRO_HW_RENDER_INTERFACE_D3D11_VERSION 1
+
+struct retro_hw_render_interface_d3d11
+{
+  /* Must be set to RETRO_HW_RENDER_INTERFACE_D3D11. */
+  enum retro_hw_render_interface_type interface_type;
+  /* Must be set to RETRO_HW_RENDER_INTERFACE_D3D11_VERSION. */
+  unsigned interface_version;
+
+  /* Opaque handle to the d3d11 backend in the frontend
+   * which must be passed along to all function pointers
+   * in this interface.
+   */
+  void* handle;
+  ID3D11Device *device;
+  ID3D11DeviceContext *context;
+  D3D_FEATURE_LEVEL featureLevel;
+  pD3DCompile D3DCompile;
+};
+
+#endif
+
+#endif /* LIBRETRO_DIRECT3D_H__ */
diff -Naur duckstation-51041e47f70123eda41d999701f5651830a0a95e.orig/src/duckstation-libretro/libretro_game_settings.cpp duckstation-51041e47f70123eda41d999701f5651830a0a95e/src/duckstation-libretro/libretro_game_settings.cpp
--- duckstation-51041e47f70123eda41d999701f5651830a0a95e.orig/src/duckstation-libretro/libretro_game_settings.cpp	1970-01-01 01:00:00.000000000 +0100
+++ duckstation-51041e47f70123eda41d999701f5651830a0a95e/src/duckstation-libretro/libretro_game_settings.cpp	2022-01-12 18:30:18.000000000 +0000
@@ -0,0 +1,1553 @@
+#include "libretro_game_settings.h"
+
+std::unique_ptr<GameSettings::Entry> GetSettingsForGame(const std::string& game_code)
+{
+  std::unique_ptr<GameSettings::Entry> gs = std::make_unique<GameSettings::Entry>();
+
+  if (game_code == "SLUS-00077")
+  {
+    gs->AddTrait(GameSettings::Trait::DisableUpscaling);
+    gs->AddTrait(GameSettings::Trait::DisablePGXP);
+    return gs;
+  }
+
+  if (game_code == "SLES-00132")
+  {
+    gs->AddTrait(GameSettings::Trait::DisableUpscaling);
+    gs->AddTrait(GameSettings::Trait::DisablePGXP);
+    return gs;
+  }
+
+  if (game_code == "SLPS-00308")
+  {
+    gs->AddTrait(GameSettings::Trait::DisableUpscaling);
+    gs->AddTrait(GameSettings::Trait::DisablePGXP);
+    return gs;
+  }
+
+  if (game_code == "SLUS-00331")
+  {
+    gs->AddTrait(GameSettings::Trait::DisableUpscaling);
+    gs->AddTrait(GameSettings::Trait::DisablePGXP);
+    return gs;
+  }
+
+  if (game_code == "SLES-00487")
+  {
+    gs->AddTrait(GameSettings::Trait::DisableUpscaling);
+    gs->AddTrait(GameSettings::Trait::DisablePGXP);
+    return gs;
+  }
+
+  if (game_code == "SLPS-00727")
+  {
+    gs->AddTrait(GameSettings::Trait::DisableUpscaling);
+    gs->AddTrait(GameSettings::Trait::DisablePGXP);
+    return gs;
+  }
+
+  if (game_code == "SLES-00703")
+  {
+    gs->AddTrait(GameSettings::Trait::DisableUpscaling);
+    gs->AddTrait(GameSettings::Trait::DisablePGXP);
+    return gs;
+  }
+
+  if (game_code == "SLES-00987")
+  {
+    gs->AddTrait(GameSettings::Trait::DisableUpscaling);
+    gs->AddTrait(GameSettings::Trait::DisablePGXP);
+    return gs;
+  }
+
+  if (game_code == "SLED-01027")
+  {
+    gs->AddTrait(GameSettings::Trait::DisableUpscaling);
+    gs->AddTrait(GameSettings::Trait::DisablePGXP);
+    return gs;
+  }
+
+  if (game_code == "SLPS-01557")
+  {
+    gs->AddTrait(GameSettings::Trait::DisableUpscaling);
+    gs->AddTrait(GameSettings::Trait::DisablePGXP);
+    return gs;
+  }
+
+  if (game_code == "SLUS-00355")
+  {
+    gs->AddTrait(GameSettings::Trait::DisableUpscaling);
+    gs->AddTrait(GameSettings::Trait::DisablePGXP);
+    return gs;
+  }
+
+  if (game_code == "SLES-00081")
+  {
+    gs->AddTrait(GameSettings::Trait::DisableUpscaling);
+    gs->AddTrait(GameSettings::Trait::DisablePGXP);
+    return gs;
+  }
+
+  if (game_code == "SLES-00149")
+  {
+    gs->AddTrait(GameSettings::Trait::DisableUpscaling);
+    gs->AddTrait(GameSettings::Trait::DisablePGXP);
+    return gs;
+  }
+
+  if (game_code == "SLES-00148")
+  {
+    gs->AddTrait(GameSettings::Trait::DisableUpscaling);
+    gs->AddTrait(GameSettings::Trait::DisablePGXP);
+    return gs;
+  }
+
+  if (game_code == "SLES-00146")
+  {
+    gs->AddTrait(GameSettings::Trait::DisableUpscaling);
+    gs->AddTrait(GameSettings::Trait::DisablePGXP);
+    return gs;
+  }
+
+  if (game_code == "SLPS-00275")
+  {
+    gs->AddTrait(GameSettings::Trait::DisableUpscaling);
+    gs->AddTrait(GameSettings::Trait::DisablePGXP);
+    return gs;
+  }
+
+  if (game_code == "SLES-00147")
+  {
+    gs->AddTrait(GameSettings::Trait::DisableUpscaling);
+    gs->AddTrait(GameSettings::Trait::DisablePGXP);
+    return gs;
+  }
+
+  if (game_code == "SLUS-00009")
+  {
+    gs->AddTrait(GameSettings::Trait::DisableUpscaling);
+    gs->AddTrait(GameSettings::Trait::DisablePGXP);
+    return gs;
+  }
+
+  if (game_code == "SLPM-87089")
+  {
+    gs->AddTrait(GameSettings::Trait::ForceInterlacing);
+    return gs;
+  }
+
+  if (game_code == "SLPS-03336")
+  {
+    gs->AddTrait(GameSettings::Trait::ForceInterlacing);
+    return gs;
+  }
+
+  if (game_code == "SLUS-01260")
+  {
+    gs->AddTrait(GameSettings::Trait::ForceSoftwareRenderer);
+    gs->AddTrait(GameSettings::Trait::ForceInterlacing);
+    return gs;
+  }
+
+  if (game_code == "SLES-01211")
+  {
+    gs->AddTrait(GameSettings::Trait::ForceSoftwareRenderer);
+    gs->AddTrait(GameSettings::Trait::ForceInterlacing);
+    return gs;
+  }
+
+  if (game_code == "SLUS-01261")
+  {
+    gs->AddTrait(GameSettings::Trait::ForceSoftwareRenderer);
+    gs->AddTrait(GameSettings::Trait::ForceInterlacing);
+    return gs;
+  }
+
+  if (game_code == "SLES-02466")
+  {
+    gs->AddTrait(GameSettings::Trait::ForceSoftwareRenderer);
+    gs->AddTrait(GameSettings::Trait::ForceInterlacing);
+    return gs;
+  }
+
+  if (game_code == "SLES-00259")
+  {
+    gs->AddTrait(GameSettings::Trait::ForceSoftwareRenderer);
+    gs->AddTrait(GameSettings::Trait::ForceInterlacing);
+    return gs;
+  }
+
+  if (game_code == "SLES-00606")
+  {
+    gs->AddTrait(GameSettings::Trait::ForceSoftwareRenderer);
+    gs->AddTrait(GameSettings::Trait::ForceInterlacing);
+    return gs;
+  }
+
+  if (game_code == "SLUS-00639")
+  {
+    gs->AddTrait(GameSettings::Trait::ForceSoftwareRenderer);
+    gs->AddTrait(GameSettings::Trait::ForceInterlacing);
+    return gs;
+  }
+
+  if (game_code == "SLUS-90039")
+  {
+    gs->AddTrait(GameSettings::Trait::ForceSoftwareRenderer);
+    gs->AddTrait(GameSettings::Trait::ForceInterlacing);
+    return gs;
+  }
+
+  if (game_code == "SLUS-00337")
+  {
+    gs->AddTrait(GameSettings::Trait::ForceInterlacing);
+    return gs;
+  }
+
+  if (game_code == "SLPS-03553")
+  {
+    gs->AddTrait(GameSettings::Trait::ForceInterlacing);
+    return gs;
+  }
+
+  if (game_code == "SLPS-01211")
+  {
+    gs->AddTrait(GameSettings::Trait::ForceInterlacing);
+    return gs;
+  }
+
+  if (game_code == "SLUS-00656")
+  {
+    gs->AddTrait(GameSettings::Trait::ForceInterlacing);
+    return gs;
+  }
+
+  if (game_code == "SLUS-00952")
+  {
+    gs->AddTrait(GameSettings::Trait::ForceInterlacing);
+    return gs;
+  }
+
+  if (game_code == "SCES-01312")
+  {
+    gs->AddTrait(GameSettings::Trait::ForceInterlacing);
+    return gs;
+  }
+
+  if (game_code == "SCPS-10126")
+  {
+    gs->AddTrait(GameSettings::Trait::ForceSoftwareRenderer);
+    return gs;
+  }
+
+  if (game_code == "SLPS-00078")
+  {
+    gs->AddTrait(GameSettings::Trait::DisableTrueColor);
+    return gs;
+  }
+
+  if (game_code == "SLUS-00297")
+  {
+    gs->AddTrait(GameSettings::Trait::DisableUpscaling);
+    gs->AddTrait(GameSettings::Trait::DisablePGXP);
+    return gs;
+  }
+
+  if (game_code == "SLPS-00435")
+  {
+    gs->AddTrait(GameSettings::Trait::ForceRecompilerICache);
+    return gs;
+  }
+
+  if (game_code == "SLUS-00388")
+  {
+    gs->AddTrait(GameSettings::Trait::ForceRecompilerICache);
+    return gs;
+  }
+
+  if (game_code == "SLES-00529")
+  {
+    gs->AddTrait(GameSettings::Trait::ForceRecompilerICache);
+    return gs;
+  }
+
+  if (game_code == "SLPS-00699")
+  {
+    gs->AddTrait(GameSettings::Trait::ForceRecompilerICache);
+    return gs;
+  }
+
+  if (game_code == "SCES-02834")
+  {
+    gs->AddTrait(GameSettings::Trait::ForceRecompilerICache);
+    return gs;
+  }
+
+  if (game_code == "SCUS-94200")
+  {
+    gs->AddTrait(GameSettings::Trait::ForceRecompilerICache);
+    return gs;
+  }
+
+  if (game_code == "SCES-00002")
+  {
+    gs->AddTrait(GameSettings::Trait::ForceRecompilerICache);
+    return gs;
+  }
+
+  if (game_code == "SCUS-94003")
+  {
+    gs->AddTrait(GameSettings::Trait::ForceRecompilerICache);
+    return gs;
+  }
+
+  if (game_code == "SLPS-00025")
+  {
+    gs->AddTrait(GameSettings::Trait::ForceRecompilerICache);
+    return gs;
+  }
+
+  if (game_code == "SLES-01987")
+  {
+    gs->AddTrait(GameSettings::Trait::ForceRecompilerICache);
+    return gs;
+  }
+
+  if (game_code == "SLPS-01774")
+  {
+    gs->AddTrait(GameSettings::Trait::ForceRecompilerICache);
+    return gs;
+  }
+
+  if (game_code == "SLPS-02701")
+  {
+    gs->AddTrait(GameSettings::Trait::ForceRecompilerICache);
+    return gs;
+  }
+
+  if (game_code == "SLUS-00862")
+  {
+    gs->AddTrait(GameSettings::Trait::ForceRecompilerICache);
+    return gs;
+  }
+
+  if (game_code == "SLES-03552")
+  {
+    gs->AddTrait(GameSettings::Trait::ForceRecompilerICache);
+    return gs;
+  }
+
+  if (game_code == "SLUS-01324")
+  {
+    gs->AddTrait(GameSettings::Trait::ForceRecompilerICache);
+    return gs;
+  }
+
+  if (game_code == "SLPM-87159")
+  {
+    gs->AddTrait(GameSettings::Trait::ForceRecompilerICache);
+    return gs;
+  }
+
+  if (game_code == "SLPS-02728")
+  {
+    gs->AddTrait(GameSettings::Trait::ForceRecompilerICache);
+    return gs;
+  }
+
+  if (game_code == "SLPM-86086")
+  {
+    gs->AddTrait(GameSettings::Trait::ForceRecompilerICache);
+    return gs;
+  }
+
+  if (game_code == "SCED-01979")
+  {
+    gs->AddTrait(GameSettings::Trait::ForceInterpreter);
+    return gs;
+  }
+
+  if (game_code == "SLED-00491")
+  {
+    gs->AddTrait(GameSettings::Trait::ForceInterpreter);
+    return gs;
+  }
+
+  if (game_code == "SCES-02777")
+  {
+    gs->AddTrait(GameSettings::Trait::ForceInterpreter);
+    return gs;
+  }
+
+  if (game_code == "SCES-02779")
+  {
+    gs->AddTrait(GameSettings::Trait::ForceInterpreter);
+    return gs;
+  }
+
+  if (game_code == "SCES-02778")
+  {
+    gs->AddTrait(GameSettings::Trait::ForceInterpreter);
+    return gs;
+  }
+
+  if (game_code == "SLUS-01134")
+  {
+    gs->AddTrait(GameSettings::Trait::ForceInterpreter);
+    return gs;
+  }
+
+  if (game_code == "SCES-03404")
+  {
+    gs->AddTrait(GameSettings::Trait::ForceInterpreter);
+    return gs;
+  }
+
+  if (game_code == "SCES-03424")
+  {
+    gs->AddTrait(GameSettings::Trait::ForceInterpreter);
+    return gs;
+  }
+
+  if (game_code == "SCES-03423")
+  {
+    gs->AddTrait(GameSettings::Trait::ForceInterpreter);
+    return gs;
+  }
+
+  if (game_code == "SCES-03524")
+  {
+    gs->AddTrait(GameSettings::Trait::ForceInterpreter);
+    return gs;
+  }
+
+  if (game_code == "SCES-02222")
+  {
+    gs->AddTrait(GameSettings::Trait::ForceInterpreter);
+    return gs;
+  }
+
+  if (game_code == "SCES-01979")
+  {
+    gs->AddTrait(GameSettings::Trait::ForceInterpreter);
+    return gs;
+  }
+
+  if (game_code == "SCPS-10101")
+  {
+    gs->AddTrait(GameSettings::Trait::ForceInterpreter);
+    return gs;
+  }
+
+  if (game_code == "SLUS-00870")
+  {
+    gs->AddTrait(GameSettings::Trait::ForceInterpreter);
+    return gs;
+  }
+
+  if (game_code == "SCES-03886")
+  {
+    gs->AddTrait(GameSettings::Trait::ForceInterpreter);
+    return gs;
+  }
+
+  if (game_code == "SLUS-00183")
+  {
+    gs->AddTrait(GameSettings::Trait::ForceRecompilerICache);
+    return gs;
+  }
+
+  if (game_code == "SCPS-10059")
+  {
+    gs->AddTrait(GameSettings::Trait::ForceRecompilerICache);
+    return gs;
+  }
+
+  if (game_code == "SCUS-94254")
+  {
+    gs->AddTrait(GameSettings::Trait::ForceRecompilerICache);
+    return gs;
+  }
+
+  if (game_code == "SCES-01752")
+  {
+    gs->AddTrait(GameSettings::Trait::ForceRecompilerICache);
+    return gs;
+  }
+
+  if (game_code == "SCES-01944")
+  {
+    gs->AddTrait(GameSettings::Trait::ForceRecompilerICache);
+    return gs;
+  }
+
+  if (game_code == "SCES-01945")
+  {
+    gs->AddTrait(GameSettings::Trait::ForceRecompilerICache);
+    return gs;
+  }
+
+  if (game_code == "SCES-01946")
+  {
+    gs->AddTrait(GameSettings::Trait::ForceRecompilerICache);
+    return gs;
+  }
+
+  if (game_code == "SCES-01947")
+  {
+    gs->AddTrait(GameSettings::Trait::ForceRecompilerICache);
+    return gs;
+  }
+
+  if (game_code == "SLUS-00707")
+  {
+    gs->AddTrait(GameSettings::Trait::ForceRecompilerICache);
+    return gs;
+  }
+
+  if (game_code == "SLPM-86192")
+  {
+    gs->AddTrait(GameSettings::Trait::ForceRecompilerICache);
+    return gs;
+  }
+
+  if (game_code == "SLES-01514")
+  {
+    gs->AddTrait(GameSettings::Trait::ForceRecompilerICache);
+    return gs;
+  }
+
+  if (game_code == "SLUS-00875")
+  {
+    gs->AddTrait(GameSettings::Trait::ForceRecompilerICache);
+    return gs;
+  }
+
+  if (game_code == "SLPM-86739")
+  {
+    gs->AddTrait(GameSettings::Trait::ForceRecompilerICache);
+    return gs;
+  }
+
+  if (game_code == "SLES-02886")
+  {
+    gs->AddTrait(GameSettings::Trait::ForceRecompilerICache);
+    return gs;
+  }
+
+  if (game_code == "SLES-02887")
+  {
+    gs->AddTrait(GameSettings::Trait::ForceRecompilerICache);
+    return gs;
+  }
+
+  if (game_code == "SLES-02888")
+  {
+    gs->AddTrait(GameSettings::Trait::ForceRecompilerICache);
+    return gs;
+  }
+
+  if (game_code == "SLES-02889")
+  {
+    gs->AddTrait(GameSettings::Trait::ForceRecompilerICache);
+    return gs;
+  }
+
+  if (game_code == "SLES-02890")
+  {
+    gs->AddTrait(GameSettings::Trait::ForceRecompilerICache);
+    return gs;
+  }
+
+  if (game_code == "SLES-03449")
+  {
+    gs->AddTrait(GameSettings::Trait::ForceRecompilerICache);
+    return gs;
+  }
+
+  if (game_code == "SLES-01265")
+  {
+    gs->AddTrait(GameSettings::Trait::ForceRecompilerICache);
+    return gs;
+  }
+
+  if (game_code == "SLUS-00644")
+  {
+    gs->AddTrait(GameSettings::Trait::ForceRecompilerICache);
+    return gs;
+  }
+
+  if (game_code == "SLES-00483")
+  {
+    gs->AddTrait(GameSettings::Trait::ForceInterlacing);
+    return gs;
+  }
+
+  if (game_code == "SLPS-02361")
+  {
+    gs->AddTrait(GameSettings::Trait::ForcePGXPVertexCache);
+    return gs;
+  }
+
+  if (game_code == "SLPS-00712")
+  {
+    gs->AddTrait(GameSettings::Trait::ForceRecompilerICache);
+    return gs;
+  }
+
+  if (game_code == "SLPS-01434")
+  {
+    gs->AddTrait(GameSettings::Trait::ForceInterlacing);
+    return gs;
+  }
+
+  if (game_code == "SLUS-00684")
+  {
+    gs->AddTrait(GameSettings::Trait::ForceInterpreter);
+    return gs;
+  }
+
+  if (game_code == "SCES-01444")
+  {
+    gs->AddTrait(GameSettings::Trait::ForceInterpreter);
+    return gs;
+  }
+
+  if (game_code == "SLPM-86750")
+  {
+    gs->AddTrait(GameSettings::Trait::ForceInterlacing);
+    return gs;
+  }
+
+  if (game_code == "SLPS-02120")
+  {
+    gs->AddTrait(GameSettings::Trait::ForceInterlacing);
+    return gs;
+  }
+
+  if (game_code == "SLUS-00348")
+  {
+    gs->AddTrait(GameSettings::Trait::DisableUpscaling);
+    return gs;
+  }
+
+  if (game_code == "SLPS-01762")
+  {
+    gs->AddTrait(GameSettings::Trait::DisablePGXPCulling);
+    return gs;
+  }
+
+  if (game_code == "SLES-03868")
+  {
+    gs->AddTrait(GameSettings::Trait::DisablePGXPCulling);
+    return gs;
+  }
+
+  if (game_code == "SLED-02439")
+  {
+    gs->AddTrait(GameSettings::Trait::DisablePGXPCulling);
+    return gs;
+  }
+
+  if (game_code == "SCES-02835")
+  {
+    gs->AddTrait(GameSettings::Trait::ForcePGXPCPUMode);
+    return gs;
+  }
+
+  if (game_code == "SCES-02104")
+  {
+    gs->AddTrait(GameSettings::Trait::ForcePGXPCPUMode);
+    return gs;
+  }
+
+  if (game_code == "SCES-01438")
+  {
+    gs->AddTrait(GameSettings::Trait::DisablePGXPCulling);
+    gs->AddTrait(GameSettings::Trait::ForcePGXPCPUMode);
+    return gs;
+  }
+
+  if (game_code == "SCUS-94467")
+  {
+    gs->AddTrait(GameSettings::Trait::ForcePGXPCPUMode);
+    return gs;
+  }
+
+  if (game_code == "SCUS-94425")
+  {
+    gs->AddTrait(GameSettings::Trait::ForcePGXPCPUMode);
+    return gs;
+  }
+
+  if (game_code == "SCPS-10085")
+  {
+    gs->AddTrait(GameSettings::Trait::ForcePGXPCPUMode);
+    return gs;
+  }
+
+  if (game_code == "SCUS-94228")
+  {
+    gs->AddTrait(GameSettings::Trait::DisablePGXPCulling);
+    gs->AddTrait(GameSettings::Trait::ForcePGXPCPUMode);
+    return gs;
+  }
+
+  if (game_code == "SCUS-94290")
+  {
+    gs->AddTrait(GameSettings::Trait::ForcePGXPCPUMode);
+    return gs;
+  }
+
+  if (game_code == "SLES-02397")
+  {
+    gs->AddTrait(GameSettings::Trait::ForcePGXPCPUMode);
+    return gs;
+  }
+
+  if (game_code == "SLES-12397")
+  {
+    gs->AddTrait(GameSettings::Trait::ForcePGXPCPUMode);
+    return gs;
+  }
+
+  if (game_code == "SLES-02398")
+  {
+    gs->AddTrait(GameSettings::Trait::ForcePGXPCPUMode);
+    return gs;
+  }
+
+  if (game_code == "SLES-12398")
+  {
+    gs->AddTrait(GameSettings::Trait::ForcePGXPCPUMode);
+    return gs;
+  }
+
+  if (game_code == "SLES-02399")
+  {
+    gs->AddTrait(GameSettings::Trait::ForcePGXPCPUMode);
+    return gs;
+  }
+
+  if (game_code == "SLES-12399")
+  {
+    gs->AddTrait(GameSettings::Trait::ForcePGXPCPUMode);
+    return gs;
+  }
+
+  if (game_code == "SLPS-02124")
+  {
+    gs->AddTrait(GameSettings::Trait::ForcePGXPCPUMode);
+    return gs;
+  }
+
+  if (game_code == "SLPS-91205")
+  {
+    gs->AddTrait(GameSettings::Trait::ForcePGXPCPUMode);
+    return gs;
+  }
+
+  if (game_code == "SLPS-02125")
+  {
+    gs->AddTrait(GameSettings::Trait::ForcePGXPCPUMode);
+    return gs;
+  }
+
+  if (game_code == "SLPS-91206")
+  {
+    gs->AddTrait(GameSettings::Trait::ForcePGXPCPUMode);
+    return gs;
+  }
+
+  if (game_code == "SCUS-94457")
+  {
+    gs->AddTrait(GameSettings::Trait::ForcePGXPCPUMode);
+    return gs;
+  }
+
+  if (game_code == "SCUS-94465")
+  {
+    gs->AddTrait(GameSettings::Trait::ForcePGXPCPUMode);
+    return gs;
+  }
+
+  if (game_code == "SLPM-80297")
+  {
+    gs->AddTrait(GameSettings::Trait::ForcePGXPCPUMode);
+    return gs;
+  }
+
+  if (game_code == "SLES-00593")
+  {
+    gs->AddTrait(GameSettings::Trait::ForcePGXPCPUMode);
+    return gs;
+  }
+
+  if (game_code == "SLED-00038")
+  {
+    gs->AddTrait(GameSettings::Trait::ForcePGXPCPUMode);
+    return gs;
+  }
+
+  if (game_code == "SLUS-00530")
+  {
+    gs->AddTrait(GameSettings::Trait::ForcePGXPCPUMode);
+    return gs;
+  }
+
+  if (game_code == "SLED-02119")
+  {
+    gs->AddTrait(GameSettings::Trait::ForcePGXPCPUMode);
+    return gs;
+  }
+
+  if (game_code == "SLES-02088")
+  {
+    gs->AddTrait(GameSettings::Trait::ForcePGXPCPUMode);
+    return gs;
+  }
+
+  if (game_code == "SLUS-00634")
+  {
+    gs->AddTrait(GameSettings::Trait::ForcePGXPCPUMode);
+    return gs;
+  }
+
+  if (game_code == "SLUS-90056")
+  {
+    gs->AddTrait(GameSettings::Trait::ForcePGXPCPUMode);
+    return gs;
+  }
+
+  if (game_code == "SLPM-86310")
+  {
+    gs->AddTrait(GameSettings::Trait::ForcePGXPCPUMode);
+    return gs;
+  }
+
+  if (game_code == "SLPM-80473")
+  {
+    gs->AddTrait(GameSettings::Trait::ForcePGXPCPUMode);
+    return gs;
+  }
+
+  if (game_code == "SLPS-01055")
+  {
+    gs->AddTrait(GameSettings::Trait::ForcePGXPCPUMode);
+    return gs;
+  }
+
+  if (game_code == "SLPM-80173")
+  {
+    gs->AddTrait(GameSettings::Trait::ForcePGXPCPUMode);
+    return gs;
+  }
+
+  if (game_code == "SLES-02600")
+  {
+    gs->AddTrait(GameSettings::Trait::ForcePGXPCPUMode);
+    return gs;
+  }
+
+  if (game_code == "SLUS-01017")
+  {
+    gs->AddTrait(GameSettings::Trait::ForcePGXPCPUMode);
+    return gs;
+  }
+
+  if (game_code == "SLES-02602")
+  {
+    gs->AddTrait(GameSettings::Trait::ForcePGXPCPUMode);
+    return gs;
+  }
+
+  if (game_code == "SCPS-10115")
+  {
+    gs->AddTrait(GameSettings::Trait::ForcePGXPCPUMode);
+    return gs;
+  }
+
+  if (game_code == "PAPX-90097")
+  {
+    gs->AddTrait(GameSettings::Trait::ForcePGXPCPUMode);
+    return gs;
+  }
+
+  if (game_code == "SLES-02601")
+  {
+    gs->AddTrait(GameSettings::Trait::ForcePGXPCPUMode);
+    return gs;
+  }
+
+  if (game_code == "SCES-03000")
+  {
+    gs->AddTrait(GameSettings::Trait::ForcePGXPCPUMode);
+    return gs;
+  }
+
+  if (game_code == "SCUS-94569")
+  {
+    gs->AddTrait(GameSettings::Trait::ForcePGXPCPUMode);
+    return gs;
+  }
+
+  if (game_code == "SLES-03972")
+  {
+    gs->AddTrait(GameSettings::Trait::ForcePGXPCPUMode);
+    return gs;
+  }
+
+  if (game_code == "SLES-03974")
+  {
+    gs->AddTrait(GameSettings::Trait::ForcePGXPCPUMode);
+    return gs;
+  }
+
+  if (game_code == "SLES-03973")
+  {
+    gs->AddTrait(GameSettings::Trait::ForcePGXPCPUMode);
+    return gs;
+  }
+
+  if (game_code == "SLES-03975")
+  {
+    gs->AddTrait(GameSettings::Trait::ForcePGXPCPUMode);
+    return gs;
+  }
+
+  if (game_code == "SLUS-01503")
+  {
+    gs->AddTrait(GameSettings::Trait::ForcePGXPCPUMode);
+    return gs;
+  }
+
+  if (game_code == "SLUS-01417")
+  {
+    gs->AddTrait(GameSettings::Trait::ForcePGXPCPUMode);
+    return gs;
+  }
+
+  if (game_code == "SLES-03662")
+  {
+    gs->AddTrait(GameSettings::Trait::ForcePGXPCPUMode);
+    return gs;
+  }
+
+  if (game_code == "SLES-03665")
+  {
+    gs->AddTrait(GameSettings::Trait::ForcePGXPCPUMode);
+    return gs;
+  }
+
+  if (game_code == "SLES-03663")
+  {
+    gs->AddTrait(GameSettings::Trait::ForcePGXPCPUMode);
+    return gs;
+  }
+
+  if (game_code == "SLES-03664")
+  {
+    gs->AddTrait(GameSettings::Trait::ForcePGXPCPUMode);
+    return gs;
+  }
+
+  if (game_code == "SLUS-01415")
+  {
+    gs->AddTrait(GameSettings::Trait::ForcePGXPCPUMode);
+    return gs;
+  }
+
+  if (game_code == "SLES-03976")
+  {
+    gs->AddTrait(GameSettings::Trait::ForcePGXPCPUMode);
+    return gs;
+  }
+
+  if (game_code == "SLPS-03492")
+  {
+    gs->AddTrait(GameSettings::Trait::ForcePGXPCPUMode);
+    return gs;
+  }
+
+  if (game_code == "SLPS-03355")
+  {
+    gs->AddTrait(GameSettings::Trait::ForcePGXPCPUMode);
+    return gs;
+  }
+
+  if (game_code == "SLPM-84013")
+  {
+    gs->AddTrait(GameSettings::Trait::ForcePGXPCPUMode);
+    return gs;
+  }
+
+  if (game_code == "SCPS-45404")
+  {
+    gs->AddTrait(GameSettings::Trait::ForcePGXPCPUMode);
+    gs->AddTrait(GameSettings::Trait::ForceRecompilerLUTFastmem);
+    return gs;
+  }
+
+  if (game_code == "SLPS-00869")
+  {
+    gs->AddTrait(GameSettings::Trait::DisablePGXP);
+    return gs;
+  }
+
+  if (game_code == "SLPS-00870")
+  {
+    gs->AddTrait(GameSettings::Trait::DisablePGXP);
+    return gs;
+  }
+
+  if (game_code == "SLPS-00935")
+  {
+    gs->AddTrait(GameSettings::Trait::DisablePGXP);
+    return gs;
+  }
+
+  if (game_code == "SLUS-01138")
+  {
+    gs->dma_max_slice_ticks = 200;
+    gs->gpu_max_run_ahead = 1;
+    return gs;
+  }
+
+  if (game_code == "SLPS-02376")
+  {
+    gs->dma_max_slice_ticks = 100;
+    gs->gpu_max_run_ahead = 1;
+    return gs;
+  }
+
+  if (game_code == "SLUS-00282")
+  {
+    gs->dma_max_slice_ticks = 200;
+    gs->gpu_max_run_ahead = 1;
+    return gs;
+  }
+
+  if (game_code == "SLES-00056")
+  {
+    gs->dma_max_slice_ticks = 200;
+    gs->gpu_max_run_ahead = 1;
+    return gs;
+  }
+
+  if (game_code == "SLES-00654")
+  {
+    gs->dma_max_slice_ticks = 200;
+    gs->gpu_max_run_ahead = 1;
+    return gs;
+  }
+
+  if (game_code == "SLES-10654")
+  {
+    gs->dma_max_slice_ticks = 200;
+    gs->gpu_max_run_ahead = 1;
+    return gs;
+  }
+
+  if (game_code == "SLES-00656")
+  {
+    gs->dma_max_slice_ticks = 200;
+    gs->gpu_max_run_ahead = 1;
+    return gs;
+  }
+
+  if (game_code == "SLES-10656")
+  {
+    gs->dma_max_slice_ticks = 200;
+    gs->gpu_max_run_ahead = 1;
+    return gs;
+  }
+
+  if (game_code == "SLES-00584")
+  {
+    gs->dma_max_slice_ticks = 200;
+    gs->gpu_max_run_ahead = 1;
+    return gs;
+  }
+
+  if (game_code == "SLES-10584")
+  {
+    gs->dma_max_slice_ticks = 200;
+    gs->gpu_max_run_ahead = 1;
+    return gs;
+  }
+
+  if (game_code == "SLES-00643")
+  {
+    gs->dma_max_slice_ticks = 200;
+    gs->gpu_max_run_ahead = 1;
+    return gs;
+  }
+
+  if (game_code == "SLES-10643")
+  {
+    gs->dma_max_slice_ticks = 200;
+    gs->gpu_max_run_ahead = 1;
+    return gs;
+  }
+
+  if (game_code == "SLPS-00638")
+  {
+    gs->dma_max_slice_ticks = 200;
+    gs->gpu_max_run_ahead = 1;
+    return gs;
+  }
+
+  if (game_code == "SLPS-00639")
+  {
+    gs->dma_max_slice_ticks = 200;
+    gs->gpu_max_run_ahead = 1;
+    return gs;
+  }
+
+  if (game_code == "SLES-00644")
+  {
+    gs->dma_max_slice_ticks = 200;
+    gs->gpu_max_run_ahead = 1;
+    return gs;
+  }
+
+  if (game_code == "SLES-10644")
+  {
+    gs->dma_max_slice_ticks = 200;
+    gs->gpu_max_run_ahead = 1;
+    return gs;
+  }
+
+  if (game_code == "SLUS-00381")
+  {
+    gs->dma_max_slice_ticks = 200;
+    gs->gpu_max_run_ahead = 1;
+    return gs;
+  }
+
+  if (game_code == "SLUS-0381")
+  {
+    gs->dma_max_slice_ticks = 200;
+    gs->gpu_max_run_ahead = 1;
+    return gs;
+  }
+
+  if (game_code == "SLUS-00386")
+  {
+    gs->dma_max_slice_ticks = 200;
+    gs->gpu_max_run_ahead = 1;
+    return gs;
+  }
+
+  if (game_code == "SLUS-00022")
+  {
+    gs->AddTrait(GameSettings::Trait::DisableUpscaling);
+    return gs;
+  }
+
+  if (game_code == "SLUS-00292")
+  {
+    gs->AddTrait(GameSettings::Trait::ForceRecompilerICache);
+    return gs;
+  }
+
+  if (game_code == "SCUS-94577")
+  {
+    gs->AddTrait(GameSettings::Trait::ForceRecompilerICache);
+    return gs;
+  }
+
+  if (game_code == "SCUS-94578")
+  {
+    gs->AddTrait(GameSettings::Trait::ForceRecompilerICache);
+    return gs;
+  }
+
+  if (game_code == "SLUS-00232")
+  {
+    gs->dma_max_slice_ticks = 100;
+    return gs;
+  }
+
+  if (game_code == "SLES-00526")
+  {
+    gs->dma_max_slice_ticks = 100;
+    return gs;
+  }
+
+  if (game_code == "SLED-00570")
+  {
+    gs->dma_max_slice_ticks = 100;
+    return gs;
+  }
+
+  if (game_code == "SLUS-00547")
+  {
+    gs->dma_max_slice_ticks = 100;
+    return gs;
+  }
+
+  if (game_code == "SLES-01239")
+  {
+    gs->dma_max_slice_ticks = 100;
+    return gs;
+  }
+
+  if (game_code == "SLED-01311")
+  {
+    gs->dma_max_slice_ticks = 100;
+    return gs;
+  }
+
+  if (game_code == "SLED-01310")
+  {
+    gs->dma_max_slice_ticks = 100;
+    return gs;
+  }
+
+  if (game_code == "SLPS-00900")
+  {
+    gs->dma_max_slice_ticks = 100;
+    return gs;
+  }
+
+  if (game_code == "SLPS-03581")
+  {
+    gs->dma_max_slice_ticks = 100;
+    return gs;
+  }
+
+  if (game_code == "SLPS-91064")
+  {
+    gs->dma_max_slice_ticks = 100;
+    return gs;
+  }
+
+  if (game_code == "SCUS-94182")
+  {
+    gs->dma_max_slice_ticks = 100;
+    return gs;
+  }
+
+  if (game_code == "SLUS-01323")
+  {
+    gs->dma_max_slice_ticks = 100;
+    return gs;
+  }
+
+  if (game_code == "SCES-00842")
+  {
+    gs->dma_max_slice_ticks = 100;
+    return gs;
+  }
+
+  if (game_code == "SLES-00910")
+  {
+    gs->dma_max_slice_ticks = 100;
+    return gs;
+  }
+
+  if (game_code == "SLES-01157")
+  {
+    gs->dma_max_slice_ticks = 100;
+    return gs;
+  }
+
+  if (game_code == "SLES-01158")
+  {
+    gs->dma_max_slice_ticks = 100;
+    return gs;
+  }
+
+  if (game_code == "SLUS-00524")
+  {
+    gs->dma_max_slice_ticks = 100;
+    return gs;
+  }
+
+  if (game_code == "SLPM-87395")
+  {
+    gs->dma_max_slice_ticks = 100;
+    gs->dma_halt_ticks = 150;
+    gs->AddTrait(GameSettings::Trait::ForceRecompilerICache);
+    return gs;
+  }
+
+  if (game_code == "SLPS-02364")
+  {
+    gs->dma_max_slice_ticks = 100;
+    gs->dma_halt_ticks = 150;
+    gs->AddTrait(GameSettings::Trait::ForceRecompilerICache);
+    return gs;
+  }
+
+  if (game_code == "SLPS-02777")
+  {
+    gs->dma_max_slice_ticks = 100;
+    gs->dma_halt_ticks = 150;
+    gs->AddTrait(GameSettings::Trait::ForceRecompilerICache);
+    return gs;
+  }
+
+  if (game_code == "SLPS-91464")
+  {
+    gs->dma_max_slice_ticks = 100;
+    gs->dma_halt_ticks = 150;
+    gs->AddTrait(GameSettings::Trait::ForceRecompilerICache);
+    return gs;
+  }
+
+  if (game_code == "SLPM-87396")
+  {
+    gs->dma_max_slice_ticks = 100;
+    gs->dma_halt_ticks = 150;
+    gs->AddTrait(GameSettings::Trait::ForceRecompilerICache);
+    return gs;
+  }
+
+  if (game_code == "SLPS-02365")
+  {
+    gs->dma_max_slice_ticks = 100;
+    gs->dma_halt_ticks = 150;
+    gs->AddTrait(GameSettings::Trait::ForceRecompilerICache);
+    return gs;
+  }
+
+  if (game_code == "SLPS-02778")
+  {
+    gs->dma_max_slice_ticks = 100;
+    gs->dma_halt_ticks = 150;
+    gs->AddTrait(GameSettings::Trait::ForceRecompilerICache);
+    return gs;
+  }
+
+  if (game_code == "SLPS-91465")
+  {
+    gs->dma_max_slice_ticks = 100;
+    gs->dma_halt_ticks = 150;
+    gs->AddTrait(GameSettings::Trait::ForceRecompilerICache);
+    return gs;
+  }
+
+  if (game_code == "SLUS-01041")
+  {
+    gs->dma_max_slice_ticks = 100;
+    gs->dma_halt_ticks = 150;
+    gs->AddTrait(GameSettings::Trait::ForceRecompilerICache);
+    return gs;
+  }
+
+  if (game_code == "SLUS-01080")
+  {
+    gs->dma_max_slice_ticks = 100;
+    gs->dma_halt_ticks = 150;
+    gs->AddTrait(GameSettings::Trait::ForceRecompilerICache);
+    return gs;
+  }
+
+  if (game_code == "SLUS-00912")
+  {
+    gs->AddTrait(GameSettings::Trait::ForceInterlacing);
+    return gs;
+  }
+
+  if (game_code == "SLPS-00267")
+  {
+    gs->AddTrait(GameSettings::Trait::ForceRecompilerICache);
+    return gs;
+  }
+
+  if (game_code == "SCPS-45294")
+  {
+    gs->AddTrait(GameSettings::Trait::ForceRecompilerICache);
+    return gs;
+  }
+
+  if (game_code == "SLES-01218")
+  {
+    gs->AddTrait(GameSettings::Trait::ForceRecompilerICache);
+    return gs;
+  }
+
+  if (game_code == "SLED-01401")
+  {
+    gs->AddTrait(GameSettings::Trait::ForceRecompilerICache);
+    return gs;
+  }
+
+  if (game_code == "SLED-01513")
+  {
+    gs->AddTrait(GameSettings::Trait::ForceRecompilerICache);
+    return gs;
+  }
+
+  if (game_code == "SLES-01264")
+  {
+    gs->AddTrait(GameSettings::Trait::ForceRecompilerICache);
+    return gs;
+  }
+
+  if (game_code == "SLUS-00674")
+  {
+    gs->AddTrait(GameSettings::Trait::ForceRecompilerICache);
+    return gs;
+  }
+
+  if (game_code == "SLPS-02878")
+  {
+    gs->AddTrait(GameSettings::Trait::ForceRecompilerLUTFastmem);
+    return gs;
+  }
+
+  if (game_code == "SLES-02605")
+  {
+    gs->AddTrait(GameSettings::Trait::ForceRecompilerLUTFastmem);
+    return gs;
+  }
+
+  if (game_code == "SLUS-01222")
+  {
+    gs->AddTrait(GameSettings::Trait::ForceRecompilerLUTFastmem);
+    return gs;
+  }
+
+  if (game_code == "SLPM-86429")
+  {
+    gs->AddTrait(GameSettings::Trait::ForceRecompilerLUTFastmem);
+    return gs;
+  }
+
+  if (game_code == "SLPM-86943")
+  {
+    gs->AddTrait(GameSettings::Trait::ForceRecompilerLUTFastmem);
+    return gs;
+  }
+
+  if (game_code == "SLUS-00860")
+  {
+    gs->AddTrait(GameSettings::Trait::ForceRecompilerLUTFastmem);
+    return gs;
+  }
+
+  if (game_code == "SLED-02879")
+  {
+    gs->AddTrait(GameSettings::Trait::ForceRecompilerLUTFastmem);
+    return gs;
+  }
+
+  if (game_code == "SLED-03048")
+  {
+    gs->AddTrait(GameSettings::Trait::ForceRecompilerLUTFastmem);
+    return gs;
+  }
+
+  if (game_code == "SLES-02908")
+  {
+    gs->AddTrait(GameSettings::Trait::ForceRecompilerLUTFastmem);
+    return gs;
+  }
+
+  if (game_code == "SLES-02909")
+  {
+    gs->AddTrait(GameSettings::Trait::ForceRecompilerLUTFastmem);
+    return gs;
+  }
+
+  if (game_code == "SLES-02910")
+  {
+    gs->AddTrait(GameSettings::Trait::ForceRecompilerLUTFastmem);
+    return gs;
+  }
+
+  if (game_code == "SLPM-86751")
+  {
+    gs->AddTrait(GameSettings::Trait::ForceRecompilerLUTFastmem);
+    return gs;
+  }
+
+  if (game_code == "SLUS-01066")
+  {
+    gs->AddTrait(GameSettings::Trait::ForceRecompilerLUTFastmem);
+    return gs;
+  }
+
+  if (game_code == "SLUS-90086")
+  {
+    gs->AddTrait(GameSettings::Trait::ForceRecompilerLUTFastmem);
+    return gs;
+  }
+
+  if (game_code == "SLES-03645")
+  {
+    gs->AddTrait(GameSettings::Trait::ForceRecompilerLUTFastmem);
+    return gs;
+  }
+
+  if (game_code == "SLES-03646")
+  {
+    gs->AddTrait(GameSettings::Trait::ForceRecompilerLUTFastmem);
+    return gs;
+  }
+
+  if (game_code == "SLES-03647")
+  {
+    gs->AddTrait(GameSettings::Trait::ForceRecompilerLUTFastmem);
+    return gs;
+  }
+
+  if (game_code == "SLUS-01419")
+  {
+    gs->AddTrait(GameSettings::Trait::ForceRecompilerLUTFastmem);
+    return gs;
+  }
+
+  if (game_code == "SLES-03954")
+  {
+    gs->AddTrait(GameSettings::Trait::ForceRecompilerLUTFastmem);
+    return gs;
+  }
+
+  if (game_code == "SLES-03956")
+  {
+    gs->AddTrait(GameSettings::Trait::ForceRecompilerLUTFastmem);
+    return gs;
+  }
+
+  if (game_code == "SLES-03955")
+  {
+    gs->AddTrait(GameSettings::Trait::ForceRecompilerLUTFastmem);
+    return gs;
+  }
+
+  if (game_code == "SLUS-01485")
+  {
+    gs->AddTrait(GameSettings::Trait::ForceRecompilerLUTFastmem);
+    return gs;
+  }
+
+  if (game_code == "SLPS-02833")
+  {
+    gs->AddTrait(GameSettings::Trait::ForceRecompilerLUTFastmem);
+    return gs;
+  }
+
+  if (game_code == "SCPS-45120")
+  {
+    gs->AddTrait(GameSettings::Trait::ForceRecompilerLUTFastmem);
+    return gs;
+  }
+
+  if (game_code == "SLPS-01009")
+  {
+    gs->AddTrait(GameSettings::Trait::ForceRecompilerLUTFastmem);
+    return gs;
+  }
+
+  if (game_code == "SCUS-94243")
+  {
+    gs->AddTrait(GameSettings::Trait::ForceRecompilerLUTFastmem);
+    return gs;
+  }
+
+  return {};
+}
diff -Naur duckstation-51041e47f70123eda41d999701f5651830a0a95e.orig/src/duckstation-libretro/libretro_game_settings.h duckstation-51041e47f70123eda41d999701f5651830a0a95e/src/duckstation-libretro/libretro_game_settings.h
--- duckstation-51041e47f70123eda41d999701f5651830a0a95e.orig/src/duckstation-libretro/libretro_game_settings.h	1970-01-01 01:00:00.000000000 +0100
+++ duckstation-51041e47f70123eda41d999701f5651830a0a95e/src/duckstation-libretro/libretro_game_settings.h	2022-01-12 18:30:18.000000000 +0000
@@ -0,0 +1,4 @@
+#include "frontend-common/game_settings.h"
+#include <memory>
+
+std::unique_ptr<GameSettings::Entry> GetSettingsForGame(const std::string& game_code);
diff -Naur duckstation-51041e47f70123eda41d999701f5651830a0a95e.orig/src/duckstation-libretro/libretro.h duckstation-51041e47f70123eda41d999701f5651830a0a95e/src/duckstation-libretro/libretro.h
--- duckstation-51041e47f70123eda41d999701f5651830a0a95e.orig/src/duckstation-libretro/libretro.h	1970-01-01 01:00:00.000000000 +0100
+++ duckstation-51041e47f70123eda41d999701f5651830a0a95e/src/duckstation-libretro/libretro.h	2022-01-12 18:30:18.000000000 +0000
@@ -0,0 +1,3793 @@
+/* Copyright (C) 2010-2020 The RetroArch team
+ *
+ * ---------------------------------------------------------------------------------------
+ * The following license statement only applies to this libretro API header (libretro.h).
+ * ---------------------------------------------------------------------------------------
+ *
+ * Permission is hereby granted, free of charge,
+ * to any person obtaining a copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation the rights to
+ * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software,
+ * and to permit persons to whom the Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
+ * INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
+ * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
+ * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+#ifndef LIBRETRO_H__
+#define LIBRETRO_H__
+
+#include <stdint.h>
+#include <stddef.h>
+#include <limits.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#ifndef __cplusplus
+#if defined(_MSC_VER) && _MSC_VER < 1800 && !defined(SN_TARGET_PS3)
+/* Hack applied for MSVC when compiling in C89 mode
+ * as it isn't C99-compliant. */
+#define bool unsigned char
+#define true 1
+#define false 0
+#else
+#include <stdbool.h>
+#endif
+#endif
+
+#ifndef RETRO_CALLCONV
+#  if defined(__GNUC__) && defined(__i386__) && !defined(__x86_64__)
+#    define RETRO_CALLCONV __attribute__((cdecl))
+#  elif defined(_MSC_VER) && defined(_M_X86) && !defined(_M_X64)
+#    define RETRO_CALLCONV __cdecl
+#  else
+#    define RETRO_CALLCONV /* all other platforms only have one calling convention each */
+#  endif
+#endif
+
+#ifndef RETRO_API
+#  if defined(_WIN32) || defined(__CYGWIN__) || defined(__MINGW32__)
+#    ifdef RETRO_IMPORT_SYMBOLS
+#      ifdef __GNUC__
+#        define RETRO_API RETRO_CALLCONV __attribute__((__dllimport__))
+#      else
+#        define RETRO_API RETRO_CALLCONV __declspec(dllimport)
+#      endif
+#    else
+#      ifdef __GNUC__
+#        define RETRO_API RETRO_CALLCONV __attribute__((__dllexport__))
+#      else
+#        define RETRO_API RETRO_CALLCONV __declspec(dllexport)
+#      endif
+#    endif
+#  else
+#      if defined(__GNUC__) && __GNUC__ >= 4
+#        define RETRO_API RETRO_CALLCONV __attribute__((__visibility__("default")))
+#      else
+#        define RETRO_API RETRO_CALLCONV
+#      endif
+#  endif
+#endif
+
+/* Used for checking API/ABI mismatches that can break libretro
+ * implementations.
+ * It is not incremented for compatible changes to the API.
+ */
+#define RETRO_API_VERSION         1
+
+/*
+ * Libretro's fundamental device abstractions.
+ *
+ * Libretro's input system consists of some standardized device types,
+ * such as a joypad (with/without analog), mouse, keyboard, lightgun
+ * and a pointer.
+ *
+ * The functionality of these devices are fixed, and individual cores
+ * map their own concept of a controller to libretro's abstractions.
+ * This makes it possible for frontends to map the abstract types to a
+ * real input device, and not having to worry about binding input
+ * correctly to arbitrary controller layouts.
+ */
+
+#define RETRO_DEVICE_TYPE_SHIFT         8
+#define RETRO_DEVICE_MASK               ((1 << RETRO_DEVICE_TYPE_SHIFT) - 1)
+#define RETRO_DEVICE_SUBCLASS(base, id) (((id + 1) << RETRO_DEVICE_TYPE_SHIFT) | base)
+
+/* Input disabled. */
+#define RETRO_DEVICE_NONE         0
+
+/* The JOYPAD is called RetroPad. It is essentially a Super Nintendo
+ * controller, but with additional L2/R2/L3/R3 buttons, similar to a
+ * PS1 DualShock. */
+#define RETRO_DEVICE_JOYPAD       1
+
+/* The mouse is a simple mouse, similar to Super Nintendo's mouse.
+ * X and Y coordinates are reported relatively to last poll (poll callback).
+ * It is up to the libretro implementation to keep track of where the mouse
+ * pointer is supposed to be on the screen.
+ * The frontend must make sure not to interfere with its own hardware
+ * mouse pointer.
+ */
+#define RETRO_DEVICE_MOUSE        2
+
+/* KEYBOARD device lets one poll for raw key pressed.
+ * It is poll based, so input callback will return with the current
+ * pressed state.
+ * For event/text based keyboard input, see
+ * RETRO_ENVIRONMENT_SET_KEYBOARD_CALLBACK.
+ */
+#define RETRO_DEVICE_KEYBOARD     3
+
+/* LIGHTGUN device is similar to Guncon-2 for PlayStation 2.
+ * It reports X/Y coordinates in screen space (similar to the pointer)
+ * in the range [-0x8000, 0x7fff] in both axes, with zero being center and
+ * -0x8000 being out of bounds.
+ * As well as reporting on/off screen state. It features a trigger,
+ * start/select buttons, auxiliary action buttons and a
+ * directional pad. A forced off-screen shot can be requested for
+ * auto-reloading function in some games.
+ */
+#define RETRO_DEVICE_LIGHTGUN     4
+
+/* The ANALOG device is an extension to JOYPAD (RetroPad).
+ * Similar to DualShock2 it adds two analog sticks and all buttons can
+ * be analog. This is treated as a separate device type as it returns
+ * axis values in the full analog range of [-0x7fff, 0x7fff],
+ * although some devices may return -0x8000.
+ * Positive X axis is right. Positive Y axis is down.
+ * Buttons are returned in the range [0, 0x7fff].
+ * Only use ANALOG type when polling for analog values.
+ */
+#define RETRO_DEVICE_ANALOG       5
+
+/* Abstracts the concept of a pointing mechanism, e.g. touch.
+ * This allows libretro to query in absolute coordinates where on the
+ * screen a mouse (or something similar) is being placed.
+ * For a touch centric device, coordinates reported are the coordinates
+ * of the press.
+ *
+ * Coordinates in X and Y are reported as:
+ * [-0x7fff, 0x7fff]: -0x7fff corresponds to the far left/top of the screen,
+ * and 0x7fff corresponds to the far right/bottom of the screen.
+ * The "screen" is here defined as area that is passed to the frontend and
+ * later displayed on the monitor.
+ *
+ * The frontend is free to scale/resize this screen as it sees fit, however,
+ * (X, Y) = (-0x7fff, -0x7fff) will correspond to the top-left pixel of the
+ * game image, etc.
+ *
+ * To check if the pointer coordinates are valid (e.g. a touch display
+ * actually being touched), PRESSED returns 1 or 0.
+ *
+ * If using a mouse on a desktop, PRESSED will usually correspond to the
+ * left mouse button, but this is a frontend decision.
+ * PRESSED will only return 1 if the pointer is inside the game screen.
+ *
+ * For multi-touch, the index variable can be used to successively query
+ * more presses.
+ * If index = 0 returns true for _PRESSED, coordinates can be extracted
+ * with _X, _Y for index = 0. One can then query _PRESSED, _X, _Y with
+ * index = 1, and so on.
+ * Eventually _PRESSED will return false for an index. No further presses
+ * are registered at this point. */
+#define RETRO_DEVICE_POINTER      6
+
+/* Buttons for the RetroPad (JOYPAD).
+ * The placement of these is equivalent to placements on the
+ * Super Nintendo controller.
+ * L2/R2/L3/R3 buttons correspond to the PS1 DualShock.
+ * Also used as id values for RETRO_DEVICE_INDEX_ANALOG_BUTTON */
+#define RETRO_DEVICE_ID_JOYPAD_B        0
+#define RETRO_DEVICE_ID_JOYPAD_Y        1
+#define RETRO_DEVICE_ID_JOYPAD_SELECT   2
+#define RETRO_DEVICE_ID_JOYPAD_START    3
+#define RETRO_DEVICE_ID_JOYPAD_UP       4
+#define RETRO_DEVICE_ID_JOYPAD_DOWN     5
+#define RETRO_DEVICE_ID_JOYPAD_LEFT     6
+#define RETRO_DEVICE_ID_JOYPAD_RIGHT    7
+#define RETRO_DEVICE_ID_JOYPAD_A        8
+#define RETRO_DEVICE_ID_JOYPAD_X        9
+#define RETRO_DEVICE_ID_JOYPAD_L       10
+#define RETRO_DEVICE_ID_JOYPAD_R       11
+#define RETRO_DEVICE_ID_JOYPAD_L2      12
+#define RETRO_DEVICE_ID_JOYPAD_R2      13
+#define RETRO_DEVICE_ID_JOYPAD_L3      14
+#define RETRO_DEVICE_ID_JOYPAD_R3      15
+
+#define RETRO_DEVICE_ID_JOYPAD_MASK    256
+
+/* Index / Id values for ANALOG device. */
+#define RETRO_DEVICE_INDEX_ANALOG_LEFT       0
+#define RETRO_DEVICE_INDEX_ANALOG_RIGHT      1
+#define RETRO_DEVICE_INDEX_ANALOG_BUTTON     2
+#define RETRO_DEVICE_ID_ANALOG_X             0
+#define RETRO_DEVICE_ID_ANALOG_Y             1
+
+/* Id values for MOUSE. */
+#define RETRO_DEVICE_ID_MOUSE_X                0
+#define RETRO_DEVICE_ID_MOUSE_Y                1
+#define RETRO_DEVICE_ID_MOUSE_LEFT             2
+#define RETRO_DEVICE_ID_MOUSE_RIGHT            3
+#define RETRO_DEVICE_ID_MOUSE_WHEELUP          4
+#define RETRO_DEVICE_ID_MOUSE_WHEELDOWN        5
+#define RETRO_DEVICE_ID_MOUSE_MIDDLE           6
+#define RETRO_DEVICE_ID_MOUSE_HORIZ_WHEELUP    7
+#define RETRO_DEVICE_ID_MOUSE_HORIZ_WHEELDOWN  8
+#define RETRO_DEVICE_ID_MOUSE_BUTTON_4         9
+#define RETRO_DEVICE_ID_MOUSE_BUTTON_5         10
+
+/* Id values for LIGHTGUN. */
+#define RETRO_DEVICE_ID_LIGHTGUN_SCREEN_X        13 /*Absolute Position*/
+#define RETRO_DEVICE_ID_LIGHTGUN_SCREEN_Y        14 /*Absolute*/
+#define RETRO_DEVICE_ID_LIGHTGUN_IS_OFFSCREEN    15 /*Status Check*/
+#define RETRO_DEVICE_ID_LIGHTGUN_TRIGGER          2
+#define RETRO_DEVICE_ID_LIGHTGUN_RELOAD          16 /*Forced off-screen shot*/
+#define RETRO_DEVICE_ID_LIGHTGUN_AUX_A            3
+#define RETRO_DEVICE_ID_LIGHTGUN_AUX_B            4
+#define RETRO_DEVICE_ID_LIGHTGUN_START            6
+#define RETRO_DEVICE_ID_LIGHTGUN_SELECT           7
+#define RETRO_DEVICE_ID_LIGHTGUN_AUX_C            8
+#define RETRO_DEVICE_ID_LIGHTGUN_DPAD_UP          9
+#define RETRO_DEVICE_ID_LIGHTGUN_DPAD_DOWN       10
+#define RETRO_DEVICE_ID_LIGHTGUN_DPAD_LEFT       11
+#define RETRO_DEVICE_ID_LIGHTGUN_DPAD_RIGHT      12
+/* deprecated */
+#define RETRO_DEVICE_ID_LIGHTGUN_X                0 /*Relative Position*/
+#define RETRO_DEVICE_ID_LIGHTGUN_Y                1 /*Relative*/
+#define RETRO_DEVICE_ID_LIGHTGUN_CURSOR           3 /*Use Aux:A*/
+#define RETRO_DEVICE_ID_LIGHTGUN_TURBO            4 /*Use Aux:B*/
+#define RETRO_DEVICE_ID_LIGHTGUN_PAUSE            5 /*Use Start*/
+
+/* Id values for POINTER. */
+#define RETRO_DEVICE_ID_POINTER_X         0
+#define RETRO_DEVICE_ID_POINTER_Y         1
+#define RETRO_DEVICE_ID_POINTER_PRESSED   2
+#define RETRO_DEVICE_ID_POINTER_COUNT     3
+
+/* Returned from retro_get_region(). */
+#define RETRO_REGION_NTSC  0
+#define RETRO_REGION_PAL   1
+
+/* Id values for LANGUAGE */
+enum retro_language
+{
+   RETRO_LANGUAGE_ENGLISH             = 0,
+   RETRO_LANGUAGE_JAPANESE            = 1,
+   RETRO_LANGUAGE_FRENCH              = 2,
+   RETRO_LANGUAGE_SPANISH             = 3,
+   RETRO_LANGUAGE_GERMAN              = 4,
+   RETRO_LANGUAGE_ITALIAN             = 5,
+   RETRO_LANGUAGE_DUTCH               = 6,
+   RETRO_LANGUAGE_PORTUGUESE_BRAZIL   = 7,
+   RETRO_LANGUAGE_PORTUGUESE_PORTUGAL = 8,
+   RETRO_LANGUAGE_RUSSIAN             = 9,
+   RETRO_LANGUAGE_KOREAN              = 10,
+   RETRO_LANGUAGE_CHINESE_TRADITIONAL = 11,
+   RETRO_LANGUAGE_CHINESE_SIMPLIFIED  = 12,
+   RETRO_LANGUAGE_ESPERANTO           = 13,
+   RETRO_LANGUAGE_POLISH              = 14,
+   RETRO_LANGUAGE_VIETNAMESE          = 15,
+   RETRO_LANGUAGE_ARABIC              = 16,
+   RETRO_LANGUAGE_GREEK               = 17,
+   RETRO_LANGUAGE_TURKISH             = 18,
+   RETRO_LANGUAGE_SLOVAK              = 19,
+   RETRO_LANGUAGE_PERSIAN             = 20,
+   RETRO_LANGUAGE_HEBREW              = 21,
+   RETRO_LANGUAGE_ASTURIAN            = 22,
+   RETRO_LANGUAGE_FINNISH             = 23,
+   RETRO_LANGUAGE_LAST,
+
+   /* Ensure sizeof(enum) == sizeof(int) */
+   RETRO_LANGUAGE_DUMMY          = INT_MAX
+};
+
+/* Passed to retro_get_memory_data/size().
+ * If the memory type doesn't apply to the
+ * implementation NULL/0 can be returned.
+ */
+#define RETRO_MEMORY_MASK        0xff
+
+/* Regular save RAM. This RAM is usually found on a game cartridge,
+ * backed up by a battery.
+ * If save game data is too complex for a single memory buffer,
+ * the SAVE_DIRECTORY (preferably) or SYSTEM_DIRECTORY environment
+ * callback can be used. */
+#define RETRO_MEMORY_SAVE_RAM    0
+
+/* Some games have a built-in clock to keep track of time.
+ * This memory is usually just a couple of bytes to keep track of time.
+ */
+#define RETRO_MEMORY_RTC         1
+
+/* System ram lets a frontend peek into a game systems main RAM. */
+#define RETRO_MEMORY_SYSTEM_RAM  2
+
+/* Video ram lets a frontend peek into a game systems video RAM (VRAM). */
+#define RETRO_MEMORY_VIDEO_RAM   3
+
+/* Keysyms used for ID in input state callback when polling RETRO_KEYBOARD. */
+enum retro_key
+{
+   RETROK_UNKNOWN        = 0,
+   RETROK_FIRST          = 0,
+   RETROK_BACKSPACE      = 8,
+   RETROK_TAB            = 9,
+   RETROK_CLEAR          = 12,
+   RETROK_RETURN         = 13,
+   RETROK_PAUSE          = 19,
+   RETROK_ESCAPE         = 27,
+   RETROK_SPACE          = 32,
+   RETROK_EXCLAIM        = 33,
+   RETROK_QUOTEDBL       = 34,
+   RETROK_HASH           = 35,
+   RETROK_DOLLAR         = 36,
+   RETROK_AMPERSAND      = 38,
+   RETROK_QUOTE          = 39,
+   RETROK_LEFTPAREN      = 40,
+   RETROK_RIGHTPAREN     = 41,
+   RETROK_ASTERISK       = 42,
+   RETROK_PLUS           = 43,
+   RETROK_COMMA          = 44,
+   RETROK_MINUS          = 45,
+   RETROK_PERIOD         = 46,
+   RETROK_SLASH          = 47,
+   RETROK_0              = 48,
+   RETROK_1              = 49,
+   RETROK_2              = 50,
+   RETROK_3              = 51,
+   RETROK_4              = 52,
+   RETROK_5              = 53,
+   RETROK_6              = 54,
+   RETROK_7              = 55,
+   RETROK_8              = 56,
+   RETROK_9              = 57,
+   RETROK_COLON          = 58,
+   RETROK_SEMICOLON      = 59,
+   RETROK_LESS           = 60,
+   RETROK_EQUALS         = 61,
+   RETROK_GREATER        = 62,
+   RETROK_QUESTION       = 63,
+   RETROK_AT             = 64,
+   RETROK_LEFTBRACKET    = 91,
+   RETROK_BACKSLASH      = 92,
+   RETROK_RIGHTBRACKET   = 93,
+   RETROK_CARET          = 94,
+   RETROK_UNDERSCORE     = 95,
+   RETROK_BACKQUOTE      = 96,
+   RETROK_a              = 97,
+   RETROK_b              = 98,
+   RETROK_c              = 99,
+   RETROK_d              = 100,
+   RETROK_e              = 101,
+   RETROK_f              = 102,
+   RETROK_g              = 103,
+   RETROK_h              = 104,
+   RETROK_i              = 105,
+   RETROK_j              = 106,
+   RETROK_k              = 107,
+   RETROK_l              = 108,
+   RETROK_m              = 109,
+   RETROK_n              = 110,
+   RETROK_o              = 111,
+   RETROK_p              = 112,
+   RETROK_q              = 113,
+   RETROK_r              = 114,
+   RETROK_s              = 115,
+   RETROK_t              = 116,
+   RETROK_u              = 117,
+   RETROK_v              = 118,
+   RETROK_w              = 119,
+   RETROK_x              = 120,
+   RETROK_y              = 121,
+   RETROK_z              = 122,
+   RETROK_LEFTBRACE      = 123,
+   RETROK_BAR            = 124,
+   RETROK_RIGHTBRACE     = 125,
+   RETROK_TILDE          = 126,
+   RETROK_DELETE         = 127,
+
+   RETROK_KP0            = 256,
+   RETROK_KP1            = 257,
+   RETROK_KP2            = 258,
+   RETROK_KP3            = 259,
+   RETROK_KP4            = 260,
+   RETROK_KP5            = 261,
+   RETROK_KP6            = 262,
+   RETROK_KP7            = 263,
+   RETROK_KP8            = 264,
+   RETROK_KP9            = 265,
+   RETROK_KP_PERIOD      = 266,
+   RETROK_KP_DIVIDE      = 267,
+   RETROK_KP_MULTIPLY    = 268,
+   RETROK_KP_MINUS       = 269,
+   RETROK_KP_PLUS        = 270,
+   RETROK_KP_ENTER       = 271,
+   RETROK_KP_EQUALS      = 272,
+
+   RETROK_UP             = 273,
+   RETROK_DOWN           = 274,
+   RETROK_RIGHT          = 275,
+   RETROK_LEFT           = 276,
+   RETROK_INSERT         = 277,
+   RETROK_HOME           = 278,
+   RETROK_END            = 279,
+   RETROK_PAGEUP         = 280,
+   RETROK_PAGEDOWN       = 281,
+
+   RETROK_F1             = 282,
+   RETROK_F2             = 283,
+   RETROK_F3             = 284,
+   RETROK_F4             = 285,
+   RETROK_F5             = 286,
+   RETROK_F6             = 287,
+   RETROK_F7             = 288,
+   RETROK_F8             = 289,
+   RETROK_F9             = 290,
+   RETROK_F10            = 291,
+   RETROK_F11            = 292,
+   RETROK_F12            = 293,
+   RETROK_F13            = 294,
+   RETROK_F14            = 295,
+   RETROK_F15            = 296,
+
+   RETROK_NUMLOCK        = 300,
+   RETROK_CAPSLOCK       = 301,
+   RETROK_SCROLLOCK      = 302,
+   RETROK_RSHIFT         = 303,
+   RETROK_LSHIFT         = 304,
+   RETROK_RCTRL          = 305,
+   RETROK_LCTRL          = 306,
+   RETROK_RALT           = 307,
+   RETROK_LALT           = 308,
+   RETROK_RMETA          = 309,
+   RETROK_LMETA          = 310,
+   RETROK_LSUPER         = 311,
+   RETROK_RSUPER         = 312,
+   RETROK_MODE           = 313,
+   RETROK_COMPOSE        = 314,
+
+   RETROK_HELP           = 315,
+   RETROK_PRINT          = 316,
+   RETROK_SYSREQ         = 317,
+   RETROK_BREAK          = 318,
+   RETROK_MENU           = 319,
+   RETROK_POWER          = 320,
+   RETROK_EURO           = 321,
+   RETROK_UNDO           = 322,
+   RETROK_OEM_102        = 323,
+
+   RETROK_LAST,
+
+   RETROK_DUMMY          = INT_MAX /* Ensure sizeof(enum) == sizeof(int) */
+};
+
+enum retro_mod
+{
+   RETROKMOD_NONE       = 0x0000,
+
+   RETROKMOD_SHIFT      = 0x01,
+   RETROKMOD_CTRL       = 0x02,
+   RETROKMOD_ALT        = 0x04,
+   RETROKMOD_META       = 0x08,
+
+   RETROKMOD_NUMLOCK    = 0x10,
+   RETROKMOD_CAPSLOCK   = 0x20,
+   RETROKMOD_SCROLLOCK  = 0x40,
+
+   RETROKMOD_DUMMY = INT_MAX /* Ensure sizeof(enum) == sizeof(int) */
+};
+
+/* If set, this call is not part of the public libretro API yet. It can
+ * change or be removed at any time. */
+#define RETRO_ENVIRONMENT_EXPERIMENTAL 0x10000
+/* Environment callback to be used internally in frontend. */
+#define RETRO_ENVIRONMENT_PRIVATE 0x20000
+
+/* Environment commands. */
+#define RETRO_ENVIRONMENT_SET_ROTATION  1  /* const unsigned * --
+                                            * Sets screen rotation of graphics.
+                                            * Valid values are 0, 1, 2, 3, which rotates screen by 0, 90, 180,
+                                            * 270 degrees counter-clockwise respectively.
+                                            */
+#define RETRO_ENVIRONMENT_GET_OVERSCAN  2  /* bool * --
+                                            * NOTE: As of 2019 this callback is considered deprecated in favor of
+                                            * using core options to manage overscan in a more nuanced, core-specific way.
+                                            *
+                                            * Boolean value whether or not the implementation should use overscan,
+                                            * or crop away overscan.
+                                            */
+#define RETRO_ENVIRONMENT_GET_CAN_DUPE  3  /* bool * --
+                                            * Boolean value whether or not frontend supports frame duping,
+                                            * passing NULL to video frame callback.
+                                            */
+
+                                           /* Environ 4, 5 are no longer supported (GET_VARIABLE / SET_VARIABLES),
+                                            * and reserved to avoid possible ABI clash.
+                                            */
+
+#define RETRO_ENVIRONMENT_SET_MESSAGE   6  /* const struct retro_message * --
+                                            * Sets a message to be displayed in implementation-specific manner
+                                            * for a certain amount of 'frames'.
+                                            * Should not be used for trivial messages, which should simply be
+                                            * logged via RETRO_ENVIRONMENT_GET_LOG_INTERFACE (or as a
+                                            * fallback, stderr).
+                                            */
+#define RETRO_ENVIRONMENT_SHUTDOWN      7  /* N/A (NULL) --
+                                            * Requests the frontend to shutdown.
+                                            * Should only be used if game has a specific
+                                            * way to shutdown the game from a menu item or similar.
+                                            */
+#define RETRO_ENVIRONMENT_SET_PERFORMANCE_LEVEL 8
+                                           /* const unsigned * --
+                                            * Gives a hint to the frontend how demanding this implementation
+                                            * is on a system. E.g. reporting a level of 2 means
+                                            * this implementation should run decently on all frontends
+                                            * of level 2 and up.
+                                            *
+                                            * It can be used by the frontend to potentially warn
+                                            * about too demanding implementations.
+                                            *
+                                            * The levels are "floating".
+                                            *
+                                            * This function can be called on a per-game basis,
+                                            * as certain games an implementation can play might be
+                                            * particularly demanding.
+                                            * If called, it should be called in retro_load_game().
+                                            */
+#define RETRO_ENVIRONMENT_GET_SYSTEM_DIRECTORY 9
+                                           /* const char ** --
+                                            * Returns the "system" directory of the frontend.
+                                            * This directory can be used to store system specific
+                                            * content such as BIOSes, configuration data, etc.
+                                            * The returned value can be NULL.
+                                            * If so, no such directory is defined,
+                                            * and it's up to the implementation to find a suitable directory.
+                                            *
+                                            * NOTE: Some cores used this folder also for "save" data such as
+                                            * memory cards, etc, for lack of a better place to put it.
+                                            * This is now discouraged, and if possible, cores should try to
+                                            * use the new GET_SAVE_DIRECTORY.
+                                            */
+#define RETRO_ENVIRONMENT_SET_PIXEL_FORMAT 10
+                                           /* const enum retro_pixel_format * --
+                                            * Sets the internal pixel format used by the implementation.
+                                            * The default pixel format is RETRO_PIXEL_FORMAT_0RGB1555.
+                                            * This pixel format however, is deprecated (see enum retro_pixel_format).
+                                            * If the call returns false, the frontend does not support this pixel
+                                            * format.
+                                            *
+                                            * This function should be called inside retro_load_game() or
+                                            * retro_get_system_av_info().
+                                            */
+#define RETRO_ENVIRONMENT_SET_INPUT_DESCRIPTORS 11
+                                           /* const struct retro_input_descriptor * --
+                                            * Sets an array of retro_input_descriptors.
+                                            * It is up to the frontend to present this in a usable way.
+                                            * The array is terminated by retro_input_descriptor::description
+                                            * being set to NULL.
+                                            * This function can be called at any time, but it is recommended
+                                            * to call it as early as possible.
+                                            */
+#define RETRO_ENVIRONMENT_SET_KEYBOARD_CALLBACK 12
+                                           /* const struct retro_keyboard_callback * --
+                                            * Sets a callback function used to notify core about keyboard events.
+                                            */
+#define RETRO_ENVIRONMENT_SET_DISK_CONTROL_INTERFACE 13
+                                           /* const struct retro_disk_control_callback * --
+                                            * Sets an interface which frontend can use to eject and insert
+                                            * disk images.
+                                            * This is used for games which consist of multiple images and
+                                            * must be manually swapped out by the user (e.g. PSX).
+                                            */
+#define RETRO_ENVIRONMENT_SET_HW_RENDER 14
+                                           /* struct retro_hw_render_callback * --
+                                            * Sets an interface to let a libretro core render with
+                                            * hardware acceleration.
+                                            * Should be called in retro_load_game().
+                                            * If successful, libretro cores will be able to render to a
+                                            * frontend-provided framebuffer.
+                                            * The size of this framebuffer will be at least as large as
+                                            * max_width/max_height provided in get_av_info().
+                                            * If HW rendering is used, pass only RETRO_HW_FRAME_BUFFER_VALID or
+                                            * NULL to retro_video_refresh_t.
+                                            */
+#define RETRO_ENVIRONMENT_GET_VARIABLE 15
+                                           /* struct retro_variable * --
+                                            * Interface to acquire user-defined information from environment
+                                            * that cannot feasibly be supported in a multi-system way.
+                                            * 'key' should be set to a key which has already been set by
+                                            * SET_VARIABLES.
+                                            * 'data' will be set to a value or NULL.
+                                            */
+#define RETRO_ENVIRONMENT_SET_VARIABLES 16
+                                           /* const struct retro_variable * --
+                                            * Allows an implementation to signal the environment
+                                            * which variables it might want to check for later using
+                                            * GET_VARIABLE.
+                                            * This allows the frontend to present these variables to
+                                            * a user dynamically.
+                                            * This should be called the first time as early as
+                                            * possible (ideally in retro_set_environment).
+                                            * Afterward it may be called again for the core to communicate
+                                            * updated options to the frontend, but the number of core
+                                            * options must not change from the number in the initial call.
+                                            *
+                                            * 'data' points to an array of retro_variable structs
+                                            * terminated by a { NULL, NULL } element.
+                                            * retro_variable::key should be namespaced to not collide
+                                            * with other implementations' keys. E.g. A core called
+                                            * 'foo' should use keys named as 'foo_option'.
+                                            * retro_variable::value should contain a human readable
+                                            * description of the key as well as a '|' delimited list
+                                            * of expected values.
+                                            *
+                                            * The number of possible options should be very limited,
+                                            * i.e. it should be feasible to cycle through options
+                                            * without a keyboard.
+                                            *
+                                            * First entry should be treated as a default.
+                                            *
+                                            * Example entry:
+                                            * { "foo_option", "Speed hack coprocessor X; false|true" }
+                                            *
+                                            * Text before first ';' is description. This ';' must be
+                                            * followed by a space, and followed by a list of possible
+                                            * values split up with '|'.
+                                            *
+                                            * Only strings are operated on. The possible values will
+                                            * generally be displayed and stored as-is by the frontend.
+                                            */
+#define RETRO_ENVIRONMENT_GET_VARIABLE_UPDATE 17
+                                           /* bool * --
+                                            * Result is set to true if some variables are updated by
+                                            * frontend since last call to RETRO_ENVIRONMENT_GET_VARIABLE.
+                                            * Variables should be queried with GET_VARIABLE.
+                                            */
+#define RETRO_ENVIRONMENT_SET_SUPPORT_NO_GAME 18
+                                           /* const bool * --
+                                            * If true, the libretro implementation supports calls to
+                                            * retro_load_game() with NULL as argument.
+                                            * Used by cores which can run without particular game data.
+                                            * This should be called within retro_set_environment() only.
+                                            */
+#define RETRO_ENVIRONMENT_GET_LIBRETRO_PATH 19
+                                           /* const char ** --
+                                            * Retrieves the absolute path from where this libretro
+                                            * implementation was loaded.
+                                            * NULL is returned if the libretro was loaded statically
+                                            * (i.e. linked statically to frontend), or if the path cannot be
+                                            * determined.
+                                            * Mostly useful in cooperation with SET_SUPPORT_NO_GAME as assets can
+                                            * be loaded without ugly hacks.
+                                            */
+
+                                           /* Environment 20 was an obsolete version of SET_AUDIO_CALLBACK.
+                                            * It was not used by any known core at the time,
+                                            * and was removed from the API. */
+#define RETRO_ENVIRONMENT_SET_FRAME_TIME_CALLBACK 21
+                                           /* const struct retro_frame_time_callback * --
+                                            * Lets the core know how much time has passed since last
+                                            * invocation of retro_run().
+                                            * The frontend can tamper with the timing to fake fast-forward,
+                                            * slow-motion, frame stepping, etc.
+                                            * In this case the delta time will use the reference value
+                                            * in frame_time_callback..
+                                            */
+#define RETRO_ENVIRONMENT_SET_AUDIO_CALLBACK 22
+                                           /* const struct retro_audio_callback * --
+                                            * Sets an interface which is used to notify a libretro core about audio
+                                            * being available for writing.
+                                            * The callback can be called from any thread, so a core using this must
+                                            * have a thread safe audio implementation.
+                                            * It is intended for games where audio and video are completely
+                                            * asynchronous and audio can be generated on the fly.
+                                            * This interface is not recommended for use with emulators which have
+                                            * highly synchronous audio.
+                                            *
+                                            * The callback only notifies about writability; the libretro core still
+                                            * has to call the normal audio callbacks
+                                            * to write audio. The audio callbacks must be called from within the
+                                            * notification callback.
+                                            * The amount of audio data to write is up to the implementation.
+                                            * Generally, the audio callback will be called continously in a loop.
+                                            *
+                                            * Due to thread safety guarantees and lack of sync between audio and
+                                            * video, a frontend  can selectively disallow this interface based on
+                                            * internal configuration. A core using this interface must also
+                                            * implement the "normal" audio interface.
+                                            *
+                                            * A libretro core using SET_AUDIO_CALLBACK should also make use of
+                                            * SET_FRAME_TIME_CALLBACK.
+                                            */
+#define RETRO_ENVIRONMENT_GET_RUMBLE_INTERFACE 23
+                                           /* struct retro_rumble_interface * --
+                                            * Gets an interface which is used by a libretro core to set
+                                            * state of rumble motors in controllers.
+                                            * A strong and weak motor is supported, and they can be
+                                            * controlled indepedently.
+                                            * Should be called from either retro_init() or retro_load_game().
+                                            * Should not be called from retro_set_environment().
+                                            * Returns false if rumble functionality is unavailable.
+                                            */
+#define RETRO_ENVIRONMENT_GET_INPUT_DEVICE_CAPABILITIES 24
+                                           /* uint64_t * --
+                                            * Gets a bitmask telling which device type are expected to be
+                                            * handled properly in a call to retro_input_state_t.
+                                            * Devices which are not handled or recognized always return
+                                            * 0 in retro_input_state_t.
+                                            * Example bitmask: caps = (1 << RETRO_DEVICE_JOYPAD) | (1 << RETRO_DEVICE_ANALOG).
+                                            * Should only be called in retro_run().
+                                            */
+#define RETRO_ENVIRONMENT_GET_SENSOR_INTERFACE (25 | RETRO_ENVIRONMENT_EXPERIMENTAL)
+                                           /* struct retro_sensor_interface * --
+                                            * Gets access to the sensor interface.
+                                            * The purpose of this interface is to allow
+                                            * setting state related to sensors such as polling rate,
+                                            * enabling/disable it entirely, etc.
+                                            * Reading sensor state is done via the normal
+                                            * input_state_callback API.
+                                            */
+#define RETRO_ENVIRONMENT_GET_CAMERA_INTERFACE (26 | RETRO_ENVIRONMENT_EXPERIMENTAL)
+                                           /* struct retro_camera_callback * --
+                                            * Gets an interface to a video camera driver.
+                                            * A libretro core can use this interface to get access to a
+                                            * video camera.
+                                            * New video frames are delivered in a callback in same
+                                            * thread as retro_run().
+                                            *
+                                            * GET_CAMERA_INTERFACE should be called in retro_load_game().
+                                            *
+                                            * Depending on the camera implementation used, camera frames
+                                            * will be delivered as a raw framebuffer,
+                                            * or as an OpenGL texture directly.
+                                            *
+                                            * The core has to tell the frontend here which types of
+                                            * buffers can be handled properly.
+                                            * An OpenGL texture can only be handled when using a
+                                            * libretro GL core (SET_HW_RENDER).
+                                            * It is recommended to use a libretro GL core when
+                                            * using camera interface.
+                                            *
+                                            * The camera is not started automatically. The retrieved start/stop
+                                            * functions must be used to explicitly
+                                            * start and stop the camera driver.
+                                            */
+#define RETRO_ENVIRONMENT_GET_LOG_INTERFACE 27
+                                           /* struct retro_log_callback * --
+                                            * Gets an interface for logging. This is useful for
+                                            * logging in a cross-platform way
+                                            * as certain platforms cannot use stderr for logging.
+                                            * It also allows the frontend to
+                                            * show logging information in a more suitable way.
+                                            * If this interface is not used, libretro cores should
+                                            * log to stderr as desired.
+                                            */
+#define RETRO_ENVIRONMENT_GET_PERF_INTERFACE 28
+                                           /* struct retro_perf_callback * --
+                                            * Gets an interface for performance counters. This is useful
+                                            * for performance logging in a cross-platform way and for detecting
+                                            * architecture-specific features, such as SIMD support.
+                                            */
+#define RETRO_ENVIRONMENT_GET_LOCATION_INTERFACE 29
+                                           /* struct retro_location_callback * --
+                                            * Gets access to the location interface.
+                                            * The purpose of this interface is to be able to retrieve
+                                            * location-based information from the host device,
+                                            * such as current latitude / longitude.
+                                            */
+#define RETRO_ENVIRONMENT_GET_CONTENT_DIRECTORY 30 /* Old name, kept for compatibility. */
+#define RETRO_ENVIRONMENT_GET_CORE_ASSETS_DIRECTORY 30
+                                           /* const char ** --
+                                            * Returns the "core assets" directory of the frontend.
+                                            * This directory can be used to store specific assets that the
+                                            * core relies upon, such as art assets,
+                                            * input data, etc etc.
+                                            * The returned value can be NULL.
+                                            * If so, no such directory is defined,
+                                            * and it's up to the implementation to find a suitable directory.
+                                            */
+#define RETRO_ENVIRONMENT_GET_SAVE_DIRECTORY 31
+                                           /* const char ** --
+                                            * Returns the "save" directory of the frontend, unless there is no
+                                            * save directory available. The save directory should be used to
+                                            * store SRAM, memory cards, high scores, etc, if the libretro core
+                                            * cannot use the regular memory interface (retro_get_memory_data()).
+                                            *
+                                            * If the frontend cannot designate a save directory, it will return
+                                            * NULL to indicate that the core should attempt to operate without a
+                                            * save directory set.
+                                            *
+                                            * NOTE: early libretro cores used the system directory for save
+                                            * files. Cores that need to be backwards-compatible can still check
+                                            * GET_SYSTEM_DIRECTORY.
+                                            */
+#define RETRO_ENVIRONMENT_SET_SYSTEM_AV_INFO 32
+                                           /* const struct retro_system_av_info * --
+                                            * Sets a new av_info structure. This can only be called from
+                                            * within retro_run().
+                                            * This should *only* be used if the core is completely altering the
+                                            * internal resolutions, aspect ratios, timings, sampling rate, etc.
+                                            * Calling this can require a full reinitialization of video/audio
+                                            * drivers in the frontend,
+                                            *
+                                            * so it is important to call it very sparingly, and usually only with
+                                            * the users explicit consent.
+                                            * An eventual driver reinitialize will happen so that video and
+                                            * audio callbacks
+                                            * happening after this call within the same retro_run() call will
+                                            * target the newly initialized driver.
+                                            *
+                                            * This callback makes it possible to support configurable resolutions
+                                            * in games, which can be useful to
+                                            * avoid setting the "worst case" in max_width/max_height.
+                                            *
+                                            * ***HIGHLY RECOMMENDED*** Do not call this callback every time
+                                            * resolution changes in an emulator core if it's
+                                            * expected to be a temporary change, for the reasons of possible
+                                            * driver reinitialization.
+                                            * This call is not a free pass for not trying to provide
+                                            * correct values in retro_get_system_av_info(). If you need to change
+                                            * things like aspect ratio or nominal width/height,
+                                            * use RETRO_ENVIRONMENT_SET_GEOMETRY, which is a softer variant
+                                            * of SET_SYSTEM_AV_INFO.
+                                            *
+                                            * If this returns false, the frontend does not acknowledge a
+                                            * changed av_info struct.
+                                            */
+#define RETRO_ENVIRONMENT_SET_PROC_ADDRESS_CALLBACK 33
+                                           /* const struct retro_get_proc_address_interface * --
+                                            * Allows a libretro core to announce support for the
+                                            * get_proc_address() interface.
+                                            * This interface allows for a standard way to extend libretro where
+                                            * use of environment calls are too indirect,
+                                            * e.g. for cases where the frontend wants to call directly into the core.
+                                            *
+                                            * If a core wants to expose this interface, SET_PROC_ADDRESS_CALLBACK
+                                            * **MUST** be called from within retro_set_environment().
+                                            */
+#define RETRO_ENVIRONMENT_SET_SUBSYSTEM_INFO 34
+                                           /* const struct retro_subsystem_info * --
+                                            * This environment call introduces the concept of libretro "subsystems".
+                                            * A subsystem is a variant of a libretro core which supports
+                                            * different kinds of games.
+                                            * The purpose of this is to support e.g. emulators which might
+                                            * have special needs, e.g. Super Nintendo's Super GameBoy, Sufami Turbo.
+                                            * It can also be used to pick among subsystems in an explicit way
+                                            * if the libretro implementation is a multi-system emulator itself.
+                                            *
+                                            * Loading a game via a subsystem is done with retro_load_game_special(),
+                                            * and this environment call allows a libretro core to expose which
+                                            * subsystems are supported for use with retro_load_game_special().
+                                            * A core passes an array of retro_game_special_info which is terminated
+                                            * with a zeroed out retro_game_special_info struct.
+                                            *
+                                            * If a core wants to use this functionality, SET_SUBSYSTEM_INFO
+                                            * **MUST** be called from within retro_set_environment().
+                                            */
+#define RETRO_ENVIRONMENT_SET_CONTROLLER_INFO 35
+                                           /* const struct retro_controller_info * --
+                                            * This environment call lets a libretro core tell the frontend
+                                            * which controller subclasses are recognized in calls to
+                                            * retro_set_controller_port_device().
+                                            *
+                                            * Some emulators such as Super Nintendo support multiple lightgun
+                                            * types which must be specifically selected from. It is therefore
+                                            * sometimes necessary for a frontend to be able to tell the core
+                                            * about a special kind of input device which is not specifcally
+                                            * provided by the Libretro API.
+                                            *
+                                            * In order for a frontend to understand the workings of those devices,
+                                            * they must be defined as a specialized subclass of the generic device
+                                            * types already defined in the libretro API.
+                                            *
+                                            * The core must pass an array of const struct retro_controller_info which
+                                            * is terminated with a blanked out struct. Each element of the
+                                            * retro_controller_info struct corresponds to the ascending port index
+                                            * that is passed to retro_set_controller_port_device() when that function
+                                            * is called to indicate to the core that the frontend has changed the
+                                            * active device subclass. SEE ALSO: retro_set_controller_port_device()
+                                            *
+                                            * The ascending input port indexes provided by the core in the struct
+                                            * are generally presented by frontends as ascending User # or Player #,
+                                            * such as Player 1, Player 2, Player 3, etc. Which device subclasses are
+                                            * supported can vary per input port.
+                                            *
+                                            * The first inner element of each entry in the retro_controller_info array
+                                            * is a retro_controller_description struct that specifies the names and
+                                            * codes of all device subclasses that are available for the corresponding
+                                            * User or Player, beginning with the generic Libretro device that the
+                                            * subclasses are derived from. The second inner element of each entry is the
+                                            * total number of subclasses that are listed in the retro_controller_description.
+                                            *
+                                            * NOTE: Even if special device types are set in the libretro core,
+                                            * libretro should only poll input based on the base input device types.
+                                            */
+#define RETRO_ENVIRONMENT_SET_MEMORY_MAPS (36 | RETRO_ENVIRONMENT_EXPERIMENTAL)
+                                           /* const struct retro_memory_map * --
+                                            * This environment call lets a libretro core tell the frontend
+                                            * about the memory maps this core emulates.
+                                            * This can be used to implement, for example, cheats in a core-agnostic way.
+                                            *
+                                            * Should only be used by emulators; it doesn't make much sense for
+                                            * anything else.
+                                            * It is recommended to expose all relevant pointers through
+                                            * retro_get_memory_* as well.
+                                            *
+                                            * Can be called from retro_init and retro_load_game.
+                                            */
+#define RETRO_ENVIRONMENT_SET_GEOMETRY 37
+                                           /* const struct retro_game_geometry * --
+                                            * This environment call is similar to SET_SYSTEM_AV_INFO for changing
+                                            * video parameters, but provides a guarantee that drivers will not be
+                                            * reinitialized.
+                                            * This can only be called from within retro_run().
+                                            *
+                                            * The purpose of this call is to allow a core to alter nominal
+                                            * width/heights as well as aspect ratios on-the-fly, which can be
+                                            * useful for some emulators to change in run-time.
+                                            *
+                                            * max_width/max_height arguments are ignored and cannot be changed
+                                            * with this call as this could potentially require a reinitialization or a
+                                            * non-constant time operation.
+                                            * If max_width/max_height are to be changed, SET_SYSTEM_AV_INFO is required.
+                                            *
+                                            * A frontend must guarantee that this environment call completes in
+                                            * constant time.
+                                            */
+#define RETRO_ENVIRONMENT_GET_USERNAME 38
+                                           /* const char **
+                                            * Returns the specified username of the frontend, if specified by the user.
+                                            * This username can be used as a nickname for a core that has online facilities
+                                            * or any other mode where personalization of the user is desirable.
+                                            * The returned value can be NULL.
+                                            * If this environ callback is used by a core that requires a valid username,
+                                            * a default username should be specified by the core.
+                                            */
+#define RETRO_ENVIRONMENT_GET_LANGUAGE 39
+                                           /* unsigned * --
+                                            * Returns the specified language of the frontend, if specified by the user.
+                                            * It can be used by the core for localization purposes.
+                                            */
+#define RETRO_ENVIRONMENT_GET_CURRENT_SOFTWARE_FRAMEBUFFER (40 | RETRO_ENVIRONMENT_EXPERIMENTAL)
+                                           /* struct retro_framebuffer * --
+                                            * Returns a preallocated framebuffer which the core can use for rendering
+                                            * the frame into when not using SET_HW_RENDER.
+                                            * The framebuffer returned from this call must not be used
+                                            * after the current call to retro_run() returns.
+                                            *
+                                            * The goal of this call is to allow zero-copy behavior where a core
+                                            * can render directly into video memory, avoiding extra bandwidth cost by copying
+                                            * memory from core to video memory.
+                                            *
+                                            * If this call succeeds and the core renders into it,
+                                            * the framebuffer pointer and pitch can be passed to retro_video_refresh_t.
+                                            * If the buffer from GET_CURRENT_SOFTWARE_FRAMEBUFFER is to be used,
+                                            * the core must pass the exact
+                                            * same pointer as returned by GET_CURRENT_SOFTWARE_FRAMEBUFFER;
+                                            * i.e. passing a pointer which is offset from the
+                                            * buffer is undefined. The width, height and pitch parameters
+                                            * must also match exactly to the values obtained from GET_CURRENT_SOFTWARE_FRAMEBUFFER.
+                                            *
+                                            * It is possible for a frontend to return a different pixel format
+                                            * than the one used in SET_PIXEL_FORMAT. This can happen if the frontend
+                                            * needs to perform conversion.
+                                            *
+                                            * It is still valid for a core to render to a different buffer
+                                            * even if GET_CURRENT_SOFTWARE_FRAMEBUFFER succeeds.
+                                            *
+                                            * A frontend must make sure that the pointer obtained from this function is
+                                            * writeable (and readable).
+                                            */
+#define RETRO_ENVIRONMENT_GET_HW_RENDER_INTERFACE (41 | RETRO_ENVIRONMENT_EXPERIMENTAL)
+                                           /* const struct retro_hw_render_interface ** --
+                                            * Returns an API specific rendering interface for accessing API specific data.
+                                            * Not all HW rendering APIs support or need this.
+                                            * The contents of the returned pointer is specific to the rendering API
+                                            * being used. See the various headers like libretro_vulkan.h, etc.
+                                            *
+                                            * GET_HW_RENDER_INTERFACE cannot be called before context_reset has been called.
+                                            * Similarly, after context_destroyed callback returns,
+                                            * the contents of the HW_RENDER_INTERFACE are invalidated.
+                                            */
+#define RETRO_ENVIRONMENT_SET_SUPPORT_ACHIEVEMENTS (42 | RETRO_ENVIRONMENT_EXPERIMENTAL)
+                                           /* const bool * --
+                                            * If true, the libretro implementation supports achievements
+                                            * either via memory descriptors set with RETRO_ENVIRONMENT_SET_MEMORY_MAPS
+                                            * or via retro_get_memory_data/retro_get_memory_size.
+                                            *
+                                            * This must be called before the first call to retro_run.
+                                            */
+#define RETRO_ENVIRONMENT_SET_HW_RENDER_CONTEXT_NEGOTIATION_INTERFACE (43 | RETRO_ENVIRONMENT_EXPERIMENTAL)
+                                           /* const struct retro_hw_render_context_negotiation_interface * --
+                                            * Sets an interface which lets the libretro core negotiate with frontend how a context is created.
+                                            * The semantics of this interface depends on which API is used in SET_HW_RENDER earlier.
+                                            * This interface will be used when the frontend is trying to create a HW rendering context,
+                                            * so it will be used after SET_HW_RENDER, but before the context_reset callback.
+                                            */
+#define RETRO_ENVIRONMENT_SET_SERIALIZATION_QUIRKS 44
+                                           /* uint64_t * --
+                                            * Sets quirk flags associated with serialization. The frontend will zero any flags it doesn't
+                                            * recognize or support. Should be set in either retro_init or retro_load_game, but not both.
+                                            */
+#define RETRO_ENVIRONMENT_SET_HW_SHARED_CONTEXT (44 | RETRO_ENVIRONMENT_EXPERIMENTAL)
+                                           /* N/A (null) * --
+                                            * The frontend will try to use a 'shared' hardware context (mostly applicable
+                                            * to OpenGL) when a hardware context is being set up.
+                                            *
+                                            * Returns true if the frontend supports shared hardware contexts and false
+                                            * if the frontend does not support shared hardware contexts.
+                                            *
+                                            * This will do nothing on its own until SET_HW_RENDER env callbacks are
+                                            * being used.
+                                            */
+#define RETRO_ENVIRONMENT_GET_VFS_INTERFACE (45 | RETRO_ENVIRONMENT_EXPERIMENTAL)
+                                           /* struct retro_vfs_interface_info * --
+                                            * Gets access to the VFS interface.
+                                            * VFS presence needs to be queried prior to load_game or any
+                                            * get_system/save/other_directory being called to let front end know
+                                            * core supports VFS before it starts handing out paths.
+                                            * It is recomended to do so in retro_set_environment
+                                            */
+#define RETRO_ENVIRONMENT_GET_LED_INTERFACE (46 | RETRO_ENVIRONMENT_EXPERIMENTAL)
+                                           /* struct retro_led_interface * --
+                                            * Gets an interface which is used by a libretro core to set
+                                            * state of LEDs.
+                                            */
+#define RETRO_ENVIRONMENT_GET_AUDIO_VIDEO_ENABLE (47 | RETRO_ENVIRONMENT_EXPERIMENTAL)
+                                           /* int * --
+                                            * Tells the core if the frontend wants audio or video.
+                                            * If disabled, the frontend will discard the audio or video,
+                                            * so the core may decide to skip generating a frame or generating audio.
+                                            * This is mainly used for increasing performance.
+                                            * Bit 0 (value 1): Enable Video
+                                            * Bit 1 (value 2): Enable Audio
+                                            * Bit 2 (value 4): Use Fast Savestates.
+                                            * Bit 3 (value 8): Hard Disable Audio
+                                            * Other bits are reserved for future use and will default to zero.
+                                            * If video is disabled:
+                                            * * The frontend wants the core to not generate any video,
+                                            *   including presenting frames via hardware acceleration.
+                                            * * The frontend's video frame callback will do nothing.
+                                            * * After running the frame, the video output of the next frame should be
+                                            *   no different than if video was enabled, and saving and loading state
+                                            *   should have no issues.
+                                            * If audio is disabled:
+                                            * * The frontend wants the core to not generate any audio.
+                                            * * The frontend's audio callbacks will do nothing.
+                                            * * After running the frame, the audio output of the next frame should be
+                                            *   no different than if audio was enabled, and saving and loading state
+                                            *   should have no issues.
+                                            * Fast Savestates:
+                                            * * Guaranteed to be created by the same binary that will load them.
+                                            * * Will not be written to or read from the disk.
+                                            * * Suggest that the core assumes loading state will succeed.
+                                            * * Suggest that the core updates its memory buffers in-place if possible.
+                                            * * Suggest that the core skips clearing memory.
+                                            * * Suggest that the core skips resetting the system.
+                                            * * Suggest that the core may skip validation steps.
+                                            * Hard Disable Audio:
+                                            * * Used for a secondary core when running ahead.
+                                            * * Indicates that the frontend will never need audio from the core.
+                                            * * Suggests that the core may stop synthesizing audio, but this should not
+                                            *   compromise emulation accuracy.
+                                            * * Audio output for the next frame does not matter, and the frontend will
+                                            *   never need an accurate audio state in the future.
+                                            * * State will never be saved when using Hard Disable Audio.
+                                            */
+#define RETRO_ENVIRONMENT_GET_MIDI_INTERFACE (48 | RETRO_ENVIRONMENT_EXPERIMENTAL)
+                                           /* struct retro_midi_interface ** --
+                                            * Returns a MIDI interface that can be used for raw data I/O.
+                                            */
+
+#define RETRO_ENVIRONMENT_GET_FASTFORWARDING (49 | RETRO_ENVIRONMENT_EXPERIMENTAL)
+                                            /* bool * --
+                                            * Boolean value that indicates whether or not the frontend is in
+                                            * fastforwarding mode.
+                                            */
+
+#define RETRO_ENVIRONMENT_GET_TARGET_REFRESH_RATE (50 | RETRO_ENVIRONMENT_EXPERIMENTAL)
+                                            /* float * --
+                                            * Float value that lets us know what target refresh rate
+                                            * is curently in use by the frontend.
+                                            *
+                                            * The core can use the returned value to set an ideal
+                                            * refresh rate/framerate.
+                                            */
+
+#define RETRO_ENVIRONMENT_GET_INPUT_BITMASKS (51 | RETRO_ENVIRONMENT_EXPERIMENTAL)
+                                            /* bool * --
+                                            * Boolean value that indicates whether or not the frontend supports
+                                            * input bitmasks being returned by retro_input_state_t. The advantage
+                                            * of this is that retro_input_state_t has to be only called once to
+                                            * grab all button states instead of multiple times.
+                                            *
+                                            * If it returns true, you can pass RETRO_DEVICE_ID_JOYPAD_MASK as 'id'
+                                            * to retro_input_state_t (make sure 'device' is set to RETRO_DEVICE_JOYPAD).
+                                            * It will return a bitmask of all the digital buttons.
+                                            */
+
+#define RETRO_ENVIRONMENT_GET_CORE_OPTIONS_VERSION 52
+                                           /* unsigned * --
+                                            * Unsigned value is the API version number of the core options
+                                            * interface supported by the frontend. If callback return false,
+                                            * API version is assumed to be 0.
+                                            *
+                                            * In legacy code, core options are set by passing an array of
+                                            * retro_variable structs to RETRO_ENVIRONMENT_SET_VARIABLES.
+                                            * This may be still be done regardless of the core options
+                                            * interface version.
+                                            *
+                                            * If version is >= 1 however, core options may instead be set by
+                                            * passing an array of retro_core_option_definition structs to
+                                            * RETRO_ENVIRONMENT_SET_CORE_OPTIONS, or a 2D array of
+                                            * retro_core_option_definition structs to RETRO_ENVIRONMENT_SET_CORE_OPTIONS_INTL.
+                                            * This allows the core to additionally set option sublabel information
+                                            * and/or provide localisation support.
+                                            *
+                                            * If version is >= 2, core options may instead be set by passing
+                                            * a retro_core_options_v2 struct to RETRO_ENVIRONMENT_SET_CORE_OPTIONS_V2,
+                                            * or an array of retro_core_options_v2 structs to
+                                            * RETRO_ENVIRONMENT_SET_CORE_OPTIONS_V2_INTL. This allows the core
+                                            * to additionally set optional core option category information
+                                            * for frontends with core option category support.
+                                            */
+
+#define RETRO_ENVIRONMENT_SET_CORE_OPTIONS 53
+                                           /* const struct retro_core_option_definition ** --
+                                            * Allows an implementation to signal the environment
+                                            * which variables it might want to check for later using
+                                            * GET_VARIABLE.
+                                            * This allows the frontend to present these variables to
+                                            * a user dynamically.
+                                            * This should only be called if RETRO_ENVIRONMENT_GET_CORE_OPTIONS_VERSION
+                                            * returns an API version of >= 1.
+                                            * This should be called instead of RETRO_ENVIRONMENT_SET_VARIABLES.
+                                            * This should be called the first time as early as
+                                            * possible (ideally in retro_set_environment).
+                                            * Afterwards it may be called again for the core to communicate
+                                            * updated options to the frontend, but the number of core
+                                            * options must not change from the number in the initial call.
+                                            *
+                                            * 'data' points to an array of retro_core_option_definition structs
+                                            * terminated by a { NULL, NULL, NULL, {{0}}, NULL } element.
+                                            * retro_core_option_definition::key should be namespaced to not collide
+                                            * with other implementations' keys. e.g. A core called
+                                            * 'foo' should use keys named as 'foo_option'.
+                                            * retro_core_option_definition::desc should contain a human readable
+                                            * description of the key.
+                                            * retro_core_option_definition::info should contain any additional human
+                                            * readable information text that a typical user may need to
+                                            * understand the functionality of the option.
+                                            * retro_core_option_definition::values is an array of retro_core_option_value
+                                            * structs terminated by a { NULL, NULL } element.
+                                            * > retro_core_option_definition::values[index].value is an expected option
+                                            *   value.
+                                            * > retro_core_option_definition::values[index].label is a human readable
+                                            *   label used when displaying the value on screen. If NULL,
+                                            *   the value itself is used.
+                                            * retro_core_option_definition::default_value is the default core option
+                                            * setting. It must match one of the expected option values in the
+                                            * retro_core_option_definition::values array. If it does not, or the
+                                            * default value is NULL, the first entry in the
+                                            * retro_core_option_definition::values array is treated as the default.
+                                            *
+                                            * The number of possible option values should be very limited,
+                                            * and must be less than RETRO_NUM_CORE_OPTION_VALUES_MAX.
+                                            * i.e. it should be feasible to cycle through options
+                                            * without a keyboard.
+                                            *
+                                            * Example entry:
+                                            * {
+                                            *     "foo_option",
+                                            *     "Speed hack coprocessor X",
+                                            *     "Provides increased performance at the expense of reduced accuracy",
+                                            * 	  {
+                                            *         { "false",    NULL },
+                                            *         { "true",     NULL },
+                                            *         { "unstable", "Turbo (Unstable)" },
+                                            *         { NULL, NULL },
+                                            *     },
+                                            *     "false"
+                                            * }
+                                            *
+                                            * Only strings are operated on. The possible values will
+                                            * generally be displayed and stored as-is by the frontend.
+                                            */
+
+#define RETRO_ENVIRONMENT_SET_CORE_OPTIONS_INTL 54
+                                           /* const struct retro_core_options_intl * --
+                                            * Allows an implementation to signal the environment
+                                            * which variables it might want to check for later using
+                                            * GET_VARIABLE.
+                                            * This allows the frontend to present these variables to
+                                            * a user dynamically.
+                                            * This should only be called if RETRO_ENVIRONMENT_GET_CORE_OPTIONS_VERSION
+                                            * returns an API version of >= 1.
+                                            * This should be called instead of RETRO_ENVIRONMENT_SET_VARIABLES.
+                                            * This should be called instead of RETRO_ENVIRONMENT_SET_CORE_OPTIONS.
+                                            * This should be called the first time as early as
+                                            * possible (ideally in retro_set_environment).
+                                            * Afterwards it may be called again for the core to communicate
+                                            * updated options to the frontend, but the number of core
+                                            * options must not change from the number in the initial call.
+                                            *
+                                            * This is fundamentally the same as RETRO_ENVIRONMENT_SET_CORE_OPTIONS,
+                                            * with the addition of localisation support. The description of the
+                                            * RETRO_ENVIRONMENT_SET_CORE_OPTIONS callback should be consulted
+                                            * for further details.
+                                            *
+                                            * 'data' points to a retro_core_options_intl struct.
+                                            *
+                                            * retro_core_options_intl::us is a pointer to an array of
+                                            * retro_core_option_definition structs defining the US English
+                                            * core options implementation. It must point to a valid array.
+                                            *
+                                            * retro_core_options_intl::local is a pointer to an array of
+                                            * retro_core_option_definition structs defining core options for
+                                            * the current frontend language. It may be NULL (in which case
+                                            * retro_core_options_intl::us is used by the frontend). Any items
+                                            * missing from this array will be read from retro_core_options_intl::us
+                                            * instead.
+                                            *
+                                            * NOTE: Default core option values are always taken from the
+                                            * retro_core_options_intl::us array. Any default values in
+                                            * retro_core_options_intl::local array will be ignored.
+                                            */
+
+#define RETRO_ENVIRONMENT_SET_CORE_OPTIONS_DISPLAY 55
+                                           /* struct retro_core_option_display * --
+                                            *
+                                            * Allows an implementation to signal the environment to show
+                                            * or hide a variable when displaying core options. This is
+                                            * considered a *suggestion*. The frontend is free to ignore
+                                            * this callback, and its implementation not considered mandatory.
+                                            *
+                                            * 'data' points to a retro_core_option_display struct
+                                            *
+                                            * retro_core_option_display::key is a variable identifier
+                                            * which has already been set by SET_VARIABLES/SET_CORE_OPTIONS.
+                                            *
+                                            * retro_core_option_display::visible is a boolean, specifying
+                                            * whether variable should be displayed
+                                            *
+                                            * Note that all core option variables will be set visible by
+                                            * default when calling SET_VARIABLES/SET_CORE_OPTIONS.
+                                            */
+
+#define RETRO_ENVIRONMENT_GET_PREFERRED_HW_RENDER 56
+                                           /* unsigned * --
+                                            *
+                                            * Allows an implementation to ask frontend preferred hardware
+                                            * context to use. Core should use this information to deal
+                                            * with what specific context to request with SET_HW_RENDER.
+                                            *
+                                            * 'data' points to an unsigned variable
+                                            */
+
+#define RETRO_ENVIRONMENT_GET_DISK_CONTROL_INTERFACE_VERSION 57
+                                           /* unsigned * --
+                                            * Unsigned value is the API version number of the disk control
+                                            * interface supported by the frontend. If callback return false,
+                                            * API version is assumed to be 0.
+                                            *
+                                            * In legacy code, the disk control interface is defined by passing
+                                            * a struct of type retro_disk_control_callback to
+                                            * RETRO_ENVIRONMENT_SET_DISK_CONTROL_INTERFACE.
+                                            * This may be still be done regardless of the disk control
+                                            * interface version.
+                                            *
+                                            * If version is >= 1 however, the disk control interface may
+                                            * instead be defined by passing a struct of type
+                                            * retro_disk_control_ext_callback to
+                                            * RETRO_ENVIRONMENT_SET_DISK_CONTROL_EXT_INTERFACE.
+                                            * This allows the core to provide additional information about
+                                            * disk images to the frontend and/or enables extra
+                                            * disk control functionality by the frontend.
+                                            */
+
+#define RETRO_ENVIRONMENT_SET_DISK_CONTROL_EXT_INTERFACE 58
+                                           /* const struct retro_disk_control_ext_callback * --
+                                            * Sets an interface which frontend can use to eject and insert
+                                            * disk images, and also obtain information about individual
+                                            * disk image files registered by the core.
+                                            * This is used for games which consist of multiple images and
+                                            * must be manually swapped out by the user (e.g. PSX, floppy disk
+                                            * based systems).
+                                            */
+
+#define RETRO_ENVIRONMENT_GET_MESSAGE_INTERFACE_VERSION 59
+                                           /* unsigned * --
+                                            * Unsigned value is the API version number of the message
+                                            * interface supported by the frontend. If callback returns
+                                            * false, API version is assumed to be 0.
+                                            *
+                                            * In legacy code, messages may be displayed in an
+                                            * implementation-specific manner by passing a struct
+                                            * of type retro_message to RETRO_ENVIRONMENT_SET_MESSAGE.
+                                            * This may be still be done regardless of the message
+                                            * interface version.
+                                            *
+                                            * If version is >= 1 however, messages may instead be
+                                            * displayed by passing a struct of type retro_message_ext
+                                            * to RETRO_ENVIRONMENT_SET_MESSAGE_EXT. This allows the
+                                            * core to specify message logging level, priority and
+                                            * destination (OSD, logging interface or both).
+                                            */
+
+#define RETRO_ENVIRONMENT_SET_MESSAGE_EXT 60
+                                           /* const struct retro_message_ext * --
+                                            * Sets a message to be displayed in an implementation-specific
+                                            * manner for a certain amount of 'frames'. Additionally allows
+                                            * the core to specify message logging level, priority and
+                                            * destination (OSD, logging interface or both).
+                                            * Should not be used for trivial messages, which should simply be
+                                            * logged via RETRO_ENVIRONMENT_GET_LOG_INTERFACE (or as a
+                                            * fallback, stderr).
+                                            */
+
+#define RETRO_ENVIRONMENT_GET_INPUT_MAX_USERS 61
+                                           /* unsigned * --
+                                            * Unsigned value is the number of active input devices
+                                            * provided by the frontend. This may change between
+                                            * frames, but will remain constant for the duration
+                                            * of each frame.
+                                            * If callback returns true, a core need not poll any
+                                            * input device with an index greater than or equal to
+                                            * the number of active devices.
+                                            * If callback returns false, the number of active input
+                                            * devices is unknown. In this case, all input devices
+                                            * should be considered active.
+                                            */
+
+#define RETRO_ENVIRONMENT_SET_AUDIO_BUFFER_STATUS_CALLBACK 62
+                                           /* const struct retro_audio_buffer_status_callback * --
+                                            * Lets the core know the occupancy level of the frontend
+                                            * audio buffer. Can be used by a core to attempt frame
+                                            * skipping in order to avoid buffer under-runs.
+                                            * A core may pass NULL to disable buffer status reporting
+                                            * in the frontend.
+                                            */
+
+#define RETRO_ENVIRONMENT_SET_MINIMUM_AUDIO_LATENCY 63
+                                           /* const unsigned * --
+                                            * Sets minimum frontend audio latency in milliseconds.
+                                            * Resultant audio latency may be larger than set value,
+                                            * or smaller if a hardware limit is encountered. A frontend
+                                            * is expected to honour requests up to 512 ms.
+                                            *
+                                            * - If value is less than current frontend
+                                            *   audio latency, callback has no effect
+                                            * - If value is zero, default frontend audio
+                                            *   latency is set
+                                            *
+                                            * May be used by a core to increase audio latency and
+                                            * therefore decrease the probability of buffer under-runs
+                                            * (crackling) when performing 'intensive' operations.
+                                            * A core utilising RETRO_ENVIRONMENT_SET_AUDIO_BUFFER_STATUS_CALLBACK
+                                            * to implement audio-buffer-based frame skipping may achieve
+                                            * optimal results by setting the audio latency to a 'high'
+                                            * (typically 6x or 8x) integer multiple of the expected
+                                            * frame time.
+                                            *
+                                            * WARNING: This can only be called from within retro_run().
+                                            * Calling this can require a full reinitialization of audio
+                                            * drivers in the frontend, so it is important to call it very
+                                            * sparingly, and usually only with the users explicit consent.
+                                            * An eventual driver reinitialize will happen so that audio
+                                            * callbacks happening after this call within the same retro_run()
+                                            * call will target the newly initialized driver.
+                                            */
+
+#define RETRO_ENVIRONMENT_SET_FASTFORWARDING_OVERRIDE 64
+                                           /* const struct retro_fastforwarding_override * --
+                                            * Used by a libretro core to override the current
+                                            * fastforwarding mode of the frontend.
+                                            * If NULL is passed to this function, the frontend
+                                            * will return true if fastforwarding override
+                                            * functionality is supported (no change in
+                                            * fastforwarding state will occur in this case).
+                                            */
+
+#define RETRO_ENVIRONMENT_SET_CONTENT_INFO_OVERRIDE 65
+                                           /* const struct retro_system_content_info_override * --
+                                            * Allows an implementation to override 'global' content
+                                            * info parameters reported by retro_get_system_info().
+                                            * Overrides also affect subsystem content info parameters
+                                            * set via RETRO_ENVIRONMENT_SET_SUBSYSTEM_INFO.
+                                            * This function must be called inside retro_set_environment().
+                                            * If callback returns false, content info overrides
+                                            * are unsupported by the frontend, and will be ignored.
+                                            * If callback returns true, extended game info may be
+                                            * retrieved by calling RETRO_ENVIRONMENT_GET_GAME_INFO_EXT
+                                            * in retro_load_game() or retro_load_game_special().
+                                            *
+                                            * 'data' points to an array of retro_system_content_info_override
+                                            * structs terminated by a { NULL, false, false } element.
+                                            * If 'data' is NULL, no changes will be made to the frontend;
+                                            * a core may therefore pass NULL in order to test whether
+                                            * the RETRO_ENVIRONMENT_SET_CONTENT_INFO_OVERRIDE and
+                                            * RETRO_ENVIRONMENT_GET_GAME_INFO_EXT callbacks are supported
+                                            * by the frontend.
+                                            *
+                                            * For struct member descriptions, see the definition of
+                                            * struct retro_system_content_info_override.
+                                            *
+                                            * Example:
+                                            *
+                                            * - struct retro_system_info:
+                                            * {
+                                            *    "My Core",                      // library_name
+                                            *    "v1.0",                         // library_version
+                                            *    "m3u|md|cue|iso|chd|sms|gg|sg", // valid_extensions
+                                            *    true,                           // need_fullpath
+                                            *    false                           // block_extract
+                                            * }
+                                            *
+                                            * - Array of struct retro_system_content_info_override:
+                                            * {
+                                            *    {
+                                            *       "md|sms|gg", // extensions
+                                            *       false,       // need_fullpath
+                                            *       true         // persistent_data
+                                            *    },
+                                            *    {
+                                            *       "sg",        // extensions
+                                            *       false,       // need_fullpath
+                                            *       false        // persistent_data
+                                            *    },
+                                            *    { NULL, false, false }
+                                            * }
+                                            *
+                                            * Result:
+                                            * - Files of type m3u, cue, iso, chd will not be
+                                            *   loaded by the frontend. Frontend will pass a
+                                            *   valid path to the core, and core will handle
+                                            *   loading internally
+                                            * - Files of type md, sms, gg will be loaded by
+                                            *   the frontend. A valid memory buffer will be
+                                            *   passed to the core. This memory buffer will
+                                            *   remain valid until retro_deinit() returns
+                                            * - Files of type sg will be loaded by the frontend.
+                                            *   A valid memory buffer will be passed to the core.
+                                            *   This memory buffer will remain valid until
+                                            *   retro_load_game() (or retro_load_game_special())
+                                            *   returns
+                                            *
+                                            * NOTE: If an extension is listed multiple times in
+                                            * an array of retro_system_content_info_override
+                                            * structs, only the first instance will be registered
+                                            */
+
+#define RETRO_ENVIRONMENT_GET_GAME_INFO_EXT 66
+                                           /* const struct retro_game_info_ext ** --
+                                            * Allows an implementation to fetch extended game
+                                            * information, providing additional content path
+                                            * and memory buffer status details.
+                                            * This function may only be called inside
+                                            * retro_load_game() or retro_load_game_special().
+                                            * If callback returns false, extended game information
+                                            * is unsupported by the frontend. In this case, only
+                                            * regular retro_game_info will be available.
+                                            * RETRO_ENVIRONMENT_GET_GAME_INFO_EXT is guaranteed
+                                            * to return true if RETRO_ENVIRONMENT_SET_CONTENT_INFO_OVERRIDE
+                                            * returns true.
+                                            *
+                                            * 'data' points to an array of retro_game_info_ext structs.
+                                            *
+                                            * For struct member descriptions, see the definition of
+                                            * struct retro_game_info_ext.
+                                            *
+                                            * - If function is called inside retro_load_game(),
+                                            *   the retro_game_info_ext array is guaranteed to
+                                            *   have a size of 1 - i.e. the returned pointer may
+                                            *   be used to access directly the members of the
+                                            *   first retro_game_info_ext struct, for example:
+                                            *
+                                            *      struct retro_game_info_ext *game_info_ext;
+                                            *      if (environ_cb(RETRO_ENVIRONMENT_GET_GAME_INFO_EXT, &game_info_ext))
+                                            *         printf("Content Directory: %s\n", game_info_ext->dir);
+                                            *
+                                            * - If the function is called inside retro_load_game_special(),
+                                            *   the retro_game_info_ext array is guaranteed to have a
+                                            *   size equal to the num_info argument passed to
+                                            *   retro_load_game_special()
+                                            */
+
+#define RETRO_ENVIRONMENT_SET_CORE_OPTIONS_V2 67
+                                           /* const struct retro_core_options_v2 * --
+                                            * Allows an implementation to signal the environment
+                                            * which variables it might want to check for later using
+                                            * GET_VARIABLE.
+                                            * This allows the frontend to present these variables to
+                                            * a user dynamically.
+                                            * This should only be called if RETRO_ENVIRONMENT_GET_CORE_OPTIONS_VERSION
+                                            * returns an API version of >= 2.
+                                            * This should be called instead of RETRO_ENVIRONMENT_SET_VARIABLES.
+                                            * This should be called instead of RETRO_ENVIRONMENT_SET_CORE_OPTIONS.
+                                            * This should be called the first time as early as
+                                            * possible (ideally in retro_set_environment).
+                                            * Afterwards it may be called again for the core to communicate
+                                            * updated options to the frontend, but the number of core
+                                            * options must not change from the number in the initial call.
+                                            * If RETRO_ENVIRONMENT_GET_CORE_OPTIONS_VERSION returns an API
+                                            * version of >= 2, this callback is guaranteed to succeed
+                                            * (i.e. callback return value does not indicate success)
+                                            * If callback returns true, frontend has core option category
+                                            * support.
+                                            * If callback returns false, frontend does not have core option
+                                            * category support.
+                                            *
+                                            * 'data' points to a retro_core_options_v2 struct, containing
+                                            * of two pointers:
+                                            * - retro_core_options_v2::categories is an array of
+                                            *   retro_core_option_v2_category structs terminated by a
+                                            *   { NULL, NULL, NULL } element. If retro_core_options_v2::categories
+                                            *   is NULL, all core options will have no category and will be shown
+                                            *   at the top level of the frontend core option interface. If frontend
+                                            *   does not have core option category support, categories array will
+                                            *   be ignored.
+                                            * - retro_core_options_v2::definitions is an array of
+                                            *   retro_core_option_v2_definition structs terminated by a
+                                            *   { NULL, NULL, NULL, NULL, NULL, NULL, {{0}}, NULL }
+                                            *   element.
+                                            *
+                                            * >> retro_core_option_v2_category notes:
+                                            *
+                                            * - retro_core_option_v2_category::key should contain string
+                                            *   that uniquely identifies the core option category. Valid
+                                            *   key characters are [a-z, A-Z, 0-9, _, -]
+                                            *   Namespace collisions with other implementations' category
+                                            *   keys are permitted.
+                                            * - retro_core_option_v2_category::desc should contain a human
+                                            *   readable description of the category key.
+                                            * - retro_core_option_v2_category::info should contain any
+                                            *   additional human readable information text that a typical
+                                            *   user may need to understand the nature of the core option
+                                            *   category.
+                                            *
+                                            * Example entry:
+                                            * {
+                                            *     "advanced_settings",
+                                            *     "Advanced",
+                                            *     "Options affecting low-level emulation performance and accuracy."
+                                            * }
+                                            *
+                                            * >> retro_core_option_v2_definition notes:
+                                            *
+                                            * - retro_core_option_v2_definition::key should be namespaced to not
+                                            *   collide with other implementations' keys. e.g. A core called
+                                            *   'foo' should use keys named as 'foo_option'. Valid key characters
+                                            *   are [a-z, A-Z, 0-9, _, -].
+                                            * - retro_core_option_v2_definition::desc should contain a human readable
+                                            *   description of the key. Will be used when the frontend does not
+                                            *   have core option category support. Examples: "Aspect Ratio" or
+                                            *   "Video > Aspect Ratio".
+                                            * - retro_core_option_v2_definition::desc_categorized should contain a
+                                            *   human readable description of the key, which will be used when
+                                            *   frontend has core option category support. Example: "Aspect Ratio",
+                                            *   where associated retro_core_option_v2_category::desc is "Video".
+                                            *   If empty or NULL, the string specified by
+                                            *   retro_core_option_v2_definition::desc will be used instead.
+                                            *   retro_core_option_v2_definition::desc_categorized will be ignored
+                                            *   if retro_core_option_v2_definition::category_key is empty or NULL.
+                                            * - retro_core_option_v2_definition::info should contain any additional
+                                            *   human readable information text that a typical user may need to
+                                            *   understand the functionality of the option.
+                                            * - retro_core_option_v2_definition::info_categorized should contain
+                                            *   any additional human readable information text that a typical user
+                                            *   may need to understand the functionality of the option, and will be
+                                            *   used when frontend has core option category support. This is provided
+                                            *   to accommodate the case where info text references an option by
+                                            *   name/desc, and the desc/desc_categorized text for that option differ.
+                                            *   If empty or NULL, the string specified by
+                                            *   retro_core_option_v2_definition::info will be used instead.
+                                            *   retro_core_option_v2_definition::info_categorized will be ignored
+                                            *   if retro_core_option_v2_definition::category_key is empty or NULL.
+                                            * - retro_core_option_v2_definition::category_key should contain a
+                                            *   category identifier (e.g. "video" or "audio") that will be
+                                            *   assigned to the core option if frontend has core option category
+                                            *   support. A categorized option will be shown in a subsection/
+                                            *   submenu of the frontend core option interface. If key is empty
+                                            *   or NULL, or if key does not match one of the
+                                            *   retro_core_option_v2_category::key values in the associated
+                                            *   retro_core_option_v2_category array, option will have no category
+                                            *   and will be shown at the top level of the frontend core option
+                                            *   interface.
+                                            * - retro_core_option_v2_definition::values is an array of
+                                            *   retro_core_option_value structs terminated by a { NULL, NULL }
+                                            *   element.
+                                            * --> retro_core_option_v2_definition::values[index].value is an
+                                            *     expected option value.
+                                            * --> retro_core_option_v2_definition::values[index].label is a
+                                            *     human readable label used when displaying the value on screen.
+                                            *     If NULL, the value itself is used.
+                                            * - retro_core_option_v2_definition::default_value is the default
+                                            *   core option setting. It must match one of the expected option
+                                            *   values in the retro_core_option_v2_definition::values array. If
+                                            *   it does not, or the default value is NULL, the first entry in the
+                                            *   retro_core_option_v2_definition::values array is treated as the
+                                            *   default.
+                                            *
+                                            * The number of possible option values should be very limited,
+                                            * and must be less than RETRO_NUM_CORE_OPTION_VALUES_MAX.
+                                            * i.e. it should be feasible to cycle through options
+                                            * without a keyboard.
+                                            *
+                                            * Example entries:
+                                            *
+                                            * - Uncategorized:
+                                            *
+                                            * {
+                                            *     "foo_option",
+                                            *     "Speed hack coprocessor X",
+                                            *     NULL,
+                                            *     "Provides increased performance at the expense of reduced accuracy.",
+                                            *     NULL,
+                                            *     NULL,
+                                            * 	  {
+                                            *         { "false",    NULL },
+                                            *         { "true",     NULL },
+                                            *         { "unstable", "Turbo (Unstable)" },
+                                            *         { NULL, NULL },
+                                            *     },
+                                            *     "false"
+                                            * }
+                                            *
+                                            * - Categorized:
+                                            *
+                                            * {
+                                            *     "foo_option",
+                                            *     "Advanced > Speed hack coprocessor X",
+                                            *     "Speed hack coprocessor X",
+                                            *     "Setting 'Advanced > Speed hack coprocessor X' to 'true' or 'Turbo' provides increased performance at the expense of reduced accuracy",
+                                            *     "Setting 'Speed hack coprocessor X' to 'true' or 'Turbo' provides increased performance at the expense of reduced accuracy",
+                                            *     "advanced_settings",
+                                            * 	  {
+                                            *         { "false",    NULL },
+                                            *         { "true",     NULL },
+                                            *         { "unstable", "Turbo (Unstable)" },
+                                            *         { NULL, NULL },
+                                            *     },
+                                            *     "false"
+                                            * }
+                                            *
+                                            * Only strings are operated on. The possible values will
+                                            * generally be displayed and stored as-is by the frontend.
+                                            */
+
+#define RETRO_ENVIRONMENT_SET_CORE_OPTIONS_V2_INTL 68
+                                           /* const struct retro_core_options_v2_intl * --
+                                            * Allows an implementation to signal the environment
+                                            * which variables it might want to check for later using
+                                            * GET_VARIABLE.
+                                            * This allows the frontend to present these variables to
+                                            * a user dynamically.
+                                            * This should only be called if RETRO_ENVIRONMENT_GET_CORE_OPTIONS_VERSION
+                                            * returns an API version of >= 2.
+                                            * This should be called instead of RETRO_ENVIRONMENT_SET_VARIABLES.
+                                            * This should be called instead of RETRO_ENVIRONMENT_SET_CORE_OPTIONS.
+                                            * This should be called instead of RETRO_ENVIRONMENT_SET_CORE_OPTIONS_INTL.
+                                            * This should be called instead of RETRO_ENVIRONMENT_SET_CORE_OPTIONS_V2.
+                                            * This should be called the first time as early as
+                                            * possible (ideally in retro_set_environment).
+                                            * Afterwards it may be called again for the core to communicate
+                                            * updated options to the frontend, but the number of core
+                                            * options must not change from the number in the initial call.
+                                            * If RETRO_ENVIRONMENT_GET_CORE_OPTIONS_VERSION returns an API
+                                            * version of >= 2, this callback is guaranteed to succeed
+                                            * (i.e. callback return value does not indicate success)
+                                            * If callback returns true, frontend has core option category
+                                            * support.
+                                            * If callback returns false, frontend does not have core option
+                                            * category support.
+                                            *
+                                            * This is fundamentally the same as RETRO_ENVIRONMENT_SET_CORE_OPTIONS_V2,
+                                            * with the addition of localisation support. The description of the
+                                            * RETRO_ENVIRONMENT_SET_CORE_OPTIONS_V2 callback should be consulted
+                                            * for further details.
+                                            *
+                                            * 'data' points to a retro_core_options_v2_intl struct.
+                                            *
+                                            * - retro_core_options_v2_intl::us is a pointer to a
+                                            *   retro_core_options_v2 struct defining the US English
+                                            *   core options implementation. It must point to a valid struct.
+                                            *
+                                            * - retro_core_options_v2_intl::local is a pointer to a
+                                            *   retro_core_options_v2 struct defining core options for
+                                            *   the current frontend language. It may be NULL (in which case
+                                            *   retro_core_options_v2_intl::us is used by the frontend). Any items
+                                            *   missing from this struct will be read from
+                                            *   retro_core_options_v2_intl::us instead.
+                                            *
+                                            * NOTE: Default core option values are always taken from the
+                                            * retro_core_options_v2_intl::us struct. Any default values in
+                                            * the retro_core_options_v2_intl::local struct will be ignored.
+                                            */
+
+/* VFS functionality */
+
+/* File paths:
+ * File paths passed as parameters when using this API shall be well formed UNIX-style,
+ * using "/" (unquoted forward slash) as directory separator regardless of the platform's native separator.
+ * Paths shall also include at least one forward slash ("game.bin" is an invalid path, use "./game.bin" instead).
+ * Other than the directory separator, cores shall not make assumptions about path format:
+ * "C:/path/game.bin", "http://example.com/game.bin", "#game/game.bin", "./game.bin" (without quotes) are all valid paths.
+ * Cores may replace the basename or remove path components from the end, and/or add new components;
+ * however, cores shall not append "./", "../" or multiple consecutive forward slashes ("//") to paths they request to front end.
+ * The frontend is encouraged to make such paths work as well as it can, but is allowed to give up if the core alters paths too much.
+ * Frontends are encouraged, but not required, to support native file system paths (modulo replacing the directory separator, if applicable).
+ * Cores are allowed to try using them, but must remain functional if the front rejects such requests.
+ * Cores are encouraged to use the libretro-common filestream functions for file I/O,
+ * as they seamlessly integrate with VFS, deal with directory separator replacement as appropriate
+ * and provide platform-specific fallbacks in cases where front ends do not support VFS. */
+
+/* Opaque file handle
+ * Introduced in VFS API v1 */
+struct retro_vfs_file_handle;
+
+/* Opaque directory handle
+ * Introduced in VFS API v3 */
+struct retro_vfs_dir_handle;
+
+/* File open flags
+ * Introduced in VFS API v1 */
+#define RETRO_VFS_FILE_ACCESS_READ            (1 << 0) /* Read only mode */
+#define RETRO_VFS_FILE_ACCESS_WRITE           (1 << 1) /* Write only mode, discard contents and overwrites existing file unless RETRO_VFS_FILE_ACCESS_UPDATE is also specified */
+#define RETRO_VFS_FILE_ACCESS_READ_WRITE      (RETRO_VFS_FILE_ACCESS_READ | RETRO_VFS_FILE_ACCESS_WRITE) /* Read-write mode, discard contents and overwrites existing file unless RETRO_VFS_FILE_ACCESS_UPDATE is also specified*/
+#define RETRO_VFS_FILE_ACCESS_UPDATE_EXISTING (1 << 2) /* Prevents discarding content of existing files opened for writing */
+
+/* These are only hints. The frontend may choose to ignore them. Other than RAM/CPU/etc use,
+   and how they react to unlikely external interference (for example someone else writing to that file,
+   or the file's server going down), behavior will not change. */
+#define RETRO_VFS_FILE_ACCESS_HINT_NONE              (0)
+/* Indicate that the file will be accessed many times. The frontend should aggressively cache everything. */
+#define RETRO_VFS_FILE_ACCESS_HINT_FREQUENT_ACCESS   (1 << 0)
+
+/* Seek positions */
+#define RETRO_VFS_SEEK_POSITION_START    0
+#define RETRO_VFS_SEEK_POSITION_CURRENT  1
+#define RETRO_VFS_SEEK_POSITION_END      2
+
+/* stat() result flags
+ * Introduced in VFS API v3 */
+#define RETRO_VFS_STAT_IS_VALID               (1 << 0)
+#define RETRO_VFS_STAT_IS_DIRECTORY           (1 << 1)
+#define RETRO_VFS_STAT_IS_CHARACTER_SPECIAL   (1 << 2)
+
+/* Get path from opaque handle. Returns the exact same path passed to file_open when getting the handle
+ * Introduced in VFS API v1 */
+typedef const char *(RETRO_CALLCONV *retro_vfs_get_path_t)(struct retro_vfs_file_handle *stream);
+
+/* Open a file for reading or writing. If path points to a directory, this will
+ * fail. Returns the opaque file handle, or NULL for error.
+ * Introduced in VFS API v1 */
+typedef struct retro_vfs_file_handle *(RETRO_CALLCONV *retro_vfs_open_t)(const char *path, unsigned mode, unsigned hints);
+
+/* Close the file and release its resources. Must be called if open_file returns non-NULL. Returns 0 on success, -1 on failure.
+ * Whether the call succeeds ot not, the handle passed as parameter becomes invalid and should no longer be used.
+ * Introduced in VFS API v1 */
+typedef int (RETRO_CALLCONV *retro_vfs_close_t)(struct retro_vfs_file_handle *stream);
+
+/* Return the size of the file in bytes, or -1 for error.
+ * Introduced in VFS API v1 */
+typedef int64_t (RETRO_CALLCONV *retro_vfs_size_t)(struct retro_vfs_file_handle *stream);
+
+/* Truncate file to specified size. Returns 0 on success or -1 on error
+ * Introduced in VFS API v2 */
+typedef int64_t (RETRO_CALLCONV *retro_vfs_truncate_t)(struct retro_vfs_file_handle *stream, int64_t length);
+
+/* Get the current read / write position for the file. Returns -1 for error.
+ * Introduced in VFS API v1 */
+typedef int64_t (RETRO_CALLCONV *retro_vfs_tell_t)(struct retro_vfs_file_handle *stream);
+
+/* Set the current read/write position for the file. Returns the new position, -1 for error.
+ * Introduced in VFS API v1 */
+typedef int64_t (RETRO_CALLCONV *retro_vfs_seek_t)(struct retro_vfs_file_handle *stream, int64_t offset, int seek_position);
+
+/* Read data from a file. Returns the number of bytes read, or -1 for error.
+ * Introduced in VFS API v1 */
+typedef int64_t (RETRO_CALLCONV *retro_vfs_read_t)(struct retro_vfs_file_handle *stream, void *s, uint64_t len);
+
+/* Write data to a file. Returns the number of bytes written, or -1 for error.
+ * Introduced in VFS API v1 */
+typedef int64_t (RETRO_CALLCONV *retro_vfs_write_t)(struct retro_vfs_file_handle *stream, const void *s, uint64_t len);
+
+/* Flush pending writes to file, if using buffered IO. Returns 0 on sucess, or -1 on failure.
+ * Introduced in VFS API v1 */
+typedef int (RETRO_CALLCONV *retro_vfs_flush_t)(struct retro_vfs_file_handle *stream);
+
+/* Delete the specified file. Returns 0 on success, -1 on failure
+ * Introduced in VFS API v1 */
+typedef int (RETRO_CALLCONV *retro_vfs_remove_t)(const char *path);
+
+/* Rename the specified file. Returns 0 on success, -1 on failure
+ * Introduced in VFS API v1 */
+typedef int (RETRO_CALLCONV *retro_vfs_rename_t)(const char *old_path, const char *new_path);
+
+/* Stat the specified file. Retruns a bitmask of RETRO_VFS_STAT_* flags, none are set if path was not valid.
+ * Additionally stores file size in given variable, unless NULL is given.
+ * Introduced in VFS API v3 */
+typedef int (RETRO_CALLCONV *retro_vfs_stat_t)(const char *path, int32_t *size);
+
+/* Create the specified directory. Returns 0 on success, -1 on unknown failure, -2 if already exists.
+ * Introduced in VFS API v3 */
+typedef int (RETRO_CALLCONV *retro_vfs_mkdir_t)(const char *dir);
+
+/* Open the specified directory for listing. Returns the opaque dir handle, or NULL for error.
+ * Support for the include_hidden argument may vary depending on the platform.
+ * Introduced in VFS API v3 */
+typedef struct retro_vfs_dir_handle *(RETRO_CALLCONV *retro_vfs_opendir_t)(const char *dir, bool include_hidden);
+
+/* Read the directory entry at the current position, and move the read pointer to the next position.
+ * Returns true on success, false if already on the last entry.
+ * Introduced in VFS API v3 */
+typedef bool (RETRO_CALLCONV *retro_vfs_readdir_t)(struct retro_vfs_dir_handle *dirstream);
+
+/* Get the name of the last entry read. Returns a string on success, or NULL for error.
+ * The returned string pointer is valid until the next call to readdir or closedir.
+ * Introduced in VFS API v3 */
+typedef const char *(RETRO_CALLCONV *retro_vfs_dirent_get_name_t)(struct retro_vfs_dir_handle *dirstream);
+
+/* Check if the last entry read was a directory. Returns true if it was, false otherwise (or on error).
+ * Introduced in VFS API v3 */
+typedef bool (RETRO_CALLCONV *retro_vfs_dirent_is_dir_t)(struct retro_vfs_dir_handle *dirstream);
+
+/* Close the directory and release its resources. Must be called if opendir returns non-NULL. Returns 0 on success, -1 on failure.
+ * Whether the call succeeds ot not, the handle passed as parameter becomes invalid and should no longer be used.
+ * Introduced in VFS API v3 */
+typedef int (RETRO_CALLCONV *retro_vfs_closedir_t)(struct retro_vfs_dir_handle *dirstream);
+
+struct retro_vfs_interface
+{
+   /* VFS API v1 */
+	retro_vfs_get_path_t get_path;
+	retro_vfs_open_t open;
+	retro_vfs_close_t close;
+	retro_vfs_size_t size;
+	retro_vfs_tell_t tell;
+	retro_vfs_seek_t seek;
+	retro_vfs_read_t read;
+	retro_vfs_write_t write;
+	retro_vfs_flush_t flush;
+	retro_vfs_remove_t remove;
+	retro_vfs_rename_t rename;
+   /* VFS API v2 */
+   retro_vfs_truncate_t truncate;
+   /* VFS API v3 */
+   retro_vfs_stat_t stat;
+   retro_vfs_mkdir_t mkdir;
+   retro_vfs_opendir_t opendir;
+   retro_vfs_readdir_t readdir;
+   retro_vfs_dirent_get_name_t dirent_get_name;
+   retro_vfs_dirent_is_dir_t dirent_is_dir;
+   retro_vfs_closedir_t closedir;
+};
+
+struct retro_vfs_interface_info
+{
+   /* Set by core: should this be higher than the version the front end supports,
+    * front end will return false in the RETRO_ENVIRONMENT_GET_VFS_INTERFACE call
+    * Introduced in VFS API v1 */
+   uint32_t required_interface_version;
+
+   /* Frontend writes interface pointer here. The frontend also sets the actual
+    * version, must be at least required_interface_version.
+    * Introduced in VFS API v1 */
+   struct retro_vfs_interface *iface;
+};
+
+enum retro_hw_render_interface_type
+{
+	RETRO_HW_RENDER_INTERFACE_VULKAN = 0,
+	RETRO_HW_RENDER_INTERFACE_D3D9   = 1,
+	RETRO_HW_RENDER_INTERFACE_D3D10  = 2,
+	RETRO_HW_RENDER_INTERFACE_D3D11  = 3,
+	RETRO_HW_RENDER_INTERFACE_D3D12  = 4,
+   RETRO_HW_RENDER_INTERFACE_GSKIT_PS2  = 5,
+   RETRO_HW_RENDER_INTERFACE_DUMMY  = INT_MAX
+};
+
+/* Base struct. All retro_hw_render_interface_* types
+ * contain at least these fields. */
+struct retro_hw_render_interface
+{
+   enum retro_hw_render_interface_type interface_type;
+   unsigned interface_version;
+};
+
+typedef void (RETRO_CALLCONV *retro_set_led_state_t)(int led, int state);
+struct retro_led_interface
+{
+    retro_set_led_state_t set_led_state;
+};
+
+/* Retrieves the current state of the MIDI input.
+ * Returns true if it's enabled, false otherwise. */
+typedef bool (RETRO_CALLCONV *retro_midi_input_enabled_t)(void);
+
+/* Retrieves the current state of the MIDI output.
+ * Returns true if it's enabled, false otherwise */
+typedef bool (RETRO_CALLCONV *retro_midi_output_enabled_t)(void);
+
+/* Reads next byte from the input stream.
+ * Returns true if byte is read, false otherwise. */
+typedef bool (RETRO_CALLCONV *retro_midi_read_t)(uint8_t *byte);
+
+/* Writes byte to the output stream.
+ * 'delta_time' is in microseconds and represent time elapsed since previous write.
+ * Returns true if byte is written, false otherwise. */
+typedef bool (RETRO_CALLCONV *retro_midi_write_t)(uint8_t byte, uint32_t delta_time);
+
+/* Flushes previously written data.
+ * Returns true if successful, false otherwise. */
+typedef bool (RETRO_CALLCONV *retro_midi_flush_t)(void);
+
+struct retro_midi_interface
+{
+   retro_midi_input_enabled_t input_enabled;
+   retro_midi_output_enabled_t output_enabled;
+   retro_midi_read_t read;
+   retro_midi_write_t write;
+   retro_midi_flush_t flush;
+};
+
+enum retro_hw_render_context_negotiation_interface_type
+{
+   RETRO_HW_RENDER_CONTEXT_NEGOTIATION_INTERFACE_VULKAN = 0,
+   RETRO_HW_RENDER_CONTEXT_NEGOTIATION_INTERFACE_DUMMY = INT_MAX
+};
+
+/* Base struct. All retro_hw_render_context_negotiation_interface_* types
+ * contain at least these fields. */
+struct retro_hw_render_context_negotiation_interface
+{
+   enum retro_hw_render_context_negotiation_interface_type interface_type;
+   unsigned interface_version;
+};
+
+/* Serialized state is incomplete in some way. Set if serialization is
+ * usable in typical end-user cases but should not be relied upon to
+ * implement frame-sensitive frontend features such as netplay or
+ * rerecording. */
+#define RETRO_SERIALIZATION_QUIRK_INCOMPLETE (1 << 0)
+/* The core must spend some time initializing before serialization is
+ * supported. retro_serialize() will initially fail; retro_unserialize()
+ * and retro_serialize_size() may or may not work correctly either. */
+#define RETRO_SERIALIZATION_QUIRK_MUST_INITIALIZE (1 << 1)
+/* Serialization size may change within a session. */
+#define RETRO_SERIALIZATION_QUIRK_CORE_VARIABLE_SIZE (1 << 2)
+/* Set by the frontend to acknowledge that it supports variable-sized
+ * states. */
+#define RETRO_SERIALIZATION_QUIRK_FRONT_VARIABLE_SIZE (1 << 3)
+/* Serialized state can only be loaded during the same session. */
+#define RETRO_SERIALIZATION_QUIRK_SINGLE_SESSION (1 << 4)
+/* Serialized state cannot be loaded on an architecture with a different
+ * endianness from the one it was saved on. */
+#define RETRO_SERIALIZATION_QUIRK_ENDIAN_DEPENDENT (1 << 5)
+/* Serialized state cannot be loaded on a different platform from the one it
+ * was saved on for reasons other than endianness, such as word size
+ * dependence */
+#define RETRO_SERIALIZATION_QUIRK_PLATFORM_DEPENDENT (1 << 6)
+
+#define RETRO_MEMDESC_CONST      (1 << 0)   /* The frontend will never change this memory area once retro_load_game has returned. */
+#define RETRO_MEMDESC_BIGENDIAN  (1 << 1)   /* The memory area contains big endian data. Default is little endian. */
+#define RETRO_MEMDESC_SYSTEM_RAM (1 << 2)   /* The memory area is system RAM.  This is main RAM of the gaming system. */
+#define RETRO_MEMDESC_SAVE_RAM   (1 << 3)   /* The memory area is save RAM. This RAM is usually found on a game cartridge, backed up by a battery. */
+#define RETRO_MEMDESC_VIDEO_RAM  (1 << 4)   /* The memory area is video RAM (VRAM) */
+#define RETRO_MEMDESC_ALIGN_2    (1 << 16)  /* All memory access in this area is aligned to their own size, or 2, whichever is smaller. */
+#define RETRO_MEMDESC_ALIGN_4    (2 << 16)
+#define RETRO_MEMDESC_ALIGN_8    (3 << 16)
+#define RETRO_MEMDESC_MINSIZE_2  (1 << 24)  /* All memory in this region is accessed at least 2 bytes at the time. */
+#define RETRO_MEMDESC_MINSIZE_4  (2 << 24)
+#define RETRO_MEMDESC_MINSIZE_8  (3 << 24)
+struct retro_memory_descriptor
+{
+   uint64_t flags;
+
+   /* Pointer to the start of the relevant ROM or RAM chip.
+    * It's strongly recommended to use 'offset' if possible, rather than
+    * doing math on the pointer.
+    *
+    * If the same byte is mapped my multiple descriptors, their descriptors
+    * must have the same pointer.
+    * If 'start' does not point to the first byte in the pointer, put the
+    * difference in 'offset' instead.
+    *
+    * May be NULL if there's nothing usable here (e.g. hardware registers and
+    * open bus). No flags should be set if the pointer is NULL.
+    * It's recommended to minimize the number of descriptors if possible,
+    * but not mandatory. */
+   void *ptr;
+   size_t offset;
+
+   /* This is the location in the emulated address space
+    * where the mapping starts. */
+   size_t start;
+
+   /* Which bits must be same as in 'start' for this mapping to apply.
+    * The first memory descriptor to claim a certain byte is the one
+    * that applies.
+    * A bit which is set in 'start' must also be set in this.
+    * Can be zero, in which case each byte is assumed mapped exactly once.
+    * In this case, 'len' must be a power of two. */
+   size_t select;
+
+   /* If this is nonzero, the set bits are assumed not connected to the
+    * memory chip's address pins. */
+   size_t disconnect;
+
+   /* This one tells the size of the current memory area.
+    * If, after start+disconnect are applied, the address is higher than
+    * this, the highest bit of the address is cleared.
+    *
+    * If the address is still too high, the next highest bit is cleared.
+    * Can be zero, in which case it's assumed to be infinite (as limited
+    * by 'select' and 'disconnect'). */
+   size_t len;
+
+   /* To go from emulated address to physical address, the following
+    * order applies:
+    * Subtract 'start', pick off 'disconnect', apply 'len', add 'offset'. */
+
+   /* The address space name must consist of only a-zA-Z0-9_-,
+    * should be as short as feasible (maximum length is 8 plus the NUL),
+    * and may not be any other address space plus one or more 0-9A-F
+    * at the end.
+    * However, multiple memory descriptors for the same address space is
+    * allowed, and the address space name can be empty. NULL is treated
+    * as empty.
+    *
+    * Address space names are case sensitive, but avoid lowercase if possible.
+    * The same pointer may exist in multiple address spaces.
+    *
+    * Examples:
+    * blank+blank - valid (multiple things may be mapped in the same namespace)
+    * 'Sp'+'Sp' - valid (multiple things may be mapped in the same namespace)
+    * 'A'+'B' - valid (neither is a prefix of each other)
+    * 'S'+blank - valid ('S' is not in 0-9A-F)
+    * 'a'+blank - valid ('a' is not in 0-9A-F)
+    * 'a'+'A' - valid (neither is a prefix of each other)
+    * 'AR'+blank - valid ('R' is not in 0-9A-F)
+    * 'ARB'+blank - valid (the B can't be part of the address either, because
+    *                      there is no namespace 'AR')
+    * blank+'B' - not valid, because it's ambigous which address space B1234
+    *             would refer to.
+    * The length can't be used for that purpose; the frontend may want
+    * to append arbitrary data to an address, without a separator. */
+   const char *addrspace;
+
+   /* TODO: When finalizing this one, add a description field, which should be
+    * "WRAM" or something roughly equally long. */
+
+   /* TODO: When finalizing this one, replace 'select' with 'limit', which tells
+    * which bits can vary and still refer to the same address (limit = ~select).
+    * TODO: limit? range? vary? something else? */
+
+   /* TODO: When finalizing this one, if 'len' is above what 'select' (or
+    * 'limit') allows, it's bankswitched. Bankswitched data must have both 'len'
+    * and 'select' != 0, and the mappings don't tell how the system switches the
+    * banks. */
+
+   /* TODO: When finalizing this one, fix the 'len' bit removal order.
+    * For len=0x1800, pointer 0x1C00 should go to 0x1400, not 0x0C00.
+    * Algorithm: Take bits highest to lowest, but if it goes above len, clear
+    * the most recent addition and continue on the next bit.
+    * TODO: Can the above be optimized? Is "remove the lowest bit set in both
+    * pointer and 'len'" equivalent? */
+
+   /* TODO: Some emulators (MAME?) emulate big endian systems by only accessing
+    * the emulated memory in 32-bit chunks, native endian. But that's nothing
+    * compared to Darek Mihocka <http://www.emulators.com/docs/nx07_vm101.htm>
+    * (section Emulation 103 - Nearly Free Byte Reversal) - he flips the ENTIRE
+    * RAM backwards! I'll want to represent both of those, via some flags.
+    *
+    * I suspect MAME either didn't think of that idea, or don't want the #ifdef.
+    * Not sure which, nor do I really care. */
+
+   /* TODO: Some of those flags are unused and/or don't really make sense. Clean
+    * them up. */
+};
+
+/* The frontend may use the largest value of 'start'+'select' in a
+ * certain namespace to infer the size of the address space.
+ *
+ * If the address space is larger than that, a mapping with .ptr=NULL
+ * should be at the end of the array, with .select set to all ones for
+ * as long as the address space is big.
+ *
+ * Sample descriptors (minus .ptr, and RETRO_MEMFLAG_ on the flags):
+ * SNES WRAM:
+ * .start=0x7E0000, .len=0x20000
+ * (Note that this must be mapped before the ROM in most cases; some of the
+ * ROM mappers
+ * try to claim $7E0000, or at least $7E8000.)
+ * SNES SPC700 RAM:
+ * .addrspace="S", .len=0x10000
+ * SNES WRAM mirrors:
+ * .flags=MIRROR, .start=0x000000, .select=0xC0E000, .len=0x2000
+ * .flags=MIRROR, .start=0x800000, .select=0xC0E000, .len=0x2000
+ * SNES WRAM mirrors, alternate equivalent descriptor:
+ * .flags=MIRROR, .select=0x40E000, .disconnect=~0x1FFF
+ * (Various similar constructions can be created by combining parts of
+ * the above two.)
+ * SNES LoROM (512KB, mirrored a couple of times):
+ * .flags=CONST, .start=0x008000, .select=0x408000, .disconnect=0x8000, .len=512*1024
+ * .flags=CONST, .start=0x400000, .select=0x400000, .disconnect=0x8000, .len=512*1024
+ * SNES HiROM (4MB):
+ * .flags=CONST,                 .start=0x400000, .select=0x400000, .len=4*1024*1024
+ * .flags=CONST, .offset=0x8000, .start=0x008000, .select=0x408000, .len=4*1024*1024
+ * SNES ExHiROM (8MB):
+ * .flags=CONST, .offset=0,                  .start=0xC00000, .select=0xC00000, .len=4*1024*1024
+ * .flags=CONST, .offset=4*1024*1024,        .start=0x400000, .select=0xC00000, .len=4*1024*1024
+ * .flags=CONST, .offset=0x8000,             .start=0x808000, .select=0xC08000, .len=4*1024*1024
+ * .flags=CONST, .offset=4*1024*1024+0x8000, .start=0x008000, .select=0xC08000, .len=4*1024*1024
+ * Clarify the size of the address space:
+ * .ptr=NULL, .select=0xFFFFFF
+ * .len can be implied by .select in many of them, but was included for clarity.
+ */
+
+struct retro_memory_map
+{
+   const struct retro_memory_descriptor *descriptors;
+   unsigned num_descriptors;
+};
+
+struct retro_controller_description
+{
+   /* Human-readable description of the controller. Even if using a generic
+    * input device type, this can be set to the particular device type the
+    * core uses. */
+   const char *desc;
+
+   /* Device type passed to retro_set_controller_port_device(). If the device
+    * type is a sub-class of a generic input device type, use the
+    * RETRO_DEVICE_SUBCLASS macro to create an ID.
+    *
+    * E.g. RETRO_DEVICE_SUBCLASS(RETRO_DEVICE_JOYPAD, 1). */
+   unsigned id;
+};
+
+struct retro_controller_info
+{
+   const struct retro_controller_description *types;
+   unsigned num_types;
+};
+
+struct retro_subsystem_memory_info
+{
+   /* The extension associated with a memory type, e.g. "psram". */
+   const char *extension;
+
+   /* The memory type for retro_get_memory(). This should be at
+    * least 0x100 to avoid conflict with standardized
+    * libretro memory types. */
+   unsigned type;
+};
+
+struct retro_subsystem_rom_info
+{
+   /* Describes what the content is (SGB BIOS, GB ROM, etc). */
+   const char *desc;
+
+   /* Same definition as retro_get_system_info(). */
+   const char *valid_extensions;
+
+   /* Same definition as retro_get_system_info(). */
+   bool need_fullpath;
+
+   /* Same definition as retro_get_system_info(). */
+   bool block_extract;
+
+   /* This is set if the content is required to load a game.
+    * If this is set to false, a zeroed-out retro_game_info can be passed. */
+   bool required;
+
+   /* Content can have multiple associated persistent
+    * memory types (retro_get_memory()). */
+   const struct retro_subsystem_memory_info *memory;
+   unsigned num_memory;
+};
+
+struct retro_subsystem_info
+{
+   /* Human-readable string of the subsystem type, e.g. "Super GameBoy" */
+   const char *desc;
+
+   /* A computer friendly short string identifier for the subsystem type.
+    * This name must be [a-z].
+    * E.g. if desc is "Super GameBoy", this can be "sgb".
+    * This identifier can be used for command-line interfaces, etc.
+    */
+   const char *ident;
+
+   /* Infos for each content file. The first entry is assumed to be the
+    * "most significant" content for frontend purposes.
+    * E.g. with Super GameBoy, the first content should be the GameBoy ROM,
+    * as it is the most "significant" content to a user.
+    * If a frontend creates new file paths based on the content used
+    * (e.g. savestates), it should use the path for the first ROM to do so. */
+   const struct retro_subsystem_rom_info *roms;
+
+   /* Number of content files associated with a subsystem. */
+   unsigned num_roms;
+
+   /* The type passed to retro_load_game_special(). */
+   unsigned id;
+};
+
+typedef void (RETRO_CALLCONV *retro_proc_address_t)(void);
+
+/* libretro API extension functions:
+ * (None here so far).
+ *
+ * Get a symbol from a libretro core.
+ * Cores should only return symbols which are actual
+ * extensions to the libretro API.
+ *
+ * Frontends should not use this to obtain symbols to standard
+ * libretro entry points (static linking or dlsym).
+ *
+ * The symbol name must be equal to the function name,
+ * e.g. if void retro_foo(void); exists, the symbol must be called "retro_foo".
+ * The returned function pointer must be cast to the corresponding type.
+ */
+typedef retro_proc_address_t (RETRO_CALLCONV *retro_get_proc_address_t)(const char *sym);
+
+struct retro_get_proc_address_interface
+{
+   retro_get_proc_address_t get_proc_address;
+};
+
+enum retro_log_level
+{
+   RETRO_LOG_DEBUG = 0,
+   RETRO_LOG_INFO,
+   RETRO_LOG_WARN,
+   RETRO_LOG_ERROR,
+
+   RETRO_LOG_DUMMY = INT_MAX
+};
+
+/* Logging function. Takes log level argument as well. */
+typedef void (RETRO_CALLCONV *retro_log_printf_t)(enum retro_log_level level,
+      const char *fmt, ...);
+
+struct retro_log_callback
+{
+   retro_log_printf_t log;
+};
+
+/* Performance related functions */
+
+/* ID values for SIMD CPU features */
+#define RETRO_SIMD_SSE      (1 << 0)
+#define RETRO_SIMD_SSE2     (1 << 1)
+#define RETRO_SIMD_VMX      (1 << 2)
+#define RETRO_SIMD_VMX128   (1 << 3)
+#define RETRO_SIMD_AVX      (1 << 4)
+#define RETRO_SIMD_NEON     (1 << 5)
+#define RETRO_SIMD_SSE3     (1 << 6)
+#define RETRO_SIMD_SSSE3    (1 << 7)
+#define RETRO_SIMD_MMX      (1 << 8)
+#define RETRO_SIMD_MMXEXT   (1 << 9)
+#define RETRO_SIMD_SSE4     (1 << 10)
+#define RETRO_SIMD_SSE42    (1 << 11)
+#define RETRO_SIMD_AVX2     (1 << 12)
+#define RETRO_SIMD_VFPU     (1 << 13)
+#define RETRO_SIMD_PS       (1 << 14)
+#define RETRO_SIMD_AES      (1 << 15)
+#define RETRO_SIMD_VFPV3    (1 << 16)
+#define RETRO_SIMD_VFPV4    (1 << 17)
+#define RETRO_SIMD_POPCNT   (1 << 18)
+#define RETRO_SIMD_MOVBE    (1 << 19)
+#define RETRO_SIMD_CMOV     (1 << 20)
+#define RETRO_SIMD_ASIMD    (1 << 21)
+
+typedef uint64_t retro_perf_tick_t;
+typedef int64_t retro_time_t;
+
+struct retro_perf_counter
+{
+   const char *ident;
+   retro_perf_tick_t start;
+   retro_perf_tick_t total;
+   retro_perf_tick_t call_cnt;
+
+   bool registered;
+};
+
+/* Returns current time in microseconds.
+ * Tries to use the most accurate timer available.
+ */
+typedef retro_time_t (RETRO_CALLCONV *retro_perf_get_time_usec_t)(void);
+
+/* A simple counter. Usually nanoseconds, but can also be CPU cycles.
+ * Can be used directly if desired (when creating a more sophisticated
+ * performance counter system).
+ * */
+typedef retro_perf_tick_t (RETRO_CALLCONV *retro_perf_get_counter_t)(void);
+
+/* Returns a bit-mask of detected CPU features (RETRO_SIMD_*). */
+typedef uint64_t (RETRO_CALLCONV *retro_get_cpu_features_t)(void);
+
+/* Asks frontend to log and/or display the state of performance counters.
+ * Performance counters can always be poked into manually as well.
+ */
+typedef void (RETRO_CALLCONV *retro_perf_log_t)(void);
+
+/* Register a performance counter.
+ * ident field must be set with a discrete value and other values in
+ * retro_perf_counter must be 0.
+ * Registering can be called multiple times. To avoid calling to
+ * frontend redundantly, you can check registered field first. */
+typedef void (RETRO_CALLCONV *retro_perf_register_t)(struct retro_perf_counter *counter);
+
+/* Starts a registered counter. */
+typedef void (RETRO_CALLCONV *retro_perf_start_t)(struct retro_perf_counter *counter);
+
+/* Stops a registered counter. */
+typedef void (RETRO_CALLCONV *retro_perf_stop_t)(struct retro_perf_counter *counter);
+
+/* For convenience it can be useful to wrap register, start and stop in macros.
+ * E.g.:
+ * #ifdef LOG_PERFORMANCE
+ * #define RETRO_PERFORMANCE_INIT(perf_cb, name) static struct retro_perf_counter name = {#name}; if (!name.registered) perf_cb.perf_register(&(name))
+ * #define RETRO_PERFORMANCE_START(perf_cb, name) perf_cb.perf_start(&(name))
+ * #define RETRO_PERFORMANCE_STOP(perf_cb, name) perf_cb.perf_stop(&(name))
+ * #else
+ * ... Blank macros ...
+ * #endif
+ *
+ * These can then be used mid-functions around code snippets.
+ *
+ * extern struct retro_perf_callback perf_cb;  * Somewhere in the core.
+ *
+ * void do_some_heavy_work(void)
+ * {
+ *    RETRO_PERFORMANCE_INIT(cb, work_1;
+ *    RETRO_PERFORMANCE_START(cb, work_1);
+ *    heavy_work_1();
+ *    RETRO_PERFORMANCE_STOP(cb, work_1);
+ *
+ *    RETRO_PERFORMANCE_INIT(cb, work_2);
+ *    RETRO_PERFORMANCE_START(cb, work_2);
+ *    heavy_work_2();
+ *    RETRO_PERFORMANCE_STOP(cb, work_2);
+ * }
+ *
+ * void retro_deinit(void)
+ * {
+ *    perf_cb.perf_log();  * Log all perf counters here for example.
+ * }
+ */
+
+struct retro_perf_callback
+{
+   retro_perf_get_time_usec_t    get_time_usec;
+   retro_get_cpu_features_t      get_cpu_features;
+
+   retro_perf_get_counter_t      get_perf_counter;
+   retro_perf_register_t         perf_register;
+   retro_perf_start_t            perf_start;
+   retro_perf_stop_t             perf_stop;
+   retro_perf_log_t              perf_log;
+};
+
+/* FIXME: Document the sensor API and work out behavior.
+ * It will be marked as experimental until then.
+ */
+enum retro_sensor_action
+{
+   RETRO_SENSOR_ACCELEROMETER_ENABLE = 0,
+   RETRO_SENSOR_ACCELEROMETER_DISABLE,
+   RETRO_SENSOR_GYROSCOPE_ENABLE,
+   RETRO_SENSOR_GYROSCOPE_DISABLE,
+   RETRO_SENSOR_ILLUMINANCE_ENABLE,
+   RETRO_SENSOR_ILLUMINANCE_DISABLE,
+
+   RETRO_SENSOR_DUMMY = INT_MAX
+};
+
+/* Id values for SENSOR types. */
+#define RETRO_SENSOR_ACCELEROMETER_X 0
+#define RETRO_SENSOR_ACCELEROMETER_Y 1
+#define RETRO_SENSOR_ACCELEROMETER_Z 2
+#define RETRO_SENSOR_GYROSCOPE_X 3
+#define RETRO_SENSOR_GYROSCOPE_Y 4
+#define RETRO_SENSOR_GYROSCOPE_Z 5
+#define RETRO_SENSOR_ILLUMINANCE 6
+
+typedef bool (RETRO_CALLCONV *retro_set_sensor_state_t)(unsigned port,
+      enum retro_sensor_action action, unsigned rate);
+
+typedef float (RETRO_CALLCONV *retro_sensor_get_input_t)(unsigned port, unsigned id);
+
+struct retro_sensor_interface
+{
+   retro_set_sensor_state_t set_sensor_state;
+   retro_sensor_get_input_t get_sensor_input;
+};
+
+enum retro_camera_buffer
+{
+   RETRO_CAMERA_BUFFER_OPENGL_TEXTURE = 0,
+   RETRO_CAMERA_BUFFER_RAW_FRAMEBUFFER,
+
+   RETRO_CAMERA_BUFFER_DUMMY = INT_MAX
+};
+
+/* Starts the camera driver. Can only be called in retro_run(). */
+typedef bool (RETRO_CALLCONV *retro_camera_start_t)(void);
+
+/* Stops the camera driver. Can only be called in retro_run(). */
+typedef void (RETRO_CALLCONV *retro_camera_stop_t)(void);
+
+/* Callback which signals when the camera driver is initialized
+ * and/or deinitialized.
+ * retro_camera_start_t can be called in initialized callback.
+ */
+typedef void (RETRO_CALLCONV *retro_camera_lifetime_status_t)(void);
+
+/* A callback for raw framebuffer data. buffer points to an XRGB8888 buffer.
+ * Width, height and pitch are similar to retro_video_refresh_t.
+ * First pixel is top-left origin.
+ */
+typedef void (RETRO_CALLCONV *retro_camera_frame_raw_framebuffer_t)(const uint32_t *buffer,
+      unsigned width, unsigned height, size_t pitch);
+
+/* A callback for when OpenGL textures are used.
+ *
+ * texture_id is a texture owned by camera driver.
+ * Its state or content should be considered immutable, except for things like
+ * texture filtering and clamping.
+ *
+ * texture_target is the texture target for the GL texture.
+ * These can include e.g. GL_TEXTURE_2D, GL_TEXTURE_RECTANGLE, and possibly
+ * more depending on extensions.
+ *
+ * affine points to a packed 3x3 column-major matrix used to apply an affine
+ * transform to texture coordinates. (affine_matrix * vec3(coord_x, coord_y, 1.0))
+ * After transform, normalized texture coord (0, 0) should be bottom-left
+ * and (1, 1) should be top-right (or (width, height) for RECTANGLE).
+ *
+ * GL-specific typedefs are avoided here to avoid relying on gl.h in
+ * the API definition.
+ */
+typedef void (RETRO_CALLCONV *retro_camera_frame_opengl_texture_t)(unsigned texture_id,
+      unsigned texture_target, const float *affine);
+
+struct retro_camera_callback
+{
+   /* Set by libretro core.
+    * Example bitmask: caps = (1 << RETRO_CAMERA_BUFFER_OPENGL_TEXTURE) | (1 << RETRO_CAMERA_BUFFER_RAW_FRAMEBUFFER).
+    */
+   uint64_t caps;
+
+   /* Desired resolution for camera. Is only used as a hint. */
+   unsigned width;
+   unsigned height;
+
+   /* Set by frontend. */
+   retro_camera_start_t start;
+   retro_camera_stop_t stop;
+
+   /* Set by libretro core if raw framebuffer callbacks will be used. */
+   retro_camera_frame_raw_framebuffer_t frame_raw_framebuffer;
+
+   /* Set by libretro core if OpenGL texture callbacks will be used. */
+   retro_camera_frame_opengl_texture_t frame_opengl_texture;
+
+   /* Set by libretro core. Called after camera driver is initialized and
+    * ready to be started.
+    * Can be NULL, in which this callback is not called.
+    */
+   retro_camera_lifetime_status_t initialized;
+
+   /* Set by libretro core. Called right before camera driver is
+    * deinitialized.
+    * Can be NULL, in which this callback is not called.
+    */
+   retro_camera_lifetime_status_t deinitialized;
+};
+
+/* Sets the interval of time and/or distance at which to update/poll
+ * location-based data.
+ *
+ * To ensure compatibility with all location-based implementations,
+ * values for both interval_ms and interval_distance should be provided.
+ *
+ * interval_ms is the interval expressed in milliseconds.
+ * interval_distance is the distance interval expressed in meters.
+ */
+typedef void (RETRO_CALLCONV *retro_location_set_interval_t)(unsigned interval_ms,
+      unsigned interval_distance);
+
+/* Start location services. The device will start listening for changes to the
+ * current location at regular intervals (which are defined with
+ * retro_location_set_interval_t). */
+typedef bool (RETRO_CALLCONV *retro_location_start_t)(void);
+
+/* Stop location services. The device will stop listening for changes
+ * to the current location. */
+typedef void (RETRO_CALLCONV *retro_location_stop_t)(void);
+
+/* Get the position of the current location. Will set parameters to
+ * 0 if no new  location update has happened since the last time. */
+typedef bool (RETRO_CALLCONV *retro_location_get_position_t)(double *lat, double *lon,
+      double *horiz_accuracy, double *vert_accuracy);
+
+/* Callback which signals when the location driver is initialized
+ * and/or deinitialized.
+ * retro_location_start_t can be called in initialized callback.
+ */
+typedef void (RETRO_CALLCONV *retro_location_lifetime_status_t)(void);
+
+struct retro_location_callback
+{
+   retro_location_start_t         start;
+   retro_location_stop_t          stop;
+   retro_location_get_position_t  get_position;
+   retro_location_set_interval_t  set_interval;
+
+   retro_location_lifetime_status_t initialized;
+   retro_location_lifetime_status_t deinitialized;
+};
+
+enum retro_rumble_effect
+{
+   RETRO_RUMBLE_STRONG = 0,
+   RETRO_RUMBLE_WEAK = 1,
+
+   RETRO_RUMBLE_DUMMY = INT_MAX
+};
+
+/* Sets rumble state for joypad plugged in port 'port'.
+ * Rumble effects are controlled independently,
+ * and setting e.g. strong rumble does not override weak rumble.
+ * Strength has a range of [0, 0xffff].
+ *
+ * Returns true if rumble state request was honored.
+ * Calling this before first retro_run() is likely to return false. */
+typedef bool (RETRO_CALLCONV *retro_set_rumble_state_t)(unsigned port,
+      enum retro_rumble_effect effect, uint16_t strength);
+
+struct retro_rumble_interface
+{
+   retro_set_rumble_state_t set_rumble_state;
+};
+
+/* Notifies libretro that audio data should be written. */
+typedef void (RETRO_CALLCONV *retro_audio_callback_t)(void);
+
+/* True: Audio driver in frontend is active, and callback is
+ * expected to be called regularily.
+ * False: Audio driver in frontend is paused or inactive.
+ * Audio callback will not be called until set_state has been
+ * called with true.
+ * Initial state is false (inactive).
+ */
+typedef void (RETRO_CALLCONV *retro_audio_set_state_callback_t)(bool enabled);
+
+struct retro_audio_callback
+{
+   retro_audio_callback_t callback;
+   retro_audio_set_state_callback_t set_state;
+};
+
+/* Notifies a libretro core of time spent since last invocation
+ * of retro_run() in microseconds.
+ *
+ * It will be called right before retro_run() every frame.
+ * The frontend can tamper with timing to support cases like
+ * fast-forward, slow-motion and framestepping.
+ *
+ * In those scenarios the reference frame time value will be used. */
+typedef int64_t retro_usec_t;
+typedef void (RETRO_CALLCONV *retro_frame_time_callback_t)(retro_usec_t usec);
+struct retro_frame_time_callback
+{
+   retro_frame_time_callback_t callback;
+   /* Represents the time of one frame. It is computed as
+    * 1000000 / fps, but the implementation will resolve the
+    * rounding to ensure that framestepping, etc is exact. */
+   retro_usec_t reference;
+};
+
+/* Notifies a libretro core of the current occupancy
+ * level of the frontend audio buffer.
+ *
+ * - active: 'true' if audio buffer is currently
+ *           in use. Will be 'false' if audio is
+ *           disabled in the frontend
+ *
+ * - occupancy: Given as a value in the range [0,100],
+ *              corresponding to the occupancy percentage
+ *              of the audio buffer
+ *
+ * - underrun_likely: 'true' if the frontend expects an
+ *                    audio buffer underrun during the
+ *                    next frame (indicates that a core
+ *                    should attempt frame skipping)
+ *
+ * It will be called right before retro_run() every frame. */
+typedef void (RETRO_CALLCONV *retro_audio_buffer_status_callback_t)(
+      bool active, unsigned occupancy, bool underrun_likely);
+struct retro_audio_buffer_status_callback
+{
+   retro_audio_buffer_status_callback_t callback;
+};
+
+/* Pass this to retro_video_refresh_t if rendering to hardware.
+ * Passing NULL to retro_video_refresh_t is still a frame dupe as normal.
+ * */
+#define RETRO_HW_FRAME_BUFFER_VALID ((void*)-1)
+
+/* Invalidates the current HW context.
+ * Any GL state is lost, and must not be deinitialized explicitly.
+ * If explicit deinitialization is desired by the libretro core,
+ * it should implement context_destroy callback.
+ * If called, all GPU resources must be reinitialized.
+ * Usually called when frontend reinits video driver.
+ * Also called first time video driver is initialized,
+ * allowing libretro core to initialize resources.
+ */
+typedef void (RETRO_CALLCONV *retro_hw_context_reset_t)(void);
+
+/* Gets current framebuffer which is to be rendered to.
+ * Could change every frame potentially.
+ */
+typedef uintptr_t (RETRO_CALLCONV *retro_hw_get_current_framebuffer_t)(void);
+
+/* Get a symbol from HW context. */
+typedef retro_proc_address_t (RETRO_CALLCONV *retro_hw_get_proc_address_t)(const char *sym);
+
+enum retro_hw_context_type
+{
+   RETRO_HW_CONTEXT_NONE             = 0,
+   /* OpenGL 2.x. Driver can choose to use latest compatibility context. */
+   RETRO_HW_CONTEXT_OPENGL           = 1,
+   /* OpenGL ES 2.0. */
+   RETRO_HW_CONTEXT_OPENGLES2        = 2,
+   /* Modern desktop core GL context. Use version_major/
+    * version_minor fields to set GL version. */
+   RETRO_HW_CONTEXT_OPENGL_CORE      = 3,
+   /* OpenGL ES 3.0 */
+   RETRO_HW_CONTEXT_OPENGLES3        = 4,
+   /* OpenGL ES 3.1+. Set version_major/version_minor. For GLES2 and GLES3,
+    * use the corresponding enums directly. */
+   RETRO_HW_CONTEXT_OPENGLES_VERSION = 5,
+
+   /* Vulkan, see RETRO_ENVIRONMENT_GET_HW_RENDER_INTERFACE. */
+   RETRO_HW_CONTEXT_VULKAN           = 6,
+
+   /* Direct3D, set version_major to select the type of interface
+    * returned by RETRO_ENVIRONMENT_GET_HW_RENDER_INTERFACE */
+   RETRO_HW_CONTEXT_DIRECT3D         = 7,
+
+   RETRO_HW_CONTEXT_DUMMY = INT_MAX
+};
+
+struct retro_hw_render_callback
+{
+   /* Which API to use. Set by libretro core. */
+   enum retro_hw_context_type context_type;
+
+   /* Called when a context has been created or when it has been reset.
+    * An OpenGL context is only valid after context_reset() has been called.
+    *
+    * When context_reset is called, OpenGL resources in the libretro
+    * implementation are guaranteed to be invalid.
+    *
+    * It is possible that context_reset is called multiple times during an
+    * application lifecycle.
+    * If context_reset is called without any notification (context_destroy),
+    * the OpenGL context was lost and resources should just be recreated
+    * without any attempt to "free" old resources.
+    */
+   retro_hw_context_reset_t context_reset;
+
+   /* Set by frontend.
+    * TODO: This is rather obsolete. The frontend should not
+    * be providing preallocated framebuffers. */
+   retro_hw_get_current_framebuffer_t get_current_framebuffer;
+
+   /* Set by frontend.
+    * Can return all relevant functions, including glClear on Windows. */
+   retro_hw_get_proc_address_t get_proc_address;
+
+   /* Set if render buffers should have depth component attached.
+    * TODO: Obsolete. */
+   bool depth;
+
+   /* Set if stencil buffers should be attached.
+    * TODO: Obsolete. */
+   bool stencil;
+
+   /* If depth and stencil are true, a packed 24/8 buffer will be added.
+    * Only attaching stencil is invalid and will be ignored. */
+
+   /* Use conventional bottom-left origin convention. If false,
+    * standard libretro top-left origin semantics are used.
+    * TODO: Move to GL specific interface. */
+   bool bottom_left_origin;
+
+   /* Major version number for core GL context or GLES 3.1+. */
+   unsigned version_major;
+
+   /* Minor version number for core GL context or GLES 3.1+. */
+   unsigned version_minor;
+
+   /* If this is true, the frontend will go very far to avoid
+    * resetting context in scenarios like toggling fullscreen, etc.
+    * TODO: Obsolete? Maybe frontend should just always assume this ...
+    */
+   bool cache_context;
+
+   /* The reset callback might still be called in extreme situations
+    * such as if the context is lost beyond recovery.
+    *
+    * For optimal stability, set this to false, and allow context to be
+    * reset at any time.
+    */
+
+   /* A callback to be called before the context is destroyed in a
+    * controlled way by the frontend. */
+   retro_hw_context_reset_t context_destroy;
+
+   /* OpenGL resources can be deinitialized cleanly at this step.
+    * context_destroy can be set to NULL, in which resources will
+    * just be destroyed without any notification.
+    *
+    * Even when context_destroy is non-NULL, it is possible that
+    * context_reset is called without any destroy notification.
+    * This happens if context is lost by external factors (such as
+    * notified by GL_ARB_robustness).
+    *
+    * In this case, the context is assumed to be already dead,
+    * and the libretro implementation must not try to free any OpenGL
+    * resources in the subsequent context_reset.
+    */
+
+   /* Creates a debug context. */
+   bool debug_context;
+};
+
+/* Callback type passed in RETRO_ENVIRONMENT_SET_KEYBOARD_CALLBACK.
+ * Called by the frontend in response to keyboard events.
+ * down is set if the key is being pressed, or false if it is being released.
+ * keycode is the RETROK value of the char.
+ * character is the text character of the pressed key. (UTF-32).
+ * key_modifiers is a set of RETROKMOD values or'ed together.
+ *
+ * The pressed/keycode state can be indepedent of the character.
+ * It is also possible that multiple characters are generated from a
+ * single keypress.
+ * Keycode events should be treated separately from character events.
+ * However, when possible, the frontend should try to synchronize these.
+ * If only a character is posted, keycode should be RETROK_UNKNOWN.
+ *
+ * Similarily if only a keycode event is generated with no corresponding
+ * character, character should be 0.
+ */
+typedef void (RETRO_CALLCONV *retro_keyboard_event_t)(bool down, unsigned keycode,
+      uint32_t character, uint16_t key_modifiers);
+
+struct retro_keyboard_callback
+{
+   retro_keyboard_event_t callback;
+};
+
+/* Callbacks for RETRO_ENVIRONMENT_SET_DISK_CONTROL_INTERFACE &
+ * RETRO_ENVIRONMENT_SET_DISK_CONTROL_EXT_INTERFACE.
+ * Should be set for implementations which can swap out multiple disk
+ * images in runtime.
+ *
+ * If the implementation can do this automatically, it should strive to do so.
+ * However, there are cases where the user must manually do so.
+ *
+ * Overview: To swap a disk image, eject the disk image with
+ * set_eject_state(true).
+ * Set the disk index with set_image_index(index). Insert the disk again
+ * with set_eject_state(false).
+ */
+
+/* If ejected is true, "ejects" the virtual disk tray.
+ * When ejected, the disk image index can be set.
+ */
+typedef bool (RETRO_CALLCONV *retro_set_eject_state_t)(bool ejected);
+
+/* Gets current eject state. The initial state is 'not ejected'. */
+typedef bool (RETRO_CALLCONV *retro_get_eject_state_t)(void);
+
+/* Gets current disk index. First disk is index 0.
+ * If return value is >= get_num_images(), no disk is currently inserted.
+ */
+typedef unsigned (RETRO_CALLCONV *retro_get_image_index_t)(void);
+
+/* Sets image index. Can only be called when disk is ejected.
+ * The implementation supports setting "no disk" by using an
+ * index >= get_num_images().
+ */
+typedef bool (RETRO_CALLCONV *retro_set_image_index_t)(unsigned index);
+
+/* Gets total number of images which are available to use. */
+typedef unsigned (RETRO_CALLCONV *retro_get_num_images_t)(void);
+
+struct retro_game_info;
+
+/* Replaces the disk image associated with index.
+ * Arguments to pass in info have same requirements as retro_load_game().
+ * Virtual disk tray must be ejected when calling this.
+ *
+ * Replacing a disk image with info = NULL will remove the disk image
+ * from the internal list.
+ * As a result, calls to get_image_index() can change.
+ *
+ * E.g. replace_image_index(1, NULL), and previous get_image_index()
+ * returned 4 before.
+ * Index 1 will be removed, and the new index is 3.
+ */
+typedef bool (RETRO_CALLCONV *retro_replace_image_index_t)(unsigned index,
+      const struct retro_game_info *info);
+
+/* Adds a new valid index (get_num_images()) to the internal disk list.
+ * This will increment subsequent return values from get_num_images() by 1.
+ * This image index cannot be used until a disk image has been set
+ * with replace_image_index. */
+typedef bool (RETRO_CALLCONV *retro_add_image_index_t)(void);
+
+/* Sets initial image to insert in drive when calling
+ * core_load_game().
+ * Since we cannot pass the initial index when loading
+ * content (this would require a major API change), this
+ * is set by the frontend *before* calling the core's
+ * retro_load_game()/retro_load_game_special() implementation.
+ * A core should therefore cache the index/path values and handle
+ * them inside retro_load_game()/retro_load_game_special().
+ * - If 'index' is invalid (index >= get_num_images()), the
+ *   core should ignore the set value and instead use 0
+ * - 'path' is used purely for error checking - i.e. when
+ *   content is loaded, the core should verify that the
+ *   disk specified by 'index' has the specified file path.
+ *   This is to guard against auto selecting the wrong image
+ *   if (for example) the user should modify an existing M3U
+ *   playlist. We have to let the core handle this because
+ *   set_initial_image() must be called before loading content,
+ *   i.e. the frontend cannot access image paths in advance
+ *   and thus cannot perform the error check itself.
+ *   If set path and content path do not match, the core should
+ *   ignore the set 'index' value and instead use 0
+ * Returns 'false' if index or 'path' are invalid, or core
+ * does not support this functionality
+ */
+typedef bool (RETRO_CALLCONV *retro_set_initial_image_t)(unsigned index, const char *path);
+
+/* Fetches the path of the specified disk image file.
+ * Returns 'false' if index is invalid (index >= get_num_images())
+ * or path is otherwise unavailable.
+ */
+typedef bool (RETRO_CALLCONV *retro_get_image_path_t)(unsigned index, char *path, size_t len);
+
+/* Fetches a core-provided 'label' for the specified disk
+ * image file. In the simplest case this may be a file name
+ * (without extension), but for cores with more complex
+ * content requirements information may be provided to
+ * facilitate user disk swapping - for example, a core
+ * running floppy-disk-based content may uniquely label
+ * save disks, data disks, level disks, etc. with names
+ * corresponding to in-game disk change prompts (so the
+ * frontend can provide better user guidance than a 'dumb'
+ * disk index value).
+ * Returns 'false' if index is invalid (index >= get_num_images())
+ * or label is otherwise unavailable.
+ */
+typedef bool (RETRO_CALLCONV *retro_get_image_label_t)(unsigned index, char *label, size_t len);
+
+struct retro_disk_control_callback
+{
+   retro_set_eject_state_t set_eject_state;
+   retro_get_eject_state_t get_eject_state;
+
+   retro_get_image_index_t get_image_index;
+   retro_set_image_index_t set_image_index;
+   retro_get_num_images_t  get_num_images;
+
+   retro_replace_image_index_t replace_image_index;
+   retro_add_image_index_t add_image_index;
+};
+
+struct retro_disk_control_ext_callback
+{
+   retro_set_eject_state_t set_eject_state;
+   retro_get_eject_state_t get_eject_state;
+
+   retro_get_image_index_t get_image_index;
+   retro_set_image_index_t set_image_index;
+   retro_get_num_images_t  get_num_images;
+
+   retro_replace_image_index_t replace_image_index;
+   retro_add_image_index_t add_image_index;
+
+   /* NOTE: Frontend will only attempt to record/restore
+    * last used disk index if both set_initial_image()
+    * and get_image_path() are implemented */
+   retro_set_initial_image_t set_initial_image; /* Optional - may be NULL */
+
+   retro_get_image_path_t get_image_path;       /* Optional - may be NULL */
+   retro_get_image_label_t get_image_label;     /* Optional - may be NULL */
+};
+
+enum retro_pixel_format
+{
+   /* 0RGB1555, native endian.
+    * 0 bit must be set to 0.
+    * This pixel format is default for compatibility concerns only.
+    * If a 15/16-bit pixel format is desired, consider using RGB565. */
+   RETRO_PIXEL_FORMAT_0RGB1555 = 0,
+
+   /* XRGB8888, native endian.
+    * X bits are ignored. */
+   RETRO_PIXEL_FORMAT_XRGB8888 = 1,
+
+   /* RGB565, native endian.
+    * This pixel format is the recommended format to use if a 15/16-bit
+    * format is desired as it is the pixel format that is typically
+    * available on a wide range of low-power devices.
+    *
+    * It is also natively supported in APIs like OpenGL ES. */
+   RETRO_PIXEL_FORMAT_RGB565   = 2,
+
+   /* Ensure sizeof() == sizeof(int). */
+   RETRO_PIXEL_FORMAT_UNKNOWN  = INT_MAX
+};
+
+struct retro_message
+{
+   const char *msg;        /* Message to be displayed. */
+   unsigned    frames;     /* Duration in frames of message. */
+};
+
+enum retro_message_target
+{
+   RETRO_MESSAGE_TARGET_ALL = 0,
+   RETRO_MESSAGE_TARGET_OSD,
+   RETRO_MESSAGE_TARGET_LOG
+};
+
+enum retro_message_type
+{
+   RETRO_MESSAGE_TYPE_NOTIFICATION = 0,
+   RETRO_MESSAGE_TYPE_NOTIFICATION_ALT,
+   RETRO_MESSAGE_TYPE_STATUS,
+   RETRO_MESSAGE_TYPE_PROGRESS
+};
+
+struct retro_message_ext
+{
+   /* Message string to be displayed/logged */
+   const char *msg;
+   /* Duration (in ms) of message when targeting the OSD */
+   unsigned duration;
+   /* Message priority when targeting the OSD
+    * > When multiple concurrent messages are sent to
+    *   the frontend and the frontend does not have the
+    *   capacity to display them all, messages with the
+    *   *highest* priority value should be shown
+    * > There is no upper limit to a message priority
+    *   value (within the bounds of the unsigned data type)
+    * > In the reference frontend (RetroArch), the same
+    *   priority values are used for frontend-generated
+    *   notifications, which are typically assigned values
+    *   between 0 and 3 depending upon importance */
+   unsigned priority;
+   /* Message logging level (info, warn, error, etc.) */
+   enum retro_log_level level;
+   /* Message destination: OSD, logging interface or both */
+   enum retro_message_target target;
+   /* Message 'type' when targeting the OSD
+    * > RETRO_MESSAGE_TYPE_NOTIFICATION: Specifies that a
+    *   message should be handled in identical fashion to
+    *   a standard frontend-generated notification
+    * > RETRO_MESSAGE_TYPE_NOTIFICATION_ALT: Specifies that
+    *   message is a notification that requires user attention
+    *   or action, but that it should be displayed in a manner
+    *   that differs from standard frontend-generated notifications.
+    *   This would typically correspond to messages that should be
+    *   displayed immediately (independently from any internal
+    *   frontend message queue), and/or which should be visually
+    *   distinguishable from frontend-generated notifications.
+    *   For example, a core may wish to inform the user of
+    *   information related to a disk-change event. It is
+    *   expected that the frontend itself may provide a
+    *   notification in this case; if the core sends a
+    *   message of type RETRO_MESSAGE_TYPE_NOTIFICATION, an
+    *   uncomfortable 'double-notification' may occur. A message
+    *   of RETRO_MESSAGE_TYPE_NOTIFICATION_ALT should therefore
+    *   be presented such that visual conflict with regular
+    *   notifications does not occur
+    * > RETRO_MESSAGE_TYPE_STATUS: Indicates that message
+    *   is not a standard notification. This typically
+    *   corresponds to 'status' indicators, such as a core's
+    *   internal FPS, which are intended to be displayed
+    *   either permanently while a core is running, or in
+    *   a manner that does not suggest user attention or action
+    *   is required. 'Status' type messages should therefore be
+    *   displayed in a different on-screen location and in a manner
+    *   easily distinguishable from both standard frontend-generated
+    *   notifications and messages of type RETRO_MESSAGE_TYPE_NOTIFICATION_ALT
+    * > RETRO_MESSAGE_TYPE_PROGRESS: Indicates that message reports
+    *   the progress of an internal core task. For example, in cases
+    *   where a core itself handles the loading of content from a file,
+    *   this may correspond to the percentage of the file that has been
+    *   read. Alternatively, an audio/video playback core may use a
+    *   message of type RETRO_MESSAGE_TYPE_PROGRESS to display the current
+    *   playback position as a percentage of the runtime. 'Progress' type
+    *   messages should therefore be displayed as a literal progress bar,
+    *   where:
+    *   - 'retro_message_ext.msg' is the progress bar title/label
+    *   - 'retro_message_ext.progress' determines the length of
+    *     the progress bar
+    * NOTE: Message type is a *hint*, and may be ignored
+    * by the frontend. If a frontend lacks support for
+    * displaying messages via alternate means than standard
+    * frontend-generated notifications, it will treat *all*
+    * messages as having the type RETRO_MESSAGE_TYPE_NOTIFICATION */
+   enum retro_message_type type;
+   /* Task progress when targeting the OSD and message is
+    * of type RETRO_MESSAGE_TYPE_PROGRESS
+    * > -1:    Unmetered/indeterminate
+    * > 0-100: Current progress percentage
+    * NOTE: Since message type is a hint, a frontend may ignore
+    * progress values. Where relevant, a core should therefore
+    * include progress percentage within the message string,
+    * such that the message intent remains clear when displayed
+    * as a standard frontend-generated notification */
+   int8_t progress;
+};
+
+/* Describes how the libretro implementation maps a libretro input bind
+ * to its internal input system through a human readable string.
+ * This string can be used to better let a user configure input. */
+struct retro_input_descriptor
+{
+   /* Associates given parameters with a description. */
+   unsigned port;
+   unsigned device;
+   unsigned index;
+   unsigned id;
+
+   /* Human readable description for parameters.
+    * The pointer must remain valid until
+    * retro_unload_game() is called. */
+   const char *description;
+};
+
+struct retro_system_info
+{
+   /* All pointers are owned by libretro implementation, and pointers must
+    * remain valid until it is unloaded. */
+
+   const char *library_name;      /* Descriptive name of library. Should not
+                                   * contain any version numbers, etc. */
+   const char *library_version;   /* Descriptive version of core. */
+
+   const char *valid_extensions;  /* A string listing probably content
+                                   * extensions the core will be able to
+                                   * load, separated with pipe.
+                                   * I.e. "bin|rom|iso".
+                                   * Typically used for a GUI to filter
+                                   * out extensions. */
+
+   /* Libretro cores that need to have direct access to their content
+    * files, including cores which use the path of the content files to
+    * determine the paths of other files, should set need_fullpath to true.
+    *
+    * Cores should strive for setting need_fullpath to false,
+    * as it allows the frontend to perform patching, etc.
+    *
+    * If need_fullpath is true and retro_load_game() is called:
+    *    - retro_game_info::path is guaranteed to have a valid path
+    *    - retro_game_info::data and retro_game_info::size are invalid
+    *
+    * If need_fullpath is false and retro_load_game() is called:
+    *    - retro_game_info::path may be NULL
+    *    - retro_game_info::data and retro_game_info::size are guaranteed
+    *      to be valid
+    *
+    * See also:
+    *    - RETRO_ENVIRONMENT_GET_SYSTEM_DIRECTORY
+    *    - RETRO_ENVIRONMENT_GET_SAVE_DIRECTORY
+    */
+   bool        need_fullpath;
+
+   /* If true, the frontend is not allowed to extract any archives before
+    * loading the real content.
+    * Necessary for certain libretro implementations that load games
+    * from zipped archives. */
+   bool        block_extract;
+};
+
+/* Defines overrides which modify frontend handling of
+ * specific content file types.
+ * An array of retro_system_content_info_override is
+ * passed to RETRO_ENVIRONMENT_SET_CONTENT_INFO_OVERRIDE
+ * NOTE: In the following descriptions, references to
+ *       retro_load_game() may be replaced with
+ *       retro_load_game_special() */
+struct retro_system_content_info_override
+{
+   /* A list of file extensions for which the override
+    * should apply, delimited by a 'pipe' character
+    * (e.g. "md|sms|gg")
+    * Permitted file extensions are limited to those
+    * included in retro_system_info::valid_extensions
+    * and/or retro_subsystem_rom_info::valid_extensions */
+   const char *extensions;
+
+   /* Overrides the need_fullpath value set in
+    * retro_system_info and/or retro_subsystem_rom_info.
+    * To reiterate:
+    *
+    * If need_fullpath is true and retro_load_game() is called:
+    *    - retro_game_info::path is guaranteed to contain a valid
+    *      path to an existent file
+    *    - retro_game_info::data and retro_game_info::size are invalid
+    *
+    * If need_fullpath is false and retro_load_game() is called:
+    *    - retro_game_info::path may be NULL
+    *    - retro_game_info::data and retro_game_info::size are guaranteed
+    *      to be valid
+    *
+    * In addition:
+    *
+    * If need_fullpath is true and retro_load_game() is called:
+    *    - retro_game_info_ext::full_path is guaranteed to contain a valid
+    *      path to an existent file
+    *    - retro_game_info_ext::archive_path may be NULL
+    *    - retro_game_info_ext::archive_file may be NULL
+    *    - retro_game_info_ext::dir is guaranteed to contain a valid path
+    *      to the directory in which the content file exists
+    *    - retro_game_info_ext::name is guaranteed to contain the
+    *      basename of the content file, without extension
+    *    - retro_game_info_ext::ext is guaranteed to contain the
+    *      extension of the content file in lower case format
+    *    - retro_game_info_ext::data and retro_game_info_ext::size
+    *      are invalid
+    *
+    * If need_fullpath is false and retro_load_game() is called:
+    *    - If retro_game_info_ext::file_in_archive is false:
+    *       - retro_game_info_ext::full_path is guaranteed to contain
+    *         a valid path to an existent file
+    *       - retro_game_info_ext::archive_path may be NULL
+    *       - retro_game_info_ext::archive_file may be NULL
+    *       - retro_game_info_ext::dir is guaranteed to contain a
+    *         valid path to the directory in which the content file exists
+    *       - retro_game_info_ext::name is guaranteed to contain the
+    *         basename of the content file, without extension
+    *       - retro_game_info_ext::ext is guaranteed to contain the
+    *         extension of the content file in lower case format
+    *    - If retro_game_info_ext::file_in_archive is true:
+    *       - retro_game_info_ext::full_path may be NULL
+    *       - retro_game_info_ext::archive_path is guaranteed to
+    *         contain a valid path to an existent compressed file
+    *         inside which the content file is located
+    *       - retro_game_info_ext::archive_file is guaranteed to
+    *         contain a valid path to an existent content file
+    *         inside the compressed file referred to by
+    *         retro_game_info_ext::archive_path
+    *            e.g. for a compressed file '/path/to/foo.zip'
+    *            containing 'bar.sfc'
+    *             > retro_game_info_ext::archive_path will be '/path/to/foo.zip'
+    *             > retro_game_info_ext::archive_file will be 'bar.sfc'
+    *       - retro_game_info_ext::dir is guaranteed to contain a
+    *         valid path to the directory in which the compressed file
+    *         (containing the content file) exists
+    *       - retro_game_info_ext::name is guaranteed to contain
+    *         EITHER
+    *         1) the basename of the compressed file (containing
+    *            the content file), without extension
+    *         OR
+    *         2) the basename of the content file inside the
+    *            compressed file, without extension
+    *         In either case, a core should consider 'name' to
+    *         be the canonical name/ID of the the content file
+    *       - retro_game_info_ext::ext is guaranteed to contain the
+    *         extension of the content file inside the compressed file,
+    *         in lower case format
+    *    - retro_game_info_ext::data and retro_game_info_ext::size are
+    *      guaranteed to be valid */
+   bool need_fullpath;
+
+   /* If need_fullpath is false, specifies whether the content
+    * data buffer available in retro_load_game() is 'persistent'
+    *
+    * If persistent_data is false and retro_load_game() is called:
+    *    - retro_game_info::data and retro_game_info::size
+    *      are valid only until retro_load_game() returns
+    *    - retro_game_info_ext::data and retro_game_info_ext::size
+    *      are valid only until retro_load_game() returns
+    *
+    * If persistent_data is true and retro_load_game() is called:
+    *    - retro_game_info::data and retro_game_info::size
+    *      are valid until retro_deinit() returns
+    *    - retro_game_info_ext::data and retro_game_info_ext::size
+    *      are valid until retro_deinit() returns */
+   bool persistent_data;
+};
+
+/* Similar to retro_game_info, but provides extended
+ * information about the source content file and
+ * game memory buffer status.
+ * And array of retro_game_info_ext is returned by
+ * RETRO_ENVIRONMENT_GET_GAME_INFO_EXT
+ * NOTE: In the following descriptions, references to
+ *       retro_load_game() may be replaced with
+ *       retro_load_game_special() */
+struct retro_game_info_ext
+{
+   /* - If file_in_archive is false, contains a valid
+    *   path to an existent content file (UTF-8 encoded)
+    * - If file_in_archive is true, may be NULL */
+   const char *full_path;
+
+   /* - If file_in_archive is false, may be NULL
+    * - If file_in_archive is true, contains a valid path
+    *   to an existent compressed file inside which the
+    *   content file is located (UTF-8 encoded) */
+   const char *archive_path;
+
+   /* - If file_in_archive is false, may be NULL
+    * - If file_in_archive is true, contain a valid path
+    *   to an existent content file inside the compressed
+    *   file referred to by archive_path (UTF-8 encoded)
+    *      e.g. for a compressed file '/path/to/foo.zip'
+    *      containing 'bar.sfc'
+    *      > archive_path will be '/path/to/foo.zip'
+    *      > archive_file will be 'bar.sfc' */
+   const char *archive_file;
+
+   /* - If file_in_archive is false, contains a valid path
+    *   to the directory in which the content file exists
+    *   (UTF-8 encoded)
+    * - If file_in_archive is true, contains a valid path
+    *   to the directory in which the compressed file
+    *   (containing the content file) exists (UTF-8 encoded) */
+   const char *dir;
+
+   /* Contains the canonical name/ID of the content file
+    * (UTF-8 encoded). Intended for use when identifying
+    * 'complementary' content named after the loaded file -
+    * i.e. companion data of a different format (a CD image
+    * required by a ROM), texture packs, internally handled
+    * save files, etc.
+    * - If file_in_archive is false, contains the basename
+    *   of the content file, without extension
+    * - If file_in_archive is true, then string is
+    *   implementation specific. A frontend may choose to
+    *   set a name value of:
+    *   EITHER
+    *   1) the basename of the compressed file (containing
+    *      the content file), without extension
+    *   OR
+    *   2) the basename of the content file inside the
+    *      compressed file, without extension
+    *   RetroArch sets the 'name' value according to (1).
+    *   A frontend that supports routine loading of
+    *   content from archives containing multiple unrelated
+    *   content files may set the 'name' value according
+    *   to (2). */
+   const char *name;
+
+   /* - If file_in_archive is false, contains the extension
+    *   of the content file in lower case format
+    * - If file_in_archive is true, contains the extension
+    *   of the content file inside the compressed file,
+    *   in lower case format */
+   const char *ext;
+
+   /* String of implementation specific meta-data. */
+   const char *meta;
+
+   /* Memory buffer of loaded game content. Will be NULL:
+    * IF
+    * - retro_system_info::need_fullpath is true and
+    *   retro_system_content_info_override::need_fullpath
+    *   is unset
+    * OR
+    * - retro_system_content_info_override::need_fullpath
+    *   is true */
+   const void *data;
+
+   /* Size of game content memory buffer, in bytes */
+   size_t size;
+
+   /* True if loaded content file is inside a compressed
+    * archive */
+   bool file_in_archive;
+
+   /* - If data is NULL, value is unset/ignored
+    * - If data is non-NULL:
+    *   - If persistent_data is false, data and size are
+    *     valid only until retro_load_game() returns
+    *   - If persistent_data is true, data and size are
+    *     are valid until retro_deinit() returns */
+   bool persistent_data;
+};
+
+struct retro_game_geometry
+{
+   unsigned base_width;    /* Nominal video width of game. */
+   unsigned base_height;   /* Nominal video height of game. */
+   unsigned max_width;     /* Maximum possible width of game. */
+   unsigned max_height;    /* Maximum possible height of game. */
+
+   float    aspect_ratio;  /* Nominal aspect ratio of game. If
+                            * aspect_ratio is <= 0.0, an aspect ratio
+                            * of base_width / base_height is assumed.
+                            * A frontend could override this setting,
+                            * if desired. */
+};
+
+struct retro_system_timing
+{
+   double fps;             /* FPS of video content. */
+   double sample_rate;     /* Sampling rate of audio. */
+};
+
+struct retro_system_av_info
+{
+   struct retro_game_geometry geometry;
+   struct retro_system_timing timing;
+};
+
+struct retro_variable
+{
+   /* Variable to query in RETRO_ENVIRONMENT_GET_VARIABLE.
+    * If NULL, obtains the complete environment string if more
+    * complex parsing is necessary.
+    * The environment string is formatted as key-value pairs
+    * delimited by semicolons as so:
+    * "key1=value1;key2=value2;..."
+    */
+   const char *key;
+
+   /* Value to be obtained. If key does not exist, it is set to NULL. */
+   const char *value;
+};
+
+struct retro_core_option_display
+{
+   /* Variable to configure in RETRO_ENVIRONMENT_SET_CORE_OPTIONS_DISPLAY */
+   const char *key;
+
+   /* Specifies whether variable should be displayed
+    * when presenting core options to the user */
+   bool visible;
+};
+
+/* Maximum number of values permitted for a core option
+ * > Note: We have to set a maximum value due the limitations
+ *   of the C language - i.e. it is not possible to create an
+ *   array of structs each containing a variable sized array,
+ *   so the retro_core_option_definition values array must
+ *   have a fixed size. The size limit of 128 is a balancing
+ *   act - it needs to be large enough to support all 'sane'
+ *   core options, but setting it too large may impact low memory
+ *   platforms. In practise, if a core option has more than
+ *   128 values then the implementation is likely flawed.
+ *   To quote the above API reference:
+ *      "The number of possible options should be very limited
+ *       i.e. it should be feasible to cycle through options
+ *       without a keyboard."
+ */
+#define RETRO_NUM_CORE_OPTION_VALUES_MAX 128
+
+struct retro_core_option_value
+{
+   /* Expected option value */
+   const char *value;
+
+   /* Human-readable value label. If NULL, value itself
+    * will be displayed by the frontend */
+   const char *label;
+};
+
+struct retro_core_option_definition
+{
+   /* Variable to query in RETRO_ENVIRONMENT_GET_VARIABLE. */
+   const char *key;
+
+   /* Human-readable core option description (used as menu label) */
+   const char *desc;
+
+   /* Human-readable core option information (used as menu sublabel) */
+   const char *info;
+
+   /* Array of retro_core_option_value structs, terminated by NULL */
+   struct retro_core_option_value values[RETRO_NUM_CORE_OPTION_VALUES_MAX];
+
+   /* Default core option value. Must match one of the values
+    * in the retro_core_option_value array, otherwise will be
+    * ignored */
+   const char *default_value;
+};
+
+struct retro_core_options_intl
+{
+   /* Pointer to an array of retro_core_option_definition structs
+    * - US English implementation
+    * - Must point to a valid array */
+   struct retro_core_option_definition *us;
+
+   /* Pointer to an array of retro_core_option_definition structs
+    * - Implementation for current frontend language
+    * - May be NULL */
+   struct retro_core_option_definition *local;
+};
+
+struct retro_core_option_v2_category
+{
+   /* Variable uniquely identifying the
+    * option category. Valid key characters
+    * are [a-z, A-Z, 0-9, _, -] */
+   const char *key;
+
+   /* Human-readable category description
+    * > Used as category menu label when
+    *   frontend has core option category
+    *   support */
+   const char *desc;
+
+   /* Human-readable category information
+    * > Used as category menu sublabel when
+    *   frontend has core option category
+    *   support
+    * > Optional (may be NULL or an empty
+    *   string) */
+   const char *info;
+};
+
+struct retro_core_option_v2_definition
+{
+   /* Variable to query in RETRO_ENVIRONMENT_GET_VARIABLE.
+    * Valid key characters are [a-z, A-Z, 0-9, _, -] */
+   const char *key;
+
+   /* Human-readable core option description
+    * > Used as menu label when frontend does
+    *   not have core option category support
+    *   e.g. "Video > Aspect Ratio" */
+   const char *desc;
+
+   /* Human-readable core option description
+    * > Used as menu label when frontend has
+    *   core option category support
+    *   e.g. "Aspect Ratio", where associated
+    *   retro_core_option_v2_category::desc
+    *   is "Video"
+    * > If empty or NULL, the string specified by
+    *   desc will be used as the menu label
+    * > Will be ignored (and may be set to NULL)
+    *   if category_key is empty or NULL */
+   const char *desc_categorized;
+
+   /* Human-readable core option information
+    * > Used as menu sublabel */
+   const char *info;
+
+   /* Human-readable core option information
+    * > Used as menu sublabel when frontend
+    *   has core option category support
+    *   (e.g. may be required when info text
+    *   references an option by name/desc,
+    *   and the desc/desc_categorized text
+    *   for that option differ)
+    * > If empty or NULL, the string specified by
+    *   info will be used as the menu sublabel
+    * > Will be ignored (and may be set to NULL)
+    *   if category_key is empty or NULL */
+   const char *info_categorized;
+
+   /* Variable specifying category (e.g. "video",
+    * "audio") that will be assigned to the option
+    * if frontend has core option category support.
+    * > Categorized options will be displayed in a
+    *   subsection/submenu of the frontend core
+    *   option interface
+    * > Specified string must match one of the
+    *   retro_core_option_v2_category::key values
+    *   in the associated retro_core_option_v2_category
+    *   array; If no match is not found, specified
+    *   string will be considered as NULL
+    * > If specified string is empty or NULL, option will
+    *   have no category and will be shown at the top
+    *   level of the frontend core option interface */
+   const char *category_key;
+
+   /* Array of retro_core_option_value structs, terminated by NULL */
+   struct retro_core_option_value values[RETRO_NUM_CORE_OPTION_VALUES_MAX];
+
+   /* Default core option value. Must match one of the values
+    * in the retro_core_option_value array, otherwise will be
+    * ignored */
+   const char *default_value;
+};
+
+struct retro_core_options_v2
+{
+   /* Array of retro_core_option_v2_category structs,
+    * terminated by NULL
+    * > If NULL, all entries in definitions array
+    *   will have no category and will be shown at
+    *   the top level of the frontend core option
+    *   interface
+    * > Will be ignored if frontend does not have
+    *   core option category support */
+   struct retro_core_option_v2_category *categories;
+
+   /* Array of retro_core_option_v2_definition structs,
+    * terminated by NULL */
+   struct retro_core_option_v2_definition *definitions;
+};
+
+struct retro_core_options_v2_intl
+{
+   /* Pointer to a retro_core_options_v2 struct
+    * > US English implementation
+    * > Must point to a valid struct */
+   struct retro_core_options_v2 *us;
+
+   /* Pointer to a retro_core_options_v2 struct
+    * - Implementation for current frontend language
+    * - May be NULL */
+   struct retro_core_options_v2 *local;
+};
+
+struct retro_game_info
+{
+   const char *path;       /* Path to game, UTF-8 encoded.
+                            * Sometimes used as a reference for building other paths.
+                            * May be NULL if game was loaded from stdin or similar,
+                            * but in this case some cores will be unable to load `data`.
+                            * So, it is preferable to fabricate something here instead
+                            * of passing NULL, which will help more cores to succeed.
+                            * retro_system_info::need_fullpath requires
+                            * that this path is valid. */
+   const void *data;       /* Memory buffer of loaded game. Will be NULL
+                            * if need_fullpath was set. */
+   size_t      size;       /* Size of memory buffer. */
+   const char *meta;       /* String of implementation specific meta-data. */
+};
+
+#define RETRO_MEMORY_ACCESS_WRITE (1 << 0)
+   /* The core will write to the buffer provided by retro_framebuffer::data. */
+#define RETRO_MEMORY_ACCESS_READ (1 << 1)
+   /* The core will read from retro_framebuffer::data. */
+#define RETRO_MEMORY_TYPE_CACHED (1 << 0)
+   /* The memory in data is cached.
+    * If not cached, random writes and/or reading from the buffer is expected to be very slow. */
+struct retro_framebuffer
+{
+   void *data;                      /* The framebuffer which the core can render into.
+                                       Set by frontend in GET_CURRENT_SOFTWARE_FRAMEBUFFER.
+                                       The initial contents of data are unspecified. */
+   unsigned width;                  /* The framebuffer width used by the core. Set by core. */
+   unsigned height;                 /* The framebuffer height used by the core. Set by core. */
+   size_t pitch;                    /* The number of bytes between the beginning of a scanline,
+                                       and beginning of the next scanline.
+                                       Set by frontend in GET_CURRENT_SOFTWARE_FRAMEBUFFER. */
+   enum retro_pixel_format format;  /* The pixel format the core must use to render into data.
+                                       This format could differ from the format used in
+                                       SET_PIXEL_FORMAT.
+                                       Set by frontend in GET_CURRENT_SOFTWARE_FRAMEBUFFER. */
+
+   unsigned access_flags;           /* How the core will access the memory in the framebuffer.
+                                       RETRO_MEMORY_ACCESS_* flags.
+                                       Set by core. */
+   unsigned memory_flags;           /* Flags telling core how the memory has been mapped.
+                                       RETRO_MEMORY_TYPE_* flags.
+                                       Set by frontend in GET_CURRENT_SOFTWARE_FRAMEBUFFER. */
+};
+
+/* Used by a libretro core to override the current
+ * fastforwarding mode of the frontend */
+struct retro_fastforwarding_override
+{
+   /* Specifies the runtime speed multiplier that
+    * will be applied when 'fastforward' is true.
+    * For example, a value of 5.0 when running 60 FPS
+    * content will cap the fast-forward rate at 300 FPS.
+    * Note that the target multiplier may not be achieved
+    * if the host hardware has insufficient processing
+    * power.
+    * Setting a value of 0.0 (or greater than 0.0 but
+    * less than 1.0) will result in an uncapped
+    * fast-forward rate (limited only by hardware
+    * capacity).
+    * If the value is negative, it will be ignored
+    * (i.e. the frontend will use a runtime speed
+    * multiplier of its own choosing) */
+   float ratio;
+
+   /* If true, fastforwarding mode will be enabled.
+    * If false, fastforwarding mode will be disabled. */
+   bool fastforward;
+
+   /* If true, and if supported by the frontend, an
+    * on-screen notification will be displayed while
+    * 'fastforward' is true.
+    * If false, and if supported by the frontend, any
+    * on-screen fast-forward notifications will be
+    * suppressed */
+   bool notification;
+
+   /* If true, the core will have sole control over
+    * when fastforwarding mode is enabled/disabled;
+    * the frontend will not be able to change the
+    * state set by 'fastforward' until either
+    * 'inhibit_toggle' is set to false, or the core
+    * is unloaded */
+   bool inhibit_toggle;
+};
+
+/* Callbacks */
+
+/* Environment callback. Gives implementations a way of performing
+ * uncommon tasks. Extensible. */
+typedef bool (RETRO_CALLCONV *retro_environment_t)(unsigned cmd, void *data);
+
+/* Render a frame. Pixel format is 15-bit 0RGB1555 native endian
+ * unless changed (see RETRO_ENVIRONMENT_SET_PIXEL_FORMAT).
+ *
+ * Width and height specify dimensions of buffer.
+ * Pitch specifices length in bytes between two lines in buffer.
+ *
+ * For performance reasons, it is highly recommended to have a frame
+ * that is packed in memory, i.e. pitch == width * byte_per_pixel.
+ * Certain graphic APIs, such as OpenGL ES, do not like textures
+ * that are not packed in memory.
+ */
+typedef void (RETRO_CALLCONV *retro_video_refresh_t)(const void *data, unsigned width,
+      unsigned height, size_t pitch);
+
+/* Renders a single audio frame. Should only be used if implementation
+ * generates a single sample at a time.
+ * Format is signed 16-bit native endian.
+ */
+typedef void (RETRO_CALLCONV *retro_audio_sample_t)(int16_t left, int16_t right);
+
+/* Renders multiple audio frames in one go.
+ *
+ * One frame is defined as a sample of left and right channels, interleaved.
+ * I.e. int16_t buf[4] = { l, r, l, r }; would be 2 frames.
+ * Only one of the audio callbacks must ever be used.
+ */
+typedef size_t (RETRO_CALLCONV *retro_audio_sample_batch_t)(const int16_t *data,
+      size_t frames);
+
+/* Polls input. */
+typedef void (RETRO_CALLCONV *retro_input_poll_t)(void);
+
+/* Queries for input for player 'port'. device will be masked with
+ * RETRO_DEVICE_MASK.
+ *
+ * Specialization of devices such as RETRO_DEVICE_JOYPAD_MULTITAP that
+ * have been set with retro_set_controller_port_device()
+ * will still use the higher level RETRO_DEVICE_JOYPAD to request input.
+ */
+typedef int16_t (RETRO_CALLCONV *retro_input_state_t)(unsigned port, unsigned device,
+      unsigned index, unsigned id);
+
+/* Sets callbacks. retro_set_environment() is guaranteed to be called
+ * before retro_init().
+ *
+ * The rest of the set_* functions are guaranteed to have been called
+ * before the first call to retro_run() is made. */
+RETRO_API void retro_set_environment(retro_environment_t);
+RETRO_API void retro_set_video_refresh(retro_video_refresh_t);
+RETRO_API void retro_set_audio_sample(retro_audio_sample_t);
+RETRO_API void retro_set_audio_sample_batch(retro_audio_sample_batch_t);
+RETRO_API void retro_set_input_poll(retro_input_poll_t);
+RETRO_API void retro_set_input_state(retro_input_state_t);
+
+/* Library global initialization/deinitialization. */
+RETRO_API void retro_init(void);
+RETRO_API void retro_deinit(void);
+
+/* Must return RETRO_API_VERSION. Used to validate ABI compatibility
+ * when the API is revised. */
+RETRO_API unsigned retro_api_version(void);
+
+/* Gets statically known system info. Pointers provided in *info
+ * must be statically allocated.
+ * Can be called at any time, even before retro_init(). */
+RETRO_API void retro_get_system_info(struct retro_system_info *info);
+
+/* Gets information about system audio/video timings and geometry.
+ * Can be called only after retro_load_game() has successfully completed.
+ * NOTE: The implementation of this function might not initialize every
+ * variable if needed.
+ * E.g. geom.aspect_ratio might not be initialized if core doesn't
+ * desire a particular aspect ratio. */
+RETRO_API void retro_get_system_av_info(struct retro_system_av_info *info);
+
+/* Sets device to be used for player 'port'.
+ * By default, RETRO_DEVICE_JOYPAD is assumed to be plugged into all
+ * available ports.
+ * Setting a particular device type is not a guarantee that libretro cores
+ * will only poll input based on that particular device type. It is only a
+ * hint to the libretro core when a core cannot automatically detect the
+ * appropriate input device type on its own. It is also relevant when a
+ * core can change its behavior depending on device type.
+ *
+ * As part of the core's implementation of retro_set_controller_port_device,
+ * the core should call RETRO_ENVIRONMENT_SET_INPUT_DESCRIPTORS to notify the
+ * frontend if the descriptions for any controls have changed as a
+ * result of changing the device type.
+ */
+RETRO_API void retro_set_controller_port_device(unsigned port, unsigned device);
+
+/* Resets the current game. */
+RETRO_API void retro_reset(void);
+
+/* Runs the game for one video frame.
+ * During retro_run(), input_poll callback must be called at least once.
+ *
+ * If a frame is not rendered for reasons where a game "dropped" a frame,
+ * this still counts as a frame, and retro_run() should explicitly dupe
+ * a frame if GET_CAN_DUPE returns true.
+ * In this case, the video callback can take a NULL argument for data.
+ */
+RETRO_API void retro_run(void);
+
+/* Returns the amount of data the implementation requires to serialize
+ * internal state (save states).
+ * Between calls to retro_load_game() and retro_unload_game(), the
+ * returned size is never allowed to be larger than a previous returned
+ * value, to ensure that the frontend can allocate a save state buffer once.
+ */
+RETRO_API size_t retro_serialize_size(void);
+
+/* Serializes internal state. If failed, or size is lower than
+ * retro_serialize_size(), it should return false, true otherwise. */
+RETRO_API bool retro_serialize(void *data, size_t size);
+RETRO_API bool retro_unserialize(const void *data, size_t size);
+
+RETRO_API void retro_cheat_reset(void);
+RETRO_API void retro_cheat_set(unsigned index, bool enabled, const char *code);
+
+/* Loads a game.
+ * Return true to indicate successful loading and false to indicate load failure.
+ */
+RETRO_API bool retro_load_game(const struct retro_game_info *game);
+
+/* Loads a "special" kind of game. Should not be used,
+ * except in extreme cases. */
+RETRO_API bool retro_load_game_special(
+  unsigned game_type,
+  const struct retro_game_info *info, size_t num_info
+);
+
+/* Unloads the currently loaded game. Called before retro_deinit(void). */
+RETRO_API void retro_unload_game(void);
+
+/* Gets region of game. */
+RETRO_API unsigned retro_get_region(void);
+
+/* Gets region of memory. */
+RETRO_API void *retro_get_memory_data(unsigned id);
+RETRO_API size_t retro_get_memory_size(unsigned id);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
diff -Naur duckstation-51041e47f70123eda41d999701f5651830a0a95e.orig/src/duckstation-libretro/libretro_host_display.cpp duckstation-51041e47f70123eda41d999701f5651830a0a95e/src/duckstation-libretro/libretro_host_display.cpp
--- duckstation-51041e47f70123eda41d999701f5651830a0a95e.orig/src/duckstation-libretro/libretro_host_display.cpp	1970-01-01 01:00:00.000000000 +0100
+++ duckstation-51041e47f70123eda41d999701f5651830a0a95e/src/duckstation-libretro/libretro_host_display.cpp	2022-01-12 18:30:18.000000000 +0000
@@ -0,0 +1,265 @@
+#include "libretro_host_display.h"
+#include "common/align.h"
+#include "common/assert.h"
+#include "common/log.h"
+#include "libretro.h"
+#include "libretro_host_interface.h"
+#include <array>
+#include <tuple>
+Log_SetChannel(LibretroHostDisplay);
+
+static retro_pixel_format GetRetroPixelFormat(HostDisplayPixelFormat format)
+{
+  switch (format)
+  {
+    case HostDisplayPixelFormat::BGRA8:
+      return RETRO_PIXEL_FORMAT_XRGB8888;
+
+    case HostDisplayPixelFormat::RGB565:
+      return RETRO_PIXEL_FORMAT_RGB565;
+
+    case HostDisplayPixelFormat::RGBA5551:
+      return RETRO_PIXEL_FORMAT_0RGB1555;
+
+    default:
+      return RETRO_PIXEL_FORMAT_UNKNOWN;
+  }
+}
+
+LibretroHostDisplay::LibretroHostDisplay()
+{
+  retro_pixel_format pf = RETRO_PIXEL_FORMAT_RGB565;
+  if (!g_retro_environment_callback(RETRO_ENVIRONMENT_SET_PIXEL_FORMAT, &pf))
+    Log_ErrorPrint("Failed to set pixel format to RGB565");
+  else
+    m_current_pixel_format = pf;
+}
+
+LibretroHostDisplay::~LibretroHostDisplay() = default;
+
+bool LibretroHostDisplay::CheckPixelFormat(retro_pixel_format new_format)
+{
+  if (new_format == RETRO_PIXEL_FORMAT_UNKNOWN || m_current_pixel_format == new_format)
+    return true;
+
+  if (!g_retro_environment_callback(RETRO_ENVIRONMENT_SET_PIXEL_FORMAT, &new_format))
+  {
+    Log_ErrorPrintf("g_retro_environment_callback(RETRO_ENVIRONMENT_SET_PIXEL_FORMAT, %u) failed",
+                    static_cast<unsigned>(new_format));
+    return false;
+  }
+
+  if (!g_libretro_host_interface.UpdateSystemAVInfo(false))
+    return false;
+
+  m_current_pixel_format = new_format;
+  return true;
+}
+
+HostDisplay::RenderAPI LibretroHostDisplay::GetRenderAPI() const
+{
+  return RenderAPI::None;
+}
+
+bool LibretroHostDisplay::CreateImGuiContext()
+{
+  return true;
+}
+
+void LibretroHostDisplay::DestroyImGuiContext()
+{
+  // noop
+}
+
+bool LibretroHostDisplay::UpdateImGuiFontTexture()
+{
+  // noop
+  return true;
+}
+
+void* LibretroHostDisplay::GetRenderDevice() const
+{
+  return nullptr;
+}
+
+void* LibretroHostDisplay::GetRenderContext() const
+{
+  return nullptr;
+}
+
+bool LibretroHostDisplay::HasRenderDevice() const
+{
+  return true;
+}
+
+bool LibretroHostDisplay::HasRenderSurface() const
+{
+  return true;
+}
+
+bool LibretroHostDisplay::CreateRenderDevice(const WindowInfo& wi, std::string_view adapter_name, bool debug_device,
+                                             bool threaded_presentation)
+{
+  m_window_info = wi;
+  return true;
+}
+
+bool LibretroHostDisplay::InitializeRenderDevice(std::string_view shader_cache_directory, bool debug_device,
+                                                 bool threaded_presentation)
+{
+  return true;
+}
+
+bool LibretroHostDisplay::MakeRenderContextCurrent()
+{
+  return true;
+}
+
+bool LibretroHostDisplay::DoneRenderContextCurrent()
+{
+  return true;
+}
+
+void LibretroHostDisplay::DestroyRenderDevice()
+{
+  ClearSoftwareCursor();
+}
+
+void LibretroHostDisplay::DestroyRenderSurface() {}
+
+bool LibretroHostDisplay::CreateResources()
+{
+  return true;
+}
+
+void LibretroHostDisplay::DestroyResources() {}
+
+bool LibretroHostDisplay::ChangeRenderWindow(const WindowInfo& wi)
+{
+  m_window_info = wi;
+  return true;
+}
+
+void LibretroHostDisplay::ResizeRenderWindow(s32 new_window_width, s32 new_window_height)
+{
+  m_window_info.surface_width = new_window_width;
+  m_window_info.surface_height = new_window_height;
+}
+
+bool LibretroHostDisplay::SupportsFullscreen() const
+{
+  return false;
+}
+
+bool LibretroHostDisplay::IsFullscreen()
+{
+  return false;
+}
+
+bool LibretroHostDisplay::SetFullscreen(bool fullscreen, u32 width, u32 height, float refresh_rate)
+{
+  return false;
+}
+
+HostDisplay::AdapterAndModeList LibretroHostDisplay::GetAdapterAndModeList()
+{
+  return {};
+}
+
+bool LibretroHostDisplay::SetPostProcessingChain(const std::string_view& config)
+{
+  return false;
+}
+
+std::unique_ptr<HostDisplayTexture> LibretroHostDisplay::CreateTexture(u32 width, u32 height, u32 layers, u32 levels,
+                                                                       u32 samples, HostDisplayPixelFormat format,
+                                                                       const void* data, u32 data_stride,
+                                                                       bool dynamic)
+{
+  return nullptr;
+}
+
+void LibretroHostDisplay::UpdateTexture(HostDisplayTexture* texture, u32 x, u32 y, u32 width, u32 height,
+                                        const void* data, u32 data_stride)
+{
+}
+
+bool LibretroHostDisplay::DownloadTexture(const void* texture_handle, HostDisplayPixelFormat texture_format, u32 x,
+                                          u32 y, u32 width, u32 height, void* out_data, u32 out_data_stride)
+{
+  return false;
+}
+
+bool LibretroHostDisplay::SupportsDisplayPixelFormat(HostDisplayPixelFormat format) const
+{
+  // For when we can change the pixel format.
+  // return (GetRetroPixelFormat(format) != RETRO_PIXEL_FORMAT_UNKNOWN);
+  return (GetRetroPixelFormat(format) == m_current_pixel_format);
+}
+
+bool LibretroHostDisplay::BeginSetDisplayPixels(HostDisplayPixelFormat format, u32 width, u32 height, void** out_buffer,
+                                                u32* out_pitch)
+{
+  const retro_pixel_format retro_pf = GetRetroPixelFormat(format);
+  if (!CheckPixelFormat(retro_pf))
+    return false;
+
+  m_software_fb.data = nullptr;
+  m_software_fb.width = width;
+  m_software_fb.height = height;
+  m_software_fb.pitch = 0;
+  m_software_fb.format = RETRO_PIXEL_FORMAT_UNKNOWN;
+  m_software_fb.access_flags = RETRO_MEMORY_ACCESS_WRITE;
+  m_software_fb.memory_flags = 0;
+  /*if (g_retro_environment_callback(RETRO_ENVIRONMENT_GET_CURRENT_SOFTWARE_FRAMEBUFFER, &m_software_fb) &&
+      m_software_fb.format == retro_pf)
+  {
+    SetDisplayTexture(m_software_fb.data, format, m_software_fb.width, m_software_fb.height, 0, 0, m_software_fb.width,
+                      m_software_fb.height);
+    *out_buffer = m_software_fb.data;
+    *out_pitch = static_cast<u32>(m_software_fb.pitch);
+    return true;
+  }*/
+
+  const u32 pitch = Common::AlignUpPow2(width * GetDisplayPixelFormatSize(format), 4);
+  const u32 required_size = height * pitch;
+  if (m_frame_buffer.size() < (required_size / 4))
+    m_frame_buffer.resize(required_size / 4);
+
+  m_frame_buffer_pitch = pitch;
+  SetDisplayTexture(m_frame_buffer.data(), format, width, height, 0, 0, width, height);
+  *out_buffer = m_frame_buffer.data();
+  *out_pitch = pitch;
+  return true;
+}
+
+void LibretroHostDisplay::EndSetDisplayPixels()
+{
+  // noop
+}
+
+void LibretroHostDisplay::SetVSync(bool enabled)
+{
+  // The libretro frontend controls this.
+  Log_DevPrintf("Ignoring SetVSync(%u)", BoolToUInt32(enabled));
+}
+
+bool LibretroHostDisplay::Render()
+{
+  if (HasDisplayTexture())
+  {
+    g_retro_video_refresh_callback(m_display_texture_handle, m_display_texture_view_width,
+                                   m_display_texture_view_height, m_frame_buffer_pitch);
+
+    if (m_display_texture_handle == m_software_fb.data)
+      ClearDisplayTexture();
+  }
+
+  return true;
+}
+
+bool LibretroHostDisplay::RenderScreenshot(u32 width, u32 height, std::vector<u32>* out_pixels, u32* out_stride,
+                                         HostDisplayPixelFormat* out_format)
+{
+  return true;
+}
diff -Naur duckstation-51041e47f70123eda41d999701f5651830a0a95e.orig/src/duckstation-libretro/libretro_host_display.h duckstation-51041e47f70123eda41d999701f5651830a0a95e/src/duckstation-libretro/libretro_host_display.h
--- duckstation-51041e47f70123eda41d999701f5651830a0a95e.orig/src/duckstation-libretro/libretro_host_display.h	1970-01-01 01:00:00.000000000 +0100
+++ duckstation-51041e47f70123eda41d999701f5651830a0a95e/src/duckstation-libretro/libretro_host_display.h	2022-01-12 18:30:18.000000000 +0000
@@ -0,0 +1,70 @@
+#pragma once
+#include "core/host_display.h"
+#include "libretro.h"
+
+class LibretroHostDisplay final : public HostDisplay
+{
+public:
+  LibretroHostDisplay();
+  ~LibretroHostDisplay();
+
+  RenderAPI GetRenderAPI() const override;
+  void* GetRenderDevice() const override;
+  void* GetRenderContext() const override;
+
+  bool HasRenderDevice() const override;
+  bool HasRenderSurface() const override;
+
+  bool CreateRenderDevice(const WindowInfo& wi, std::string_view adapter_name, bool debug_device,
+                          bool threaded_presentation) override;
+  bool InitializeRenderDevice(std::string_view shader_cache_directory, bool debug_device,
+                              bool threaded_presentation) override;
+  void DestroyRenderDevice() override;
+
+  bool MakeRenderContextCurrent() override;
+  bool DoneRenderContextCurrent() override;
+
+  bool ChangeRenderWindow(const WindowInfo& wi) override;
+  void ResizeRenderWindow(s32 new_window_width, s32 new_window_height) override;
+  bool SupportsFullscreen() const override;
+  bool IsFullscreen() override;
+  bool SetFullscreen(bool fullscreen, u32 width, u32 height, float refresh_rate) override;
+  AdapterAndModeList GetAdapterAndModeList() override;
+  bool CreateImGuiContext() override;
+  void DestroyImGuiContext() override;
+  bool UpdateImGuiFontTexture() override;
+  void DestroyRenderSurface() override;
+
+  bool SetPostProcessingChain(const std::string_view& config) override;
+
+  bool CreateResources() override;
+  void DestroyResources() override;
+
+  std::unique_ptr<HostDisplayTexture> CreateTexture(u32 width, u32 height, u32 layers, u32 levels, u32 samples,
+                                                    HostDisplayPixelFormat format, const void* data, u32 data_stride,
+                                                    bool dynamic = false) override;
+  void UpdateTexture(HostDisplayTexture* texture, u32 x, u32 y, u32 width, u32 height, const void* data,
+                     u32 data_stride) override;
+  bool DownloadTexture(const void* texture_handle, HostDisplayPixelFormat texture_format, u32 x, u32 y, u32 width,
+                       u32 height, void* out_data, u32 out_data_stride) override;
+
+  void SetVSync(bool enabled) override;
+
+  bool Render() override;
+  bool RenderScreenshot(u32 width, u32 height, std::vector<u32>* out_pixels, u32* out_stride,
+                        HostDisplayPixelFormat* out_format) override;
+
+  bool SupportsDisplayPixelFormat(HostDisplayPixelFormat format) const override;
+
+  bool BeginSetDisplayPixels(HostDisplayPixelFormat format, u32 width, u32 height, void** out_buffer,
+                             u32* out_pitch) override;
+  void EndSetDisplayPixels() override;
+
+private:
+  bool CheckPixelFormat(retro_pixel_format new_format);
+
+  std::vector<u32> m_frame_buffer;
+  u32 m_frame_buffer_pitch = 0;
+  retro_framebuffer m_software_fb = {};
+  retro_pixel_format m_current_pixel_format = RETRO_PIXEL_FORMAT_UNKNOWN;
+};
diff -Naur duckstation-51041e47f70123eda41d999701f5651830a0a95e.orig/src/duckstation-libretro/libretro_host_interface.cpp duckstation-51041e47f70123eda41d999701f5651830a0a95e/src/duckstation-libretro/libretro_host_interface.cpp
--- duckstation-51041e47f70123eda41d999701f5651830a0a95e.orig/src/duckstation-libretro/libretro_host_interface.cpp	1970-01-01 01:00:00.000000000 +0100
+++ duckstation-51041e47f70123eda41d999701f5651830a0a95e/src/duckstation-libretro/libretro_host_interface.cpp	2022-01-12 18:30:18.000000000 +0000
@@ -0,0 +1,1693 @@
+#include "libretro_host_interface.h"
+#include "common/assert.h"
+#include "common/byte_stream.h"
+#include "common/file_system.h"
+#include "common/log.h"
+#include "common/platform.h"
+#include "common/string_util.h"
+#include "core/analog_controller.h"
+#include "core/analog_joystick.h"
+#include "core/bus.h"
+#include "core/cheats.h"
+#include "core/digital_controller.h"
+#include "core/gpu.h"
+#include "core/namco_guncon.h"
+#include "core/negcon.h"
+#include "core/pad.h"
+#include "core/playstation_mouse.h"
+#include "core/system.h"
+#include "libretro_audio_stream.h"
+#include "libretro_game_settings.h"
+#include "libretro_host_display.h"
+#include "libretro_opengl_host_display.h"
+#include "libretro_settings_interface.h"
+#include "libretro_vulkan_host_display.h"
+#include <array>
+#include <cstring>
+#include <tuple>
+#include <utility>
+#include <vector>
+Log_SetChannel(LibretroHostInterface);
+
+#ifdef WIN32
+#include "libretro_d3d11_host_display.h"
+#endif
+
+LibretroHostInterface g_libretro_host_interface;
+#define P_THIS (&g_libretro_host_interface)
+
+#define RETRO_DEVICE_PS_CONTROLLER RETRO_DEVICE_SUBCLASS(RETRO_DEVICE_JOYPAD, 0)
+#define RETRO_DEVICE_PS_DUALSHOCK RETRO_DEVICE_SUBCLASS(RETRO_DEVICE_ANALOG, 0)
+#define RETRO_DEVICE_PS_ANALOG_JOYSTICK RETRO_DEVICE_SUBCLASS(RETRO_DEVICE_ANALOG, 1)
+#define RETRO_DEVICE_PS_NEGCON RETRO_DEVICE_SUBCLASS(RETRO_DEVICE_ANALOG, 2)
+#define RETRO_DEVICE_PS_GUNCON RETRO_DEVICE_SUBCLASS(RETRO_DEVICE_LIGHTGUN, 0)
+#define RETRO_DEVICE_PS_MOUSE RETRO_DEVICE_SUBCLASS(RETRO_DEVICE_MOUSE, 0)
+
+retro_environment_t g_retro_environment_callback;
+retro_video_refresh_t g_retro_video_refresh_callback;
+retro_audio_sample_t g_retro_audio_sample_callback;
+retro_audio_sample_batch_t g_retro_audio_sample_batch_callback;
+retro_input_poll_t g_retro_input_poll_callback;
+retro_input_state_t g_retro_input_state_callback;
+
+static retro_log_callback s_libretro_log_callback = {};
+static bool s_libretro_log_callback_valid = false;
+static bool s_libretro_log_callback_registered = false;
+static bool libretro_supports_option_categories = false;
+static int show_multitap = -1;
+static int analog_press = -1;
+
+static void LibretroLogCallback(void* pUserParam, const char* channelName, const char* functionName, LOGLEVEL level,
+                                const char* message)
+{
+  static constexpr std::array<retro_log_level, LOGLEVEL_COUNT> levels = {
+    {RETRO_LOG_ERROR, RETRO_LOG_ERROR, RETRO_LOG_WARN, RETRO_LOG_INFO, RETRO_LOG_INFO, RETRO_LOG_INFO, RETRO_LOG_DEBUG,
+     RETRO_LOG_DEBUG, RETRO_LOG_DEBUG, RETRO_LOG_DEBUG}};
+
+  s_libretro_log_callback.log(levels[level], "[%s] %s\n", (level <= LOGLEVEL_PERF) ? functionName : channelName,
+                              message);
+}
+
+LibretroHostInterface::LibretroHostInterface() = default;
+
+LibretroHostInterface::~LibretroHostInterface()
+{
+  // a few things we are safe to cleanup because these pointers are garaunteed to be initialized to zero (0)
+  // when the shared library (dll/so) is loaded into memory. Other things are not safe, such as calling
+  // HostInterface::Shutdown, because it depends on a bunch of vars being initialized to zero at runtime,
+  // otherwise it thinks it needs to clean them up and they're actually invalid, and crashes happen.
+
+  m_audio_stream.reset();   // assert checks will expect this is nullified.
+  ReleaseHostDisplay();     // assert checks will expect this is nullified.
+}
+
+#include "libretro_core_options.h"
+
+void LibretroHostInterface::retro_set_environment()
+{
+  libretro_supports_option_categories = false;
+  libretro_set_core_options(g_retro_environment_callback, &libretro_supports_option_categories);
+
+  static const struct retro_controller_description pads[] = {
+   	  { "Digital Controller (Gamepad)", RETRO_DEVICE_JOYPAD },
+   	  { "Analog Controller (DualShock)", RETRO_DEVICE_PS_DUALSHOCK },
+   	  { "Analog Joystick", RETRO_DEVICE_PS_ANALOG_JOYSTICK },
+   	  { "NeGcon", RETRO_DEVICE_PS_NEGCON },
+   	  { "Namco GunCon", RETRO_DEVICE_PS_GUNCON },
+   	  { "PlayStation Mouse", RETRO_DEVICE_PS_MOUSE },
+      { NULL, 0 },
+  };
+
+  static const struct retro_controller_description pads_mt[] = {
+   	  { "Digital Controller (Gamepad)", RETRO_DEVICE_JOYPAD },
+   	  { "Analog Controller (DualShock)", RETRO_DEVICE_PS_DUALSHOCK },
+   	  { "Analog Joystick", RETRO_DEVICE_PS_ANALOG_JOYSTICK },
+   	  { "NeGcon", RETRO_DEVICE_PS_NEGCON },
+   	  { "PlayStation Mouse", RETRO_DEVICE_PS_MOUSE },
+      { NULL, 0 },
+  };
+
+  static const struct retro_controller_info ports[] = {
+   	  { pads, 6 },
+   	  { pads, 6 },
+   	  { pads_mt, 6 },
+   	  { pads_mt, 6 },
+   	  { pads_mt, 6 },
+   	  { pads_mt, 6 },
+   	  { pads_mt, 6 },
+   	  { pads_mt, 6 },
+      { NULL, 0 },
+  };
+
+  g_retro_environment_callback(RETRO_ENVIRONMENT_SET_CONTROLLER_INFO, (void *)ports);
+
+  InitLogging();
+}
+
+void LibretroHostInterface::InitInterfaces()
+{
+  InitRumbleInterface();
+  InitDiskControlInterface();
+
+  unsigned dummy = 0;
+  m_supports_input_bitmasks = g_retro_environment_callback(RETRO_ENVIRONMENT_GET_INPUT_BITMASKS, &dummy);
+}
+
+void LibretroHostInterface::InitLogging()
+{
+  if (s_libretro_log_callback_registered)
+    return;
+
+  s_libretro_log_callback_valid =
+    g_retro_environment_callback(RETRO_ENVIRONMENT_GET_LOG_INTERFACE, &s_libretro_log_callback);
+
+  if (s_libretro_log_callback_valid)
+  {
+    Log::RegisterCallback(LibretroLogCallback, nullptr);
+    s_libretro_log_callback_registered = true;
+  }
+}
+
+bool LibretroHostInterface::Initialize()
+{
+  if (!HostInterface::Initialize())
+    return false;
+
+  /* Reset disk control info struct */
+  P_THIS->m_disk_control_info.has_sub_images      = false;
+  P_THIS->m_disk_control_info.initial_image_index = 0;
+  P_THIS->m_disk_control_info.image_index         = 0;
+  P_THIS->m_disk_control_info.image_count         = 0;
+  P_THIS->m_disk_control_info.sub_images_parent_path.clear();
+  P_THIS->m_disk_control_info.image_paths.clear();
+  P_THIS->m_disk_control_info.image_labels.clear();
+
+  InitInterfaces();
+  LibretroSettingsInterface si;
+  LoadSettings(si);
+  FixIncompatibleSettings(true);
+  UpdateLogging();
+
+  return true;
+}
+
+void LibretroHostInterface::Shutdown()
+{
+  libretro_supports_option_categories = false;
+  HostInterface::Shutdown();
+
+  /* Reset disk control info struct */
+  P_THIS->m_disk_control_info.has_sub_images      = false;
+  P_THIS->m_disk_control_info.initial_image_index = 0;
+  P_THIS->m_disk_control_info.image_index         = 0;
+  P_THIS->m_disk_control_info.image_count         = 0;
+  P_THIS->m_disk_control_info.sub_images_parent_path.clear();
+  P_THIS->m_disk_control_info.image_paths.clear();
+  P_THIS->m_disk_control_info.image_labels.clear();
+}
+
+void LibretroHostInterface::ReportError(const char* message)
+{
+  AddFormattedOSDMessage(10.0f, "ERROR: %s", message);
+  Log_ErrorPrint(message);
+}
+
+void LibretroHostInterface::ReportMessage(const char* message)
+{
+  AddOSDMessage(message, 5.0f);
+  Log_InfoPrint(message);
+}
+
+bool LibretroHostInterface::ConfirmMessage(const char* message)
+{
+  Log_InfoPrintf("Confirm: %s", message);
+  return false;
+}
+
+void LibretroHostInterface::GetGameInfo(const char* path, CDImage* image, std::string* code, std::string* title)
+{
+  // Just use the filename for now... we don't have the game list. Unless we can pull this from the frontend somehow?
+  *title = FileSystem::GetFileTitleFromPath(path);
+
+  if (image)
+    *code = System::GetGameCodeForImage(image, true);
+  else
+    code->clear();
+}
+
+static const char* GetSaveDirectory()
+{
+  const char* save_directory = nullptr;
+  if (!g_retro_environment_callback(RETRO_ENVIRONMENT_GET_SAVE_DIRECTORY, &save_directory) || !save_directory)
+    save_directory = "saves";
+
+  return save_directory;
+}
+
+std::string LibretroHostInterface::GetSharedMemoryCardPath(u32 slot) const
+{
+  return StringUtil::StdStringFromFormat("%s" FS_OSPATH_SEPARATOR_STR "duckstation_shared_card_%d.mcd",
+                                         GetSaveDirectory(), slot + 1);
+}
+
+std::string LibretroHostInterface::GetGameMemoryCardPath(const char* game_code, u32 slot) const
+{
+  return StringUtil::StdStringFromFormat("%s" FS_OSPATH_SEPARATOR_STR "%s_%d.mcd", GetSaveDirectory(), game_code,
+                                         slot + 1);
+}
+
+std::string LibretroHostInterface::GetShaderCacheBasePath() const
+{
+  // Use the save directory, and failing that, the system directory.
+  const char* save_directory_ptr = nullptr;
+  if (!g_retro_environment_callback(RETRO_ENVIRONMENT_GET_SAVE_DIRECTORY, &save_directory_ptr) || !save_directory_ptr)
+  {
+    save_directory_ptr = nullptr;
+    if (!g_retro_environment_callback(RETRO_ENVIRONMENT_GET_SYSTEM_DIRECTORY, &save_directory_ptr) ||
+        !save_directory_ptr)
+    {
+      Log_WarningPrint("No shader cache directory available, startup will be slower.");
+      return std::string();
+    }
+  }
+
+  // Use a directory named "duckstation_cache" in the save/system directory.
+  std::string shader_cache_path = StringUtil::StdStringFromFormat(
+    "%s" FS_OSPATH_SEPARATOR_STR "duckstation_cache" FS_OSPATH_SEPARATOR_STR, save_directory_ptr);
+  if (!FileSystem::DirectoryExists(shader_cache_path.c_str()) &&
+      !FileSystem::CreateDirectory(shader_cache_path.c_str(), false))
+  {
+    Log_ErrorPrintf("Failed to create shader cache directory: '%s'", shader_cache_path.c_str());
+    return std::string();
+  }
+
+  Log_InfoPrintf("Shader cache directory: '%s'", shader_cache_path.c_str());
+  return shader_cache_path;
+}
+
+std::string LibretroHostInterface::GetStringSettingValue(const char* section, const char* key,
+                                                         const char* default_value /*= ""*/)
+{
+  TinyString name;
+  name.Format("duckstation_%s.%s", section, key);
+  retro_variable var{name, default_value};
+  if (g_retro_environment_callback(RETRO_ENVIRONMENT_GET_VARIABLE, &var) && var.value)
+    return var.value;
+  else
+    return default_value;
+}
+
+void LibretroHostInterface::DisplayLoadingScreen(const char* message, int progress_min /*= -1*/,
+                                                int progress_max /*= -1*/, int progress_value /*= -1*/) {}
+
+void LibretroHostInterface::AddOSDMessage(std::string message, float duration /*= 2.0f*/)
+{
+  if (!g_settings.display_show_osd_messages)
+    return;
+
+  retro_message msg = {};
+  msg.msg = message.c_str();
+  msg.frames = static_cast<u32>(duration * (System::IsShutdown() ? 60.0f : System::GetThrottleFrequency()));
+  g_retro_environment_callback(RETRO_ENVIRONMENT_SET_MESSAGE, &msg);
+}
+
+void LibretroHostInterface::AddKeyedOSDMessage(std::string key, std::string message, float duration /* = 2.0f */) {}
+
+void LibretroHostInterface::RemoveKeyedOSDMessage(std::string key) {}
+
+void LibretroHostInterface::retro_get_system_av_info(struct retro_system_av_info* info)
+{
+  const bool use_resolution_scale = (g_settings.gpu_renderer != GPURenderer::Software);
+  GetSystemAVInfo(info, use_resolution_scale);
+  m_last_aspect_ratio = info->geometry.aspect_ratio;
+
+  Log_InfoPrintf("base = %ux%u, max = %ux%u, aspect ratio = %.2f, fps = %.2f", info->geometry.base_width,
+                 info->geometry.base_height, info->geometry.max_width, info->geometry.max_height,
+                 info->geometry.aspect_ratio, info->timing.fps);
+}
+
+void LibretroHostInterface::GetSystemAVInfo(struct retro_system_av_info* info, bool use_resolution_scale)
+{
+  const u32 resolution_scale = use_resolution_scale ? GetResolutionScale() : 1u;
+  Assert(System::IsValid());
+
+  std::memset(info, 0, sizeof(*info));
+
+  info->geometry.base_width = (m_display ? m_display->GetDisplayWidth() : GPU_MAX_DISPLAY_WIDTH) * resolution_scale;
+  info->geometry.base_height = (m_display ? m_display->GetDisplayHeight() : GPU_MAX_DISPLAY_HEIGHT) * resolution_scale;
+  info->geometry.aspect_ratio = (m_display ? m_display->GetDisplayAspectRatio() : (g_gpu ? g_gpu->GetDisplayAspectRatio() : g_settings.GetDisplayAspectRatioValue()));
+  info->geometry.max_width = VRAM_WIDTH * resolution_scale;
+  info->geometry.max_height = VRAM_HEIGHT * resolution_scale;
+
+  info->timing.fps = System::GetThrottleFrequency();
+  info->timing.sample_rate = static_cast<double>(AUDIO_SAMPLE_RATE);
+}
+
+bool LibretroHostInterface::UpdateSystemAVInfo(bool use_resolution_scale)
+{
+  struct retro_system_av_info avi;
+  GetSystemAVInfo(&avi, use_resolution_scale);
+
+  Log_InfoPrintf("base = %ux%u, max = %ux%u, aspect ratio = %.2f, fps = %.2f", avi.geometry.base_width,
+                 avi.geometry.base_height, avi.geometry.max_width, avi.geometry.max_height, avi.geometry.aspect_ratio,
+                 avi.timing.fps);
+
+  if (!g_retro_environment_callback(RETRO_ENVIRONMENT_SET_SYSTEM_AV_INFO, &avi))
+  {
+    Log_ErrorPrintf("Failed to update system AV info on resolution change");
+    return false;
+  }
+
+  m_display->ResizeRenderWindow(avi.geometry.base_width, avi.geometry.base_height);
+  m_last_aspect_ratio = avi.geometry.aspect_ratio;
+  return true;
+}
+
+void LibretroHostInterface::UpdateGeometry()
+{
+  struct retro_system_av_info avi;
+  const bool use_resolution_scale = (g_settings.gpu_renderer != GPURenderer::Software);
+  GetSystemAVInfo(&avi, use_resolution_scale);
+
+  Log_InfoPrintf("base = %ux%u, max = %ux%u, aspect ratio = %.2f", avi.geometry.base_width, avi.geometry.base_height,
+                 avi.geometry.max_width, avi.geometry.max_height, avi.geometry.aspect_ratio);
+
+  if (!g_retro_environment_callback(RETRO_ENVIRONMENT_SET_GEOMETRY, &avi.geometry))
+    Log_WarningPrint("RETRO_ENVIRONMENT_SET_GEOMETRY failed");
+
+  m_display->ResizeRenderWindow(avi.geometry.base_width, avi.geometry.base_height);
+  m_last_aspect_ratio = avi.geometry.aspect_ratio;
+}
+
+void LibretroHostInterface::UpdateLogging()
+{
+  Log::SetFilterLevel(g_settings.log_level);
+
+  if (s_libretro_log_callback_valid)
+    Log::SetConsoleOutputParams(false);
+  else
+    Log::SetConsoleOutputParams(true, nullptr, g_settings.log_level);
+}
+
+bool LibretroHostInterface::UpdateGameSettings()
+{
+  std::unique_ptr<GameSettings::Entry> new_game_settings;
+
+  if (!System::IsShutdown() && !System::GetRunningCode().empty())
+  {
+    new_game_settings = GetSettingsForGame(System::GetRunningCode());
+    if (new_game_settings)
+      Log_InfoPrintf("Game settings found for %s", System::GetRunningCode().c_str());
+  }
+
+  if (new_game_settings == m_game_settings)
+    return false;
+
+  m_game_settings = std::move(new_game_settings);
+  return true;
+}
+
+void LibretroHostInterface::ApplyGameSettings()
+{
+  if (!g_settings.apply_game_settings || !m_game_settings)
+    return;
+
+  m_game_settings->ApplySettings(System::GetState() == System::State::Starting);
+}
+
+bool LibretroHostInterface::retro_load_game(const struct retro_game_info* game)
+{
+  auto bp = std::make_shared<SystemBootParameters>();
+  bp->filename = game->path;
+  bp->media_playlist_index = P_THIS->m_disk_control_info.initial_image_index;
+  bp->force_software_renderer = !m_hw_render_callback_valid;
+
+  struct retro_input_descriptor desc[] = {
+#define JOYP(port)                                                                                                     \
+  {port, RETRO_DEVICE_JOYPAD, 0, RETRO_DEVICE_ID_JOYPAD_LEFT, "D-Pad Left"},                                           \
+    {port, RETRO_DEVICE_JOYPAD, 0, RETRO_DEVICE_ID_JOYPAD_UP, "D-Pad Up"},                                             \
+    {port, RETRO_DEVICE_JOYPAD, 0, RETRO_DEVICE_ID_JOYPAD_DOWN, "D-Pad Down"},                                         \
+    {port, RETRO_DEVICE_JOYPAD, 0, RETRO_DEVICE_ID_JOYPAD_RIGHT, "D-Pad Right"},                                       \
+    {port, RETRO_DEVICE_JOYPAD, 0, RETRO_DEVICE_ID_JOYPAD_B, "Cross"},                                                 \
+    {port, RETRO_DEVICE_JOYPAD, 0, RETRO_DEVICE_ID_JOYPAD_A, "Circle"},                                                \
+    {port, RETRO_DEVICE_JOYPAD, 0, RETRO_DEVICE_ID_JOYPAD_X, "Triangle"},                                              \
+    {port, RETRO_DEVICE_JOYPAD, 0, RETRO_DEVICE_ID_JOYPAD_Y, "Square"},                                                \
+    {port, RETRO_DEVICE_JOYPAD, 0, RETRO_DEVICE_ID_JOYPAD_L, "L1"},                                                    \
+    {port, RETRO_DEVICE_JOYPAD, 0, RETRO_DEVICE_ID_JOYPAD_L2, "L2"},                                                   \
+    {port, RETRO_DEVICE_JOYPAD, 0, RETRO_DEVICE_ID_JOYPAD_L3, "L3"},                                                   \
+    {port, RETRO_DEVICE_JOYPAD, 0, RETRO_DEVICE_ID_JOYPAD_R, "R1"},                                                    \
+    {port, RETRO_DEVICE_JOYPAD, 0, RETRO_DEVICE_ID_JOYPAD_R2, "R2"},                                                   \
+    {port, RETRO_DEVICE_JOYPAD, 0, RETRO_DEVICE_ID_JOYPAD_R3, "R3"},                                                   \
+    {port, RETRO_DEVICE_JOYPAD, 0, RETRO_DEVICE_ID_JOYPAD_SELECT, "Select"},                                           \
+    {port, RETRO_DEVICE_JOYPAD, 0, RETRO_DEVICE_ID_JOYPAD_START, "Start"},                                             \
+    {port, RETRO_DEVICE_ANALOG, RETRO_DEVICE_INDEX_ANALOG_LEFT, RETRO_DEVICE_ID_ANALOG_X, "Left Analog X"},            \
+    {port, RETRO_DEVICE_ANALOG, RETRO_DEVICE_INDEX_ANALOG_LEFT, RETRO_DEVICE_ID_ANALOG_Y, "Left Analog Y"},            \
+    {port, RETRO_DEVICE_ANALOG, RETRO_DEVICE_INDEX_ANALOG_RIGHT, RETRO_DEVICE_ID_ANALOG_X, "Right Analog X"},          \
+    {port, RETRO_DEVICE_ANALOG, RETRO_DEVICE_INDEX_ANALOG_RIGHT, RETRO_DEVICE_ID_ANALOG_Y, "Right Analog Y"},
+
+    JOYP(0) JOYP(1) JOYP(2) JOYP(3) JOYP(4) JOYP(5) JOYP(6) JOYP(7)
+
+      {0},
+  };
+
+  g_retro_environment_callback(RETRO_ENVIRONMENT_SET_INPUT_DESCRIPTORS, desc);
+
+  if (!BootSystem(std::move(bp)))
+    return false;
+
+  if (g_settings.gpu_renderer != GPURenderer::Software)
+  {
+    if (!m_hw_render_callback_valid)
+      RequestHardwareRendererContext();
+    else
+      SwitchToHardwareRenderer();
+  }
+
+  /* Initialise disk control info struct */
+  if (System::HasMedia())
+  {
+    if (System::HasMediaSubImages())
+    {
+      const std::string& parent_path = System::GetMediaFileName();
+      if (parent_path.empty())
+        return false;
+
+      P_THIS->m_disk_control_info.has_sub_images         = true;
+      P_THIS->m_disk_control_info.image_index            = System::GetMediaSubImageIndex();
+      P_THIS->m_disk_control_info.image_count            = System::GetMediaSubImageCount();
+      P_THIS->m_disk_control_info.sub_images_parent_path = parent_path;
+
+      for (u32 i = 0; i < P_THIS->m_disk_control_info.image_count; i++)
+      {
+        const std::string& sub_image_path = System::GetMediaSubImagePath(i);
+        if (sub_image_path.empty())
+          return false;
+
+        const std::string& sub_image_label = System::GetMediaSubImageTitle(i);
+        if (sub_image_label.empty())
+          return false;
+
+        P_THIS->m_disk_control_info.image_paths.push_back(sub_image_path);
+        P_THIS->m_disk_control_info.image_labels.push_back(sub_image_label);
+      }
+    }
+    else
+    {
+      const std::string& image_path = System::GetMediaFileName();
+      if (image_path.empty())
+        return false;
+
+      const std::string_view image_label = FileSystem::GetFileTitleFromPath(image_path);
+      if (image_label.empty())
+        return false;
+
+      P_THIS->m_disk_control_info.has_sub_images = false;
+      P_THIS->m_disk_control_info.image_index    = 0;
+      P_THIS->m_disk_control_info.image_count    = 1;
+      P_THIS->m_disk_control_info.sub_images_parent_path.clear();
+
+      P_THIS->m_disk_control_info.image_paths.push_back(image_path);
+      P_THIS->m_disk_control_info.image_labels.push_back(std::string(image_label));
+    }
+  }
+
+  switch (System::GetRegion())
+  {
+      case  ConsoleRegion::NTSC_J:
+      {
+         struct retro_core_option_display option_display;
+         option_display.visible = false;
+         option_display.key = "duckstation_BIOS.PathNTSCU";
+         g_retro_environment_callback(RETRO_ENVIRONMENT_SET_CORE_OPTIONS_DISPLAY, &option_display);
+         option_display.key = "duckstation_BIOS.PathPAL";
+         g_retro_environment_callback(RETRO_ENVIRONMENT_SET_CORE_OPTIONS_DISPLAY, &option_display);
+
+         break;
+      }
+
+      case  ConsoleRegion::NTSC_U:
+      {
+         struct retro_core_option_display option_display;
+         option_display.visible = false;
+         option_display.key = "duckstation_BIOS.PathNTSCJ";
+         g_retro_environment_callback(RETRO_ENVIRONMENT_SET_CORE_OPTIONS_DISPLAY, &option_display);
+         option_display.key = "duckstation_BIOS.PathPAL";
+         g_retro_environment_callback(RETRO_ENVIRONMENT_SET_CORE_OPTIONS_DISPLAY, &option_display);
+
+         break;
+      }
+
+      case  ConsoleRegion::PAL:
+      {
+         struct retro_core_option_display option_display;
+         option_display.visible = false;
+         option_display.key = "duckstation_BIOS.PathNTSCU";
+         g_retro_environment_callback(RETRO_ENVIRONMENT_SET_CORE_OPTIONS_DISPLAY, &option_display);
+         option_display.key = "duckstation_BIOS.PathNTSCJ";
+         g_retro_environment_callback(RETRO_ENVIRONMENT_SET_CORE_OPTIONS_DISPLAY, &option_display);
+
+         break;
+      }
+  }
+
+  struct retro_core_option_display option_display;
+  option_display.visible = false;
+  if (g_settings.gpu_renderer == GPURenderer::Software)
+  {
+      option_display.key = "duckstation_GPU.UseSoftwareRendererForReadbacks";
+      g_retro_environment_callback(RETRO_ENVIRONMENT_SET_CORE_OPTIONS_DISPLAY, &option_display);
+      option_display.key = "duckstation_GPU.MSAA";
+      g_retro_environment_callback(RETRO_ENVIRONMENT_SET_CORE_OPTIONS_DISPLAY, &option_display);
+      option_display.key = "duckstation_GPU.TrueColor";
+      g_retro_environment_callback(RETRO_ENVIRONMENT_SET_CORE_OPTIONS_DISPLAY, &option_display);
+      option_display.key = "duckstation_GPU.ScaledDithering";
+      g_retro_environment_callback(RETRO_ENVIRONMENT_SET_CORE_OPTIONS_DISPLAY, &option_display);
+      option_display.key = "duckstation_GPU.ChromaSmoothing24Bit";
+      g_retro_environment_callback(RETRO_ENVIRONMENT_SET_CORE_OPTIONS_DISPLAY, &option_display);
+      option_display.key = "duckstation_GPU.TextureFilter";
+      g_retro_environment_callback(RETRO_ENVIRONMENT_SET_CORE_OPTIONS_DISPLAY, &option_display);
+      option_display.key = "duckstation_GPU.PGXPEnable";
+      g_retro_environment_callback(RETRO_ENVIRONMENT_SET_CORE_OPTIONS_DISPLAY, &option_display);
+      option_display.key = "duckstation_GPU.PGXPCulling";
+      g_retro_environment_callback(RETRO_ENVIRONMENT_SET_CORE_OPTIONS_DISPLAY, &option_display);
+      option_display.key = "duckstation_GPU.PGXPTextureCorrection";
+      g_retro_environment_callback(RETRO_ENVIRONMENT_SET_CORE_OPTIONS_DISPLAY, &option_display);
+      option_display.key = "duckstation_GPU.PGXPDepthBuffer";
+      g_retro_environment_callback(RETRO_ENVIRONMENT_SET_CORE_OPTIONS_DISPLAY, &option_display);
+      option_display.key = "duckstation_GPU.PGXPVertexCache";
+      g_retro_environment_callback(RETRO_ENVIRONMENT_SET_CORE_OPTIONS_DISPLAY, &option_display);
+      option_display.key = "duckstation_GPU.PGXPCPU";
+      g_retro_environment_callback(RETRO_ENVIRONMENT_SET_CORE_OPTIONS_DISPLAY, &option_display);
+      option_display.key = "duckstation_GPU.PGXPPreserveProjFP";
+      g_retro_environment_callback(RETRO_ENVIRONMENT_SET_CORE_OPTIONS_DISPLAY, &option_display);
+      option_display.key = "duckstation_GPU.PGXPTolerance";
+      g_retro_environment_callback(RETRO_ENVIRONMENT_SET_CORE_OPTIONS_DISPLAY, &option_display);
+      option_display.key = "duckstation_GPU.DownsampleMode";
+      g_retro_environment_callback(RETRO_ENVIRONMENT_SET_CORE_OPTIONS_DISPLAY, &option_display);
+      option_display.key = "duckstation_GPU.ResolutionScale";
+      g_retro_environment_callback(RETRO_ENVIRONMENT_SET_CORE_OPTIONS_DISPLAY, &option_display);
+#ifdef ANDROID
+      option_display.key = "duckstation_GPU.ResolutionSoftScale";
+      g_retro_environment_callback(RETRO_ENVIRONMENT_SET_CORE_OPTIONS_DISPLAY, &option_display);
+#endif
+  }
+  else
+  {
+      option_display.key = "duckstation_GPU.UseThread";
+      g_retro_environment_callback(RETRO_ENVIRONMENT_SET_CORE_OPTIONS_DISPLAY, &option_display);
+      option_display.key = "duckstation_GPU.ResolutionSoftScale";
+      g_retro_environment_callback(RETRO_ENVIRONMENT_SET_CORE_OPTIONS_DISPLAY, &option_display);
+  }
+
+  return true;
+}
+
+void LibretroHostInterface::retro_set_controller_port_device(unsigned port, unsigned device)
+{
+  if (port >= NUM_CONTROLLER_AND_CARD_PORTS)
+	return;
+
+  switch (device)
+  {
+    case RETRO_DEVICE_JOYPAD:
+    case RETRO_DEVICE_PS_CONTROLLER:
+      g_settings.controller_types[port] = ControllerType::DigitalController;
+      Log_InfoPrintf("Port %u = Digital Controller (Gamepad)", (port + 1));
+      break;
+
+    case RETRO_DEVICE_PS_DUALSHOCK:
+      g_settings.controller_types[port] = ControllerType::AnalogController;
+      Log_InfoPrintf("Port %u = Analog Controller (DualShock)", (port + 1));
+      break;
+
+    case RETRO_DEVICE_PS_ANALOG_JOYSTICK:
+      g_settings.controller_types[port] = ControllerType::AnalogJoystick;
+      Log_InfoPrintf("Port %u = Analog Joystick", (port + 1));
+      break;
+
+    case RETRO_DEVICE_PS_NEGCON:
+      g_settings.controller_types[port] = ControllerType::NeGcon;
+      Log_InfoPrintf("Port %u = NeGcon", (port + 1));
+      break;
+
+    case RETRO_DEVICE_PS_GUNCON:
+      g_settings.controller_types[port] = ControllerType::NamcoGunCon;
+      Log_InfoPrintf("Port %u = Namco GunCon", (port + 1));
+      break;
+
+    case RETRO_DEVICE_PS_MOUSE:
+      g_settings.controller_types[port] = ControllerType::PlayStationMouse;
+      Log_InfoPrintf("Port %u = PlayStation Mouse", (port + 1));
+      break;
+
+    case RETRO_DEVICE_NONE:
+    default:
+      g_settings.controller_types[port] = ControllerType::None;
+      Log_InfoPrintf("Port %u = None", (port + 1));
+      break;
+  }
+  System::UpdateControllers();
+  System::ResetControllers();
+  System::UpdateControllerSettings();
+}
+
+void LibretroHostInterface::retro_run_frame()
+{
+  Assert(!System::IsShutdown());
+
+  if (HasCoreVariablesChanged())
+    UpdateSettings();
+
+  UpdateControllers();
+
+  System::RunFrame();
+
+  const float aspect_ratio = m_display->GetDisplayAspectRatio();
+
+  if (aspect_ratio != m_last_aspect_ratio)
+    UpdateGeometry();
+
+  m_display->Render();
+}
+
+unsigned LibretroHostInterface::retro_get_region()
+{
+  return System::IsPALRegion() ? RETRO_REGION_PAL : RETRO_REGION_NTSC;
+}
+
+size_t LibretroHostInterface::retro_serialize_size()
+{
+  return System::MAX_SAVE_STATE_SIZE;
+}
+
+bool LibretroHostInterface::retro_serialize(void* data, size_t size)
+{
+  std::unique_ptr<ByteStream> stream = ByteStream_CreateMemoryStream(data, static_cast<u32>(size));
+  if (!System::SaveState(stream.get(), 0))
+  {
+    Log_ErrorPrintf("Failed to save state to memory stream");
+    return false;
+  }
+
+  return true;
+}
+
+bool LibretroHostInterface::retro_unserialize(const void* data, size_t size)
+{
+  std::unique_ptr<ByteStream> stream = ByteStream_CreateReadOnlyMemoryStream(data, static_cast<u32>(size));
+  if (!System::LoadState(stream.get(), false))
+  {
+    Log_ErrorPrintf("Failed to load save state from memory stream");
+    return false;
+  }
+
+  return true;
+}
+
+void* LibretroHostInterface::retro_get_memory_data(unsigned id)
+{
+  switch (id)
+  {
+    case RETRO_MEMORY_SYSTEM_RAM:
+      return System::IsShutdown() ? nullptr : Bus::g_ram;
+
+    case RETRO_MEMORY_SAVE_RAM: {
+      const MemoryCardType type = g_settings.memory_card_types[0];
+      if (System::IsShutdown()  || type != MemoryCardType::Libretro) {
+        return nullptr;
+      }
+      auto card = g_pad.GetMemoryCard(0);
+      auto& data = card->GetData();
+      return data.data();
+      break;
+    }
+
+    default:
+      return nullptr;
+  }
+}
+
+size_t LibretroHostInterface::retro_get_memory_size(unsigned id)
+{
+  switch (id)
+  {
+    case RETRO_MEMORY_SYSTEM_RAM:
+      return Bus::g_ram_size;
+
+    case RETRO_MEMORY_SAVE_RAM: {
+      const MemoryCardType type = g_settings.memory_card_types[0];
+      if (System::IsShutdown()  || type != MemoryCardType::Libretro) {
+        return 0;
+      }
+      return 128 * 1024;
+    }
+
+    default:
+      return 0;
+  }
+}
+
+void LibretroHostInterface::retro_cheat_reset()
+{
+  System::SetCheatList(nullptr);
+}
+
+void LibretroHostInterface::retro_cheat_set(unsigned index, bool enabled, const char* code)
+{
+  CheatList* cl = System::GetCheatList();
+  if (!cl)
+  {
+    System::SetCheatList(std::make_unique<CheatList>());
+    cl = System::GetCheatList();
+  }
+
+  CheatCode cc;
+  cc.description = StringUtil::StdStringFromFormat("Cheat%u", index);
+  cc.enabled = true;
+  if (!CheatList::ParseLibretroCheat(&cc, code))
+    Log_ErrorPrintf("Failed to parse cheat %u '%s'", index, code);
+
+  cl->SetCode(index, std::move(cc));
+}
+
+bool LibretroHostInterface::AcquireHostDisplay()
+{
+  // start in software mode, switch to hardware later
+  m_display = std::make_unique<LibretroHostDisplay>();
+  return true;
+}
+
+void LibretroHostInterface::ReleaseHostDisplay()
+{
+  if (m_hw_render_display)
+  {
+    m_hw_render_display->DestroyRenderDevice();
+    m_hw_render_display.reset();
+    m_using_hardware_renderer = false;
+  }
+
+  if (m_display)
+  {
+    m_display->DestroyRenderDevice();
+    m_display.reset();
+  }
+}
+
+std::unique_ptr<AudioStream> LibretroHostInterface::CreateAudioStream(AudioBackend backend)
+{
+  return std::make_unique<LibretroAudioStream>();
+}
+void LibretroHostInterface::OnSystemCreated() {}
+
+void LibretroHostInterface::OnSystemPaused(bool paused) {}
+
+void LibretroHostInterface::OnSystemDestroyed() {}
+
+void LibretroHostInterface::OnControllerTypeChanged(u32 slot) {}
+
+void LibretroHostInterface::SetMouseMode(bool relative, bool hide_cursor) {}
+
+bool LibretroHostInterface::HasCoreVariablesChanged()
+{
+  bool changed = false;
+  return (g_retro_environment_callback(RETRO_ENVIRONMENT_GET_VARIABLE_UPDATE, &changed) && changed);
+}
+
+std::string LibretroHostInterface::GetBIOSDirectory()
+{
+  // Assume BIOS files are located in system directory.
+  const char* system_directory = nullptr;
+  if (!g_retro_environment_callback(RETRO_ENVIRONMENT_GET_SYSTEM_DIRECTORY, &system_directory) || !system_directory)
+    return GetProgramDirectoryRelativePath("system");
+  else
+    return system_directory;
+}
+
+std::unique_ptr<ByteStream> LibretroHostInterface::OpenPackageFile(const char* path, u32 flags)
+{
+  Log_ErrorPrintf("Ignoring request for package file '%s'", path);
+  return {};
+}
+
+void LibretroHostInterface::LoadSettings(SettingsInterface& si)
+{
+  HostInterface::LoadSettings(si);
+
+  // turn percentage into fraction for overclock
+  const u32 overclock_percent = static_cast<u32>(std::max(si.GetIntValue("CPU", "Overclock", 100), 1));
+  Settings::CPUOverclockPercentToFraction(overclock_percent, &g_settings.cpu_overclock_numerator,
+                                          &g_settings.cpu_overclock_denominator);
+  g_settings.cpu_overclock_enable = (overclock_percent != 100);
+  g_settings.UpdateOverclockActive();
+
+  // convert msaa settings
+  const std::string msaa = si.GetStringValue("GPU", "MSAA", "1");
+  g_settings.gpu_multisamples = StringUtil::FromChars<u32>(msaa).value_or(1);
+  g_settings.gpu_per_sample_shading = StringUtil::EndsWith(msaa, "-ssaa");
+
+  // Ensure we don't use the standalone memcard directory in shared mode.
+  for (u32 i = 0; i < NUM_CONTROLLER_AND_CARD_PORTS; i++)
+    g_settings.memory_card_paths[i] = GetSharedMemoryCardPath(i);
+
+  int show_multitap_prev = show_multitap;
+  if (g_settings.multitap_mode == MultitapMode::Disabled)
+    show_multitap = 0;
+  else if (g_settings.multitap_mode == MultitapMode::BothPorts)
+    show_multitap = 2;
+  else
+    show_multitap = 1;
+
+  if (show_multitap != show_multitap_prev)
+  {
+    unsigned i;
+    struct retro_core_option_display option_display;
+    char controller_multitap_options[8][49] = {
+        "duckstation_Controller3.ForceAnalogOnReset",
+        "duckstation_Controller3.AnalogDPadInDigitalMode",
+        "duckstation_Controller3.AxisScale",
+        "duckstation_Controller3.VibrationBias",
+        "duckstation_Controller4.ForceAnalogOnReset",
+        "duckstation_Controller4.AnalogDPadInDigitalMode",
+        "duckstation_Controller4.AxisScale",
+        "duckstation_Controller4.VibrationBias"
+    };
+
+    option_display.visible = show_multitap;
+
+    for (i = 0; i < 8; i++)
+    {
+        option_display.key = controller_multitap_options[i];
+        g_retro_environment_callback(RETRO_ENVIRONMENT_SET_CORE_OPTIONS_DISPLAY, &option_display);
+    }
+
+    char controller_double_multitap_options[16][49] = {
+        "duckstation_Controller5.ForceAnalogOnReset",
+        "duckstation_Controller5.AnalogDPadInDigitalMode",
+        "duckstation_Controller5.AxisScale",
+        "duckstation_Controller5.VibrationBias",
+        "duckstation_Controller6.ForceAnalogOnReset",
+        "duckstation_Controller6.AnalogDPadInDigitalMode",
+        "duckstation_Controller6.AxisScale",
+        "duckstation_Controller6.VibrationBias",
+        "duckstation_Controller7.ForceAnalogOnReset",
+        "duckstation_Controller7.AnalogDPadInDigitalMode",
+        "duckstation_Controller7.AxisScale",
+        "duckstation_Controller7.VibrationBias",
+        "duckstation_Controller8.ForceAnalogOnReset",
+        "duckstation_Controller8.AnalogDPadInDigitalMode",
+        "duckstation_Controller8.AxisScale",
+        "duckstation_Controller8.VibrationBias"
+    };
+
+    if (show_multitap == 2)
+        option_display.visible = true;
+    else
+        option_display.visible = false;
+
+    for (i = 0; i < 16; i++)
+    {
+        option_display.key = controller_double_multitap_options[i];
+        g_retro_environment_callback(RETRO_ENVIRONMENT_SET_CORE_OPTIONS_DISPLAY, &option_display);
+    }
+  }
+
+}
+
+std::vector<std::string> LibretroHostInterface::GetSettingStringList(const char* section, const char* key)
+{
+  return {};
+}
+
+void LibretroHostInterface::UpdateSettings()
+{
+  Settings old_settings(std::move(g_settings));
+  LibretroSettingsInterface si;
+  LoadSettings(si);
+  ApplyGameSettings();
+  FixIncompatibleSettings(false);
+
+  if (System::IsValid())
+  {
+    if ((g_settings.gpu_resolution_scale != old_settings.gpu_resolution_scale || g_settings.gpu_downsample_mode != old_settings.gpu_downsample_mode) &&
+        g_settings.gpu_renderer != GPURenderer::Software)
+    {
+      ReportMessage("Resolution changed, updating system AV info...");
+
+      UpdateSystemAVInfo(true);
+
+      if (!g_settings.IsUsingSoftwareRenderer())
+      {
+        if (!m_hw_render_callback_valid)
+          RequestHardwareRendererContext();
+        else if (!m_using_hardware_renderer)
+          SwitchToHardwareRenderer();
+      }
+
+      // Don't let the base class mess with the GPU.
+      old_settings.gpu_resolution_scale = g_settings.gpu_resolution_scale;
+    }
+
+    if (g_settings.gpu_renderer != old_settings.gpu_renderer)
+    {
+      ReportFormattedMessage("Switch to %s renderer pending, please restart the core to apply.",
+                             Settings::GetRendererDisplayName(g_settings.gpu_renderer));
+      g_settings.gpu_renderer = old_settings.gpu_renderer;
+    }
+	
+    if (g_settings.memory_card_types[0] == MemoryCardType::Libretro && old_settings.memory_card_types[0] != MemoryCardType::Libretro)
+    {
+      ReportFormattedMessage("Setting memory card 1 to Save RAM mode will apply on core reload, to prevent save loss.");
+      g_settings.memory_card_types[0] = old_settings.memory_card_types[0];
+    }
+  }
+
+  CheckForSettingsChanges(old_settings);
+}
+
+void LibretroHostInterface::CheckForSettingsChanges(const Settings& old_settings)
+{
+  HostInterface::CheckForSettingsChanges(old_settings);
+
+  if (g_settings.display_aspect_ratio != old_settings.display_aspect_ratio)
+    UpdateGeometry();
+
+  if (g_settings.log_level != old_settings.log_level)
+    UpdateLogging();
+}
+
+void LibretroHostInterface::OnRunningGameChanged(const std::string& path, CDImage* image, const std::string& game_code,
+                                                 const std::string& game_title)
+{
+  Log_InfoPrintf("Running game changed: %s (%s)", System::GetRunningCode().c_str(), System::GetRunningTitle().c_str());
+  if (UpdateGameSettings())
+    UpdateSettings();
+}
+
+void LibretroHostInterface::OnSystemPerformanceCountersUpdated() {}
+
+void LibretroHostInterface::OnDisplayInvalidated() {}
+
+void LibretroHostInterface::InitRumbleInterface()
+{
+  m_rumble_interface_valid = g_retro_environment_callback(RETRO_ENVIRONMENT_GET_RUMBLE_INTERFACE, &m_rumble_interface);
+}
+
+void LibretroHostInterface::UpdateControllers()
+{
+  g_retro_input_poll_callback();
+
+  for (u32 i = 0; i < NUM_CONTROLLER_AND_CARD_PORTS; i++)
+  {
+    switch (g_settings.controller_types[i])
+    {
+      case ControllerType::None:
+        break;
+
+      case ControllerType::DigitalController:
+        UpdateControllersDigitalController(i);
+        break;
+
+      case ControllerType::AnalogController:
+        UpdateControllersAnalogController(i);
+        break;
+
+      case ControllerType::AnalogJoystick:
+        UpdateControllersAnalogJoystick(i);
+        break;
+
+      case ControllerType::NeGcon:
+        UpdateControllersNeGcon(i);
+        break;
+
+      case ControllerType::NamcoGunCon:
+        UpdateControllersNamcoGunCon(i);
+        break;
+
+      case ControllerType::PlayStationMouse:
+        UpdateControllersPlayStationMouse(i);
+        break;
+
+      default:
+        ReportFormattedError("Unhandled controller type '%s'.",
+                             Settings::GetControllerTypeDisplayName(g_settings.controller_types[i]));
+        break;
+    }
+  }
+}
+
+void LibretroHostInterface::UpdateControllersDigitalController(u32 index)
+{
+  DigitalController* controller = static_cast<DigitalController*>(System::GetController(index));
+  DebugAssert(controller);
+
+  static constexpr std::array<std::pair<DigitalController::Button, u32>, 14> mapping = {
+    {{DigitalController::Button::Left, RETRO_DEVICE_ID_JOYPAD_LEFT},
+     {DigitalController::Button::Right, RETRO_DEVICE_ID_JOYPAD_RIGHT},
+     {DigitalController::Button::Up, RETRO_DEVICE_ID_JOYPAD_UP},
+     {DigitalController::Button::Down, RETRO_DEVICE_ID_JOYPAD_DOWN},
+     {DigitalController::Button::Circle, RETRO_DEVICE_ID_JOYPAD_A},
+     {DigitalController::Button::Cross, RETRO_DEVICE_ID_JOYPAD_B},
+     {DigitalController::Button::Triangle, RETRO_DEVICE_ID_JOYPAD_X},
+     {DigitalController::Button::Square, RETRO_DEVICE_ID_JOYPAD_Y},
+     {DigitalController::Button::Start, RETRO_DEVICE_ID_JOYPAD_START},
+     {DigitalController::Button::Select, RETRO_DEVICE_ID_JOYPAD_SELECT},
+     {DigitalController::Button::L1, RETRO_DEVICE_ID_JOYPAD_L},
+     {DigitalController::Button::L2, RETRO_DEVICE_ID_JOYPAD_L2},
+     {DigitalController::Button::R1, RETRO_DEVICE_ID_JOYPAD_R},
+     {DigitalController::Button::R2, RETRO_DEVICE_ID_JOYPAD_R2}}};
+
+  if (m_supports_input_bitmasks)
+  {
+    const u16 active = g_retro_input_state_callback(index, RETRO_DEVICE_JOYPAD, 0, RETRO_DEVICE_ID_JOYPAD_MASK);
+    for (const auto& it : mapping)
+      controller->SetButtonState(it.first, (active & (static_cast<u16>(1u) << it.second)) != 0u);
+  }
+  else
+  {
+    for (const auto& it : mapping)
+    {
+      const int16_t state = g_retro_input_state_callback(index, RETRO_DEVICE_JOYPAD, 0, it.second);
+      controller->SetButtonState(it.first, state != 0);
+    }
+  }
+}
+
+void LibretroHostInterface::UpdateControllersAnalogController(u32 index)
+{
+  AnalogController* controller = static_cast<AnalogController*>(System::GetController(index));
+  DebugAssert(controller);
+
+  static constexpr std::array<std::pair<AnalogController::Button, u32>, 16> button_mapping = {
+    {{AnalogController::Button::Left, RETRO_DEVICE_ID_JOYPAD_LEFT},
+     {AnalogController::Button::Right, RETRO_DEVICE_ID_JOYPAD_RIGHT},
+     {AnalogController::Button::Up, RETRO_DEVICE_ID_JOYPAD_UP},
+     {AnalogController::Button::Down, RETRO_DEVICE_ID_JOYPAD_DOWN},
+     {AnalogController::Button::Circle, RETRO_DEVICE_ID_JOYPAD_A},
+     {AnalogController::Button::Cross, RETRO_DEVICE_ID_JOYPAD_B},
+     {AnalogController::Button::Triangle, RETRO_DEVICE_ID_JOYPAD_X},
+     {AnalogController::Button::Square, RETRO_DEVICE_ID_JOYPAD_Y},
+     {AnalogController::Button::Start, RETRO_DEVICE_ID_JOYPAD_START},
+     {AnalogController::Button::Select, RETRO_DEVICE_ID_JOYPAD_SELECT},
+     {AnalogController::Button::L1, RETRO_DEVICE_ID_JOYPAD_L},
+     {AnalogController::Button::L2, RETRO_DEVICE_ID_JOYPAD_L2},
+     {AnalogController::Button::L3, RETRO_DEVICE_ID_JOYPAD_L3},
+     {AnalogController::Button::R1, RETRO_DEVICE_ID_JOYPAD_R},
+     {AnalogController::Button::R2, RETRO_DEVICE_ID_JOYPAD_R2},
+     {AnalogController::Button::R3, RETRO_DEVICE_ID_JOYPAD_R3}}};
+
+  static constexpr std::array<std::pair<AnalogController::Axis, std::pair<u32, u32>>, 4> axis_mapping = {
+    {{AnalogController::Axis::LeftX, {RETRO_DEVICE_INDEX_ANALOG_LEFT, RETRO_DEVICE_ID_ANALOG_X}},
+     {AnalogController::Axis::LeftY, {RETRO_DEVICE_INDEX_ANALOG_LEFT, RETRO_DEVICE_ID_ANALOG_Y}},
+     {AnalogController::Axis::RightX, {RETRO_DEVICE_INDEX_ANALOG_RIGHT, RETRO_DEVICE_ID_ANALOG_X}},
+     {AnalogController::Axis::RightY, {RETRO_DEVICE_INDEX_ANALOG_RIGHT, RETRO_DEVICE_ID_ANALOG_Y}}}};
+
+  if (m_supports_input_bitmasks)
+  {
+    const u16 active = g_retro_input_state_callback(index, RETRO_DEVICE_JOYPAD, 0, RETRO_DEVICE_ID_JOYPAD_MASK);
+    for (const auto& it : button_mapping)
+      controller->SetButtonState(it.first, (active & (static_cast<u16>(1u) << it.second)) != 0u);
+  }
+  else
+  {
+    for (const auto& it : button_mapping)
+    {
+      const int16_t state = g_retro_input_state_callback(index, RETRO_DEVICE_JOYPAD, 0, it.second);
+      controller->SetButtonState(it.first, state != 0);
+    }
+  }
+
+  for (const auto& it : axis_mapping)
+  {
+    const int16_t state = g_retro_input_state_callback(index, RETRO_DEVICE_ANALOG, it.second.first, it.second.second);
+    controller->SetAxisState(static_cast<s32>(it.first), std::clamp(static_cast<float>(state) / 32767.0f, -1.0f, 1.0f));
+  }
+
+  if (m_rumble_interface_valid)
+  {
+    const u16 strong = static_cast<u16>(static_cast<u32>(controller->GetVibrationMotorStrength(0) * 65535.0f));
+    const u16 weak = static_cast<u16>(static_cast<u32>(controller->GetVibrationMotorStrength(1) * 65535.0f));
+    m_rumble_interface.set_rumble_state(index, RETRO_RUMBLE_STRONG, strong);
+    m_rumble_interface.set_rumble_state(index, RETRO_RUMBLE_WEAK, weak);
+  }
+
+  const u16 L1 = g_retro_input_state_callback(index, RETRO_DEVICE_JOYPAD, 0, RETRO_DEVICE_ID_JOYPAD_L);
+  const u16 R1 = g_retro_input_state_callback(index, RETRO_DEVICE_JOYPAD, 0, RETRO_DEVICE_ID_JOYPAD_R);
+  const u16 L3 = g_retro_input_state_callback(index, RETRO_DEVICE_JOYPAD, 0, RETRO_DEVICE_ID_JOYPAD_L3);
+  const u16 R3 = g_retro_input_state_callback(index, RETRO_DEVICE_JOYPAD, 0, RETRO_DEVICE_ID_JOYPAD_R3);
+
+  // Workaround for the fact it will otherwise spam the analog button.
+  if (L1 && R1 && L3 && R3 && analog_press == 0)
+  {
+    analog_press = 1;
+    controller->SetButtonState(AnalogController::Button::Analog, (L1 && R1 && L3 && R3));
+  }
+  if (!L1 || !R1 || !L3 || !R3)
+  {
+    analog_press = 0;
+  }
+}
+
+void LibretroHostInterface::UpdateControllersAnalogJoystick(u32 index)
+{
+  AnalogJoystick* controller = static_cast<AnalogJoystick*>(System::GetController(index));
+  DebugAssert(controller);
+
+  static constexpr std::array<std::pair<AnalogJoystick::Button, u32>, 16> button_mapping = {
+    {{AnalogJoystick::Button::Left, RETRO_DEVICE_ID_JOYPAD_LEFT},
+     {AnalogJoystick::Button::Right, RETRO_DEVICE_ID_JOYPAD_RIGHT},
+     {AnalogJoystick::Button::Up, RETRO_DEVICE_ID_JOYPAD_UP},
+     {AnalogJoystick::Button::Down, RETRO_DEVICE_ID_JOYPAD_DOWN},
+     {AnalogJoystick::Button::Circle, RETRO_DEVICE_ID_JOYPAD_A},
+     {AnalogJoystick::Button::Cross, RETRO_DEVICE_ID_JOYPAD_B},
+     {AnalogJoystick::Button::Triangle, RETRO_DEVICE_ID_JOYPAD_X},
+     {AnalogJoystick::Button::Square, RETRO_DEVICE_ID_JOYPAD_Y},
+     {AnalogJoystick::Button::Start, RETRO_DEVICE_ID_JOYPAD_START},
+     {AnalogJoystick::Button::Select, RETRO_DEVICE_ID_JOYPAD_SELECT},
+     {AnalogJoystick::Button::L1, RETRO_DEVICE_ID_JOYPAD_L},
+     {AnalogJoystick::Button::L2, RETRO_DEVICE_ID_JOYPAD_L2},
+     {AnalogJoystick::Button::L3, RETRO_DEVICE_ID_JOYPAD_L3},
+     {AnalogJoystick::Button::R1, RETRO_DEVICE_ID_JOYPAD_R},
+     {AnalogJoystick::Button::R2, RETRO_DEVICE_ID_JOYPAD_R2},
+     {AnalogJoystick::Button::R3, RETRO_DEVICE_ID_JOYPAD_R3}}};
+
+  static constexpr std::array<std::pair<AnalogJoystick::Axis, std::pair<u32, u32>>, 4> axis_mapping = {
+    {{AnalogJoystick::Axis::LeftX, {RETRO_DEVICE_INDEX_ANALOG_LEFT, RETRO_DEVICE_ID_ANALOG_X}},
+     {AnalogJoystick::Axis::LeftY, {RETRO_DEVICE_INDEX_ANALOG_LEFT, RETRO_DEVICE_ID_ANALOG_Y}},
+     {AnalogJoystick::Axis::RightX, {RETRO_DEVICE_INDEX_ANALOG_RIGHT, RETRO_DEVICE_ID_ANALOG_X}},
+     {AnalogJoystick::Axis::RightY, {RETRO_DEVICE_INDEX_ANALOG_RIGHT, RETRO_DEVICE_ID_ANALOG_Y}}}};
+
+  if (m_supports_input_bitmasks)
+  {
+    const u16 active = g_retro_input_state_callback(index, RETRO_DEVICE_JOYPAD, 0, RETRO_DEVICE_ID_JOYPAD_MASK);
+    for (const auto& it : button_mapping)
+      controller->SetButtonState(it.first, (active & (static_cast<u16>(1u) << it.second)) != 0u);
+  }
+  else
+  {
+    for (const auto& it : button_mapping)
+    {
+      const int16_t state = g_retro_input_state_callback(index, RETRO_DEVICE_JOYPAD, 0, it.second);
+      controller->SetButtonState(it.first, state != 0);
+    }
+  }
+
+  for (const auto& it : axis_mapping)
+  {
+    const int16_t state = g_retro_input_state_callback(index, RETRO_DEVICE_ANALOG, it.second.first, it.second.second);
+    controller->SetAxisState(static_cast<s32>(it.first), std::clamp(static_cast<float>(state) / 32767.0f, -1.0f, 1.0f));
+  }
+}
+
+void LibretroHostInterface::UpdateControllersNeGcon(u32 index)
+{
+  NeGcon* controller = static_cast<NeGcon*>(System::GetController(index));
+  DebugAssert(controller);
+
+  static constexpr std::array<std::pair<NeGcon::Button, u32>, 8> button_mapping = {
+    {{NeGcon::Button::Left, RETRO_DEVICE_ID_JOYPAD_LEFT},
+     {NeGcon::Button::Right, RETRO_DEVICE_ID_JOYPAD_RIGHT},
+     {NeGcon::Button::Up, RETRO_DEVICE_ID_JOYPAD_UP},
+     {NeGcon::Button::Down, RETRO_DEVICE_ID_JOYPAD_DOWN},
+     {NeGcon::Button::A, RETRO_DEVICE_ID_JOYPAD_A},
+     {NeGcon::Button::B, RETRO_DEVICE_ID_JOYPAD_X},
+     {NeGcon::Button::Start, RETRO_DEVICE_ID_JOYPAD_START},
+     {NeGcon::Button::R, RETRO_DEVICE_ID_JOYPAD_R}}};
+
+  static constexpr std::array<std::pair<NeGcon::Axis, std::pair<u32, u32>>, 4> axis_mapping = {
+    {{NeGcon::Axis::Steering, {RETRO_DEVICE_INDEX_ANALOG_LEFT, RETRO_DEVICE_ID_ANALOG_X}},
+     {NeGcon::Axis::I, {RETRO_DEVICE_INDEX_ANALOG_BUTTON, RETRO_DEVICE_ID_JOYPAD_B}},
+     {NeGcon::Axis::II, {RETRO_DEVICE_INDEX_ANALOG_BUTTON, RETRO_DEVICE_ID_JOYPAD_Y}},
+     {NeGcon::Axis::L, {RETRO_DEVICE_INDEX_ANALOG_BUTTON, RETRO_DEVICE_ID_JOYPAD_L}}}};
+
+  if (m_supports_input_bitmasks)
+  {
+    const u16 active = g_retro_input_state_callback(index, RETRO_DEVICE_JOYPAD, 0, RETRO_DEVICE_ID_JOYPAD_MASK);
+    for (const auto& it : button_mapping)
+      controller->SetButtonState(it.first, (active & (static_cast<u16>(1u) << it.second)) != 0u);
+  }
+  else
+  {
+    for (const auto& it : button_mapping)
+    {
+      const int16_t state = g_retro_input_state_callback(index, RETRO_DEVICE_JOYPAD, 0, it.second);
+      controller->SetButtonState(it.first, state != 0);
+    }
+  }
+
+  for (const auto& it : axis_mapping)
+  {
+    int16_t state = g_retro_input_state_callback(index, RETRO_DEVICE_ANALOG, it.second.first, it.second.second);
+    if (state == 0 && it.second.second == RETRO_DEVICE_ID_JOYPAD_B)
+    {
+        state = g_retro_input_state_callback(index, RETRO_DEVICE_ANALOG, it.second.first, RETRO_DEVICE_ID_JOYPAD_R2);
+    }
+    else if (state == 0 && it.second.second == RETRO_DEVICE_ID_JOYPAD_Y)
+    {
+        state = g_retro_input_state_callback(index, RETRO_DEVICE_ANALOG, it.second.first, RETRO_DEVICE_ID_JOYPAD_L2);
+    }
+
+    controller->SetAxisState(static_cast<s32>(it.first), std::clamp(static_cast<float>(state) / 32767.0f, -1.0f, 1.0f));
+  }
+
+}
+
+void LibretroHostInterface::UpdateControllersNamcoGunCon(u32 index)
+{
+  NamcoGunCon* controller = static_cast<NamcoGunCon*>(System::GetController(index));
+  DebugAssert(controller);
+
+  static constexpr std::array<std::pair<NamcoGunCon::Button, u32>, 4> button_mapping = {
+    {{NamcoGunCon::Button::Trigger, RETRO_DEVICE_ID_LIGHTGUN_TRIGGER},
+     {NamcoGunCon::Button::ShootOffscreen, RETRO_DEVICE_ID_LIGHTGUN_RELOAD},
+     {NamcoGunCon::Button::A, RETRO_DEVICE_ID_LIGHTGUN_AUX_A},
+     {NamcoGunCon::Button::B, RETRO_DEVICE_ID_LIGHTGUN_AUX_B}}};
+
+  for (const auto& it : button_mapping)
+  {
+    const int16_t state = g_retro_input_state_callback(index, RETRO_DEVICE_LIGHTGUN, 0, it.second);
+    controller->SetButtonState(it.first, state != 0);
+  }
+
+  // Mouse range is between -32767 & 32767
+  const int16_t gun_x = g_retro_input_state_callback(index, RETRO_DEVICE_LIGHTGUN, 0, RETRO_DEVICE_ID_LIGHTGUN_SCREEN_X);
+  const int16_t gun_y = g_retro_input_state_callback(index, RETRO_DEVICE_LIGHTGUN, 0, RETRO_DEVICE_ID_LIGHTGUN_SCREEN_Y);
+  const s32 pos_x = (g_retro_input_state_callback(index, RETRO_DEVICE_LIGHTGUN, 0, RETRO_DEVICE_ID_LIGHTGUN_IS_OFFSCREEN) ? 0 : (((static_cast<s32>(gun_x) + 0x7FFF) * m_display->GetWindowWidth()) / 0xFFFF));
+  const s32 pos_y = (g_retro_input_state_callback(index, RETRO_DEVICE_LIGHTGUN, 0, RETRO_DEVICE_ID_LIGHTGUN_IS_OFFSCREEN) ? 0 : (((static_cast<s32>(gun_y) + 0x7FFF) * m_display->GetWindowHeight()) / 0xFFFF));
+
+  m_display->SetMousePosition(pos_x, pos_y);
+
+}
+
+void LibretroHostInterface::UpdateControllersPlayStationMouse(u32 index)
+{
+  PlayStationMouse* controller = static_cast<PlayStationMouse*>(System::GetController(index));
+  DebugAssert(controller);
+
+  static constexpr std::array<std::pair<PlayStationMouse::Button, u32>, 2> button_mapping = {
+    {{PlayStationMouse::Button::Left, RETRO_DEVICE_ID_MOUSE_LEFT},
+     {PlayStationMouse::Button::Right, RETRO_DEVICE_ID_MOUSE_RIGHT}}};
+
+  for (const auto& it : button_mapping)
+  {
+    const int16_t state = g_retro_input_state_callback(index, RETRO_DEVICE_MOUSE, 0, it.second);
+    controller->SetButtonState(it.first, state != 0);
+  }
+
+  const int16_t mouse_x = g_retro_input_state_callback(index, RETRO_DEVICE_MOUSE, 0, RETRO_DEVICE_ID_MOUSE_X);
+  const int16_t mouse_y = g_retro_input_state_callback(index, RETRO_DEVICE_MOUSE, 0, RETRO_DEVICE_ID_MOUSE_Y);
+  const s32 pos_x = (m_display->GetMousePositionX() + mouse_x);
+  const s32 pos_y = (m_display->GetMousePositionY() + mouse_y);
+
+  m_display->SetMousePosition(pos_x, pos_y);
+
+}
+
+static std::optional<GPURenderer> RetroHwContextToRenderer(retro_hw_context_type type)
+{
+  switch (type)
+  {
+    case RETRO_HW_CONTEXT_OPENGL:
+    case RETRO_HW_CONTEXT_OPENGL_CORE:
+    case RETRO_HW_CONTEXT_OPENGLES3:
+    case RETRO_HW_CONTEXT_OPENGLES_VERSION:
+      return GPURenderer::HardwareOpenGL;
+
+    case RETRO_HW_CONTEXT_VULKAN:
+      return GPURenderer::HardwareVulkan;
+
+#ifdef WIN32
+    case RETRO_HW_CONTEXT_DIRECT3D:
+      return GPURenderer::HardwareD3D11;
+#endif
+
+    default:
+      return std::nullopt;
+  }
+}
+
+static std::optional<GPURenderer> RenderAPIToRenderer(HostDisplay::RenderAPI api)
+{
+  switch (api)
+  {
+    case HostDisplay::RenderAPI::OpenGL:
+    case HostDisplay::RenderAPI::OpenGLES:
+      return GPURenderer::HardwareOpenGL;
+
+    case HostDisplay::RenderAPI::Vulkan:
+      return GPURenderer::HardwareVulkan;
+
+#ifdef WIN32
+    case HostDisplay::RenderAPI::D3D11:
+      return GPURenderer::HardwareD3D11;
+#endif
+
+    default:
+      return std::nullopt;
+  }
+}
+
+bool LibretroHostInterface::RequestHardwareRendererContext()
+{
+  retro_variable renderer_variable{"duckstation_GPU.Renderer",
+                                   Settings::GetRendererName(Settings::DEFAULT_GPU_RENDERER)};
+  if (!g_retro_environment_callback(RETRO_ENVIRONMENT_GET_VARIABLE, &renderer_variable) || !renderer_variable.value)
+    renderer_variable.value = Settings::GetRendererName(Settings::DEFAULT_GPU_RENDERER);
+
+  GPURenderer renderer = Settings::ParseRendererName(renderer_variable.value).value_or(Settings::DEFAULT_GPU_RENDERER);
+  unsigned preferred_renderer = 0;
+  g_retro_environment_callback(RETRO_ENVIRONMENT_GET_PREFERRED_HW_RENDER, &preferred_renderer);
+  if (std::strcmp(renderer_variable.value, "Auto") == 0)
+  {
+    std::optional<GPURenderer> preferred_gpu_renderer =
+      RetroHwContextToRenderer(static_cast<retro_hw_context_type>(preferred_renderer));
+    if (preferred_gpu_renderer.has_value())
+      renderer = preferred_gpu_renderer.value();
+  }
+
+  Log_InfoPrintf("Renderer = %s", Settings::GetRendererName(renderer));
+  if (renderer == GPURenderer::Software)
+  {
+    m_hw_render_callback_valid = false;
+    return false;
+  }
+
+  Log_InfoPrintf("Requesting hardware renderer context for %s", Settings::GetRendererName(renderer));
+
+  m_hw_render_callback = {};
+  m_hw_render_callback.context_reset = HardwareRendererContextReset;
+  m_hw_render_callback.context_destroy = HardwareRendererContextDestroy;
+
+  switch (renderer)
+  {
+#ifdef WIN32
+    case GPURenderer::HardwareD3D11:
+      m_hw_render_callback_valid = LibretroD3D11HostDisplay::RequestHardwareRendererContext(&m_hw_render_callback);
+      break;
+#endif
+
+    case GPURenderer::HardwareVulkan:
+      m_hw_render_callback_valid = LibretroVulkanHostDisplay::RequestHardwareRendererContext(&m_hw_render_callback);
+      break;
+
+    case GPURenderer::HardwareOpenGL:
+    {
+      const bool prefer_gles =
+        (preferred_renderer == RETRO_HW_CONTEXT_OPENGLES2 || preferred_renderer == RETRO_HW_CONTEXT_OPENGLES_VERSION);
+      m_hw_render_callback_valid =
+        LibretroOpenGLHostDisplay::RequestHardwareRendererContext(&m_hw_render_callback, prefer_gles);
+    }
+    break;
+
+    default:
+      Log_ErrorPrintf("Unhandled renderer %s", Settings::GetRendererName(renderer));
+      m_hw_render_callback_valid = false;
+      break;
+  }
+
+  return m_hw_render_callback_valid;
+}
+
+void LibretroHostInterface::HardwareRendererContextReset()
+{
+  Log_InfoPrintf("Hardware context reset, type = %u",
+                 static_cast<unsigned>(g_libretro_host_interface.m_hw_render_callback.context_type));
+
+  g_libretro_host_interface.m_hw_render_callback_valid = true;
+  g_libretro_host_interface.SwitchToHardwareRenderer();
+}
+
+void LibretroHostInterface::SwitchToHardwareRenderer()
+{
+  struct retro_system_av_info avi;
+  g_libretro_host_interface.GetSystemAVInfo(&avi, true);
+
+  WindowInfo wi;
+  wi.type = WindowInfo::Type::Libretro;
+  wi.display_connection = &g_libretro_host_interface.m_hw_render_callback;
+  wi.surface_width = avi.geometry.base_width;
+  wi.surface_height = avi.geometry.base_height;
+  wi.surface_scale = 1.0f;
+
+  // use the existing device if we just resized the window
+  std::optional<GPURenderer> renderer;
+  std::unique_ptr<HostDisplay> display = std::move(m_hw_render_display);
+  if (display)
+  {
+    Log_InfoPrintf("Using existing hardware display");
+    renderer = RenderAPIToRenderer(display->GetRenderAPI());
+    if (!display->ChangeRenderWindow(wi) || !display->CreateResources())
+    {
+      Log_ErrorPrintf("Failed to recreate resources after reinit");
+      display->DestroyRenderDevice();
+      display.reset();
+    }
+  }
+
+  if (!display)
+  {
+    renderer = RetroHwContextToRenderer(m_hw_render_callback.context_type);
+    if (!renderer.has_value())
+    {
+      Log_ErrorPrintf("Unknown context type %u", static_cast<unsigned>(m_hw_render_callback.context_type));
+      return;
+    }
+
+    switch (renderer.value())
+    {
+      case GPURenderer::HardwareOpenGL:
+        display = std::make_unique<LibretroOpenGLHostDisplay>();
+        break;
+
+      case GPURenderer::HardwareVulkan:
+        display = std::make_unique<LibretroVulkanHostDisplay>();
+        break;
+
+#ifdef WIN32
+      case GPURenderer::HardwareD3D11:
+        display = std::make_unique<LibretroD3D11HostDisplay>();
+        break;
+#endif
+
+      default:
+        Log_ErrorPrintf("Unhandled renderer '%s'", Settings::GetRendererName(renderer.value()));
+        return;
+    }
+    if (!display || !display->CreateRenderDevice(wi, {}, g_settings.gpu_use_debug_device, false) ||
+        !display->InitializeRenderDevice(GetShaderCacheBasePath(), g_settings.gpu_use_debug_device, false))
+    {
+      Log_ErrorPrintf("Failed to create hardware host display");
+      return;
+    }
+  }
+
+  std::swap(display, g_libretro_host_interface.m_display);
+  System::RecreateGPU(renderer.value());
+  display->DestroyRenderDevice();
+  m_using_hardware_renderer = true;
+}
+
+void LibretroHostInterface::HardwareRendererContextDestroy()
+{
+  Log_InfoPrintf("Hardware context destroyed");
+
+  // switch back to software
+  if (g_libretro_host_interface.m_using_hardware_renderer)
+    g_libretro_host_interface.SwitchToSoftwareRenderer();
+
+  if (g_libretro_host_interface.m_hw_render_display)
+  {
+    g_libretro_host_interface.m_hw_render_display->DestroyRenderDevice();
+    g_libretro_host_interface.m_hw_render_display.reset();
+  }
+
+  g_libretro_host_interface.m_hw_render_callback_valid = false;
+}
+
+void LibretroHostInterface::SwitchToSoftwareRenderer()
+{
+  Log_InfoPrintf("Switching to software renderer");
+
+  // keep the hw renderer around in case we need it later
+  // but keep it active until we've recreated the GPU so we can save the state
+  std::unique_ptr<HostDisplay> save_display;
+  if (m_using_hardware_renderer)
+  {
+    save_display = std::move(m_display);
+    m_using_hardware_renderer = false;
+  }
+
+  m_display = std::make_unique<LibretroHostDisplay>();
+  System::RecreateGPU(GPURenderer::Software, false);
+
+  if (save_display)
+  {
+    save_display->DestroyResources();
+    m_hw_render_display = std::move(save_display);
+  }
+}
+
+bool LibretroHostInterface::DiskControlSetEjectState(bool ejected)
+{
+  if (System::IsShutdown())
+    return false;
+
+  if (ejected)
+  {
+    if (!System::HasMedia())
+      return false;
+
+    System::RemoveMedia();
+  }
+  else
+  {
+    if (System::HasMedia())
+      return false;
+
+    if (P_THIS->m_disk_control_info.has_sub_images)
+    {
+      if (!System::InsertMedia(P_THIS->m_disk_control_info.sub_images_parent_path.c_str()))
+        return false;
+
+      if (!System::SwitchMediaSubImage(P_THIS->m_disk_control_info.image_index))
+        return false;
+    }
+    else if (!System::InsertMedia(P_THIS->m_disk_control_info.image_paths[P_THIS->m_disk_control_info.image_index].c_str()))
+      return false;
+  }
+
+  return true;
+}
+
+bool LibretroHostInterface::DiskControlGetEjectState()
+{
+  if (System::IsShutdown())
+    return false;
+
+  return !System::HasMedia();
+}
+
+unsigned LibretroHostInterface::DiskControlGetImageIndex()
+{
+  return (unsigned)P_THIS->m_disk_control_info.image_index;
+}
+
+bool LibretroHostInterface::DiskControlSetImageIndex(unsigned index)
+{
+  if (System::IsShutdown() ||
+      System::HasMedia() ||
+      (index >= P_THIS->m_disk_control_info.image_count))
+    return false;
+
+  P_THIS->m_disk_control_info.image_index = (u32)index;
+  return true;
+}
+
+unsigned LibretroHostInterface::DiskControlGetNumImages()
+{
+  return (unsigned)P_THIS->m_disk_control_info.image_count;
+}
+
+bool LibretroHostInterface::DiskControlReplaceImageIndex(unsigned index, const retro_game_info* info)
+{
+#ifdef _MSC_VER
+#define CASE_COMPARE _stricmp
+#else
+#define CASE_COMPARE strcasecmp
+#endif
+
+  if (System::IsShutdown() ||
+      System::HasMedia() ||
+      (index >= P_THIS->m_disk_control_info.image_count))
+    return false;
+
+  /* Multi-image content cannot be modified */
+  if (P_THIS->m_disk_control_info.has_sub_images)
+    return false;
+
+  if (!info)
+  {
+    /* Remove specified image */
+    P_THIS->m_disk_control_info.image_count--;
+
+    if (index < P_THIS->m_disk_control_info.image_index)
+      P_THIS->m_disk_control_info.image_index--;
+
+    P_THIS->m_disk_control_info.image_paths.erase(
+        P_THIS->m_disk_control_info.image_paths.begin() + index);
+    P_THIS->m_disk_control_info.image_labels.erase(
+        P_THIS->m_disk_control_info.image_labels.begin() + index);
+    return true;
+  }
+
+  if (!info->path)
+    return false;
+
+  const char *extension = std::strrchr(info->path, '.');
+  if (!extension)
+    return false;
+
+  /* We cannot 'insert' an M3U file
+   * > New image must be 'single disk' content */
+  if (CASE_COMPARE(extension, ".m3u") == 0)
+    return false;
+
+  const std::string_view image_label = FileSystem::GetFileTitleFromPath(info->path);
+  if (image_label.empty())
+    return false;
+
+  P_THIS->m_disk_control_info.image_paths[index]  = info->path;
+  P_THIS->m_disk_control_info.image_labels[index] = std::string(image_label);
+  return true;
+}
+
+bool LibretroHostInterface::DiskControlAddImageIndex()
+{
+  if (System::IsShutdown())
+    return false;
+
+  /* Multi-image content cannot be modified */
+  if (P_THIS->m_disk_control_info.has_sub_images)
+    return false;
+
+  P_THIS->m_disk_control_info.image_count++;
+  P_THIS->m_disk_control_info.image_paths.push_back("");
+  P_THIS->m_disk_control_info.image_labels.push_back("");
+  return true;
+}
+
+bool LibretroHostInterface::DiskControlSetInitialImage(unsigned index, const char* path)
+{
+  /* Note: 'path' is ignored, since we cannot
+   * determine the actual set path until after
+   * content is loaded by the core emulation
+   * code (at which point it is too late to
+   * compare it with the value supplied here) */
+  P_THIS->m_disk_control_info.initial_image_index = index;
+  return true;
+}
+
+bool LibretroHostInterface::DiskControlGetImagePath(unsigned index, char* path, size_t len)
+{
+  if ((index >= P_THIS->m_disk_control_info.image_count) ||
+      (index >= P_THIS->m_disk_control_info.image_paths.size()) ||
+      P_THIS->m_disk_control_info.image_paths[index].empty())
+    return false;
+
+  StringUtil::Strlcpy(path, P_THIS->m_disk_control_info.image_paths[index].c_str(), len);
+  return true;
+}
+
+bool LibretroHostInterface::DiskControlGetImageLabel(unsigned index, char* label, size_t len)
+{
+  if ((index >= P_THIS->m_disk_control_info.image_count) ||
+      (index >= P_THIS->m_disk_control_info.image_labels.size()) ||
+      P_THIS->m_disk_control_info.image_labels[index].empty())
+    return false;
+
+  StringUtil::Strlcpy(label, P_THIS->m_disk_control_info.image_labels[index].c_str(), len);
+  return true;
+}
+
+void LibretroHostInterface::InitDiskControlInterface()
+{
+  unsigned version = 0;
+  if (g_retro_environment_callback(RETRO_ENVIRONMENT_GET_DISK_CONTROL_INTERFACE_VERSION, &version) && version >= 1)
+  {
+    retro_disk_control_ext_callback ext_cb = {
+      &LibretroHostInterface::DiskControlSetEjectState, &LibretroHostInterface::DiskControlGetEjectState,
+      &LibretroHostInterface::DiskControlGetImageIndex, &LibretroHostInterface::DiskControlSetImageIndex,
+      &LibretroHostInterface::DiskControlGetNumImages,  &LibretroHostInterface::DiskControlReplaceImageIndex,
+      &LibretroHostInterface::DiskControlAddImageIndex, &LibretroHostInterface::DiskControlSetInitialImage,
+      &LibretroHostInterface::DiskControlGetImagePath,  &LibretroHostInterface::DiskControlGetImageLabel};
+    if (g_retro_environment_callback(RETRO_ENVIRONMENT_SET_DISK_CONTROL_EXT_INTERFACE, &ext_cb))
+      return;
+  }
+
+  retro_disk_control_callback cb = {
+    &LibretroHostInterface::DiskControlSetEjectState, &LibretroHostInterface::DiskControlGetEjectState,
+    &LibretroHostInterface::DiskControlGetImageIndex, &LibretroHostInterface::DiskControlSetImageIndex,
+    &LibretroHostInterface::DiskControlGetNumImages,  &LibretroHostInterface::DiskControlReplaceImageIndex,
+    &LibretroHostInterface::DiskControlAddImageIndex};
+  if (!g_retro_environment_callback(RETRO_ENVIRONMENT_SET_DISK_CONTROL_INTERFACE, &cb))
+    Log_WarningPrint("Failed to set disk control interface");
+}
diff -Naur duckstation-51041e47f70123eda41d999701f5651830a0a95e.orig/src/duckstation-libretro/libretro_host_interface.h duckstation-51041e47f70123eda41d999701f5651830a0a95e/src/duckstation-libretro/libretro_host_interface.h
--- duckstation-51041e47f70123eda41d999701f5651830a0a95e.orig/src/duckstation-libretro/libretro_host_interface.h	1970-01-01 01:00:00.000000000 +0100
+++ duckstation-51041e47f70123eda41d999701f5651830a0a95e/src/duckstation-libretro/libretro_host_interface.h	2022-01-12 18:30:18.000000000 +0000
@@ -0,0 +1,157 @@
+#pragma once
+#include "core/host_interface.h"
+#include "core/system.h"
+#include "libretro.h"
+#include <limits>
+#include <optional>
+#include <memory>
+#include <vector>
+#include <string>
+
+namespace GameSettings
+{
+struct Entry;
+}
+
+class LibretroHostInterface final : public HostInterface
+{
+public:
+
+  struct DiskControlInfo
+  {
+    bool has_sub_images;
+    u32 initial_image_index;
+    u32 image_index;
+    u32 image_count;
+    std::string sub_images_parent_path;
+    std::vector<std::string> image_paths;
+    std::vector<std::string> image_labels;
+  };
+
+  LibretroHostInterface();
+  ~LibretroHostInterface() override;
+
+  ALWAYS_INLINE u32 GetResolutionScale() const { return (g_settings.gpu_downsample_mode == GPUDownsampleMode::Box) ? 1u : g_settings.gpu_resolution_scale; }
+
+  bool Initialize() override;
+  void Shutdown() override;
+
+  void ReportError(const char* message) override;
+  void ReportMessage(const char* message) override;
+  bool ConfirmMessage(const char* message) override;
+  void AddOSDMessage(std::string message, float duration = 2.0f) override;
+  void AddKeyedOSDMessage(std::string key, std::string message, float duration = 2.0f) override;
+  void RemoveKeyedOSDMessage(std::string key) override;
+  void DisplayLoadingScreen(const char* message, int progress_min = -1, int progress_max = -1,
+                            int progress_value = -1) override;
+
+  void GetGameInfo(const char* path, CDImage* image, std::string* code, std::string* title) override;
+  std::string GetSharedMemoryCardPath(u32 slot) const override;
+  std::string GetGameMemoryCardPath(const char* game_code, u32 slot) const override;
+  std::string GetShaderCacheBasePath() const override;
+  std::string GetStringSettingValue(const char* section, const char* key, const char* default_value = "") override;
+  std::vector<std::string> GetSettingStringList(const char* section, const char* key) override;
+  std::string GetBIOSDirectory() override;
+  std::unique_ptr<ByteStream> OpenPackageFile(const char* path, u32 flags) override;
+
+  bool UpdateSystemAVInfo(bool use_resolution_scale);
+  
+  void OnSystemPerformanceCountersUpdated() override;
+  void OnDisplayInvalidated() override;
+
+  // Called by frontend
+  void retro_set_environment();
+  void retro_get_system_av_info(struct retro_system_av_info* info);
+  bool retro_load_game(const struct retro_game_info* game);
+  void retro_set_controller_port_device(unsigned port, unsigned device);
+  void retro_run_frame();
+  unsigned retro_get_region();
+  size_t retro_serialize_size();
+  bool retro_serialize(void* data, size_t size);
+  bool retro_unserialize(const void* data, size_t size);
+  void* retro_get_memory_data(unsigned id);
+  size_t retro_get_memory_size(unsigned id);
+  void retro_cheat_reset();
+  void retro_cheat_set(unsigned index, bool enabled, const char* code);
+
+protected:
+  bool AcquireHostDisplay() override;
+  void ReleaseHostDisplay() override;
+  std::unique_ptr<AudioStream> CreateAudioStream(AudioBackend backend) override;
+  void OnSystemCreated() override;
+  void OnSystemPaused(bool paused) override;
+  void OnSystemDestroyed() override;
+  void CheckForSettingsChanges(const Settings& old_settings) override;
+  void OnRunningGameChanged(const std::string& path, CDImage* image, const std::string& game_code,
+                            const std::string& game_title) override;
+  void OnControllerTypeChanged(u32 slot) override;
+
+  void SetMouseMode(bool relative, bool hide_cursor) override;
+
+private:
+  bool HasCoreVariablesChanged();
+  void InitInterfaces();
+  void InitLogging();
+  void InitDiskControlInterface();
+  void InitRumbleInterface();
+
+  void LoadSettings(SettingsInterface& si) override;
+  void UpdateSettings();
+  void UpdateControllers();
+  void UpdateControllersDigitalController(u32 index);
+  void UpdateControllersAnalogController(u32 index);
+  void UpdateControllersAnalogJoystick(u32 index);
+  void UpdateControllersNeGcon(u32 index);
+  void UpdateControllersNamcoGunCon(u32 index);
+  void UpdateControllersPlayStationMouse(u32 index);
+  void GetSystemAVInfo(struct retro_system_av_info* info, bool use_resolution_scale);
+  void UpdateGeometry();
+  void UpdateLogging();
+
+  bool UpdateGameSettings();
+  void ApplyGameSettings();
+
+  // Hardware renderer setup.
+  bool RequestHardwareRendererContext();
+  void SwitchToHardwareRenderer();
+  void SwitchToSoftwareRenderer();
+
+  static void HardwareRendererContextReset();
+  static void HardwareRendererContextDestroy();
+
+  // Disk control callbacks
+  static bool RETRO_CALLCONV DiskControlSetEjectState(bool ejected);
+  static bool RETRO_CALLCONV DiskControlGetEjectState();
+  static unsigned RETRO_CALLCONV DiskControlGetImageIndex();
+  static bool RETRO_CALLCONV DiskControlSetImageIndex(unsigned index);
+  static unsigned RETRO_CALLCONV DiskControlGetNumImages();
+  static bool RETRO_CALLCONV DiskControlReplaceImageIndex(unsigned index, const retro_game_info* info);
+  static bool RETRO_CALLCONV DiskControlAddImageIndex();
+  static bool RETRO_CALLCONV DiskControlSetInitialImage(unsigned index, const char* path);
+  static bool RETRO_CALLCONV DiskControlGetImagePath(unsigned index, char* path, size_t len);
+  static bool RETRO_CALLCONV DiskControlGetImageLabel(unsigned index, char* label, size_t len);
+
+  std::unique_ptr<GameSettings::Entry> m_game_settings;
+  float m_last_aspect_ratio = 4.0f / 3.0f;
+
+  retro_hw_render_callback m_hw_render_callback = {};
+  std::unique_ptr<HostDisplay> m_hw_render_display;
+  bool m_hw_render_callback_valid = false;
+  bool m_using_hardware_renderer = false;
+
+  retro_rumble_interface m_rumble_interface = {};
+  bool m_rumble_interface_valid = false;
+  bool m_supports_input_bitmasks = false;
+
+  DiskControlInfo m_disk_control_info = {};
+};
+
+extern LibretroHostInterface g_libretro_host_interface;
+
+// libretro callbacks
+extern retro_environment_t g_retro_environment_callback;
+extern retro_video_refresh_t g_retro_video_refresh_callback;
+extern retro_audio_sample_t g_retro_audio_sample_callback;
+extern retro_audio_sample_batch_t g_retro_audio_sample_batch_callback;
+extern retro_input_poll_t g_retro_input_poll_callback;
+extern retro_input_state_t g_retro_input_state_callback;
diff -Naur duckstation-51041e47f70123eda41d999701f5651830a0a95e.orig/src/duckstation-libretro/libretro_opengl_host_display.cpp duckstation-51041e47f70123eda41d999701f5651830a0a95e/src/duckstation-libretro/libretro_opengl_host_display.cpp
--- duckstation-51041e47f70123eda41d999701f5651830a0a95e.orig/src/duckstation-libretro/libretro_opengl_host_display.cpp	1970-01-01 01:00:00.000000000 +0100
+++ duckstation-51041e47f70123eda41d999701f5651830a0a95e/src/duckstation-libretro/libretro_opengl_host_display.cpp	2022-01-12 18:30:18.000000000 +0000
@@ -0,0 +1,681 @@
+#include "libretro_opengl_host_display.h"
+#include "common/align.h"
+#include "common/assert.h"
+#include "common/log.h"
+#include "core/gpu.h"
+#include "libretro.h"
+#include "libretro_host_interface.h"
+#include <array>
+#include <tuple>
+Log_SetChannel(LibretroOpenGLHostDisplay);
+
+class LibretroOpenGLHostDisplayTexture : public HostDisplayTexture
+{
+public:
+  LibretroOpenGLHostDisplayTexture(GL::Texture texture, HostDisplayPixelFormat format)
+    : m_texture(std::move(texture)), m_format(format)
+  {
+  }
+  ~LibretroOpenGLHostDisplayTexture() override = default;
+
+  void* GetHandle() const override { return reinterpret_cast<void*>(static_cast<uintptr_t>(m_texture.GetGLId())); }
+  u32 GetWidth() const override { return m_texture.GetWidth(); }
+  u32 GetHeight() const override { return m_texture.GetHeight(); }
+  u32 GetLayers() const override { return 1; }
+  u32 GetLevels() const override { return 1; }
+  u32 GetSamples() const override { return m_texture.GetSamples(); }
+  HostDisplayPixelFormat GetFormat() const override { return m_format; }
+
+  GLuint GetGLID() const { return m_texture.GetGLId(); }
+
+private:
+  GL::Texture m_texture;
+  HostDisplayPixelFormat m_format;
+};
+
+LibretroOpenGLHostDisplay::LibretroOpenGLHostDisplay() = default;
+
+LibretroOpenGLHostDisplay::~LibretroOpenGLHostDisplay() = default;
+
+HostDisplay::RenderAPI LibretroOpenGLHostDisplay::GetRenderAPI() const
+{
+  return m_is_gles ? HostDisplay::RenderAPI::OpenGLES : HostDisplay::RenderAPI::OpenGL;
+}
+
+void* LibretroOpenGLHostDisplay::GetRenderDevice() const
+{
+  return nullptr;
+}
+
+void* LibretroOpenGLHostDisplay::GetRenderContext() const
+{
+  return nullptr;
+}
+
+static constexpr std::array<std::tuple<GLenum, GLenum, GLenum>, static_cast<u32>(HostDisplayPixelFormat::Count)>
+  s_display_pixel_format_mapping = {{
+    {},                                                  // Unknown
+    {GL_RGBA8, GL_RGBA, GL_UNSIGNED_BYTE},               // RGBA8
+    {GL_RGBA8, GL_BGRA, GL_UNSIGNED_BYTE},               // BGRA8
+    {GL_RGB565, GL_RGB, GL_UNSIGNED_SHORT_5_6_5},        // RGB565
+    {GL_RGB5_A1, GL_BGRA, GL_UNSIGNED_SHORT_1_5_5_5_REV} // RGBA5551
+  }};
+
+std::unique_ptr<HostDisplayTexture> LibretroOpenGLHostDisplay::CreateTexture(u32 width, u32 height, u32 layers,
+                                                                             u32 levels, u32 samples,
+                                                                             HostDisplayPixelFormat format,
+                                                                             const void* data, u32 data_stride,
+                                                                             bool dynamic /* = false */)
+{
+  if (layers != 1 || levels != 1)
+    return {};
+
+  const auto [gl_internal_format, gl_format, gl_type] = s_display_pixel_format_mapping[static_cast<u32>(format)];
+
+  // TODO: Set pack width
+  Assert(!data || data_stride == (width * sizeof(u32)));
+
+  GL::Texture tex;
+  if (!tex.Create(width, height, samples, gl_internal_format, gl_format, gl_type, data, data_stride))
+    return {};
+
+  return std::make_unique<LibretroOpenGLHostDisplayTexture>(std::move(tex), format);
+}
+
+void LibretroOpenGLHostDisplay::UpdateTexture(HostDisplayTexture* texture, u32 x, u32 y, u32 width, u32 height,
+                                              const void* texture_data, u32 texture_data_stride)
+{
+  LibretroOpenGLHostDisplayTexture* tex = static_cast<LibretroOpenGLHostDisplayTexture*>(texture);
+  const auto [gl_internal_format, gl_format, gl_type] =
+    s_display_pixel_format_mapping[static_cast<u32>(texture->GetFormat())];
+  GLint alignment;
+  if (texture_data_stride & 1)
+    alignment = 1;
+  else if (texture_data_stride & 2)
+    alignment = 2;
+  else
+    alignment = 4;
+
+  GLint old_texture_binding = 0, old_alignment = 0, old_row_length = 0;
+  glGetIntegerv(GL_TEXTURE_BINDING_2D, &old_texture_binding);
+  glBindTexture(GL_TEXTURE_2D, tex->GetGLID());
+
+  glGetIntegerv(GL_UNPACK_ALIGNMENT, &old_alignment);
+  glPixelStorei(GL_UNPACK_ALIGNMENT, alignment);
+
+  glGetIntegerv(GL_UNPACK_ROW_LENGTH, &old_row_length);
+  glPixelStorei(GL_UNPACK_ROW_LENGTH, texture_data_stride / GetDisplayPixelFormatSize(texture->GetFormat()));
+
+  glTexSubImage2D(GL_TEXTURE_2D, 0, x, y, width, height, gl_format, gl_type, texture_data);
+
+  glPixelStorei(GL_UNPACK_ROW_LENGTH, old_row_length);
+
+  glPixelStorei(GL_UNPACK_ALIGNMENT, old_alignment);
+  glBindTexture(GL_TEXTURE_2D, old_texture_binding);
+}
+
+bool LibretroOpenGLHostDisplay::DownloadTexture(const void* texture_handle, HostDisplayPixelFormat texture_format,
+                                                u32 x, u32 y, u32 width, u32 height, void* out_data,
+                                                u32 out_data_stride)
+{
+  GLint alignment;
+  if (out_data_stride & 1)
+    alignment = 1;
+  else if (out_data_stride & 2)
+    alignment = 2;
+  else
+    alignment = 4;
+
+  GLint old_alignment = 0, old_row_length = 0;
+  glGetIntegerv(GL_PACK_ALIGNMENT, &old_alignment);
+  glPixelStorei(GL_PACK_ALIGNMENT, alignment);
+
+  glGetIntegerv(GL_PACK_ROW_LENGTH, &old_row_length);
+  glPixelStorei(GL_PACK_ROW_LENGTH, out_data_stride / GetDisplayPixelFormatSize(texture_format));
+
+  const GLuint texture = static_cast<GLuint>(reinterpret_cast<uintptr_t>(texture_handle));
+  const auto [gl_internal_format, gl_format, gl_type] =
+    s_display_pixel_format_mapping[static_cast<u32>(texture_format)];
+
+  GL::Texture::GetTextureSubImage(texture, 0, x, y, 0, width, height, 1, gl_format, gl_type, height * out_data_stride,
+                                  out_data);
+
+  glPixelStorei(GL_PACK_ALIGNMENT, old_alignment);
+  glPixelStorei(GL_PACK_ROW_LENGTH, old_row_length);
+  return true;
+}
+
+bool LibretroOpenGLHostDisplay::SupportsDisplayPixelFormat(HostDisplayPixelFormat format) const
+{
+  return (std::get<0>(s_display_pixel_format_mapping[static_cast<u32>(format)]) != static_cast<GLenum>(0));
+}
+
+bool LibretroOpenGLHostDisplay::BeginSetDisplayPixels(HostDisplayPixelFormat format, u32 width, u32 height,
+                                                      void** out_buffer, u32* out_pitch)
+{
+  const u32 pixel_size = GetDisplayPixelFormatSize(format);
+  const u32 stride = Common::AlignUpPow2(width * pixel_size, 4);
+  const u32 size_required = stride * height * pixel_size;
+
+  const u32 buffer_size = Common::AlignUpPow2(size_required * 2, 4 * 1024 * 1024);
+  if (!m_display_pixels_texture_pbo || m_display_pixels_texture_pbo->GetSize() < buffer_size)
+  {
+    m_display_pixels_texture_pbo.reset();
+    m_display_pixels_texture_pbo = GL::StreamBuffer::Create(GL_PIXEL_UNPACK_BUFFER, buffer_size);
+    if (!m_display_pixels_texture_pbo)
+      return false;
+  }
+
+  const auto map = m_display_pixels_texture_pbo->Map(GetDisplayPixelFormatSize(format), size_required);
+  m_display_texture_format = format;
+  m_display_pixels_texture_pbo_map_offset = map.buffer_offset;
+  m_display_pixels_texture_pbo_map_size = size_required;
+  *out_buffer = map.pointer;
+  *out_pitch = stride;
+
+  glBindTexture(GL_TEXTURE_2D, m_display_pixels_texture_id);
+  SetDisplayTexture(reinterpret_cast<void*>(static_cast<uintptr_t>(m_display_pixels_texture_id)), format, width, height,
+                    0, 0, width, height);
+  return true;
+}
+
+void LibretroOpenGLHostDisplay::EndSetDisplayPixels()
+{
+  const u32 width = static_cast<u32>(m_display_texture_view_width);
+  const u32 height = static_cast<u32>(m_display_texture_view_height);
+
+  const auto [gl_internal_format, gl_format, gl_type] =
+    s_display_pixel_format_mapping[static_cast<u32>(m_display_texture_format)];
+
+  glBindTexture(GL_TEXTURE_2D, m_display_pixels_texture_id);
+
+  m_display_pixels_texture_pbo->Unmap(m_display_pixels_texture_pbo_map_size);
+  m_display_pixels_texture_pbo->Bind();
+  glTexImage2D(GL_TEXTURE_2D, 0, gl_internal_format, width, height, 0, gl_format, gl_type,
+               reinterpret_cast<void*>(static_cast<uintptr_t>(m_display_pixels_texture_pbo_map_offset)));
+  m_display_pixels_texture_pbo->Unbind();
+
+  m_display_pixels_texture_pbo_map_offset = 0;
+  m_display_pixels_texture_pbo_map_size = 0;
+
+  glBindTexture(GL_TEXTURE_2D, 0);
+}
+
+bool LibretroOpenGLHostDisplay::SetDisplayPixels(HostDisplayPixelFormat format, u32 width, u32 height,
+                                                 const void* buffer, u32 pitch)
+{
+  glBindTexture(GL_TEXTURE_2D, m_display_pixels_texture_id);
+
+  const auto [gl_internal_format, gl_format, gl_type] = s_display_pixel_format_mapping[static_cast<u32>(format)];
+  const u32 pixel_size = GetDisplayPixelFormatSize(format);
+  const bool is_packed_tightly = (pitch == (pixel_size * width));
+
+  // If we have GLES3, we can set row_length.
+  if (!is_packed_tightly)
+    glPixelStorei(GL_UNPACK_ROW_LENGTH, pitch / pixel_size);
+
+  glTexImage2D(GL_TEXTURE_2D, 0, gl_internal_format, width, height, 0, gl_format, gl_type, buffer);
+
+  if (!is_packed_tightly)
+    glPixelStorei(GL_UNPACK_ROW_LENGTH, 0);
+
+  glBindTexture(GL_TEXTURE_2D, 0);
+
+  SetDisplayTexture(reinterpret_cast<void*>(static_cast<uintptr_t>(m_display_pixels_texture_id)), format, width, height,
+                    0, 0, width, height);
+  return true;
+}
+
+void LibretroOpenGLHostDisplay::SetVSync(bool enabled)
+{
+  // The libretro frontend controls this.
+  Log_DevPrintf("Ignoring SetVSync(%u)", BoolToUInt32(enabled));
+}
+
+const char* LibretroOpenGLHostDisplay::GetGLSLVersionString() const
+{
+  if (GetRenderAPI() == RenderAPI::OpenGLES)
+  {
+    if (GLAD_GL_ES_VERSION_3_0)
+      return "#version 300 es";
+    else
+      return "#version 100";
+  }
+  else
+  {
+    if (GLAD_GL_VERSION_3_3)
+      return "#version 330";
+    else
+      return "#version 130";
+  }
+}
+
+std::string LibretroOpenGLHostDisplay::GetGLSLVersionHeader() const
+{
+  std::string header = GetGLSLVersionString();
+  header += "\n\n";
+  if (GetRenderAPI() == RenderAPI::OpenGLES)
+  {
+    header += "precision highp float;\n";
+    header += "precision highp int;\n\n";
+  }
+
+  return header;
+}
+
+static void APIENTRY GLDebugCallback(GLenum source, GLenum type, GLuint id, GLenum severity, GLsizei length,
+                                     const GLchar* message, const void* userParam)
+{
+  switch (severity)
+  {
+    case GL_DEBUG_SEVERITY_HIGH_KHR:
+      Log_ErrorPrint(message);
+      break;
+    case GL_DEBUG_SEVERITY_MEDIUM_KHR:
+      Log_WarningPrint(message);
+      break;
+    case GL_DEBUG_SEVERITY_LOW_KHR:
+      Log_InfoPrint(message);
+      break;
+    case GL_DEBUG_SEVERITY_NOTIFICATION:
+      // Log_DebugPrint(message);
+      break;
+  }
+}
+
+bool LibretroOpenGLHostDisplay::HasRenderDevice() const
+{
+  return true;
+}
+
+bool LibretroOpenGLHostDisplay::HasRenderSurface() const
+{
+  return true;
+}
+
+static bool TryDesktopVersions(retro_hw_render_callback* cb)
+{
+  static constexpr std::array<std::tuple<u32, u32>, 11> desktop_versions_to_try = {
+    {/*{4, 6}, {4, 5}, {4, 4}, {4, 3}, {4, 2}, {4, 1}, {4, 0}, */ {3, 3}, {3, 2}, {3, 1}, {3, 0}}};
+
+  for (const auto& [major, minor] : desktop_versions_to_try)
+  {
+    if (major > 3 || (major == 3 && minor >= 2))
+    {
+      cb->context_type = RETRO_HW_CONTEXT_OPENGL_CORE;
+      cb->version_major = major;
+      cb->version_minor = minor;
+    }
+    else
+    {
+      cb->context_type = RETRO_HW_CONTEXT_OPENGL;
+      cb->version_major = 0;
+      cb->version_minor = 0;
+    }
+
+    if (g_retro_environment_callback(RETRO_ENVIRONMENT_SET_HW_RENDER, cb))
+      return true;
+  }
+
+  return false;
+}
+
+static bool TryESVersions(retro_hw_render_callback* cb)
+{
+  static constexpr std::array<std::tuple<u32, u32>, 4> es_versions_to_try = {{{3, 2}, {3, 1}, {3, 0}}};
+
+  for (const auto& [major, minor] : es_versions_to_try)
+  {
+    if (major >= 3 && minor > 0)
+    {
+      cb->context_type = RETRO_HW_CONTEXT_OPENGLES_VERSION;
+      cb->version_major = major;
+      cb->version_minor = minor;
+    }
+    else
+    {
+      cb->context_type = RETRO_HW_CONTEXT_OPENGLES3;
+      cb->version_major = 0;
+      cb->version_minor = 0;
+    }
+
+    if (g_retro_environment_callback(RETRO_ENVIRONMENT_SET_HW_RENDER, cb))
+      return true;
+  }
+
+  return false;
+}
+
+bool LibretroOpenGLHostDisplay::RequestHardwareRendererContext(retro_hw_render_callback* cb, bool prefer_gles)
+{
+  // Prefer a desktop OpenGL context where possible. If we can't get this, try OpenGL ES.
+  cb->cache_context = false;
+  cb->bottom_left_origin = true;
+
+  if (!prefer_gles)
+  {
+    if (TryDesktopVersions(cb) || TryESVersions(cb))
+      return true;
+  }
+  else
+  {
+    if (TryESVersions(cb) || TryDesktopVersions(cb))
+      return true;
+  }
+
+  Log_ErrorPrint("Failed to set any GL HW renderer");
+  return false;
+}
+
+bool LibretroOpenGLHostDisplay::CreateRenderDevice(const WindowInfo& wi, std::string_view adapter_name,
+                                                   bool debug_device, bool threaded_presentation)
+{
+  Assert(wi.type == WindowInfo::Type::Libretro);
+
+  // gross - but can't do much because of the GLADloadproc below.
+  static retro_hw_render_callback* cb;
+  cb = static_cast<retro_hw_render_callback*>(wi.display_connection);
+
+  m_window_info = wi;
+  m_is_gles = (cb->context_type == RETRO_HW_CONTEXT_OPENGLES3 || cb->context_type == RETRO_HW_CONTEXT_OPENGLES_VERSION);
+
+  const GLADloadproc get_proc_address = [](const char* sym) -> void* {
+    return reinterpret_cast<void*>(cb->get_proc_address(sym));
+  };
+
+  // Load GLAD.
+  const auto load_result = m_is_gles ? gladLoadGLES2Loader(get_proc_address) : gladLoadGLLoader(get_proc_address);
+  if (!load_result)
+  {
+    Log_ErrorPrintf("Failed to load GL functions");
+    return false;
+  }
+
+  return true;
+}
+
+bool LibretroOpenGLHostDisplay::InitializeRenderDevice(std::string_view shader_cache_directory, bool debug_device,
+                                                       bool threaded_presentation)
+{
+  glGetIntegerv(GL_UNIFORM_BUFFER_OFFSET_ALIGNMENT, reinterpret_cast<GLint*>(&m_uniform_buffer_alignment));
+
+  if (debug_device && GLAD_GL_KHR_debug)
+  {
+    if (GetRenderAPI() == RenderAPI::OpenGLES)
+      glDebugMessageCallbackKHR(GLDebugCallback, nullptr);
+    else
+      glDebugMessageCallback(GLDebugCallback, nullptr);
+
+    glEnable(GL_DEBUG_OUTPUT);
+    // glEnable(GL_DEBUG_OUTPUT_SYNCHRONOUS);
+  }
+
+  if (!CreateResources())
+    return false;
+
+  // Start with vsync on.
+  SetVSync(true);
+
+  return true;
+}
+
+bool LibretroOpenGLHostDisplay::MakeRenderContextCurrent()
+{
+  return true;
+}
+
+bool LibretroOpenGLHostDisplay::DoneRenderContextCurrent()
+{
+  return true;
+}
+
+void LibretroOpenGLHostDisplay::DestroyRenderDevice()
+{
+  ClearSoftwareCursor();
+  DestroyResources();
+}
+
+void LibretroOpenGLHostDisplay::ResizeRenderWindow(s32 new_window_width, s32 new_window_height)
+{
+  m_window_info.surface_width = static_cast<u32>(new_window_width);
+  m_window_info.surface_height = static_cast<u32>(new_window_height);
+}
+
+bool LibretroOpenGLHostDisplay::ChangeRenderWindow(const WindowInfo& new_wi)
+{
+  m_window_info = new_wi;
+  return true;
+}
+
+bool LibretroOpenGLHostDisplay::SupportsFullscreen() const
+{
+  return false;
+}
+
+bool LibretroOpenGLHostDisplay::IsFullscreen()
+{
+  return false;
+}
+
+bool LibretroOpenGLHostDisplay::SetFullscreen(bool fullscreen, u32 width, u32 height, float refresh_rate)
+{
+  return false;
+}
+
+HostDisplay::AdapterAndModeList LibretroOpenGLHostDisplay::GetAdapterAndModeList()
+{
+  return {};
+}
+
+void LibretroOpenGLHostDisplay::DestroyRenderSurface() {}
+
+bool LibretroOpenGLHostDisplay::SetPostProcessingChain(const std::string_view& config)
+{
+  return false;
+}
+
+bool LibretroOpenGLHostDisplay::CreateImGuiContext()
+{
+  return false;
+}
+
+void LibretroOpenGLHostDisplay::DestroyImGuiContext() {}
+
+bool LibretroOpenGLHostDisplay::UpdateImGuiFontTexture()
+{
+  return false;
+}
+
+bool LibretroOpenGLHostDisplay::CreateResources()
+{
+  static constexpr char fullscreen_quad_vertex_shader[] = R"(
+uniform vec4 u_src_rect;
+out vec2 v_tex0;
+
+void main()
+{
+  vec2 pos = vec2(float((gl_VertexID << 1) & 2), float(gl_VertexID & 2));
+  v_tex0 = u_src_rect.xy + pos * u_src_rect.zw;
+  gl_Position = vec4(pos * vec2(2.0f, -2.0f) + vec2(-1.0f, 1.0f), 0.0f, 1.0f);
+}
+)";
+
+  static constexpr char display_fragment_shader[] = R"(
+uniform sampler2D samp0;
+
+in vec2 v_tex0;
+out vec4 o_col0;
+
+void main()
+{
+  o_col0 = vec4(texture(samp0, v_tex0).rgb, 1.0);
+}
+)";
+
+  static constexpr char cursor_fragment_shader[] = R"(
+uniform sampler2D samp0;
+
+in vec2 v_tex0;
+out vec4 o_col0;
+
+void main()
+{
+  o_col0 = texture(samp0, v_tex0);
+}
+)";
+
+  if (!m_display_program.Compile(GetGLSLVersionHeader() + fullscreen_quad_vertex_shader, {},
+                                 GetGLSLVersionHeader() + display_fragment_shader) ||
+      !m_cursor_program.Compile(GetGLSLVersionHeader() + fullscreen_quad_vertex_shader, {},
+                                GetGLSLVersionHeader() + cursor_fragment_shader))
+  {
+    Log_ErrorPrintf("Failed to compile display shaders");
+    return false;
+  }
+
+  if (GetRenderAPI() != RenderAPI::OpenGLES)
+  {
+    m_display_program.BindFragData(0, "o_col0");
+    m_cursor_program.BindFragData(0, "o_col0");
+  }
+
+  if (!m_display_program.Link() || !m_cursor_program.Link())
+  {
+    Log_ErrorPrintf("Failed to link display programs");
+    return false;
+  }
+
+  m_display_program.Bind();
+  m_display_program.RegisterUniform("u_src_rect");
+  m_display_program.RegisterUniform("samp0");
+  m_display_program.Uniform1i(1, 0);
+  m_cursor_program.Bind();
+  m_cursor_program.RegisterUniform("u_src_rect");
+  m_cursor_program.RegisterUniform("samp0");
+  m_cursor_program.Uniform1i(1, 0);
+
+  glGenVertexArrays(1, &m_display_vao);
+
+  // samplers
+  glGenSamplers(1, &m_display_nearest_sampler);
+  glSamplerParameteri(m_display_nearest_sampler, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
+  glSamplerParameteri(m_display_nearest_sampler, GL_TEXTURE_MAG_FILTER, GL_NEAREST);
+  glGenSamplers(1, &m_display_linear_sampler);
+  glSamplerParameteri(m_display_linear_sampler, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
+  glSamplerParameteri(m_display_linear_sampler, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
+
+  return true;
+}
+
+void LibretroOpenGLHostDisplay::DestroyResources()
+{
+  if (m_display_pixels_texture_id != 0)
+  {
+    glDeleteTextures(1, &m_display_pixels_texture_id);
+    m_display_pixels_texture_id = 0;
+  }
+
+  if (m_display_vao != 0)
+  {
+    glDeleteVertexArrays(1, &m_display_vao);
+    m_display_vao = 0;
+  }
+  if (m_display_linear_sampler != 0)
+  {
+    glDeleteSamplers(1, &m_display_linear_sampler);
+    m_display_linear_sampler = 0;
+  }
+  if (m_display_nearest_sampler != 0)
+  {
+    glDeleteSamplers(1, &m_display_nearest_sampler);
+    m_display_nearest_sampler = 0;
+  }
+
+  m_cursor_program.Destroy();
+  m_display_program.Destroy();
+}
+
+bool LibretroOpenGLHostDisplay::Render()
+{
+  const GLuint fbo = static_cast<GLuint>(
+    static_cast<retro_hw_render_callback*>(m_window_info.display_connection)->get_current_framebuffer());
+  const u32 resolution_scale = g_libretro_host_interface.GetResolutionScale();
+  const u32 display_width = static_cast<u32>(m_display_width) * resolution_scale;
+  const u32 display_height = static_cast<u32>(m_display_height) * resolution_scale;
+
+  glEnable(GL_SCISSOR_TEST);
+  glScissor(0, 0, display_width, display_height);
+  glBindFramebuffer(GL_DRAW_FRAMEBUFFER, fbo);
+  glClearColor(0.0f, 0.0f, 0.0f, 0.0f);
+  glClear(GL_COLOR_BUFFER_BIT);
+  glDisable(GL_SCISSOR_TEST);
+
+  if (HasDisplayTexture())
+  {
+    const auto [left, top, width, height] = CalculateDrawRect(display_width, display_height, 0, false);
+    RenderDisplay(left, top, width, height, m_display_texture_handle, m_display_texture_width, m_display_texture_height,
+                  m_display_texture_view_x, m_display_texture_view_y, m_display_texture_view_width,
+                  m_display_texture_view_height, m_display_linear_filtering);
+  }
+
+  g_retro_video_refresh_callback(RETRO_HW_FRAME_BUFFER_VALID, display_width, display_height, 0);
+
+  GL::Program::ResetLastProgram();
+  return true;
+}
+
+bool LibretroOpenGLHostDisplay::RenderScreenshot(u32 width, u32 height, std::vector<u32>* out_pixels, u32* out_stride,
+                                                 HostDisplayPixelFormat* out_format)
+{
+  GL::Texture texture;
+  if (!texture.Create(width, height, 1, GL_RGBA8, GL_RGBA, GL_UNSIGNED_BYTE, nullptr) || !texture.CreateFramebuffer())
+    return false;
+
+  glDisable(GL_SCISSOR_TEST);
+  texture.BindFramebuffer(GL_FRAMEBUFFER);
+  glClearColor(0.0f, 0.0f, 0.0f, 1.0f);
+  glClear(GL_COLOR_BUFFER_BIT);
+
+  if (HasDisplayTexture())
+  {
+    const auto [left, top, draw_width, draw_height] = CalculateDrawRect(width, height, 0);
+    RenderDisplay(left, height - top - draw_height, draw_width, draw_height, m_display_texture_handle,
+                  m_display_texture_width, m_display_texture_height, m_display_texture_view_x, m_display_texture_view_y,
+                  m_display_texture_view_width, m_display_texture_view_height, m_display_linear_filtering);
+  }
+
+  out_pixels->resize(width * height);
+  *out_stride = sizeof(u32) * width;
+  *out_format = HostDisplayPixelFormat::RGBA8;
+  glReadPixels(0, 0, width, height, GL_RGBA, GL_UNSIGNED_BYTE, out_pixels->data());
+  glBindFramebuffer(GL_FRAMEBUFFER, 0);
+
+  return true;
+}
+
+void LibretroOpenGLHostDisplay::RenderDisplay(s32 left, s32 bottom, s32 width, s32 height, void* texture_handle,
+                                              u32 texture_width, s32 texture_height, s32 texture_view_x,
+                                              s32 texture_view_y, s32 texture_view_width, s32 texture_view_height,
+                                              bool linear_filter)
+{
+  glViewport(left, bottom, width, height);
+  glDisable(GL_BLEND);
+  glDisable(GL_CULL_FACE);
+  glDisable(GL_DEPTH_TEST);
+  glDepthMask(GL_FALSE);
+  glBindTexture(GL_TEXTURE_2D, static_cast<GLuint>(reinterpret_cast<uintptr_t>(texture_handle)));
+  m_display_program.Bind();
+
+  const float position_adjust = m_display_linear_filtering ? 0.5f : 0.0f;
+  const float size_adjust = m_display_linear_filtering ? 1.0f : 0.0f;
+  const float flip_adjust = (texture_view_height < 0) ? -1.0f : 1.0f;
+  m_display_program.Uniform4f(
+    0, (static_cast<float>(texture_view_x) + position_adjust) / static_cast<float>(texture_width),
+    (static_cast<float>(texture_view_y) + (position_adjust * flip_adjust)) / static_cast<float>(texture_height),
+    (static_cast<float>(texture_view_width) - size_adjust) / static_cast<float>(texture_width),
+    (static_cast<float>(texture_view_height) - (size_adjust * flip_adjust)) / static_cast<float>(texture_height));
+  glBindSampler(0, linear_filter ? m_display_linear_sampler : m_display_nearest_sampler);
+  glBindVertexArray(m_display_vao);
+  glDrawArrays(GL_TRIANGLES, 0, 3);
+  glBindSampler(0, 0);
+}
diff -Naur duckstation-51041e47f70123eda41d999701f5651830a0a95e.orig/src/duckstation-libretro/libretro_opengl_host_display.h duckstation-51041e47f70123eda41d999701f5651830a0a95e/src/duckstation-libretro/libretro_opengl_host_display.h
--- duckstation-51041e47f70123eda41d999701f5651830a0a95e.orig/src/duckstation-libretro/libretro_opengl_host_display.h	1970-01-01 01:00:00.000000000 +0100
+++ duckstation-51041e47f70123eda41d999701f5651830a0a95e/src/duckstation-libretro/libretro_opengl_host_display.h	2022-01-12 18:30:18.000000000 +0000
@@ -0,0 +1,103 @@
+#pragma once
+
+// GLAD has to come first so that Qt doesn't pull in the system GL headers, which are incompatible with glad.
+#include <glad.h>
+
+// Hack to prevent Apple's glext.h headers from getting included via qopengl.h, since we still want to use glad.
+#ifdef __APPLE__
+#define __glext_h_
+#endif
+
+#include "common/gl/program.h"
+#include "common/gl/stream_buffer.h"
+#include "common/gl/texture.h"
+#include "core/host_display.h"
+#include "libretro.h"
+#include <memory>
+#include <string>
+
+class LibretroOpenGLHostDisplay final : public HostDisplay
+{
+public:
+  LibretroOpenGLHostDisplay();
+  ~LibretroOpenGLHostDisplay();
+
+  static bool RequestHardwareRendererContext(retro_hw_render_callback* cb, bool prefer_gles);
+
+  RenderAPI GetRenderAPI() const override;
+  void* GetRenderDevice() const override;
+  void* GetRenderContext() const override;
+
+  bool HasRenderDevice() const override;
+  bool HasRenderSurface() const override;
+
+  bool CreateRenderDevice(const WindowInfo& wi, std::string_view adapter_name, bool debug_device,
+                          bool threaded_presentation) override;
+  bool InitializeRenderDevice(std::string_view shader_cache_directory, bool debug_device,
+                              bool threaded_presentation) override;
+  void DestroyRenderDevice() override;
+
+  bool MakeRenderContextCurrent() override;
+  bool DoneRenderContextCurrent() override;
+
+  void ResizeRenderWindow(s32 new_window_width, s32 new_window_height) override;
+
+  bool ChangeRenderWindow(const WindowInfo& new_wi) override;
+
+  bool SupportsFullscreen() const override;
+  bool IsFullscreen() override;
+  bool SetFullscreen(bool fullscreen, u32 width, u32 height, float refresh_rate) override;
+  AdapterAndModeList GetAdapterAndModeList() override;
+  void DestroyRenderSurface() override;
+
+  bool SetPostProcessingChain(const std::string_view& config) override;
+
+  std::unique_ptr<HostDisplayTexture> CreateTexture(u32 width, u32 height, u32 layers, u32 levels, u32 samples,
+                                                    HostDisplayPixelFormat format, const void* data, u32 data_stride,
+                                                    bool dynamic = false) override;
+  void UpdateTexture(HostDisplayTexture* texture, u32 x, u32 y, u32 width, u32 height, const void* texture_data,
+                     u32 texture_data_stride) override;
+  bool DownloadTexture(const void* texture_handle, HostDisplayPixelFormat texture_format, u32 x, u32 y, u32 width,
+                       u32 height, void* out_data, u32 out_data_stride) override;
+  bool SupportsDisplayPixelFormat(HostDisplayPixelFormat format) const override;
+  bool BeginSetDisplayPixels(HostDisplayPixelFormat format, u32 width, u32 height, void** out_buffer,
+                             u32* out_pitch) override;
+  void EndSetDisplayPixels() override;
+  bool SetDisplayPixels(HostDisplayPixelFormat format, u32 width, u32 height, const void* buffer, u32 pitch) override;
+
+  void SetVSync(bool enabled) override;
+
+  bool Render() override;
+  bool RenderScreenshot(u32 width, u32 height, std::vector<u32>* out_pixels, u32* out_stride,
+                        HostDisplayPixelFormat* out_format) override;
+
+protected:
+  const char* GetGLSLVersionString() const;
+  std::string GetGLSLVersionHeader() const;
+
+  bool CreateResources() override;
+  void DestroyResources() override;
+
+  bool CreateImGuiContext() override;
+  void DestroyImGuiContext() override;
+  bool UpdateImGuiFontTexture() override;
+
+  void RenderDisplay(s32 left, s32 bottom, s32 width, s32 height, void* texture_handle, u32 texture_width,
+                     s32 texture_height, s32 texture_view_x, s32 texture_view_y, s32 texture_view_width,
+                     s32 texture_view_height, bool linear_filter);
+
+  GL::Program m_display_program;
+  GL::Program m_cursor_program;
+  GLuint m_display_vao = 0;
+  GLuint m_display_nearest_sampler = 0;
+  GLuint m_display_linear_sampler = 0;
+  GLuint m_uniform_buffer_alignment = 1;
+
+  GLuint m_display_pixels_texture_id = 0;
+  std::unique_ptr<GL::StreamBuffer> m_display_pixels_texture_pbo;
+  u32 m_display_pixels_texture_pbo_map_offset = 0;
+  u32 m_display_pixels_texture_pbo_map_size = 0;
+  std::vector<u8> m_gles_pixels_repack_buffer;
+
+  bool m_is_gles = false;
+};
diff -Naur duckstation-51041e47f70123eda41d999701f5651830a0a95e.orig/src/duckstation-libretro/libretro_settings_interface.cpp duckstation-51041e47f70123eda41d999701f5651830a0a95e/src/duckstation-libretro/libretro_settings_interface.cpp
--- duckstation-51041e47f70123eda41d999701f5651830a0a95e.orig/src/duckstation-libretro/libretro_settings_interface.cpp	1970-01-01 01:00:00.000000000 +0100
+++ duckstation-51041e47f70123eda41d999701f5651830a0a95e/src/duckstation-libretro/libretro_settings_interface.cpp	2022-01-12 18:30:18.000000000 +0000
@@ -0,0 +1,128 @@
+#include "libretro_settings_interface.h"
+#include "common/log.h"
+#include "common/string_util.h"
+#include "libretro_host_interface.h"
+#include <type_traits>
+Log_SetChannel(LibretroSettingsInterface);
+
+template<typename T, typename DefaultValueType>
+static T GetVariable(const char* section, const char* key, DefaultValueType default_value)
+{
+
+  TinyString full_key;
+  full_key.Format("duckstation_%s.%s", section, key);
+
+  retro_variable rv = {full_key.GetCharArray(), nullptr};
+  if (!g_retro_environment_callback(RETRO_ENVIRONMENT_GET_VARIABLE, &rv) || !rv.value)
+    return T(default_value);
+
+  if constexpr (std::is_same_v<T, std::string>)
+  {
+    return T(rv.value);
+  }
+  else if constexpr (std::is_same_v<T, bool>)
+  {
+    return (StringUtil::Strcasecmp(rv.value, "true") == 0 || StringUtil::Strcasecmp(rv.value, "1") == 0);
+  }
+  else if constexpr (std::is_same_v<T, float>)
+  {
+    return std::strtof(rv.value, nullptr);
+  }
+  else
+  {
+    std::optional<T> parsed = StringUtil::FromChars<T>(rv.value);
+    if (!parsed.has_value())
+      return T(default_value);
+
+    return parsed.value();
+  }
+}
+
+bool LibretroSettingsInterface::Save()
+{
+  Log_WarningPrintf("Save not implemented");
+  return true;
+}
+
+void LibretroSettingsInterface::Clear()
+{
+  Log_WarningPrintf("Clear not implemented");
+}
+
+int LibretroSettingsInterface::GetIntValue(const char* section, const char* key, int default_value /*= 0*/)
+{
+  return GetVariable<int>(section, key, default_value);
+}
+
+float LibretroSettingsInterface::GetFloatValue(const char* section, const char* key, float default_value /*= 0.0f*/)
+{
+  return GetVariable<float>(section, key, default_value);
+}
+
+bool LibretroSettingsInterface::GetBoolValue(const char* section, const char* key, bool default_value /*= false*/)
+{
+  return GetVariable<bool>(section, key, default_value);
+}
+
+std::string LibretroSettingsInterface::GetStringValue(const char* section, const char* key,
+                                                      const char* default_value /*= ""*/)
+{
+  return GetVariable<std::string>(section, key, default_value);
+}
+
+void LibretroSettingsInterface::SetIntValue(const char* section, const char* key, int value)
+{
+  Log_ErrorPrintf("SetIntValue(\"%s\", \"%s\", %d) not implemented", section, key, value);
+}
+
+void LibretroSettingsInterface::SetFloatValue(const char* section, const char* key, float value)
+{
+  Log_ErrorPrintf("SetFloatValue(\"%s\", \"%s\", %f) not implemented", section, key, value);
+}
+
+void LibretroSettingsInterface::SetBoolValue(const char* section, const char* key, bool value)
+{
+  Log_ErrorPrintf("SetBoolValue(\"%s\", \"%s\", %u) not implemented", section, key, static_cast<unsigned>(value));
+}
+
+void LibretroSettingsInterface::SetStringValue(const char* section, const char* key, const char* value)
+{
+  Log_ErrorPrintf("SetStringValue(\"%s\", \"%s\", \"%s\") not implemented", section, key, value);
+}
+
+std::vector<std::string> LibretroSettingsInterface::GetStringList(const char* section, const char* key)
+{
+  std::string value = GetVariable<std::string>(section, key, "");
+  if (value.empty())
+    return {};
+
+  return std::vector<std::string>({std::move(value)});
+}
+
+void LibretroSettingsInterface::SetStringList(const char* section, const char* key,
+                                              const std::vector<std::string>& items)
+{
+  Log_ErrorPrintf("SetStringList(\"%s\", \"%s\") not implemented", section, key);
+}
+
+bool LibretroSettingsInterface::RemoveFromStringList(const char* section, const char* key, const char* item)
+{
+  Log_ErrorPrintf("RemoveFromStringList(\"%s\", \"%s\", \"%s\") not implemented", section, key, item);
+  return false;
+}
+
+bool LibretroSettingsInterface::AddToStringList(const char* section, const char* key, const char* item)
+{
+  Log_ErrorPrintf("AddToStringList(\"%s\", \"%s\", \"%s\") not implemented", section, key, item);
+  return false;
+}
+
+void LibretroSettingsInterface::DeleteValue(const char* section, const char* key)
+{
+  Log_ErrorPrintf("DeleteValue(\"%s\", \"%s\") not implemented", section, key);
+}
+
+void LibretroSettingsInterface::ClearSection(const char* section)
+{
+  Log_ErrorPrintf("ClearSection(\"%s\") not implemented", section);
+}
diff -Naur duckstation-51041e47f70123eda41d999701f5651830a0a95e.orig/src/duckstation-libretro/libretro_settings_interface.h duckstation-51041e47f70123eda41d999701f5651830a0a95e/src/duckstation-libretro/libretro_settings_interface.h
--- duckstation-51041e47f70123eda41d999701f5651830a0a95e.orig/src/duckstation-libretro/libretro_settings_interface.h	1970-01-01 01:00:00.000000000 +0100
+++ duckstation-51041e47f70123eda41d999701f5651830a0a95e/src/duckstation-libretro/libretro_settings_interface.h	2022-01-12 18:30:18.000000000 +0000
@@ -0,0 +1,27 @@
+#pragma once
+#include "core/settings.h"
+
+class LibretroSettingsInterface : public SettingsInterface
+{
+public:
+  bool Save() override;
+  void Clear() override;
+
+  int GetIntValue(const char* section, const char* key, int default_value = 0) override;
+  float GetFloatValue(const char* section, const char* key, float default_value = 0.0f) override;
+  bool GetBoolValue(const char* section, const char* key, bool default_value = false) override;
+  std::string GetStringValue(const char* section, const char* key, const char* default_value = "") override;
+
+  void SetIntValue(const char* section, const char* key, int value) override;
+  void SetFloatValue(const char* section, const char* key, float value) override;
+  void SetBoolValue(const char* section, const char* key, bool value) override;
+  void SetStringValue(const char* section, const char* key, const char* value) override;
+
+  std::vector<std::string> GetStringList(const char* section, const char* key) override;
+  void SetStringList(const char* section, const char* key, const std::vector<std::string>& items) override;
+  bool RemoveFromStringList(const char* section, const char* key, const char* item) override;
+  bool AddToStringList(const char* section, const char* key, const char* item) override;
+
+  void DeleteValue(const char* section, const char* key) override;
+  void ClearSection(const char* section) override;
+};
diff -Naur duckstation-51041e47f70123eda41d999701f5651830a0a95e.orig/src/duckstation-libretro/libretro_vulkan.h duckstation-51041e47f70123eda41d999701f5651830a0a95e/src/duckstation-libretro/libretro_vulkan.h
--- duckstation-51041e47f70123eda41d999701f5651830a0a95e.orig/src/duckstation-libretro/libretro_vulkan.h	1970-01-01 01:00:00.000000000 +0100
+++ duckstation-51041e47f70123eda41d999701f5651830a0a95e/src/duckstation-libretro/libretro_vulkan.h	2022-01-12 18:30:18.000000000 +0000
@@ -0,0 +1,397 @@
+/* Copyright (C) 2010-2020 The RetroArch team
+ *
+ * ---------------------------------------------------------------------------------------------
+ * The following license statement only applies to this libretro API header (libretro_vulkan.h)
+ * ---------------------------------------------------------------------------------------------
+ *
+ * Permission is hereby granted, free of charge,
+ * to any person obtaining a copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation the rights to
+ * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software,
+ * and to permit persons to whom the Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
+ * INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
+ * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
+ * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+#ifndef LIBRETRO_VULKAN_H__
+#define LIBRETRO_VULKAN_H__
+
+#include "libretro.h"
+#include <vulkan/vulkan.h>
+
+#define RETRO_HW_RENDER_INTERFACE_VULKAN_VERSION 5
+#define RETRO_HW_RENDER_CONTEXT_NEGOTIATION_INTERFACE_VULKAN_VERSION 1
+
+struct retro_vulkan_image
+{
+   VkImageView image_view;
+   VkImageLayout image_layout;
+   VkImageViewCreateInfo create_info;
+};
+
+typedef void (*retro_vulkan_set_image_t)(void *handle,
+      const struct retro_vulkan_image *image,
+      uint32_t num_semaphores,
+      const VkSemaphore *semaphores,
+      uint32_t src_queue_family);
+
+typedef uint32_t (*retro_vulkan_get_sync_index_t)(void *handle);
+typedef uint32_t (*retro_vulkan_get_sync_index_mask_t)(void *handle);
+typedef void (*retro_vulkan_set_command_buffers_t)(void *handle,
+      uint32_t num_cmd,
+      const VkCommandBuffer *cmd);
+typedef void (*retro_vulkan_wait_sync_index_t)(void *handle);
+typedef void (*retro_vulkan_lock_queue_t)(void *handle);
+typedef void (*retro_vulkan_unlock_queue_t)(void *handle);
+typedef void (*retro_vulkan_set_signal_semaphore_t)(void *handle, VkSemaphore semaphore);
+
+typedef const VkApplicationInfo *(*retro_vulkan_get_application_info_t)(void);
+
+struct retro_vulkan_context
+{
+   VkPhysicalDevice gpu;
+   VkDevice device;
+   VkQueue queue;
+   uint32_t queue_family_index;
+   VkQueue presentation_queue;
+   uint32_t presentation_queue_family_index;
+};
+
+typedef bool (*retro_vulkan_create_device_t)(
+      struct retro_vulkan_context *context,
+      VkInstance instance,
+      VkPhysicalDevice gpu,
+      VkSurfaceKHR surface,
+      PFN_vkGetInstanceProcAddr get_instance_proc_addr,
+      const char **required_device_extensions,
+      unsigned num_required_device_extensions,
+      const char **required_device_layers,
+      unsigned num_required_device_layers,
+      const VkPhysicalDeviceFeatures *required_features);
+
+typedef void (*retro_vulkan_destroy_device_t)(void);
+
+/* Note on thread safety:
+ * The Vulkan API is heavily designed around multi-threading, and
+ * the libretro interface for it should also be threading friendly.
+ * A core should be able to build command buffers and submit
+ * command buffers to the GPU from any thread.
+ */
+
+struct retro_hw_render_context_negotiation_interface_vulkan
+{
+   /* Must be set to RETRO_HW_RENDER_CONTEXT_NEGOTIATION_INTERFACE_VULKAN. */
+   enum retro_hw_render_context_negotiation_interface_type interface_type;
+   /* Must be set to RETRO_HW_RENDER_CONTEXT_NEGOTIATION_INTERFACE_VULKAN_VERSION. */
+   unsigned interface_version;
+
+   /* If non-NULL, returns a VkApplicationInfo struct that the frontend can use instead of
+    * its "default" application info.
+    */
+   retro_vulkan_get_application_info_t get_application_info;
+
+   /* If non-NULL, the libretro core will choose one or more physical devices,
+    * create one or more logical devices and create one or more queues.
+    * The core must prepare a designated PhysicalDevice, Device, Queue and queue family index
+    * which the frontend will use for its internal operation.
+    *
+    * If gpu is not VK_NULL_HANDLE, the physical device provided to the frontend must be this PhysicalDevice.
+    * The core is still free to use other physical devices.
+    *
+    * The frontend will request certain extensions and layers for a device which is created.
+    * The core must ensure that the queue and queue_family_index support GRAPHICS and COMPUTE.
+    *
+    * If surface is not VK_NULL_HANDLE, the core must consider presentation when creating the queues.
+    * If presentation to "surface" is supported on the queue, presentation_queue must be equal to queue.
+    * If not, a second queue must be provided in presentation_queue and presentation_queue_index.
+    * If surface is not VK_NULL_HANDLE, the instance from frontend will have been created with supported for
+    * VK_KHR_surface extension.
+    *
+    * The core is free to set its own queue priorities.
+    * Device provided to frontend is owned by the frontend, but any additional device resources must be freed by core
+    * in destroy_device callback.
+    *
+    * If this function returns true, a PhysicalDevice, Device and Queues are initialized.
+    * If false, none of the above have been initialized and the frontend will attempt
+    * to fallback to "default" device creation, as if this function was never called.
+    */
+   retro_vulkan_create_device_t create_device;
+
+   /* If non-NULL, this callback is called similar to context_destroy for HW_RENDER_INTERFACE.
+    * However, it will be called even if context_reset was not called.
+    * This can happen if the context never succeeds in being created.
+    * destroy_device will always be called before the VkInstance
+    * of the frontend is destroyed if create_device was called successfully so that the core has a chance of
+    * tearing down its own device resources.
+    *
+    * Only auxillary resources should be freed here, i.e. resources which are not part of retro_vulkan_context.
+    */
+   retro_vulkan_destroy_device_t destroy_device;
+};
+
+struct retro_hw_render_interface_vulkan
+{
+   /* Must be set to RETRO_HW_RENDER_INTERFACE_VULKAN. */
+   enum retro_hw_render_interface_type interface_type;
+   /* Must be set to RETRO_HW_RENDER_INTERFACE_VULKAN_VERSION. */
+   unsigned interface_version;
+
+   /* Opaque handle to the Vulkan backend in the frontend
+    * which must be passed along to all function pointers
+    * in this interface.
+    *
+    * The rationale for including a handle here (which libretro v1
+    * doesn't currently do in general) is:
+    *
+    * - Vulkan cores should be able to be freely threaded without lots of fuzz.
+    *   This would break frontends which currently rely on TLS
+    *   to deal with multiple cores loaded at the same time.
+    * - Fixing this in general is TODO for an eventual libretro v2.
+    */
+   void *handle;
+
+   /* The Vulkan instance the context is using. */
+   VkInstance instance;
+   /* The physical device used. */
+   VkPhysicalDevice gpu;
+   /* The logical device used. */
+   VkDevice device;
+
+   /* Allows a core to fetch all its needed symbols without having to link
+    * against the loader itself. */
+   PFN_vkGetDeviceProcAddr get_device_proc_addr;
+   PFN_vkGetInstanceProcAddr get_instance_proc_addr;
+
+   /* The queue the core must use to submit data.
+    * This queue and index must remain constant throughout the lifetime
+    * of the context.
+    *
+    * This queue will be the queue that supports graphics and compute
+    * if the device supports compute.
+    */
+   VkQueue queue;
+   unsigned queue_index;
+
+   /* Before calling retro_video_refresh_t with RETRO_HW_FRAME_BUFFER_VALID,
+    * set which image to use for this frame.
+    *
+    * If num_semaphores is non-zero, the frontend will wait for the
+    * semaphores provided to be signaled before using the results further
+    * in the pipeline.
+    *
+    * Semaphores provided by a single call to set_image will only be
+    * waited for once (waiting for a semaphore resets it).
+    * E.g. set_image, video_refresh, and then another
+    * video_refresh without set_image,
+    * but same image will only wait for semaphores once.
+    *
+    * For this reason, ownership transfer will only occur if semaphores
+    * are waited on for a particular frame in the frontend.
+    *
+    * Using semaphores is optional for synchronization purposes,
+    * but if not using
+    * semaphores, an image memory barrier in vkCmdPipelineBarrier
+    * should be used in the graphics_queue.
+    * Example:
+    *
+    * vkCmdPipelineBarrier(cmd,
+    *    srcStageMask = VK_PIPELINE_STAGE_ALL_GRAPHICS_BIT,
+    *    dstStageMask = VK_PIPELINE_STAGE_FRAGMENT_SHADER_BIT,
+    *    image_memory_barrier = {
+    *       srcAccessMask = VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT,
+    *       dstAccessMask = VK_ACCESS_SHADER_READ_BIT,
+    *    });
+    *
+    * The use of pipeline barriers instead of semaphores is encouraged
+    * as it is simpler and more fine-grained. A layout transition
+    * must generally happen anyways which requires a
+    * pipeline barrier.
+    *
+    * The image passed to set_image must have imageUsage flags set to at least
+    * VK_IMAGE_USAGE_TRANSFER_SRC_BIT and VK_IMAGE_USAGE_SAMPLED_BIT.
+    * The core will naturally want to use flags such as
+    * VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT and/or
+    * VK_IMAGE_USAGE_TRANSFER_DST_BIT depending
+    * on how the final image is created.
+    *
+    * The image must also have been created with MUTABLE_FORMAT bit set if
+    * 8-bit formats are used, so that the frontend can reinterpret sRGB
+    * formats as it sees fit.
+    *
+    * Images passed to set_image should be created with TILING_OPTIMAL.
+    * The image layout should be transitioned to either
+    * VK_IMAGE_LAYOUT_GENERIC or VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL.
+    * The actual image layout used must be set in image_layout.
+    *
+    * The image must be a 2D texture which may or not be layered
+    * and/or mipmapped.
+    *
+    * The image must be suitable for linear sampling.
+    * While the image_view is typically the only field used,
+    * the frontend may want to reinterpret the texture as sRGB vs.
+    * non-sRGB for example so the VkImageViewCreateInfo used to
+    * create the image view must also be passed in.
+    *
+    * The data in the pointer to the image struct will not be copied
+    * as the pNext field in create_info cannot be reliably deep-copied.
+    * The image pointer passed to set_image must be valid until
+    * retro_video_refresh_t has returned.
+    *
+    * If frame duping is used when passing NULL to retro_video_refresh_t,
+    * the frontend is free to either use the latest image passed to
+    * set_image or reuse the older pointer passed to set_image the
+    * frame RETRO_HW_FRAME_BUFFER_VALID was last used.
+    *
+    * Essentially, the lifetime of the pointer passed to
+    * retro_video_refresh_t should be extended if frame duping is used
+    * so that the frontend can reuse the older pointer.
+    *
+    * The image itself however, must not be touched by the core until
+    * wait_sync_index has been completed later. The frontend may perform
+    * layout transitions on the image, so even read-only access is not defined.
+    * The exception to read-only rule is if GENERAL layout is used for the image.
+    * In this case, the frontend is not allowed to perform any layout transitions,
+    * so concurrent reads from core and frontend are allowed.
+    *
+    * If frame duping is used, or if set_command_buffers is used,
+    * the frontend will not wait for any semaphores.
+    *
+    * The src_queue_family is used to specify which queue family
+    * the image is currently owned by. If using multiple queue families
+    * (e.g. async compute), the frontend will need to acquire ownership of the
+    * image before rendering with it and release the image afterwards.
+    *
+    * If src_queue_family is equal to the queue family (queue_index),
+    * no ownership transfer will occur.
+    * Similarly, if src_queue_family is VK_QUEUE_FAMILY_IGNORED,
+    * no ownership transfer will occur.
+    *
+    * The frontend will always release ownership back to src_queue_family.
+    * Waiting for frontend to complete with wait_sync_index() ensures that
+    * the frontend has released ownership back to the application.
+    * Note that in Vulkan, transfering ownership is a two-part process.
+    *
+    * Example frame:
+    *  - core releases ownership from src_queue_index to queue_index with VkImageMemoryBarrier.
+    *  - core calls set_image with src_queue_index.
+    *  - Frontend will acquire the image with src_queue_index -> queue_index as well, completing the ownership transfer.
+    *  - Frontend renders the frame.
+    *  - Frontend releases ownership with queue_index -> src_queue_index.
+    *  - Next time image is used, core must acquire ownership from queue_index ...
+    *
+    * Since the frontend releases ownership, we cannot necessarily dupe the frame because
+    * the core needs to make the roundtrip of ownership transfer.
+    */
+   retro_vulkan_set_image_t set_image;
+
+   /* Get the current sync index for this frame which is obtained in
+    * frontend by calling e.g. vkAcquireNextImageKHR before calling
+    * retro_run().
+    *
+    * This index will correspond to which swapchain buffer is currently
+    * the active one.
+    *
+    * Knowing this index is very useful for maintaining safe asynchronous CPU
+    * and GPU operation without stalling.
+    *
+    * The common pattern for synchronization is to receive fences when
+    * submitting command buffers to Vulkan (vkQueueSubmit) and add this fence
+    * to a list of fences for frame number get_sync_index().
+    *
+    * Next time we receive the same get_sync_index(), we can wait for the
+    * fences from before, which will usually return immediately as the
+    * frontend will generally also avoid letting the GPU run ahead too much.
+    *
+    * After the fence has signaled, we know that the GPU has completed all
+    * GPU work related to work submitted in the frame we last saw get_sync_index().
+    *
+    * This means we can safely reuse or free resources allocated in this frame.
+    *
+    * In theory, even if we wait for the fences correctly, it is not technically
+    * safe to write to the image we earlier passed to the frontend since we're
+    * not waiting for the frontend GPU jobs to complete.
+    *
+    * The frontend will guarantee that the appropriate pipeline barrier
+    * in graphics_queue has been used such that
+    * VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT cannot
+    * start until the frontend is done with the image.
+    */
+   retro_vulkan_get_sync_index_t get_sync_index;
+
+   /* Returns a bitmask of how many swapchain images we currently have
+    * in the frontend.
+    *
+    * If bit #N is set in the return value, get_sync_index can return N.
+    * Knowing this value is useful for preallocating per-frame management
+    * structures ahead of time.
+    *
+    * While this value will typically remain constant throughout the
+    * applications lifecycle, it may for example change if the frontend
+    * suddently changes fullscreen state and/or latency.
+    *
+    * If this value ever changes, it is safe to assume that the device
+    * is completely idle and all synchronization objects can be deleted
+    * right away as desired.
+    */
+   retro_vulkan_get_sync_index_mask_t get_sync_index_mask;
+
+   /* Instead of submitting the command buffer to the queue first, the core
+    * can pass along its command buffer to the frontend, and the frontend
+    * will submit the command buffer together with the frontends command buffers.
+    *
+    * This has the advantage that the overhead of vkQueueSubmit can be
+    * amortized into a single call. For this mode, semaphores in set_image
+    * will be ignored, so vkCmdPipelineBarrier must be used to synchronize
+    * the core and frontend.
+    *
+    * The command buffers in set_command_buffers are only executed once,
+    * even if frame duping is used.
+    *
+    * If frame duping is used, set_image should be used for the frames
+    * which should be duped instead.
+    *
+    * Command buffers passed to the frontend with set_command_buffers
+    * must not actually be submitted to the GPU until retro_video_refresh_t
+    * is called.
+    *
+    * The frontend must submit the command buffer before submitting any
+    * other command buffers provided by set_command_buffers. */
+   retro_vulkan_set_command_buffers_t set_command_buffers;
+
+   /* Waits on CPU for device activity for the current sync index to complete.
+    * This is useful since the core will not have a relevant fence to sync with
+    * when the frontend is submitting the command buffers. */
+   retro_vulkan_wait_sync_index_t wait_sync_index;
+
+   /* If the core submits command buffers itself to any of the queues provided
+    * in this interface, the core must lock and unlock the frontend from
+    * racing on the VkQueue.
+    *
+    * Queue submission can happen on any thread.
+    * Even if queue submission happens on the same thread as retro_run(),
+    * the lock/unlock functions must still be called.
+    *
+    * NOTE: Queue submissions are heavy-weight. */
+   retro_vulkan_lock_queue_t lock_queue;
+   retro_vulkan_unlock_queue_t unlock_queue;
+
+   /* Sets a semaphore which is signaled when the image in set_image can safely be reused.
+    * The semaphore is consumed next call to retro_video_refresh_t.
+    * The semaphore will be signalled even for duped frames.
+    * The semaphore will be signalled only once, so set_signal_semaphore should be called every frame.
+    * The semaphore may be VK_NULL_HANDLE, which disables semaphore signalling for next call to retro_video_refresh_t.
+    *
+    * This is mostly useful to support use cases where you're rendering to a single image that
+    * is recycled in a ping-pong fashion with the frontend to save memory (but potentially less throughput).
+    */
+   retro_vulkan_set_signal_semaphore_t set_signal_semaphore;
+};
+
+#endif
diff -Naur duckstation-51041e47f70123eda41d999701f5651830a0a95e.orig/src/duckstation-libretro/libretro_vulkan_host_display.cpp duckstation-51041e47f70123eda41d999701f5651830a0a95e/src/duckstation-libretro/libretro_vulkan_host_display.cpp
--- duckstation-51041e47f70123eda41d999701f5651830a0a95e.orig/src/duckstation-libretro/libretro_vulkan_host_display.cpp	1970-01-01 01:00:00.000000000 +0100
+++ duckstation-51041e47f70123eda41d999701f5651830a0a95e/src/duckstation-libretro/libretro_vulkan_host_display.cpp	2022-01-12 18:30:18.000000000 +0000
@@ -0,0 +1,753 @@
+#include "libretro_vulkan_host_display.h"
+#include "common/align.h"
+#include "common/assert.h"
+#include "common/log.h"
+#include "common/vulkan/builders.h"
+#include "common/vulkan/context.h"
+#include "common/vulkan/shader_cache.h"
+#include "common/vulkan/staging_texture.h"
+#include "common/vulkan/util.h"
+#include "core/shader_cache_version.h"
+#include "libretro_host_interface.h"
+#include "vulkan_loader.h"
+Log_SetChannel(LibretroVulkanHostDisplay);
+
+class LibretroVulkanHostDisplayTexture : public HostDisplayTexture
+{
+public:
+  LibretroVulkanHostDisplayTexture(Vulkan::Texture texture, Vulkan::StagingTexture staging_texture,
+                                   HostDisplayPixelFormat format)
+    : m_texture(std::move(texture)), m_staging_texture(std::move(staging_texture)), m_format(format)
+  {
+  }
+  ~LibretroVulkanHostDisplayTexture() override = default;
+
+  void* GetHandle() const override { return const_cast<Vulkan::Texture*>(&m_texture); }
+  u32 GetWidth() const override { return m_texture.GetWidth(); }
+  u32 GetHeight() const override { return m_texture.GetHeight(); }
+  u32 GetLayers() const override { return m_texture.GetLayers(); }
+  u32 GetLevels() const override { return m_texture.GetLevels(); }
+  u32 GetSamples() const override { return m_texture.GetSamples(); }
+  HostDisplayPixelFormat GetFormat() const override { return m_format; }
+
+  const Vulkan::Texture& GetTexture() const { return m_texture; }
+  Vulkan::Texture& GetTexture() { return m_texture; }
+  Vulkan::StagingTexture& GetStagingTexture() { return m_staging_texture; }
+
+private:
+  Vulkan::Texture m_texture;
+  Vulkan::StagingTexture m_staging_texture;
+  HostDisplayPixelFormat m_format;
+};
+
+LibretroVulkanHostDisplay::LibretroVulkanHostDisplay() = default;
+
+LibretroVulkanHostDisplay::~LibretroVulkanHostDisplay() = default;
+
+HostDisplay::RenderAPI LibretroVulkanHostDisplay::GetRenderAPI() const
+{
+  return HostDisplay::RenderAPI::Vulkan;
+}
+
+void* LibretroVulkanHostDisplay::GetRenderDevice() const
+{
+  return nullptr;
+}
+
+void* LibretroVulkanHostDisplay::GetRenderContext() const
+{
+  return nullptr;
+}
+
+bool LibretroVulkanHostDisplay::SupportsFullscreen() const
+{
+  return false;
+}
+
+bool LibretroVulkanHostDisplay::IsFullscreen()
+{
+  return false;
+}
+
+bool LibretroVulkanHostDisplay::SetFullscreen(bool fullscreen, u32 width, u32 height, float refresh_rate)
+{
+  return false;
+}
+
+HostDisplay::AdapterAndModeList LibretroVulkanHostDisplay::GetAdapterAndModeList()
+{
+  return {};
+}
+
+void LibretroVulkanHostDisplay::DestroyRenderSurface() {}
+
+bool LibretroVulkanHostDisplay::SetPostProcessingChain(const std::string_view& config)
+{
+  return false;
+}
+
+static constexpr std::array<VkFormat, static_cast<u32>(HostDisplayPixelFormat::Count)> s_display_pixel_format_mapping =
+  {{VK_FORMAT_UNDEFINED, VK_FORMAT_R8G8B8A8_UNORM, VK_FORMAT_B8G8R8A8_UNORM, VK_FORMAT_R5G6B5_UNORM_PACK16,
+    VK_FORMAT_A1R5G5B5_UNORM_PACK16}};
+
+std::unique_ptr<HostDisplayTexture> LibretroVulkanHostDisplay::CreateTexture(u32 width, u32 height, u32 layers,
+                                                                             u32 levels, u32 samples,
+                                                                             HostDisplayPixelFormat format,
+                                                                             const void* data, u32 data_stride,
+                                                                             bool dynamic /* = false */)
+{
+  const VkFormat vk_format = s_display_pixel_format_mapping[static_cast<u32>(format)];
+  if (vk_format == VK_FORMAT_UNDEFINED)
+    return {};
+
+  static constexpr VkImageUsageFlags usage =
+    VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT;
+
+  Vulkan::Texture texture;
+  if (!texture.Create(width, height, levels, layers, vk_format, static_cast<VkSampleCountFlagBits>(samples),
+                      (layers > 1) ? VK_IMAGE_VIEW_TYPE_2D_ARRAY : VK_IMAGE_VIEW_TYPE_2D, VK_IMAGE_TILING_OPTIMAL,
+                      usage))
+  {
+    return {};
+  }
+
+  Vulkan::StagingTexture staging_texture;
+  if (data || dynamic)
+  {
+    if (!staging_texture.Create(dynamic ? Vulkan::StagingBuffer::Type::Mutable : Vulkan::StagingBuffer::Type::Upload,
+                                vk_format, width, height))
+    {
+      return {};
+    }
+  }
+
+  texture.TransitionToLayout(g_vulkan_context->GetCurrentCommandBuffer(), VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL);
+
+  if (data)
+  {
+    staging_texture.WriteTexels(0, 0, width, height, data, data_stride);
+    staging_texture.CopyToTexture(g_vulkan_context->GetCurrentCommandBuffer(), 0, 0, texture, 0, 0, 0, 0, width,
+                                  height);
+  }
+  else
+  {
+    // clear it instead so we don't read uninitialized data (and keep the validation layer happy!)
+    static constexpr VkClearColorValue ccv = {};
+    static constexpr VkImageSubresourceRange isr = {VK_IMAGE_ASPECT_COLOR_BIT, 0u, 1u, 0u, 1u};
+    vkCmdClearColorImage(g_vulkan_context->GetCurrentCommandBuffer(), texture.GetImage(), texture.GetLayout(), &ccv, 1u,
+                         &isr);
+  }
+
+  texture.TransitionToLayout(g_vulkan_context->GetCurrentCommandBuffer(), VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL);
+
+  // don't need to keep the staging texture around if we're not dynamic
+  if (!dynamic)
+    staging_texture.Destroy(true);
+
+  return std::make_unique<LibretroVulkanHostDisplayTexture>(std::move(texture), std::move(staging_texture), format);
+}
+
+void LibretroVulkanHostDisplay::UpdateTexture(HostDisplayTexture* texture, u32 x, u32 y, u32 width, u32 height,
+                                              const void* data, u32 data_stride)
+{
+  LibretroVulkanHostDisplayTexture* vk_texture = static_cast<LibretroVulkanHostDisplayTexture*>(texture);
+
+  Vulkan::StagingTexture* staging_texture;
+  if (vk_texture->GetStagingTexture().IsValid())
+  {
+    staging_texture = &vk_texture->GetStagingTexture();
+  }
+  else
+  {
+    // TODO: This should use a stream buffer instead for speed.
+    if (m_upload_staging_texture.IsValid())
+      m_upload_staging_texture.Flush();
+
+    if ((m_upload_staging_texture.GetWidth() < width || m_upload_staging_texture.GetHeight() < height) &&
+        !m_upload_staging_texture.Create(Vulkan::StagingBuffer::Type::Upload, VK_FORMAT_R8G8B8A8_UNORM, width, height))
+    {
+      Panic("Failed to create upload staging texture");
+    }
+
+    staging_texture = &m_upload_staging_texture;
+  }
+
+  staging_texture->WriteTexels(0, 0, width, height, data, data_stride);
+  staging_texture->CopyToTexture(0, 0, vk_texture->GetTexture(), x, y, 0, 0, width, height);
+}
+
+bool LibretroVulkanHostDisplay::DownloadTexture(const void* texture_handle, HostDisplayPixelFormat texture_format,
+                                                u32 x, u32 y, u32 width, u32 height, void* out_data,
+                                                u32 out_data_stride)
+{
+  Vulkan::Texture* texture = static_cast<Vulkan::Texture*>(const_cast<void*>(texture_handle));
+
+  if ((m_readback_staging_texture.GetWidth() < width || m_readback_staging_texture.GetHeight() < height) &&
+      !m_readback_staging_texture.Create(Vulkan::StagingBuffer::Type::Readback, texture->GetFormat(), width, height))
+  {
+    return false;
+  }
+
+  m_readback_staging_texture.CopyFromTexture(*texture, x, y, 0, 0, 0, 0, width, height);
+  m_readback_staging_texture.ReadTexels(0, 0, width, height, out_data, out_data_stride);
+  return true;
+}
+
+bool LibretroVulkanHostDisplay::SupportsDisplayPixelFormat(HostDisplayPixelFormat format) const
+{
+  const VkFormat vk_format = s_display_pixel_format_mapping[static_cast<u32>(format)];
+  if (vk_format == VK_FORMAT_UNDEFINED)
+    return false;
+
+  VkFormatProperties fp = {};
+  vkGetPhysicalDeviceFormatProperties(g_vulkan_context->GetPhysicalDevice(), vk_format, &fp);
+
+  const VkFormatFeatureFlags required = (VK_FORMAT_FEATURE_SAMPLED_IMAGE_BIT | VK_FORMAT_FEATURE_TRANSFER_DST_BIT);
+  return ((fp.optimalTilingFeatures & required) == required);
+}
+
+bool LibretroVulkanHostDisplay::BeginSetDisplayPixels(HostDisplayPixelFormat format, u32 width, u32 height,
+                                                      void** out_buffer, u32* out_pitch)
+{
+  const VkFormat vk_format = s_display_pixel_format_mapping[static_cast<u32>(format)];
+
+  if (m_display_pixels_texture.GetWidth() < width || m_display_pixels_texture.GetHeight() < height ||
+      m_display_pixels_texture.GetFormat() != vk_format)
+  {
+    if (!m_display_pixels_texture.Create(width, height, 1, 1, vk_format, VK_SAMPLE_COUNT_1_BIT, VK_IMAGE_VIEW_TYPE_2D,
+                                         VK_IMAGE_TILING_OPTIMAL,
+                                         VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT))
+    {
+      return false;
+    }
+  }
+
+  if ((m_upload_staging_texture.GetWidth() < width || m_upload_staging_texture.GetHeight() < height) &&
+      !m_upload_staging_texture.Create(Vulkan::StagingBuffer::Type::Upload, vk_format, width, height))
+  {
+    return false;
+  }
+
+  SetDisplayTexture(&m_display_pixels_texture, format, m_display_pixels_texture.GetWidth(),
+                    m_display_pixels_texture.GetHeight(), 0, 0, width, height);
+
+  *out_buffer = m_upload_staging_texture.GetMappedPointer();
+  *out_pitch = m_upload_staging_texture.GetMappedStride();
+  return true;
+}
+
+void LibretroVulkanHostDisplay::EndSetDisplayPixels()
+{
+  m_upload_staging_texture.CopyToTexture(0, 0, m_display_pixels_texture, 0, 0, 0, 0,
+                                         static_cast<u32>(m_display_texture_view_width),
+                                         static_cast<u32>(m_display_texture_view_height));
+}
+
+void LibretroVulkanHostDisplay::SetVSync(bool enabled)
+{
+  // The libretro frontend controls this.
+  Log_DevPrintf("Ignoring SetVSync(%u)", BoolToUInt32(enabled));
+}
+
+static bool RetroCreateVulkanDevice(struct retro_vulkan_context* context, VkInstance instance, VkPhysicalDevice gpu,
+                                    VkSurfaceKHR surface, PFN_vkGetInstanceProcAddr get_instance_proc_addr,
+                                    const char** required_device_extensions, unsigned num_required_device_extensions,
+                                    const char** required_device_layers, unsigned num_required_device_layers,
+                                    const VkPhysicalDeviceFeatures* required_features)
+{
+  // We need some module functions.
+  vkGetInstanceProcAddr = get_instance_proc_addr;
+  if (!Vulkan::LoadVulkanInstanceFunctions(instance))
+  {
+    Log_ErrorPrintf("Failed to load Vulkan instance functions");
+    Vulkan::ResetVulkanLibraryFunctionPointers();
+    return false;
+  }
+
+  if (gpu == VK_NULL_HANDLE)
+  {
+    Vulkan::Context::GPUList gpus = Vulkan::Context::EnumerateGPUs(instance);
+    if (gpus.empty())
+    {
+      g_libretro_host_interface.ReportError("No GPU provided and none available, cannot create device");
+      Vulkan::ResetVulkanLibraryFunctionPointers();
+      return false;
+    }
+
+    Log_InfoPrintf("No GPU provided, using first/default");
+    gpu = gpus[0];
+  }
+
+  if (!Vulkan::Context::CreateFromExistingInstance(
+        instance, gpu, surface, false, false, false, required_device_extensions, num_required_device_extensions,
+        required_device_layers, num_required_device_layers, required_features))
+  {
+    Vulkan::ResetVulkanLibraryFunctionPointers();
+    return false;
+  }
+
+  context->gpu = g_vulkan_context->GetPhysicalDevice();
+  context->device = g_vulkan_context->GetDevice();
+  context->queue = g_vulkan_context->GetGraphicsQueue();
+  context->queue_family_index = g_vulkan_context->GetGraphicsQueueFamilyIndex();
+  context->presentation_queue = g_vulkan_context->GetPresentQueue();
+  context->presentation_queue_family_index = g_vulkan_context->GetPresentQueueFamilyIndex();
+  return true;
+}
+
+static retro_hw_render_context_negotiation_interface_vulkan s_vulkan_context_negotiation_interface = {
+  RETRO_HW_RENDER_CONTEXT_NEGOTIATION_INTERFACE_VULKAN,         // interface_type
+  RETRO_HW_RENDER_CONTEXT_NEGOTIATION_INTERFACE_VULKAN_VERSION, // interface_version
+  nullptr,                                                      // get_application_info
+  RetroCreateVulkanDevice,                                      // create_device
+  nullptr                                                       // destroy_device
+};
+
+bool LibretroVulkanHostDisplay::RequestHardwareRendererContext(retro_hw_render_callback* cb)
+{
+  cb->cache_context = false;
+  cb->bottom_left_origin = false;
+  cb->context_type = RETRO_HW_CONTEXT_VULKAN;
+  return g_retro_environment_callback(RETRO_ENVIRONMENT_SET_HW_RENDER, cb) &&
+         g_retro_environment_callback(RETRO_ENVIRONMENT_SET_HW_RENDER_CONTEXT_NEGOTIATION_INTERFACE,
+                                      &s_vulkan_context_negotiation_interface);
+}
+
+bool LibretroVulkanHostDisplay::CreateRenderDevice(const WindowInfo& wi, std::string_view adapter_name,
+                                                   bool debug_device, bool threaded_presentation)
+{
+  retro_hw_render_interface* ri = nullptr;
+  if (!g_retro_environment_callback(RETRO_ENVIRONMENT_GET_HW_RENDER_INTERFACE, &ri))
+  {
+    Log_ErrorPrint("Failed to get HW render interface");
+    return false;
+  }
+  else if (ri->interface_type != RETRO_HW_RENDER_INTERFACE_VULKAN ||
+           ri->interface_version != RETRO_HW_RENDER_INTERFACE_VULKAN_VERSION)
+  {
+    Log_ErrorPrintf("Unexpected HW interface - type %u version %u", static_cast<unsigned>(ri->interface_type),
+                    static_cast<unsigned>(ri->interface_version));
+    return false;
+  }
+
+  if (!g_vulkan_context)
+  {
+    Log_ErrorPrintf("Vulkan context was not negotiated/created");
+    return false;
+  }
+
+  // TODO: Grab queue? it should be the same
+  m_ri = reinterpret_cast<retro_hw_render_interface_vulkan*>(ri);
+  return true;
+}
+
+bool LibretroVulkanHostDisplay::InitializeRenderDevice(std::string_view shader_cache_directory, bool debug_device,
+                                                       bool threaded_presentation)
+{
+  Vulkan::ShaderCache::Create(shader_cache_directory, SHADER_CACHE_VERSION, debug_device);
+
+  if (!CreateResources())
+    return false;
+
+  return true;
+}
+
+bool LibretroVulkanHostDisplay::HasRenderDevice() const
+{
+  return static_cast<bool>(g_vulkan_context);
+}
+
+bool LibretroVulkanHostDisplay::HasRenderSurface() const
+{
+  return true;
+}
+
+void LibretroVulkanHostDisplay::DestroyRenderDevice()
+{
+  if (!g_vulkan_context)
+    return;
+
+  g_vulkan_context->WaitForGPUIdle();
+
+  ClearSoftwareCursor();
+  DestroyResources();
+
+  Vulkan::ShaderCache::Destroy();
+  DestroyRenderSurface();
+  Vulkan::Context::Destroy();
+  Vulkan::ResetVulkanLibraryFunctionPointers();
+}
+
+bool LibretroVulkanHostDisplay::MakeRenderContextCurrent()
+{
+  return true;
+}
+
+bool LibretroVulkanHostDisplay::DoneRenderContextCurrent()
+{
+  return true;
+}
+
+bool LibretroVulkanHostDisplay::CreateResources()
+{
+  static constexpr char fullscreen_quad_vertex_shader[] = R"(
+#version 450 core
+
+layout(push_constant) uniform PushConstants {
+  uniform vec4 u_src_rect;
+};
+
+layout(location = 0) out vec2 v_tex0;
+
+void main()
+{
+  vec2 pos = vec2(float((gl_VertexIndex << 1) & 2), float(gl_VertexIndex & 2));
+  v_tex0 = u_src_rect.xy + pos * u_src_rect.zw;
+  gl_Position = vec4(pos * vec2(2.0f, -2.0f) + vec2(-1.0f, 1.0f), 0.0f, 1.0f);
+  gl_Position.y = -gl_Position.y;
+}
+)";
+
+  static constexpr char display_fragment_shader_src[] = R"(
+#version 450 core
+
+layout(set = 0, binding = 0) uniform sampler2D samp0;
+
+layout(location = 0) in vec2 v_tex0;
+layout(location = 0) out vec4 o_col0;
+
+void main()
+{
+  o_col0 = vec4(texture(samp0, v_tex0).rgb, 1.0);
+}
+)";
+
+  static constexpr char cursor_fragment_shader_src[] = R"(
+#version 450 core
+
+layout(set = 0, binding = 0) uniform sampler2D samp0;
+
+layout(location = 0) in vec2 v_tex0;
+layout(location = 0) out vec4 o_col0;
+
+void main()
+{
+  o_col0 = texture(samp0, v_tex0);
+}
+)";
+
+  VkDevice device = g_vulkan_context->GetDevice();
+  VkPipelineCache pipeline_cache = g_vulkan_shader_cache->GetPipelineCache();
+
+  m_frame_render_pass = g_vulkan_context->GetRenderPass(FRAMEBUFFER_FORMAT, VK_FORMAT_UNDEFINED, VK_SAMPLE_COUNT_1_BIT,
+                                                        VK_ATTACHMENT_LOAD_OP_CLEAR);
+  if (m_frame_render_pass == VK_NULL_HANDLE)
+    return false;
+
+  Vulkan::DescriptorSetLayoutBuilder dslbuilder;
+  dslbuilder.AddBinding(0, VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER, 1, VK_SHADER_STAGE_FRAGMENT_BIT);
+  m_descriptor_set_layout = dslbuilder.Create(device);
+  if (m_descriptor_set_layout == VK_NULL_HANDLE)
+    return false;
+
+  Vulkan::PipelineLayoutBuilder plbuilder;
+  plbuilder.AddDescriptorSet(m_descriptor_set_layout);
+  plbuilder.AddPushConstants(VK_SHADER_STAGE_VERTEX_BIT, 0, sizeof(PushConstants));
+  m_pipeline_layout = plbuilder.Create(device);
+  if (m_pipeline_layout == VK_NULL_HANDLE)
+    return false;
+
+  VkShaderModule vertex_shader = g_vulkan_shader_cache->GetVertexShader(fullscreen_quad_vertex_shader);
+  if (vertex_shader == VK_NULL_HANDLE)
+    return false;
+
+  VkShaderModule display_fragment_shader = g_vulkan_shader_cache->GetFragmentShader(display_fragment_shader_src);
+  VkShaderModule cursor_fragment_shader = g_vulkan_shader_cache->GetFragmentShader(cursor_fragment_shader_src);
+  if (display_fragment_shader == VK_NULL_HANDLE || cursor_fragment_shader == VK_NULL_HANDLE)
+    return false;
+
+  Vulkan::GraphicsPipelineBuilder gpbuilder;
+  gpbuilder.SetVertexShader(vertex_shader);
+  gpbuilder.SetFragmentShader(display_fragment_shader);
+  gpbuilder.SetPrimitiveTopology(VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST);
+  gpbuilder.SetNoCullRasterizationState();
+  gpbuilder.SetNoDepthTestState();
+  gpbuilder.SetNoBlendingState();
+  gpbuilder.SetDynamicViewportAndScissorState();
+  gpbuilder.SetPipelineLayout(m_pipeline_layout);
+  gpbuilder.SetRenderPass(m_frame_render_pass, 0);
+
+  m_display_pipeline = gpbuilder.Create(device, pipeline_cache, false);
+  if (m_display_pipeline == VK_NULL_HANDLE)
+    return false;
+
+  gpbuilder.SetFragmentShader(cursor_fragment_shader);
+  gpbuilder.SetBlendAttachment(0, true, VK_BLEND_FACTOR_SRC_ALPHA, VK_BLEND_FACTOR_ONE_MINUS_SRC_ALPHA, VK_BLEND_OP_ADD,
+                               VK_BLEND_FACTOR_ONE, VK_BLEND_FACTOR_ZERO, VK_BLEND_OP_ADD);
+  m_cursor_pipeline = gpbuilder.Create(device, pipeline_cache, false);
+  if (m_cursor_pipeline == VK_NULL_HANDLE)
+    return false;
+
+  // don't need these anymore
+  vkDestroyShaderModule(device, vertex_shader, nullptr);
+  vkDestroyShaderModule(device, display_fragment_shader, nullptr);
+  vkDestroyShaderModule(device, cursor_fragment_shader, nullptr);
+
+  Vulkan::SamplerBuilder sbuilder;
+  sbuilder.SetPointSampler(VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_BORDER);
+  m_point_sampler = sbuilder.Create(device, true);
+  if (m_point_sampler == VK_NULL_HANDLE)
+    return false;
+
+  sbuilder.SetLinearSampler(false, VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_BORDER);
+  m_linear_sampler = sbuilder.Create(device);
+  if (m_linear_sampler == VK_NULL_HANDLE)
+    return false;
+
+  return true;
+}
+
+void LibretroVulkanHostDisplay::DestroyResources()
+{
+  Vulkan::Util::SafeDestroyFramebuffer(m_frame_framebuffer);
+  m_frame_texture.Destroy();
+
+  m_display_pixels_texture.Destroy(false);
+  m_readback_staging_texture.Destroy(false);
+  m_upload_staging_texture.Destroy(false);
+
+  Vulkan::Util::SafeDestroyPipeline(m_display_pipeline);
+  Vulkan::Util::SafeDestroyPipeline(m_cursor_pipeline);
+  Vulkan::Util::SafeDestroyPipelineLayout(m_pipeline_layout);
+  Vulkan::Util::SafeDestroyDescriptorSetLayout(m_descriptor_set_layout);
+  Vulkan::Util::SafeDestroySampler(m_point_sampler);
+  Vulkan::Util::SafeDestroySampler(m_linear_sampler);
+
+  m_frame_render_pass = VK_NULL_HANDLE;
+
+  Vulkan::ShaderCompiler::DeinitializeGlslang();
+}
+
+void LibretroVulkanHostDisplay::ResizeRenderWindow(s32 new_window_width, s32 new_window_height)
+{
+  m_window_info.surface_width = static_cast<u32>(new_window_width);
+  m_window_info.surface_height = static_cast<u32>(new_window_height);
+}
+
+bool LibretroVulkanHostDisplay::ChangeRenderWindow(const WindowInfo& new_wi)
+{
+  // re-query hardware render interface - in vulkan, things get recreated without us being notified
+  retro_hw_render_interface* ri = nullptr;
+  if (!g_retro_environment_callback(RETRO_ENVIRONMENT_GET_HW_RENDER_INTERFACE, &ri))
+  {
+    Log_ErrorPrint("Failed to get HW render interface");
+    return false;
+  }
+  else if (ri->interface_type != RETRO_HW_RENDER_INTERFACE_VULKAN ||
+           ri->interface_version != RETRO_HW_RENDER_INTERFACE_VULKAN_VERSION)
+  {
+    Log_ErrorPrintf("Unexpected HW interface - type %u version %u", static_cast<unsigned>(ri->interface_type),
+                    static_cast<unsigned>(ri->interface_version));
+    return false;
+  }
+
+  retro_hw_render_interface_vulkan* vri = reinterpret_cast<retro_hw_render_interface_vulkan*>(ri);
+  if (vri != m_ri)
+  {
+    Log_WarningPrintf("HW render interface pointer changed without us being notified, this might cause issues?");
+    m_ri = vri;
+  }
+
+  return true;
+}
+
+bool LibretroVulkanHostDisplay::CreateImGuiContext()
+{
+  return false;
+}
+
+void LibretroVulkanHostDisplay::DestroyImGuiContext() {}
+
+bool LibretroVulkanHostDisplay::UpdateImGuiFontTexture()
+{
+  return false;
+}
+
+bool LibretroVulkanHostDisplay::Render()
+{
+  const u32 resolution_scale = g_libretro_host_interface.GetResolutionScale();
+  const u32 display_width = static_cast<u32>(m_display_width) * resolution_scale;
+  const u32 display_height = static_cast<u32>(m_display_height) * resolution_scale;
+  if (display_width == 0 || display_height == 0 || !CheckFramebufferSize(display_width, display_height))
+    return false;
+
+  VkCommandBuffer cmdbuffer = g_vulkan_context->GetCurrentCommandBuffer();
+  m_frame_texture.OverrideImageLayout(m_frame_view.image_layout);
+  m_frame_texture.TransitionToLayout(cmdbuffer, VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL);
+
+  const VkClearValue clear_value = {};
+  const VkRenderPassBeginInfo rp = {
+    VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO,  nullptr, m_frame_render_pass, m_frame_framebuffer,
+    {{0, 0}, {display_width, display_height}}, 1u,      &clear_value};
+  vkCmdBeginRenderPass(cmdbuffer, &rp, VK_SUBPASS_CONTENTS_INLINE);
+
+  if (HasDisplayTexture())
+  {
+    const auto [left, top, width, height] = CalculateDrawRect(display_width, display_height, 0, false);
+    RenderDisplay(left, top, width, height, m_display_texture_handle, m_display_texture_width, m_display_texture_height,
+                  m_display_texture_view_x, m_display_texture_view_y, m_display_texture_view_width,
+                  m_display_texture_view_height, m_display_linear_filtering);
+  }
+
+  vkCmdEndRenderPass(cmdbuffer);
+  m_frame_texture.TransitionToLayout(cmdbuffer, VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL);
+  m_frame_view.image_layout = m_frame_texture.GetLayout();
+  m_ri->set_image(m_ri->handle, &m_frame_view, 0, nullptr, VK_QUEUE_FAMILY_IGNORED);
+
+  // TODO: We can't use this because it doesn't support passing fences...
+  // m_ri.set_command_buffers(m_ri.handle, 1, &cmdbuffer);
+  m_ri->lock_queue(m_ri->handle);
+  g_vulkan_context->SubmitCommandBuffer();
+  m_ri->unlock_queue(m_ri->handle);
+  g_vulkan_context->MoveToNextCommandBuffer();
+
+  g_retro_video_refresh_callback(RETRO_HW_FRAME_BUFFER_VALID, display_width, display_height, 0);
+  return true;
+}
+
+bool LibretroVulkanHostDisplay::RenderScreenshot(u32 width, u32 height, std::vector<u32>* out_pixels, u32* out_stride,
+                                                 HostDisplayPixelFormat* out_format)
+{
+  *out_format = HostDisplayPixelFormat::RGBA8;
+  *out_stride = sizeof(u32) * width;
+  out_pixels->resize(width * height);
+
+  // if we don't have a texture (display off), then just write out nothing.
+  if (!HasDisplayTexture())
+  {
+    std::fill(out_pixels->begin(), out_pixels->end(), static_cast<u32>(0));
+    return true;
+  }
+
+  Vulkan::Texture tex;
+  Vulkan::StagingTexture staging_tex;
+  if (!tex.Create(width, height, 1, 1, FRAMEBUFFER_FORMAT, VK_SAMPLE_COUNT_1_BIT, VK_IMAGE_VIEW_TYPE_2D,
+                  VK_IMAGE_TILING_OPTIMAL, VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT | VK_IMAGE_USAGE_TRANSFER_SRC_BIT) ||
+      !staging_tex.Create(Vulkan::StagingBuffer::Type::Readback, FRAMEBUFFER_FORMAT, width, height))
+  {
+    return false;
+  }
+
+  const VkFramebuffer fb = tex.CreateFramebuffer(m_frame_render_pass);
+  if (!fb)
+    return false;
+
+  tex.TransitionToLayout(g_vulkan_context->GetCurrentCommandBuffer(), VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL);
+
+  const VkClearValue clear_value = {};
+  const VkRenderPassBeginInfo rp = {VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO,
+                                    nullptr,
+                                    m_frame_render_pass,
+                                    fb,
+                                    {{0, 0}, {width, height}},
+                                    1u,
+                                    &clear_value};
+  vkCmdBeginRenderPass(g_vulkan_context->GetCurrentCommandBuffer(), &rp, VK_SUBPASS_CONTENTS_INLINE);
+
+  const auto [left, top, draw_width, draw_height] = CalculateDrawRect(width, height, 0);
+  RenderDisplay(left, top, draw_width, draw_height, m_display_texture_handle, m_display_texture_width,
+                m_display_texture_height, m_display_texture_view_x, m_display_texture_view_y,
+                m_display_texture_view_width, m_display_texture_view_height, m_display_linear_filtering);
+
+  vkCmdEndRenderPass(g_vulkan_context->GetCurrentCommandBuffer());
+  tex.TransitionToLayout(g_vulkan_context->GetCurrentCommandBuffer(), VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL);
+  staging_tex.CopyFromTexture(tex, 0, 0, 0, 0, 0, 0, width, height);
+  staging_tex.ReadTexels(0, 0, width, height, out_pixels->data(), *out_stride);
+
+  // destroying these immediately should be safe since nothing's going to access them, and it's not part of the command
+  // stream
+  vkDestroyFramebuffer(g_vulkan_context->GetDevice(), fb, nullptr);
+  staging_tex.Destroy(false);
+  tex.Destroy(false);
+  return true;
+}
+
+void LibretroVulkanHostDisplay::RenderDisplay(s32 left, s32 top, s32 width, s32 height, void* texture_handle,
+                                              u32 texture_width, s32 texture_height, s32 texture_view_x,
+                                              s32 texture_view_y, s32 texture_view_width, s32 texture_view_height,
+                                              bool linear_filter)
+{
+  VkCommandBuffer cmdbuffer = g_vulkan_context->GetCurrentCommandBuffer();
+
+  VkDescriptorSet ds = g_vulkan_context->AllocateDescriptorSet(m_descriptor_set_layout);
+  if (ds == VK_NULL_HANDLE)
+  {
+    Log_ErrorPrintf("Skipping rendering display because of no descriptor set");
+    return;
+  }
+
+  {
+    const Vulkan::Texture* vktex = static_cast<Vulkan::Texture*>(texture_handle);
+    Vulkan::DescriptorSetUpdateBuilder dsupdate;
+    dsupdate.AddCombinedImageSamplerDescriptorWrite(
+      ds, 0, vktex->GetView(), linear_filter ? m_linear_sampler : m_point_sampler, vktex->GetLayout());
+    dsupdate.Update(g_vulkan_context->GetDevice());
+  }
+
+  const float position_adjust = m_display_linear_filtering ? 0.5f : 0.0f;
+  const float size_adjust = m_display_linear_filtering ? 1.0f : 0.0f;
+  const PushConstants pc{(static_cast<float>(texture_view_x) + position_adjust) / static_cast<float>(texture_width),
+                         (static_cast<float>(texture_view_y) + position_adjust) / static_cast<float>(texture_height),
+                         (static_cast<float>(texture_view_width) - size_adjust) / static_cast<float>(texture_width),
+                         (static_cast<float>(texture_view_height) - size_adjust) / static_cast<float>(texture_height)};
+
+  vkCmdBindPipeline(cmdbuffer, VK_PIPELINE_BIND_POINT_GRAPHICS, m_display_pipeline);
+  vkCmdPushConstants(cmdbuffer, m_pipeline_layout, VK_SHADER_STAGE_VERTEX_BIT, 0, sizeof(pc), &pc);
+  vkCmdBindDescriptorSets(cmdbuffer, VK_PIPELINE_BIND_POINT_GRAPHICS, m_pipeline_layout, 0, 1, &ds, 0, nullptr);
+  Vulkan::Util::SetViewportAndScissor(cmdbuffer, left, top, width, height);
+  vkCmdDraw(cmdbuffer, 3, 1, 0, 0);
+}
+
+bool LibretroVulkanHostDisplay::CheckFramebufferSize(u32 width, u32 height)
+{
+  static constexpr VkImageUsageFlags usage = VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT | VK_IMAGE_USAGE_TRANSFER_SRC_BIT |
+                                             VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT;
+  static constexpr VkImageViewType view_type = VK_IMAGE_VIEW_TYPE_2D;
+  static constexpr VkImageTiling tiling = VK_IMAGE_TILING_OPTIMAL;
+
+  if (m_frame_texture.GetWidth() == width && m_frame_texture.GetHeight() == height)
+    return true;
+
+  g_vulkan_context->DeferFramebufferDestruction(m_frame_framebuffer);
+  m_frame_texture.Destroy(true);
+
+  if (!m_frame_texture.Create(width, height, 1, 1, FRAMEBUFFER_FORMAT, VK_SAMPLE_COUNT_1_BIT, view_type, tiling, usage))
+    return false;
+
+  VkCommandBuffer cmdbuf = g_vulkan_context->GetCurrentCommandBuffer();
+  m_frame_texture.TransitionToLayout(cmdbuf, VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL);
+
+  static constexpr VkClearColorValue cc = {};
+  static constexpr VkImageSubresourceRange range = {VK_IMAGE_ASPECT_COLOR_BIT, 0, 1, 0, 1};
+  vkCmdClearColorImage(cmdbuf, m_frame_texture.GetImage(), m_frame_texture.GetLayout(), &cc, 1, &range);
+
+  Vulkan::FramebufferBuilder fbb;
+  fbb.SetRenderPass(m_frame_render_pass);
+  fbb.AddAttachment(m_frame_texture.GetView());
+  fbb.SetSize(width, height, 1);
+  m_frame_framebuffer = fbb.Create(g_vulkan_context->GetDevice(), false);
+  if (m_frame_framebuffer == VK_NULL_HANDLE)
+    return false;
+
+  m_frame_view = {};
+  m_frame_view.image_view = m_frame_texture.GetView();
+  m_frame_view.image_layout = m_frame_texture.GetLayout();
+  m_frame_view.create_info.sType = VK_STRUCTURE_TYPE_IMAGE_VIEW_CREATE_INFO;
+  m_frame_view.create_info.image = m_frame_texture.GetImage();
+  m_frame_view.create_info.viewType = view_type;
+  m_frame_view.create_info.format = FRAMEBUFFER_FORMAT;
+  m_frame_view.create_info.components = {VK_COMPONENT_SWIZZLE_R, VK_COMPONENT_SWIZZLE_G, VK_COMPONENT_SWIZZLE_B,
+                                         VK_COMPONENT_SWIZZLE_A};
+  m_frame_view.create_info.subresourceRange = range;
+  return true;
+}
diff -Naur duckstation-51041e47f70123eda41d999701f5651830a0a95e.orig/src/duckstation-libretro/libretro_vulkan_host_display.h duckstation-51041e47f70123eda41d999701f5651830a0a95e/src/duckstation-libretro/libretro_vulkan_host_display.h
--- duckstation-51041e47f70123eda41d999701f5651830a0a95e.orig/src/duckstation-libretro/libretro_vulkan_host_display.h	1970-01-01 01:00:00.000000000 +0100
+++ duckstation-51041e47f70123eda41d999701f5651830a0a95e/src/duckstation-libretro/libretro_vulkan_host_display.h	2022-01-12 18:30:18.000000000 +0000
@@ -0,0 +1,108 @@
+#pragma once
+#include "common/vulkan/staging_texture.h"
+#include "common/vulkan/stream_buffer.h"
+#include "common/vulkan/texture.h"
+#include "core/host_display.h"
+#include "libretro.h"
+
+#define HAVE_VULKAN
+#include "libretro_vulkan.h"
+
+class LibretroVulkanHostDisplay final : public HostDisplay
+{
+public:
+  LibretroVulkanHostDisplay();
+  ~LibretroVulkanHostDisplay();
+
+  static bool RequestHardwareRendererContext(retro_hw_render_callback* cb);
+
+  RenderAPI GetRenderAPI() const override;
+  void* GetRenderDevice() const override;
+  void* GetRenderContext() const override;
+
+  bool HasRenderDevice() const override;
+  bool HasRenderSurface() const override;
+
+  bool CreateRenderDevice(const WindowInfo& wi, std::string_view adapter_name, bool debug_device,
+                          bool threaded_presentation) override;
+  bool InitializeRenderDevice(std::string_view shader_cache_directory, bool debug_device,
+                              bool threaded_presentation) override;
+  void DestroyRenderDevice() override;
+
+  bool MakeRenderContextCurrent() override;
+  bool DoneRenderContextCurrent() override;
+
+  void ResizeRenderWindow(s32 new_window_width, s32 new_window_height) override;
+
+  bool ChangeRenderWindow(const WindowInfo& new_wi) override;
+
+  bool SupportsFullscreen() const override;
+  bool IsFullscreen() override;
+  bool SetFullscreen(bool fullscreen, u32 width, u32 height, float refresh_rate) override;
+  AdapterAndModeList GetAdapterAndModeList() override;
+  void DestroyRenderSurface() override;
+
+  bool SetPostProcessingChain(const std::string_view& config) override;
+
+  std::unique_ptr<HostDisplayTexture> CreateTexture(u32 width, u32 height, u32 layers, u32 levels, u32 samples,
+                                                    HostDisplayPixelFormat format, const void* data, u32 data_stride,
+                                                    bool dynamic = false) override;
+  void UpdateTexture(HostDisplayTexture* texture, u32 x, u32 y, u32 width, u32 height, const void* texture_data,
+                     u32 texture_data_stride) override;
+  bool DownloadTexture(const void* texture_handle, HostDisplayPixelFormat texture_format, u32 x, u32 y, u32 width,
+                       u32 height, void* out_data, u32 out_data_stride) override;
+
+  bool SupportsDisplayPixelFormat(HostDisplayPixelFormat format) const override;
+  bool BeginSetDisplayPixels(HostDisplayPixelFormat format, u32 width, u32 height, void** out_buffer,
+                             u32* out_pitch) override;
+  void EndSetDisplayPixels() override;
+
+  void SetVSync(bool enabled) override;
+
+  bool Render() override;
+  bool RenderScreenshot(u32 width, u32 height, std::vector<u32>* out_pixels, u32* out_stride,
+                        HostDisplayPixelFormat* out_format) override;
+
+protected:
+  bool CreateResources() override;
+  void DestroyResources() override;
+
+  bool CreateImGuiContext() override;
+  void DestroyImGuiContext() override;
+  bool UpdateImGuiFontTexture() override;
+
+private:
+  static constexpr VkFormat FRAMEBUFFER_FORMAT = VK_FORMAT_R8G8B8A8_UNORM;
+
+  struct PushConstants
+  {
+    float src_rect_left;
+    float src_rect_top;
+    float src_rect_width;
+    float src_rect_height;
+  };
+
+  void RenderDisplay(s32 left, s32 top, s32 width, s32 height, void* texture_handle, u32 texture_width,
+                     s32 texture_height, s32 texture_view_x, s32 texture_view_y, s32 texture_view_width,
+                     s32 texture_view_height, bool linear_filter);
+
+  bool CheckFramebufferSize(u32 width, u32 height);
+
+  VkDescriptorSetLayout m_descriptor_set_layout = VK_NULL_HANDLE;
+  VkPipelineLayout m_pipeline_layout = VK_NULL_HANDLE;
+  VkPipeline m_cursor_pipeline = VK_NULL_HANDLE;
+  VkPipeline m_display_pipeline = VK_NULL_HANDLE;
+  VkSampler m_point_sampler = VK_NULL_HANDLE;
+  VkSampler m_linear_sampler = VK_NULL_HANDLE;
+
+  Vulkan::Texture m_display_pixels_texture;
+  Vulkan::StagingTexture m_upload_staging_texture;
+  Vulkan::StagingTexture m_readback_staging_texture;
+
+  retro_hw_render_interface_vulkan* m_ri = nullptr;
+
+  Vulkan::Texture m_frame_texture;
+  retro_vulkan_image m_frame_view = {};
+  VkFramebuffer m_frame_framebuffer = VK_NULL_HANDLE;
+  VkRenderPass m_frame_render_pass = VK_NULL_HANDLE;
+};
diff -Naur duckstation-51041e47f70123eda41d999701f5651830a0a95e.orig/src/duckstation-libretro/main.cpp duckstation-51041e47f70123eda41d999701f5651830a0a95e/src/duckstation-libretro/main.cpp
--- duckstation-51041e47f70123eda41d999701f5651830a0a95e.orig/src/duckstation-libretro/main.cpp	1970-01-01 01:00:00.000000000 +0100
+++ duckstation-51041e47f70123eda41d999701f5651830a0a95e/src/duckstation-libretro/main.cpp	2022-01-15 21:21:51.256498685 +0000
@@ -0,0 +1,153 @@
+#include "common/assert.h"
+#include "common/log.h"
+#include "libretro_host_interface.h"
+#include "scmversion/scmversion.h"
+Log_SetChannel(Main);
+
+RETRO_API unsigned retro_api_version(void)
+{
+  return RETRO_API_VERSION;
+}
+
+RETRO_API void retro_init(void)
+{
+  // default log to stdout until we get an interface
+  Log::SetConsoleOutputParams(true, nullptr, LOGLEVEL_INFO);
+
+  if (!g_libretro_host_interface.Initialize())
+    Panic("Host interface initialization failed");
+}
+
+RETRO_API void retro_deinit(void)
+{
+  g_libretro_host_interface.Shutdown();
+}
+
+RETRO_API void retro_get_system_info(struct retro_system_info* info)
+{
+  std::memset(info, 0, sizeof(*info));
+
+#if defined(_DEBUGFAST)
+  info->library_name = "SwanStation DebugFast";
+#elif defined(_DEBUG)
+  info->library_name = "SwanStation Debug";
+#else
+  info->library_name = "SwanStation";
+#endif
+
+  info->library_version = g_scm_hash_str;
+  info->valid_extensions = "exe|psexe|cue|bin|img|iso|chd|pbp|ecm|mds|psf|m3u";
+  info->need_fullpath = true;
+  info->block_extract = false;
+}
+
+RETRO_API void retro_get_system_av_info(struct retro_system_av_info* info)
+{
+  g_libretro_host_interface.retro_get_system_av_info(info);
+}
+
+RETRO_API void retro_set_controller_port_device(unsigned port, unsigned device)
+{
+  g_libretro_host_interface.retro_set_controller_port_device(port, device);
+}
+
+RETRO_API void retro_reset(void)
+{
+  Log_InfoPrint("retro_reset()");
+  g_libretro_host_interface.ResetSystem();
+}
+
+RETRO_API void retro_run(void)
+{
+  g_libretro_host_interface.retro_run_frame();
+}
+
+RETRO_API size_t retro_serialize_size(void)
+{
+  return g_libretro_host_interface.retro_serialize_size();
+}
+
+RETRO_API bool retro_serialize(void* data, size_t size)
+{
+  return g_libretro_host_interface.retro_serialize(data, size);
+}
+
+RETRO_API bool retro_unserialize(const void* data, size_t size)
+{
+  return g_libretro_host_interface.retro_unserialize(data, size);
+}
+
+RETRO_API void retro_cheat_reset(void)
+{
+  Log_InfoPrint("retro_cheat_reset()");
+  g_libretro_host_interface.retro_cheat_reset();
+}
+
+RETRO_API void retro_cheat_set(unsigned index, bool enabled, const char* code)
+{
+  Log_InfoPrintf("retro_cheat_set(%u, %u, %s)", index, enabled, code);
+  g_libretro_host_interface.retro_cheat_set(index, enabled, code);
+}
+
+RETRO_API bool retro_load_game(const struct retro_game_info* game)
+{
+  Log_InfoPrintf("retro_load_game(%s)", game->path);
+  return g_libretro_host_interface.retro_load_game(game);
+}
+
+RETRO_API bool retro_load_game_special(unsigned game_type, const struct retro_game_info* info, size_t num_info)
+{
+  Log_ErrorPrintf("retro_load_game_special()");
+  return false;
+}
+
+RETRO_API void retro_unload_game(void)
+{
+  g_libretro_host_interface.DestroySystem();
+}
+
+RETRO_API unsigned retro_get_region(void)
+{
+  return g_libretro_host_interface.retro_get_region();
+}
+
+RETRO_API void* retro_get_memory_data(unsigned id)
+{
+  return g_libretro_host_interface.retro_get_memory_data(id);
+}
+
+RETRO_API size_t retro_get_memory_size(unsigned id)
+{
+  return g_libretro_host_interface.retro_get_memory_size(id);
+}
+
+RETRO_API void retro_set_environment(retro_environment_t f)
+{
+  g_retro_environment_callback = f;
+  g_libretro_host_interface.retro_set_environment();
+}
+
+RETRO_API void retro_set_video_refresh(retro_video_refresh_t f)
+{
+  g_retro_video_refresh_callback = f;
+}
+
+RETRO_API void retro_set_audio_sample(retro_audio_sample_t f)
+{
+  g_retro_audio_sample_callback = f;
+}
+
+RETRO_API void retro_set_audio_sample_batch(retro_audio_sample_batch_t f)
+{
+  g_retro_audio_sample_batch_callback = f;
+}
+
+RETRO_API void retro_set_input_poll(retro_input_poll_t f)
+{
+  g_retro_input_poll_callback = f;
+}
+
+RETRO_API void retro_set_input_state(retro_input_state_t f)
+{
+  g_retro_input_state_callback = f;
+}
diff -Naur duckstation-51041e47f70123eda41d999701f5651830a0a95e.orig/src/duckstation-libretro/retro_inline.h duckstation-51041e47f70123eda41d999701f5651830a0a95e/src/duckstation-libretro/retro_inline.h
--- duckstation-51041e47f70123eda41d999701f5651830a0a95e.orig/src/duckstation-libretro/retro_inline.h	1970-01-01 01:00:00.000000000 +0100
+++ duckstation-51041e47f70123eda41d999701f5651830a0a95e/src/duckstation-libretro/retro_inline.h	2022-01-12 18:30:18.000000000 +0000
@@ -0,0 +1,39 @@
+/* Copyright  (C) 2010-2020 The RetroArch team
+ *
+ * ---------------------------------------------------------------------------------------
+ * The following license statement only applies to this file (retro_inline.h).
+ * ---------------------------------------------------------------------------------------
+ *
+ * Permission is hereby granted, free of charge,
+ * to any person obtaining a copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation the rights to
+ * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software,
+ * and to permit persons to whom the Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
+ * INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
+ * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
+ * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+#ifndef __LIBRETRO_SDK_INLINE_H
+#define __LIBRETRO_SDK_INLINE_H
+
+#ifndef INLINE
+
+#if defined(_WIN32) || defined(__INTEL_COMPILER)
+#define INLINE __inline
+#elif defined(__STDC_VERSION__) && __STDC_VERSION__>=199901L
+#define INLINE inline
+#elif defined(__GNUC__)
+#define INLINE __inline__
+#else
+#define INLINE
+#endif
+
+#endif
+#endif
