diff --git a/src/core/CMakeLists.txt b/src/core/CMakeLists.txt
index f507b5dc4..ae71ccc37 100644
--- a/src/core/CMakeLists.txt
+++ b/src/core/CMakeLists.txt
@@ -247,8 +247,6 @@ add_library(citra_core STATIC
     hle/service/cam/cam_s.h
     hle/service/cam/cam_u.cpp
     hle/service/cam/cam_u.h
-    hle/service/cam/y2r_u.cpp
-    hle/service/cam/y2r_u.h
     hle/service/cecd/cecd.cpp
     hle/service/cecd/cecd.h
     hle/service/cecd/cecd_ndm.cpp
@@ -281,8 +279,8 @@ add_library(citra_core STATIC
     hle/service/dlp/dlp_srvr.h
     hle/service/dsp/dsp_dsp.cpp
     hle/service/dsp/dsp_dsp.h
-    hle/service/err/err_f.cpp
-    hle/service/err/err_f.h
+    hle/service/err_f.cpp
+    hle/service/err_f.h
     hle/service/frd/frd.cpp
     hle/service/frd/frd.h
     hle/service/frd/frd_a.cpp
@@ -309,8 +307,8 @@ add_library(citra_core STATIC
     hle/service/hid/hid_spvr.h
     hle/service/hid/hid_user.cpp
     hle/service/hid/hid_user.h
-    hle/service/http/http_c.cpp
-    hle/service/http/http_c.h
+    hle/service/http_c.cpp
+    hle/service/http_c.h
     hle/service/ir/extra_hid.cpp
     hle/service/ir/extra_hid.h
     hle/service/ir/ir.cpp
@@ -325,8 +323,8 @@ add_library(citra_core STATIC
     hle/service/ldr_ro/cro_helper.h
     hle/service/ldr_ro/ldr_ro.cpp
     hle/service/ldr_ro/ldr_ro.h
-    hle/service/mic/mic_u.cpp
-    hle/service/mic/mic_u.h
+    hle/service/mic_u.cpp
+    hle/service/mic_u.h
     hle/service/mvd/mvd.cpp
     hle/service/mvd/mvd.h
     hle/service/mvd/mvd_std.cpp
@@ -423,10 +421,12 @@ add_library(citra_core STATIC
     hle/service/sm/sm.h
     hle/service/sm/srv.cpp
     hle/service/sm/srv.h
-    hle/service/soc/soc_u.cpp
-    hle/service/soc/soc_u.h
-    hle/service/ssl/ssl_c.cpp
-    hle/service/ssl/ssl_c.h
+    hle/service/soc_u.cpp
+    hle/service/soc_u.h
+    hle/service/ssl_c.cpp
+    hle/service/ssl_c.h
+    hle/service/y2r_u.cpp
+    hle/service/y2r_u.h
     hw/aes/arithmetic128.cpp
     hw/aes/arithmetic128.h
     hw/aes/ccm.cpp
diff --git a/src/core/core.cpp b/src/core/core.cpp
index 97f71d7d6..5f2cb6714 100644
--- a/src/core/core.cpp
+++ b/src/core/core.cpp
@@ -36,7 +36,7 @@
 #include "core/hle/service/fs/archive.h"
 #include "core/hle/service/gsp/gsp.h"
 #include "core/hle/service/ir/ir_rst.h"
-#include "core/hle/service/mic/mic_u.h"
+#include "core/hle/service/mic_u.h"
 #include "core/hle/service/plgldr/plgldr.h"
 #include "core/hle/service/service.h"
 #include "core/hle/service/sm/sm.h"
diff --git a/src/core/hle/service/ac/ac.cpp b/src/core/hle/service/ac/ac.cpp
index c1a61126b..3293eb611 100644
--- a/src/core/hle/service/ac/ac.cpp
+++ b/src/core/hle/service/ac/ac.cpp
@@ -16,7 +16,7 @@
 #include "core/hle/service/ac/ac.h"
 #include "core/hle/service/ac/ac_i.h"
 #include "core/hle/service/ac/ac_u.h"
-#include "core/hle/service/soc/soc_u.h"
+#include "core/hle/service/soc_u.h"
 #include "core/memory.h"
 
 namespace Service::AC {
diff --git a/src/core/hle/service/cam/y2r_u.cpp b/src/core/hle/service/cam/y2r_u.cpp
deleted file mode 100644
index db1b52f15..000000000
--- a/src/core/hle/service/cam/y2r_u.cpp
+++ /dev/null
@@ -1,710 +0,0 @@
-// Copyright 2015 Citra Emulator Project
-// Licensed under GPLv2 or any later version
-// Refer to the license.txt file included.
-
-#include <array>
-#include <cstring>
-#include "common/archives.h"
-#include "common/common_funcs.h"
-#include "common/logging/log.h"
-#include "core/core.h"
-#include "core/hle/ipc_helpers.h"
-#include "core/hle/kernel/event.h"
-#include "core/hle/kernel/process.h"
-#include "core/hle/service/cam/y2r_u.h"
-#include "core/hw/y2r.h"
-
-SERVICE_CONSTRUCT_IMPL(Service::Y2R::Y2R_U)
-SERIALIZE_EXPORT_IMPL(Service::Y2R::Y2R_U)
-
-namespace Service::Y2R {
-
-template <class Archive>
-void Y2R_U::serialize(Archive& ar, const unsigned int) {
-    ar& boost::serialization::base_object<Kernel::SessionRequestHandler>(*this);
-    ar& completion_event;
-    ar& conversion;
-    ar& dithering_weight_params;
-    ar& temporal_dithering_enabled;
-    ar& transfer_end_interrupt_enabled;
-    ar& spacial_dithering_enabled;
-}
-
-constexpr std::array<CoefficientSet, 4> standard_coefficients{{
-    {{0x100, 0x166, 0xB6, 0x58, 0x1C5, -0x166F, 0x10EE, -0x1C5B}}, // ITU_Rec601
-    {{0x100, 0x193, 0x77, 0x2F, 0x1DB, -0x1933, 0xA7C, -0x1D51}},  // ITU_Rec709
-    {{0x12A, 0x198, 0xD0, 0x64, 0x204, -0x1BDE, 0x10F2, -0x229B}}, // ITU_Rec601_Scaling
-    {{0x12A, 0x1CA, 0x88, 0x36, 0x21C, -0x1F04, 0x99C, -0x2421}},  // ITU_Rec709_Scaling
-}};
-
-ResultCode ConversionConfiguration::SetInputLineWidth(u16 width) {
-    if (width == 0 || width > 1024 || width % 8 != 0) {
-        return ResultCode(ErrorDescription::OutOfRange, ErrorModule::CAM,
-                          ErrorSummary::InvalidArgument, ErrorLevel::Usage); // 0xE0E053FD
-    }
-
-    // Note: The hardware uses the register value 0 to represent a width of 1024, so for a width of
-    // 1024 the `camera` module would set the value 0 here, but we don't need to emulate this
-    // internal detail.
-    this->input_line_width = width;
-    return RESULT_SUCCESS;
-}
-
-ResultCode ConversionConfiguration::SetInputLines(u16 lines) {
-    if (lines == 0 || lines > 1024) {
-        return ResultCode(ErrorDescription::OutOfRange, ErrorModule::CAM,
-                          ErrorSummary::InvalidArgument, ErrorLevel::Usage); // 0xE0E053FD
-    }
-
-    // Note: In what appears to be a bug, the `camera` module does not set the hardware register at
-    // all if `lines` is 1024, so the conversion uses the last value that was set. The intention
-    // was probably to set it to 0 like in SetInputLineWidth.
-    if (lines != 1024) {
-        this->input_lines = lines;
-    }
-    return RESULT_SUCCESS;
-}
-
-ResultCode ConversionConfiguration::SetStandardCoefficient(
-    StandardCoefficient standard_coefficient) {
-    const auto index = static_cast<std::size_t>(standard_coefficient);
-    if (index >= standard_coefficients.size()) {
-        return ResultCode(ErrorDescription::InvalidEnumValue, ErrorModule::CAM,
-                          ErrorSummary::InvalidArgument, ErrorLevel::Usage); // 0xE0E053ED
-    }
-
-    std::memcpy(coefficients.data(), standard_coefficients[index].data(), sizeof(coefficients));
-    return RESULT_SUCCESS;
-}
-
-void Y2R_U::SetInputFormat(Kernel::HLERequestContext& ctx) {
-    IPC::RequestParser rp(ctx);
-
-    conversion.input_format = rp.PopEnum<InputFormat>();
-
-    IPC::RequestBuilder rb = rp.MakeBuilder(1, 0);
-    rb.Push(RESULT_SUCCESS);
-
-    LOG_DEBUG(Service_Y2R, "called input_format={}", conversion.input_format);
-}
-
-void Y2R_U::GetInputFormat(Kernel::HLERequestContext& ctx) {
-    IPC::RequestParser rp(ctx);
-
-    IPC::RequestBuilder rb = rp.MakeBuilder(2, 0);
-    rb.Push(RESULT_SUCCESS);
-    rb.PushEnum(conversion.input_format);
-
-    LOG_DEBUG(Service_Y2R, "called input_format={}", conversion.input_format);
-}
-
-void Y2R_U::SetOutputFormat(Kernel::HLERequestContext& ctx) {
-    IPC::RequestParser rp(ctx);
-
-    conversion.output_format = rp.PopEnum<OutputFormat>();
-
-    IPC::RequestBuilder rb = rp.MakeBuilder(1, 0);
-    rb.Push(RESULT_SUCCESS);
-
-    LOG_DEBUG(Service_Y2R, "called output_format={}", conversion.output_format);
-}
-
-void Y2R_U::GetOutputFormat(Kernel::HLERequestContext& ctx) {
-    IPC::RequestParser rp(ctx);
-
-    IPC::RequestBuilder rb = rp.MakeBuilder(2, 0);
-    rb.Push(RESULT_SUCCESS);
-    rb.PushEnum(conversion.output_format);
-
-    LOG_DEBUG(Service_Y2R, "called output_format={}", conversion.output_format);
-}
-
-void Y2R_U::SetRotation(Kernel::HLERequestContext& ctx) {
-    IPC::RequestParser rp(ctx);
-
-    conversion.rotation = rp.PopEnum<Rotation>();
-
-    IPC::RequestBuilder rb = rp.MakeBuilder(1, 0);
-    rb.Push(RESULT_SUCCESS);
-
-    LOG_DEBUG(Service_Y2R, "called rotation={}", conversion.rotation);
-}
-
-void Y2R_U::GetRotation(Kernel::HLERequestContext& ctx) {
-    IPC::RequestParser rp(ctx);
-
-    IPC::RequestBuilder rb = rp.MakeBuilder(2, 0);
-    rb.Push(RESULT_SUCCESS);
-    rb.PushEnum(conversion.rotation);
-
-    LOG_DEBUG(Service_Y2R, "called rotation={}", conversion.rotation);
-}
-
-void Y2R_U::SetBlockAlignment(Kernel::HLERequestContext& ctx) {
-    IPC::RequestParser rp(ctx);
-
-    conversion.block_alignment = rp.PopEnum<BlockAlignment>();
-
-    IPC::RequestBuilder rb = rp.MakeBuilder(1, 0);
-    rb.Push(RESULT_SUCCESS);
-
-    LOG_DEBUG(Service_Y2R, "called block_alignment={}", conversion.block_alignment);
-}
-
-void Y2R_U::GetBlockAlignment(Kernel::HLERequestContext& ctx) {
-    IPC::RequestParser rp(ctx);
-
-    IPC::RequestBuilder rb = rp.MakeBuilder(2, 0);
-    rb.Push(RESULT_SUCCESS);
-    rb.PushEnum(conversion.block_alignment);
-
-    LOG_DEBUG(Service_Y2R, "called block_alignment={}", conversion.block_alignment);
-}
-
-void Y2R_U::SetSpacialDithering(Kernel::HLERequestContext& ctx) {
-    IPC::RequestParser rp(ctx);
-
-    spacial_dithering_enabled = rp.Pop<bool>();
-
-    IPC::RequestBuilder rb = rp.MakeBuilder(1, 0);
-    rb.Push(RESULT_SUCCESS);
-
-    LOG_DEBUG(Service_Y2R, "(STUBBED) called");
-}
-
-void Y2R_U::GetSpacialDithering(Kernel::HLERequestContext& ctx) {
-    IPC::RequestParser rp(ctx);
-
-    IPC::RequestBuilder rb = rp.MakeBuilder(2, 0);
-    rb.Push(RESULT_SUCCESS);
-    rb.Push(spacial_dithering_enabled);
-
-    LOG_DEBUG(Service_Y2R, "(STUBBED) called");
-}
-
-void Y2R_U::SetTemporalDithering(Kernel::HLERequestContext& ctx) {
-    IPC::RequestParser rp(ctx);
-    temporal_dithering_enabled = rp.Pop<bool>();
-
-    IPC::RequestBuilder rb = rp.MakeBuilder(1, 0);
-    rb.Push(RESULT_SUCCESS);
-
-    LOG_DEBUG(Service_Y2R, "(STUBBED) called");
-}
-
-void Y2R_U::GetTemporalDithering(Kernel::HLERequestContext& ctx) {
-    IPC::RequestParser rp(ctx);
-
-    IPC::RequestBuilder rb = rp.MakeBuilder(2, 0);
-    rb.Push(RESULT_SUCCESS);
-    rb.Push(temporal_dithering_enabled);
-
-    LOG_DEBUG(Service_Y2R, "(STUBBED) called");
-}
-
-void Y2R_U::SetTransferEndInterrupt(Kernel::HLERequestContext& ctx) {
-    IPC::RequestParser rp(ctx);
-    transfer_end_interrupt_enabled = rp.Pop<bool>();
-
-    IPC::RequestBuilder rb = rp.MakeBuilder(1, 0);
-    rb.Push(RESULT_SUCCESS);
-
-    LOG_DEBUG(Service_Y2R, "(STUBBED) called");
-}
-
-void Y2R_U::GetTransferEndInterrupt(Kernel::HLERequestContext& ctx) {
-    IPC::RequestParser rp(ctx);
-
-    IPC::RequestBuilder rb = rp.MakeBuilder(2, 0);
-    rb.Push(RESULT_SUCCESS);
-    rb.Push(transfer_end_interrupt_enabled);
-
-    LOG_DEBUG(Service_Y2R, "(STUBBED) called");
-}
-
-void Y2R_U::GetTransferEndEvent(Kernel::HLERequestContext& ctx) {
-    IPC::RequestParser rp(ctx);
-
-    IPC::RequestBuilder rb = rp.MakeBuilder(1, 2);
-    rb.Push(RESULT_SUCCESS);
-    rb.PushCopyObjects(completion_event);
-
-    LOG_DEBUG(Service_Y2R, "called");
-}
-
-void Y2R_U::SetSendingY(Kernel::HLERequestContext& ctx) {
-    IPC::RequestParser rp(ctx);
-    conversion.src_Y.address = rp.Pop<u32>();
-    conversion.src_Y.image_size = rp.Pop<u32>();
-    conversion.src_Y.transfer_unit = rp.Pop<u32>();
-    conversion.src_Y.gap = rp.Pop<u32>();
-    auto process = rp.PopObject<Kernel::Process>();
-    // TODO (wwylele): pass process handle to y2r engine or convert VAddr to PAddr
-
-    IPC::RequestBuilder rb = rp.MakeBuilder(1, 0);
-    rb.Push(RESULT_SUCCESS);
-
-    LOG_DEBUG(Service_Y2R,
-              "called image_size=0x{:08X}, transfer_unit={}, transfer_stride={}, "
-              "src_process_id={}",
-              conversion.src_Y.image_size, conversion.src_Y.transfer_unit, conversion.src_Y.gap,
-              process->process_id);
-}
-
-void Y2R_U::SetSendingU(Kernel::HLERequestContext& ctx) {
-    IPC::RequestParser rp(ctx);
-    conversion.src_U.address = rp.Pop<u32>();
-    conversion.src_U.image_size = rp.Pop<u32>();
-    conversion.src_U.transfer_unit = rp.Pop<u32>();
-    conversion.src_U.gap = rp.Pop<u32>();
-    auto process = rp.PopObject<Kernel::Process>();
-    // TODO (wwylele): pass the process handle to y2r engine or convert VAddr to PAddr
-
-    IPC::RequestBuilder rb = rp.MakeBuilder(1, 0);
-    rb.Push(RESULT_SUCCESS);
-
-    LOG_DEBUG(Service_Y2R,
-              "called image_size=0x{:08X}, transfer_unit={}, transfer_stride={}, "
-              "src_process_id={}",
-              conversion.src_U.image_size, conversion.src_U.transfer_unit, conversion.src_U.gap,
-              process->process_id);
-}
-
-void Y2R_U::SetSendingV(Kernel::HLERequestContext& ctx) {
-    IPC::RequestParser rp(ctx);
-
-    conversion.src_V.address = rp.Pop<u32>();
-    conversion.src_V.image_size = rp.Pop<u32>();
-    conversion.src_V.transfer_unit = rp.Pop<u32>();
-    conversion.src_V.gap = rp.Pop<u32>();
-    auto process = rp.PopObject<Kernel::Process>();
-    // TODO (wwylele): pass the process handle to y2r engine or convert VAddr to PAddr
-
-    IPC::RequestBuilder rb = rp.MakeBuilder(1, 0);
-    rb.Push(RESULT_SUCCESS);
-
-    LOG_DEBUG(Service_Y2R,
-              "called image_size=0x{:08X}, transfer_unit={}, transfer_stride={}, "
-              "src_process_id={}",
-              conversion.src_V.image_size, conversion.src_V.transfer_unit, conversion.src_V.gap,
-              process->process_id);
-}
-
-void Y2R_U::SetSendingYUYV(Kernel::HLERequestContext& ctx) {
-    IPC::RequestParser rp(ctx);
-
-    conversion.src_YUYV.address = rp.Pop<u32>();
-    conversion.src_YUYV.image_size = rp.Pop<u32>();
-    conversion.src_YUYV.transfer_unit = rp.Pop<u32>();
-    conversion.src_YUYV.gap = rp.Pop<u32>();
-    auto process = rp.PopObject<Kernel::Process>();
-    // TODO (wwylele): pass the process handle to y2r engine or convert VAddr to PAddr
-
-    IPC::RequestBuilder rb = rp.MakeBuilder(1, 0);
-    rb.Push(RESULT_SUCCESS);
-
-    LOG_DEBUG(Service_Y2R,
-              "called image_size=0x{:08X}, transfer_unit={}, transfer_stride={}, "
-              "src_process_id={}",
-              conversion.src_YUYV.image_size, conversion.src_YUYV.transfer_unit,
-              conversion.src_YUYV.gap, process->process_id);
-}
-
-void Y2R_U::IsFinishedSendingYuv(Kernel::HLERequestContext& ctx) {
-    IPC::RequestParser rp(ctx);
-
-    IPC::RequestBuilder rb = rp.MakeBuilder(2, 0);
-    rb.Push(RESULT_SUCCESS);
-    rb.Push<u8>(1);
-
-    LOG_DEBUG(Service_Y2R, "(STUBBED) called");
-}
-
-void Y2R_U::IsFinishedSendingY(Kernel::HLERequestContext& ctx) {
-    IPC::RequestParser rp(ctx);
-
-    IPC::RequestBuilder rb = rp.MakeBuilder(2, 0);
-    rb.Push(RESULT_SUCCESS);
-    rb.Push<u8>(1);
-
-    LOG_DEBUG(Service_Y2R, "(STUBBED) called");
-}
-
-void Y2R_U::IsFinishedSendingU(Kernel::HLERequestContext& ctx) {
-    IPC::RequestParser rp(ctx);
-
-    IPC::RequestBuilder rb = rp.MakeBuilder(2, 0);
-    rb.Push(RESULT_SUCCESS);
-    rb.Push<u8>(1);
-
-    LOG_DEBUG(Service_Y2R, "(STUBBED) called");
-}
-
-void Y2R_U::IsFinishedSendingV(Kernel::HLERequestContext& ctx) {
-    IPC::RequestParser rp(ctx);
-
-    IPC::RequestBuilder rb = rp.MakeBuilder(2, 0);
-    rb.Push(RESULT_SUCCESS);
-    rb.Push<u8>(1);
-
-    LOG_DEBUG(Service_Y2R, "(STUBBED) called");
-}
-
-void Y2R_U::SetReceiving(Kernel::HLERequestContext& ctx) {
-    IPC::RequestParser rp(ctx);
-
-    conversion.dst.address = rp.Pop<u32>();
-    conversion.dst.image_size = rp.Pop<u32>();
-    conversion.dst.transfer_unit = rp.Pop<u32>();
-    conversion.dst.gap = rp.Pop<u32>();
-    auto dst_process = rp.PopObject<Kernel::Process>();
-    // TODO (wwylele): pass the process handle to y2r engine or convert VAddr to PAddr
-
-    IPC::RequestBuilder rb = rp.MakeBuilder(1, 0);
-    rb.Push(RESULT_SUCCESS);
-
-    LOG_DEBUG(Service_Y2R,
-              "called image_size=0x{:08X}, transfer_unit={}, transfer_stride={}, "
-              "dst_process_id={}",
-              conversion.dst.image_size, conversion.dst.transfer_unit, conversion.dst.gap,
-              static_cast<u32>(dst_process->process_id));
-}
-
-void Y2R_U::IsFinishedReceiving(Kernel::HLERequestContext& ctx) {
-    IPC::RequestParser rp(ctx);
-
-    IPC::RequestBuilder rb = rp.MakeBuilder(2, 0);
-    rb.Push(RESULT_SUCCESS);
-    rb.Push<u8>(1);
-
-    LOG_DEBUG(Service_Y2R, "(STUBBED) called");
-}
-
-void Y2R_U::SetInputLineWidth(Kernel::HLERequestContext& ctx) {
-    IPC::RequestParser rp(ctx);
-    u32 input_line_width = rp.Pop<u32>();
-
-    IPC::RequestBuilder rb = rp.MakeBuilder(1, 0);
-    rb.Push(conversion.SetInputLineWidth(input_line_width));
-
-    LOG_DEBUG(Service_Y2R, "called input_line_width={}", input_line_width);
-}
-
-void Y2R_U::GetInputLineWidth(Kernel::HLERequestContext& ctx) {
-    IPC::RequestParser rp(ctx);
-
-    IPC::RequestBuilder rb = rp.MakeBuilder(2, 0);
-    rb.Push(RESULT_SUCCESS);
-    rb.Push(conversion.input_line_width);
-
-    LOG_DEBUG(Service_Y2R, "called input_line_width={}", conversion.input_line_width);
-}
-
-void Y2R_U::SetInputLines(Kernel::HLERequestContext& ctx) {
-    IPC::RequestParser rp(ctx);
-    u32 input_lines = rp.Pop<u32>();
-
-    IPC::RequestBuilder rb = rp.MakeBuilder(1, 0);
-    rb.Push(conversion.SetInputLines(input_lines));
-
-    LOG_DEBUG(Service_Y2R, "called input_lines={}", input_lines);
-}
-
-void Y2R_U::GetInputLines(Kernel::HLERequestContext& ctx) {
-    IPC::RequestParser rp(ctx);
-
-    IPC::RequestBuilder rb = rp.MakeBuilder(2, 0);
-    rb.Push(RESULT_SUCCESS);
-    rb.Push(static_cast<u32>(conversion.input_lines));
-
-    LOG_DEBUG(Service_Y2R, "called input_lines={}", conversion.input_lines);
-}
-
-void Y2R_U::SetCoefficient(Kernel::HLERequestContext& ctx) {
-    IPC::RequestParser rp(ctx);
-
-    rp.PopRaw<CoefficientSet>(conversion.coefficients);
-
-    IPC::RequestBuilder rb = rp.MakeBuilder(1, 0);
-    rb.Push(RESULT_SUCCESS);
-
-    LOG_DEBUG(Service_Y2R, "called coefficients=[{:X}, {:X}, {:X}, {:X}, {:X}, {:X}, {:X}, {:X}]",
-              conversion.coefficients[0], conversion.coefficients[1], conversion.coefficients[2],
-              conversion.coefficients[3], conversion.coefficients[4], conversion.coefficients[5],
-              conversion.coefficients[6], conversion.coefficients[7]);
-}
-
-void Y2R_U::GetCoefficient(Kernel::HLERequestContext& ctx) {
-    IPC::RequestParser rp(ctx);
-
-    IPC::RequestBuilder rb = rp.MakeBuilder(5, 0);
-    rb.Push(RESULT_SUCCESS);
-    rb.PushRaw(conversion.coefficients);
-
-    LOG_DEBUG(Service_Y2R, "called");
-}
-
-void Y2R_U::SetStandardCoefficient(Kernel::HLERequestContext& ctx) {
-    IPC::RequestParser rp(ctx);
-    u32 index = rp.Pop<u32>();
-
-    IPC::RequestBuilder rb = rp.MakeBuilder(1, 0);
-    rb.Push(conversion.SetStandardCoefficient(static_cast<StandardCoefficient>(index)));
-
-    LOG_DEBUG(Service_Y2R, "called standard_coefficient={}", index);
-}
-
-void Y2R_U::GetStandardCoefficient(Kernel::HLERequestContext& ctx) {
-    IPC::RequestParser rp(ctx);
-    const u32 index = rp.Pop<u32>();
-
-    if (index < standard_coefficients.size()) {
-        IPC::RequestBuilder rb = rp.MakeBuilder(5, 0);
-        rb.Push(RESULT_SUCCESS);
-        rb.PushRaw(standard_coefficients[index]);
-
-        LOG_DEBUG(Service_Y2R, "called standard_coefficient={} ", index);
-    } else {
-        IPC::RequestBuilder rb = rp.MakeBuilder(1, 0);
-        rb.Push(ResultCode(ErrorDescription::InvalidEnumValue, ErrorModule::CAM,
-                           ErrorSummary::InvalidArgument, ErrorLevel::Usage));
-
-        LOG_ERROR(Service_Y2R, "called standard_coefficient={}  The argument is invalid!", index);
-    }
-}
-
-void Y2R_U::SetAlpha(Kernel::HLERequestContext& ctx) {
-    IPC::RequestParser rp(ctx);
-    conversion.alpha = rp.Pop<u32>();
-
-    IPC::RequestBuilder rb = rp.MakeBuilder(1, 0);
-    rb.Push(RESULT_SUCCESS);
-
-    LOG_DEBUG(Service_Y2R, "called alpha={}", conversion.alpha);
-}
-
-void Y2R_U::GetAlpha(Kernel::HLERequestContext& ctx) {
-    IPC::RequestParser rp(ctx);
-
-    IPC::RequestBuilder rb = rp.MakeBuilder(2, 0);
-    rb.Push(RESULT_SUCCESS);
-    rb.Push(conversion.alpha);
-
-    LOG_DEBUG(Service_Y2R, "called alpha={}", conversion.alpha);
-}
-
-void Y2R_U::SetDitheringWeightParams(Kernel::HLERequestContext& ctx) {
-    IPC::RequestParser rp(ctx);
-    rp.PopRaw(dithering_weight_params);
-    IPC::RequestBuilder rb = rp.MakeBuilder(1, 0);
-    rb.Push(RESULT_SUCCESS);
-
-    LOG_DEBUG(Service_Y2R, "called");
-}
-
-void Y2R_U::GetDitheringWeightParams(Kernel::HLERequestContext& ctx) {
-    IPC::RequestParser rp(ctx);
-
-    IPC::RequestBuilder rb = rp.MakeBuilder(9, 0);
-    rb.Push(RESULT_SUCCESS);
-    rb.PushRaw(dithering_weight_params);
-
-    LOG_DEBUG(Service_Y2R, "called");
-}
-
-void Y2R_U::StartConversion(Kernel::HLERequestContext& ctx) {
-    IPC::RequestParser rp(ctx);
-
-    // dst_image_size would seem to be perfect for this, but it doesn't include the gap :(
-    u32 total_output_size =
-        conversion.input_lines * (conversion.dst.transfer_unit + conversion.dst.gap);
-    Memory::RasterizerFlushVirtualRegion(conversion.dst.address, total_output_size,
-                                         Memory::FlushMode::FlushAndInvalidate);
-
-    HW::Y2R::PerformConversion(system.Memory(), conversion);
-
-    completion_event->Signal();
-
-    IPC::RequestBuilder rb = rp.MakeBuilder(1, 0);
-    rb.Push(RESULT_SUCCESS);
-
-    LOG_DEBUG(Service_Y2R, "called");
-}
-
-void Y2R_U::StopConversion(Kernel::HLERequestContext& ctx) {
-    IPC::RequestParser rp(ctx);
-
-    IPC::RequestBuilder rb = rp.MakeBuilder(1, 0);
-    rb.Push(RESULT_SUCCESS);
-
-    LOG_DEBUG(Service_Y2R, "called");
-}
-
-void Y2R_U::IsBusyConversion(Kernel::HLERequestContext& ctx) {
-    IPC::RequestParser rp(ctx);
-
-    IPC::RequestBuilder rb = rp.MakeBuilder(2, 0);
-    rb.Push(RESULT_SUCCESS);
-    rb.Push<u8>(0); // StartConversion always finishes immediately
-
-    LOG_DEBUG(Service_Y2R, "called");
-}
-
-void Y2R_U::SetPackageParameter(Kernel::HLERequestContext& ctx) {
-    IPC::RequestParser rp(ctx);
-    auto params = rp.PopRaw<ConversionParameters>();
-
-    conversion.input_format = params.input_format;
-    conversion.output_format = params.output_format;
-    conversion.rotation = params.rotation;
-    conversion.block_alignment = params.block_alignment;
-
-    ResultCode result = conversion.SetInputLineWidth(params.input_line_width);
-
-    if (result.IsError())
-        goto cleanup;
-
-    result = conversion.SetInputLines(params.input_lines);
-
-    if (result.IsError())
-        goto cleanup;
-
-    result = conversion.SetStandardCoefficient(params.standard_coefficient);
-
-    if (result.IsError())
-        goto cleanup;
-
-    conversion.padding = params.padding;
-    conversion.alpha = params.alpha;
-
-cleanup:
-    IPC::RequestBuilder rb = rp.MakeBuilder(1, 0);
-    rb.Push(result);
-
-    LOG_DEBUG(Service_Y2R,
-              "called input_format={} output_format={} rotation={} block_alignment={} "
-              "input_line_width={} input_lines={} standard_coefficient={} reserved={} alpha={:X}",
-              params.input_format, params.output_format, params.rotation, params.block_alignment,
-              params.input_line_width, params.input_lines, params.standard_coefficient,
-              params.padding, params.alpha);
-}
-
-void Y2R_U::PingProcess(Kernel::HLERequestContext& ctx) {
-    IPC::RequestParser rp(ctx);
-
-    IPC::RequestBuilder rb = rp.MakeBuilder(2, 0);
-    rb.Push(RESULT_SUCCESS);
-    rb.Push<u8>(0);
-
-    LOG_DEBUG(Service_Y2R, "(STUBBED) called");
-}
-
-void Y2R_U::DriverInitialize(Kernel::HLERequestContext& ctx) {
-    IPC::RequestParser rp(ctx);
-
-    IPC::RequestBuilder rb = rp.MakeBuilder(1, 0);
-
-    conversion.input_format = InputFormat::YUV422_Indiv8;
-    conversion.output_format = OutputFormat::RGBA8;
-    conversion.rotation = Rotation::None;
-    conversion.block_alignment = BlockAlignment::Linear;
-    conversion.coefficients.fill(0);
-    conversion.SetInputLineWidth(1024);
-    conversion.SetInputLines(1024);
-    conversion.alpha = 0;
-
-    ConversionBuffer zero_buffer = {};
-    conversion.src_Y = zero_buffer;
-    conversion.src_U = zero_buffer;
-    conversion.src_V = zero_buffer;
-    conversion.dst = zero_buffer;
-
-    completion_event->Clear();
-
-    rb.Push(RESULT_SUCCESS);
-
-    LOG_DEBUG(Service_Y2R, "called");
-}
-
-void Y2R_U::DriverFinalize(Kernel::HLERequestContext& ctx) {
-    IPC::RequestParser rp(ctx);
-
-    IPC::RequestBuilder rb = rp.MakeBuilder(1, 0);
-    rb.Push(RESULT_SUCCESS);
-
-    LOG_DEBUG(Service_Y2R, "called");
-}
-
-void Y2R_U::GetPackageParameter(Kernel::HLERequestContext& ctx) {
-    IPC::RequestParser rp(ctx);
-
-    IPC::RequestBuilder rb = rp.MakeBuilder(4, 0);
-    rb.Push(RESULT_SUCCESS);
-    rb.PushRaw(conversion);
-
-    LOG_DEBUG(Service_Y2R, "called");
-}
-
-Y2R_U::Y2R_U(Core::System& system) : ServiceFramework("y2r:u", 1), system(system) {
-    static const FunctionInfo functions[] = {
-        // clang-format off
-        {0x0001, &Y2R_U::SetInputFormat, "SetInputFormat"},
-        {0x0002, &Y2R_U::GetInputFormat, "GetInputFormat"},
-        {0x0003, &Y2R_U::SetOutputFormat, "SetOutputFormat"},
-        {0x0004, &Y2R_U::GetOutputFormat, "GetOutputFormat"},
-        {0x0005, &Y2R_U::SetRotation, "SetRotation"},
-        {0x0006, &Y2R_U::GetRotation, "GetRotation"},
-        {0x0007, &Y2R_U::SetBlockAlignment, "SetBlockAlignment"},
-        {0x0008, &Y2R_U::GetBlockAlignment, "GetBlockAlignment"},
-        {0x0009, &Y2R_U::SetSpacialDithering, "SetSpacialDithering"},
-        {0x000A, &Y2R_U::GetSpacialDithering, "GetSpacialDithering"},
-        {0x000B, &Y2R_U::SetTemporalDithering, "SetTemporalDithering"},
-        {0x000C, &Y2R_U::GetTemporalDithering, "GetTemporalDithering"},
-        {0x000D, &Y2R_U::SetTransferEndInterrupt, "SetTransferEndInterrupt"},
-        {0x000E, &Y2R_U::GetTransferEndInterrupt, "GetTransferEndInterrupt"},
-        {0x000F, &Y2R_U::GetTransferEndEvent, "GetTransferEndEvent"},
-        {0x0010, &Y2R_U::SetSendingY, "SetSendingY"},
-        {0x0011, &Y2R_U::SetSendingU, "SetSendingU"},
-        {0x0012, &Y2R_U::SetSendingV, "SetSendingV"},
-        {0x0013, &Y2R_U::SetSendingYUYV, "SetSendingYUYV"},
-        {0x0014, &Y2R_U::IsFinishedSendingYuv, "IsFinishedSendingYuv"},
-        {0x0015, &Y2R_U::IsFinishedSendingY, "IsFinishedSendingY"},
-        {0x0016, &Y2R_U::IsFinishedSendingU, "IsFinishedSendingU"},
-        {0x0017, &Y2R_U::IsFinishedSendingV, "IsFinishedSendingV"},
-        {0x0018, &Y2R_U::SetReceiving, "SetReceiving"},
-        {0x0019, &Y2R_U::IsFinishedReceiving, "IsFinishedReceiving"},
-        {0x001A, &Y2R_U::SetInputLineWidth, "SetInputLineWidth"},
-        {0x001B, &Y2R_U::GetInputLineWidth, "GetInputLineWidth"},
-        {0x001C, &Y2R_U::SetInputLines, "SetInputLines"},
-        {0x001D, &Y2R_U::GetInputLines, "GetInputLines"},
-        {0x001E, &Y2R_U::SetCoefficient, "SetCoefficient"},
-        {0x001F, &Y2R_U::GetCoefficient, "GetCoefficient"},
-        {0x0020, &Y2R_U::SetStandardCoefficient, "SetStandardCoefficient"},
-        {0x0021, &Y2R_U::GetStandardCoefficient, "GetStandardCoefficient"},
-        {0x0022, &Y2R_U::SetAlpha, "SetAlpha"},
-        {0x0023, &Y2R_U::GetAlpha, "GetAlpha"},
-        {0x0024, &Y2R_U::SetDitheringWeightParams, "SetDitheringWeightParams"},
-        {0x0025, &Y2R_U::GetDitheringWeightParams, "GetDitheringWeightParams"},
-        {0x0026, &Y2R_U::StartConversion, "StartConversion"},
-        {0x0027, &Y2R_U::StopConversion, "StopConversion"},
-        {0x0028, &Y2R_U::IsBusyConversion, "IsBusyConversion"},
-        {0x0029, &Y2R_U::SetPackageParameter, "SetPackageParameter"},
-        {0x002A, &Y2R_U::PingProcess, "PingProcess"},
-        {0x002B, &Y2R_U::DriverInitialize, "DriverInitialize"},
-        {0x002C, &Y2R_U::DriverFinalize, "DriverFinalize"},
-        {0x002D, &Y2R_U::GetPackageParameter, "GetPackageParameter"},
-        // clang-format on
-    };
-    RegisterHandlers(functions);
-
-    completion_event = system.Kernel().CreateEvent(Kernel::ResetType::OneShot, "Y2R:Completed");
-}
-
-Y2R_U::~Y2R_U() = default;
-
-void InstallInterfaces(Core::System& system) {
-    auto& service_manager = system.ServiceManager();
-    std::make_shared<Y2R_U>(system)->InstallAsService(service_manager);
-}
-
-} // namespace Service::Y2R
diff --git a/src/core/hle/service/cam/y2r_u.h b/src/core/hle/service/cam/y2r_u.h
deleted file mode 100644
index 1ac675f92..000000000
--- a/src/core/hle/service/cam/y2r_u.h
+++ /dev/null
@@ -1,368 +0,0 @@
-// Copyright 2014 Citra Emulator Project
-// Licensed under GPLv2 or any later version
-// Refer to the license.txt file included.
-
-#pragma once
-
-#include <array>
-#include <memory>
-#include <string>
-#include <boost/serialization/array.hpp>
-#include "common/common_types.h"
-#include "core/hle/result.h"
-#include "core/hle/service/service.h"
-
-namespace Core {
-class System;
-}
-
-namespace Kernel {
-class Event;
-}
-
-namespace Service::Y2R {
-
-enum class InputFormat : u8 {
-    /// 8-bit input, with YUV components in separate planes and 4:2:2 subsampling.
-    YUV422_Indiv8 = 0,
-    /// 8-bit input, with YUV components in separate planes and 4:2:0 subsampling.
-    YUV420_Indiv8 = 1,
-
-    /// 16-bit input (only LSB used), with YUV components in separate planes and 4:2:2 subsampling.
-    YUV422_Indiv16 = 2,
-    /// 16-bit input (only LSB used), with YUV components in separate planes and 4:2:0 subsampling.
-    YUV420_Indiv16 = 3,
-
-    /// 8-bit input, with a single interleaved stream in YUYV format and 4:2:2 subsampling.
-    YUYV422_Interleaved = 4,
-};
-
-enum class OutputFormat : u8 {
-    RGBA8 = 0,
-    RGB8 = 1,
-    RGB5A1 = 2,
-    RGB565 = 3,
-};
-
-enum class Rotation : u8 {
-    None = 0,
-    Clockwise_90 = 1,
-    Clockwise_180 = 2,
-    Clockwise_270 = 3,
-};
-
-enum class BlockAlignment : u8 {
-    /// Image is output in linear format suitable for use as a framebuffer.
-    Linear = 0,
-    /// Image is output in tiled PICA format, suitable for use as a texture.
-    Block8x8 = 1,
-};
-
-enum class StandardCoefficient : u8 {
-    /// ITU Rec. BT.601 primaries, with PC ranges.
-    ITU_Rec601 = 0,
-    /// ITU Rec. BT.709 primaries, with PC ranges.
-    ITU_Rec709 = 1,
-    /// ITU Rec. BT.601 primaries, with TV ranges.
-    ITU_Rec601_Scaling = 2,
-    /// ITU Rec. BT.709 primaries, with TV ranges.
-    ITU_Rec709_Scaling = 3,
-};
-
-/**
- * A set of coefficients configuring the RGB to YUV conversion. Coefficients 0-4 are unsigned 2.8
- * fixed pointer numbers representing entries on the conversion matrix, while coefficient 5-7 are
- * signed 11.5 fixed point numbers added as offsets to the RGB result.
- *
- * The overall conversion process formula is:
- * ```
- * R = trunc((c_0 * Y           + c_1 * V) + c_5 + 0.75)
- * G = trunc((c_0 * Y - c_3 * U - c_2 * V) + c_6 + 0.75)
- * B = trunc((c_0 * Y + c_4 * U          ) + c_7 + 0.75)
- * ```
- */
-using CoefficientSet = std::array<s16, 8>;
-
-struct ConversionBuffer {
-    /// Current reading/writing address of this buffer.
-    VAddr address;
-    /// Remaining amount of bytes to be DMAed, does not include the inter-trasfer gap.
-    u32 image_size;
-    /// Size of a single DMA transfer.
-    u16 transfer_unit;
-    /// Amount of bytes to be skipped between copying each `transfer_unit` bytes.
-    u16 gap;
-
-private:
-    template <class Archive>
-    void serialize(Archive& ar, const unsigned int) {
-        ar& address;
-        ar& image_size;
-        ar& transfer_unit;
-        ar& gap;
-    }
-    friend class boost::serialization::access;
-};
-
-struct ConversionConfiguration {
-    InputFormat input_format;
-    OutputFormat output_format;
-    Rotation rotation;
-    BlockAlignment block_alignment;
-    u16 input_line_width;
-    u16 input_lines;
-    CoefficientSet coefficients;
-    u8 padding;
-    u16 alpha;
-
-    /// Input parameters for the Y (luma) plane
-    ConversionBuffer src_Y, src_U, src_V, src_YUYV;
-    /// Output parameters for the conversion results
-    ConversionBuffer dst;
-
-    ResultCode SetInputLineWidth(u16 width);
-    ResultCode SetInputLines(u16 lines);
-    ResultCode SetStandardCoefficient(StandardCoefficient standard_coefficient);
-
-private:
-    template <class Archive>
-    void serialize(Archive& ar, const unsigned int) {
-        ar& input_format;
-        ar& output_format;
-        ar& rotation;
-        ar& block_alignment;
-        ar& input_line_width;
-        ar& input_lines;
-        ar& coefficients;
-        ar& padding;
-        ar& alpha;
-        ar& src_Y;
-        ar& src_U;
-        ar& src_V;
-        ar& src_YUYV;
-        ar& dst;
-    }
-    friend class boost::serialization::access;
-};
-
-struct DitheringWeightParams {
-    u16 w0_xEven_yEven;
-    u16 w0_xOdd_yEven;
-    u16 w0_xEven_yOdd;
-    u16 w0_xOdd_yOdd;
-    u16 w1_xEven_yEven;
-    u16 w1_xOdd_yEven;
-    u16 w1_xEven_yOdd;
-    u16 w1_xOdd_yOdd;
-    u16 w2_xEven_yEven;
-    u16 w2_xOdd_yEven;
-    u16 w2_xEven_yOdd;
-    u16 w2_xOdd_yOdd;
-    u16 w3_xEven_yEven;
-    u16 w3_xOdd_yEven;
-    u16 w3_xEven_yOdd;
-    u16 w3_xOdd_yOdd;
-
-private:
-    template <class Archive>
-    void serialize(Archive& ar, const unsigned int) {
-        ar& w0_xEven_yEven;
-        ar& w0_xOdd_yEven;
-        ar& w0_xEven_yOdd;
-        ar& w0_xOdd_yOdd;
-        ar& w1_xEven_yEven;
-        ar& w1_xOdd_yEven;
-        ar& w1_xEven_yOdd;
-        ar& w1_xOdd_yOdd;
-        ar& w2_xEven_yEven;
-        ar& w2_xOdd_yEven;
-        ar& w2_xEven_yOdd;
-        ar& w2_xOdd_yOdd;
-        ar& w3_xEven_yEven;
-        ar& w3_xOdd_yEven;
-        ar& w3_xEven_yOdd;
-        ar& w3_xOdd_yOdd;
-    }
-    friend class boost::serialization::access;
-};
-
-struct ConversionParameters {
-    InputFormat input_format;
-    OutputFormat output_format;
-    Rotation rotation;
-    BlockAlignment block_alignment;
-    u16 input_line_width;
-    u16 input_lines;
-    StandardCoefficient standard_coefficient;
-    u8 padding;
-    u16 alpha;
-};
-static_assert(sizeof(ConversionParameters) == 12, "ConversionParameters struct has incorrect size");
-
-class Y2R_U final : public ServiceFramework<Y2R_U> {
-public:
-    explicit Y2R_U(Core::System& system);
-    ~Y2R_U() override;
-
-private:
-    void SetInputFormat(Kernel::HLERequestContext& ctx);
-    void GetInputFormat(Kernel::HLERequestContext& ctx);
-    void SetOutputFormat(Kernel::HLERequestContext& ctx);
-    void GetOutputFormat(Kernel::HLERequestContext& ctx);
-    void SetRotation(Kernel::HLERequestContext& ctx);
-    void GetRotation(Kernel::HLERequestContext& ctx);
-    void SetBlockAlignment(Kernel::HLERequestContext& ctx);
-    void GetBlockAlignment(Kernel::HLERequestContext& ctx);
-
-    /**
-     * Y2R_U::SetSpacialDithering service function
-     *  Inputs:
-     *      1 : u8, 0 = Disabled, 1 = Enabled
-     *  Outputs:
-     *      1 : Result of function, 0 on success, otherwise error code
-     */
-    void SetSpacialDithering(Kernel::HLERequestContext& ctx);
-
-    /**
-     * Y2R_U::GetSpacialDithering service function
-     *  Outputs:
-     *      1 : Result of function, 0 on success, otherwise error code
-     *      2 : u8, 0 = Disabled, 1 = Enabled
-     */
-    void GetSpacialDithering(Kernel::HLERequestContext& ctx);
-
-    /**
-     * Y2R_U::SetTemporalDithering service function
-     *  Inputs:
-     *      1 : u8, 0 = Disabled, 1 = Enabled
-     *  Outputs:
-     *      1 : Result of function, 0 on success, otherwise error code
-     */
-    void SetTemporalDithering(Kernel::HLERequestContext& ctx);
-
-    /**
-     * Y2R_U::GetTemporalDithering service function
-     *  Outputs:
-     *      1 : Result of function, 0 on success, otherwise error code
-     *      2 : u8, 0 = Disabled, 1 = Enabled
-     */
-    void GetTemporalDithering(Kernel::HLERequestContext& ctx);
-
-    /**
-     * Y2R_U::SetTransferEndInterrupt service function
-     *  Inputs:
-     *      1 : u8, 0 = Disabled, 1 = Enabled
-     *  Outputs:
-     *      1 : Result of function, 0 on success, otherwise error code
-     */
-    void SetTransferEndInterrupt(Kernel::HLERequestContext& ctx);
-
-    /**
-     * Y2R_U::GetTransferEndInterrupt service function
-     *  Outputs:
-     *      1 : Result of function, 0 on success, otherwise error code
-     *      2 : u8, 0 = Disabled, 1 = Enabled
-     */
-    void GetTransferEndInterrupt(Kernel::HLERequestContext& ctx);
-
-    /**
-     * Y2R_U::GetTransferEndEvent service function
-     *  Outputs:
-     *      1 : Result of function, 0 on success, otherwise error code
-     *      3 : The handle of the completion event
-     */
-    void GetTransferEndEvent(Kernel::HLERequestContext& ctx);
-
-    void SetSendingY(Kernel::HLERequestContext& ctx);
-    void SetSendingU(Kernel::HLERequestContext& ctx);
-    void SetSendingV(Kernel::HLERequestContext& ctx);
-    void SetSendingYUYV(Kernel::HLERequestContext& ctx);
-
-    /**
-     * Y2R::IsFinishedSendingYuv service function
-     * Output:
-     *       1 : Result of the function, 0 on success, otherwise error code
-     *       2 : u8, 0 = Not Finished, 1 = Finished
-     */
-    void IsFinishedSendingYuv(Kernel::HLERequestContext& ctx);
-
-    /**
-     * Y2R::IsFinishedSendingY service function
-     * Output:
-     *       1 : Result of the function, 0 on success, otherwise error code
-     *       2 : u8, 0 = Not Finished, 1 = Finished
-     */
-    void IsFinishedSendingY(Kernel::HLERequestContext& ctx);
-
-    /**
-     * Y2R::IsFinishedSendingU service function
-     * Output:
-     *       1 : Result of the function, 0 on success, otherwise error code
-     *       2 : u8, 0 = Not Finished, 1 = Finished
-     */
-    void IsFinishedSendingU(Kernel::HLERequestContext& ctx);
-
-    /**
-     * Y2R::IsFinishedSendingV service function
-     * Output:
-     *       1 : Result of the function, 0 on success, otherwise error code
-     *       2 : u8, 0 = Not Finished, 1 = Finished
-     */
-    void IsFinishedSendingV(Kernel::HLERequestContext& ctx);
-
-    void SetReceiving(Kernel::HLERequestContext& ctx);
-
-    /**
-     * Y2R::IsFinishedReceiving service function
-     * Output:
-     *       1 : Result of the function, 0 on success, otherwise error code
-     *       2 : u8, 0 = Not Finished, 1 = Finished
-     */
-    void IsFinishedReceiving(Kernel::HLERequestContext& ctx);
-
-    void SetInputLineWidth(Kernel::HLERequestContext& ctx);
-    void GetInputLineWidth(Kernel::HLERequestContext& ctx);
-    void SetInputLines(Kernel::HLERequestContext& ctx);
-    void GetInputLines(Kernel::HLERequestContext& ctx);
-    void SetCoefficient(Kernel::HLERequestContext& ctx);
-    void GetCoefficient(Kernel::HLERequestContext& ctx);
-    void SetStandardCoefficient(Kernel::HLERequestContext& ctx);
-    void GetStandardCoefficient(Kernel::HLERequestContext& ctx);
-    void SetAlpha(Kernel::HLERequestContext& ctx);
-    void GetAlpha(Kernel::HLERequestContext& ctx);
-    void SetDitheringWeightParams(Kernel::HLERequestContext& ctx);
-    void GetDitheringWeightParams(Kernel::HLERequestContext& ctx);
-    void StartConversion(Kernel::HLERequestContext& ctx);
-    void StopConversion(Kernel::HLERequestContext& ctx);
-    void IsBusyConversion(Kernel::HLERequestContext& ctx);
-
-    /**
-     * Y2R_U::SetPackageParameter service function
-     */
-    void SetPackageParameter(Kernel::HLERequestContext& ctx);
-
-    void PingProcess(Kernel::HLERequestContext& ctx);
-    void DriverInitialize(Kernel::HLERequestContext& ctx);
-    void DriverFinalize(Kernel::HLERequestContext& ctx);
-    void GetPackageParameter(Kernel::HLERequestContext& ctx);
-
-    Core::System& system;
-
-    std::shared_ptr<Kernel::Event> completion_event;
-    ConversionConfiguration conversion{};
-    DitheringWeightParams dithering_weight_params{};
-    bool temporal_dithering_enabled = false;
-    bool transfer_end_interrupt_enabled = false;
-    bool spacial_dithering_enabled = false;
-
-    template <class Archive>
-    void serialize(Archive& ar, const unsigned int);
-    friend class boost::serialization::access;
-};
-
-void InstallInterfaces(Core::System& system);
-
-} // namespace Service::Y2R
-
-SERVICE_CONSTRUCT(Service::Y2R::Y2R_U)
-BOOST_CLASS_EXPORT_KEY(Service::Y2R::Y2R_U)
diff --git a/src/core/hle/service/err/err_f.cpp b/src/core/hle/service/err/err_f.cpp
deleted file mode 100644
index 896306cf1..000000000
--- a/src/core/hle/service/err/err_f.cpp
+++ /dev/null
@@ -1,267 +0,0 @@
-// Copyright 2014 Citra Emulator Project
-// Licensed under GPLv2 or any later version
-// Refer to the license.txt file included.
-
-#include <array>
-#include <chrono>
-#include <iomanip>
-#include <sstream>
-#include "common/archives.h"
-#include "common/bit_field.h"
-#include "common/common_types.h"
-#include "common/logging/log.h"
-#include "core/core.h"
-#include "core/hle/ipc.h"
-#include "core/hle/ipc_helpers.h"
-#include "core/hle/result.h"
-#include "core/hle/service/err/err_f.h"
-#undef exception_info // We use 'exception_info' as a plain identifier, but MSVC defines this in one
-                      // of its many headers.
-
-SERIALIZE_EXPORT_IMPL(Service::ERR::ERR_F)
-
-namespace boost::serialization {
-template <class Archive>
-void load_construct_data(Archive& ar, Service::ERR::ERR_F* t, const unsigned int) {
-    ::new (t) Service::ERR::ERR_F(Core::Global<Core::System>());
-}
-
-template void load_construct_data<iarchive>(iarchive& ar, Service::ERR::ERR_F* t,
-                                            const unsigned int);
-} // namespace boost::serialization
-
-namespace Service::ERR {
-
-enum class FatalErrType : u32 {
-    Generic = 0,
-    Corrupted = 1,
-    CardRemoved = 2,
-    Exception = 3,
-    ResultFailure = 4,
-    Logged = 5,
-};
-
-enum class ExceptionType : u32 {
-    PrefetchAbort = 0,
-    DataAbort = 1,
-    Undefined = 2,
-    VectorFP = 3,
-};
-
-struct ExceptionInfo {
-    u8 exception_type;
-    INSERT_PADDING_BYTES(3);
-    u32 sr;
-    u32 ar;
-    u32 fpexc;
-    u32 fpinst;
-    u32 fpinst2;
-};
-static_assert(sizeof(ExceptionInfo) == 0x18, "ExceptionInfo struct has incorrect size");
-
-struct ExceptionContext final {
-    std::array<u32, 16> arm_regs;
-    u32 cpsr;
-};
-static_assert(sizeof(ExceptionContext) == 0x44, "ExceptionContext struct has incorrect size");
-
-struct ExceptionData {
-    ExceptionInfo exception_info;
-    ExceptionContext exception_context;
-    INSERT_PADDING_WORDS(1);
-};
-static_assert(sizeof(ExceptionData) == 0x60, "ExceptionData struct has incorrect size");
-
-struct ErrInfo {
-    struct ErrInfoCommon {
-        u8 specifier;          // 0x0
-        u8 rev_high;           // 0x1
-        u16 rev_low;           // 0x2
-        u32 result_code;       // 0x4
-        u32 pc_address;        // 0x8
-        u32 pid;               // 0xC
-        u32 title_id_low;      // 0x10
-        u32 title_id_high;     // 0x14
-        u32 app_title_id_low;  // 0x18
-        u32 app_title_id_high; // 0x1C
-    } errinfo_common;
-    static_assert(sizeof(ErrInfoCommon) == 0x20, "ErrInfoCommon struct has incorrect size");
-
-    union {
-        struct {
-            char data[0x60]; // 0x20
-        } generic;
-
-        struct {
-            ExceptionData exception_data; // 0x20
-        } exception;
-
-        struct {
-            char message[0x60]; // 0x20
-        } result_failure;
-    };
-};
-
-static std::string GetErrType(u8 type_code) {
-    switch (static_cast<FatalErrType>(type_code)) {
-    case FatalErrType::Generic:
-        return "Generic";
-    case FatalErrType::Corrupted:
-        return "Corrupted";
-    case FatalErrType::CardRemoved:
-        return "CardRemoved";
-    case FatalErrType::Exception:
-        return "Exception";
-    case FatalErrType::ResultFailure:
-        return "ResultFailure";
-    case FatalErrType::Logged:
-        return "Logged";
-    default:
-        return "Unknown Error Type";
-    }
-}
-
-static std::string GetExceptionType(u8 type_code) {
-    switch (static_cast<ExceptionType>(type_code)) {
-    case ExceptionType::PrefetchAbort:
-        return "Prefetch Abort";
-    case ExceptionType::DataAbort:
-        return "Data Abort";
-    case ExceptionType::Undefined:
-        return "Undefined Exception";
-    case ExceptionType::VectorFP:
-        return "Vector Floating Point Exception";
-    default:
-        return "Unknown Exception Type";
-    }
-}
-
-static std::string GetCurrentSystemTime() {
-    auto now = std::chrono::system_clock::now();
-    auto time = std::chrono::system_clock::to_time_t(now);
-
-    std::stringstream time_stream;
-    time_stream << std::put_time(std::localtime(&time), "%Y/%m/%d %H:%M:%S");
-    return time_stream.str();
-}
-
-static void LogGenericInfo(const ErrInfo::ErrInfoCommon& errinfo_common) {
-    LOG_CRITICAL(Service_ERR, "PID: 0x{:08X}", errinfo_common.pid);
-    LOG_CRITICAL(Service_ERR, "REV: 0x{:08X}_0x{:08X}", errinfo_common.rev_high,
-                 errinfo_common.rev_low);
-    LOG_CRITICAL(Service_ERR, "TID: 0x{:08X}_0x{:08X}", errinfo_common.title_id_high,
-                 errinfo_common.title_id_low);
-    LOG_CRITICAL(Service_ERR, "AID: 0x{:08X}_0x{:08X}", errinfo_common.app_title_id_high,
-                 errinfo_common.app_title_id_low);
-    LOG_CRITICAL(Service_ERR, "ADR: 0x{:08X}", errinfo_common.pc_address);
-
-    ResultCode result_code{errinfo_common.result_code};
-    LOG_CRITICAL(Service_ERR, "RSL: 0x{:08X}", result_code.raw);
-    LOG_CRITICAL(Service_ERR, "  Level: {}", static_cast<u32>(result_code.level.Value()));
-    LOG_CRITICAL(Service_ERR, "  Summary: {}", static_cast<u32>(result_code.summary.Value()));
-    LOG_CRITICAL(Service_ERR, "  Module: {}", static_cast<u32>(result_code.module.Value()));
-    LOG_CRITICAL(Service_ERR, "  Desc: {}", static_cast<u32>(result_code.description.Value()));
-}
-
-void ERR_F::ThrowFatalError(Kernel::HLERequestContext& ctx) {
-    IPC::RequestParser rp(ctx);
-
-    LOG_CRITICAL(Service_ERR, "Fatal error");
-    const ErrInfo errinfo = rp.PopRaw<ErrInfo>();
-    LOG_CRITICAL(Service_ERR, "Fatal error type: {}", GetErrType(errinfo.errinfo_common.specifier));
-    system.SetStatus(Core::System::ResultStatus::ErrorUnknown);
-
-    // Generic Info
-    LogGenericInfo(errinfo.errinfo_common);
-
-    switch (static_cast<FatalErrType>(errinfo.errinfo_common.specifier)) {
-    case FatalErrType::Generic:
-    case FatalErrType::Corrupted:
-    case FatalErrType::CardRemoved:
-    case FatalErrType::Logged: {
-        LOG_CRITICAL(Service_ERR, "Datetime: {}", GetCurrentSystemTime());
-        break;
-    }
-    case FatalErrType::Exception: {
-        const auto& errtype = errinfo.exception;
-
-        // Register Info
-        LOG_CRITICAL(Service_ERR, "ARM Registers:");
-        for (u32 index = 0; index < errtype.exception_data.exception_context.arm_regs.size();
-             ++index) {
-            if (index < 13) {
-                LOG_DEBUG(Service_ERR, "r{}=0x{:08X}", index,
-                          errtype.exception_data.exception_context.arm_regs.at(index));
-            } else if (index == 13) {
-                LOG_CRITICAL(Service_ERR, "SP=0x{:08X}",
-                             errtype.exception_data.exception_context.arm_regs.at(index));
-            } else if (index == 14) {
-                LOG_CRITICAL(Service_ERR, "LR=0x{:08X}",
-                             errtype.exception_data.exception_context.arm_regs.at(index));
-            } else if (index == 15) {
-                LOG_CRITICAL(Service_ERR, "PC=0x{:08X}",
-                             errtype.exception_data.exception_context.arm_regs.at(index));
-            }
-        }
-        LOG_CRITICAL(Service_ERR, "CPSR=0x{:08X}", errtype.exception_data.exception_context.cpsr);
-
-        // Exception Info
-        LOG_CRITICAL(Service_ERR, "EXCEPTION TYPE: {}",
-                     GetExceptionType(errtype.exception_data.exception_info.exception_type));
-        switch (static_cast<ExceptionType>(errtype.exception_data.exception_info.exception_type)) {
-        case ExceptionType::PrefetchAbort:
-            LOG_CRITICAL(Service_ERR, "IFSR: 0x{:08X}", errtype.exception_data.exception_info.sr);
-            LOG_CRITICAL(Service_ERR, "r15: 0x{:08X}", errtype.exception_data.exception_info.ar);
-            break;
-        case ExceptionType::DataAbort:
-            LOG_CRITICAL(Service_ERR, "DFSR: 0x{:08X}", errtype.exception_data.exception_info.sr);
-            LOG_CRITICAL(Service_ERR, "DFAR: 0x{:08X}", errtype.exception_data.exception_info.ar);
-            break;
-        case ExceptionType::VectorFP:
-            LOG_CRITICAL(Service_ERR, "FPEXC: 0x{:08X}",
-                         errtype.exception_data.exception_info.fpinst);
-            LOG_CRITICAL(Service_ERR, "FINST: 0x{:08X}",
-                         errtype.exception_data.exception_info.fpinst);
-            LOG_CRITICAL(Service_ERR, "FINST2: 0x{:08X}",
-                         errtype.exception_data.exception_info.fpinst2);
-            break;
-        case ExceptionType::Undefined:
-            break; // Not logging exception_info for this case
-        }
-        LOG_CRITICAL(Service_ERR, "Datetime: {}", GetCurrentSystemTime());
-        break;
-    }
-
-    case FatalErrType::ResultFailure: {
-        const auto& errtype = errinfo.result_failure;
-
-        // Failure Message
-        LOG_CRITICAL(Service_ERR, "Failure Message: {}", errtype.message);
-        LOG_CRITICAL(Service_ERR, "Datetime: {}", GetCurrentSystemTime());
-        break;
-    }
-
-    } // switch FatalErrType
-
-    IPC::RequestBuilder rb = rp.MakeBuilder(1, 0);
-    rb.Push(RESULT_SUCCESS);
-}
-
-ERR_F::ERR_F(Core::System& system) : ServiceFramework("err:f", 1), system(system) {
-    static const FunctionInfo functions[] = {
-        // clang-format off
-        {0x0001, &ERR_F::ThrowFatalError, "ThrowFatalError"},
-        {0x0002, nullptr, "SetUserString"},
-        // clang-format on
-    };
-    RegisterHandlers(functions);
-}
-
-ERR_F::~ERR_F() = default;
-
-void InstallInterfaces(Core::System& system) {
-    auto errf = std::make_shared<ERR_F>(system);
-    errf->InstallAsNamedPort(system.Kernel());
-}
-
-} // namespace Service::ERR
diff --git a/src/core/hle/service/err/err_f.h b/src/core/hle/service/err/err_f.h
deleted file mode 100644
index 1b9fad452..000000000
--- a/src/core/hle/service/err/err_f.h
+++ /dev/null
@@ -1,50 +0,0 @@
-// Copyright 2014 Citra Emulator Project
-// Licensed under GPLv2 or any later version
-// Refer to the license.txt file included.
-
-#pragma once
-
-#include "core/hle/service/service.h"
-
-namespace Core {
-class System;
-}
-
-namespace Kernel {
-class HLERequestContext;
-}
-
-namespace Service::ERR {
-
-/// Interface to "err:f" service
-class ERR_F final : public ServiceFramework<ERR_F> {
-public:
-    explicit ERR_F(Core::System& system);
-    ~ERR_F();
-
-private:
-    /* ThrowFatalError function
-     * Inputs:
-     *       0 : Header code [0x00010800]
-     *    1-32 : FatalErrInfo
-     * Outputs:
-     *       0 : Header code
-     *       1 : Result code
-     */
-    void ThrowFatalError(Kernel::HLERequestContext& ctx);
-
-    Core::System& system;
-
-    SERVICE_SERIALIZATION_SIMPLE
-};
-
-void InstallInterfaces(Core::System& system);
-
-} // namespace Service::ERR
-
-BOOST_CLASS_EXPORT_KEY(Service::ERR::ERR_F)
-
-namespace boost::serialization {
-template <class Archive>
-void load_construct_data(Archive& ar, Service::ERR::ERR_F* t, const unsigned int);
-}
diff --git a/src/core/hle/service/http/http_c.cpp b/src/core/hle/service/http/http_c.cpp
deleted file mode 100644
index f3583982c..000000000
--- a/src/core/hle/service/http/http_c.cpp
+++ /dev/null
@@ -1,966 +0,0 @@
-// Copyright 2014 Citra Emulator Project
-// Licensed under GPLv2 or any later version
-// Refer to the license.txt file included.
-
-#include <atomic>
-#include <unordered_map>
-#include <cryptopp/aes.h>
-#include <cryptopp/modes.h>
-#include "common/archives.h"
-#include "common/assert.h"
-#include "core/core.h"
-#include "core/file_sys/archive_ncch.h"
-#include "core/file_sys/file_backend.h"
-#include "core/hle/ipc_helpers.h"
-#include "core/hle/kernel/ipc.h"
-#include "core/hle/romfs.h"
-#include "core/hle/service/fs/archive.h"
-#include "core/hle/service/http/http_c.h"
-#include "core/hw/aes/key.h"
-
-SERIALIZE_EXPORT_IMPL(Service::HTTP::HTTP_C)
-SERIALIZE_EXPORT_IMPL(Service::HTTP::SessionData)
-
-namespace Service::HTTP {
-
-namespace ErrCodes {
-enum {
-    InvalidRequestState = 22,
-    TooManyContexts = 26,
-    InvalidRequestMethod = 32,
-    ContextNotFound = 100,
-
-    /// This error is returned in multiple situations: when trying to initialize an
-    /// already-initialized session, or when using the wrong context handle in a context-bound
-    /// session
-    SessionStateError = 102,
-    TooManyClientCerts = 203,
-    NotImplemented = 1012,
-};
-}
-
-const ResultCode ERROR_STATE_ERROR = // 0xD8A0A066
-    ResultCode(ErrCodes::SessionStateError, ErrorModule::HTTP, ErrorSummary::InvalidState,
-               ErrorLevel::Permanent);
-const ResultCode ERROR_NOT_IMPLEMENTED = // 0xD960A3F4
-    ResultCode(ErrCodes::NotImplemented, ErrorModule::HTTP, ErrorSummary::Internal,
-               ErrorLevel::Permanent);
-const ResultCode ERROR_TOO_MANY_CLIENT_CERTS = // 0xD8A0A0CB
-    ResultCode(ErrCodes::TooManyClientCerts, ErrorModule::HTTP, ErrorSummary::InvalidState,
-               ErrorLevel::Permanent);
-const ResultCode ERROR_WRONG_CERT_ID = // 0xD8E0B839
-    ResultCode(57, ErrorModule::SSL, ErrorSummary::InvalidArgument, ErrorLevel::Permanent);
-const ResultCode ERROR_WRONG_CERT_HANDLE = // 0xD8A0A0C9
-    ResultCode(201, ErrorModule::HTTP, ErrorSummary::InvalidState, ErrorLevel::Permanent);
-const ResultCode ERROR_CERT_ALREADY_SET = // 0xD8A0A03D
-    ResultCode(61, ErrorModule::HTTP, ErrorSummary::InvalidState, ErrorLevel::Permanent);
-
-static std::pair<std::string, std::string> SplitUrl(const std::string& url) {
-    const std::string prefix = "://";
-    const auto scheme_end = url.find(prefix);
-    const auto prefix_end = scheme_end == std::string::npos ? 0 : scheme_end + prefix.length();
-
-    const auto path_index = url.find("/", prefix_end);
-    std::string host;
-    std::string path;
-    if (path_index == std::string::npos) {
-        // If no path is specified after the host, set it to "/"
-        host = url;
-        path = "/";
-    } else {
-        host = url.substr(0, path_index);
-        path = url.substr(path_index);
-    }
-    return std::make_pair(host, path);
-}
-
-void Context::MakeRequest() {
-    ASSERT(state == RequestState::NotStarted);
-
-#ifdef ENABLE_WEB_SERVICE
-    const auto& [host, path] = SplitUrl(url);
-    const auto client = std::make_unique<httplib::Client>(host);
-    SSL_CTX* ctx = client->ssl_context();
-    if (ctx) {
-        if (auto client_cert = ssl_config.client_cert_ctx.lock()) {
-            SSL_CTX_use_certificate_ASN1(ctx, static_cast<int>(client_cert->certificate.size()),
-                                         client_cert->certificate.data());
-            SSL_CTX_use_PrivateKey_ASN1(EVP_PKEY_RSA, ctx, client_cert->private_key.data(),
-                                        static_cast<long>(client_cert->private_key.size()));
-        }
-
-        // TODO(B3N30): Check for SSLOptions-Bits and set the verify method accordingly
-        // https://www.3dbrew.org/wiki/SSL_Services#SSLOpt
-        // Hack: Since for now RootCerts are not implemented we set the VerifyMode to None.
-        SSL_CTX_set_verify(ctx, SSL_VERIFY_NONE, NULL);
-    }
-
-    state = RequestState::InProgress;
-
-    static const std::unordered_map<RequestMethod, std::string> request_method_strings{
-        {RequestMethod::Get, "GET"},       {RequestMethod::Post, "POST"},
-        {RequestMethod::Head, "HEAD"},     {RequestMethod::Put, "PUT"},
-        {RequestMethod::Delete, "DELETE"}, {RequestMethod::PostEmpty, "POST"},
-        {RequestMethod::PutEmpty, "PUT"},
-    };
-
-    httplib::Request request;
-    httplib::Error error;
-    request.method = request_method_strings.at(method);
-    request.path = path;
-    // TODO(B3N30): Add post data body
-    request.progress = [this](u64 current, u64 total) -> bool {
-        // TODO(B3N30): Is there a state that shows response header are available
-        current_download_size_bytes = current;
-        total_download_size_bytes = total;
-        return true;
-    };
-
-    for (const auto& header : headers) {
-        request.headers.emplace(header.name, header.value);
-    }
-
-    if (!client->send(request, response, error)) {
-        LOG_ERROR(Service_HTTP, "Request failed: {}: {}", error, httplib::to_string(error));
-        state = RequestState::TimedOut;
-    } else {
-        LOG_DEBUG(Service_HTTP, "Request successful");
-        // TODO(B3N30): Verify this state on HW
-        state = RequestState::ReadyToDownloadContent;
-    }
-#else
-    LOG_ERROR(Service_HTTP, "Tried to make request but WebServices is not enabled in this build");
-    state = RequestState::TimedOut;
-#endif
-}
-
-void HTTP_C::Initialize(Kernel::HLERequestContext& ctx) {
-    IPC::RequestParser rp(ctx);
-    const u32 shmem_size = rp.Pop<u32>();
-    u32 pid = rp.PopPID();
-    shared_memory = rp.PopObject<Kernel::SharedMemory>();
-    if (shared_memory) {
-        shared_memory->SetName("HTTP_C:shared_memory");
-    }
-
-    LOG_WARNING(Service_HTTP, "(STUBBED) called, shared memory size: {} pid: {}", shmem_size, pid);
-
-    auto* session_data = GetSessionData(ctx.Session());
-    ASSERT(session_data);
-
-    if (session_data->initialized) {
-        LOG_ERROR(Service_HTTP, "Tried to initialize an already initialized session");
-        IPC::RequestBuilder rb = rp.MakeBuilder(1, 0);
-        rb.Push(ERROR_STATE_ERROR);
-        return;
-    }
-
-    session_data->initialized = true;
-    session_data->session_id = ++session_counter;
-
-    IPC::RequestBuilder rb = rp.MakeBuilder(1, 0);
-    // This returns 0xd8a0a046 if no network connection is available.
-    // Just assume we are always connected.
-    rb.Push(RESULT_SUCCESS);
-}
-
-void HTTP_C::InitializeConnectionSession(Kernel::HLERequestContext& ctx) {
-    IPC::RequestParser rp(ctx);
-    const Context::Handle context_handle = rp.Pop<u32>();
-    u32 pid = rp.PopPID();
-
-    LOG_DEBUG(Service_HTTP, "called, context_id={} pid={}", context_handle, pid);
-
-    auto* session_data = GetSessionData(ctx.Session());
-    ASSERT(session_data);
-
-    if (session_data->initialized) {
-        LOG_ERROR(Service_HTTP, "Tried to initialize an already initialized session");
-        IPC::RequestBuilder rb = rp.MakeBuilder(1, 0);
-        rb.Push(ERROR_STATE_ERROR);
-        return;
-    }
-
-    // TODO(Subv): Check that the input PID matches the PID that created the context.
-    auto itr = contexts.find(context_handle);
-    if (itr == contexts.end()) {
-        IPC::RequestBuilder rb = rp.MakeBuilder(1, 0);
-        rb.Push(ResultCode(ErrCodes::ContextNotFound, ErrorModule::HTTP, ErrorSummary::InvalidState,
-                           ErrorLevel::Permanent));
-        return;
-    }
-
-    session_data->initialized = true;
-    session_data->session_id = ++session_counter;
-    // Bind the context to the current session.
-    session_data->current_http_context = context_handle;
-
-    IPC::RequestBuilder rb = rp.MakeBuilder(1, 0);
-    rb.Push(RESULT_SUCCESS);
-}
-
-void HTTP_C::BeginRequest(Kernel::HLERequestContext& ctx) {
-    IPC::RequestParser rp(ctx);
-    const Context::Handle context_handle = rp.Pop<u32>();
-
-    LOG_WARNING(Service_HTTP, "(STUBBED) called, context_id={}", context_handle);
-
-    if (!PerformStateChecks(ctx, rp, context_handle)) {
-        return;
-    }
-
-    auto itr = contexts.find(context_handle);
-    ASSERT(itr != contexts.end());
-
-    // On a 3DS BeginRequest and BeginRequestAsync will push the Request to a worker queue.
-    // You can only enqueue 8 requests at the same time.
-    // trying to enqueue any more will either fail (BeginRequestAsync), or block (BeginRequest)
-    // Note that you only can have 8 Contexts at a time. So this difference shouldn't matter
-    // Then there are 3? worker threads that pop the requests from the queue and send them
-    // For now make every request async in it's own thread.
-
-    itr->second.request_future =
-        std::async(std::launch::async, &Context::MakeRequest, std::ref(itr->second));
-
-    IPC::RequestBuilder rb = rp.MakeBuilder(1, 0);
-    rb.Push(RESULT_SUCCESS);
-}
-
-void HTTP_C::BeginRequestAsync(Kernel::HLERequestContext& ctx) {
-    IPC::RequestParser rp(ctx);
-    const Context::Handle context_handle = rp.Pop<u32>();
-
-    LOG_WARNING(Service_HTTP, "(STUBBED) called, context_id={}", context_handle);
-
-    if (!PerformStateChecks(ctx, rp, context_handle)) {
-        return;
-    }
-
-    auto itr = contexts.find(context_handle);
-    ASSERT(itr != contexts.end());
-
-    // On a 3DS BeginRequest and BeginRequestAsync will push the Request to a worker queue.
-    // You can only enqueue 8 requests at the same time.
-    // trying to enqueue any more will either fail (BeginRequestAsync), or block (BeginRequest)
-    // Note that you only can have 8 Contexts at a time. So this difference shouldn't matter
-    // Then there are 3? worker threads that pop the requests from the queue and send them
-    // For now make every request async in it's own thread.
-
-    itr->second.request_future =
-        std::async(std::launch::async, &Context::MakeRequest, std::ref(itr->second));
-
-    IPC::RequestBuilder rb = rp.MakeBuilder(1, 0);
-    rb.Push(RESULT_SUCCESS);
-}
-
-void HTTP_C::ReceiveData(Kernel::HLERequestContext& ctx) {
-    ReceiveDataImpl(ctx, false);
-}
-
-void HTTP_C::ReceiveDataTimeout(Kernel::HLERequestContext& ctx) {
-    ReceiveDataImpl(ctx, true);
-}
-
-void HTTP_C::ReceiveDataImpl(Kernel::HLERequestContext& ctx, bool timeout) {
-    IPC::RequestParser rp(ctx);
-    const Context::Handle context_handle = rp.Pop<u32>();
-    [[maybe_unused]] const u32 buffer_size = rp.Pop<u32>();
-    u64 timeout_nanos = 0;
-    if (timeout) {
-        timeout_nanos = rp.Pop<u64>();
-        LOG_WARNING(Service_HTTP, "(STUBBED) called, timeout={}", timeout_nanos);
-    } else {
-        LOG_WARNING(Service_HTTP, "(STUBBED) called");
-    }
-
-    if (!PerformStateChecks(ctx, rp, context_handle)) {
-        return;
-    }
-
-    auto itr = contexts.find(context_handle);
-    ASSERT(itr != contexts.end());
-
-    if (timeout) {
-        itr->second.request_future.wait_for(std::chrono::nanoseconds(timeout_nanos));
-        // TODO (flTobi): Return error on timeout
-    } else {
-        itr->second.request_future.wait();
-    }
-
-    IPC::RequestBuilder rb = rp.MakeBuilder(1, 0);
-    rb.Push(RESULT_SUCCESS);
-}
-
-void HTTP_C::CreateContext(Kernel::HLERequestContext& ctx) {
-    IPC::RequestParser rp(ctx);
-    const u32 url_size = rp.Pop<u32>();
-    RequestMethod method = rp.PopEnum<RequestMethod>();
-    Kernel::MappedBuffer& buffer = rp.PopMappedBuffer();
-
-    // Copy the buffer into a string without the \0 at the end of the buffer
-    std::string url(url_size, '\0');
-    buffer.Read(&url[0], 0, url_size - 1);
-
-    LOG_DEBUG(Service_HTTP, "called, url_size={}, url={}, method={}", url_size, url, method);
-
-    auto* session_data = EnsureSessionInitialized(ctx, rp);
-    if (!session_data) {
-        return;
-    }
-
-    // This command can only be called without a bound session.
-    if (session_data->current_http_context) {
-        LOG_ERROR(Service_HTTP, "Command called with a bound context");
-
-        IPC::RequestBuilder rb = rp.MakeBuilder(1, 2);
-        rb.Push(ResultCode(ErrorDescription::NotImplemented, ErrorModule::HTTP,
-                           ErrorSummary::Internal, ErrorLevel::Permanent));
-        rb.PushMappedBuffer(buffer);
-        return;
-    }
-
-    static constexpr std::size_t MaxConcurrentHTTPContexts = 8;
-    if (session_data->num_http_contexts >= MaxConcurrentHTTPContexts) {
-        // There can only be 8 HTTP contexts open at the same time for any particular session.
-        LOG_ERROR(Service_HTTP, "Tried to open too many HTTP contexts");
-
-        IPC::RequestBuilder rb = rp.MakeBuilder(1, 2);
-        rb.Push(ResultCode(ErrCodes::TooManyContexts, ErrorModule::HTTP, ErrorSummary::InvalidState,
-                           ErrorLevel::Permanent));
-        rb.PushMappedBuffer(buffer);
-        return;
-    }
-
-    if (method == RequestMethod::None || static_cast<u32>(method) >= TotalRequestMethods) {
-        LOG_ERROR(Service_HTTP, "invalid request method={}", method);
-
-        IPC::RequestBuilder rb = rp.MakeBuilder(1, 2);
-        rb.Push(ResultCode(ErrCodes::InvalidRequestMethod, ErrorModule::HTTP,
-                           ErrorSummary::InvalidState, ErrorLevel::Permanent));
-        rb.PushMappedBuffer(buffer);
-        return;
-    }
-
-    contexts.try_emplace(++context_counter);
-    contexts[context_counter].url = std::move(url);
-    contexts[context_counter].method = method;
-    contexts[context_counter].state = RequestState::NotStarted;
-    // TODO(Subv): Find a correct default value for this field.
-    contexts[context_counter].socket_buffer_size = 0;
-    contexts[context_counter].handle = context_counter;
-    contexts[context_counter].session_id = session_data->session_id;
-
-    session_data->num_http_contexts++;
-
-    IPC::RequestBuilder rb = rp.MakeBuilder(2, 2);
-    rb.Push(RESULT_SUCCESS);
-    rb.Push<u32>(context_counter);
-    rb.PushMappedBuffer(buffer);
-}
-
-void HTTP_C::CloseContext(Kernel::HLERequestContext& ctx) {
-    IPC::RequestParser rp(ctx);
-
-    u32 context_handle = rp.Pop<u32>();
-
-    LOG_WARNING(Service_HTTP, "(STUBBED) called, handle={}", context_handle);
-
-    auto* session_data = EnsureSessionInitialized(ctx, rp);
-    if (!session_data) {
-        return;
-    }
-
-    ASSERT_MSG(!session_data->current_http_context,
-               "Unimplemented CloseContext on context-bound session");
-
-    auto itr = contexts.find(context_handle);
-    if (itr == contexts.end()) {
-        // The real HTTP module just silently fails in this case.
-        IPC::RequestBuilder rb = rp.MakeBuilder(1, 0);
-        rb.Push(RESULT_SUCCESS);
-        LOG_ERROR(Service_HTTP, "called, context {} not found", context_handle);
-        return;
-    }
-
-    // TODO(Subv): What happens if you try to close a context that's currently being used?
-    // TODO(Subv): Make sure that only the session that created the context can close it.
-
-    // Note that this will block if a request is still in progress
-    contexts.erase(itr);
-    session_data->num_http_contexts--;
-
-    IPC::RequestBuilder rb = rp.MakeBuilder(1, 0);
-    rb.Push(RESULT_SUCCESS);
-}
-
-void HTTP_C::AddRequestHeader(Kernel::HLERequestContext& ctx) {
-    IPC::RequestParser rp(ctx);
-    const u32 context_handle = rp.Pop<u32>();
-    [[maybe_unused]] const u32 name_size = rp.Pop<u32>();
-    const u32 value_size = rp.Pop<u32>();
-    const std::vector<u8> name_buffer = rp.PopStaticBuffer();
-    Kernel::MappedBuffer& value_buffer = rp.PopMappedBuffer();
-
-    // Copy the name_buffer into a string without the \0 at the end
-    const std::string name(name_buffer.begin(), name_buffer.end() - 1);
-
-    // Copy the value_buffer into a string without the \0 at the end
-    std::string value(value_size - 1, '\0');
-    value_buffer.Read(&value[0], 0, value_size - 1);
-
-    LOG_DEBUG(Service_HTTP, "called, name={}, value={}, context_handle={}", name, value,
-              context_handle);
-
-    if (!PerformStateChecks(ctx, rp, context_handle)) {
-        return;
-    }
-
-    auto itr = contexts.find(context_handle);
-    ASSERT(itr != contexts.end());
-
-    if (itr->second.state != RequestState::NotStarted) {
-        LOG_ERROR(Service_HTTP,
-                  "Tried to add a request header on a context that has already been started.");
-        IPC::RequestBuilder rb = rp.MakeBuilder(1, 2);
-        rb.Push(ResultCode(ErrCodes::InvalidRequestState, ErrorModule::HTTP,
-                           ErrorSummary::InvalidState, ErrorLevel::Permanent));
-        rb.PushMappedBuffer(value_buffer);
-        return;
-    }
-
-    ASSERT(std::find_if(itr->second.headers.begin(), itr->second.headers.end(),
-                        [&name](const Context::RequestHeader& m) -> bool {
-                            return m.name == name;
-                        }) == itr->second.headers.end());
-
-    itr->second.headers.emplace_back(name, value);
-
-    IPC::RequestBuilder rb = rp.MakeBuilder(1, 2);
-    rb.Push(RESULT_SUCCESS);
-    rb.PushMappedBuffer(value_buffer);
-}
-
-void HTTP_C::AddPostDataAscii(Kernel::HLERequestContext& ctx) {
-    IPC::RequestParser rp(ctx);
-    const u32 context_handle = rp.Pop<u32>();
-    [[maybe_unused]] const u32 name_size = rp.Pop<u32>();
-    const u32 value_size = rp.Pop<u32>();
-    const std::vector<u8> name_buffer = rp.PopStaticBuffer();
-    Kernel::MappedBuffer& value_buffer = rp.PopMappedBuffer();
-
-    // Copy the name_buffer into a string without the \0 at the end
-    const std::string name(name_buffer.begin(), name_buffer.end() - 1);
-
-    // Copy the value_buffer into a string without the \0 at the end
-    std::string value(value_size - 1, '\0');
-    value_buffer.Read(&value[0], 0, value_size - 1);
-
-    LOG_DEBUG(Service_HTTP, "called, name={}, value={}, context_handle={}", name, value,
-              context_handle);
-
-    if (!PerformStateChecks(ctx, rp, context_handle)) {
-        return;
-    }
-
-    auto itr = contexts.find(context_handle);
-    ASSERT(itr != contexts.end());
-
-    if (itr->second.state != RequestState::NotStarted) {
-        LOG_ERROR(Service_HTTP,
-                  "Tried to add post data on a context that has already been started.");
-        IPC::RequestBuilder rb = rp.MakeBuilder(1, 2);
-        rb.Push(ResultCode(ErrCodes::InvalidRequestState, ErrorModule::HTTP,
-                           ErrorSummary::InvalidState, ErrorLevel::Permanent));
-        rb.PushMappedBuffer(value_buffer);
-        return;
-    }
-
-    ASSERT(std::find_if(itr->second.post_data.begin(), itr->second.post_data.end(),
-                        [&name](const Context::PostData& m) -> bool { return m.name == name; }) ==
-           itr->second.post_data.end());
-
-    itr->second.post_data.emplace_back(name, value);
-
-    IPC::RequestBuilder rb = rp.MakeBuilder(1, 2);
-    rb.Push(RESULT_SUCCESS);
-    rb.PushMappedBuffer(value_buffer);
-}
-
-void HTTP_C::GetResponseStatusCode(Kernel::HLERequestContext& ctx) {
-    GetResponseStatusCodeImpl(ctx, false);
-}
-
-void HTTP_C::GetResponseStatusCodeTimeout(Kernel::HLERequestContext& ctx) {
-    GetResponseStatusCodeImpl(ctx, true);
-}
-
-void HTTP_C::GetResponseStatusCodeImpl(Kernel::HLERequestContext& ctx, bool timeout) {
-    IPC::RequestParser rp(ctx);
-    const Context::Handle context_handle = rp.Pop<u32>();
-    u64 timeout_nanos = 0;
-    if (timeout) {
-        timeout_nanos = rp.Pop<u64>();
-        LOG_INFO(Service_HTTP, "called, timeout={}", timeout_nanos);
-    } else {
-        LOG_INFO(Service_HTTP, "called");
-    }
-
-    if (!PerformStateChecks(ctx, rp, context_handle)) {
-        return;
-    }
-
-    auto itr = contexts.find(context_handle);
-    ASSERT(itr != contexts.end());
-
-    if (timeout) {
-        itr->second.request_future.wait_for(std::chrono::nanoseconds(timeout));
-        // TODO (flTobi): Return error on timeout
-    } else {
-        itr->second.request_future.wait();
-    }
-
-    const u32 response_code = itr->second.response.status;
-
-    IPC::RequestBuilder rb = rp.MakeBuilder(2, 0);
-    rb.Push(RESULT_SUCCESS);
-    rb.Push(response_code);
-}
-
-void HTTP_C::SetClientCertContext(Kernel::HLERequestContext& ctx) {
-    IPC::RequestParser rp(ctx);
-    const u32 context_handle = rp.Pop<u32>();
-    const u32 client_cert_handle = rp.Pop<u32>();
-
-    LOG_DEBUG(Service_HTTP, "called with context_handle={} client_cert_handle={}", context_handle,
-              client_cert_handle);
-
-    if (!PerformStateChecks(ctx, rp, context_handle)) {
-        return;
-    }
-
-    auto http_context_itr = contexts.find(context_handle);
-    ASSERT(http_context_itr != contexts.end());
-
-    auto cert_context_itr = client_certs.find(client_cert_handle);
-    if (cert_context_itr == client_certs.end()) {
-        LOG_ERROR(Service_HTTP, "called with wrong client_cert_handle {}", client_cert_handle);
-        IPC::RequestBuilder rb = rp.MakeBuilder(1, 0);
-        rb.Push(ERROR_WRONG_CERT_HANDLE);
-        return;
-    }
-
-    if (http_context_itr->second.ssl_config.client_cert_ctx.lock()) {
-        LOG_ERROR(Service_HTTP,
-                  "Tried to set a client cert to a context that already has a client cert");
-        IPC::RequestBuilder rb = rp.MakeBuilder(1, 0);
-        rb.Push(ERROR_CERT_ALREADY_SET);
-        return;
-    }
-
-    if (http_context_itr->second.state != RequestState::NotStarted) {
-        LOG_ERROR(Service_HTTP,
-                  "Tried to set a client cert on a context that has already been started.");
-        IPC::RequestBuilder rb = rp.MakeBuilder(1, 0);
-        rb.Push(ResultCode(ErrCodes::InvalidRequestState, ErrorModule::HTTP,
-                           ErrorSummary::InvalidState, ErrorLevel::Permanent));
-        return;
-    }
-
-    http_context_itr->second.ssl_config.client_cert_ctx = cert_context_itr->second;
-    IPC::RequestBuilder rb = rp.MakeBuilder(1, 0);
-    rb.Push(RESULT_SUCCESS);
-}
-
-void HTTP_C::GetSSLError(Kernel::HLERequestContext& ctx) {
-    IPC::RequestParser rp(ctx);
-    const u32 context_handle = rp.Pop<u32>();
-    const u32 unk = rp.Pop<u32>();
-
-    LOG_WARNING(Service_HTTP, "(STUBBED) called, context_handle={}, unk={}", context_handle, unk);
-
-    auto http_context_itr = contexts.find(context_handle);
-    ASSERT(http_context_itr != contexts.end());
-
-    IPC::RequestBuilder rb = rp.MakeBuilder(2, 0);
-    rb.Push(RESULT_SUCCESS);
-    // Since we create the actual http/ssl context only when the request is submitted we can't check
-    // for SSL Errors here. Just submit no error.
-    rb.Push<u32>(0);
-}
-
-void HTTP_C::OpenClientCertContext(Kernel::HLERequestContext& ctx) {
-    IPC::RequestParser rp(ctx);
-    u32 cert_size = rp.Pop<u32>();
-    u32 key_size = rp.Pop<u32>();
-    Kernel::MappedBuffer& cert_buffer = rp.PopMappedBuffer();
-    Kernel::MappedBuffer& key_buffer = rp.PopMappedBuffer();
-
-    LOG_DEBUG(Service_HTTP, "called, cert_size {}, key_size {}", cert_size, key_size);
-
-    auto* session_data = GetSessionData(ctx.Session());
-    ASSERT(session_data);
-
-    ResultCode result(RESULT_SUCCESS);
-
-    if (!session_data->initialized) {
-        LOG_ERROR(Service_HTTP, "Command called without Initialize");
-        result = ERROR_STATE_ERROR;
-    } else if (session_data->current_http_context) {
-        LOG_ERROR(Service_HTTP, "Command called with a bound context");
-        result = ERROR_NOT_IMPLEMENTED;
-    } else if (session_data->num_client_certs >= 2) {
-        LOG_ERROR(Service_HTTP, "tried to load more then 2 client certs");
-        result = ERROR_TOO_MANY_CLIENT_CERTS;
-    } else {
-        client_certs[++client_certs_counter] = std::make_shared<ClientCertContext>();
-        client_certs[client_certs_counter]->handle = client_certs_counter;
-        client_certs[client_certs_counter]->certificate.resize(cert_size);
-        cert_buffer.Read(&client_certs[client_certs_counter]->certificate[0], 0, cert_size);
-        client_certs[client_certs_counter]->private_key.resize(key_size);
-        cert_buffer.Read(&client_certs[client_certs_counter]->private_key[0], 0, key_size);
-        client_certs[client_certs_counter]->session_id = session_data->session_id;
-
-        ++session_data->num_client_certs;
-    }
-
-    IPC::RequestBuilder rb = rp.MakeBuilder(1, 4);
-    rb.Push(result);
-    rb.PushMappedBuffer(cert_buffer);
-    rb.PushMappedBuffer(key_buffer);
-}
-
-void HTTP_C::OpenDefaultClientCertContext(Kernel::HLERequestContext& ctx) {
-    IPC::RequestParser rp(ctx);
-    u8 cert_id = rp.Pop<u8>();
-
-    LOG_DEBUG(Service_HTTP, "called, cert_id={} cert_handle={}", cert_id, client_certs_counter);
-
-    auto* session_data = EnsureSessionInitialized(ctx, rp);
-    if (!session_data) {
-        return;
-    }
-
-    if (session_data->current_http_context) {
-        LOG_ERROR(Service_HTTP, "Command called with a bound context");
-        IPC::RequestBuilder rb = rp.MakeBuilder(1, 0);
-        rb.Push(ERROR_NOT_IMPLEMENTED);
-        return;
-    }
-
-    if (session_data->num_client_certs >= 2) {
-        LOG_ERROR(Service_HTTP, "tried to load more then 2 client certs");
-        IPC::RequestBuilder rb = rp.MakeBuilder(1, 0);
-        rb.Push(ERROR_TOO_MANY_CLIENT_CERTS);
-        return;
-    }
-
-    constexpr u8 default_cert_id = 0x40;
-    if (cert_id != default_cert_id) {
-        LOG_ERROR(Service_HTTP, "called with invalid cert_id {}", cert_id);
-        IPC::RequestBuilder rb = rp.MakeBuilder(1, 0);
-        rb.Push(ERROR_WRONG_CERT_ID);
-        return;
-    }
-
-    if (!ClCertA.init) {
-        LOG_ERROR(Service_HTTP, "called but ClCertA is missing");
-        IPC::RequestBuilder rb = rp.MakeBuilder(1, 0);
-        rb.Push(static_cast<ResultCode>(-1));
-        return;
-    }
-
-    const auto& it = std::find_if(client_certs.begin(), client_certs.end(),
-                                  [default_cert_id, &session_data](const auto& i) {
-                                      return default_cert_id == i.second->cert_id &&
-                                             session_data->session_id == i.second->session_id;
-                                  });
-
-    if (it != client_certs.end()) {
-        IPC::RequestBuilder rb = rp.MakeBuilder(2, 0);
-        rb.Push(RESULT_SUCCESS);
-        rb.Push<u32>(it->first);
-
-        LOG_DEBUG(Service_HTTP, "called, with an already loaded cert_id={}", cert_id);
-        return;
-    }
-
-    client_certs[++client_certs_counter] = std::make_shared<ClientCertContext>();
-    client_certs[client_certs_counter]->handle = client_certs_counter;
-    client_certs[client_certs_counter]->certificate = ClCertA.certificate;
-    client_certs[client_certs_counter]->private_key = ClCertA.private_key;
-    client_certs[client_certs_counter]->session_id = session_data->session_id;
-    ++session_data->num_client_certs;
-
-    IPC::RequestBuilder rb = rp.MakeBuilder(2, 0);
-    rb.Push(RESULT_SUCCESS);
-    rb.Push<u32>(client_certs_counter);
-}
-
-void HTTP_C::CloseClientCertContext(Kernel::HLERequestContext& ctx) {
-    IPC::RequestParser rp(ctx);
-    ClientCertContext::Handle cert_handle = rp.Pop<u32>();
-
-    LOG_DEBUG(Service_HTTP, "called, cert_handle={}", cert_handle);
-
-    auto* session_data = GetSessionData(ctx.Session());
-    ASSERT(session_data);
-
-    if (client_certs.find(cert_handle) == client_certs.end()) {
-        LOG_ERROR(Service_HTTP, "Command called with a unkown client cert handle {}", cert_handle);
-        IPC::RequestBuilder rb = rp.MakeBuilder(1, 0);
-        // This just return success without doing anything
-        rb.Push(RESULT_SUCCESS);
-        return;
-    }
-
-    if (client_certs[cert_handle]->session_id != session_data->session_id) {
-        LOG_ERROR(Service_HTTP, "called from another main session");
-        IPC::RequestBuilder rb = rp.MakeBuilder(1, 0);
-        // This just return success without doing anything
-        rb.Push(RESULT_SUCCESS);
-        return;
-    }
-
-    client_certs.erase(cert_handle);
-    session_data->num_client_certs--;
-
-    IPC::RequestBuilder rb = rp.MakeBuilder(1, 0);
-    rb.Push(RESULT_SUCCESS);
-}
-
-void HTTP_C::Finalize(Kernel::HLERequestContext& ctx) {
-    IPC::RequestParser rp(ctx);
-
-    shared_memory = nullptr;
-
-    IPC::RequestBuilder rb = rp.MakeBuilder(1, 0);
-    rb.Push(RESULT_SUCCESS);
-
-    LOG_WARNING(Service_HTTP, "(STUBBED) called");
-}
-
-void HTTP_C::GetDownloadSizeState(Kernel::HLERequestContext& ctx) {
-    IPC::RequestParser rp(ctx);
-    const Context::Handle context_handle = rp.Pop<u32>();
-
-    LOG_INFO(Service_HTTP, "called");
-
-    const auto* session_data = EnsureSessionInitialized(ctx, rp);
-    if (!session_data) {
-        return;
-    }
-
-    auto itr = contexts.find(context_handle);
-    ASSERT(itr != contexts.end());
-
-    // On the real console, the current downloaded progress and the total size of the content gets
-    // returned. Since we do not support chunked downloads on the host, always return the content
-    // length if the download is complete and 0 otherwise.
-    u32 content_length = 0;
-    const bool is_complete = itr->second.request_future.wait_for(std::chrono::milliseconds(0)) ==
-                             std::future_status::ready;
-    if (is_complete) {
-        const auto& headers = itr->second.response.headers;
-        const auto& it = headers.find("Content-Length");
-        if (it != headers.end()) {
-            content_length = std::stoi(it->second);
-        }
-    }
-
-    IPC::RequestBuilder rb = rp.MakeBuilder(3, 0);
-    rb.Push(RESULT_SUCCESS);
-    rb.Push(content_length);
-    rb.Push(content_length);
-}
-
-SessionData* HTTP_C::EnsureSessionInitialized(Kernel::HLERequestContext& ctx,
-                                              IPC::RequestParser rp) {
-    auto* session_data = GetSessionData(ctx.Session());
-    ASSERT(session_data);
-
-    if (!session_data->initialized) {
-        LOG_ERROR(Service_HTTP, "Tried to make a request on an uninitialized session");
-        IPC::RequestBuilder rb = rp.MakeBuilder(1, 0);
-        rb.Push(ERROR_STATE_ERROR);
-        return nullptr;
-    }
-
-    return session_data;
-}
-
-bool HTTP_C::PerformStateChecks(Kernel::HLERequestContext& ctx, IPC::RequestParser rp,
-                                Context::Handle context_handle) {
-    const auto* session_data = EnsureSessionInitialized(ctx, rp);
-    if (!session_data) {
-        return false;
-    }
-
-    // This command can only be called with a bound context
-    if (!session_data->current_http_context) {
-        LOG_ERROR(Service_HTTP, "Tried to make a request without a bound context");
-
-        IPC::RequestBuilder rb = rp.MakeBuilder(1, 0);
-        rb.Push(ResultCode(ErrorDescription::NotImplemented, ErrorModule::HTTP,
-                           ErrorSummary::Internal, ErrorLevel::Permanent));
-        return false;
-    }
-
-    if (session_data->current_http_context != context_handle) {
-        LOG_ERROR(
-            Service_HTTP,
-            "Tried to make a request on a mismatched session input context={} session context={}",
-            context_handle, *session_data->current_http_context);
-        IPC::RequestBuilder rb = rp.MakeBuilder(1, 0);
-        rb.Push(ERROR_STATE_ERROR);
-        return false;
-    }
-
-    return true;
-}
-
-void HTTP_C::DecryptClCertA() {
-    static constexpr u32 iv_length = 16;
-
-    FileSys::NCCHArchive archive(0x0004001b00010002, Service::FS::MediaType::NAND);
-
-    std::array<char, 8> exefs_filepath;
-    FileSys::Path file_path = FileSys::MakeNCCHFilePath(
-        FileSys::NCCHFileOpenType::NCCHData, 0, FileSys::NCCHFilePathType::RomFS, exefs_filepath);
-    FileSys::Mode open_mode = {};
-    open_mode.read_flag.Assign(1);
-    auto file_result = archive.OpenFile(file_path, open_mode);
-    if (file_result.Failed()) {
-        LOG_ERROR(Service_HTTP, "ClCertA file missing");
-        return;
-    }
-
-    auto romfs = std::move(file_result).Unwrap();
-    std::vector<u8> romfs_buffer(romfs->GetSize());
-    romfs->Read(0, romfs_buffer.size(), romfs_buffer.data());
-    romfs->Close();
-
-    if (!HW::AES::IsNormalKeyAvailable(HW::AES::KeySlotID::SSLKey)) {
-        LOG_ERROR(Service_HTTP, "NormalKey in KeySlot 0x0D missing");
-        return;
-    }
-    HW::AES::AESKey key = HW::AES::GetNormalKey(HW::AES::KeySlotID::SSLKey);
-
-    const RomFS::RomFSFile cert_file =
-        RomFS::GetFile(romfs_buffer.data(), {u"ctr-common-1-cert.bin"});
-    if (cert_file.Length() == 0) {
-        LOG_ERROR(Service_HTTP, "ctr-common-1-cert.bin missing");
-        return;
-    }
-    if (cert_file.Length() <= iv_length) {
-        LOG_ERROR(Service_HTTP, "ctr-common-1-cert.bin size is too small. Size: {}",
-                  cert_file.Length());
-        return;
-    }
-
-    std::vector<u8> cert_data(cert_file.Length() - iv_length);
-
-    using CryptoPP::AES;
-    CryptoPP::CBC_Mode<AES>::Decryption aes_cert;
-    std::array<u8, iv_length> cert_iv;
-    std::memcpy(cert_iv.data(), cert_file.Data(), iv_length);
-    aes_cert.SetKeyWithIV(key.data(), AES::BLOCKSIZE, cert_iv.data());
-    aes_cert.ProcessData(cert_data.data(), cert_file.Data() + iv_length,
-                         cert_file.Length() - iv_length);
-
-    const RomFS::RomFSFile key_file =
-        RomFS::GetFile(romfs_buffer.data(), {u"ctr-common-1-key.bin"});
-    if (key_file.Length() == 0) {
-        LOG_ERROR(Service_HTTP, "ctr-common-1-key.bin missing");
-        return;
-    }
-    if (key_file.Length() <= iv_length) {
-        LOG_ERROR(Service_HTTP, "ctr-common-1-key.bin size is too small. Size: {}",
-                  key_file.Length());
-        return;
-    }
-
-    std::vector<u8> key_data(key_file.Length() - iv_length);
-
-    CryptoPP::CBC_Mode<AES>::Decryption aes_key;
-    std::array<u8, iv_length> key_iv;
-    std::memcpy(key_iv.data(), key_file.Data(), iv_length);
-    aes_key.SetKeyWithIV(key.data(), AES::BLOCKSIZE, key_iv.data());
-    aes_key.ProcessData(key_data.data(), key_file.Data() + iv_length,
-                        key_file.Length() - iv_length);
-
-    ClCertA.certificate = std::move(cert_data);
-    ClCertA.private_key = std::move(key_data);
-    ClCertA.init = true;
-}
-
-HTTP_C::HTTP_C() : ServiceFramework("http:C", 32) {
-    static const FunctionInfo functions[] = {
-        // clang-format off
-        {0x0001, &HTTP_C::Initialize, "Initialize"},
-        {0x0002, &HTTP_C::CreateContext, "CreateContext"},
-        {0x0003, &HTTP_C::CloseContext, "CloseContext"},
-        {0x0004, nullptr, "CancelConnection"},
-        {0x0005, nullptr, "GetRequestState"},
-        {0x0006, &HTTP_C::GetDownloadSizeState, "GetDownloadSizeState"},
-        {0x0007, nullptr, "GetRequestError"},
-        {0x0008, &HTTP_C::InitializeConnectionSession, "InitializeConnectionSession"},
-        {0x0009, &HTTP_C::BeginRequest, "BeginRequest"},
-        {0x000A, &HTTP_C::BeginRequestAsync, "BeginRequestAsync"},
-        {0x000B, &HTTP_C::ReceiveData, "ReceiveData"},
-        {0x000C, &HTTP_C::ReceiveDataTimeout, "ReceiveDataTimeout"},
-        {0x000D, nullptr, "SetProxy"},
-        {0x000E, nullptr, "SetProxyDefault"},
-        {0x000F, nullptr, "SetBasicAuthorization"},
-        {0x0010, nullptr, "SetSocketBufferSize"},
-        {0x0011, &HTTP_C::AddRequestHeader, "AddRequestHeader"},
-        {0x0012, &HTTP_C::AddPostDataAscii, "AddPostDataAscii"},
-        {0x0013, nullptr, "AddPostDataBinary"},
-        {0x0014, nullptr, "AddPostDataRaw"},
-        {0x0015, nullptr, "SetPostDataType"},
-        {0x0016, nullptr, "SendPostDataAscii"},
-        {0x0017, nullptr, "SendPostDataAsciiTimeout"},
-        {0x0018, nullptr, "SendPostDataBinary"},
-        {0x0019, nullptr, "SendPostDataBinaryTimeout"},
-        {0x001A, nullptr, "SendPostDataRaw"},
-        {0x001B, nullptr, "SendPOSTDataRawTimeout"},
-        {0x001C, nullptr, "SetPostDataEncoding"},
-        {0x001D, nullptr, "NotifyFinishSendPostData"},
-        {0x001E, nullptr, "GetResponseHeader"},
-        {0x001F, nullptr, "GetResponseHeaderTimeout"},
-        {0x0020, nullptr, "GetResponseData"},
-        {0x0021, nullptr, "GetResponseDataTimeout"},
-        {0x0022, &HTTP_C::GetResponseStatusCode, "GetResponseStatusCode"},
-        {0x0023, &HTTP_C::GetResponseStatusCodeTimeout, "GetResponseStatusCodeTimeout"},
-        {0x0024, nullptr, "AddTrustedRootCA"},
-        {0x0025, nullptr, "AddDefaultCert"},
-        {0x0026, nullptr, "SelectRootCertChain"},
-        {0x0027, nullptr, "SetClientCert"},
-        {0x0029, &HTTP_C::SetClientCertContext, "SetClientCertContext"},
-        {0x002A, &HTTP_C::GetSSLError, "GetSSLError"},
-        {0x002B, nullptr, "SetSSLOpt"},
-        {0x002C, nullptr, "SetSSLClearOpt"},
-        {0x002D, nullptr, "CreateRootCertChain"},
-        {0x002E, nullptr, "DestroyRootCertChain"},
-        {0x002F, nullptr, "RootCertChainAddCert"},
-        {0x0030, nullptr, "RootCertChainAddDefaultCert"},
-        {0x0031, nullptr, "RootCertChainRemoveCert"},
-        {0x0032, &HTTP_C::OpenClientCertContext, "OpenClientCertContext"},
-        {0x0033, &HTTP_C::OpenDefaultClientCertContext, "OpenDefaultClientCertContext"},
-        {0x0034, &HTTP_C::CloseClientCertContext, "CloseClientCertContext"},
-        {0x0035, nullptr, "SetDefaultProxy"},
-        {0x0036, nullptr, "ClearDNSCache"},
-        {0x0037, nullptr, "SetKeepAlive"},
-        {0x0038, nullptr, "SetPostDataTypeSize"},
-        {0x0039, &HTTP_C::Finalize, "Finalize"},
-        // clang-format on
-    };
-    RegisterHandlers(functions);
-
-    DecryptClCertA();
-}
-
-void InstallInterfaces(Core::System& system) {
-    auto& service_manager = system.ServiceManager();
-    std::make_shared<HTTP_C>()->InstallAsService(service_manager);
-}
-} // namespace Service::HTTP
diff --git a/src/core/hle/service/http/http_c.h b/src/core/hle/service/http/http_c.h
deleted file mode 100644
index 7b2045465..000000000
--- a/src/core/hle/service/http/http_c.h
+++ /dev/null
@@ -1,539 +0,0 @@
-// Copyright 2014 Citra Emulator Project
-// Licensed under GPLv2 or any later version
-// Refer to the license.txt file included.
-
-#pragma once
-
-#include <future>
-#include <memory>
-#include <optional>
-#include <string>
-#include <unordered_map>
-#include <vector>
-#include <boost/optional.hpp>
-#include <boost/serialization/optional.hpp>
-#include <boost/serialization/shared_ptr.hpp>
-#include <boost/serialization/string.hpp>
-#include <boost/serialization/unordered_map.hpp>
-#include <boost/serialization/vector.hpp>
-#include <boost/serialization/weak_ptr.hpp>
-#ifdef ENABLE_WEB_SERVICE
-#if defined(__ANDROID__)
-#include <ifaddrs.h>
-#endif
-#include <httplib.h>
-#endif
-#include "core/hle/kernel/shared_memory.h"
-#include "core/hle/service/service.h"
-
-namespace Core {
-class System;
-}
-
-namespace IPC {
-class RequestParser;
-}
-
-namespace Service::HTTP {
-
-enum class RequestMethod : u8 {
-    None = 0x0,
-    Get = 0x1,
-    Post = 0x2,
-    Head = 0x3,
-    Put = 0x4,
-    Delete = 0x5,
-    PostEmpty = 0x6,
-    PutEmpty = 0x7,
-};
-
-/// The number of request methods, any valid method must be less than this.
-constexpr u32 TotalRequestMethods = 8;
-
-enum class RequestState : u8 {
-    NotStarted = 0x1,             // Request has not started yet.
-    InProgress = 0x5,             // Request in progress, sending request over the network.
-    ReadyToDownloadContent = 0x7, // Ready to download the content. (needs verification)
-    ReadyToDownload = 0x8,        // Ready to download?
-    TimedOut = 0xA,               // Request timed out?
-};
-
-/// Represents a client certificate along with its private key, stored as a byte array of DER data.
-/// There can only be at most one client certificate context attached to an HTTP context at any
-/// given time.
-struct ClientCertContext {
-    using Handle = u32;
-    Handle handle;
-    u32 session_id;
-    u8 cert_id;
-    std::vector<u8> certificate;
-    std::vector<u8> private_key;
-
-private:
-    template <class Archive>
-    void serialize(Archive& ar, const unsigned int) {
-        ar& handle;
-        ar& session_id;
-        ar& cert_id;
-        ar& certificate;
-        ar& private_key;
-    }
-    friend class boost::serialization::access;
-};
-
-/// Represents a root certificate chain, it contains a list of DER-encoded certificates for
-/// verifying HTTP requests. An HTTP context can have at most one root certificate chain attached to
-/// it, but the chain may contain an arbitrary number of certificates in it.
-struct RootCertChain {
-    struct RootCACert {
-        using Handle = u32;
-        Handle handle;
-        u32 session_id;
-        std::vector<u8> certificate;
-
-    private:
-        template <class Archive>
-        void serialize(Archive& ar, const unsigned int) {
-            ar& handle;
-            ar& session_id;
-            ar& certificate;
-        }
-        friend class boost::serialization::access;
-    };
-
-    using Handle = u32;
-    Handle handle;
-    u32 session_id;
-    std::vector<RootCACert> certificates;
-
-private:
-    template <class Archive>
-    void serialize(Archive& ar, const unsigned int) {
-        ar& handle;
-        ar& session_id;
-        ar& certificates;
-    }
-    friend class boost::serialization::access;
-};
-
-/// Represents an HTTP context.
-class Context final {
-public:
-    using Handle = u32;
-
-    Context() = default;
-    Context(const Context&) = delete;
-    Context& operator=(const Context&) = delete;
-
-    void MakeRequest();
-
-    struct Proxy {
-        std::string url;
-        std::string username;
-        std::string password;
-        u16 port;
-
-    private:
-        template <class Archive>
-        void serialize(Archive& ar, const unsigned int) {
-            ar& url;
-            ar& username;
-            ar& password;
-            ar& port;
-        }
-        friend class boost::serialization::access;
-    };
-
-    struct BasicAuth {
-        std::string username;
-        std::string password;
-
-    private:
-        template <class Archive>
-        void serialize(Archive& ar, const unsigned int) {
-            ar& username;
-            ar& password;
-        }
-        friend class boost::serialization::access;
-    };
-
-    struct RequestHeader {
-        RequestHeader(std::string name, std::string value) : name(name), value(value){};
-        std::string name;
-        std::string value;
-
-    private:
-        template <class Archive>
-        void serialize(Archive& ar, const unsigned int) {
-            ar& name;
-            ar& value;
-        }
-        friend class boost::serialization::access;
-    };
-
-    struct PostData {
-        // TODO(Subv): Support Binary and Raw POST elements.
-        PostData(std::string name, std::string value) : name(name), value(value){};
-        PostData() = default;
-        std::string name;
-        std::string value;
-
-    private:
-        template <class Archive>
-        void serialize(Archive& ar, const unsigned int) {
-            ar& name;
-            ar& value;
-        }
-        friend class boost::serialization::access;
-    };
-
-    struct SSLConfig {
-        u32 options;
-        std::weak_ptr<ClientCertContext> client_cert_ctx;
-        std::weak_ptr<RootCertChain> root_ca_chain;
-
-    private:
-        template <class Archive>
-        void serialize(Archive& ar, const unsigned int) {
-            ar& options;
-            ar& client_cert_ctx;
-            ar& root_ca_chain;
-        }
-        friend class boost::serialization::access;
-    };
-
-    Handle handle;
-    u32 session_id;
-    std::string url;
-    RequestMethod method;
-    std::atomic<RequestState> state = RequestState::NotStarted;
-    std::optional<Proxy> proxy;
-    std::optional<BasicAuth> basic_auth;
-    SSLConfig ssl_config{};
-    u32 socket_buffer_size;
-    std::vector<RequestHeader> headers;
-    std::vector<PostData> post_data;
-
-    std::future<void> request_future;
-    std::atomic<u64> current_download_size_bytes;
-    std::atomic<u64> total_download_size_bytes;
-#ifdef ENABLE_WEB_SERVICE
-    httplib::Response response;
-#endif
-};
-
-struct SessionData : public Kernel::SessionRequestHandler::SessionDataBase {
-    /// The HTTP context that is currently bound to this session, this can be empty if no context
-    /// has been bound. Certain commands can only be called on a session with a bound context.
-    boost::optional<Context::Handle> current_http_context;
-
-    u32 session_id;
-
-    /// Number of HTTP contexts that are currently opened in this session.
-    u32 num_http_contexts = 0;
-    /// Number of ClientCert contexts that are currently opened in this session.
-    u32 num_client_certs = 0;
-
-    /// Whether this session has been initialized in some way, be it via Initialize or
-    /// InitializeConnectionSession.
-    bool initialized = false;
-
-private:
-    template <class Archive>
-    void serialize(Archive& ar, const unsigned int) {
-        ar& boost::serialization::base_object<Kernel::SessionRequestHandler::SessionDataBase>(
-            *this);
-        ar& current_http_context;
-        ar& session_id;
-        ar& num_http_contexts;
-        ar& num_client_certs;
-        ar& initialized;
-    }
-    friend class boost::serialization::access;
-};
-
-class HTTP_C final : public ServiceFramework<HTTP_C, SessionData> {
-public:
-    HTTP_C();
-
-private:
-    /**
-     * HTTP_C::Initialize service function
-     *  Inputs:
-     *      1 : POST buffer size
-     *      2 : 0x20
-     *      3 : 0x0 (Filled with process ID by ARM11 Kernel)
-     *      4 : 0x0
-     *      5 : POST buffer memory block handle
-     *  Outputs:
-     *      1 : Result of function, 0 on success, otherwise error code
-     */
-    void Initialize(Kernel::HLERequestContext& ctx);
-
-    /**
-     * HTTP_C::CreateContext service function
-     *  Inputs:
-     *      1 : URL buffer size, including null-terminator
-     *      2 : RequestMethod
-     *      3 : (URLSize << 4) | 10
-     *      4 : URL data pointer
-     *  Outputs:
-     *      1 : Result of function, 0 on success, otherwise error code
-     *      2 : HTTP context handle
-     */
-    void CreateContext(Kernel::HLERequestContext& ctx);
-
-    /**
-     * HTTP_C::CreateContext service function
-     *  Inputs:
-     *      1 : Context handle
-     *  Outputs:
-     *      1 : Result of function, 0 on success, otherwise error code
-     */
-    void CloseContext(Kernel::HLERequestContext& ctx);
-
-    /**
-     * HTTP_C::GetDownloadSizeState service function
-     *  Inputs:
-     *      1 : Context handle
-     *  Outputs:
-     *      1 : Result of function, 0 on success, otherwise error code
-     *      2 : Total content data downloaded so far
-     *      3 : Total content size from the "Content-Length" response header
-     */
-    void GetDownloadSizeState(Kernel::HLERequestContext& ctx);
-
-    /**
-     * HTTP_C::InitializeConnectionSession service function
-     *  Inputs:
-     *      1 : HTTP context handle
-     *      2 : 0x20, processID translate-header for the ARM11-kernel
-     *      3 : processID set by the ARM11-kernel
-     *  Outputs:
-     *      1 : Result of function, 0 on success, otherwise error code
-     */
-    void InitializeConnectionSession(Kernel::HLERequestContext& ctx);
-
-    /**
-     * HTTP_C::BeginRequest service function
-     *  Inputs:
-     *      1 : Context handle
-     *  Outputs:
-     *      1 : Result of function, 0 on success, otherwise error code
-     */
-    void BeginRequest(Kernel::HLERequestContext& ctx);
-
-    /**
-     * HTTP_C::BeginRequestAsync service function
-     *  Inputs:
-     *      1 : Context handle
-     *  Outputs:
-     *      1 : Result of function, 0 on success, otherwise error code
-     */
-    void BeginRequestAsync(Kernel::HLERequestContext& ctx);
-
-    /**
-     * HTTP_C::ReceiveData service function
-     *  Inputs:
-     *      1 : Context handle
-     *      2 : Buffer size
-     *      3 : (OutSize<<4) | 12
-     *      4 : Output data pointer
-     *  Outputs:
-     *      1 : Result of function, 0 on success, otherwise error code
-     */
-    void ReceiveData(Kernel::HLERequestContext& ctx);
-
-    /**
-     * HTTP_C::ReceiveDataTimeout service function
-     *  Inputs:
-     *      1 : Context handle
-     *      2 : Buffer size
-     *    3-4 : u64 nanoseconds delay
-     *      5 : (OutSize<<4) | 12
-     *      6 : Output data pointer
-     *  Outputs:
-     *      1 : Result of function, 0 on success, otherwise error code
-     */
-    void ReceiveDataTimeout(Kernel::HLERequestContext& ctx);
-
-    /**
-     * ReceiveDataImpl:
-     *  Implements ReceiveData and ReceiveDataTimeout service functions
-     */
-    void ReceiveDataImpl(Kernel::HLERequestContext& ctx, bool timeout);
-
-    /**
-     * HTTP_C::AddRequestHeader service function
-     *  Inputs:
-     * 1 : Context handle
-     * 2 : Header name buffer size, including null-terminator.
-     * 3 : Header value buffer size, including null-terminator.
-     * 4 : (HeaderNameSize<<14) | 0xC02
-     * 5 : Header name data pointer
-     * 6 : (HeaderValueSize<<4) | 10
-     * 7 : Header value data pointer
-     *  Outputs:
-     *      1 : Result of function, 0 on success, otherwise error code
-     */
-    void AddRequestHeader(Kernel::HLERequestContext& ctx);
-
-    /**
-     * HTTP_C::AddPostDataAscii service function
-     *  Inputs:
-     * 1 : Context handle
-     * 2 : Form name buffer size, including null-terminator.
-     * 3 : Form value buffer size, including null-terminator.
-     * 4 : (FormNameSize<<14) | 0xC02
-     * 5 : Form name data pointer
-     * 6 : (FormValueSize<<4) | 10
-     * 7 : Form value data pointer
-     *  Outputs:
-     *      1 : Result of function, 0 on success, otherwise error code
-     */
-    void AddPostDataAscii(Kernel::HLERequestContext& ctx);
-
-    /**
-     * HTTP_C::GetResponseStatusCode service function
-     *  Inputs:
-     *      1 : Context handle
-     *  Outputs:
-     *      1 : Result of function, 0 on success, otherwise error code
-     *      2 : HTTP response status code
-     */
-    void GetResponseStatusCode(Kernel::HLERequestContext& ctx);
-
-    /**
-     * HTTP_C::GetResponseStatusCode service function
-     *  Inputs:
-     *      1 : Context handle
-     *    2-3 : u64 nanoseconds timeout
-     *  Outputs:
-     *      1 : Result of function, 0 on success, otherwise error code
-     *      2 : HTTP response status code
-     */
-    void GetResponseStatusCodeTimeout(Kernel::HLERequestContext& ctx);
-
-    /**
-     * GetResponseStatusCodeImpl:
-     *  Implements GetResponseStatusCode and GetResponseStatusCodeTimeout service functions
-     */
-    void GetResponseStatusCodeImpl(Kernel::HLERequestContext& ctx, bool timeout);
-
-    /**
-     * HTTP_C::SetClientCertContext service function
-     *  Inputs:
-     * 1 : Context handle
-     * 2 : Cert context handle
-     *  Outputs:
-     *      1 : Result of function, 0 on success, otherwise error code
-     */
-    void SetClientCertContext(Kernel::HLERequestContext& ctx);
-
-    /**
-     * HTTP_C::GetSSLError service function
-     *  Inputs:
-     * 1 : Context handle
-     * 2 : Unknown
-     *  Outputs:
-     *      1 : Result of function, 0 on success, otherwise error code
-     *      2 : SSL Error code
-     */
-    void GetSSLError(Kernel::HLERequestContext& ctx);
-
-    /**
-     * HTTP_C::OpenClientCertContext service function
-     *  Inputs:
-     *      1 :  Cert size
-     *      2 :  Key size
-     *      3 :  (CertSize<<4) | 10
-     *      4 :  Pointer to input cert
-     *      5 :  (KeySize<<4) | 10
-     *      6 :  Pointer to input key
-     *  Outputs:
-     *      1 : Result of function, 0 on success, otherwise error code
-     */
-    void OpenClientCertContext(Kernel::HLERequestContext& ctx);
-
-    /**
-     * HTTP_C::OpenDefaultClientCertContext service function
-     *  Inputs:
-     * 1 : CertID
-     *  Outputs:
-     *      1 : Result of function, 0 on success, otherwise error code
-     *      2 : Client Cert context handle
-     */
-    void OpenDefaultClientCertContext(Kernel::HLERequestContext& ctx);
-
-    /**
-     * HTTP_C::CloseClientCertContext service function
-     *  Inputs:
-     * 1 : ClientCert Handle
-     *  Outputs:
-     *      1 : Result of function, 0 on success, otherwise error code
-     */
-    void CloseClientCertContext(Kernel::HLERequestContext& ctx);
-
-    /**
-     * HTTP_C::Finalize service function
-     *  Outputs:
-     *      1 : Result of function, 0 on success, otherwise error code
-     */
-    void Finalize(Kernel::HLERequestContext& ctx);
-
-    [[nodiscard]] SessionData* EnsureSessionInitialized(Kernel::HLERequestContext& ctx,
-                                                        IPC::RequestParser rp);
-
-    [[nodiscard]] bool PerformStateChecks(Kernel::HLERequestContext& ctx, IPC::RequestParser rp,
-                                          Context::Handle context_handle);
-
-    void DecryptClCertA();
-
-    std::shared_ptr<Kernel::SharedMemory> shared_memory = nullptr;
-
-    /// The next number to use when a new HTTP session is initalized.
-    u32 session_counter = 0;
-
-    /// The next handle number to use when a new HTTP context is created.
-    Context::Handle context_counter = 0;
-
-    /// The next handle number to use when a new ClientCert context is created.
-    ClientCertContext::Handle client_certs_counter = 0;
-
-    /// Global list of HTTP contexts currently opened.
-    std::unordered_map<Context::Handle, Context> contexts;
-
-    /// Global list of  ClientCert contexts currently opened.
-    std::unordered_map<ClientCertContext::Handle, std::shared_ptr<ClientCertContext>> client_certs;
-
-    struct {
-        std::vector<u8> certificate;
-        std::vector<u8> private_key;
-        bool init = false;
-    } ClCertA;
-
-private:
-    template <class Archive>
-    void serialize(Archive& ar, const unsigned int) {
-        // NOTE: Serialization of the HTTP service is on a 'best effort' basis.
-        // There is a very good chance that saving/loading during a network connection will break,
-        // regardless!
-        ar& boost::serialization::base_object<Kernel::SessionRequestHandler>(*this);
-        ar& ClCertA.certificate;
-        ar& ClCertA.private_key;
-        ar& ClCertA.init;
-        ar& context_counter;
-        ar& client_certs_counter;
-        ar& client_certs;
-        // NOTE: `contexts` is not serialized because it contains non-serializable data. (i.e.
-        // handles to ongoing HTTP requests.) Serializing across HTTP contexts will break.
-    }
-    friend class boost::serialization::access;
-};
-
-void InstallInterfaces(Core::System& system);
-
-} // namespace Service::HTTP
-
-BOOST_CLASS_EXPORT_KEY(Service::HTTP::HTTP_C)
-BOOST_CLASS_EXPORT_KEY(Service::HTTP::SessionData)
diff --git a/src/core/hle/service/mic/mic_u.cpp b/src/core/hle/service/mic/mic_u.cpp
deleted file mode 100644
index bca6177c0..000000000
--- a/src/core/hle/service/mic/mic_u.cpp
+++ /dev/null
@@ -1,532 +0,0 @@
-// Copyright 2014 Citra Emulator Project
-// Licensed under GPLv2 or any later version
-// Refer to the license.txt file included.
-
-#include <span>
-#include <boost/serialization/weak_ptr.hpp>
-#include "audio_core/input.h"
-#include "audio_core/input_details.h"
-#include "common/archives.h"
-#include "common/logging/log.h"
-#include "common/settings.h"
-#include "core/core.h"
-#include "core/hle/ipc.h"
-#include "core/hle/ipc_helpers.h"
-#include "core/hle/kernel/event.h"
-#include "core/hle/kernel/handle_table.h"
-#include "core/hle/kernel/kernel.h"
-#include "core/hle/kernel/shared_memory.h"
-#include "core/hle/service/mic/mic_u.h"
-
-SERVICE_CONSTRUCT_IMPL(Service::MIC::MIC_U)
-SERIALIZE_EXPORT_IMPL(Service::MIC::MIC_U)
-
-namespace Service::MIC {
-
-template <class Archive>
-void MIC_U::serialize(Archive& ar, const unsigned int) {
-    ar& boost::serialization::base_object<Kernel::SessionRequestHandler>(*this);
-    ar&* impl.get();
-}
-
-/// Microphone audio encodings.
-enum class Encoding : u8 {
-    PCM8 = 0,        ///< Unsigned 8-bit PCM.
-    PCM16 = 1,       ///< Unsigned 16-bit PCM.
-    PCM8Signed = 2,  ///< Signed 8-bit PCM.
-    PCM16Signed = 3, ///< Signed 16-bit PCM.
-};
-
-/// Microphone audio sampling rates. The actual accurate sampling rate can be calculated using
-/// (16756991 / 512) / (SampleRate + 1) where SampleRate is one of the above values.
-enum class SampleRate : u8 {
-    Rate32730 = 0, ///< 32728.498 Hz
-    Rate16360 = 1, ///< 16364.479 Hz
-    Rate10910 = 2, ///< 10909.499 Hz
-    Rate8180 = 3   ///< 8182.1245 Hz
-};
-
-constexpr u32 GetSampleRateInHz(SampleRate sample_rate) {
-    switch (sample_rate) {
-    case SampleRate::Rate8180:
-        return 8182;
-    case SampleRate::Rate10910:
-        return 10909;
-    case SampleRate::Rate16360:
-        return 16364;
-    case SampleRate::Rate32730:
-        return 32728;
-    default:
-        UNREACHABLE();
-    }
-}
-
-// The 3ds hardware was tested to write to the sharedmem every 15 samples regardless of sample_rate.
-constexpr u64 GetBufferUpdatePeriod(SampleRate sample_rate) {
-    return 15 * BASE_CLOCK_RATE_ARM11 / GetSampleRateInHz(sample_rate);
-}
-
-// Variables holding the current mic buffer writing state
-struct State {
-    std::weak_ptr<Kernel::SharedMemory> memory_ref{};
-    u8* sharedmem_buffer = nullptr;
-    u32 sharedmem_size = 0;
-    std::size_t size = 0;
-    u32 offset = 0;
-    u32 initial_offset = 0;
-    bool looped_buffer = false;
-    u8 sample_size = 0;
-    SampleRate sample_rate = SampleRate::Rate16360;
-
-    void WriteSamples(std::span<const u8> samples) {
-        u32 bytes_total_written = 0;
-        auto sample_buffer = sharedmem_buffer + initial_offset;
-        // Do not let sampling buffer overrun shared memory space.
-        const auto sample_buffer_size =
-            std::min(size, sharedmem_size - initial_offset - sizeof(u32));
-
-        // Write samples in a loop until the input runs out
-        while (samples.size() > bytes_total_written) {
-            // TODO: If the sample size is 16-bit, this could theoretically cut a sample in the case
-            // where the application configures an odd size.
-            std::size_t bytes_to_write =
-                std::min(samples.size() - bytes_total_written, sample_buffer_size - offset);
-            std::memcpy(sample_buffer + offset, samples.data() + bytes_total_written,
-                        bytes_to_write);
-            offset += static_cast<u32>(bytes_to_write);
-            bytes_total_written += static_cast<u32>(bytes_to_write);
-
-            if (offset >= sample_buffer_size && looped_buffer) {
-                offset = 0;
-            }
-
-            if (!looped_buffer) {
-                break;
-            }
-        }
-
-        // The last 4 bytes of the shared memory contains the latest offset
-        // so update that as well https://www.3dbrew.org/wiki/MIC_Shared_Memory
-        u32_le off = offset;
-        std::memcpy(sharedmem_buffer + (sharedmem_size - sizeof(u32)), reinterpret_cast<u8*>(&off),
-                    sizeof(u32));
-    }
-
-private:
-    template <class Archive>
-    void serialize(Archive& ar, const unsigned int) {
-        std::shared_ptr<Kernel::SharedMemory> _memory_ref = memory_ref.lock();
-        ar& _memory_ref;
-        memory_ref = _memory_ref;
-        ar& sharedmem_size;
-        ar& size;
-        ar& offset;
-        ar& initial_offset;
-        ar& looped_buffer;
-        ar& sample_size;
-        ar& sample_rate;
-        sharedmem_buffer = _memory_ref ? _memory_ref->GetPointer() : nullptr;
-    }
-    friend class boost::serialization::access;
-};
-
-struct MIC_U::Impl {
-    explicit Impl(Core::System& system) : timing(system.CoreTiming()) {
-        buffer_full_event =
-            system.Kernel().CreateEvent(Kernel::ResetType::OneShot, "MIC_U::buffer_full_event");
-        buffer_write_event = timing.RegisterEvent(
-            "MIC_U::UpdateBuffer", [this](std::uintptr_t user_data, s64 cycles_late) {
-                UpdateSharedMemBuffer(user_data, cycles_late);
-            });
-    }
-
-    void MapSharedMem(Kernel::HLERequestContext& ctx) {
-        IPC::RequestParser rp(ctx);
-        const u32 size = rp.Pop<u32>();
-        shared_memory = rp.PopObject<Kernel::SharedMemory>();
-
-        if (shared_memory) {
-            shared_memory->SetName("MIC_U:shared_memory");
-            state.memory_ref = shared_memory;
-            state.sharedmem_buffer = shared_memory->GetPointer();
-            state.sharedmem_size = size;
-        }
-
-        IPC::RequestBuilder rb = rp.MakeBuilder(1, 0);
-        rb.Push(RESULT_SUCCESS);
-
-        LOG_TRACE(Service_MIC, "called, size=0x{:X}", size);
-    }
-
-    void UnmapSharedMem(Kernel::HLERequestContext& ctx) {
-        IPC::RequestParser rp(ctx);
-        IPC::RequestBuilder rb = rp.MakeBuilder(1, 0);
-        shared_memory = nullptr;
-        rb.Push(RESULT_SUCCESS);
-        LOG_TRACE(Service_MIC, "called");
-    }
-
-    void UpdateSharedMemBuffer(std::uintptr_t user_data, s64 cycles_late) {
-        if (change_mic_impl_requested.exchange(false)) {
-            CreateMic();
-        }
-        // If the event was scheduled before the application requested the mic to stop sampling
-        if (!mic->IsSampling()) {
-            return;
-        }
-
-        AudioCore::Samples samples = mic->Read();
-        if (!samples.empty()) {
-            // write the samples to sharedmem page
-            state.WriteSamples(samples);
-        }
-
-        // schedule next run
-        timing.ScheduleEvent(GetBufferUpdatePeriod(state.sample_rate) - cycles_late,
-                             buffer_write_event);
-    }
-
-    void StartSampling() {
-        auto sign = encoding == Encoding::PCM8Signed || encoding == Encoding::PCM16Signed
-                        ? AudioCore::Signedness::Signed
-                        : AudioCore::Signedness::Unsigned;
-        mic->StartSampling({sign, state.sample_size, state.looped_buffer,
-                            GetSampleRateInHz(state.sample_rate), state.initial_offset,
-                            static_cast<u32>(state.size)});
-    }
-
-    void StartSampling(Kernel::HLERequestContext& ctx) {
-        IPC::RequestParser rp(ctx);
-
-        encoding = rp.PopEnum<Encoding>();
-        SampleRate sample_rate = rp.PopEnum<SampleRate>();
-        u32 audio_buffer_offset = rp.PopRaw<u32>();
-        u32 audio_buffer_size = rp.Pop<u32>();
-        bool audio_buffer_loop = rp.Pop<bool>();
-
-        if (mic->IsSampling()) {
-            LOG_CRITICAL(Service_MIC,
-                         "Application started sampling again before stopping sampling");
-            mic->StopSampling();
-        }
-
-        u8 sample_size = encoding == Encoding::PCM8Signed || encoding == Encoding::PCM8 ? 8 : 16;
-        state.offset = 0;
-        state.initial_offset = audio_buffer_offset;
-        state.sample_rate = sample_rate;
-        state.sample_size = sample_size;
-        state.looped_buffer = audio_buffer_loop;
-        state.size = audio_buffer_size;
-
-        StartSampling();
-
-        timing.ScheduleEvent(GetBufferUpdatePeriod(state.sample_rate), buffer_write_event);
-
-        IPC::RequestBuilder rb = rp.MakeBuilder(1, 0);
-        rb.Push(RESULT_SUCCESS);
-        LOG_TRACE(Service_MIC,
-                  "called, encoding={}, sample_rate={}, "
-                  "audio_buffer_offset={}, audio_buffer_size={}, audio_buffer_loop={}",
-                  encoding, sample_rate, audio_buffer_offset, audio_buffer_size, audio_buffer_loop);
-    }
-
-    void AdjustSampling(Kernel::HLERequestContext& ctx) {
-        IPC::RequestParser rp(ctx);
-        SampleRate sample_rate = rp.PopEnum<SampleRate>();
-        mic->AdjustSampleRate(GetSampleRateInHz(sample_rate));
-
-        IPC::RequestBuilder rb = rp.MakeBuilder(1, 0);
-        rb.Push(RESULT_SUCCESS);
-        LOG_TRACE(Service_MIC, "sample_rate={}", sample_rate);
-    }
-
-    void StopSampling(Kernel::HLERequestContext& ctx) {
-        IPC::RequestParser rp(ctx);
-
-        IPC::RequestBuilder rb = rp.MakeBuilder(1, 0);
-        rb.Push(RESULT_SUCCESS);
-        mic->StopSampling();
-        timing.RemoveEvent(buffer_write_event);
-        LOG_TRACE(Service_MIC, "called");
-    }
-
-    void IsSampling(Kernel::HLERequestContext& ctx) {
-        IPC::RequestParser rp(ctx);
-
-        IPC::RequestBuilder rb = rp.MakeBuilder(2, 0);
-        rb.Push(RESULT_SUCCESS);
-        bool is_sampling = mic->IsSampling();
-        rb.Push<bool>(is_sampling);
-        LOG_TRACE(Service_MIC, "IsSampling: {}", is_sampling);
-    }
-
-    void GetBufferFullEvent(Kernel::HLERequestContext& ctx) {
-        IPC::RequestParser rp(ctx);
-
-        IPC::RequestBuilder rb = rp.MakeBuilder(1, 2);
-        rb.Push(RESULT_SUCCESS);
-        rb.PushCopyObjects(buffer_full_event);
-        LOG_WARNING(Service_MIC, "(STUBBED) called");
-    }
-
-    void SetGain(Kernel::HLERequestContext& ctx) {
-        IPC::RequestParser rp(ctx);
-        u8 gain = rp.Pop<u8>();
-        mic->SetGain(gain);
-
-        IPC::RequestBuilder rb = rp.MakeBuilder(1, 0);
-        rb.Push(RESULT_SUCCESS);
-        LOG_TRACE(Service_MIC, "gain={}", gain);
-    }
-
-    void GetGain(Kernel::HLERequestContext& ctx) {
-        IPC::RequestParser rp(ctx);
-
-        IPC::RequestBuilder rb = rp.MakeBuilder(2, 0);
-        rb.Push(RESULT_SUCCESS);
-        u8 gain = mic->GetGain();
-        rb.Push<u8>(gain);
-        LOG_TRACE(Service_MIC, "gain={}", gain);
-    }
-
-    void SetPower(Kernel::HLERequestContext& ctx) {
-        IPC::RequestParser rp(ctx);
-        bool power = rp.Pop<bool>();
-        mic->SetPower(power);
-
-        IPC::RequestBuilder rb = rp.MakeBuilder(1, 0);
-        rb.Push(RESULT_SUCCESS);
-        LOG_TRACE(Service_MIC, "mic_power={}", power);
-    }
-
-    void GetPower(Kernel::HLERequestContext& ctx) {
-        IPC::RequestParser rp(ctx);
-
-        IPC::RequestBuilder rb = rp.MakeBuilder(2, 0);
-        rb.Push(RESULT_SUCCESS);
-        bool mic_power = mic->GetPower();
-        rb.Push<u8>(mic_power);
-        LOG_TRACE(Service_MIC, "called");
-    }
-
-    void SetIirFilterMic(Kernel::HLERequestContext& ctx) {
-        IPC::RequestParser rp(ctx);
-        const u32 size = rp.Pop<u32>();
-        const Kernel::MappedBuffer& buffer = rp.PopMappedBuffer();
-
-        IPC::RequestBuilder rb = rp.MakeBuilder(1, 2);
-        rb.Push(RESULT_SUCCESS);
-        rb.PushMappedBuffer(buffer);
-        LOG_WARNING(Service_MIC, "(STUBBED) called, size=0x{:X}, buffer=0x{:08X}", size,
-                    buffer.GetId());
-    }
-
-    void SetClamp(Kernel::HLERequestContext& ctx) {
-        IPC::RequestParser rp(ctx);
-        clamp = rp.Pop<bool>();
-
-        IPC::RequestBuilder rb = rp.MakeBuilder(1, 0);
-        rb.Push(RESULT_SUCCESS);
-        LOG_WARNING(Service_MIC, "(STUBBED) called, clamp={}", clamp);
-    }
-
-    void GetClamp(Kernel::HLERequestContext& ctx) {
-        IPC::RequestParser rp(ctx);
-
-        IPC::RequestBuilder rb = rp.MakeBuilder(2, 0);
-        rb.Push(RESULT_SUCCESS);
-        rb.Push<bool>(clamp);
-        LOG_WARNING(Service_MIC, "(STUBBED) called");
-    }
-
-    void SetAllowShellClosed(Kernel::HLERequestContext& ctx) {
-        IPC::RequestParser rp(ctx);
-        allow_shell_closed = rp.Pop<bool>();
-
-        IPC::RequestBuilder rb = rp.MakeBuilder(1, 0);
-        rb.Push(RESULT_SUCCESS);
-        LOG_WARNING(Service_MIC, "(STUBBED) called, allow_shell_closed={}", allow_shell_closed);
-    }
-
-    void SetClientVersion(Kernel::HLERequestContext& ctx) {
-        IPC::RequestParser rp(ctx);
-        const u32 version = rp.Pop<u32>();
-        LOG_WARNING(Service_MIC, "(STUBBED) called, version: 0x{:08X}", version);
-
-        IPC::RequestBuilder rb = rp.MakeBuilder(1, 0);
-        rb.Push(RESULT_SUCCESS);
-    }
-
-    void CreateMic() {
-        std::unique_ptr<AudioCore::Input> new_mic = AudioCore::CreateInputFromID(
-            Settings::values.input_type.GetValue(), Settings::values.input_device.GetValue());
-
-        // If theres already a mic, copy over any data to the new mic impl
-        if (mic) {
-            new_mic->SetGain(mic->GetGain());
-            new_mic->SetPower(mic->GetPower());
-            auto params = mic->GetParameters();
-            if (mic->IsSampling()) {
-                mic->StopSampling();
-                new_mic->StartSampling(params);
-            }
-        }
-
-        mic = std::move(new_mic);
-        change_mic_impl_requested.store(false);
-    }
-
-    std::atomic<bool> change_mic_impl_requested = false;
-    std::shared_ptr<Kernel::Event> buffer_full_event;
-    Core::TimingEventType* buffer_write_event = nullptr;
-    std::shared_ptr<Kernel::SharedMemory> shared_memory;
-    u32 client_version = 0;
-    bool allow_shell_closed = false;
-    bool clamp = false;
-    std::unique_ptr<AudioCore::Input> mic;
-    Core::Timing& timing;
-    State state{};
-    Encoding encoding{};
-
-private:
-    template <class Archive>
-    void serialize(Archive& ar, const unsigned int file_version) {
-        ar& change_mic_impl_requested;
-        ar& buffer_full_event;
-        // buffer_write_event set in constructor
-        ar& shared_memory;
-        ar& client_version;
-        ar& allow_shell_closed;
-        ar& clamp;
-        // mic interface set in constructor
-        ar& state;
-        if (file_version > 0) {
-            // Maintain the internal mic state
-            ar& encoding;
-            bool is_sampling = mic && mic->IsSampling();
-            ar& is_sampling;
-            if (Archive::is_loading::value) {
-                if (is_sampling) {
-                    CreateMic();
-                    StartSampling();
-                } else if (mic) {
-                    mic->StopSampling();
-                }
-            }
-        }
-    }
-    friend class boost::serialization::access;
-};
-
-void MIC_U::MapSharedMem(Kernel::HLERequestContext& ctx) {
-    impl->MapSharedMem(ctx);
-}
-
-void MIC_U::UnmapSharedMem(Kernel::HLERequestContext& ctx) {
-    impl->UnmapSharedMem(ctx);
-}
-
-void MIC_U::StartSampling(Kernel::HLERequestContext& ctx) {
-    impl->StartSampling(ctx);
-}
-
-void MIC_U::AdjustSampling(Kernel::HLERequestContext& ctx) {
-    impl->AdjustSampling(ctx);
-}
-
-void MIC_U::StopSampling(Kernel::HLERequestContext& ctx) {
-    impl->StopSampling(ctx);
-}
-
-void MIC_U::IsSampling(Kernel::HLERequestContext& ctx) {
-    impl->IsSampling(ctx);
-}
-
-void MIC_U::GetBufferFullEvent(Kernel::HLERequestContext& ctx) {
-    impl->GetBufferFullEvent(ctx);
-}
-
-void MIC_U::SetGain(Kernel::HLERequestContext& ctx) {
-    impl->SetGain(ctx);
-}
-
-void MIC_U::GetGain(Kernel::HLERequestContext& ctx) {
-    impl->GetGain(ctx);
-}
-
-void MIC_U::SetPower(Kernel::HLERequestContext& ctx) {
-    impl->SetPower(ctx);
-}
-
-void MIC_U::GetPower(Kernel::HLERequestContext& ctx) {
-    impl->GetPower(ctx);
-}
-
-void MIC_U::SetIirFilterMic(Kernel::HLERequestContext& ctx) {
-    impl->SetIirFilterMic(ctx);
-}
-
-void MIC_U::SetClamp(Kernel::HLERequestContext& ctx) {
-    impl->SetClamp(ctx);
-}
-
-void MIC_U::GetClamp(Kernel::HLERequestContext& ctx) {
-    impl->GetClamp(ctx);
-}
-
-void MIC_U::SetAllowShellClosed(Kernel::HLERequestContext& ctx) {
-    impl->SetAllowShellClosed(ctx);
-}
-
-void MIC_U::SetClientVersion(Kernel::HLERequestContext& ctx) {
-    impl->SetClientVersion(ctx);
-}
-
-MIC_U::MIC_U(Core::System& system)
-    : ServiceFramework{"mic:u", 1}, impl{std::make_unique<Impl>(system)} {
-    static const FunctionInfo functions[] = {
-        // clang-format off
-        {0x0001, &MIC_U::MapSharedMem, "MapSharedMem"},
-        {0x0002, &MIC_U::UnmapSharedMem, "UnmapSharedMem"},
-        {0x0003, &MIC_U::StartSampling, "StartSampling"},
-        {0x0004, &MIC_U::AdjustSampling, "AdjustSampling"},
-        {0x0005, &MIC_U::StopSampling, "StopSampling"},
-        {0x0006, &MIC_U::IsSampling, "IsSampling"},
-        {0x0007, &MIC_U::GetBufferFullEvent, "GetBufferFullEvent"},
-        {0x0008, &MIC_U::SetGain, "SetGain"},
-        {0x0009, &MIC_U::GetGain, "GetGain"},
-        {0x000A, &MIC_U::SetPower, "SetPower"},
-        {0x000B, &MIC_U::GetPower, "GetPower"},
-        {0x000C, &MIC_U::SetIirFilterMic, "SetIirFilterMic"},
-        {0x000D, &MIC_U::SetClamp, "SetClamp"},
-        {0x000E, &MIC_U::GetClamp, "GetClamp"},
-        {0x000F, &MIC_U::SetAllowShellClosed, "SetAllowShellClosed"},
-        {0x0010, &MIC_U::SetClientVersion, "SetClientVersion"},
-        // clang-format on
-    };
-
-    impl->CreateMic();
-    RegisterHandlers(functions);
-}
-
-MIC_U::~MIC_U() {
-    impl->mic->StopSampling();
-}
-
-void MIC_U::ReloadMic() {
-    impl->change_mic_impl_requested.store(true);
-}
-
-void ReloadMic(Core::System& system) {
-    auto micu = system.ServiceManager().GetService<Service::MIC::MIC_U>("mic:u");
-    if (!micu)
-        return;
-    micu->ReloadMic();
-}
-
-void InstallInterfaces(Core::System& system) {
-    auto& service_manager = system.ServiceManager();
-    std::make_shared<MIC_U>(system)->InstallAsService(service_manager);
-}
-
-} // namespace Service::MIC
diff --git a/src/core/hle/service/mic/mic_u.h b/src/core/hle/service/mic/mic_u.h
deleted file mode 100644
index 1a404f194..000000000
--- a/src/core/hle/service/mic/mic_u.h
+++ /dev/null
@@ -1,207 +0,0 @@
-// Copyright 2014 Citra Emulator Project
-// Licensed under GPLv2 or any later version
-// Refer to the license.txt file included.
-
-#pragma once
-
-#include <memory>
-#include <boost/serialization/version.hpp>
-#include "core/hle/service/service.h"
-
-namespace Core {
-class System;
-}
-
-namespace Service::MIC {
-
-class MIC_U final : public ServiceFramework<MIC_U> {
-public:
-    explicit MIC_U(Core::System& system);
-    ~MIC_U();
-
-    void ReloadMic();
-
-private:
-    /**
-     * MIC::MapSharedMem service function
-     *  Inputs:
-     *      0 : Header Code[0x00010042]
-     *      1 : Shared-mem size
-     *      2 : CopyHandleDesc
-     *      3 : Shared-mem handle
-     *  Outputs:
-     *      1 : Result of function, 0 on success, otherwise error code
-     */
-    void MapSharedMem(Kernel::HLERequestContext& ctx);
-
-    /**
-     * MIC::UnmapSharedMem service function
-     *  Inputs:
-     *      0 : Header Code[0x00020000]
-     *  Outputs:
-     *      1 : Result of function, 0 on success, otherwise error code
-     */
-    void UnmapSharedMem(Kernel::HLERequestContext& ctx);
-
-    /**
-     * MIC::StartSampling service function
-     *  Inputs:
-     *      0 : Header Code[0x00030140]
-     *      1 : Encoding
-     *      2 : SampleRate
-     *      3 : Base offset for audio data in sharedmem
-     *      4 : Size of the audio data in sharedmem
-     *      5 : Loop at end of buffer
-     *  Outputs:
-     *      1 : Result of function, 0 on success, otherwise error code
-     */
-    void StartSampling(Kernel::HLERequestContext& ctx);
-
-    /**
-     * MIC::AdjustSampling service function
-     *  Inputs:
-     *      0 : Header Code[0x00040040]
-     *      1 : SampleRate
-     *  Outputs:
-     *      1 : Result of function, 0 on success, otherwise error code
-     */
-    void AdjustSampling(Kernel::HLERequestContext& ctx);
-
-    /**
-     * MIC::StopSampling service function
-     *  Inputs:
-     *      0 : Header Code[0x00050000]
-     *  Outputs:
-     *      1 : Result of function, 0 on success, otherwise error code
-     */
-    void StopSampling(Kernel::HLERequestContext& ctx);
-
-    /**
-     * MIC::IsSampling service function
-     *  Inputs:
-     *      0 : Header Code[0x00060000]
-     *  Outputs:
-     *      1 : Result of function, 0 on success, otherwise error code
-     *      2 : 0 = sampling, non-zero = sampling
-     */
-    void IsSampling(Kernel::HLERequestContext& ctx);
-
-    /**
-     * MIC::GetBufferFullEvent service function
-     *  Inputs:
-     *      0 : Header Code[0x00070000]
-     *  Outputs:
-     *      1 : Result of function, 0 on success, otherwise error code
-     *      3 : Event handle
-     */
-    void GetBufferFullEvent(Kernel::HLERequestContext& ctx);
-
-    /**
-     * MIC::SetGain service function
-     *  Inputs:
-     *      0 : Header Code[0x00080040]
-     *      1 : Gain
-     *  Outputs:
-     *      1 : Result of function, 0 on success, otherwise error code
-     */
-    void SetGain(Kernel::HLERequestContext& ctx);
-
-    /**
-     * MIC::GetGain service function
-     *  Inputs:
-     *      0 : Header Code[0x00090000]
-     *  Outputs:
-     *      1 : Result of function, 0 on success, otherwise error code
-     *      2 : Gain
-     */
-    void GetGain(Kernel::HLERequestContext& ctx);
-
-    /**
-     * MIC::SetPower service function
-     *  Inputs:
-     *      0 : Header Code[0x000A0040]
-     *      1 : Power (0 = off, 1 = on)
-     *  Outputs:
-     *      1 : Result of function, 0 on success, otherwise error code
-     */
-    void SetPower(Kernel::HLERequestContext& ctx);
-
-    /**
-     * MIC::GetPower service function
-     *  Inputs:
-     *      0 : Header Code[0x000B0000]
-     *  Outputs:
-     *      1 : Result of function, 0 on success, otherwise error code
-     *      2 : Power
-     */
-    void GetPower(Kernel::HLERequestContext& ctx);
-
-    /**
-     * MIC::SetIirFilterMic service function
-     *  Inputs:
-     *      0 : Header Code[0x000C0042]
-     *      1 : Size
-     *      2 : (Size << 4) | 0xA
-     *      3 : Pointer to IIR Filter Data
-     *  Outputs:
-     *      1 : Result of function, 0 on success, otherwise error code
-     */
-    void SetIirFilterMic(Kernel::HLERequestContext& ctx);
-
-    /**
-     * MIC::SetClamp service function
-     *  Inputs:
-     *      0 : Header Code[0x000D0040]
-     *      1 : Clamp (0 = don't clamp, non-zero = clamp)
-     *  Outputs:
-     *      1 : Result of function, 0 on success, otherwise error code
-     */
-    void SetClamp(Kernel::HLERequestContext& ctx);
-
-    /**
-     * MIC::GetClamp service function
-     *  Inputs:
-     *      0 : Header Code[0x000E0000]
-     *  Outputs:
-     *      1 : Result of function, 0 on success, otherwise error code
-     *      2 : Clamp (0 = don't clamp, non-zero = clamp)
-     */
-    void GetClamp(Kernel::HLERequestContext& ctx);
-
-    /**
-     * MIC::SetAllowShellClosed service function
-     *  Inputs:
-     *      0 : Header Code[0x000F0040]
-     *      1 : Sampling allowed while shell closed (0 = disallow, non-zero = allow)
-     *  Outputs:
-     *      1 : Result of function, 0 on success, otherwise error code
-     */
-    void SetAllowShellClosed(Kernel::HLERequestContext& ctx);
-
-    /**
-     * MIC_U::SetClientVersion service function
-     *  Inputs:
-     *      0 : Header Code[0x00100040]
-     *      1 : Used SDK Version
-     *  Outputs:
-     *      1 : Result of function, 0 on success, otherwise error code
-     */
-    void SetClientVersion(Kernel::HLERequestContext& ctx);
-
-    struct Impl;
-    std::unique_ptr<Impl> impl;
-
-    template <class Archive>
-    void serialize(Archive& ar, const unsigned int);
-    friend class boost::serialization::access;
-};
-
-void ReloadMic(Core::System& system);
-
-void InstallInterfaces(Core::System& system);
-
-} // namespace Service::MIC
-
-SERVICE_CONSTRUCT(Service::MIC::MIC_U)
-BOOST_CLASS_EXPORT_KEY(Service::MIC::MIC_U)
-BOOST_CLASS_VERSION(Service::MIC::MIC_U::Impl, 1)
diff --git a/src/core/hle/service/service.cpp b/src/core/hle/service/service.cpp
index 668b6cbb5..91b56b12c 100644
--- a/src/core/hle/service/service.cpp
+++ b/src/core/hle/service/service.cpp
@@ -19,23 +19,22 @@
 #include "core/hle/service/apt/apt.h"
 #include "core/hle/service/boss/boss.h"
 #include "core/hle/service/cam/cam.h"
-#include "core/hle/service/cam/y2r_u.h"
 #include "core/hle/service/cecd/cecd.h"
 #include "core/hle/service/cfg/cfg.h"
 #include "core/hle/service/csnd/csnd_snd.h"
 #include "core/hle/service/dlp/dlp.h"
 #include "core/hle/service/dsp/dsp_dsp.h"
-#include "core/hle/service/err/err_f.h"
+#include "core/hle/service/err_f.h"
 #include "core/hle/service/frd/frd.h"
 #include "core/hle/service/fs/archive.h"
 #include "core/hle/service/fs/fs_user.h"
 #include "core/hle/service/gsp/gsp.h"
 #include "core/hle/service/gsp/gsp_lcd.h"
 #include "core/hle/service/hid/hid.h"
-#include "core/hle/service/http/http_c.h"
+#include "core/hle/service/http_c.h"
 #include "core/hle/service/ir/ir.h"
 #include "core/hle/service/ldr_ro/ldr_ro.h"
-#include "core/hle/service/mic/mic_u.h"
+#include "core/hle/service/mic_u.h"
 #include "core/hle/service/mvd/mvd.h"
 #include "core/hle/service/ndm/ndm_u.h"
 #include "core/hle/service/news/news.h"
@@ -51,8 +50,9 @@
 #include "core/hle/service/service.h"
 #include "core/hle/service/sm/sm.h"
 #include "core/hle/service/sm/srv.h"
-#include "core/hle/service/soc/soc_u.h"
-#include "core/hle/service/ssl/ssl_c.h"
+#include "core/hle/service/soc_u.h"
+#include "core/hle/service/ssl_c.h"
+#include "core/hle/service/y2r_u.h"
 #include "core/loader/loader.h"
 
 namespace Service {
diff --git a/src/core/hle/service/soc/soc_u.cpp b/src/core/hle/service/soc/soc_u.cpp
deleted file mode 100644
index 1b91fdaae..000000000
--- a/src/core/hle/service/soc/soc_u.cpp
+++ /dev/null
@@ -1,1873 +0,0 @@
-// Copyright 2014 Citra Emulator Project
-// Licensed under GPLv2 or any later version
-// Refer to the license.txt file included.
-
-#include <algorithm>
-#include <cstring>
-#include <type_traits>
-#include <unordered_map>
-#include <vector>
-#include "common/archives.h"
-#include "common/assert.h"
-#include "common/bit_field.h"
-#include "common/common_types.h"
-#include "common/logging/log.h"
-#include "common/scope_exit.h"
-#include "common/swap.h"
-#include "core/core.h"
-#include "core/hle/ipc_helpers.h"
-#include "core/hle/kernel/shared_memory.h"
-#include "core/hle/result.h"
-#include "core/hle/service/soc/soc_u.h"
-
-#ifdef _WIN32
-#include <winsock2.h>
-#include <ws2tcpip.h>
-
-// MinGW does not define several errno constants
-#ifndef _MSC_VER
-#define EBADMSG 104
-#define ENODATA 120
-#define ENOMSG 122
-#define ENOSR 124
-#define ENOSTR 125
-#define ETIME 137
-#endif // _MSC_VER
-#else
-#include <cerrno>
-#include <arpa/inet.h>
-#include <fcntl.h>
-#include <ifaddrs.h>
-#include <netdb.h>
-#include <netinet/in.h>
-#include <netinet/tcp.h>
-#include <poll.h>
-#include <sys/socket.h>
-#include <sys/types.h>
-#include <unistd.h>
-#endif
-
-#ifdef _WIN32
-#define WSAEAGAIN WSAEWOULDBLOCK
-#define WSAEMULTIHOP -1 // Invalid dummy value
-#define ERRNO(x) WSA##x
-#define GET_ERRNO WSAGetLastError()
-#define poll(x, y, z) WSAPoll(x, y, z);
-#define SHUT_RD SD_RECEIVE
-#define SHUT_WR SD_SEND
-#define SHUT_RDWR SD_BOTH
-#else
-#define ERRNO(x) x
-#define GET_ERRNO errno
-#define closesocket(x) close(x)
-#endif
-#define MSGCUSTOM_HANDLE_DONTWAIT 0x80000000
-
-SERIALIZE_EXPORT_IMPL(Service::SOC::SOC_U)
-
-namespace Service::SOC {
-
-const s32 SOCKET_ERROR_VALUE = -1;
-
-static u32 SocketProtocolToPlatform(u32 protocol) {
-    switch (protocol) {
-    case 0:
-        return 0;
-    case 6:
-        return IPPROTO_TCP;
-    case 17:
-        return IPPROTO_UDP;
-    default:
-        break;
-    }
-    return -1;
-}
-
-static u32 SocketProtocolFromPlatform(u32 protocol) {
-    switch (protocol) {
-    case 0:
-        return 0;
-    case IPPROTO_TCP:
-        return 6;
-    case IPPROTO_UDP:
-        return 17;
-    default:
-        break;
-    }
-    return -1;
-}
-
-static u32 SocketDomainToPlatform(u32 domain) {
-    switch (domain) {
-    case 0:
-        return AF_UNSPEC;
-    case 2:
-        return AF_INET;
-    case 23:
-        return AF_INET6;
-    default:
-        break;
-    }
-    return -1;
-}
-
-static u32 SocketDomainFromPlatform(u32 domain) {
-    switch (domain) {
-    case AF_UNSPEC:
-        return 0;
-    case AF_INET:
-        return 2;
-    case AF_INET6:
-        return 23;
-    default:
-        break;
-    }
-    return -1;
-}
-
-static u32 SocketTypeToPlatform(u32 type) {
-    switch (type) {
-    case 0:
-        return 0;
-    case 1:
-        return SOCK_STREAM;
-    case 2:
-        return SOCK_DGRAM;
-    default:
-        break;
-    }
-    return -1;
-}
-
-static u32 SocketTypeFromPlatform(u32 type) {
-    switch (type) {
-    case 0:
-        return 0;
-    case SOCK_STREAM:
-        return 1;
-    case SOCK_DGRAM:
-        return 2;
-    default:
-        break;
-    }
-    return -1;
-}
-
-/// Holds the translation from system network errors to 3DS network errors
-static const std::unordered_map<int, int> error_map = {{
-    {E2BIG, 1},
-    {ERRNO(EACCES), 2},
-    {ERRNO(EADDRINUSE), 3},
-    {ERRNO(EADDRNOTAVAIL), 4},
-    {ERRNO(EAFNOSUPPORT), 5},
-    {EAGAIN, 6},
-#ifdef _WIN32
-    {WSAEWOULDBLOCK, 6},
-#else
-#if EAGAIN != EWOULDBLOCK
-    {EWOULDBLOCK, 6},
-#endif
-#endif // _WIN32
-    {ERRNO(EALREADY), 7},
-    {ERRNO(EBADF), 8},
-    {EBADMSG, 9},
-    {EBUSY, 10},
-    {ECANCELED, 11},
-    {ECHILD, 12},
-    {ERRNO(ECONNABORTED), 13},
-    {ERRNO(ECONNREFUSED), 14},
-    {ERRNO(ECONNRESET), 15},
-    {EDEADLK, 16},
-    {ERRNO(EDESTADDRREQ), 17},
-    {EDOM, 18},
-    {ERRNO(EDQUOT), 19},
-    {EEXIST, 20},
-    {ERRNO(EFAULT), 21},
-    {EFBIG, 22},
-    {ERRNO(EHOSTUNREACH), 23},
-    {EIDRM, 24},
-    {EILSEQ, 25},
-    {ERRNO(EINPROGRESS), 26},
-    {ERRNO(EINTR), 27},
-    {ERRNO(EINVAL), 28},
-    {EIO, 29},
-    {ERRNO(EISCONN), 30},
-    {EISDIR, 31},
-    {ERRNO(ELOOP), 32},
-    {ERRNO(EMFILE), 33},
-    {EMLINK, 34},
-    {ERRNO(EMSGSIZE), 35},
-#ifdef EMULTIHOP
-    {ERRNO(EMULTIHOP), 36},
-#endif
-    {ERRNO(ENAMETOOLONG), 37},
-    {ERRNO(ENETDOWN), 38},
-    {ERRNO(ENETRESET), 39},
-    {ERRNO(ENETUNREACH), 40},
-    {ENFILE, 41},
-    {ERRNO(ENOBUFS), 42},
-#ifdef ENODATA
-    {ENODATA, 43},
-#endif
-    {ENODEV, 44},
-    {ENOENT, 45},
-    {ENOEXEC, 46},
-    {ENOLCK, 47},
-    {ENOLINK, 48},
-    {ENOMEM, 49},
-    {ENOMSG, 50},
-    {ERRNO(ENOPROTOOPT), 51},
-    {ENOSPC, 52},
-#ifdef ENOSR
-    {ENOSR, 53},
-#endif
-#ifdef ENOSTR
-    {ENOSTR, 54},
-#endif
-    {ENOSYS, 55},
-    {ERRNO(ENOTCONN), 56},
-    {ENOTDIR, 57},
-    {ERRNO(ENOTEMPTY), 58},
-    {ERRNO(ENOTSOCK), 59},
-    {ENOTSUP, 60},
-    {ENOTTY, 61},
-    {ENXIO, 62},
-    {ERRNO(EOPNOTSUPP), 63},
-    {EOVERFLOW, 64},
-    {EPERM, 65},
-    {EPIPE, 66},
-    {EPROTO, 67},
-    {ERRNO(EPROTONOSUPPORT), 68},
-    {ERRNO(EPROTOTYPE), 69},
-    {ERANGE, 70},
-    {EROFS, 71},
-    {ESPIPE, 72},
-    {ESRCH, 73},
-    {ERRNO(ESTALE), 74},
-#ifdef ETIME
-    {ETIME, 75},
-#endif
-    {ERRNO(ETIMEDOUT), 76},
-}};
-
-/// Converts a network error from platform-specific to 3ds-specific
-static int TranslateError(int error) {
-    const auto& found = error_map.find(error);
-    if (found != error_map.end()) {
-        return -found->second;
-    }
-    return error;
-}
-
-struct CTRLinger {
-    u32_le l_onoff;
-    u32_le l_linger;
-};
-
-/// Holds the translation from system network socket options to 3DS network socket options
-/// Note: -1 = No effect/unavailable
-static constexpr u64 sockopt_map_key(int i, int j) {
-    return (u64)i << 32 | (unsigned int)j;
-}
-const std::unordered_map<u64, std::pair<int, int>> SOC_U::sockopt_map = {{
-    {sockopt_map_key(SOC_SOL_IP, 0x0007), {IPPROTO_IP, IP_TOS}},
-    {sockopt_map_key(SOC_SOL_IP, 0x0008), {IPPROTO_IP, IP_TTL}},
-    {sockopt_map_key(SOC_SOL_IP, 0x0009), {IPPROTO_IP, IP_MULTICAST_LOOP}},  // Never used?
-    {sockopt_map_key(SOC_SOL_IP, 0x000A), {IPPROTO_IP, IP_MULTICAST_TTL}},   // Never used?
-    {sockopt_map_key(SOC_SOL_IP, 0x000B), {IPPROTO_IP, IP_ADD_MEMBERSHIP}},  // Never used?
-    {sockopt_map_key(SOC_SOL_IP, 0x000C), {IPPROTO_IP, IP_DROP_MEMBERSHIP}}, // Never used?
-    {sockopt_map_key(SOC_SOL_SOCKET, 0x0004), {SOL_SOCKET, SO_REUSEADDR}},
-    {sockopt_map_key(SOC_SOL_SOCKET, 0x0080), {SOL_SOCKET, SO_LINGER}},
-    {sockopt_map_key(SOC_SOL_SOCKET, 0x0100), {SOL_SOCKET, SO_OOBINLINE}},
-    {sockopt_map_key(SOC_SOL_SOCKET, 0x1001), {SOL_SOCKET, SO_SNDBUF}},
-    {sockopt_map_key(SOC_SOL_SOCKET, 0x1002), {SOL_SOCKET, SO_RCVBUF}},
-    {sockopt_map_key(SOC_SOL_SOCKET, 0x1003),
-     {SOL_SOCKET, SO_SNDLOWAT}}, // Not supported in winsock2
-    {sockopt_map_key(SOC_SOL_SOCKET, 0x1004),
-     {SOL_SOCKET, SO_RCVLOWAT}}, // Not supported in winsock2
-    {sockopt_map_key(SOC_SOL_SOCKET, 0x1008), {SOL_SOCKET, SO_TYPE}},
-    {sockopt_map_key(SOC_SOL_SOCKET, 0x1009), {SOL_SOCKET, SO_ERROR}},
-    {sockopt_map_key(SOC_SOL_TCP, 0x2001), {IPPROTO_TCP, TCP_NODELAY}},
-    {sockopt_map_key(SOC_SOL_TCP, 0x2002), {IPPROTO_TCP, -1}}, // TCP_MAXSEG, never used?
-    {sockopt_map_key(SOC_SOL_TCP, 0x2003), {IPPROTO_TCP, -1}}, // TCP_STDURG, never used?
-}};
-
-/// Converts a socket option from platform-specific to 3ds-specific
-std::pair<int, int> SOC_U::TranslateSockOpt(int level, int opt) {
-    const auto& found = sockopt_map.find(sockopt_map_key(level, opt));
-    if (found != sockopt_map.end()) {
-        return found->second;
-    }
-    return std::make_pair(SOL_SOCKET, opt);
-}
-
-static void TranslateSockOptDataToPlatform(std::vector<u8>& out, const std::vector<u8>& in,
-                                           int platform_level, int platform_opt) {
-    // linger structure may be different between 3DS and platform
-    if (platform_level == SOL_SOCKET && platform_opt == SO_LINGER &&
-        in.size() == sizeof(CTRLinger)) {
-        linger linger_out;
-        linger_out.l_onoff = static_cast<decltype(linger_out.l_onoff)>(
-            reinterpret_cast<const CTRLinger*>(in.data())->l_onoff);
-        linger_out.l_linger = static_cast<decltype(linger_out.l_linger)>(
-            reinterpret_cast<const CTRLinger*>(in.data())->l_linger);
-        out.resize(sizeof(linger));
-        std::memcpy(out.data(), &linger_out, sizeof(linger));
-        return;
-    }
-    // Other options should have the size of an int, even for booleans
-    int value;
-    if (in.size() == sizeof(u8)) {
-        value = static_cast<int>(*reinterpret_cast<const u8*>(in.data()));
-    } else if (in.size() == sizeof(u16)) {
-        value = static_cast<int>(*reinterpret_cast<const u16_le*>(in.data()));
-    } else if (in.size() == sizeof(u32)) {
-        value = static_cast<int>(*reinterpret_cast<const u32_le*>(in.data()));
-    } else {
-        LOG_ERROR(
-            Service_SOC,
-            "Unknown sockopt data combination: in_size={}, platform_level={}, platform_opt={}",
-            in.size(), platform_level, platform_opt);
-        out = in;
-        return;
-    }
-    out.resize(sizeof(int));
-    std::memcpy(out.data(), &value, sizeof(int));
-}
-
-static u32 TranslateSockOptSizeToPlatform(int platform_level, int platform_opt) {
-    if (platform_level == SOL_SOCKET && platform_opt == SO_LINGER)
-        return sizeof(linger);
-    return sizeof(int);
-}
-
-static void TranslateSockOptDataFromPlatform(std::vector<u8>& out, const std::vector<u8>& in,
-                                             int platform_level, int platform_opt) {
-    if (platform_level == SOL_SOCKET && platform_opt == SO_LINGER && in.size() == sizeof(linger)) {
-        CTRLinger linger_out;
-        linger_out.l_onoff = static_cast<decltype(linger_out.l_onoff)>(
-            reinterpret_cast<const linger*>(in.data())->l_onoff);
-        linger_out.l_linger = static_cast<decltype(linger_out.l_linger)>(
-            reinterpret_cast<const linger*>(in.data())->l_linger);
-        std::memcpy(out.data(), &linger_out, std::min(out.size(), sizeof(CTRLinger)));
-        return;
-    }
-    if (out.size() == sizeof(u8) && in.size() == sizeof(int)) {
-        *reinterpret_cast<u8*>(out.data()) =
-            static_cast<u8>(*reinterpret_cast<const int*>(in.data()));
-    } else if (out.size() == sizeof(u16_le) && in.size() == sizeof(int)) {
-        *reinterpret_cast<u16_le*>(out.data()) =
-            static_cast<u16_le>(*reinterpret_cast<const int*>(in.data()));
-    } else if (out.size() == sizeof(u32_le) && in.size() == sizeof(int)) {
-        *reinterpret_cast<u32_le*>(out.data()) =
-            static_cast<u32_le>(*reinterpret_cast<const int*>(in.data()));
-    } else {
-        LOG_ERROR(Service_SOC,
-                  "Unknown sockopt data combination: in_size={}, out_size={}, platform_level={}, "
-                  "platform_opt={}",
-                  in.size(), out.size(), platform_level, platform_opt);
-        out = in;
-        return;
-    }
-}
-
-bool SOC_U::GetSocketBlocking(const SocketHolder& socket_holder) {
-    return socket_holder.blocking;
-}
-u32 SOC_U::SetSocketBlocking(SocketHolder& socket_holder, bool blocking) {
-    u32 posix_ret = 0;
-#ifdef _WIN32
-    unsigned long nonblocking = (blocking) ? 0 : 1;
-    int ret = ioctlsocket(socket_holder.socket_fd, FIONBIO, &nonblocking);
-    if (ret == SOCKET_ERROR_VALUE) {
-        posix_ret = TranslateError(GET_ERRNO);
-        return posix_ret;
-    }
-    socket_holder.blocking = blocking;
-#else
-    int flags = ::fcntl(socket_holder.socket_fd, F_GETFL, 0);
-    if (flags == SOCKET_ERROR_VALUE) {
-        posix_ret = TranslateError(GET_ERRNO);
-        return posix_ret;
-    }
-
-    flags &= ~O_NONBLOCK;
-    if (!blocking) { // O_NONBLOCK
-        flags |= O_NONBLOCK;
-    }
-
-    socket_holder.blocking = blocking;
-
-    const int ret = ::fcntl(socket_holder.socket_fd, F_SETFL, flags);
-    if (ret == SOCKET_ERROR_VALUE) {
-        posix_ret = TranslateError(GET_ERRNO);
-        return posix_ret;
-    }
-#endif
-    return posix_ret;
-}
-
-static u32 SendRecvFlagsToPlatform(u32 flags) {
-    u32 ret = 0;
-    if (flags & 1) {
-        ret |= MSG_OOB;
-    }
-    if (flags & 2) {
-        ret |= MSG_PEEK;
-    }
-    if (flags & 4) {
-        // Magic value to decide platform specific action
-        ret |= MSGCUSTOM_HANDLE_DONTWAIT;
-    }
-    return ret;
-}
-
-static s32 ShutdownHowToPlatform(s32 how) {
-    if (how == 0) {
-        return SHUT_RD;
-    }
-    if (how == 1) {
-        return SHUT_WR;
-    }
-    if (how == 2) {
-        return SHUT_RDWR;
-    }
-    return -1;
-}
-
-/// Structure to represent the 3ds' pollfd structure, which is different than most implementations
-struct CTRPollFD {
-    u32 fd; ///< Socket handle
-
-    union Events {
-        u32 hex; ///< The complete value formed by the flags
-        BitField<0, 1, u32> pollrdnorm;
-        BitField<1, 1, u32> pollrdband; // The 3DS OS mistakenly uses POLLRDBAND as POLLPRI,
-        BitField<2, 1, u32> pollpri;    // this is reflected in the translate functions below.
-        BitField<3, 1, u32> pollwrnorm;
-        BitField<4, 1, u32> pollwrband;
-        BitField<5, 1, u32> pollerr;
-        BitField<6, 1, u32> pollhup;
-        BitField<7, 1, u32> pollnval;
-
-        /// Translates the resulting events of a Poll operation from platform-specific to 3ds
-        /// specific
-        static Events TranslateTo3DS(u32 input_event, u8 haslibctrbug) {
-            Events ev = {};
-
-            if (input_event & POLLRDNORM)
-                ev.pollrdnorm.Assign(1);
-            if (input_event & POLLRDBAND)
-                ev.pollpri.Assign(1);
-            if (input_event & POLLHUP)
-                ev.pollhup.Assign(1);
-            if (input_event & POLLERR)
-                ev.pollerr.Assign(1);
-            if (input_event & POLLWRNORM) {
-                if (haslibctrbug) {
-                    ev.pollwrband.Assign(1);
-                } else {
-                    ev.pollwrnorm.Assign(1);
-                }
-            }
-            if (input_event & POLLWRBAND)
-                ev.pollwrband.Assign(1);
-            if (input_event & POLLNVAL)
-                ev.pollnval.Assign(1);
-            return ev;
-        }
-
-        /// Translates the resulting events of a Poll operation from 3ds specific to platform
-        /// specific
-        static u32 TranslateToPlatform(Events input_event, bool isOutput, u8& has_libctru_bug) {
-#if _WIN32
-            constexpr bool isWin = true;
-#else
-            constexpr bool isWin = false;
-#endif
-            has_libctru_bug = 0;
-            if (!input_event.pollwrnorm && input_event.pollwrband) {
-                // Fixes a bug in libctru and some homebrew using libcurl
-                // having the wrong value for POLLOUT
-                input_event.pollwrnorm.Assign(1);
-                input_event.pollwrband.Assign(0);
-                has_libctru_bug = 1;
-            }
-            u32 ret = 0;
-            if (input_event.pollrdnorm)
-                ret |= POLLRDNORM;
-            if (input_event.pollrdband && !isWin)
-                ret |= POLLPRI;
-            if (input_event.pollhup && isOutput)
-                ret |= POLLHUP;
-            if (input_event.pollerr && isOutput)
-                ret |= POLLERR;
-            if (input_event.pollwrnorm)
-                ret |= POLLWRNORM;
-            if (input_event.pollwrband && !isWin)
-                ret |= POLLWRBAND;
-            if (input_event.pollnval && isOutput)
-                ret |= POLLNVAL;
-            return ret;
-        }
-    };
-    Events events;  ///< Events to poll for (input)
-    Events revents; ///< Events received (output)
-
-    /// Converts a platform-specific pollfd to a 3ds specific structure
-    static CTRPollFD FromPlatform(SOC::SOC_U& socu, pollfd const& fd, u8 has_libctru_bug) {
-        CTRPollFD result;
-        result.events.hex = Events::TranslateTo3DS(fd.events, has_libctru_bug).hex;
-        result.revents.hex = Events::TranslateTo3DS(fd.revents, has_libctru_bug).hex;
-        for (const auto& socket : socu.open_sockets) {
-            if (socket.second.socket_fd == fd.fd) {
-                result.fd = socket.first;
-                break;
-            }
-        }
-        return result;
-    }
-
-    /// Converts a 3ds specific pollfd to a platform-specific structure
-    static pollfd ToPlatform(SOC::SOC_U& socu, CTRPollFD const& fd, u8& haslibctrbug) {
-        pollfd result;
-        u8 unused = 0;
-        result.events = Events::TranslateToPlatform(fd.events, false, haslibctrbug);
-        result.revents = Events::TranslateToPlatform(fd.revents, true, unused);
-        auto iter = socu.open_sockets.find(fd.fd);
-        result.fd = (iter != socu.open_sockets.end()) ? iter->second.socket_fd : 0;
-        if (iter == socu.open_sockets.end()) {
-            LOG_ERROR(Service_SOC, "Invalid socket handle: {}", fd.fd);
-        }
-        return result;
-    }
-};
-static_assert(std::is_trivially_copyable_v<CTRPollFD>,
-              "CTRPollFD is used with std::memcpy and must be trivially copyable");
-
-/// Union to represent the 3ds' sockaddr structure
-union CTRSockAddr {
-    /// Structure to represent a raw sockaddr
-    struct {
-        u8 len;           ///< The length of the entire structure, only the set fields count
-        u8 sa_family;     ///< The address family of the sockaddr
-        u8 sa_data[0x1A]; ///< The extra data, this varies, depending on the address family
-    } raw;
-
-    /// Structure to represent the 3ds' sockaddr_in structure
-    struct CTRSockAddrIn {
-        u8 len;        ///< The length of the entire structure
-        u8 sin_family; ///< The address family of the sockaddr_in
-        u16 sin_port;  ///< The port associated with this sockaddr_in
-        u32 sin_addr;  ///< The actual address of the sockaddr_in
-    } in;
-    static_assert(sizeof(CTRSockAddrIn) == 8, "Invalid CTRSockAddrIn size");
-
-    /// Convert a 3DS CTRSockAddr to a platform-specific sockaddr
-    static sockaddr ToPlatform(CTRSockAddr const& ctr_addr) {
-        sockaddr result;
-        ASSERT_MSG(ctr_addr.raw.len == sizeof(CTRSockAddrIn),
-                   "Unhandled address size (len) in CTRSockAddr::ToPlatform");
-        result.sa_family = SocketDomainToPlatform(ctr_addr.raw.sa_family);
-        std::memset(result.sa_data, 0, sizeof(result.sa_data));
-
-        // We can not guarantee ABI compatibility between platforms so we copy the fields manually
-        switch (result.sa_family) {
-        case AF_INET: {
-            sockaddr_in* result_in = reinterpret_cast<sockaddr_in*>(&result);
-            result_in->sin_port = ctr_addr.in.sin_port;
-            result_in->sin_addr.s_addr = ctr_addr.in.sin_addr;
-            std::memset(result_in->sin_zero, 0, sizeof(result_in->sin_zero));
-            break;
-        }
-        default:
-            ASSERT_MSG(false, "Unhandled address family (sa_family) in CTRSockAddr::ToPlatform");
-            break;
-        }
-        return result;
-    }
-
-    /// Convert a platform-specific sockaddr to a 3DS CTRSockAddr
-    static CTRSockAddr FromPlatform(sockaddr const& addr) {
-        CTRSockAddr result;
-        result.raw.sa_family = static_cast<u8>(SocketDomainFromPlatform(addr.sa_family));
-        // We can not guarantee ABI compatibility between platforms so we copy the fields manually
-        switch (addr.sa_family) {
-        case AF_INET: {
-            sockaddr_in const* addr_in = reinterpret_cast<sockaddr_in const*>(&addr);
-            result.raw.len = sizeof(CTRSockAddrIn);
-            result.in.sin_port = addr_in->sin_port;
-            result.in.sin_addr = addr_in->sin_addr.s_addr;
-            break;
-        }
-        default:
-            ASSERT_MSG(false, "Unhandled address family (sa_family) in CTRSockAddr::ToPlatform");
-            break;
-        }
-        return result;
-    }
-};
-
-struct CTRAddrInfo {
-    s32_le ai_flags;
-    s32_le ai_family;
-    s32_le ai_socktype;
-    s32_le ai_protocol;
-    s32_le ai_addrlen;
-    char ai_canonname[256];
-    CTRSockAddr ai_addr;
-
-    static u32 AddressInfoFlagsToPlatform(u32 flags) {
-        u32 ret = 0;
-        if (flags & 1) {
-            ret |= AI_PASSIVE;
-        }
-        if (flags & 2) {
-            ret |= AI_CANONNAME;
-        }
-        if (flags & 4) {
-            ret |= AI_NUMERICHOST;
-        }
-        if (flags & 8) {
-            ret |= AI_NUMERICSERV;
-        }
-        return ret;
-    }
-
-    static u32 AddressInfoFlagsFromPlatform(u32 flags) {
-        u32 ret = 0;
-        if (flags & AI_PASSIVE) {
-            ret |= 1;
-        }
-        if (flags & AI_CANONNAME) {
-            ret |= 2;
-        }
-        if (flags & AI_NUMERICHOST) {
-            ret |= 4;
-        }
-        if (flags & AI_NUMERICSERV) {
-            ret |= 8;
-        }
-        return ret;
-    }
-
-    /// Converts a platform-specific addrinfo to a 3ds addrinfo.
-    static CTRAddrInfo FromPlatform(const addrinfo& addr) {
-        CTRAddrInfo ctr_addr{
-            .ai_flags = static_cast<s32_le>(AddressInfoFlagsFromPlatform(addr.ai_flags)),
-            .ai_family = static_cast<s32_le>(SocketDomainFromPlatform(addr.ai_family)),
-            .ai_socktype = static_cast<s32_le>(SocketTypeFromPlatform(addr.ai_socktype)),
-            .ai_protocol = static_cast<s32_le>(SocketProtocolFromPlatform(addr.ai_protocol)),
-            .ai_addr = CTRSockAddr::FromPlatform(*addr.ai_addr),
-        };
-        ctr_addr.ai_addrlen = static_cast<s32_le>(ctr_addr.ai_addr.raw.len);
-        if (addr.ai_canonname)
-            std::strncpy(ctr_addr.ai_canonname, addr.ai_canonname,
-                         sizeof(ctr_addr.ai_canonname) - 1);
-        return ctr_addr;
-    }
-
-    /// Converts a platform-specific addrinfo to a 3ds addrinfo.
-    static addrinfo ToPlatform(const CTRAddrInfo& ctr_addr) {
-        // Only certain fields are meaningful in hints, copy them manually
-        addrinfo addr = {
-            .ai_flags = static_cast<int>(AddressInfoFlagsToPlatform(ctr_addr.ai_flags)),
-            .ai_family = static_cast<int>(SocketDomainToPlatform(ctr_addr.ai_family)),
-            .ai_socktype = static_cast<int>(SocketTypeToPlatform(ctr_addr.ai_socktype)),
-            .ai_protocol = static_cast<int>(SocketProtocolToPlatform(ctr_addr.ai_protocol)),
-        };
-        return addr;
-    }
-};
-
-static u32 NameInfoFlagsToPlatform(u32 flags) {
-    u32 ret = 0;
-    if (flags & 1) {
-        ret |= NI_NOFQDN;
-    }
-    if (flags & 2) {
-        ret |= NI_NUMERICHOST;
-    }
-    if (flags & 4) {
-        ret |= NI_NAMEREQD;
-    }
-    if (flags & 8) {
-        ret |= NI_NUMERICSERV;
-    }
-    if (flags & 16) {
-        ret |= NI_DGRAM;
-    }
-    return ret;
-}
-
-static_assert(sizeof(CTRAddrInfo) == 0x130, "Size of CTRAddrInfo is not correct");
-
-void SOC_U::PreTimerAdjust() {
-    adjust_value_last = std::chrono::steady_clock::now();
-}
-
-void SOC_U::PostTimerAdjust(Kernel::HLERequestContext& ctx, const std::string& caller_method) {
-    std::chrono::time_point<std::chrono::steady_clock> new_timer = std::chrono::steady_clock::now();
-    ASSERT(new_timer >= adjust_value_last);
-    ctx.SleepClientThread(
-        fmt::format("soc_u::{}", caller_method),
-        std::chrono::duration_cast<std::chrono::nanoseconds>(new_timer - adjust_value_last),
-        nullptr);
-}
-
-void SOC_U::CleanupSockets() {
-    for (const auto& sock : open_sockets)
-        closesocket(sock.second.socket_fd);
-    open_sockets.clear();
-}
-
-void SOC_U::Socket(Kernel::HLERequestContext& ctx) {
-    IPC::RequestParser rp(ctx);
-    u32 domain = SocketDomainToPlatform(rp.Pop<u32>()); // Address family
-    u32 type = SocketTypeToPlatform(rp.Pop<u32>());
-    u32 protocol = SocketProtocolToPlatform(rp.Pop<u32>());
-    rp.PopPID();
-
-    IPC::RequestBuilder rb = rp.MakeBuilder(2, 0);
-
-    // Only 0 is allowed according to 3dbrew, using 0 will let the OS decide which protocol to use
-    if (protocol != 0) {
-        rb.Push(UnimplementedFunction(ErrorModule::SOC)); // TODO(Subv): Correct error code
-        rb.Skip(1, false);
-        return;
-    }
-
-    if (domain != AF_INET) {
-        rb.Push(UnimplementedFunction(ErrorModule::SOC)); // TODO(Subv): Correct error code
-        rb.Skip(1, false);
-        return;
-    }
-
-    if (type != SOCK_DGRAM && type != SOCK_STREAM) {
-        rb.Push(UnimplementedFunction(ErrorModule::SOC)); // TODO(Subv): Correct error code
-        rb.Skip(1, false);
-        return;
-    }
-
-    u64 ret = static_cast<u64>(::socket(domain, type, protocol));
-    u32 socketHandle = GetNextSocketID();
-
-    if ((s64)ret != SOCKET_ERROR_VALUE) {
-        open_sockets[socketHandle] = {static_cast<decltype(SocketHolder::socket_fd)>(ret), true};
-#if _WIN32
-        // Disable UDP connection reset
-        int new_behavior = 0;
-        unsigned long bytes_returned = 0;
-        WSAIoctl(static_cast<SOCKET>(ret), _WSAIOW(IOC_VENDOR, 12), &new_behavior,
-                 sizeof(new_behavior), NULL, 0, &bytes_returned, NULL, NULL);
-#endif
-    }
-
-    if ((s64)ret == SOCKET_ERROR_VALUE)
-        ret = TranslateError(GET_ERRNO);
-
-    rb.Push(RESULT_SUCCESS);
-    rb.Push(socketHandle);
-}
-
-void SOC_U::Bind(Kernel::HLERequestContext& ctx) {
-    IPC::RequestParser rp(ctx);
-    u32 socket_handle = rp.Pop<u32>();
-    auto fd_info = open_sockets.find(socket_handle);
-    if (fd_info == open_sockets.end()) {
-        LOG_ERROR(Service_SOC, "Invalid socket handle: {}", socket_handle);
-        IPC::RequestBuilder rb = rp.MakeBuilder(1, 0);
-        rb.Push(ERR_INVALID_HANDLE);
-        return;
-    }
-    u32 len = rp.Pop<u32>();
-    rp.PopPID();
-    auto sock_addr_buf = rp.PopStaticBuffer();
-
-    CTRSockAddr ctr_sock_addr;
-    std::memcpy(&ctr_sock_addr, sock_addr_buf.data(), len);
-
-    sockaddr sock_addr = CTRSockAddr::ToPlatform(ctr_sock_addr);
-
-    s32 ret = ::bind(fd_info->second.socket_fd, &sock_addr, sizeof(sock_addr));
-
-    if (ret != 0)
-        ret = TranslateError(GET_ERRNO);
-
-    IPC::RequestBuilder rb = rp.MakeBuilder(2, 0);
-    rb.Push(RESULT_SUCCESS);
-    rb.Push(ret);
-}
-
-void SOC_U::Fcntl(Kernel::HLERequestContext& ctx) {
-    IPC::RequestParser rp(ctx);
-    u32 socket_handle = rp.Pop<u32>();
-    auto fd_info = open_sockets.find(socket_handle);
-    if (fd_info == open_sockets.end()) {
-        LOG_ERROR(Service_SOC, "Invalid socket handle: {}", socket_handle);
-        IPC::RequestBuilder rb = rp.MakeBuilder(1, 0);
-        rb.Push(ERR_INVALID_HANDLE);
-        return;
-    }
-    u32 ctr_cmd = rp.Pop<u32>();
-    u32 ctr_arg = rp.Pop<u32>();
-    rp.PopPID();
-
-    u32 posix_ret = 0; // TODO: Check what hardware returns for F_SETFL (unspecified by POSIX)
-    SCOPE_EXIT({
-        IPC::RequestBuilder rb = rp.MakeBuilder(2, 0);
-        rb.Push(RESULT_SUCCESS);
-        rb.Push(posix_ret);
-    });
-
-    if (ctr_cmd == 3) { // F_GETFL
-        posix_ret = 0;
-        if (GetSocketBlocking(fd_info->second) == false)
-            posix_ret |= 4;    // O_NONBLOCK
-    } else if (ctr_cmd == 4) { // F_SETFL
-        posix_ret = SetSocketBlocking(fd_info->second, !(ctr_arg & 4));
-    } else {
-        LOG_ERROR(Service_SOC, "Unsupported command ({}) in fcntl call", ctr_cmd);
-        posix_ret = TranslateError(EINVAL); // TODO: Find the correct error
-        return;
-    }
-}
-
-void SOC_U::Listen(Kernel::HLERequestContext& ctx) {
-    IPC::RequestParser rp(ctx);
-    u32 socket_handle = rp.Pop<u32>();
-    auto fd_info = open_sockets.find(socket_handle);
-    if (fd_info == open_sockets.end()) {
-        LOG_ERROR(Service_SOC, "Invalid socket handle: {}", socket_handle);
-        IPC::RequestBuilder rb = rp.MakeBuilder(1, 0);
-        rb.Push(ERR_INVALID_HANDLE);
-        return;
-    }
-    u32 backlog = rp.Pop<u32>();
-    rp.PopPID();
-
-    s32 ret = ::listen(fd_info->second.socket_fd, backlog);
-    if (ret != 0)
-        ret = TranslateError(GET_ERRNO);
-
-    IPC::RequestBuilder rb = rp.MakeBuilder(2, 0);
-    rb.Push(RESULT_SUCCESS);
-    rb.Push(ret);
-}
-
-void SOC_U::Accept(Kernel::HLERequestContext& ctx) {
-    // TODO(Subv): Calling this function on a blocking socket will block the emu thread,
-    // preventing graceful shutdown when closing the emulator, this can be fixed by always
-    // performing nonblocking operations and spinlock until the data is available
-    IPC::RequestParser rp(ctx);
-    const auto socket_handle = rp.Pop<u32>();
-    auto fd_info = open_sockets.find(socket_handle);
-    if (fd_info == open_sockets.end()) {
-        LOG_ERROR(Service_SOC, "Invalid socket handle: {}", socket_handle);
-        IPC::RequestBuilder rb = rp.MakeBuilder(1, 0);
-        rb.Push(ERR_INVALID_HANDLE);
-        return;
-    }
-    const auto max_addr_len = rp.Pop<u32>();
-    rp.PopPID();
-    sockaddr addr;
-    socklen_t addr_len = sizeof(addr);
-    u32 ret = static_cast<u32>(::accept(fd_info->second.socket_fd, &addr, &addr_len));
-
-    if (static_cast<s32>(ret) != SOCKET_ERROR_VALUE) {
-        u32 socketID = GetNextSocketID();
-        open_sockets[socketID] = {static_cast<decltype(SocketHolder::socket_fd)>(ret), true};
-        ret = socketID;
-    }
-
-    CTRSockAddr ctr_addr;
-    std::vector<u8> ctr_addr_buf(sizeof(ctr_addr));
-    if (static_cast<s32>(ret) == SOCKET_ERROR_VALUE) {
-        ret = TranslateError(GET_ERRNO);
-    } else {
-        ctr_addr = CTRSockAddr::FromPlatform(addr);
-        std::memcpy(ctr_addr_buf.data(), &ctr_addr, sizeof(ctr_addr));
-    }
-
-    if (ctr_addr_buf.size() > max_addr_len) {
-        LOG_WARNING(Frontend, "CTRSockAddr is too long, truncating data.");
-        ctr_addr_buf.resize(max_addr_len);
-    }
-
-    IPC::RequestBuilder rb = rp.MakeBuilder(2, 2);
-    rb.Push(RESULT_SUCCESS);
-    rb.Push(ret);
-    rb.PushStaticBuffer(std::move(ctr_addr_buf), 0);
-}
-
-void SOC_U::GetHostId(Kernel::HLERequestContext& ctx) {
-    IPC::RequestParser rp(ctx);
-
-    u32 host_id = 0;
-    auto info = GetDefaultInterfaceInfo();
-    if (info.has_value()) {
-        host_id = info->address;
-    }
-
-    IPC::RequestBuilder rb = rp.MakeBuilder(2, 0);
-    rb.Push(RESULT_SUCCESS);
-    rb.Push(host_id);
-}
-
-void SOC_U::Close(Kernel::HLERequestContext& ctx) {
-    IPC::RequestParser rp(ctx);
-    u32 socket_handle = rp.Pop<u32>();
-    auto fd_info = open_sockets.find(socket_handle);
-    if (fd_info == open_sockets.end()) {
-        LOG_ERROR(Service_SOC, "Invalid socket handle: {}", socket_handle);
-        IPC::RequestBuilder rb = rp.MakeBuilder(1, 0);
-        rb.Push(ERR_INVALID_HANDLE);
-        return;
-    }
-    rp.PopPID();
-
-    s32 ret = 0;
-
-    ret = closesocket(fd_info->second.socket_fd);
-
-    open_sockets.erase(socket_handle);
-
-    if (ret != 0)
-        ret = TranslateError(GET_ERRNO);
-
-    IPC::RequestBuilder rb = rp.MakeBuilder(2, 0);
-    rb.Push(RESULT_SUCCESS);
-    rb.Push(ret);
-}
-
-void SOC_U::SendToOther(Kernel::HLERequestContext& ctx) {
-    IPC::RequestParser rp(ctx);
-    const u32 socket_handle = rp.Pop<u32>();
-    const auto fd_info = open_sockets.find(socket_handle);
-    if (fd_info == open_sockets.end()) {
-        LOG_ERROR(Service_SOC, "Invalid socket handle: {}", socket_handle);
-        IPC::RequestBuilder rb = rp.MakeBuilder(1, 0);
-        rb.Push(ERR_INVALID_HANDLE);
-        return;
-    }
-    const u32 len = rp.Pop<u32>();
-    u32 flags = SendRecvFlagsToPlatform(rp.Pop<u32>());
-    bool dont_wait = (flags & MSGCUSTOM_HANDLE_DONTWAIT) != 0;
-    flags &= ~MSGCUSTOM_HANDLE_DONTWAIT;
-#ifdef _WIN32
-    bool was_blocking = GetSocketBlocking(fd_info->second);
-    if (dont_wait && was_blocking) {
-        SetSocketBlocking(fd_info->second, false);
-    }
-#else
-    if (dont_wait) {
-        flags |= MSG_DONTWAIT;
-    }
-#endif // _WIN32
-    const u32 addr_len = rp.Pop<u32>();
-    rp.PopPID();
-    const auto dest_addr_buffer = rp.PopStaticBuffer();
-
-    auto input_mapped_buff = rp.PopMappedBuffer();
-    std::vector<u8> input_buff(len);
-    input_mapped_buff.Read(input_buff.data(), 0,
-                           std::min(input_mapped_buff.GetSize(), static_cast<size_t>(len)));
-
-    s32 ret = -1;
-    if (addr_len > 0) {
-        CTRSockAddr ctr_dest_addr;
-        std::memcpy(&ctr_dest_addr, dest_addr_buffer.data(), sizeof(ctr_dest_addr));
-        sockaddr dest_addr = CTRSockAddr::ToPlatform(ctr_dest_addr);
-        ret = ::sendto(fd_info->second.socket_fd, reinterpret_cast<const char*>(input_buff.data()),
-                       len, flags, &dest_addr, sizeof(dest_addr));
-    } else {
-        ret = ::sendto(fd_info->second.socket_fd, reinterpret_cast<const char*>(input_buff.data()),
-                       len, flags, nullptr, 0);
-    }
-
-    const auto send_error = (ret == SOCKET_ERROR_VALUE) ? GET_ERRNO : 0;
-
-#ifdef _WIN32
-    if (dont_wait && was_blocking) {
-        SetSocketBlocking(fd_info->second, true);
-    }
-#endif
-
-    if (ret == SOCKET_ERROR_VALUE) {
-        ret = TranslateError(send_error);
-    }
-
-    IPC::RequestBuilder rb = rp.MakeBuilder(2, 0);
-    rb.Push(RESULT_SUCCESS);
-    rb.Push(ret);
-}
-
-void SOC_U::SendTo(Kernel::HLERequestContext& ctx) {
-    IPC::RequestParser rp(ctx);
-    u32 socket_handle = rp.Pop<u32>();
-    auto fd_info = open_sockets.find(socket_handle);
-    if (fd_info == open_sockets.end()) {
-        LOG_ERROR(Service_SOC, "Invalid socket handle: {}", socket_handle);
-        IPC::RequestBuilder rb = rp.MakeBuilder(1, 0);
-        rb.Push(ERR_INVALID_HANDLE);
-        return;
-    }
-    u32 len = rp.Pop<u32>();
-    u32 flags = SendRecvFlagsToPlatform(rp.Pop<u32>());
-    bool dont_wait = (flags & MSGCUSTOM_HANDLE_DONTWAIT) != 0;
-    flags &= ~MSGCUSTOM_HANDLE_DONTWAIT;
-#ifdef _WIN32
-    bool was_blocking = GetSocketBlocking(fd_info->second);
-    if (dont_wait && was_blocking) {
-        SetSocketBlocking(fd_info->second, false);
-    }
-#else
-    if (dont_wait) {
-        flags |= MSG_DONTWAIT;
-    }
-#endif // _WIN32
-    u32 addr_len = rp.Pop<u32>();
-    rp.PopPID();
-    auto input_buff = rp.PopStaticBuffer();
-    auto dest_addr_buff = rp.PopStaticBuffer();
-
-    s32 ret = -1;
-    if (addr_len > 0) {
-        CTRSockAddr ctr_dest_addr;
-        std::memcpy(&ctr_dest_addr, dest_addr_buff.data(), sizeof(ctr_dest_addr));
-        sockaddr dest_addr = CTRSockAddr::ToPlatform(ctr_dest_addr);
-        ret = ::sendto(fd_info->second.socket_fd, reinterpret_cast<const char*>(input_buff.data()),
-                       len, flags, &dest_addr, sizeof(dest_addr));
-    } else {
-        ret = ::sendto(fd_info->second.socket_fd, reinterpret_cast<const char*>(input_buff.data()),
-                       len, flags, nullptr, 0);
-    }
-
-    auto send_error = (ret == SOCKET_ERROR_VALUE) ? GET_ERRNO : 0;
-
-#ifdef _WIN32
-    if (dont_wait && was_blocking) {
-        SetSocketBlocking(fd_info->second, true);
-    }
-#endif
-
-    if (ret == SOCKET_ERROR_VALUE)
-        ret = TranslateError(send_error);
-
-    IPC::RequestBuilder rb = rp.MakeBuilder(2, 0);
-    rb.Push(RESULT_SUCCESS);
-    rb.Push(ret);
-}
-
-void SOC_U::RecvFromOther(Kernel::HLERequestContext& ctx) {
-    IPC::RequestParser rp(ctx);
-    u32 socket_handle = rp.Pop<u32>();
-    auto fd_info = open_sockets.find(socket_handle);
-    if (fd_info == open_sockets.end()) {
-        LOG_ERROR(Service_SOC, "Invalid socket handle: {}", socket_handle);
-        IPC::RequestBuilder rb = rp.MakeBuilder(1, 0);
-        rb.Push(ERR_INVALID_HANDLE);
-        return;
-    }
-    u32 len = rp.Pop<u32>();
-    u32 flags = SendRecvFlagsToPlatform(rp.Pop<u32>());
-    bool dont_wait = (flags & MSGCUSTOM_HANDLE_DONTWAIT) != 0;
-    flags &= ~MSGCUSTOM_HANDLE_DONTWAIT;
-#ifdef _WIN32
-    bool was_blocking = GetSocketBlocking(fd_info->second);
-    if (dont_wait && was_blocking) {
-        SetSocketBlocking(fd_info->second, false);
-    }
-#else
-    if (dont_wait) {
-        flags |= MSG_DONTWAIT;
-    }
-#endif // _WIN32
-    u32 addr_len = rp.Pop<u32>();
-    rp.PopPID();
-    auto& buffer = rp.PopMappedBuffer();
-
-    CTRSockAddr ctr_src_addr;
-    std::vector<u8> output_buff(len);
-    std::vector<u8> addr_buff(addr_len);
-    sockaddr src_addr;
-    socklen_t src_addr_len = sizeof(src_addr);
-
-    s32 ret = -1;
-    if (GetSocketBlocking(fd_info->second) && !dont_wait) {
-        PreTimerAdjust();
-    }
-
-    if (addr_len > 0) {
-        ret = ::recvfrom(fd_info->second.socket_fd, reinterpret_cast<char*>(output_buff.data()),
-                         len, flags, &src_addr, &src_addr_len);
-        if (ret >= 0 && src_addr_len > 0) {
-            ctr_src_addr = CTRSockAddr::FromPlatform(src_addr);
-            std::memcpy(addr_buff.data(), &ctr_src_addr, addr_len);
-        }
-    } else {
-        ret = ::recvfrom(fd_info->second.socket_fd, reinterpret_cast<char*>(output_buff.data()),
-                         len, flags, NULL, 0);
-        addr_buff.resize(0);
-    }
-    int recv_error = (ret == SOCKET_ERROR_VALUE) ? GET_ERRNO : 0;
-    if (GetSocketBlocking(fd_info->second) && !dont_wait) {
-        PostTimerAdjust(ctx, "RecvFromOther");
-    }
-#ifdef _WIN32
-    if (dont_wait && was_blocking) {
-        SetSocketBlocking(fd_info->second, true);
-    }
-#endif
-    if (ret == SOCKET_ERROR_VALUE) {
-        ret = TranslateError(recv_error);
-    } else {
-        buffer.Write(output_buff.data(), 0, ret);
-    }
-
-    IPC::RequestBuilder rb = rp.MakeBuilder(2, 4);
-    rb.Push(RESULT_SUCCESS);
-    rb.Push(ret);
-    rb.PushStaticBuffer(std::move(addr_buff), 0);
-    rb.PushMappedBuffer(buffer);
-}
-
-void SOC_U::RecvFrom(Kernel::HLERequestContext& ctx) {
-    // TODO(Subv): Calling this function on a blocking socket will block the emu thread,
-    // preventing graceful shutdown when closing the emulator, this can be fixed by always
-    // performing nonblocking operations and spinlock until the data is available
-    IPC::RequestParser rp(ctx);
-    u32 socket_handle = rp.Pop<u32>();
-    auto fd_info = open_sockets.find(socket_handle);
-    if (fd_info == open_sockets.end()) {
-        LOG_ERROR(Service_SOC, "Invalid socket handle: {}", socket_handle);
-        IPC::RequestBuilder rb = rp.MakeBuilder(1, 0);
-        rb.Push(ERR_INVALID_HANDLE);
-        return;
-    }
-    u32 len = rp.Pop<u32>();
-    u32 flags = SendRecvFlagsToPlatform(rp.Pop<u32>());
-    bool dont_wait = (flags & MSGCUSTOM_HANDLE_DONTWAIT) != 0;
-    flags &= ~MSGCUSTOM_HANDLE_DONTWAIT;
-#ifdef _WIN32
-    bool was_blocking = GetSocketBlocking(fd_info->second);
-    if (dont_wait && was_blocking) {
-        SetSocketBlocking(fd_info->second, false);
-    }
-#else
-    if (dont_wait) {
-        flags |= MSG_DONTWAIT;
-    }
-#endif // _WIN32
-    u32 addr_len = rp.Pop<u32>();
-    rp.PopPID();
-
-    CTRSockAddr ctr_src_addr;
-    std::vector<u8> output_buff(len);
-    std::vector<u8> addr_buff(addr_len);
-    sockaddr src_addr;
-    socklen_t src_addr_len = sizeof(src_addr);
-
-    s32 ret = -1;
-    if (GetSocketBlocking(fd_info->second) && !dont_wait) {
-        PreTimerAdjust();
-    }
-    if (addr_len > 0) {
-        // Only get src adr if input adr available
-        ret = ::recvfrom(fd_info->second.socket_fd, reinterpret_cast<char*>(output_buff.data()),
-                         len, flags, &src_addr, &src_addr_len);
-        if (ret >= 0 && src_addr_len > 0) {
-            ctr_src_addr = CTRSockAddr::FromPlatform(src_addr);
-            std::memcpy(addr_buff.data(), &ctr_src_addr, addr_len);
-        }
-    } else {
-        ret = ::recvfrom(fd_info->second.socket_fd, reinterpret_cast<char*>(output_buff.data()),
-                         len, flags, NULL, 0);
-        addr_buff.resize(0);
-    }
-    int recv_error = (ret == SOCKET_ERROR_VALUE) ? GET_ERRNO : 0;
-    if (GetSocketBlocking(fd_info->second) && !dont_wait) {
-        PostTimerAdjust(ctx, "RecvFrom");
-    }
-#ifdef _WIN32
-    if (dont_wait && was_blocking) {
-        SetSocketBlocking(fd_info->second, true);
-    }
-#endif
-    s32 total_received = ret;
-    if (ret == SOCKET_ERROR_VALUE) {
-        ret = TranslateError(recv_error);
-        total_received = 0;
-    }
-
-    // Write only the data we received to avoid overwriting parts of the buffer with zeros
-    output_buff.resize(total_received);
-
-    IPC::RequestBuilder rb = rp.MakeBuilder(3, 4);
-    rb.Push(RESULT_SUCCESS);
-    rb.Push(ret);
-    rb.Push(total_received);
-    rb.PushStaticBuffer(std::move(output_buff), 0);
-    rb.PushStaticBuffer(std::move(addr_buff), 1);
-}
-
-void SOC_U::Poll(Kernel::HLERequestContext& ctx) {
-    IPC::RequestParser rp(ctx);
-    u32 nfds = rp.Pop<u32>();
-    s32 timeout = rp.Pop<s32>();
-    rp.PopPID();
-    auto input_fds = rp.PopStaticBuffer();
-
-    std::vector<CTRPollFD> ctr_fds(nfds);
-    std::memcpy(ctr_fds.data(), input_fds.data(), nfds * sizeof(CTRPollFD));
-
-    // The 3ds_pollfd and the pollfd structures may be different (Windows/Linux have different
-    // sizes)
-    // so we have to copy the data in order
-    std::vector<pollfd> platform_pollfd(nfds);
-    std::vector<u8> has_libctru_bug(nfds, false);
-    for (u32 i = 0; i < nfds; i++) {
-        platform_pollfd[i] = CTRPollFD::ToPlatform(*this, ctr_fds[i], has_libctru_bug[i]);
-    }
-
-    if (timeout) {
-        PreTimerAdjust();
-    }
-    s32 ret = ::poll(platform_pollfd.data(), nfds, timeout);
-    if (timeout) {
-        PostTimerAdjust(ctx, "Poll");
-    }
-
-    // Now update the output 3ds_pollfd structure
-    for (u32 i = 0; i < nfds; i++) {
-        ctr_fds[i] = CTRPollFD::FromPlatform(*this, platform_pollfd[i], has_libctru_bug[i]);
-    }
-
-    std::vector<u8> output_fds(nfds * sizeof(CTRPollFD));
-    std::memcpy(output_fds.data(), ctr_fds.data(), nfds * sizeof(CTRPollFD));
-
-    if (ret == SOCKET_ERROR_VALUE) {
-        int err = GET_ERRNO;
-        LOG_ERROR(Service_SOC, "Socket error: {}", err);
-
-        ret = TranslateError(GET_ERRNO);
-    }
-
-    IPC::RequestBuilder rb = rp.MakeBuilder(2, 2);
-    rb.Push(RESULT_SUCCESS);
-    rb.Push(ret);
-    rb.PushStaticBuffer(std::move(output_fds), 0);
-}
-
-void SOC_U::GetSockName(Kernel::HLERequestContext& ctx) {
-    IPC::RequestParser rp(ctx);
-    const auto socket_handle = rp.Pop<u32>();
-    auto fd_info = open_sockets.find(socket_handle);
-    if (fd_info == open_sockets.end()) {
-        LOG_ERROR(Service_SOC, "Invalid socket handle: {}", socket_handle);
-        IPC::RequestBuilder rb = rp.MakeBuilder(1, 0);
-        rb.Push(ERR_INVALID_HANDLE);
-        return;
-    }
-    const auto max_addr_len = rp.Pop<u32>();
-    rp.PopPID();
-
-    sockaddr dest_addr;
-    socklen_t dest_addr_len = sizeof(dest_addr);
-    s32 ret = ::getsockname(fd_info->second.socket_fd, &dest_addr, &dest_addr_len);
-
-    CTRSockAddr ctr_dest_addr = CTRSockAddr::FromPlatform(dest_addr);
-    std::vector<u8> dest_addr_buff(sizeof(ctr_dest_addr));
-    std::memcpy(dest_addr_buff.data(), &ctr_dest_addr, sizeof(ctr_dest_addr));
-
-    if (ret != 0)
-        ret = TranslateError(GET_ERRNO);
-
-    if (dest_addr_buff.size() > max_addr_len) {
-        LOG_WARNING(Frontend, "CTRSockAddr is too long, truncating data.");
-        dest_addr_buff.resize(max_addr_len);
-    }
-
-    IPC::RequestBuilder rb = rp.MakeBuilder(2, 2);
-    rb.Push(RESULT_SUCCESS);
-    rb.Push(ret);
-    rb.PushStaticBuffer(std::move(dest_addr_buff), 0);
-}
-
-void SOC_U::Shutdown(Kernel::HLERequestContext& ctx) {
-    IPC::RequestParser rp(ctx);
-    u32 socket_handle = rp.Pop<u32>();
-    auto fd_info = open_sockets.find(socket_handle);
-    if (fd_info == open_sockets.end()) {
-        LOG_ERROR(Service_SOC, "Invalid socket handle: {}", socket_handle);
-        IPC::RequestBuilder rb = rp.MakeBuilder(1, 0);
-        rb.Push(ERR_INVALID_HANDLE);
-        return;
-    }
-    s32 how = ShutdownHowToPlatform(rp.Pop<s32>());
-    rp.PopPID();
-
-    s32 ret = ::shutdown(fd_info->second.socket_fd, how);
-    if (ret != 0)
-        ret = TranslateError(GET_ERRNO);
-    IPC::RequestBuilder rb = rp.MakeBuilder(2, 0);
-    rb.Push(RESULT_SUCCESS);
-    rb.Push(ret);
-}
-
-void SOC_U::GetHostByName(Kernel::HLERequestContext& ctx) {
-    IPC::RequestParser rp(ctx);
-    [[maybe_unused]] u32 name_len = rp.Pop<u32>();
-    [[maybe_unused]] u32 out_buf_len = rp.Pop<u32>();
-    auto host_name = rp.PopStaticBuffer();
-
-    struct hostent* result = ::gethostbyname(reinterpret_cast<char*>(host_name.data()));
-
-    std::vector<u8> hbn_data_out(sizeof(HostByNameData));
-    HostByNameData& hbn_data = *reinterpret_cast<HostByNameData*>(hbn_data_out.data());
-    int ret = 0;
-
-    if (result) {
-        hbn_data.addr_type = result->h_addrtype;
-        hbn_data.addr_len = result->h_length;
-        std::strncpy(hbn_data.h_name.data(), result->h_name, 255);
-        u16 count;
-        for (count = 0; count < HostByNameData::max_entries; count++) {
-            char* curr = result->h_aliases[count];
-            if (!curr) {
-                break;
-            }
-            std::strncpy(hbn_data.aliases[count].data(), curr, 255);
-        }
-        hbn_data.alias_count = count;
-        for (count = 0; count < HostByNameData::max_entries; count++) {
-            char* curr = result->h_addr_list[count];
-            if (!curr) {
-                break;
-            }
-            std::memcpy(hbn_data.addresses[count].data(), curr, result->h_length);
-        }
-        hbn_data.addr_count = count;
-    } else {
-        ret = -1;
-    }
-
-    IPC::RequestBuilder rb = rp.MakeBuilder(2, 2);
-    rb.Push(RESULT_SUCCESS);
-    rb.Push(ret);
-    rb.PushStaticBuffer(std::move(hbn_data_out), 0);
-}
-
-void SOC_U::GetPeerName(Kernel::HLERequestContext& ctx) {
-    IPC::RequestParser rp(ctx);
-    const auto socket_handle = rp.Pop<u32>();
-    auto fd_info = open_sockets.find(socket_handle);
-    if (fd_info == open_sockets.end()) {
-        LOG_ERROR(Service_SOC, "Invalid socket handle: {}", socket_handle);
-        IPC::RequestBuilder rb = rp.MakeBuilder(1, 0);
-        rb.Push(ERR_INVALID_HANDLE);
-        return;
-    }
-    const auto max_addr_len = rp.Pop<u32>();
-    rp.PopPID();
-
-    sockaddr dest_addr;
-    socklen_t dest_addr_len = sizeof(dest_addr);
-    const int ret = ::getpeername(fd_info->second.socket_fd, &dest_addr, &dest_addr_len);
-
-    CTRSockAddr ctr_dest_addr = CTRSockAddr::FromPlatform(dest_addr);
-    std::vector<u8> dest_addr_buff(sizeof(ctr_dest_addr));
-    std::memcpy(dest_addr_buff.data(), &ctr_dest_addr, sizeof(ctr_dest_addr));
-
-    int result = 0;
-    if (ret != 0) {
-        result = TranslateError(GET_ERRNO);
-    }
-
-    if (dest_addr_buff.size() > max_addr_len) {
-        LOG_WARNING(Frontend, "CTRSockAddr is too long, truncating data.");
-        dest_addr_buff.resize(max_addr_len);
-    }
-
-    IPC::RequestBuilder rb = rp.MakeBuilder(2, 2);
-    rb.Push(RESULT_SUCCESS);
-    rb.Push(result);
-    rb.PushStaticBuffer(std::move(dest_addr_buff), 0);
-}
-
-void SOC_U::Connect(Kernel::HLERequestContext& ctx) {
-    // TODO(Subv): Calling this function on a blocking socket will block the emu thread,
-    // preventing graceful shutdown when closing the emulator, this can be fixed by always
-    // performing nonblocking operations and spinlock until the data is available
-    IPC::RequestParser rp(ctx);
-    const auto socket_handle = rp.Pop<u32>();
-    auto fd_info = open_sockets.find(socket_handle);
-    if (fd_info == open_sockets.end()) {
-        LOG_ERROR(Service_SOC, "Invalid socket handle: {}", socket_handle);
-        IPC::RequestBuilder rb = rp.MakeBuilder(1, 0);
-        rb.Push(ERR_INVALID_HANDLE);
-        return;
-    }
-    [[maybe_unused]] const auto input_addr_len = rp.Pop<u32>();
-    rp.PopPID();
-    auto input_addr_buf = rp.PopStaticBuffer();
-
-    CTRSockAddr ctr_input_addr;
-    std::memcpy(&ctr_input_addr, input_addr_buf.data(), sizeof(ctr_input_addr));
-
-    sockaddr input_addr = CTRSockAddr::ToPlatform(ctr_input_addr);
-    if (GetSocketBlocking(fd_info->second)) {
-        PreTimerAdjust();
-    }
-    s32 ret = ::connect(fd_info->second.socket_fd, &input_addr, sizeof(input_addr));
-    if (GetSocketBlocking(fd_info->second)) {
-        PostTimerAdjust(ctx, "Connect");
-    }
-    if (ret != 0)
-        ret = TranslateError(GET_ERRNO);
-
-    IPC::RequestBuilder rb = rp.MakeBuilder(2, 0);
-    rb.Push(RESULT_SUCCESS);
-    rb.Push(ret);
-}
-
-void SOC_U::InitializeSockets(Kernel::HLERequestContext& ctx) {
-    // TODO(Subv): Implement
-    IPC::RequestParser rp(ctx);
-    [[maybe_unused]] const auto memory_block_size = rp.Pop<u32>();
-    rp.PopPID();
-    rp.PopObject<Kernel::SharedMemory>();
-
-    IPC::RequestBuilder rb = rp.MakeBuilder(1, 0);
-    rb.Push(RESULT_SUCCESS);
-}
-
-void SOC_U::ShutdownSockets(Kernel::HLERequestContext& ctx) {
-    // TODO(Subv): Implement
-    IPC::RequestParser rp(ctx);
-    CleanupSockets();
-
-    IPC::RequestBuilder rb = rp.MakeBuilder(1, 0);
-    rb.Push(RESULT_SUCCESS);
-}
-
-void SOC_U::GetSockOpt(Kernel::HLERequestContext& ctx) {
-    IPC::RequestParser rp(ctx);
-    u32 socket_handle = rp.Pop<u32>();
-    auto fd_info = open_sockets.find(socket_handle);
-    if (fd_info == open_sockets.end()) {
-        LOG_ERROR(Service_SOC, "Invalid socket handle: {}", socket_handle);
-        IPC::RequestBuilder rb = rp.MakeBuilder(1, 0);
-        rb.Push(ERR_INVALID_HANDLE);
-        return;
-    }
-    const u32 level = rp.Pop<u32>();
-    const s32 optname = rp.Pop<s32>();
-    u32 optlen = rp.Pop<u32>();
-    rp.PopPID();
-
-    s32 err = 0;
-
-    std::vector<u8> optval(optlen);
-
-    if (optname < 0) {
-#ifdef _WIN32
-        err = WSAEINVAL;
-#else
-        err = EINVAL;
-#endif
-    } else {
-        const auto level_opt = TranslateSockOpt(level, optname);
-        std::vector<u8> platform_data(
-            TranslateSockOptSizeToPlatform(level_opt.first, level_opt.second));
-        socklen_t platform_data_size = static_cast<socklen_t>(platform_data.size());
-        err = ::getsockopt(fd_info->second.socket_fd, level_opt.first, level_opt.second,
-                           reinterpret_cast<char*>(platform_data.data()), &platform_data_size);
-        if (err == SOCKET_ERROR_VALUE) {
-            err = TranslateError(GET_ERRNO);
-        } else {
-            platform_data.resize(static_cast<size_t>(platform_data_size));
-            TranslateSockOptDataFromPlatform(optval, platform_data, level_opt.first,
-                                             level_opt.second);
-        }
-    }
-
-    IPC::RequestBuilder rb = rp.MakeBuilder(3, 2);
-    rb.Push(RESULT_SUCCESS);
-    rb.Push(err);
-    rb.Push(static_cast<u32>(optval.size()));
-    rb.PushStaticBuffer(std::move(optval), 0);
-}
-
-void SOC_U::SetSockOpt(Kernel::HLERequestContext& ctx) {
-    IPC::RequestParser rp(ctx);
-    const auto socket_handle = rp.Pop<u32>();
-    auto fd_info = open_sockets.find(socket_handle);
-    if (fd_info == open_sockets.end()) {
-        LOG_ERROR(Service_SOC, "Invalid socket handle: {}", socket_handle);
-        IPC::RequestBuilder rb = rp.MakeBuilder(1, 0);
-        rb.Push(ERR_INVALID_HANDLE);
-        return;
-    }
-    const auto level = rp.Pop<u32>();
-    const auto optname = rp.Pop<s32>();
-    const auto optlen = rp.Pop<u32>();
-    rp.PopPID();
-    auto optval = rp.PopStaticBuffer();
-    optval.resize(optlen);
-
-    s32 err = 0;
-
-    if (optname < 0) {
-#ifdef _WIN32
-        err = WSAEINVAL;
-#else
-        err = EINVAL;
-#endif
-    } else {
-        std::vector<u8> platform_data;
-        const auto levelopt = TranslateSockOpt(level, optname);
-        TranslateSockOptDataToPlatform(platform_data, optval, levelopt.first, levelopt.second);
-        err = static_cast<u32>(::setsockopt(fd_info->second.socket_fd, levelopt.first,
-                                            levelopt.second,
-                                            reinterpret_cast<char*>(platform_data.data()),
-                                            static_cast<socklen_t>(platform_data.size())));
-        if (err == SOCKET_ERROR_VALUE) {
-            err = TranslateError(GET_ERRNO);
-        }
-    }
-
-    IPC::RequestBuilder rb = rp.MakeBuilder(2, 0);
-    rb.Push(RESULT_SUCCESS);
-    rb.Push(err);
-}
-
-void SOC_U::GetNetworkOpt(Kernel::HLERequestContext& ctx) {
-    IPC::RequestParser rp(ctx);
-    u32 level = rp.Pop<u32>();
-    u32 opt_name = rp.Pop<u32>();
-    u32 opt_len = rp.Pop<u32>();
-    std::vector<u8> opt_data(opt_len);
-
-    u32 err = SOC_ERR_INAVLID_ENUM_VALUE;
-
-    /// Only available level is SOC_SOL_CONFIG, any other value returns an error
-    if (level == SOC_SOL_CONFIG) {
-        switch (static_cast<NetworkOpt>(opt_name)) {
-        case NetworkOpt::NETOPT_MAC_ADDRESS: {
-            if (opt_len >= 6) {
-                std::array<u8, 6> fake_mac = {0};
-                std::memcpy(opt_data.data(), fake_mac.data(), fake_mac.size());
-            }
-            LOG_WARNING(Service_SOC, "(STUBBED) called, level={} opt_name={}", level, opt_name);
-            err = 0;
-        } break;
-        case NetworkOpt::NETOPT_IP_INFO: {
-            if (opt_len >= sizeof(InterfaceInfo)) {
-                InterfaceInfo& out_info = *reinterpret_cast<InterfaceInfo*>(opt_data.data());
-                auto info = GetDefaultInterfaceInfo();
-                if (info.has_value()) {
-                    out_info = info.value();
-                }
-            }
-            // Extra data not used normally, takes 0xC bytes more
-            if (opt_len >= sizeof(InterfaceInfo) + 0xC) {
-                LOG_ERROR(Service_SOC, "(STUBBED) called, level={} opt_name={} opt_len >= 24",
-                          level, opt_name);
-            }
-            err = 0;
-        } break;
-        default:
-            LOG_ERROR(Service_SOC, "(STUBBED) called, level={} opt_name={}", level, opt_name);
-            break;
-        }
-    } else {
-        LOG_ERROR(Service_SOC, "Unknown level={}", level);
-    }
-
-    if (err != 0) {
-        opt_data.resize(0);
-        opt_len = 0;
-    }
-
-    IPC::RequestBuilder rb = rp.MakeBuilder(3, 2);
-    rb.Push(RESULT_SUCCESS);
-    rb.Push(err);
-    rb.Push(static_cast<u32>(opt_len));
-    rb.PushStaticBuffer(std::move(opt_data), 0);
-}
-
-void SOC_U::GetAddrInfoImpl(Kernel::HLERequestContext& ctx) {
-    IPC::RequestParser rp(ctx);
-    u32 node_length = rp.Pop<u32>();
-    u32 service_length = rp.Pop<u32>();
-    u32 hints_size = rp.Pop<u32>();
-    u32 out_size = rp.Pop<u32>();
-    auto node = rp.PopStaticBuffer();
-    auto service = rp.PopStaticBuffer();
-    auto hints_buff = rp.PopStaticBuffer();
-
-    const char* node_data = node_length > 0 ? reinterpret_cast<const char*>(node.data()) : nullptr;
-    const char* service_data =
-        service_length > 0 ? reinterpret_cast<const char*>(service.data()) : nullptr;
-
-    s32 ret = -1;
-    addrinfo* out = nullptr;
-    if (hints_size > 0) {
-        CTRAddrInfo ctr_hints;
-        std::memcpy(&ctr_hints, hints_buff.data(), hints_size);
-        addrinfo hints = CTRAddrInfo::ToPlatform(ctr_hints);
-        // Mimic what soc does in real hardware
-        if (hints.ai_socktype != 0 && hints.ai_protocol == 0) {
-            hints.ai_protocol = hints.ai_socktype == SOCK_STREAM ? IPPROTO_TCP : IPPROTO_UDP;
-        }
-        if (hints.ai_protocol != 0 && hints.ai_socktype == 0) {
-            hints.ai_socktype = hints.ai_protocol == IPPROTO_TCP ? SOCK_STREAM : SOCK_DGRAM;
-        }
-        ret = getaddrinfo(node_data, service_data, &hints, &out);
-    } else {
-        ret = getaddrinfo(node_data, service_data, nullptr, &out);
-    }
-
-    std::vector<u8> out_buff(out_size);
-    u32 count = 0;
-
-    if (ret == SOCKET_ERROR_VALUE) {
-        ret = TranslateError(GET_ERRNO);
-        out_buff.resize(0);
-    } else {
-        std::size_t pos = 0;
-        addrinfo* cur = out;
-        while (cur != nullptr) {
-            if (pos <= out_size - sizeof(CTRAddrInfo)) {
-                // According to 3dbrew, this function fills whatever it can and does not error even
-                // if the buffer is not big enough. However the count returned is always correct.
-                CTRAddrInfo ctr_addr = CTRAddrInfo::FromPlatform(*cur);
-                std::memcpy(out_buff.data() + pos, &ctr_addr, sizeof(ctr_addr));
-                pos += sizeof(ctr_addr);
-            }
-            cur = cur->ai_next;
-            count++;
-        }
-        if (out != nullptr)
-            freeaddrinfo(out);
-    }
-
-    IPC::RequestBuilder rb = rp.MakeBuilder(3, 2);
-    rb.Push(RESULT_SUCCESS);
-    rb.Push(ret);
-    rb.Push(count);
-    rb.PushStaticBuffer(std::move(out_buff), 0);
-}
-
-void SOC_U::GetNameInfoImpl(Kernel::HLERequestContext& ctx) {
-    IPC::RequestParser rp(ctx);
-    u32 socklen = rp.Pop<u32>();
-    u32 hostlen = rp.Pop<u32>();
-    u32 servlen = rp.Pop<u32>();
-    s32 flags = NameInfoFlagsToPlatform(rp.Pop<s32>());
-    auto sa_buff = rp.PopStaticBuffer();
-
-    CTRSockAddr ctr_sa;
-    std::memcpy(&ctr_sa, sa_buff.data(), socklen);
-    sockaddr sa = CTRSockAddr::ToPlatform(ctr_sa);
-
-    std::vector<u8> host(hostlen);
-    std::vector<u8> serv(servlen);
-    char* host_data = hostlen > 0 ? reinterpret_cast<char*>(host.data()) : nullptr;
-    char* serv_data = servlen > 0 ? reinterpret_cast<char*>(serv.data()) : nullptr;
-
-    s32 ret = getnameinfo(&sa, sizeof(sa), host_data, hostlen, serv_data, servlen, flags);
-    if (ret == SOCKET_ERROR_VALUE) {
-        ret = TranslateError(GET_ERRNO);
-    }
-
-    IPC::RequestBuilder rb = rp.MakeBuilder(2, 4);
-    rb.Push(RESULT_SUCCESS);
-    rb.Push(ret);
-    rb.PushStaticBuffer(std::move(host), 0);
-    rb.PushStaticBuffer(std::move(serv), 1);
-}
-
-SOC_U::SOC_U() : ServiceFramework("soc:U") {
-    static const FunctionInfo functions[] = {
-        // clang-format off
-        {0x0001, &SOC_U::InitializeSockets, "InitializeSockets"},
-        {0x0002, &SOC_U::Socket, "Socket"},
-        {0x0003, &SOC_U::Listen, "Listen"},
-        {0x0004, &SOC_U::Accept, "Accept"},
-        {0x0005, &SOC_U::Bind, "Bind"},
-        {0x0006, &SOC_U::Connect, "Connect"},
-        {0x0007, &SOC_U::RecvFromOther, "recvfrom_other"},
-        {0x0008, &SOC_U::RecvFrom, "RecvFrom"},
-        {0x0009, &SOC_U::SendToOther, "SendToOther"},
-        {0x000A, &SOC_U::SendTo, "SendTo"},
-        {0x000B, &SOC_U::Close, "Close"},
-        {0x000C, &SOC_U::Shutdown, "Shutdown"},
-        {0x000D, &SOC_U::GetHostByName, "GetHostByName"},
-        {0x000E, nullptr, "GetHostByAddr"},
-        {0x000F, &SOC_U::GetAddrInfoImpl, "GetAddrInfo"},
-        {0x0010, &SOC_U::GetNameInfoImpl, "GetNameInfo"},
-        {0x0011, &SOC_U::GetSockOpt, "GetSockOpt"},
-        {0x0012, &SOC_U::SetSockOpt, "SetSockOpt"},
-        {0x0013, &SOC_U::Fcntl, "Fcntl"},
-        {0x0014, &SOC_U::Poll, "Poll"},
-        {0x0015, nullptr, "SockAtMark"},
-        {0x0016, &SOC_U::GetHostId, "GetHostId"},
-        {0x0017, &SOC_U::GetSockName, "GetSockName"},
-        {0x0018, &SOC_U::GetPeerName, "GetPeerName"},
-        {0x0019, &SOC_U::ShutdownSockets, "ShutdownSockets"},
-        {0x001A, &SOC_U::GetNetworkOpt, "GetNetworkOpt"},
-        {0x001B, nullptr, "ICMPSocket"},
-        {0x001C, nullptr, "ICMPPing"},
-        {0x001D, nullptr, "ICMPCancel"},
-        {0x001E, nullptr, "ICMPClose"},
-        {0x001F, nullptr, "GetResolverInfo"},
-        {0x0021, nullptr, "CloseSockets"},
-        {0x0023, nullptr, "AddGlobalSocket"},
-        // clang-format on
-    };
-
-    RegisterHandlers(functions);
-
-#ifdef _WIN32
-    WSADATA data;
-    WSAStartup(MAKEWORD(2, 2), &data);
-#endif
-}
-
-SOC_U::~SOC_U() {
-    CleanupSockets();
-#ifdef _WIN32
-    WSACleanup();
-#endif
-}
-
-std::optional<SOC_U::InterfaceInfo> SOC_U::GetDefaultInterfaceInfo() {
-    if (this->interface_info_cached) {
-        return InterfaceInfo(this->interface_info);
-    }
-
-    InterfaceInfo ret;
-    s64 sock_fd = -1;
-    bool interface_found = false;
-    struct sockaddr_in s_in = {.sin_family = AF_INET, .sin_port = htons(53), .sin_addr = {}};
-    s_in.sin_addr.s_addr = inet_addr("8.8.8.8");
-    socklen_t s_info_len = sizeof(struct sockaddr_in);
-    sockaddr_in s_info;
-
-    if ((sock_fd = ::socket(AF_INET, SOCK_STREAM, 0)) == -1) {
-        return std::nullopt;
-    }
-
-    if (::connect(sock_fd, (struct sockaddr*)(&s_in), sizeof(struct sockaddr_in)) != 0) {
-        closesocket(sock_fd);
-        return std::nullopt;
-    }
-
-    if (::getsockname(sock_fd, (struct sockaddr*)&s_info, &s_info_len) != 0 ||
-        s_info_len != sizeof(struct sockaddr_in)) {
-        closesocket(sock_fd);
-        return std::nullopt;
-    }
-    closesocket(sock_fd);
-
-#ifdef _WIN32
-    sock_fd = WSASocket(AF_INET, SOCK_DGRAM, 0, 0, 0, 0);
-    if (sock_fd == SOCKET_ERROR) {
-        return std::nullopt;
-    }
-
-    const int max_interfaces = 100;
-    std::vector<INTERFACE_INFO> interface_list_vec(max_interfaces);
-    INTERFACE_INFO* interface_list = reinterpret_cast<INTERFACE_INFO*>(interface_list_vec.data());
-    unsigned long bytes_used;
-    if (WSAIoctl(sock_fd, SIO_GET_INTERFACE_LIST, 0, 0, interface_list,
-                 max_interfaces * sizeof(INTERFACE_INFO), &bytes_used, 0, 0) == SOCKET_ERROR) {
-        closesocket(sock_fd);
-        return std::nullopt;
-    }
-    closesocket(sock_fd);
-
-    int num_interfaces = bytes_used / sizeof(INTERFACE_INFO);
-    for (int i = 0; i < num_interfaces; i++) {
-        if (((sockaddr*)&(interface_list[i].iiAddress))->sa_family == AF_INET &&
-            std::memcmp(&((sockaddr_in*)&(interface_list[i].iiAddress))->sin_addr.s_addr,
-                        &s_info.sin_addr.s_addr, sizeof(s_info.sin_addr.s_addr)) == 0) {
-            ret.address = ((sockaddr_in*)&(interface_list[i].iiAddress))->sin_addr.s_addr;
-            ret.netmask = ((sockaddr_in*)&(interface_list[i].iiNetmask))->sin_addr.s_addr;
-            ret.broadcast =
-                ((sockaddr_in*)&(interface_list[i].iiBroadcastAddress))->sin_addr.s_addr;
-            interface_found = true;
-            {
-                char address[16] = {0}, netmask[16] = {0}, broadcast[16] = {0};
-                std::strncpy(address,
-                             inet_ntoa(((sockaddr_in*)&(interface_list[i].iiAddress))->sin_addr),
-                             sizeof(address) - 1);
-                std::strncpy(netmask,
-                             inet_ntoa(((sockaddr_in*)&(interface_list[i].iiNetmask))->sin_addr),
-                             sizeof(netmask) - 1);
-                std::strncpy(
-                    broadcast,
-                    inet_ntoa(((sockaddr_in*)&(interface_list[i].iiBroadcastAddress))->sin_addr),
-                    sizeof(broadcast) - 1);
-
-                LOG_DEBUG(Service_SOC, "Found interface: (addr: {}, netmask: {}, broadcast: {})",
-                          address, netmask, broadcast);
-            }
-            break;
-        }
-    }
-#else
-    struct ifaddrs* ifaddr;
-    struct ifaddrs* ifa;
-    if (getifaddrs(&ifaddr) == -1) {
-        return std::nullopt;
-    }
-
-    for (ifa = ifaddr; ifa != NULL; ifa = ifa->ifa_next) {
-        if (ifa->ifa_addr && ifa->ifa_addr->sa_family == AF_INET) {
-            struct sockaddr_in* in_address = (struct sockaddr_in*)ifa->ifa_addr;
-            struct sockaddr_in* in_netmask = (struct sockaddr_in*)ifa->ifa_netmask;
-            struct sockaddr_in* in_broadcast = (struct sockaddr_in*)ifa->ifa_broadaddr;
-            if (in_address->sin_addr.s_addr == s_info.sin_addr.s_addr) {
-                ret.address = in_address->sin_addr.s_addr;
-                ret.netmask = in_netmask->sin_addr.s_addr;
-                ret.broadcast = in_broadcast->sin_addr.s_addr;
-                interface_found = true;
-                {
-                    char address[16] = {0}, netmask[16] = {0}, broadcast[16] = {0};
-                    std::strncpy(address, inet_ntoa(in_address->sin_addr), sizeof(address) - 1);
-                    std::strncpy(netmask, inet_ntoa(in_netmask->sin_addr), sizeof(netmask) - 1);
-                    std::strncpy(broadcast, inet_ntoa(in_broadcast->sin_addr),
-                                 sizeof(broadcast) - 1);
-
-                    LOG_DEBUG(Service_SOC,
-                              "Found interface: (addr: {}, netmask: {}, broadcast: {})", address,
-                              netmask, broadcast);
-                }
-            }
-        }
-    }
-    freeifaddrs(ifaddr);
-#endif // _WIN32
-    if (interface_found) {
-        this->interface_info = ret;
-        this->interface_info_cached = true;
-        return ret;
-    } else {
-        LOG_DEBUG(Service_SOC, "Interface not found");
-        return std::nullopt;
-    }
-}
-
-std::shared_ptr<SOC_U> GetService(Core::System& system) {
-    return system.ServiceManager().GetService<SOC_U>("cfg:u");
-}
-
-void InstallInterfaces(Core::System& system) {
-    auto& service_manager = system.ServiceManager();
-    std::make_shared<SOC_U>()->InstallAsService(service_manager);
-}
-
-} // namespace Service::SOC
diff --git a/src/core/hle/service/soc/soc_u.h b/src/core/hle/service/soc/soc_u.h
deleted file mode 100644
index 4c56d3152..000000000
--- a/src/core/hle/service/soc/soc_u.h
+++ /dev/null
@@ -1,165 +0,0 @@
-// Copyright 2014 Citra Emulator Project
-// Licensed under GPLv2 or any later version
-// Refer to the license.txt file included.
-
-#pragma once
-
-#include <unordered_map>
-#include <utility>
-#include <boost/serialization/unordered_map.hpp>
-#include "core/hle/result.h"
-#include "core/hle/service/service.h"
-
-namespace Core {
-class System;
-}
-
-namespace Service::SOC {
-
-/// Holds information about a particular socket
-struct SocketHolder {
-#ifdef _WIN32
-    using SOCKET = unsigned long long;
-    SOCKET socket_fd; ///< The socket descriptor
-#else
-    int socket_fd; ///< The socket descriptor
-#endif // _WIN32
-
-    bool blocking = true; ///< Whether the socket is blocking or not.
-
-private:
-    template <class Archive>
-    void serialize(Archive& ar, const unsigned int) {
-        ar& socket_fd;
-        ar& blocking;
-    }
-    friend class boost::serialization::access;
-};
-
-class SOC_U final : public ServiceFramework<SOC_U> {
-public:
-    SOC_U();
-    ~SOC_U();
-
-    struct InterfaceInfo {
-        u32 address;
-        u32 netmask;
-        u32 broadcast;
-    };
-
-    // Gets the interface info that is able to reach the internet.
-    std::optional<InterfaceInfo> GetDefaultInterfaceInfo();
-
-private:
-    static constexpr ResultCode ERR_INVALID_HANDLE =
-        ResultCode(ErrorDescription::InvalidHandle, ErrorModule::SOC, ErrorSummary::InvalidArgument,
-                   ErrorLevel::Permanent);
-    static constexpr u32 SOC_ERR_INAVLID_ENUM_VALUE = 0xFFFF8025;
-
-    static constexpr u32 SOC_SOL_IP = 0x0000;
-    static constexpr u32 SOC_SOL_TCP = 0x0006;
-    static constexpr u32 SOC_SOL_CONFIG = 0xFFFE;
-    static constexpr u32 SOC_SOL_SOCKET = 0xFFFF;
-
-    static const std::unordered_map<u64, std::pair<int, int>> sockopt_map;
-    static std::pair<int, int> TranslateSockOpt(int level, int opt);
-    bool GetSocketBlocking(const SocketHolder& socket_holder);
-    u32 SetSocketBlocking(SocketHolder& socket_holder, bool blocking);
-
-    // From
-    // https://github.com/devkitPro/libctru/blob/1de86ea38aec419744149daf692556e187d4678a/libctru/include/3ds/services/soc.h#L15
-    enum class NetworkOpt {
-        NETOPT_MAC_ADDRESS = 0x1004,     ///< The mac address of the interface
-        NETOPT_ARP_TABLE = 0x3002,       ///< The ARP table
-        NETOPT_IP_INFO = 0x4003,         ///< The current IP setup
-        NETOPT_IP_MTU = 0x4004,          ///< The value of the IP MTU
-        NETOPT_ROUTING_TABLE = 0x4006,   ///< The routing table
-        NETOPT_UDP_NUMBER = 0x8002,      ///< The number of sockets in the UDP table
-        NETOPT_UDP_TABLE = 0x8003,       ///< The table of opened UDP sockets
-        NETOPT_TCP_NUMBER = 0x9002,      ///< The number of sockets in the TCP table
-        NETOPT_TCP_TABLE = 0x9003,       ///< The table of opened TCP sockets
-        NETOPT_DNS_TABLE = 0xB003,       ///< The table of the DNS servers
-        NETOPT_DHCP_LEASE_TIME = 0xC001, ///< The DHCP lease time remaining, in seconds
-    };
-
-    struct HostByNameData {
-        static const u32 max_entries = 24;
-
-        u16_le addr_type;
-        u16_le addr_len;
-        u16_le addr_count;
-        u16_le alias_count;
-        std::array<char, 256> h_name;
-        std::array<std::array<char, 256>, max_entries> aliases;
-        std::array<std::array<u8, 16>, max_entries> addresses;
-    };
-    static_assert(sizeof(HostByNameData) == 0x1A88, "Invalid HostByNameData size");
-
-    void Socket(Kernel::HLERequestContext& ctx);
-    void Bind(Kernel::HLERequestContext& ctx);
-    void Fcntl(Kernel::HLERequestContext& ctx);
-    void Listen(Kernel::HLERequestContext& ctx);
-    void Accept(Kernel::HLERequestContext& ctx);
-    void GetHostId(Kernel::HLERequestContext& ctx);
-    void Close(Kernel::HLERequestContext& ctx);
-    void SendToOther(Kernel::HLERequestContext& ctx);
-    void SendTo(Kernel::HLERequestContext& ctx);
-    void RecvFromOther(Kernel::HLERequestContext& ctx);
-    void RecvFrom(Kernel::HLERequestContext& ctx);
-    void Poll(Kernel::HLERequestContext& ctx);
-    void GetSockName(Kernel::HLERequestContext& ctx);
-    void Shutdown(Kernel::HLERequestContext& ctx);
-    void GetHostByName(Kernel::HLERequestContext& ctx);
-    void GetPeerName(Kernel::HLERequestContext& ctx);
-    void Connect(Kernel::HLERequestContext& ctx);
-    void InitializeSockets(Kernel::HLERequestContext& ctx);
-    void ShutdownSockets(Kernel::HLERequestContext& ctx);
-    void GetSockOpt(Kernel::HLERequestContext& ctx);
-    void SetSockOpt(Kernel::HLERequestContext& ctx);
-    void GetNetworkOpt(Kernel::HLERequestContext& ctx);
-
-    // Some platforms seem to have GetAddrInfo and GetNameInfo defined as macros,
-    // so we have to use a different name here.
-    void GetAddrInfoImpl(Kernel::HLERequestContext& ctx);
-    void GetNameInfoImpl(Kernel::HLERequestContext& ctx);
-
-    // Socked ids
-    u32 next_socket_id = 3;
-    u32 GetNextSocketID() {
-        return next_socket_id++;
-    }
-
-    // System timer adjust
-    std::chrono::time_point<std::chrono::steady_clock> adjust_value_last;
-    void PreTimerAdjust();
-    void PostTimerAdjust(Kernel::HLERequestContext& ctx, const std::string& caller_method);
-
-    /// Close all open sockets
-    void CleanupSockets();
-
-    /// Holds info about the currently open sockets
-    friend struct CTRPollFD;
-    std::unordered_map<u32, SocketHolder> open_sockets;
-
-    /// Cache interface info for the current session
-    /// These two fields are not saved to savestates on purpose
-    /// as network interfaces may change and it's better to.
-    /// obtain them again between play sessions.
-    bool interface_info_cached = false;
-    InterfaceInfo interface_info;
-
-    template <class Archive>
-    void serialize(Archive& ar, const unsigned int) {
-        ar& boost::serialization::base_object<Kernel::SessionRequestHandler>(*this);
-        ar& open_sockets;
-    }
-    friend class boost::serialization::access;
-};
-
-std::shared_ptr<SOC_U> GetService(Core::System& system);
-
-void InstallInterfaces(Core::System& system);
-
-} // namespace Service::SOC
-
-BOOST_CLASS_EXPORT_KEY(Service::SOC::SOC_U)
diff --git a/src/core/hle/service/ssl/ssl_c.cpp b/src/core/hle/service/ssl/ssl_c.cpp
deleted file mode 100644
index df95a72aa..000000000
--- a/src/core/hle/service/ssl/ssl_c.cpp
+++ /dev/null
@@ -1,99 +0,0 @@
-// Copyright 2014 Citra Emulator Project
-// Licensed under GPLv2 or any later version
-// Refer to the license.txt file included.
-
-#include "common/archives.h"
-#include "common/common_types.h"
-#include "core/core.h"
-#include "core/hle/ipc.h"
-#include "core/hle/ipc_helpers.h"
-#include "core/hle/service/ssl/ssl_c.h"
-
-SERIALIZE_EXPORT_IMPL(Service::SSL::SSL_C)
-namespace Service::SSL {
-
-void SSL_C::Initialize(Kernel::HLERequestContext& ctx) {
-    IPC::RequestParser rp(ctx);
-    rp.PopPID();
-
-    // Seed random number generator when the SSL service is initialized
-    std::random_device rand_device;
-    rand_gen.seed(rand_device());
-
-    // Stub, return success
-    IPC::RequestBuilder rb = rp.MakeBuilder(1, 0);
-    rb.Push(RESULT_SUCCESS);
-}
-
-void SSL_C::GenerateRandomData(Kernel::HLERequestContext& ctx) {
-    IPC::RequestParser rp(ctx);
-    u32 size = rp.Pop<u32>();
-    auto buffer = rp.PopMappedBuffer();
-
-    // Fill the output buffer with random data.
-    u32 data = 0;
-    u32 i = 0;
-    while (i < size) {
-        if ((i % 4) == 0) {
-            // The random number generator returns 4 bytes worth of data, so generate new random
-            // data when i == 0 and when i is divisible by 4
-            data = rand_gen();
-        }
-
-        if (size > 4) {
-            // Use up the entire 4 bytes of the random data for as long as possible
-            buffer.Write(&data, i, 4);
-            i += 4;
-        } else if (size == 2) {
-            buffer.Write(&data, i, 2);
-            i += 2;
-        } else {
-            buffer.Write(&data, i, 1);
-            i++;
-        }
-    }
-
-    // Stub, return success
-    IPC::RequestBuilder rb = rp.MakeBuilder(1, 2);
-    rb.Push(RESULT_SUCCESS);
-    rb.PushMappedBuffer(buffer);
-}
-
-SSL_C::SSL_C() : ServiceFramework("ssl:C") {
-    static const FunctionInfo functions[] = {
-        // clang-format off
-        {0x0001, &SSL_C::Initialize, "Initialize"},
-        {0x0002, nullptr, "CreateContext"},
-        {0x0003, nullptr, "CreateRootCertChain"},
-        {0x0004, nullptr, "DestroyRootCertChain"},
-        {0x0005, nullptr, "AddTrustedRootCA"},
-        {0x0006, nullptr, "RootCertChainAddDefaultCert"},
-        {0x0007, nullptr, "RootCertChainRemoveCert"},
-        {0x000D, nullptr, "OpenClientCertContext"},
-        {0x000E, nullptr, "OpenDefaultClientCertContext"},
-        {0x000F, nullptr, "CloseClientCertContext"},
-        {0x0011, &SSL_C::GenerateRandomData, "GenerateRandomData"},
-        {0x0012, nullptr, "InitializeConnectionSession"},
-        {0x0013, nullptr, "StartConnection"},
-        {0x0014, nullptr, "StartConnectionGetOut"},
-        {0x0015, nullptr, "Read"},
-        {0x0016, nullptr, "ReadPeek"},
-        {0x0017, nullptr, "Write"},
-        {0x0018, nullptr, "ContextSetRootCertChain"},
-        {0x0019, nullptr, "ContextSetClientCert"},
-        {0x001B, nullptr, "ContextClearOpt"},
-        {0x001C, nullptr, "ContextGetProtocolCipher"},
-        {0x001E, nullptr, "DestroyContext"},
-        {0x001F, nullptr, "ContextInitSharedmem"},
-        // clang-format on
-    };
-
-    RegisterHandlers(functions);
-}
-
-void InstallInterfaces(Core::System& system) {
-    auto& service_manager = system.ServiceManager();
-    std::make_shared<SSL_C>()->InstallAsService(service_manager);
-}
-
-} // namespace Service::SSL
diff --git a/src/core/hle/service/ssl/ssl_c.h b/src/core/hle/service/ssl/ssl_c.h
deleted file mode 100644
index 30b87378a..000000000
--- a/src/core/hle/service/ssl/ssl_c.h
+++ /dev/null
@@ -1,34 +0,0 @@
-// Copyright 2014 Citra Emulator Project
-// Licensed under GPLv2 or any later version
-// Refer to the license.txt file included.
-
-#pragma once
-
-#include <random>
-#include "core/hle/service/service.h"
-
-namespace Core {
-class System;
-}
-
-namespace Service::SSL {
-
-class SSL_C final : public ServiceFramework<SSL_C> {
-public:
-    SSL_C();
-
-private:
-    void Initialize(Kernel::HLERequestContext& ctx);
-    void GenerateRandomData(Kernel::HLERequestContext& ctx);
-
-    // TODO: Implement a proper CSPRNG in the future when actual security is needed
-    std::mt19937 rand_gen;
-
-    SERVICE_SERIALIZATION_SIMPLE
-};
-
-void InstallInterfaces(Core::System& system);
-
-} // namespace Service::SSL
-
-BOOST_CLASS_EXPORT_KEY(Service::SSL::SSL_C)
diff --git a/src/core/hw/y2r.cpp b/src/core/hw/y2r.cpp
index 5ea646924..d6f7023f7 100644
--- a/src/core/hw/y2r.cpp
+++ b/src/core/hw/y2r.cpp
@@ -12,7 +12,7 @@
 #include "common/microprofileui.h"
 #include "common/vector_math.h"
 #include "core/core.h"
-#include "core/hle/service/cam/y2r_u.h"
+#include "core/hle/service/y2r_u.h"
 #include "core/hw/y2r.h"
 #include "core/memory.h"
 
