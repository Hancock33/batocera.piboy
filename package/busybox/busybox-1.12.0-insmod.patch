--- busybox-1.12.0/modutils/insmod.c	Wed Aug  6 00:56:02 2008
+++ busybox-1.12.0-insmod/modutils/insmod.c	Sun Aug 31 23:56:28 2008
@@ -1059,8 +1059,9 @@
 
 		case R_68K_PC8:
 			v -= dot;
-			if ((ElfW(Sword))v > 0x7f ||
-					(ElfW(Sword))v < -(ElfW(Sword))0x80) {
+			if ((ElfW(Sword))v > 0x7f
+			 || (ElfW(Sword))v < -(ElfW(Sword))0x80
+			) {
 				ret = obj_reloc_overflow;
 			}
 			*(char *)loc = v;
@@ -1068,8 +1069,9 @@
 
 		case R_68K_PC16:
 			v -= dot;
-			if ((ElfW(Sword))v > 0x7fff ||
-					(ElfW(Sword))v < -(ElfW(Sword))0x8000) {
+			if ((ElfW(Sword))v > 0x7fff
+			 || (ElfW(Sword))v < -(ElfW(Sword))0x8000
+			) {
 				ret = obj_reloc_overflow;
 			}
 			*(short *)loc = v;
@@ -1208,8 +1210,9 @@
 			{
 				Elf32_Addr word;
 
-				if ((Elf32_Sword)v > 0x7fff ||
-				    (Elf32_Sword)v < -(Elf32_Sword)0x8000) {
+				if ((Elf32_Sword)v > 0x7fff
+				 || (Elf32_Sword)v < -(Elf32_Sword)0x8000
+				) {
 					ret = obj_reloc_overflow;
 				}
 
@@ -1238,8 +1241,9 @@
 				Elf32_Addr word;
 
 				v -= dot + 4;
-				if ((Elf32_Sword)v > 0x7fff ||
-				    (Elf32_Sword)v < -(Elf32_Sword)0x8000) {
+				if ((Elf32_Sword)v > 0x7fff
+				 || (Elf32_Sword)v < -(Elf32_Sword)0x8000
+				) {
 					ret = obj_reloc_overflow;
 				}
 
@@ -1253,9 +1257,10 @@
 				Elf32_Addr word, gp;
 				/* get _gp */
 				gp = obj_symbol_final_value(f, obj_find_symbol(f, SPFX "_gp"));
-				v-=gp;
-				if ((Elf32_Sword)v > 0x7fff ||
-						(Elf32_Sword)v < -(Elf32_Sword)0x8000) {
+				v -= gp;
+				if ((Elf32_Sword)v > 0x7fff
+				 || (Elf32_Sword)v < -(Elf32_Sword)0x8000
+				) {
 					ret = obj_reloc_overflow;
 				}
 
@@ -2132,7 +2137,6 @@
 	for (sym = f->symtab[hash]; sym; sym = sym->next)
 		if (f->symbol_cmp(sym->name, name) == 0)
 			return sym;
-
 	return NULL;
 }
 
@@ -2141,12 +2145,10 @@
 	if (sym) {
 		if (sym->secidx >= SHN_LORESERVE)
 			return sym->value;
-
 		return sym->value + f->sections[sym->secidx]->header.sh_addr;
-	} else {
-		/* As a special case, a NULL sym has value zero.  */
-		return 0;
 	}
+	/* As a special case, a NULL sym has value zero.  */
+	return 0;
 }
 
 static struct obj_section *obj_find_section(struct obj_file *f, const char *name)
@@ -2156,7 +2158,6 @@
 	for (i = 0; i < n; ++i)
 		if (strcmp(f->sections[i]->name, name) == 0)
 			return f->sections[i];
-
 	return NULL;
 }
 
@@ -2167,9 +2168,11 @@
 	af = a->header.sh_flags;
 
 	ac = 0;
-	if (a->name[0] != '.' || strlen(a->name) != 10 ||
-			strcmp(a->name + 5, ".init"))
+	if (a->name[0] != '.' || strlen(a->name) != 10
+	 || strcmp(a->name + 5, ".init") != 0
+	) {
 		ac |= 32;
+	}
 	if (af & SHF_ALLOC)
 		ac |= 16;
 	if (!(af & SHF_WRITE))
@@ -2212,7 +2215,7 @@
 	sec->name = name;
 	sec->idx = newidx;
 	if (size)
-		sec->contents = xmalloc(size);
+		sec->contents = xzalloc(size);
 
 	obj_insert_section_load_order(f, sec);
 
@@ -2227,7 +2230,7 @@
 	int newidx = f->header.e_shnum++;
 	struct obj_section *sec;
 
-	f->sections = xrealloc(f->sections, (newidx + 1) * sizeof(sec));
+	f->sections = xrealloc_vector(f->sections, 2, newidx);
 	f->sections[newidx] = sec = arch_new_section();
 
 	sec->header.sh_type = SHT_PROGBITS;
@@ -2237,7 +2240,7 @@
 	sec->name = name;
 	sec->idx = newidx;
 	if (size)
-		sec->contents = xmalloc(size);
+		sec->contents = xzalloc(size);
 
 	sec->load_next = f->load_order;
 	f->load_order = sec;
@@ -2689,8 +2692,7 @@
 	/* Collect the modules' symbols.  */
 
 	if (nmod) {
-		ext_modules = modules = xmalloc(nmod * sizeof(*modules));
-		memset(modules, 0, nmod * sizeof(*modules));
+		ext_modules = modules = xzalloc(nmod * sizeof(*modules));
 		for (i = 0, mn = module_names, m = modules;
 				i < nmod; ++i, ++m, mn += strlen(mn) + 1) {
 			struct new_module_info info;
@@ -2770,13 +2772,14 @@
 }
 
 
-static void  new_create_this_module(struct obj_file *f, const char *m_name)
+static void new_create_this_module(struct obj_file *f, const char *m_name)
 {
 	struct obj_section *sec;
 
 	sec = obj_create_alloced_section_first(f, ".this", tgt_sizeof_long,
 			sizeof(struct new_module));
-	memset(sec->contents, 0, sizeof(struct new_module));
+	/* done by obj_create_alloced_section_first: */
+	/*memset(sec->contents, 0, sizeof(struct new_module));*/
 
 	obj_add_symbol(f, SPFX "__this_module", -1,
 			ELF_ST_INFO(STB_LOCAL, STT_OBJECT), sec->idx, 0,
@@ -2856,18 +2859,19 @@
 		/* We don't want to export symbols residing in sections that
 		   aren't loaded.  There are a number of these created so that
 		   we make sure certain module options don't appear twice.  */
-
-		loaded = alloca(sizeof(int) * (i = f->header.e_shnum));
+		i = f->header.e_shnum;
+		loaded = alloca(sizeof(int) * i);
 		while (--i >= 0)
 			loaded[i] = (f->sections[i]->header.sh_flags & SHF_ALLOC) != 0;
 
 		for (nsyms = i = 0; i < HASH_BUCKETS; ++i) {
 			struct obj_symbol *sym;
-			for (sym = f->symtab[i]; sym; sym = sym->next)
+			for (sym = f->symtab[i]; sym; sym = sym->next) {
 				if (ELF_ST_BIND(sym->info) != STB_LOCAL
 						&& sym->secidx <= SHN_HIRESERVE
 						&& (sym->secidx >= SHN_LORESERVE
-							|| loaded[sym->secidx])) {
+							|| loaded[sym->secidx])
+				) {
 					ElfW(Addr) ofs = nsyms * 2 * tgt_sizeof_void_p;
 
 					obj_symbol_patch(f, sec->idx, ofs, sym);
@@ -2876,6 +2880,7 @@
 
 					nsyms++;
 				}
+			}
 		}
 
 		obj_extend_section(sec, nsyms * 2 * tgt_sizeof_char_p);
@@ -2934,9 +2939,11 @@
 	}
 	sec = obj_find_section(f, ".data.init");
 	if (sec) {
-		if (!module->runsize ||
-				module->runsize > sec->header.sh_addr - m_addr)
+		if (!module->runsize
+		 || module->runsize > sec->header.sh_addr - m_addr
+		) {
 			module->runsize = sec->header.sh_addr - m_addr;
+		}
 	}
 	sec = obj_find_section(f, ARCHDATA_SEC_NAME);
 	if (sec && sec->header.sh_size) {
@@ -3083,9 +3090,9 @@
 		if (i == f->header.e_shnum) {
 			struct obj_section *sec;
 
+			f->header.e_shnum++;
 			f->sections = xrealloc_vector(f->sections, 2, i);
 			f->sections[i] = sec = arch_new_section();
-			f->header.e_shnum = i + 1;
 
 			sec->header.sh_type = SHT_PROGBITS;
 			sec->header.sh_flags = SHF_WRITE | SHF_ALLOC;
@@ -3124,12 +3131,9 @@
 	for (i = 0; i < f->header.e_shnum; ++i) {
 		struct obj_section *s = f->sections[i];
 		if (s->header.sh_type == SHT_NOBITS) {
+			s->contents = NULL;
 			if (s->header.sh_size != 0)
-				s->contents = memset(xmalloc(s->header.sh_size),
-						0, s->header.sh_size);
-			else
-				s->contents = NULL;
-
+				s->contents = xzalloc(s->header.sh_size),
 			s->header.sh_type = SHT_PROGBITS;
 		}
 	}
@@ -3222,8 +3226,8 @@
 #if SHT_RELM == SHT_RELA
 #if defined(__alpha__) && defined(AXP_BROKEN_GAS)
 			/* Work around a nasty GAS bug, that is fixed as of 2.7.0.9.  */
-			if (!extsym || !extsym->st_name ||
-					ELF_ST_BIND(extsym->st_info) != STB_LOCAL)
+			if (!extsym || !extsym->st_name
+			 || ELF_ST_BIND(extsym->st_info) != STB_LOCAL)
 #endif
 				value += rel->r_addend;
 #endif
@@ -3329,16 +3333,17 @@
 	}
 
 	if (f->header.e_ident[EI_MAG0] != ELFMAG0
-			|| f->header.e_ident[EI_MAG1] != ELFMAG1
-			|| f->header.e_ident[EI_MAG2] != ELFMAG2
-			|| f->header.e_ident[EI_MAG3] != ELFMAG3) {
+	 || f->header.e_ident[EI_MAG1] != ELFMAG1
+	 || f->header.e_ident[EI_MAG2] != ELFMAG2
+	 || f->header.e_ident[EI_MAG3] != ELFMAG3
+	) {
 		bb_error_msg_and_die("not an ELF file");
 	}
 	if (f->header.e_ident[EI_CLASS] != ELFCLASSM
-			|| f->header.e_ident[EI_DATA] != (BB_BIG_ENDIAN
-				? ELFDATA2MSB : ELFDATA2LSB)
-			|| f->header.e_ident[EI_VERSION] != EV_CURRENT
-			|| !MATCH_MACHINE(f->header.e_machine)) {
+	 || f->header.e_ident[EI_DATA] != (BB_BIG_ENDIAN ? ELFDATA2MSB : ELFDATA2LSB)
+	 || f->header.e_ident[EI_VERSION] != EV_CURRENT
+	 || !MATCH_MACHINE(f->header.e_machine)
+	) {
 		bb_error_msg_and_die("ELF file not for this architecture");
 	}
 	if (f->header.e_type != ET_REL) {
@@ -3354,8 +3359,10 @@
 	}
 
 	shnum = f->header.e_shnum;
-	f->sections = xmalloc(sizeof(struct obj_section *) * shnum);
-	memset(f->sections, 0, sizeof(struct obj_section *) * shnum);
+	/* Growth of ->sections vector will be done by
+	 * xrealloc_vector(..., 2, ...), therefore we must allocate
+	 * at least 2^2 = 4 extra elements here. */
+	f->sections = xzalloc(sizeof(f->sections[0]) * (shnum + 4));
 
 	section_headers = alloca(sizeof(ElfW(Shdr)) * shnum);
 	fseek(fp, f->header.e_shoff, SEEK_SET);
@@ -3391,14 +3398,13 @@
 			case SHT_SYMTAB:
 			case SHT_STRTAB:
 			case SHT_RELM:
+				sec->contents = NULL;
 				if (sec->header.sh_size > 0) {
-					sec->contents = xmalloc(sec->header.sh_size);
+					sec->contents = xzalloc(sec->header.sh_size);
 					fseek(fp, sec->header.sh_offset, SEEK_SET);
 					if (fread(sec->contents, sec->header.sh_size, 1, fp) != 1) {
 						bb_perror_msg_and_die("error reading ELF section data");
 					}
-				} else {
-					sec->contents = NULL;
 				}
 				break;
 
@@ -3860,16 +3866,20 @@
 	for (nsyms = i = 0; i < HASH_BUCKETS; ++i)
 		for (sym = f->symtab[i]; sym; sym = sym->next)
 			if (sym->secidx <= SHN_HIRESERVE
-					&& (sym->secidx >= SHN_LORESERVE || loaded[sym->secidx]))
+			 && (sym->secidx >= SHN_LORESERVE || loaded[sym->secidx])
+			) {
 				++nsyms;
+			}
 
 	all = alloca(nsyms * sizeof(struct obj_symbol *));
 
 	for (i = 0, p = all; i < HASH_BUCKETS; ++i)
 		for (sym = f->symtab[i]; sym; sym = sym->next)
 			if (sym->secidx <= SHN_HIRESERVE
-					&& (sym->secidx >= SHN_LORESERVE || loaded[sym->secidx]))
+			 && (sym->secidx >= SHN_LORESERVE || loaded[sym->secidx])
+			) {
 				*p++ = sym;
+			}
 
 	/* And list them.  */
 	printf("\nSymbols:\n");
@@ -4265,7 +4275,7 @@
 	}
 #else
 	len = MAXINT(ssize_t);
-	map = xmalloc_open_read_close(filename, &len);
+	map = xmalloc_xopen_read_close(filename, &len);
 #endif
 
 	if (init_module(map, len, options) != 0)
