--- valgrind-2.1.1.orig/coregrind/vg_syscalls.c	2004-02-24 17:07:10.000000000 -0700
+++ valgrind-2.1.1/coregrind/vg_syscalls.c	2004-04-16 18:13:11.000000000 -0600
@@ -3231,6 +3245,93 @@
    case CDROM_CLEAR_OPTIONS: /* 0x5321 */
       break;
 
+      /* Stuff added by Erik Andersen for general device probing/handling */
+#define BLKSSZGET  _IO(0x12,104)
+   case BLKSSZGET:
+      SYSCALL_TRACK( pre_mem_write, tid, "ioctl(BLKSSZGET)", arg3,
+	      sizeof(int));
+      break;
+#undef _IOR
+#define _IOR(type,nr,size)      _IOC(_IOC_READ,(type),(nr),sizeof(size))
+#define BLKGETSIZE64 _IOR(0x12,114,sizeof(uint64_t))
+   case BLKGETSIZE64:
+      SYSCALL_TRACK( pre_mem_write, tid, "ioctl(BLKGETSIZE64)", arg3,
+	      sizeof(uint64_t));
+      break;
+#define HDIO_GETGEO             0x0301  /* get device geometry */
+   case HDIO_GETGEO:
+      {
+	  struct hd_geometry {
+	      unsigned char heads;
+	      unsigned char sectors;
+	      unsigned short cylinders;
+	      unsigned long start;
+	  };
+
+	  SYSCALL_TRACK( pre_mem_write, tid, "ioctl(HDIO_GETGEO)", arg3,
+		  sizeof(struct hd_geometry));
+      }
+      break;
+#define HDIO_GET_IDENTITY	0x030d	/* get IDE identification info */
+#define struct_hd_driveid_size	256	/* ATA6 specifies words 0-255 */
+   case HDIO_GET_IDENTITY:
+      SYSCALL_TRACK( pre_mem_write, tid, "ioctl(HDIO_GET_IDENTITY)", arg3,
+	      struct_hd_driveid_size);
+      break;
+#define SCSI_IOCTL_GET_IDLUN 0x5382
+   case SCSI_IOCTL_GET_IDLUN:
+      {
+	  struct scsi_idlun
+	  {
+	      int mux4;
+	      int host_unique_id;
+
+	  };
+
+	  SYSCALL_TRACK( pre_mem_write, tid, "ioctl(SCSI_IOCTL_GET_IDLUN)", arg3,
+		  sizeof(struct scsi_idlun));
+      }
+      break;
+#define SCSI_IOCTL_SEND_COMMAND 1
+   case SCSI_IOCTL_SEND_COMMAND:
+      SYSCALL_TRACK( pre_mem_write, tid, "ioctl(SCSI_IOCTL_SEND_COMMAND)", arg3,
+	      ((2 * sizeof(unsigned int)) + 6 + 512));
+      break;
+#define SCSI_IOCTL_GET_BUS_NUMBER 0x5386
+   case SCSI_IOCTL_GET_BUS_NUMBER:
+      SYSCALL_TRACK( pre_mem_write, tid, "ioctl(SCSI_IOCTL_GET_BUS_NUMBER)", arg3,
+	      sizeof(int));
+      break;
+#define SCSI_IOCTL_PROBE_HOST 0x5385
+   case SCSI_IOCTL_PROBE_HOST:
+      {
+	  int xxxx;
+	  char *array = (char*)arg3;
+	  xxxx = array[0] + (array[1]<<8) + (array[2]<<16) + (array[3]<<24);
+	  SYSCALL_TRACK( pre_mem_write, tid, "ioctl(SCSI_IOCTL_PROBE_HOST)", arg3,
+		  sizeof(int));
+      }
+      break;
+#define BLKFLSBUF  _IO(0x12,97)
+   case BLKFLSBUF:
+      break;
+#define BLKRRPART  _IO(0x12,95)
+   case BLKRRPART:
+      break;
+#define MTIOCTOP  _IO(0x6d,0x1)
+   case MTIOCTOP:
+      {
+	  struct mtop
+	  {
+	      short int mt_op;		/* Operations defined below.  */
+	      int mt_count;		/* How many of them.  */
+	  };
+	  SYSCALL_TRACK( pre_mem_write, tid, "ioctl(MTIOCTOP)", arg3, 
+		  sizeof(struct mtop));
+      }
+      break;
+
+
       /* We don't have any specific information on it, so
 	 try to do something reasonable based on direction and
 	 size bits.  The encoding scheme is described in
--- valgrind-2.1.1.orig/coregrind/vg_libpthread.c	2004-03-08 08:57:17.000000000 -0700
+++ valgrind-2.1.1/coregrind/vg_libpthread.c	2004-04-16 17:58:31.000000000 -0600
@@ -3175,6 +3175,8 @@
    pthread_mutex).  So basically, this is completely broken on recent
    glibcs. */
 
+#ifndef __UCLIBC__
+
 #undef _IO_flockfile
 void _IO_flockfile ( _IO_FILE * file )
 {
@@ -3192,6 +3194,7 @@
 weak_alias(_IO_funlockfile, funlockfile);
 #endif
 
+#endif
 
 /* This doesn't seem to be needed to simulate libpthread.so's external
    interface, but many people complain about its absence. */
