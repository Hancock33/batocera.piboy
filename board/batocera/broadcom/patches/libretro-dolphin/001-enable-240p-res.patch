diff --git a/Source/Core/VideoCommon/FramebufferManager.cpp b/Source/Core/VideoCommon/FramebufferManager.cpp
index 6277598d92..9cf5c1df6a 100644
--- a/Source/Core/VideoCommon/FramebufferManager.cpp
+++ b/Source/Core/VideoCommon/FramebufferManager.cpp
@@ -185,19 +185,24 @@ FramebufferManager::ConvertEFBRectangle(const MathUtil::Rectangle<int>& rc) cons
   return result;
 }
 
-unsigned int FramebufferManager::GetEFBScale() const
+bool FramebufferManager::IsUnscaled() const
 {
-  return m_efb_scale;
+  return m_efb_scale == 2;
+}
+
+float FramebufferManager::GetEFBScalef() const
+{
+  return m_efb_scale / 2.0f;
 }
 
 int FramebufferManager::EFBToScaledX(int x) const
 {
-  return x * static_cast<int>(m_efb_scale);
+  return x * static_cast<int>(m_efb_scale) / 2;
 }
 
 int FramebufferManager::EFBToScaledY(int y) const
 {
-  return y * static_cast<int>(m_efb_scale);
+  return y * static_cast<int>(m_efb_scale) / 2;;
 }
 
 float FramebufferManager::EFBToScaledXf(float x) const
@@ -221,8 +226,8 @@ std::tuple<u32, u32> FramebufferManager::CalculateTargetSize(int efb_scale)
   if (max_size < EFB_WIDTH * m_efb_scale)
     m_efb_scale = max_size / EFB_WIDTH;
 
-  u32 new_efb_width = std::max(EFB_WIDTH * static_cast<int>(m_efb_scale), 1u);
-  u32 new_efb_height = std::max(EFB_HEIGHT * static_cast<int>(m_efb_scale), 1u);
+  u32 new_efb_width = std::max(EFB_WIDTH * static_cast<int>(m_efb_scale) / 2, 1u);
+  u32 new_efb_height = std::max(EFB_HEIGHT * static_cast<int>(m_efb_scale) / 2, 1u);
 
   return std::make_tuple(new_efb_width, new_efb_height);
 }
@@ -698,7 +703,8 @@ void FramebufferManager::DestroyReadbackPipelines()
 
 bool FramebufferManager::CreateReadbackFramebuffer()
 {
-  if (GetEFBScale() != 1)
+  //if (GetEFBScale() != 1)
+  if (IsUnscaled())
   {
     const TextureConfig color_config(IsUsingTiledEFBCache() ? m_efb_cache_tile_size : EFB_WIDTH,
                                      IsUsingTiledEFBCache() ? m_efb_cache_tile_size : EFB_HEIGHT, 1,
@@ -720,7 +726,8 @@ bool FramebufferManager::CreateReadbackFramebuffer()
       (IsUsingTiledEFBCache() && !g_backend_info.bSupportsPartialDepthCopies) ||
       !AbstractTexture::IsCompatibleDepthAndColorFormats(m_efb_depth_texture->GetFormat(),
                                                          GetEFBDepthCopyFormat()) ||
-      GetEFBScale() != 1)
+      //GetEFBScale() != 1)
+      IsUnscaled())
   {
     const TextureConfig depth_config(IsUsingTiledEFBCache() ? m_efb_cache_tile_size : EFB_WIDTH,
                                      IsUsingTiledEFBCache() ? m_efb_cache_tile_size : EFB_HEIGHT, 1,
@@ -802,7 +809,8 @@ void FramebufferManager::PopulateEFBCache(bool depth, u32 tile_index, bool async
   const MathUtil::Rectangle<int> native_rect = ConvertEFBRectangle(rect);
   AbstractTexture* src_texture =
       depth ? ResolveEFBDepthTexture(native_rect) : ResolveEFBColorTexture(native_rect);
-  if (GetEFBScale() != 1 || force_intermediate_copy)
+  //if (GetEFBScale() != 1 || force_intermediate_copy)
+  if (IsUnscaled() || force_intermediate_copy)
   {
     // Downsample from internal resolution to 1x.
     // TODO: This won't produce correct results at IRs above 2x. More samples are required.
@@ -988,7 +996,7 @@ void FramebufferManager::CreatePokeVertices(std::vector<EFBPokeVertex>* destinat
     // GPU will expand the point to a quad.
     const float cs_x = (static_cast<float>(x) + 0.5f) * cs_pixel_width - 1.0f;
     const float cs_y = 1.0f - (static_cast<float>(y) + 0.5f) * cs_pixel_height;
-    const float point_size = static_cast<float>(GetEFBScale());
+    const float point_size = GetEFBScalef();
     destination_list->push_back({{cs_x, cs_y, z, point_size}, color});
     return;
   }
diff --git a/Source/Core/VideoCommon/FramebufferManager.h b/Source/Core/VideoCommon/FramebufferManager.h
index 7654698070..4de17b4f0b 100644
--- a/Source/Core/VideoCommon/FramebufferManager.h
+++ b/Source/Core/VideoCommon/FramebufferManager.h
@@ -74,7 +74,8 @@ public:
   // Use this to convert a whole native EFB rect to backbuffer coordinates
   MathUtil::Rectangle<int> ConvertEFBRectangle(const MathUtil::Rectangle<int>& rc) const;
 
-  unsigned int GetEFBScale() const;
+  bool IsUnscaled() const;
+  float GetEFBScalef() const;
 
   // Use this to upscale native EFB coordinates to IDEAL internal resolution
   int EFBToScaledX(int x) const;
@@ -194,7 +195,8 @@ protected:
   void DoLoadState(PointerWrap& p);
   void DoSaveState(PointerWrap& p);
 
-  float m_efb_scale = 1.0f;
+  //float m_efb_scale = 1.0f;
+  float m_efb_scale = 2.0f;
   PixelFormat m_prev_efb_format;
 
   std::unique_ptr<AbstractTexture> m_efb_color_texture;
diff --git a/Source/Core/VideoCommon/Present.cpp b/Source/Core/VideoCommon/Present.cpp
index 6c5a1a4303..303cafa9c6 100644
--- a/Source/Core/VideoCommon/Present.cpp
+++ b/Source/Core/VideoCommon/Present.cpp
@@ -86,7 +86,7 @@ static void TryToSnapToXFBSize(int& width, int& height, int xfb_width, int xfb_h
   // The reason why the threshold is 1 pixel (per internal resolution multiplier) is because of
   // minor inaccuracies of the VI aspect ratio (and because some resolutions are rounded
   // while other are floored).
-  const unsigned int efb_scale = g_framebuffer_manager->GetEFBScale();
+  const unsigned int efb_scale = g_framebuffer_manager->GetEFBScalef();
   const unsigned int pixel_difference_width = std::abs(width - xfb_width);
   const unsigned int pixel_difference_height = std::abs(height - xfb_height);
   // We ignore this if there's an offset on both hor and ver size,
diff --git a/Source/Core/VideoCommon/TextureCacheBase.cpp b/Source/Core/VideoCommon/TextureCacheBase.cpp
index b1aac00672..57cd4f78b3 100644
--- a/Source/Core/VideoCommon/TextureCacheBase.cpp
+++ b/Source/Core/VideoCommon/TextureCacheBase.cpp
@@ -1066,7 +1066,8 @@ SamplerState TextureCacheBase::GetSamplerState(u32 index, float custom_tex_scale
     // that have arbitrary contents, eg. are used for fog effects where the
     // distance they kick in at is important to preserve at any resolution.
     // Correct this with the upscaling factor of custom textures.
-    s32 lod_offset = std::log2(g_framebuffer_manager->GetEFBScale() / custom_tex_scale) * 256.f;
+    //s32 lod_offset = std::log2(g_framebuffer_manager->GetEFBScale() / custom_tex_scale) * 256.f;
+    s64 lod_offset = std::log2(g_framebuffer_manager->GetEFBScalef() / custom_tex_scale) * (s64) 256.f;
     state.tm0.lod_bias = std::clamp<s32>(state.tm0.lod_bias + lod_offset, -32768, 32767);
 
     // Anisotropic also pushes mips farther away so it cannot be used either
@@ -2302,7 +2303,8 @@ void TextureCacheBase::CopyRenderTargetToTexture(
   //       complex down filtering to average all pixels and produce the correct result.
   const bool linear_filter =
       !is_depth_copy &&
-      (scaleByHalf || g_framebuffer_manager->GetEFBScale() != 1 || y_scale > 1.0f);
+      //(scaleByHalf || g_framebuffer_manager->GetEFBScale() != 1 || y_scale > 1.0f);
+      (scaleByHalf || g_framebuffer_manager->IsUnscaled() || y_scale > 1.0f);
 
   RcTcacheEntry entry;
   if (copy_to_vram)
diff --git a/Source/Core/VideoCommon/VideoConfig.cpp b/Source/Core/VideoCommon/VideoConfig.cpp
index a15331569d..1c24dde51f 100644
--- a/Source/Core/VideoCommon/VideoConfig.cpp
+++ b/Source/Core/VideoCommon/VideoConfig.cpp
@@ -363,7 +363,7 @@ void CheckForConfigChanges()
   if (changed_bits == 0)
     return;
 
-  float old_scale = g_framebuffer_manager->GetEFBScale();
+  float old_scale = g_framebuffer_manager->GetEFBScalef();
 
   // Framebuffer changed?
   if (changed_bits & (CONFIG_CHANGE_BIT_MULTISAMPLES | CONFIG_CHANGE_BIT_STEREO_MODE |
@@ -372,7 +372,7 @@ void CheckForConfigChanges()
     g_framebuffer_manager->RecreateEFBFramebuffer(g_ActiveConfig.iEFBScale);
   }
 
-  if (old_scale != g_framebuffer_manager->GetEFBScale())
+  if (old_scale != g_framebuffer_manager->GetEFBScalef())
   {
     auto& system = Core::System::GetInstance();
     auto& pixel_shader_manager = system.GetPixelShaderManager();
