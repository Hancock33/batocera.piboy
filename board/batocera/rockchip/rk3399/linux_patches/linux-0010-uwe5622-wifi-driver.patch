From 8c1a307e50c7bf0ce8d76afc89ec05ed9e5a0173 Mon Sep 17 00:00:00 2001
From: Jernej Skrabec <jernej.skrabec@gmail.com>
Date: Mon, 27 Dec 2021 22:29:53 +0100
Subject: [PATCH] uwe5622 wifi driver

---
 drivers/net/wireless/Kconfig                  |    1 +
 drivers/net/wireless/Makefile                 |    1 +
 drivers/net/wireless/uwe5622/Kconfig          |   13 +
 drivers/net/wireless/uwe5622/Makefile         |   10 +
 drivers/net/wireless/uwe5622/tty-sdio/Kconfig |    4 +
 .../net/wireless/uwe5622/tty-sdio/Makefile    |   14 +
 .../uwe5622/tty-sdio/alignment/sitm.c         |  166 +
 .../uwe5622/tty-sdio/alignment/sitm.h         |   52 +
 .../net/wireless/uwe5622/tty-sdio/rfkill.c    |   84 +
 .../net/wireless/uwe5622/tty-sdio/rfkill.h    |   25 +
 drivers/net/wireless/uwe5622/tty-sdio/tty.c   |  706 +++
 drivers/net/wireless/uwe5622/tty-sdio/tty.h   |   44 +
 drivers/net/wireless/uwe5622/tty-sdio/woble.c |  168 +
 drivers/net/wireless/uwe5622/tty-sdio/woble.h |  137 +
 .../net/wireless/uwe5622/unisocwcn/Kconfig    |   93 +
 .../net/wireless/uwe5622/unisocwcn/Makefile   |   95 +
 .../uwe5622/unisocwcn/include/bus_common.h    |   16 +
 .../unisocwcn/include/marlin_platform.h       |  111 +
 .../wireless/uwe5622/unisocwcn/include/mchn.h |  108 +
 .../uwe5622/unisocwcn/include/uwe5621_glb.h   |  295 ++
 .../uwe5622/unisocwcn/include/uwe5622_glb.h   |  121 +
 .../uwe5622/unisocwcn/include/uwe5623_glb.h   |  307 ++
 .../uwe5622/unisocwcn/include/uwe562x_glb.h   |  419 ++
 .../uwe5622/unisocwcn/include/wcn_bus.h       |  605 +++
 .../uwe5622/unisocwcn/include/wcn_glb.h       |   26 +
 .../uwe5622/unisocwcn/include/wcn_glb_reg.h   |   31 +
 .../uwe5622/unisocwcn/include/wcn_types.h     |   12 +
 .../uwe5622/unisocwcn/platform/loopcheck.c    |  256 +
 .../uwe5622/unisocwcn/platform/loopcheck.h    |   16 +
 .../uwe5622/unisocwcn/platform/mdbg_type.h    |   97 +
 .../uwe5622/unisocwcn/platform/wcn_boot.c     | 2076 +++++++++
 .../uwe5622/unisocwcn/platform/wcn_misc.c     |  120 +
 .../uwe5622/unisocwcn/platform/wcn_misc.h     |   72 +
 .../uwe5622/unisocwcn/platform/wcn_procfs.c   |  944 ++++
 .../uwe5622/unisocwcn/platform/wcn_procfs.h   |   19 +
 .../uwe5622/unisocwcn/platform/wcn_txrx.c     |  163 +
 .../uwe5622/unisocwcn/platform/wcn_txrx.h     |  134 +
 .../wireless/uwe5622/unisocwcn/sdio/sdio_v3.c |  166 +
 .../wireless/uwe5622/unisocwcn/sdio/sdiohal.h |  522 +++
 .../uwe5622/unisocwcn/sdio/sdiohal_common.c   | 1465 ++++++
 .../uwe5622/unisocwcn/sdio/sdiohal_ctl.c      | 1241 +++++
 .../uwe5622/unisocwcn/sdio/sdiohal_main.c     | 2069 +++++++++
 .../uwe5622/unisocwcn/sdio/sdiohal_rx.c       |  333 ++
 .../uwe5622/unisocwcn/sdio/sdiohal_tx.c       |  195 +
 .../uwe5622/unisocwcn/sleep/sdio_int.c        |  353 ++
 .../uwe5622/unisocwcn/sleep/sdio_int.h        |  127 +
 .../uwe5622/unisocwcn/sleep/slp_mgr.c         |  202 +
 .../uwe5622/unisocwcn/sleep/slp_mgr.h         |   52 +
 .../uwe5622/unisocwcn/sleep/slp_sdio.c        |   67 +
 .../uwe5622/unisocwcn/sleep/slp_sdio.h        |   22 +
 .../net/wireless/uwe5622/unisocwcn/wcn_bus.c  |  311 ++
 .../net/wireless/uwe5622/unisocwifi/Kconfig   |   12 +
 .../net/wireless/uwe5622/unisocwifi/Makefile  |   60 +
 .../wireless/uwe5622/unisocwifi/api_version.c |  498 ++
 .../wireless/uwe5622/unisocwifi/cfg80211.c    | 3815 +++++++++++++++
 .../wireless/uwe5622/unisocwifi/cfg80211.h    |  211 +
 .../net/wireless/uwe5622/unisocwifi/cmdevt.c  | 3561 ++++++++++++++
 .../net/wireless/uwe5622/unisocwifi/cmdevt.h  | 1125 +++++
 .../net/wireless/uwe5622/unisocwifi/debug.c   |  189 +
 .../net/wireless/uwe5622/unisocwifi/debug.h   |   88 +
 .../net/wireless/uwe5622/unisocwifi/defrag.c  |  264 ++
 .../net/wireless/uwe5622/unisocwifi/defrag.h  |   35 +
 .../net/wireless/uwe5622/unisocwifi/ibss.c    |  209 +
 .../net/wireless/uwe5622/unisocwifi/ibss.h    |   36 +
 .../net/wireless/uwe5622/unisocwifi/intf.h    |   41 +
 .../wireless/uwe5622/unisocwifi/intf_ops.h    |   97 +
 .../net/wireless/uwe5622/unisocwifi/main.c    | 1643 +++++++
 drivers/net/wireless/uwe5622/unisocwifi/mm.c  |  620 +++
 drivers/net/wireless/uwe5622/unisocwifi/mm.h  |   40 +
 drivers/net/wireless/uwe5622/unisocwifi/msg.c |  183 +
 drivers/net/wireless/uwe5622/unisocwifi/msg.h |  219 +
 drivers/net/wireless/uwe5622/unisocwifi/nan.c |   87 +
 drivers/net/wireless/uwe5622/unisocwifi/nan.h |  304 ++
 drivers/net/wireless/uwe5622/unisocwifi/npi.c |  313 ++
 drivers/net/wireless/uwe5622/unisocwifi/npi.h |   75 +
 drivers/net/wireless/uwe5622/unisocwifi/qos.c |  815 ++++
 drivers/net/wireless/uwe5622/unisocwifi/qos.h |  247 +
 .../wireless/uwe5622/unisocwifi/reg_domain.c  |  342 ++
 .../wireless/uwe5622/unisocwifi/reg_domain.h  |   27 +
 .../net/wireless/uwe5622/unisocwifi/reorder.c |  996 ++++
 .../net/wireless/uwe5622/unisocwifi/reorder.h |   76 +
 .../wireless/uwe5622/unisocwifi/rf_marlin3.c  |  440 ++
 .../wireless/uwe5622/unisocwifi/rf_marlin3.h  |  181 +
 .../uwe5622/unisocwifi/rnd_mac_addr.c         |   28 +
 .../uwe5622/unisocwifi/rnd_mac_addr.h         |   13 +
 drivers/net/wireless/uwe5622/unisocwifi/rtt.c |  965 ++++
 drivers/net/wireless/uwe5622/unisocwifi/rtt.h |  528 +++
 .../net/wireless/uwe5622/unisocwifi/rx_msg.c  |  602 +++
 .../net/wireless/uwe5622/unisocwifi/rx_msg.h  |  266 ++
 .../wireless/uwe5622/unisocwifi/softap_hook.c |   76 +
 .../wireless/uwe5622/unisocwifi/softap_hook.h |    9 +
 .../net/wireless/uwe5622/unisocwifi/sprdwl.h  |  397 ++
 .../net/wireless/uwe5622/unisocwifi/tcp_ack.c |  606 +++
 .../net/wireless/uwe5622/unisocwifi/tcp_ack.h |   89 +
 .../net/wireless/uwe5622/unisocwifi/tracer.c  |  192 +
 .../net/wireless/uwe5622/unisocwifi/tracer.h  |   54 +
 .../net/wireless/uwe5622/unisocwifi/tx_msg.c  | 1833 ++++++++
 .../net/wireless/uwe5622/unisocwifi/tx_msg.h  |  125 +
 .../net/wireless/uwe5622/unisocwifi/txrx.c    |  224 +
 .../net/wireless/uwe5622/unisocwifi/txrx.h    |   49 +
 .../net/wireless/uwe5622/unisocwifi/vendor.c  | 4134 +++++++++++++++++
 .../net/wireless/uwe5622/unisocwifi/vendor.h  | 1684 +++++++
 .../net/wireless/uwe5622/unisocwifi/version.h |   55 +
 .../net/wireless/uwe5622/unisocwifi/wl_core.c |  714 +++
 .../net/wireless/uwe5622/unisocwifi/wl_core.h |  210 +
 .../net/wireless/uwe5622/unisocwifi/wl_intf.c | 1881 ++++++++
 .../net/wireless/uwe5622/unisocwifi/wl_intf.h |  302 ++
 .../net/wireless/uwe5622/unisocwifi/work.c    |  215 +
 .../net/wireless/uwe5622/unisocwifi/work.h    |   84 +
 109 files changed, 46870 insertions(+)
 create mode 100644 drivers/net/wireless/uwe5622/Kconfig
 create mode 100644 drivers/net/wireless/uwe5622/Makefile
 create mode 100644 drivers/net/wireless/uwe5622/tty-sdio/Kconfig
 create mode 100644 drivers/net/wireless/uwe5622/tty-sdio/Makefile
 create mode 100644 drivers/net/wireless/uwe5622/tty-sdio/alignment/sitm.c
 create mode 100644 drivers/net/wireless/uwe5622/tty-sdio/alignment/sitm.h
 create mode 100644 drivers/net/wireless/uwe5622/tty-sdio/rfkill.c
 create mode 100644 drivers/net/wireless/uwe5622/tty-sdio/rfkill.h
 create mode 100644 drivers/net/wireless/uwe5622/tty-sdio/tty.c
 create mode 100644 drivers/net/wireless/uwe5622/tty-sdio/tty.h
 create mode 100644 drivers/net/wireless/uwe5622/tty-sdio/woble.c
 create mode 100644 drivers/net/wireless/uwe5622/tty-sdio/woble.h
 create mode 100644 drivers/net/wireless/uwe5622/unisocwcn/Kconfig
 create mode 100644 drivers/net/wireless/uwe5622/unisocwcn/Makefile
 create mode 100644 drivers/net/wireless/uwe5622/unisocwcn/include/bus_common.h
 create mode 100644 drivers/net/wireless/uwe5622/unisocwcn/include/marlin_platform.h
 create mode 100644 drivers/net/wireless/uwe5622/unisocwcn/include/mchn.h
 create mode 100644 drivers/net/wireless/uwe5622/unisocwcn/include/uwe5621_glb.h
 create mode 100644 drivers/net/wireless/uwe5622/unisocwcn/include/uwe5622_glb.h
 create mode 100644 drivers/net/wireless/uwe5622/unisocwcn/include/uwe5623_glb.h
 create mode 100644 drivers/net/wireless/uwe5622/unisocwcn/include/uwe562x_glb.h
 create mode 100644 drivers/net/wireless/uwe5622/unisocwcn/include/wcn_bus.h
 create mode 100644 drivers/net/wireless/uwe5622/unisocwcn/include/wcn_glb.h
 create mode 100644 drivers/net/wireless/uwe5622/unisocwcn/include/wcn_glb_reg.h
 create mode 100644 drivers/net/wireless/uwe5622/unisocwcn/include/wcn_types.h
 create mode 100644 drivers/net/wireless/uwe5622/unisocwcn/platform/loopcheck.c
 create mode 100644 drivers/net/wireless/uwe5622/unisocwcn/platform/loopcheck.h
 create mode 100644 drivers/net/wireless/uwe5622/unisocwcn/platform/mdbg_type.h
 create mode 100644 drivers/net/wireless/uwe5622/unisocwcn/platform/wcn_boot.c
 create mode 100644 drivers/net/wireless/uwe5622/unisocwcn/platform/wcn_misc.c
 create mode 100644 drivers/net/wireless/uwe5622/unisocwcn/platform/wcn_misc.h
 create mode 100644 drivers/net/wireless/uwe5622/unisocwcn/platform/wcn_procfs.c
 create mode 100644 drivers/net/wireless/uwe5622/unisocwcn/platform/wcn_procfs.h
 create mode 100644 drivers/net/wireless/uwe5622/unisocwcn/platform/wcn_txrx.c
 create mode 100644 drivers/net/wireless/uwe5622/unisocwcn/platform/wcn_txrx.h
 create mode 100644 drivers/net/wireless/uwe5622/unisocwcn/sdio/sdio_v3.c
 create mode 100644 drivers/net/wireless/uwe5622/unisocwcn/sdio/sdiohal.h
 create mode 100644 drivers/net/wireless/uwe5622/unisocwcn/sdio/sdiohal_common.c
 create mode 100644 drivers/net/wireless/uwe5622/unisocwcn/sdio/sdiohal_ctl.c
 create mode 100644 drivers/net/wireless/uwe5622/unisocwcn/sdio/sdiohal_main.c
 create mode 100644 drivers/net/wireless/uwe5622/unisocwcn/sdio/sdiohal_rx.c
 create mode 100644 drivers/net/wireless/uwe5622/unisocwcn/sdio/sdiohal_tx.c
 create mode 100644 drivers/net/wireless/uwe5622/unisocwcn/sleep/sdio_int.c
 create mode 100644 drivers/net/wireless/uwe5622/unisocwcn/sleep/sdio_int.h
 create mode 100644 drivers/net/wireless/uwe5622/unisocwcn/sleep/slp_mgr.c
 create mode 100644 drivers/net/wireless/uwe5622/unisocwcn/sleep/slp_mgr.h
 create mode 100644 drivers/net/wireless/uwe5622/unisocwcn/sleep/slp_sdio.c
 create mode 100644 drivers/net/wireless/uwe5622/unisocwcn/sleep/slp_sdio.h
 create mode 100644 drivers/net/wireless/uwe5622/unisocwcn/wcn_bus.c
 create mode 100644 drivers/net/wireless/uwe5622/unisocwifi/Kconfig
 create mode 100644 drivers/net/wireless/uwe5622/unisocwifi/Makefile
 create mode 100644 drivers/net/wireless/uwe5622/unisocwifi/api_version.c
 create mode 100644 drivers/net/wireless/uwe5622/unisocwifi/cfg80211.c
 create mode 100644 drivers/net/wireless/uwe5622/unisocwifi/cfg80211.h
 create mode 100644 drivers/net/wireless/uwe5622/unisocwifi/cmdevt.c
 create mode 100644 drivers/net/wireless/uwe5622/unisocwifi/cmdevt.h
 create mode 100644 drivers/net/wireless/uwe5622/unisocwifi/debug.c
 create mode 100644 drivers/net/wireless/uwe5622/unisocwifi/debug.h
 create mode 100644 drivers/net/wireless/uwe5622/unisocwifi/defrag.c
 create mode 100644 drivers/net/wireless/uwe5622/unisocwifi/defrag.h
 create mode 100644 drivers/net/wireless/uwe5622/unisocwifi/ibss.c
 create mode 100644 drivers/net/wireless/uwe5622/unisocwifi/ibss.h
 create mode 100644 drivers/net/wireless/uwe5622/unisocwifi/intf.h
 create mode 100644 drivers/net/wireless/uwe5622/unisocwifi/intf_ops.h
 create mode 100644 drivers/net/wireless/uwe5622/unisocwifi/main.c
 create mode 100644 drivers/net/wireless/uwe5622/unisocwifi/mm.c
 create mode 100644 drivers/net/wireless/uwe5622/unisocwifi/mm.h
 create mode 100644 drivers/net/wireless/uwe5622/unisocwifi/msg.c
 create mode 100644 drivers/net/wireless/uwe5622/unisocwifi/msg.h
 create mode 100644 drivers/net/wireless/uwe5622/unisocwifi/nan.c
 create mode 100644 drivers/net/wireless/uwe5622/unisocwifi/nan.h
 create mode 100644 drivers/net/wireless/uwe5622/unisocwifi/npi.c
 create mode 100644 drivers/net/wireless/uwe5622/unisocwifi/npi.h
 create mode 100644 drivers/net/wireless/uwe5622/unisocwifi/qos.c
 create mode 100644 drivers/net/wireless/uwe5622/unisocwifi/qos.h
 create mode 100644 drivers/net/wireless/uwe5622/unisocwifi/reg_domain.c
 create mode 100644 drivers/net/wireless/uwe5622/unisocwifi/reg_domain.h
 create mode 100644 drivers/net/wireless/uwe5622/unisocwifi/reorder.c
 create mode 100644 drivers/net/wireless/uwe5622/unisocwifi/reorder.h
 create mode 100644 drivers/net/wireless/uwe5622/unisocwifi/rf_marlin3.c
 create mode 100644 drivers/net/wireless/uwe5622/unisocwifi/rf_marlin3.h
 create mode 100644 drivers/net/wireless/uwe5622/unisocwifi/rnd_mac_addr.c
 create mode 100644 drivers/net/wireless/uwe5622/unisocwifi/rnd_mac_addr.h
 create mode 100644 drivers/net/wireless/uwe5622/unisocwifi/rtt.c
 create mode 100644 drivers/net/wireless/uwe5622/unisocwifi/rtt.h
 create mode 100644 drivers/net/wireless/uwe5622/unisocwifi/rx_msg.c
 create mode 100644 drivers/net/wireless/uwe5622/unisocwifi/rx_msg.h
 create mode 100644 drivers/net/wireless/uwe5622/unisocwifi/softap_hook.c
 create mode 100644 drivers/net/wireless/uwe5622/unisocwifi/softap_hook.h
 create mode 100644 drivers/net/wireless/uwe5622/unisocwifi/sprdwl.h
 create mode 100644 drivers/net/wireless/uwe5622/unisocwifi/tcp_ack.c
 create mode 100644 drivers/net/wireless/uwe5622/unisocwifi/tcp_ack.h
 create mode 100644 drivers/net/wireless/uwe5622/unisocwifi/tracer.c
 create mode 100644 drivers/net/wireless/uwe5622/unisocwifi/tracer.h
 create mode 100644 drivers/net/wireless/uwe5622/unisocwifi/tx_msg.c
 create mode 100644 drivers/net/wireless/uwe5622/unisocwifi/tx_msg.h
 create mode 100644 drivers/net/wireless/uwe5622/unisocwifi/txrx.c
 create mode 100644 drivers/net/wireless/uwe5622/unisocwifi/txrx.h
 create mode 100644 drivers/net/wireless/uwe5622/unisocwifi/vendor.c
 create mode 100644 drivers/net/wireless/uwe5622/unisocwifi/vendor.h
 create mode 100644 drivers/net/wireless/uwe5622/unisocwifi/version.h
 create mode 100644 drivers/net/wireless/uwe5622/unisocwifi/wl_core.c
 create mode 100644 drivers/net/wireless/uwe5622/unisocwifi/wl_core.h
 create mode 100644 drivers/net/wireless/uwe5622/unisocwifi/wl_intf.c
 create mode 100644 drivers/net/wireless/uwe5622/unisocwifi/wl_intf.h
 create mode 100644 drivers/net/wireless/uwe5622/unisocwifi/work.c
 create mode 100644 drivers/net/wireless/uwe5622/unisocwifi/work.h

diff --git a/drivers/net/wireless/Kconfig b/drivers/net/wireless/Kconfig
index 7add2002ff4c..980347b8c381 100644
--- a/drivers/net/wireless/Kconfig
+++ b/drivers/net/wireless/Kconfig
@@ -33,6 +33,7 @@ source "drivers/net/wireless/realtek/Kconfig"
 source "drivers/net/wireless/rsi/Kconfig"
 source "drivers/net/wireless/st/Kconfig"
 source "drivers/net/wireless/ti/Kconfig"
+source "drivers/net/wireless/uwe5622/Kconfig"
 source "drivers/net/wireless/zydas/Kconfig"
 source "drivers/net/wireless/quantenna/Kconfig"
 
diff --git a/drivers/net/wireless/Makefile b/drivers/net/wireless/Makefile
index 80b324499786..493309c202f5 100644
--- a/drivers/net/wireless/Makefile
+++ b/drivers/net/wireless/Makefile
@@ -20,6 +20,7 @@ obj-$(CONFIG_WLAN_VENDOR_ST) += st/
 obj-$(CONFIG_WLAN_VENDOR_TI) += ti/
 obj-$(CONFIG_WLAN_VENDOR_ZYDAS) += zydas/
 obj-$(CONFIG_WLAN_VENDOR_QUANTENNA) += quantenna/
+obj-$(CONFIG_SPARD_WLAN_SUPPORT) += uwe5622/
 
 # 16-bit wireless PCMCIA client drivers
 obj-$(CONFIG_PCMCIA_RAYCS)	+= ray_cs.o
diff --git a/drivers/net/wireless/uwe5622/Kconfig b/drivers/net/wireless/uwe5622/Kconfig
new file mode 100644
index 000000000000..a1e123b039bd
--- /dev/null
+++ b/drivers/net/wireless/uwe5622/Kconfig
@@ -0,0 +1,13 @@
+config SPARD_WLAN_SUPPORT
+	bool "Unisoc wireless Support"
+	select AW_WIFI_DEVICE_UWE5622  if SPARD_WLAN_SUPPORT
+	select AW_BIND_VERIFY  if SPARD_WLAN_SUPPORT
+	default n
+	help
+	  This is support for spreadtrum wireless chip.
+
+if SPARD_WLAN_SUPPORT
+source "drivers/net/wireless/uwe5622/unisocwcn/Kconfig"
+source "drivers/net/wireless/uwe5622/unisocwifi/Kconfig"
+source "drivers/net/wireless/uwe5622/tty-sdio/Kconfig"
+endif
diff --git a/drivers/net/wireless/uwe5622/Makefile b/drivers/net/wireless/uwe5622/Makefile
new file mode 100644
index 000000000000..8d7f17ff95c1
--- /dev/null
+++ b/drivers/net/wireless/uwe5622/Makefile
@@ -0,0 +1,10 @@
+obj-$(CONFIG_AW_WIFI_DEVICE_UWE5622) += unisocwcn/
+obj-$(CONFIG_WLAN_UWE5622)    += unisocwifi/
+obj-$(CONFIG_TTY_OVERY_SDIO)  += tty-sdio/
+
+UNISOCWCN_DIR := $(shell cd $(srctree)/drivers/net/wireless/uwe5622/unisocwcn/ && /bin/pwd)
+UNISOC_BSP_INCLUDE := $(UNISOCWCN_DIR)/include
+export UNISOC_BSP_INCLUDE
+
+UNISOC_FW_PATH_CONFIG := "/lib/firmware/"
+export UNISOC_FW_PATH_CONFIG
diff --git a/drivers/net/wireless/uwe5622/tty-sdio/Kconfig b/drivers/net/wireless/uwe5622/tty-sdio/Kconfig
new file mode 100644
index 000000000000..df2027bf05f2
--- /dev/null
+++ b/drivers/net/wireless/uwe5622/tty-sdio/Kconfig
@@ -0,0 +1,4 @@
+config TTY_OVERY_SDIO
+	tristate "Spard TTY Overy SDIO Driver"
+	help
+	  Spard tty overy sdio driver.
diff --git a/drivers/net/wireless/uwe5622/tty-sdio/Makefile b/drivers/net/wireless/uwe5622/tty-sdio/Makefile
new file mode 100644
index 000000000000..b25faacadac1
--- /dev/null
+++ b/drivers/net/wireless/uwe5622/tty-sdio/Makefile
@@ -0,0 +1,14 @@
+ccflags-y += -I$(srctree)/drivers/net/wireless/uwe5622/sprdwcn/include
+
+ifneq ($(UNISOC_BSP_INCLUDE),)
+ccflags-y += -I$(UNISOC_BSP_INCLUDE)
+endif
+
+sprdbt_tty-objs := \
+	tty.o \
+	rfkill.o \
+	woble.o\
+	alignment/sitm.o
+
+obj-$(CONFIG_TTY_OVERY_SDIO) += sprdbt_tty.o
+
diff --git a/drivers/net/wireless/uwe5622/tty-sdio/alignment/sitm.c b/drivers/net/wireless/uwe5622/tty-sdio/alignment/sitm.c
new file mode 100644
index 000000000000..3506fb0692db
--- /dev/null
+++ b/drivers/net/wireless/uwe5622/tty-sdio/alignment/sitm.c
@@ -0,0 +1,166 @@
+/*
+ * Copyright (C) 2016 Spreadtrum Communications Inc.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include <linux/slab.h>
+#include <linux/kfifo.h>
+#include "sitm.h"
+
+
+static const uint8_t preamble_sizes[] = {
+	HCI_COMMAND_PREAMBLE_SIZE,
+	HCI_ACL_PREAMBLE_SIZE,
+	HCI_SCO_PREAMBLE_SIZE,
+	HCI_EVENT_PREAMBLE_SIZE
+};
+
+static struct packet_receive_data_t *rd;
+
+int sitm_ini(void)
+{
+	rd = kmalloc(sizeof(struct packet_receive_data_t),
+		GFP_KERNEL);
+	memset(rd, 0, sizeof(struct packet_receive_data_t));
+	if (kfifo_alloc(&rd->fifo,
+		HCI_HAL_SERIAL_BUFFER_SIZE, GFP_KERNEL)) {
+		pr_err("no memory for sitm ring buf");
+	}
+	return 0;
+}
+
+int sitm_cleanup(void)
+{
+	kfifo_free(&rd->fifo);
+	kfree(rd);
+	rd = NULL;
+	return 0;
+}
+
+
+
+static int data_ready(uint8_t *buf, uint32_t count)
+{
+	int ret = kfifo_out(&rd->fifo, buf, count);
+	return ret;
+}
+
+void parse_frame(data_ready_cb data_ready, frame_complete_cb frame_complete)
+{
+	uint8_t byte;
+	size_t buffer_size, bytes_read;
+
+	while (data_ready(&byte, 1) == 1) {
+		switch (rd->state) {
+		case BRAND_NEW:
+			if (byte > DATA_TYPE_EVENT
+				|| byte < DATA_TYPE_COMMAND) {
+				pr_err("unknown head: 0x%02x\n", byte);
+				break;
+			}
+			rd->type = byte;
+			rd->bytes_remaining =
+				preamble_sizes[PACKET_TYPE_TO_INDEX(rd->type)]
+				+ 1;
+			memset(rd->preamble, 0, PREAMBLE_BUFFER_SIZE);
+			rd->index = 0;
+			rd->state = PREAMBLE;
+		case PREAMBLE:
+			rd->preamble[rd->index] = byte;
+			rd->index++;
+			rd->bytes_remaining--;
+
+			if (rd->bytes_remaining == 0) {
+				rd->bytes_remaining =
+					(rd->type == DATA_TYPE_ACL) ?
+					RETRIEVE_ACL_LENGTH(rd->preamble)
+					: byte;
+				buffer_size = rd->index
+					+ rd->bytes_remaining;
+				memcpy(rd->buffer,
+					rd->preamble,
+					rd->index);
+				rd->state =
+					rd->bytes_remaining > 0 ?
+					BODY : FINISHED;
+			}
+			break;
+		case BODY:
+			rd->buffer[rd->index] = byte;
+			rd->index++;
+			rd->bytes_remaining--;
+			bytes_read = data_ready((rd->buffer
+				+ rd->index),
+				rd->bytes_remaining);
+			rd->index += bytes_read;
+			rd->bytes_remaining -= bytes_read;
+			rd->state =
+				rd->bytes_remaining == 0 ?
+				FINISHED : rd->state;
+			break;
+		case IGNORE:
+			pr_err("PARSE IGNORE\n");
+			rd->bytes_remaining--;
+			if (rd->bytes_remaining == 0) {
+				rd->state = BRAND_NEW;
+				return;
+			}
+			break;
+		case FINISHED:
+			pr_err("%s state.\n", __func__);
+			break;
+		default:
+			pr_err("PARSE DEFAULT\n");
+			break;
+		}
+
+		if (rd->state == FINISHED) {
+			if (rd->type == DATA_TYPE_COMMAND
+				|| rd->type == DATA_TYPE_ACL) {
+				uint32_t tail = BYTE_ALIGNMENT
+					- ((rd->index
+					+ BYTE_ALIGNMENT)
+					% BYTE_ALIGNMENT);
+
+				while (tail--)
+					rd->buffer[rd->index++] = 0;
+			}
+			frame_complete(rd->buffer,
+				rd->index);
+			rd->state = BRAND_NEW;
+		}
+	}
+}
+
+int sitm_write(const uint8_t *buf, int count, frame_complete_cb frame_complete)
+{
+	int ret;
+
+	if (!rd) {
+		pr_err("hci fifo no memory\n");
+		return count;
+	}
+
+	ret = kfifo_avail(&rd->fifo);
+	if (ret == 0) {
+		pr_err("hci fifo no memory\n");
+		return ret;
+	} else if (ret < count) {
+		pr_err("hci fifo low memory\n");
+		count = ret;
+	}
+
+	kfifo_in(&rd->fifo, buf, count);
+	parse_frame(data_ready, frame_complete);
+	return count;
+}
+
+
diff --git a/drivers/net/wireless/uwe5622/tty-sdio/alignment/sitm.h b/drivers/net/wireless/uwe5622/tty-sdio/alignment/sitm.h
new file mode 100644
index 000000000000..5cad2607f35d
--- /dev/null
+++ b/drivers/net/wireless/uwe5622/tty-sdio/alignment/sitm.h
@@ -0,0 +1,52 @@
+#ifndef __SITM_H
+#define __SITM_H
+
+#include <linux/types.h>
+#include <linux/kfifo.h>
+
+#define PREAMBLE_BUFFER_SIZE 5
+#define PACKET_TYPE_TO_INDEX(type) ((type) - 1)
+#define HCI_COMMAND_PREAMBLE_SIZE 3
+#define HCI_ACL_PREAMBLE_SIZE 4
+#define HCI_SCO_PREAMBLE_SIZE 3
+#define HCI_EVENT_PREAMBLE_SIZE 2
+#define RETRIEVE_ACL_LENGTH(preamble) \
+	((((preamble)[4] & 0xFFFF) << 8) | (preamble)[3])
+#define HCI_HAL_SERIAL_BUFFER_SIZE 1026
+
+#define BYTE_ALIGNMENT 4
+
+enum receive_state_t {
+	BRAND_NEW,
+	PREAMBLE,
+	BODY,
+	IGNORE,
+	FINISHED
+};
+
+enum serial_data_type_t {
+	DATA_TYPE_COMMAND = 1,
+	DATA_TYPE_ACL     = 2,
+	DATA_TYPE_SCO     = 3,
+	DATA_TYPE_EVENT   = 4
+};
+
+
+struct packet_receive_data_t {
+	enum receive_state_t state;
+	uint16_t bytes_remaining;
+	uint8_t type;
+	uint8_t preamble[PREAMBLE_BUFFER_SIZE];
+	uint16_t index;
+	struct kfifo fifo;
+	uint8_t buffer[HCI_HAL_SERIAL_BUFFER_SIZE + BYTE_ALIGNMENT];
+};
+
+typedef int (*frame_complete_cb)(uint8_t *data, size_t len);
+typedef int (*data_ready_cb)(uint8_t *data, uint32_t len);
+
+
+int sitm_write(const uint8_t *buf, int count, frame_complete_cb frame_complete);
+int sitm_ini(void);
+int sitm_cleanup(void);
+#endif
diff --git a/drivers/net/wireless/uwe5622/tty-sdio/rfkill.c b/drivers/net/wireless/uwe5622/tty-sdio/rfkill.c
new file mode 100644
index 000000000000..66ce926033e9
--- /dev/null
+++ b/drivers/net/wireless/uwe5622/tty-sdio/rfkill.c
@@ -0,0 +1,84 @@
+/*
+ * Copyright (C) 2015 Spreadtrum Communications Inc.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include <linux/kernel.h>
+#include <linux/delay.h>
+#include <linux/device.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/rfkill.h>
+#include <linux/gpio.h>
+#include <linux/ioport.h>
+#include <linux/clk.h>
+#include <linux/of_gpio.h>
+#include <linux/version.h>
+#include <marlin_platform.h>
+
+
+static struct rfkill *bt_rfk;
+static const char bt_name[] = "bluetooth";
+
+static int bluetooth_set_power(void *data, bool blocked)
+{
+	pr_info("%s: start_block=%d\n", __func__, blocked);
+	if (!blocked)
+		start_marlin(MARLIN_BLUETOOTH);
+	else
+		stop_marlin(MARLIN_BLUETOOTH);
+
+	pr_info("%s: end_block=%d\n", __func__, blocked);
+	return 0;
+}
+
+static struct rfkill_ops rfkill_bluetooth_ops = {
+	.set_block = bluetooth_set_power,
+};
+
+int rfkill_bluetooth_init(struct platform_device *pdev)
+{
+
+	int rc = 0;
+
+	pr_info("-->%s\n", __func__);
+	bt_rfk = rfkill_alloc(bt_name, &pdev->dev, RFKILL_TYPE_BLUETOOTH,
+			&rfkill_bluetooth_ops, NULL);
+	if (!bt_rfk) {
+		rc = -ENOMEM;
+		goto err_rfkill_alloc;
+	}
+	/* userspace cannot take exclusive control */
+	rfkill_init_sw_state(bt_rfk, true);
+	rc = rfkill_register(bt_rfk);
+	if (rc)
+		goto err_rfkill_reg;
+
+	pr_info("<--%s\n", __func__);
+
+	return 0;
+
+err_rfkill_reg:
+	rfkill_destroy(bt_rfk);
+err_rfkill_alloc:
+	return rc;
+}
+
+int rfkill_bluetooth_remove(struct platform_device *dev)
+{
+	pr_info("-->%s\n", __func__);
+	rfkill_unregister(bt_rfk);
+	rfkill_destroy(bt_rfk);
+	pr_info("<--%s\n", __func__);
+	return 0;
+}
+
+
diff --git a/drivers/net/wireless/uwe5622/tty-sdio/rfkill.h b/drivers/net/wireless/uwe5622/tty-sdio/rfkill.h
new file mode 100644
index 000000000000..d092996a563c
--- /dev/null
+++ b/drivers/net/wireless/uwe5622/tty-sdio/rfkill.h
@@ -0,0 +1,25 @@
+/*
+ * Copyright (C) 2016 Spreadtrum Communications Inc.
+ *
+ * Filename : marlin_rfkill.h
+ * Abstract : This file is a implementation for itm sipc command/event function
+ *
+ * Authors	: yufeng.yang
+ *
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+#ifndef __MARLIN_RFKILL_H__
+#define __MARLIN_RFILL_H__
+
+int rfkill_bluetooth_init(struct platform_device *pdev);
+int rfkill_bluetooth_remove(struct platform_device *pdev);
+
+#endif
diff --git a/drivers/net/wireless/uwe5622/tty-sdio/tty.c b/drivers/net/wireless/uwe5622/tty-sdio/tty.c
new file mode 100644
index 000000000000..50d81e7cb799
--- /dev/null
+++ b/drivers/net/wireless/uwe5622/tty-sdio/tty.c
@@ -0,0 +1,706 @@
+/*
+ * Copyright (C) 2015 Spreadtrum Communications Inc.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/slab.h>
+#include <linux/types.h>
+#include <linux/kdev_t.h>
+#include <linux/tty.h>
+#include <linux/vt_kern.h>
+#include <linux/init.h>
+#include <linux/console.h>
+#include <linux/delay.h>
+#include <linux/semaphore.h>
+#include <linux/vmalloc.h>
+#include <linux/atomic.h>
+#ifdef CONFIG_OF
+#include <linux/of_device.h>
+#endif
+#include <linux/compat.h>
+#include <linux/tty_flip.h>
+#include <linux/kthread.h>
+#include <linux/interrupt.h>
+#include <linux/workqueue.h>
+#include <linux/version.h>
+
+#include <marlin_platform.h>
+#include "tty.h"
+#include "rfkill.h"
+#include "woble.h"
+#include "alignment/sitm.h"
+
+static unsigned int log_level = MTTY_LOG_LEVEL_NONE;
+
+#define BT_VER(fmt, ...)						\
+	do {										\
+		if (log_level == MTTY_LOG_LEVEL_VER)	\
+			pr_err(fmt, ##__VA_ARGS__);			\
+	} while (0)
+
+
+static struct semaphore sem_id;
+
+struct rx_data {
+	unsigned int channel;
+	struct mbuf_t *head;
+	struct mbuf_t *tail;
+	unsigned int num;
+	struct list_head entry;
+};
+
+struct mtty_device {
+	struct mtty_init_data   *pdata;
+	struct tty_port *port;
+	struct tty_struct   *tty;
+	struct tty_driver   *driver;
+
+	/* mtty state */
+	atomic_t state;
+	/*spinlock_t    rw_lock;*/
+	struct mutex    rw_mutex;
+	struct list_head rx_head;
+	/*struct tasklet_struct rx_task;*/
+	struct work_struct bt_rx_work;
+	struct workqueue_struct *bt_rx_workqueue;
+};
+
+static struct mtty_device *mtty_dev;
+static unsigned int que_task = 1;
+static int que_sche = 1;
+
+static void hex_dump(unsigned char *bin, size_t binsz)
+{
+	char *str, hex_str[] = "0123456789ABCDEF";
+	size_t i;
+
+	str = (char *)vmalloc(binsz * 3);
+	if (!str) {
+		return;
+	}
+
+	for (i = 0; i < binsz; i++) {
+		str[(i * 3) + 0] = hex_str[(bin[i] >> 4) & 0x0F];
+		str[(i * 3) + 1] = hex_str[(bin[i]) & 0x0F];
+		str[(i * 3) + 2] = ' ';
+	}
+	str[(binsz * 3) - 1] = 0x00;
+	pr_info("%s\n", str);
+	vfree(str);
+}
+
+static void hex_dump_block(unsigned char *bin, size_t binsz)
+{
+#define HEX_DUMP_BLOCK_SIZE 20
+	int loop = binsz / HEX_DUMP_BLOCK_SIZE;
+	int tail = binsz % HEX_DUMP_BLOCK_SIZE;
+	int i;
+
+	if (!loop) {
+		hex_dump(bin, binsz);
+		return;
+	}
+
+	for (i = 0; i < loop; i++) {
+		hex_dump(bin + i * HEX_DUMP_BLOCK_SIZE, HEX_DUMP_BLOCK_SIZE);
+	}
+
+	if (tail)
+		hex_dump(bin + i * HEX_DUMP_BLOCK_SIZE, tail);
+}
+
+/* static void mtty_rx_task(unsigned long data) */
+static void mtty_rx_work_queue(struct work_struct *work)
+{
+	int i, ret = 0;
+	/*struct mtty_device *mtty = (struct mtty_device *)data;*/
+	struct mtty_device *mtty;
+	struct rx_data *rx = NULL;
+
+	que_task = que_task + 1;
+	if (que_task > 65530)
+		que_task = 0;
+	pr_info("mtty que_task= %d\n", que_task);
+	que_sche = que_sche - 1;
+
+	mtty = container_of(work, struct mtty_device, bt_rx_work);
+	if (unlikely(!mtty)) {
+		pr_err("mtty_rx_task mtty is NULL\n");
+		return;
+	}
+
+	if (atomic_read(&mtty->state) == MTTY_STATE_OPEN) {
+		do {
+			mutex_lock(&mtty->rw_mutex);
+			if (list_empty_careful(&mtty->rx_head)) {
+				pr_err("mtty over load queue done\n");
+				mutex_unlock(&mtty->rw_mutex);
+				break;
+			}
+			rx = list_first_entry_or_null(&mtty->rx_head,
+				struct rx_data, entry);
+			if (!rx) {
+				pr_err("mtty over load queue abort\n");
+				mutex_unlock(&mtty->rw_mutex);
+				break;
+			}
+			list_del(&rx->entry);
+			mutex_unlock(&mtty->rw_mutex);
+
+			pr_err("mtty over load working at channel: %d, len: %d\n",
+					rx->channel, rx->head->len);
+			for (i = 0; i < rx->head->len; i++) {
+				ret = tty_insert_flip_char(mtty->port,
+						*(rx->head->buf+i), TTY_NORMAL);
+				if (ret != 1) {
+					i--;
+					continue;
+				} else {
+					tty_flip_buffer_push(mtty->port);
+				}
+			}
+			pr_err("mtty over load cut channel: %d\n", rx->channel);
+			kfree(rx->head->buf);
+			kfree(rx);
+
+		} while (1);
+	} else {
+		pr_info("mtty status isn't open, status:%d\n", atomic_read(&mtty->state));
+	}
+}
+
+static int mtty_rx_cb(int chn, struct mbuf_t *head, struct mbuf_t *tail, int num)
+{
+	int ret = 0, block_size;
+	struct rx_data *rx;
+
+	//bt_wakeup_host();
+	block_size = ((head->buf[2] & 0x7F) << 9) + (head->buf[1] << 1) + (head->buf[0] >> 7);
+
+	if (log_level == MTTY_LOG_LEVEL_VER) {
+		BT_VER("%s dump head: %d, channel: %d, num: %d\n", __func__, BT_SDIO_HEAD_LEN, chn, num);
+		hex_dump_block((unsigned char *)head->buf, BT_SDIO_HEAD_LEN);
+		BT_VER("%s dump block %d\n", __func__, block_size);
+		hex_dump_block((unsigned char *)head->buf + BT_SDIO_HEAD_LEN, block_size);
+	}
+
+	woble_data_recv((unsigned char *)head->buf + BT_SDIO_HEAD_LEN, block_size);
+
+	if (atomic_read(&mtty_dev->state) == MTTY_STATE_CLOSE) {
+		pr_err("%s mtty bt is closed abnormally\n", __func__);
+		sprdwcn_bus_push_list(chn, head, tail, num);
+		return -1;
+	}
+
+	if (mtty_dev != NULL) {
+		if (!work_pending(&mtty_dev->bt_rx_work)) {
+			BT_VER("%s tty_insert_flip_string", __func__);
+			ret = tty_insert_flip_string(mtty_dev->port,
+				(unsigned char *)head->buf + BT_SDIO_HEAD_LEN,
+				block_size);   // -BT_SDIO_HEAD_LEN
+			BT_VER("%s ret: %d, len: %d\n", __func__, ret, block_size);
+			if (ret)
+				tty_flip_buffer_push(mtty_dev->port);
+			if (ret == (block_size)) {
+				BT_VER("%s send success", __func__);
+				sprdwcn_bus_push_list(chn, head, tail, num);
+				return 0;
+			}
+		}
+
+		rx = kmalloc(sizeof(struct rx_data), GFP_KERNEL);
+		if (rx == NULL) {
+			pr_err("%s rx == NULL\n", __func__);
+			sprdwcn_bus_push_list(chn, head, tail, num);
+			return -ENOMEM;
+		}
+
+		rx->head = head;
+		rx->tail = tail;
+		rx->channel = chn;
+		rx->num = num;
+		rx->head->len = (block_size) - ret;
+		rx->head->buf = kmalloc(rx->head->len, GFP_KERNEL);
+		if (rx->head->buf == NULL) {
+			pr_err("mtty low memory!\n");
+			kfree(rx);
+			sprdwcn_bus_push_list(chn, head, tail, num);
+			return -ENOMEM;
+		}
+
+		memcpy(rx->head->buf, (unsigned char *)head->buf + BT_SDIO_HEAD_LEN + ret, rx->head->len);
+		sprdwcn_bus_push_list(chn, head, tail, num);
+		mutex_lock(&mtty_dev->rw_mutex);
+		pr_err("mtty over load push %d -> %d, channel: %d len: %d\n",
+			block_size, ret, rx->channel, rx->head->len);
+		list_add_tail(&rx->entry, &mtty_dev->rx_head);
+		mutex_unlock(&mtty_dev->rw_mutex);
+		if (!work_pending(&mtty_dev->bt_rx_work)) {
+			pr_err("work_pending\n");
+			queue_work(mtty_dev->bt_rx_workqueue,
+				&mtty_dev->bt_rx_work);
+		}
+		return 0;
+	}
+	pr_err("mtty_rx_cb mtty_dev is NULL!!!\n");
+
+	return -1;
+}
+
+static int mtty_tx_cb(int chn, struct mbuf_t *head, struct mbuf_t *tail, int num)
+{
+	int i;
+	struct mbuf_t *pos = NULL;
+	BT_VER("%s channel: %d, head: %p, tail: %p num: %d\n", __func__, chn, head, tail, num);
+	pos = head;
+	for (i = 0; i < num; i++, pos = pos->next) {
+		kfree(pos->buf);
+		pos->buf = NULL;
+	}
+	if ((sprdwcn_bus_list_free(chn, head, tail, num)) == 0) {
+		BT_VER("%s sprdwcn_bus_list_free() success\n", __func__);
+		up(&sem_id);
+	} else
+		pr_err("%s sprdwcn_bus_list_free() fail\n", __func__);
+
+	return 0;
+}
+
+static int mtty_open(struct tty_struct *tty, struct file *filp)
+{
+	struct mtty_device *mtty = NULL;
+	struct tty_driver *driver = NULL;
+	if (tty == NULL) {
+		pr_err("mtty open input tty is NULL!\n");
+		return -ENOMEM;
+	}
+	driver = tty->driver;
+	mtty = (struct mtty_device *)driver->driver_state;
+
+	if (mtty == NULL) {
+		pr_err("mtty open input mtty NULL!\n");
+		return -ENOMEM;
+	}
+
+	mtty->tty = tty;
+	tty->driver_data = (void *)mtty;
+
+	atomic_set(&mtty->state, MTTY_STATE_OPEN);
+	que_task = 0;
+	que_sche = 0;
+	sitm_ini();
+	pr_info("mtty_open device success!\n");
+	return 0;
+}
+
+static void mtty_close(struct tty_struct *tty, struct file *filp)
+{
+	struct mtty_device *mtty = NULL;
+
+	if (tty == NULL) {
+		pr_err("mtty close input tty is NULL!\n");
+		return;
+	}
+	mtty = (struct mtty_device *) tty->driver_data;
+	if (mtty == NULL) {
+		pr_err("mtty close s tty is NULL!\n");
+		return;
+	}
+
+	atomic_set(&mtty->state, MTTY_STATE_CLOSE);
+	sitm_cleanup();
+
+	pr_info("mtty_close device success !\n");
+}
+
+static int mtty_write(struct tty_struct *tty,
+		const unsigned char *buf, int count)
+{
+	int num = 1, ret;
+	struct mbuf_t *tx_head = NULL, *tx_tail = NULL;
+	unsigned char *block = NULL;
+
+	BT_VER("%s +++\n", __func__);
+
+	if (log_level == MTTY_LOG_LEVEL_VER) {
+		BT_VER("%s dump size: %d\n", __func__, count);
+		hex_dump_block((unsigned char *)buf, count);
+	}
+
+	block = kmalloc(count + BT_SDIO_HEAD_LEN, GFP_KERNEL);
+
+	if (!block) {
+		pr_err("%s kmalloc failed\n", __func__);
+		return -ENOMEM;
+	}
+	memset(block, 0, count + BT_SDIO_HEAD_LEN);
+	memcpy(block + BT_SDIO_HEAD_LEN, buf, count);
+	down(&sem_id);
+	ret = sprdwcn_bus_list_alloc(BT_TX_CHANNEL, &tx_head, &tx_tail, &num);
+	if (ret) {
+		pr_err("%s sprdwcn_bus_list_alloc failed: %d\n", __func__, ret);
+		up(&sem_id);
+		kfree(block);
+		block = NULL;
+		return -ENOMEM;
+	}
+	tx_head->buf = block;
+	tx_head->len = count;
+	tx_head->next = NULL;
+
+	ret = sprdwcn_bus_push_list(BT_TX_CHANNEL, tx_head, tx_tail, num);
+	if (ret) {
+		pr_err("%s sprdwcn_bus_push_list failed: %d\n", __func__, ret);
+		kfree(tx_head->buf);
+		tx_head->buf = NULL;
+		sprdwcn_bus_list_free(BT_TX_CHANNEL, tx_head, tx_tail, num);
+		return -EBUSY;
+	}
+
+	BT_VER("%s ---\n", __func__);
+	return count;
+}
+
+static  int sdio_data_transmit(uint8_t *data, size_t count)
+{
+	return mtty_write(NULL, data, count);
+}
+
+static int mtty_write_plus(struct tty_struct *tty,
+		  const unsigned char *buf, int count)
+{
+	return sitm_write(buf, count, sdio_data_transmit);
+}
+
+static void mtty_flush_chars(struct tty_struct *tty)
+{
+}
+
+static unsigned int mtty_write_room(struct tty_struct *tty)
+{
+	return UINT_MAX;
+}
+
+static const struct tty_operations mtty_ops = {
+	.open  = mtty_open,
+	.close = mtty_close,
+	.write = mtty_write_plus,
+	.flush_chars = mtty_flush_chars,
+	.write_room  = mtty_write_room,
+};
+
+static struct tty_port *mtty_port_init(void)
+{
+	struct tty_port *port = NULL;
+
+	port = kzalloc(sizeof(struct tty_port), GFP_KERNEL);
+	if (port == NULL)
+		return NULL;
+	tty_port_init(port);
+
+	return port;
+}
+
+static int mtty_tty_driver_init(struct mtty_device *device)
+{
+	struct tty_driver *driver;
+	int ret = 0;
+
+	device->port = mtty_port_init();
+	if (!device->port)
+		return -ENOMEM;
+
+	driver = tty_alloc_driver(MTTY_DEV_MAX_NR * 2, 0);
+	if (!IS_ERR(driver))
+		return -ENOMEM;
+
+	/*
+	* Initialize the tty_driver structure
+	* Entries in mtty_driver that are NOT initialized:
+	* proc_entry, set_termios, flush_buffer, set_ldisc, write_proc
+	*/
+	driver->owner = THIS_MODULE;
+	driver->driver_name = device->pdata->name;
+	driver->name = device->pdata->name;
+	driver->major = 0;
+	driver->type = TTY_DRIVER_TYPE_SYSTEM;
+	driver->subtype = SYSTEM_TYPE_TTY;
+	driver->init_termios = tty_std_termios;
+	driver->driver_state = (void *)device;
+	device->driver = driver;
+	device->driver->flags = TTY_DRIVER_REAL_RAW;
+	/* initialize the tty driver */
+	tty_set_operations(driver, &mtty_ops);
+	tty_port_link_device(device->port, driver, 0);
+	ret = tty_register_driver(driver);
+	if (ret) {
+		tty_driver_kref_put(driver);
+		tty_port_destroy(device->port);
+		return ret;
+	}
+	return ret;
+}
+
+static void mtty_tty_driver_exit(struct mtty_device *device)
+{
+	struct tty_driver *driver = device->driver;
+
+	tty_unregister_driver(driver);
+	tty_driver_kref_put(driver);
+	tty_port_destroy(device->port);
+}
+
+__attribute__((unused))
+static int mtty_parse_dt(struct mtty_init_data **init, struct device *dev)
+{
+#ifdef CONFIG_OF
+	struct device_node *np = dev->of_node;
+	struct mtty_init_data *pdata = NULL;
+	int ret;
+
+	pdata = kzalloc(sizeof(struct mtty_init_data), GFP_KERNEL);
+	if (!pdata)
+	return -ENOMEM;
+
+	ret = of_property_read_string(np,
+		"sprd,name",
+		(const char **)&pdata->name);
+	if (ret)
+	goto error;
+	*init = pdata;
+
+	return 0;
+error:
+	kfree(pdata);
+	*init = NULL;
+	return ret;
+#else
+	return -ENODEV;
+#endif
+}
+
+static inline void mtty_destroy_pdata(struct mtty_init_data **init)
+{
+#if (defined CONFIG_OF)
+	struct mtty_init_data *pdata = *init;
+
+	kfree(pdata);
+
+	*init = NULL;
+#endif
+}
+
+static int bt_tx_powerchange(int channel, int is_resume)
+{
+	unsigned long power_state = marlin_get_power_state();
+	pr_info("%s is_resume =%d", __func__, is_resume);
+	if (test_bit(MARLIN_BLUETOOTH, &power_state)) {
+		if (!is_resume) {
+			hci_set_ap_sleep_mode(WOBLE_IS_NOT_SHUTDOWN, WOBLE_IS_NOT_RESUME);
+			hci_set_ap_start_sleep();
+		}
+		if (is_resume) {
+			hci_set_ap_sleep_mode(WOBLE_IS_NOT_SHUTDOWN, WOBLE_IS_RESUME);
+		}
+	}
+
+	return 0;
+}
+
+struct mchn_ops_t bt_rx_ops = {
+	.channel = BT_RX_CHANNEL,
+	.hif_type = HW_TYPE_SDIO,
+	.inout = BT_RX_INOUT,
+	.pool_size = BT_RX_POOL_SIZE,
+	.pop_link = mtty_rx_cb,
+};
+
+struct mchn_ops_t bt_tx_ops = {
+	.channel = BT_TX_CHANNEL,
+	.hif_type = HW_TYPE_SDIO,
+	.inout = BT_TX_INOUT,
+	.pool_size = BT_TX_POOL_SIZE,
+	.pop_link = mtty_tx_cb,
+	.power_notify = bt_tx_powerchange,
+};
+
+static int  mtty_probe(struct platform_device *pdev)
+{
+	struct mtty_init_data *pdata = (struct mtty_init_data *)
+					pdev->dev.platform_data;
+	struct mtty_device *mtty;
+	int rval = 0;
+
+	if (pdev->dev.of_node && !pdata) {
+		rval = mtty_parse_dt(&pdata, &pdev->dev);
+		if (rval) {
+			pr_err("failed to parse mtty device tree, ret=%d\n",
+					rval);
+			return rval;
+		}
+	}
+
+	mtty = kzalloc(sizeof(struct mtty_device), GFP_KERNEL);
+	if (mtty == NULL) {
+		mtty_destroy_pdata(&pdata);
+		pr_err("mtty Failed to allocate device!\n");
+		return -ENOMEM;
+	}
+
+	mtty->pdata = pdata;
+	rval = mtty_tty_driver_init(mtty);
+	if (rval) {
+		mtty_tty_driver_exit(mtty);
+		kfree(mtty->port);
+		kfree(mtty);
+		mtty_destroy_pdata(&pdata);
+		pr_err("regitster notifier failed (%d)\n", rval);
+		return rval;
+	}
+
+	pr_info("mtty_probe init device addr: 0x%p\n", mtty);
+	platform_set_drvdata(pdev, mtty);
+
+	/*spin_lock_init(&mtty->rw_lock);*/
+	atomic_set(&mtty->state, MTTY_STATE_CLOSE);
+	mutex_init(&mtty->rw_mutex);
+	INIT_LIST_HEAD(&mtty->rx_head);
+	/*tasklet_init(&mtty->rx_task, mtty_rx_task, (unsigned long)mtty);*/
+	mtty->bt_rx_workqueue =
+	create_singlethread_workqueue("SPRDBT_RX_QUEUE");
+	if (!mtty->bt_rx_workqueue) {
+		pr_err("%s SPRDBT_RX_QUEUE create failed", __func__);
+		return -ENOMEM;
+	}
+	INIT_WORK(&mtty->bt_rx_work, mtty_rx_work_queue);
+
+	mtty_dev = mtty;
+
+	rfkill_bluetooth_init(pdev);
+	woble_init();
+	sprdwcn_bus_chn_init(&bt_rx_ops);
+	sprdwcn_bus_chn_init(&bt_tx_ops);
+	sema_init(&sem_id, BT_TX_POOL_SIZE - 1);
+
+	return 0;
+}
+
+int marlin_sdio_write(const unsigned char *buf, int count)
+{
+	int num = 1, ret;
+	struct mbuf_t *tx_head = NULL, *tx_tail = NULL;
+	unsigned char *block = NULL, *tmp_buf = (unsigned char *)buf + 1;
+	unsigned short op = 0;
+
+	STREAM_TO_UINT16(op, tmp_buf);
+
+	if (buf[0] == 0x1) {
+		pr_info("%s +++ op 0x%04X\n", __func__, op);
+	}
+
+	block = kmalloc(count + BT_SDIO_HEAD_LEN, GFP_KERNEL);
+
+	if (!block) {
+		pr_err("%s kmalloc failed\n", __func__);
+		return -ENOMEM;
+	}
+
+	if (log_level == MTTY_LOG_LEVEL_VER) {
+		pr_info("%s dump size: %d\n", __func__, count);
+		hex_dump_block((unsigned char *)buf, count);
+	}
+
+	memset(block, 0, count + BT_SDIO_HEAD_LEN);
+	memcpy(block + BT_SDIO_HEAD_LEN, buf, count);
+
+	down(&sem_id);
+	ret = sprdwcn_bus_list_alloc(BT_TX_CHANNEL, &tx_head, &tx_tail, &num);
+
+	if (ret) {
+		pr_err("%s sprdwcn_bus_list_alloc failed: %d\n", __func__, ret);
+		up(&sem_id);
+		kfree(block);
+		block = NULL;
+		return -ENOMEM;
+	}
+
+	tx_head->buf = block;
+	tx_head->len = count;
+	tx_head->next = NULL;
+
+	ret = sprdwcn_bus_push_list(BT_TX_CHANNEL, tx_head, tx_tail, num);
+
+	if (ret) {
+		pr_err("%s sprdwcn_bus_push_list failed: %d\n", __func__, ret);
+		kfree(tx_head->buf);
+		tx_head->buf = NULL;
+		sprdwcn_bus_list_free(BT_TX_CHANNEL, tx_head, tx_tail, num);
+		return -EBUSY;
+	}
+
+	BT_VER("%s ---\n", __func__);
+
+	return count;
+}
+
+static void  mtty_shutdown(struct platform_device *pdev)
+{
+	unsigned long int power_state = marlin_get_power_state();
+	pr_info("%s ---\n", __func__);
+	if (test_bit(MARLIN_BLUETOOTH, &power_state)) {
+		pr_info("set bluetooth into sleep mode\n");
+		hci_set_ap_sleep_mode(1, 0);
+		hci_set_ap_start_sleep();
+	}
+	return;
+}
+
+static int  mtty_remove(struct platform_device *pdev)
+{
+	struct mtty_device *mtty = platform_get_drvdata(pdev);
+
+	mtty_tty_driver_exit(mtty);
+	sprdwcn_bus_chn_deinit(&bt_rx_ops);
+	sprdwcn_bus_chn_deinit(&bt_tx_ops);
+	kfree(mtty->port);
+	mtty_destroy_pdata(&mtty->pdata);
+	flush_workqueue(mtty->bt_rx_workqueue);
+	destroy_workqueue(mtty->bt_rx_workqueue);
+	/*tasklet_kill(&mtty->rx_task);*/
+	kfree(mtty);
+	platform_set_drvdata(pdev, NULL);
+
+	return 0;
+}
+
+static const struct of_device_id mtty_match_table[] = {
+	{ .compatible = "sprd,mtty", },
+	{ },
+};
+
+static struct platform_driver mtty_driver = {
+	.driver = {
+		.owner = THIS_MODULE,
+		.name = "mtty",
+		.of_match_table = mtty_match_table,
+	},
+	.probe = mtty_probe,
+	.remove = mtty_remove,
+	.shutdown = mtty_shutdown,
+};
+
+module_platform_driver(mtty_driver);
+
+MODULE_AUTHOR("Unisoc wcn bt");
+MODULE_DESCRIPTION("Unisoc marlin tty driver");
diff --git a/drivers/net/wireless/uwe5622/tty-sdio/tty.h b/drivers/net/wireless/uwe5622/tty-sdio/tty.h
new file mode 100644
index 000000000000..7306fa14e19c
--- /dev/null
+++ b/drivers/net/wireless/uwe5622/tty-sdio/tty.h
@@ -0,0 +1,44 @@
+/*
+ * Copyright (C) 2015 Spreadtrum Communications Inc.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#ifndef __MTTY_H
+#define __MTTY_H
+
+#include <wcn_bus.h>
+
+enum mtty_state {
+	MTTY_STATE_CLOSE,
+	MTTY_STATE_OPEN
+};
+
+enum mtty_log_level {
+	MTTY_LOG_LEVEL_NONE,
+	MTTY_LOG_LEVEL_VER,
+};
+
+struct mtty_init_data {
+    char *name;
+};
+
+#define MTTY_DEV_MAX_NR     1
+#define BT_TX_CHANNEL       3
+//#define BT_TX_CHANNEL1    4
+#define BT_RX_CHANNEL       17
+#define BT_TX_INOUT         1
+#define BT_RX_INOUT         0
+#define BT_TX_POOL_SIZE     64  // the max buffer is 64
+#define BT_RX_POOL_SIZE     1
+#define BT_SDIO_HEAD_LEN    4
+
+int marlin_sdio_write(const unsigned char *buf, int count);
+#endif
diff --git a/drivers/net/wireless/uwe5622/tty-sdio/woble.c b/drivers/net/wireless/uwe5622/tty-sdio/woble.c
new file mode 100644
index 000000000000..10ed19a3342c
--- /dev/null
+++ b/drivers/net/wireless/uwe5622/tty-sdio/woble.c
@@ -0,0 +1,168 @@
+/*
+ * btif_woble.c
+ *
+ *  Created on: 2020
+ *      Author: Unisoc
+ */
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/slab.h>
+#include <linux/types.h>
+#include <linux/kdev_t.h>
+#include <linux/tty.h>
+#include <linux/vt_kern.h>
+#include <linux/init.h>
+#include <linux/console.h>
+#include <linux/delay.h>
+#include <linux/semaphore.h>
+#include <linux/vmalloc.h>
+
+#include <linux/file.h>
+#include <linux/string.h>
+#include "woble.h"
+#include "tty.h"
+
+#define MAX_WAKE_DEVICE_MAX_NUM 36
+#define CONFIG_FILE_PATH "/data/misc/bluedroid/bt_config.conf"
+
+static struct hci_cmd_t hci_cmd;
+uint8_t device_count_db;
+const woble_config_t s_woble_config_cust = {WOBLE_MOD_ENABLE, WOBLE_SLEEP_MOD_COULD_NOT_KNOW, 0, WOBLE_SLEEP_MOD_NOT_NEED_NOTITY};
+
+mtty_bt_wake_t bt_wake_dev_db[MAX_WAKE_DEVICE_MAX_NUM];
+
+int woble_init(void)
+{
+	memset(&hci_cmd, 0, sizeof(struct hci_cmd_t));
+	sema_init(&hci_cmd.wait, 0);
+
+	return 0;
+}
+
+int woble_data_recv(const unsigned char *buf, int count)
+{
+	unsigned short opcode = 0;
+	unsigned char status = 0;
+	const unsigned char *p = 0;
+	const unsigned char *rxmsg = buf;
+	int left_length = count;
+	int pack_length = 0;
+	int last = 0;
+	int ret = -1;
+
+	if (count < 0) {
+		pr_err("%s count < 0!!!", __func__);
+	}
+
+	do {
+		rxmsg = buf + (count - left_length);
+		switch (rxmsg[PACKET_TYPE]) {
+		case HCI_EVT:
+			if (left_length < 3) {
+				pr_err("%s left_length <3 !!!!!", __func__);
+			}
+			pack_length = rxmsg[EVT_HEADER_SIZE];
+			pack_length += 3;
+
+			if (left_length - pack_length < 0) {
+				pr_err("%s left_length - pack_length <0 !!!!!", __func__);
+
+			}
+			switch (rxmsg[EVT_HEADER_EVENT]) {
+			default:
+			case BT_HCI_EVT_CMD_COMPLETE:
+				p = rxmsg + 4;
+				STREAM_TO_UINT16(opcode, p);
+				STREAM_TO_UINT8(status, p);
+				break;
+
+			case BT_HCI_EVT_CMD_STATUS:
+				p = rxmsg + 5;
+				STREAM_TO_UINT16(opcode, p);
+				status = rxmsg[3];
+				break;
+			}
+			last = left_length;
+			left_length -= pack_length;
+			break;
+		default:
+			left_length = 0;
+			break;
+		}
+	} while (left_length);
+
+	if (hci_cmd.opcode == opcode && hci_cmd.opcode) {
+		pr_info("%s opcode: 0x%04X, status: %d\n", __func__, opcode, status);
+		up(&hci_cmd.wait);
+		ret = 0;
+	}
+	return ret;
+}
+
+int hci_cmd_send_sync(unsigned short opcode, struct HC_BT_HDR *py,
+		struct HC_BT_HDR *rsp)
+{
+	unsigned char msg_req[HCI_CMD_MAX_LEN], *p;
+	int ret = 0;
+
+	p = msg_req;
+	UINT8_TO_STREAM(p, HCI_CMD);
+	UINT16_TO_STREAM(p, opcode);
+
+	if (py == NULL) {
+		UINT8_TO_STREAM(p, 0);
+	} else {
+		UINT8_TO_STREAM(p, py->len);
+		ARRAY_TO_STREAM(p, py->data, py->len);
+	}
+
+	hci_cmd.opcode = opcode;
+	ret = marlin_sdio_write(msg_req, p - msg_req);
+	if (!ret) {
+		hci_cmd.opcode = 0;
+		pr_err("%s marlin_sdio_write fail", __func__);
+		return 0;
+	}
+	down(&hci_cmd.wait);
+	hci_cmd.opcode = 0;
+
+	return 0;
+}
+
+void hci_set_ap_sleep_mode(int is_shutdown, int is_resume)
+{
+	struct HC_BT_HDR *payload = (struct HC_BT_HDR *)vmalloc(sizeof(struct HC_BT_HDR) + 3);
+	unsigned char *p;
+	p = payload->data;
+
+	payload->len = 6;
+	if (is_resume && !is_shutdown) {
+		UINT8_TO_STREAM(p, 0);
+	} else {
+		UINT8_TO_STREAM(p, s_woble_config_cust.woble_mod);
+	}
+
+	if (is_shutdown) {
+		UINT8_TO_STREAM(p, WOBLE_SLEEP_MOD_COULD_KNOW);
+	} else {
+		UINT8_TO_STREAM(p, WOBLE_SLEEP_MOD_COULD_NOT_KNOW);
+	}
+
+	UINT16_TO_STREAM(p, s_woble_config_cust.timeout);
+	UINT8_TO_STREAM(p, s_woble_config_cust.notify);
+	UINT8_TO_STREAM(p, 0);
+
+	hci_cmd_send_sync(BT_HCI_OP_SET_SLEEPMODE, payload, NULL);
+	vfree(payload);
+	return;
+}
+
+void hci_set_ap_start_sleep(void)
+{
+	struct HC_BT_HDR *payload = (struct HC_BT_HDR *)vmalloc(sizeof(struct HC_BT_HDR) + 3);
+
+	hci_cmd_send_sync(BT_HCI_OP_SET_STARTSLEEP, NULL, NULL);
+	vfree(payload);
+	return;
+}
diff --git a/drivers/net/wireless/uwe5622/tty-sdio/woble.h b/drivers/net/wireless/uwe5622/tty-sdio/woble.h
new file mode 100644
index 000000000000..e47752985036
--- /dev/null
+++ b/drivers/net/wireless/uwe5622/tty-sdio/woble.h
@@ -0,0 +1,137 @@
+/*
+ * btif_woble.h
+ *
+ *  Created on: 2020
+ *      Author: unisoc
+ */
+
+#ifndef __WOBLE_H
+#define __WOBLE_H
+
+#define HCI_CMD			0x01
+#define HCI_ACL			0x02
+#define HCI_SCO			0x03
+#define HCI_EVT			0x04
+
+#define PACKET_TYPE         0
+#define EVT_HEADER_TYPE     0
+#define EVT_HEADER_EVENT    1
+#define EVT_HEADER_SIZE     2
+#define EVT_VENDOR_CODE_LSB 3
+#define EVT_VENDOR_CODE_MSB 4
+#define EVT_LE_META_SUBEVT  3
+#define EVT_ADV_LENGTH      13
+
+#define BT_HCI_EVT_CMD_COMPLETE    0x0e
+#define BT_HCI_EVT_CMD_STATUS      0x0f
+
+#define ACL_HEADER_SIZE_LB  3
+#define ACL_HEADER_SIZE_HB  4
+#define EVT_HEADER_STATUS   4
+
+#define HCI_CMD_MAX_LEN     258
+#define BD_ADDR_LEN         6
+
+#define UINT8_TO_STREAM(p, u8)     {*(p)++ = (uint8_t)(u8); }
+#define UINT16_TO_STREAM(p, u16)   {*(p)++ = (uint8_t)(u16); *(p)++ = (uint8_t)((u16) >> 8); }
+#define ARRAY_TO_STREAM(p, a, len) {register int ijk; for (ijk = 0; ijk < len; ijk++) *(p)++ = (uint8_t) a[ijk]; }
+#define STREAM_TO_UINT8(u8, p)     {u8 = (uint8_t)(*(p)); (p) += 1; }
+#define STREAM_TO_UINT16(u16, p)   {u16 = ((uint16_t)(*(p)) + (((uint16_t)(*((p) + 1))) << 8)); (p) += 2; }
+#define BDADDR_TO_STREAM(p, a)     {register int ijk; for (ijk = 0; ijk < BD_ADDR_LEN;  ijk++) *(p)++ = (uint8_t) a[BD_ADDR_LEN - 1 - ijk]; }
+#define STREAM_TO_ARRAY(a, p, len) {register int ijk; for (ijk = 0; ijk < len; ijk++) ((uint8_t *) a)[ijk] = *p++; }
+
+#define BT_HCI_OP_RESET            0x0c03
+#define BT_HCI_OP_ENABLE           0xfca1
+#define BT_HCI_OP_WOBLE            0xfd08
+#define BT_HCI_OP_SET_SLEEPMODE    0xfd09
+#define BT_HCI_OP_ADD_WAKEUPLIST   0xfd0a
+#define BT_HCI_OP_SET_STARTSLEEP   0xfd0d
+
+#define WOBLE_DEVICES_SIZE         10
+
+struct HC_BT_HDR {
+	unsigned short event;
+	unsigned short len;
+	unsigned short offset;
+	unsigned short layer_specific;
+	unsigned char data[];
+};
+
+struct hci_cmd_t {
+	unsigned short opcode;
+	struct semaphore wait;
+	struct HC_BT_HDR response;
+};
+
+typedef enum {
+	WOBLE_MOD_DISABLE = 0,
+	WOBLE_MOD_ENABLE,
+	WOBLE_MOD_UNDEFINE = 0xff,
+} WOBLE_MOD;
+
+typedef enum {
+	WOBLE_SLEEP_MOD_COULD_KNOW = 0,
+	WOBLE_SLEEP_MOD_COULD_NOT_KNOW
+} WOBLE_SLEEP_MOD;
+
+typedef enum {
+	WOBLE_SLEEP_MOD_NOT_NEED_NOTITY = 0,
+	WOBLE_SLEEP_MOD_NEED_NOTITY,
+} WOBLE_NOFITY_MOD;
+
+typedef enum {
+	WOBLE_WAKE_MOD_ALL_ADV_DATA = (1 << 0),
+	WOBLE_WAKE_MOD_ALL_ACL_DATA = (1 << 1),
+	WOBLE_WAKE_MOD_SPECIAL_ADV_DATA = (1 << 2),
+	WOBLE_WAKE_MOD_SPECIAL_ACL_DATA = (1 << 3),
+} WOBLE_WAKE_MOD;
+
+typedef enum {
+	WOBLE_DISCONNECT_MOD_NOT = 0,
+	WOBLE_DISCONNECT_MOD_WILL
+} WOBLE_DISCONNECT_MOD;
+
+typedef enum {
+	WOBLE_ADV_WAKE_MOD_RAW_DATA = (1 << 0),
+	WOBLE_ADV_WAKE_MOD_ADTYE = (1 << 1),
+} WOBLE_ADV_WAKE_MOD;
+
+typedef enum {
+	WOBLE_IS_NOT_SHUTDOWN = 0,
+	WOBLE_IS_SHUTDOWN,
+} WOBLE_SHUTDOWN_MOD;
+
+typedef enum {
+	WOBLE_IS_NOT_RESUME = 0,
+	WOBLE_IS_RESUME,
+} WOBLE_RESUME_MOD;
+
+typedef struct {
+	uint8_t woble_mod;
+	uint8_t sleep_mod;
+	uint16_t timeout;
+	uint8_t notify;
+} woble_config_t;
+
+typedef struct mtty_bt_wake_t {
+	uint8_t addr[6];
+	char *addr_str;
+	uint8_t dev_tp;
+	char *dev_tp_str;
+	uint8_t addr_tp;
+	char *addr_tp_str;
+} mtty_bt_wake_t;
+
+int woble_init(void);
+void hci_set_ap_sleep_mode(int is_shutdown, int is_resume);
+
+int mtty_bt_str_hex(char *str, uint8_t count, char *hex);
+int mtty_bt_conf_prase(char *conf_str);
+int mtty_bt_read_conf(void);
+int woble_data_recv(const unsigned char *buf, int count);
+int hci_cmd_send_sync(unsigned short opcode, struct HC_BT_HDR *py, struct HC_BT_HDR *rsp);
+
+void hci_add_device_to_wakeup_list(mtty_bt_wake_t bt_wakeup_dev);
+void hci_set_ap_start_sleep(void);
+#endif
+
diff --git a/drivers/net/wireless/uwe5622/unisocwcn/Kconfig b/drivers/net/wireless/uwe5622/unisocwcn/Kconfig
new file mode 100644
index 000000000000..4543ab28cff3
--- /dev/null
+++ b/drivers/net/wireless/uwe5622/unisocwcn/Kconfig
@@ -0,0 +1,93 @@
+#
+# UNISOC WCN device (NEW )configuration
+#
+menu "UNISOC WCN Device Drivers(for new chip...)"
+
+config SC23XX
+	bool "SC23XX chip Support"
+	default n
+	help
+	  This is support wcn chip for spreadtrum.
+	  if you want to use 23xx series wcn chip of spreadtrum.
+	  please say "y".
+	  Thanks.
+
+config UMW2653
+	tristate "UMW2653 chip Support"
+	depends on SC23XX
+	default n
+	help
+	  This is support wcn chip for spreadtrum.
+	  If you want to use UMW2653 chip of spreadtrum.
+	  Please say "y".
+	  Thanks.
+
+config SC2342_INTEG
+	tristate "SC2342 Integrated chip Support"
+	depends on SC23XX
+	default n
+	help
+	  This is support wcn chip for spreadtrum.
+	  If you want to use sc2342 integrated chip of spreadtrum.
+	  Please say "y".
+	  Thanks.
+
+
+config SC2355
+	tristate "SC2355 chip Support"
+	depends on SC23XX
+	default n
+	help
+	  This is support wcn chip for spreadtrum.
+	  If you want to use sc2355 chip of spreadtrum.
+	  Please say "y".
+	  Thanks.
+
+config SC2366
+	tristate "SC2366 chip Support"
+	depends on SC23XX
+	default n
+	help
+	  This is support wcn chip for spreadtrum.
+	  If you want to use sc2366 chip of spreadtrum.
+	  Please say "y".
+	  Thanks.
+
+config AW_WIFI_DEVICE_UWE5622
+	bool "allwinner board Support for uwe5622"
+	default n
+	help
+	  This is support wcn chip for allwinner board.
+	  if you want to support allwinner board.
+	  please say "y".
+	  Thanks.
+
+config AW_BIND_VERIFY
+	bool "allwinner wcn bind verify"
+	depends on AW_WIFI_DEVICE_UWE5622
+	default n
+	help
+	  This is support wcn bind verify for allwinner board.
+	  if you want to do wcn chip bind verify.
+	  please say "y".
+	  Thanks.
+
+# sprd's boot driver based on SC2342-integ...,etc
+#source "drivers/misc/sprdwcn/boot/Kconfig"
+
+# sprd's gnss driver based on SC2355/2342...,etc
+#source "drivers/misc/sprdwcn/gnss/Kconfig"
+
+# sprd's SDIO device driver based on SC2355...,etc
+#source "drivers/misc/sprdwcn/sdio/Kconfig"
+
+# sprd's SIPC device driver based on SC2342 integ...,etc
+#source "drivers/misc/sprdwcn/sipc/Kconfig"
+
+# sprd's sleep device driver based on SC2355...,etc
+#source "drivers/misc/sprdwcn/sleep/Kconfig"
+
+# sprd's wcn platform driver based on SC2355/SC2342...,etc
+#source "drivers/misc/sprdwcn/platform/Kconfig"
+
+endmenu
diff --git a/drivers/net/wireless/uwe5622/unisocwcn/Makefile b/drivers/net/wireless/uwe5622/unisocwcn/Makefile
new file mode 100644
index 000000000000..b9e3d0e245a0
--- /dev/null
+++ b/drivers/net/wireless/uwe5622/unisocwcn/Makefile
@@ -0,0 +1,95 @@
+PWD := $(shell pwd)
+CURFOLDER ?= $(pwd)
+
+LD_CFLAGS += -D__linux__
+EXTRA_CFLAGS=-fno-pic
+
+all_dependencies := driver
+driver_dependencies :=
+
+ifeq ($(CONFIG_AW_WIFI_DEVICE_UWE5622),y)
+#ccflags-y += -DCONFIG_CHECK_DRIVER_BY_CHIPID
+ccflags-y += -DCONFIG_UWE5622
+BSP_CHIP_ID := uwe5622
+WCN_HW_TYPE := sdio
+endif
+
+MODULE_NAME := $(BSP_CHIP_ID)_bsp_$(WCN_HW_TYPE)
+
+ifneq ($(UNISOC_FW_PATH_CONFIG),)
+ccflags-y += -DCONFIG_CUSTOMIZE_UNISOC_FW_PATH=\"$(UNISOC_FW_PATH_CONFIG)\"
+endif
+ifneq ($(UNISOC_DBG_FILESIZE_CONFIG),)
+ccflags-y += -DCONFIG_CUSTOMIZE_UNISOC_DBG_FILESIZE=$(UNISOC_DBG_FILESIZE_CONFIG)
+endif
+ifneq ($(UNISOC_DBG_FILENUM_CONFIG),)
+ccflags-y += -DCONFIG_CUSTOMIZE_UNISOC_DBG_FILENUM=$(UNISOC_DBG_FILENUM_CONFIG)
+endif
+ifneq ($(UNISOC_DBG_PATH_CONFIG),)
+ccflags-y += -DCONFIG_CUSTOMIZE_UNISOC_DBG_PATH=\"$(UNISOC_DBG_PATH_CONFIG)\"
+endif
+
+#### add cflag ######
+ccflags-y += -DCONFIG_SDIOHAL
+ccflags-y += -DCONFIG_WCN_SLP
+ccflags-y += -DCONFIG_WCN_BOOT
+ccflags-y += -DCONFIG_WCN_UTILS
+
+#### include path ######
+ccflags-y += -I$(src)/include/
+ccflags-y += -I$(src)/platform/
+
+#### add cflag ######
+#ccflags-y += -DCONFIG_AW_BOARD
+ccflags-y += -DCONFIG_WCN_PARSE_DTS
+#ccflags-y += -DCONFIG_SDIO_TX_ADMA_MODE
+#ccflags-y += -DCONFIG_SDIO_RX_ADMA_MODE
+ccflags-y += -DCONFIG_SDIO_INBAND_INT
+#ccflags-y += -DCONFIG_SDIO_INBAND_POLLING
+#ccflags-y += -DCONFIG_SDIO_BLKSIZE_512
+#ccflags-y += -DCONFIG_SDIO_PWRSEQ
+
+all_dependencies += install
+
+obj-$(CONFIG_AW_WIFI_DEVICE_UWE5622) := $(MODULE_NAME).o
+
+$(MODULE_NAME)-y += wcn_bus.o \
+		    platform/wcn_boot.o \
+		    platform/wcn_txrx.o \
+		    platform/wcn_misc.o \
+		    platform/wcn_procfs.o \
+		    platform/loopcheck.o
+
+$(MODULE_NAME)-y += \
+		    sdio/sdiohal_main.o \
+		    sdio/sdiohal_common.o \
+		    sdio/sdiohal_tx.o \
+		    sdio/sdiohal_rx.o \
+		    sdio/sdio_v3.o \
+		    sdio/sdiohal_ctl.o \
+		    sleep/sdio_int.o \
+		    sleep/slp_mgr.o \
+		    sleep/slp_sdio.o
+
+KDIR ?= $(ANDROID_PRODUCT_OUT)/obj/KERNEL_OBJ
+ARCH ?= arm
+CROSS_COMPILE ?= arm-histbv310-linux-
+
+EXTRA_CFLAGS += -I$(src)/include -D__linux__
+
+all: $(all_dependencies)
+
+driver: $(driver_dependencies)
+	@echo build driver
+	$(MAKE) ARCH=$(ARCH) CROSS_COMPILE=$(CROSS_COMPILE) -C $(KDIR) M=$(PWD) modules
+
+install:
+	@echo install targets
+	mkdir -p $(ANDROID_PRODUCT_OUT)/system/lib/modules
+	cp -fv $(PWD)/$(MODULE_NAME).ko $(ANDROID_PRODUCT_OUT)/system/lib/modules/$(MODULE_NAME).ko
+	make clean
+
+clean:
+	$(MAKE) -C $(KDIR) M=$(PWD) clean
+	$(RM) Module.markers
+	$(RM) modules.order
diff --git a/drivers/net/wireless/uwe5622/unisocwcn/include/bus_common.h b/drivers/net/wireless/uwe5622/unisocwcn/include/bus_common.h
new file mode 100644
index 000000000000..4ca7be28168e
--- /dev/null
+++ b/drivers/net/wireless/uwe5622/unisocwcn/include/bus_common.h
@@ -0,0 +1,16 @@
+#ifndef __BUS_COMMON_H__
+#define __BUS_COMMON_H__
+
+#include <wcn_bus.h>
+
+int bus_chn_init(struct mchn_ops_t *ops, int hif_type);
+int bus_chn_deinit(struct mchn_ops_t *ops);
+int buf_list_alloc(int chn, struct mbuf_t **head,
+		   struct mbuf_t **tail, int *num);
+int buf_list_free(int chn, struct mbuf_t *head,
+		  struct mbuf_t *tail, int num);
+int buf_list_is_full(int chn);
+struct mchn_ops_t *chn_ops(int channel);
+int module_ops_register(struct sprdwcn_bus_ops *ops);
+void module_ops_unregister(void);
+#endif
diff --git a/drivers/net/wireless/uwe5622/unisocwcn/include/marlin_platform.h b/drivers/net/wireless/uwe5622/unisocwcn/include/marlin_platform.h
new file mode 100644
index 000000000000..c62c6b5d35d8
--- /dev/null
+++ b/drivers/net/wireless/uwe5622/unisocwcn/include/marlin_platform.h
@@ -0,0 +1,111 @@
+/*
+ * Copyright (C) 2016 Spreadtrum Communications Inc.
+ *
+ * Filename : marlin.h
+ * Abstract : This file is a implementation for driver of marlin2
+ *
+ * Authors	: yufeng.yang
+ *
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+#ifndef __MARLIN_H__
+#define __MARLIN_H__
+
+#include <linux/types.h>
+
+#define FALSE								(0)
+#define TRUE								(1)
+
+typedef int (*marlin_reset_callback) (void *para);
+extern marlin_reset_callback marlin_reset_func;
+extern void *marlin_callback_para;
+enum marlin_sub_sys {
+	MARLIN_BLUETOOTH = 0,
+	MARLIN_FM,
+	MARLIN_WIFI,
+	MARLIN_WIFI_FLUSH,
+	MARLIN_SDIO_TX,
+	MARLIN_SDIO_RX,
+	MARLIN_MDBG,
+	MARLIN_GNSS,
+	WCN_AUTO,	/* fist GPS, then btwififm */
+	MARLIN_ALL,
+};
+
+enum wcn_chip_model {
+	WCN_CHIP_INVALID,
+	WCN_CHIP_MARLIN3,
+	WCN_CHIP_MARLIN3L,
+	WCN_CHIP_MARLIN3E,
+};
+
+enum wcn_chip_id_type {
+	WCN_CHIP_ID_INVALID,
+	WCN_CHIP_ID_AA,
+	WCN_CHIP_ID_AB,
+	WCN_CHIP_ID_AC,
+	WCN_CHIP_ID_AD,
+};
+
+enum wcn_clock_type {
+	WCN_CLOCK_TYPE_UNKNOWN,
+	WCN_CLOCK_TYPE_TCXO,
+	WCN_CLOCK_TYPE_TSX,
+};
+
+enum wcn_clock_mode {
+	WCN_CLOCK_MODE_UNKNOWN,
+	WCN_CLOCK_MODE_XO,
+	WCN_CLOCK_MODE_BUFFER,
+};
+
+/* number of marlin antennas */
+enum marlin_ant_num {
+	MARLIN_ANT_NOT_CFG = 0,
+	MARLIN_ONE_ANT,
+	MARLIN_TWO_ANT,
+	MARLIN_THREE_ANT,
+	MARLIN_ANT_NUM
+};
+
+enum marlin_wake_host_en {
+	BT_WAKE_HOST = 0,
+	WL_WAKE_HOST
+};
+
+unsigned int marlin_get_wcn_chipid(void);
+const char *wcn_get_chip_name(void);
+enum wcn_chip_model wcn_get_chip_model(void);
+enum wcn_chip_id_type wcn_get_chip_type(void);
+unsigned long marlin_get_power_state(void);
+unsigned char marlin_get_bt_wl_wake_host_en(void);
+int marlin_get_wcn_module_vendor(void);
+int marlin_get_ant_num(void);
+void marlin_power_off(enum marlin_sub_sys subsys);
+int marlin_get_power(enum marlin_sub_sys subsys);
+int marlin_reset_reg(void);
+int start_marlin(u32 subsys);
+int stop_marlin(u32 subsys);
+void marlin_schedule_download_wq(void);
+int open_power_ctl(void);
+bool marlin_get_download_status(void);
+void marlin_chip_en(bool enable, bool reset);
+int marlin_get_module_status(void);
+int marlin_get_module_status_changed(void);
+int wcn_get_module_status_changed(void);
+void wcn_set_module_status_changed(bool status);
+int marlin_reset_register_notify(void *callback_func, void *para);
+int marlin_reset_unregister_notify(void);
+int is_first_power_on(enum marlin_sub_sys subsys);
+int cali_ini_need_download(enum marlin_sub_sys subsys);
+const char *strno(int subsys);
+void mdbg_assert_interface(char *str);
+#endif
diff --git a/drivers/net/wireless/uwe5622/unisocwcn/include/mchn.h b/drivers/net/wireless/uwe5622/unisocwcn/include/mchn.h
new file mode 100644
index 000000000000..4f93edf184b7
--- /dev/null
+++ b/drivers/net/wireless/uwe5622/unisocwcn/include/mchn.h
@@ -0,0 +1,108 @@
+/*
+ * Copyright (C) 2016 Spreadtrum Communications Inc.
+ *
+ * Authors	: jinglong.chen
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#ifndef __MCHN_H__
+#define __MCHN_H__
+
+#include <linux/kernel.h>
+#include <linux/slab.h>
+#include <linux/spinlock.h>
+#include <linux/interrupt.h>
+
+#define HW_TYPE_SDIO 0
+#define HW_TYPE_PCIE 1
+#define MCHN_MAX_NUM 32
+
+struct mbuf_t {
+	struct __mbuf *next;
+	unsigned char *buf;
+	unsigned long  phy;
+	unsigned short len;
+	unsigned short rsvd;
+	unsigned int   seq;
+};
+
+struct buffer_pool_t {
+	int size;
+	int free;
+	int payload;
+	void *head;
+	char *mem;
+	spinlock_t lock;
+	unsigned long irq_flags;
+};
+
+struct mchn_ops_t {
+	/*channel id*/
+	int channel;
+	/*hardware interface type*/
+	int hif_type;
+	/*inout=1 tx side, inout=0 rx side */
+	int inout;
+	/*set callback pop_link/push_link frequency */
+	int intr_interval;
+	/*data buffer size */
+	int buf_size;
+	/*mbuf pool size */
+	int pool_size;
+	/*The large number of trans */
+	int once_max_trans;
+	/*rx side threshold */
+	int rx_threshold;
+	/*tx timeout */
+	int timeout;
+	/*callback in top tophalf*/
+	int cb_in_irq;
+	/*pending link num*/
+	int max_pending;
+	/*pop link list, (1)chn id, (2)mbuf link head
+	 *(3) mbuf link tail (4)number of node
+	 */
+	int (*pop_link)(int, mbuf_t *, mbuf_t *, int);
+	/*ap don't need to implementation*/
+	int (*push_link)(int, mbuf_t **, mbuf_t **, int *);
+	/*(1)channel id (2)trans time, -1 express timeout*/
+	int (*tx_complete)(int, int);
+	int (*power_notify)(int, int);
+};
+
+struct mchn_info_t {
+	mchn_ops_t *ops[MCHN_MAX_NUM];
+	struct {
+		buffer_pool_t pool;
+	} chn_public[MCHN_MAX_NUM];
+};
+
+/*configuration channel*/
+int mchn_init(struct mchn_ops_t *ops);
+/*cancellation channel*/
+int mchn_deinit(struct mchn_ops_t *ops);
+/*push link list*/
+int mchn_push_link(int channel, struct mbuf_t *head, struct mbuf_t *tail,
+	int num);
+/*push link list, Using a blocking mode, Timeout wait for tx_complete*/
+int mchn_push_link_wait_complete(int chn, struct mbuf_t *head,
+	struct mbuf_t *tail, int num, int timeout);
+int mchn_hw_pop_link(int chn, void *head, void *tail, int num);
+int mchn_hw_tx_complete(int chn, int timeout);
+int mchn_hw_req_push_link(int chn, int need);
+int mbuf_link_alloc(int chn, struct mbuf_t **head, struct mbuf_t **tail,
+	int *num);
+int mbuf_link_free(int chn, struct mbuf_t *head, struct mbuf_t *tail, int num);
+int mchn_hw_max_pending(int chn);
+struct mchn_info_t *mchn_info(void);
+struct mchn_ops_t *mchn_ops(int channel);
+#endif
+
diff --git a/drivers/net/wireless/uwe5622/unisocwcn/include/uwe5621_glb.h b/drivers/net/wireless/uwe5622/unisocwcn/include/uwe5621_glb.h
new file mode 100644
index 000000000000..5f07c79e352d
--- /dev/null
+++ b/drivers/net/wireless/uwe5622/unisocwcn/include/uwe5621_glb.h
@@ -0,0 +1,295 @@
+#ifndef __UWE5621_GLB_H__
+#define __UWE5621_GLB_H__
+
+#include "../sleep/slp_mgr.h"
+
+/* log buf size */
+#define MDBG_RX_RING_SIZE		(64*1024)
+
+#define CP_START_ADDR		0x40500000
+#define CP_RESET_REG		0x40088288
+#define CP_SDIO_PRIORITY_ADDR 0x40130150
+
+/* set sdio higher priority to visit iram */
+#define M6_TO_S0_HIGH_PRIORITY 0X80000000
+
+#define PACKET_SIZE		(32*1024)
+/* time out in waiting wifi to come up */
+#define POWERUP_WAIT_MS	30000
+#define POWERUP_DELAY		200
+#define RESET_DELAY		1
+
+#define FIRMWARE_MAX_SIZE 0xf0c00
+#define WIFI_REG 0x60300004
+#define CHIPID_REG 0x4083c208
+#define CALI_REG 0x70040000
+#define CALI_OFSET_REG 0x70040010
+#define MARLIN_AA_CHIPID 0x23550000
+#define MARLIN_AB_CHIPID 0x23550001
+#define MARLIN_AC_CHIPID 0x23550002
+#define MARLIN_AD_CHIPID 0x23550003
+#define MARLIN3_AA_CHIPID	MARLIN_AA_CHIPID
+#define MARLIN3L_AA_CHIPID	0
+#define MARLIN3E_AA_CHIPID	0
+
+#define CARD_DETECT_WAIT_MS	3000
+#define DCACHE_CMD_ISSUE_START 0X80000000
+#define DCACHE_CMD_CLEAN_ALL 0X00000000
+#define DCACHE_CMD_CLEAN_INVALID_ALL 0X00000008
+#define DCACHE_REG_BASE 0X401E0000
+#define DCACHE_REG_ENABLE (DCACHE_REG_BASE)
+#define DCACHE_CFG0 (DCACHE_REG_BASE + 0X0040)
+#define DCACHE_CMD_CFG2 (DCACHE_REG_BASE + 0X0058)
+#define DCACHE_INT_RAW_STS (DCACHE_REG_BASE + 0X0064)
+#define DCACHE_INT_CLR (DCACHE_REG_BASE + 0X006C)
+#define DCACHE_CMD_IRQ_CLR 0X00000001
+#define DCACHE_CMD_CFG2_MASK 0X8000003F
+#define DCACHE_ENABLE_MASK 0XFFFFFFFF
+#define DCACHE_DEBUG_EN 0X80000000
+#define DCACHE_SIZE_32K 0X3
+#define DCACHE_SIZE_SEL_MASK 0X30000000
+
+#define DUMP_PACKET_SIZE		(32 * 1024)
+#define DUMP_SDIO_ADDR			(0x40140000)
+#define DUMP_SDIO_ADDR_SIZE		(0x10000)
+/* for wifi */
+#define DUMP_WIFI_AON_MAC_ADDR			(0x400f0000)
+#define DUMP_WIFI_AON_MAC_ADDR_SIZE		(0x108)
+#define DUMP_WIFI_REF_ADDR			(0x4083c000)
+#define DUMP_WIFI_REF_ADDR_SIZE			(0x350)
+#define DUMP_WIFI_RTN_PD_MAC_ADDR		(0x400f1000)
+#define DUMP_WIFI_RTN_PD_MAC_ADDR_SIZE		(0xD100)
+#define DUMP_WIFI_352K_RAM_ADDR			(0x40300000)
+#define DUMP_WIFI_352K_RAM_ADDR_SIZE		(0x58000)
+#define CHIP_SLP				(0X4083C00C)
+#define WIFI_WRAP_PWRON				(1 << 14)
+#define WIFI_PHY_PWRON				(1 << 15)
+#define WIFI_MAC_PWRON				(1 << 16)
+#define WIFI_ALL_PWRON	(WIFI_MAC_PWRON | WIFI_WRAP_PWRON)
+#define PD_WIFI_AON_CFG4			(0x4083c088)
+#define PD_WIFI_MAC_AON_CFG4			(0X4083C0A8)
+#define PD_WIFI_PHY_AON_CFG4			(0x4083C0B8)
+#define WIFI_MAC_RTN_SLEEPPS_CTL		(0x400f4704)
+#define WIFI_RETENTION				(1 << 0)
+#define WIFI_WRAP_PWR_DOWN			(1 << 1)
+#define WIFI_MAC_PWR_DOWN			(1 << 2)
+#define WIFI_PHY_PWR_DOWN			(1 << 2)
+#define WIFI_ENABLE				(0x40130004)
+#define AHB_EB0					(0x40130004)
+#define WIFI_EN					(1 << 5)
+#define BT_EN					(1 << 4)
+#define WIFI_MAC_EN				(1 << 9)
+#define WIFI_ALL_EN		(WIFI_EN | WIFI_MAC_EN)
+#define CLK_CTRL0			0x4083c040
+#define APLL_PDN			(1 << 0)
+#define BPLL_PDN			(1 << 1)
+
+/* AON_APB */
+#define CLK_CTL3			0x4083c04c
+#define BT_32M_EB			(1 << 18)
+#define BT_64M_EB			(1 << 19)
+
+/* for BT */
+#define BT_ACC_ADDR			(0x40240000)
+#define BT_ACC_SIZE			(0x8d8)
+#define BT_JAL_ADDR			(0x40246000)
+#define BT_JAL_SIZE			(0x738)
+#define BT_HAB_ADDR			(0x40248000)
+#define BT_HAB_SIZE			(0xA0)
+#define BT_LEJAL_ADDR			(0x4024A000)
+#define BT_LEJAL_SIZE			(0x21C)
+#define BT_MODEM_ADDR			(0x4024F000)
+#define BT_MODEM_SIZE			(0x300)
+/* for BT (HW DEC and BB) Buffer */
+#define HCI_ARM_WR_RD_MODE		(0x40240600)
+#define HCI_ARM_WR_RD_VALUE		(0xFFFF)
+
+#define BT_CMD_BUF_ADDR		(0x40200000)
+#define BT_CMD_BUF_SIZE		(0x200)
+#define BT_EVENT_BUF_ADDR		(0x40204000)
+#define BT_EVENT_BUF_SIZE		(0x200)
+#define BT_LMP_TX_BUF_ADDR		(0x40208000)
+#define BT_LMP_TX_BUF_SIZE		(0x12A4)
+#define BT_LMP_RX_BUF_ADDR		(0x40200C00)
+#define BT_LMP_RX_BUF_SIZE		(0xB744)
+#define BT_ACL_TX_BUF_ADDR		(0x40210000)
+#define BT_ACL_TX_BUF_SIZE		(0x3000)
+#define BT_ACL_RX_BUF_ADDR		(0x40214000)
+#define BT_ACL_RX_BUF_SIZE		(0x3000)
+#define BT_SCO_TX_BUF_ADDR		(0x40218000)
+#define BT_SCO_TX_BUF_SIZE		(0x2D0)
+#define BT_SCO_RX_BUF_ADDR		(0x4021C000)
+#define BT_SCO_RX_BUF_SIZE		(0x5C0)
+#define BT_BB_TX_BUF_ADDR		(0x40241000)
+#define BT_BB_TX_BUF_SIZE		(0x400)
+#define BT_BB_RX_BUF_ADDR		(0x40242000)
+#define BT_BB_RX_BUF_SIZE		(0x400)
+
+#define DUMP_BT_ADDR			(0)
+#define DUMP_BT_ADDR_SIZE		(0)
+/* for fm */
+#define DUMP_FM1_ADDR			(0x40098000)
+#define DUMP_FM1_ADDR_SIZE		(0x238)
+#define DUMP_FM_RDS_ADDR		(0x40098800)
+#define DUMP_FM_RDS_ADDR_SIZE		(0x4c)
+#define DUMP_FM_ADDR			(0x40098000)
+#define DUMP_FM_ADDR_SIZE		(0xabc)
+
+#define DUMP_INTC_ADDR			(0)
+#define DUMP_SYSTIMER_ADDR		(0)
+/* need check, not need to dump it */
+#define DUMP_WDG_ADDR			0
+#define DUMP_WIFI_ADDR			0
+#define DUMP_WIFI_ADDR_SIZE		0
+#define DUMP_BT_CMD_ADDR		0
+#define DUMP_BT_CMD_ADDR_SIZE	0
+
+/* For TOP */
+#define AON_AHB_ADDR			(0x40880000)
+#define AON_AHB_SIZE			(0x54)
+#define AON_APB_ADDR			(0x4083C000)
+#define AON_APB_SIZE			(0x354)
+#define BTWF_AHB_ADDR			(0x40130000)
+#define BTWF_AHB_SIZE			(0x400)
+#define BTWF_APB_ADDR			(0x40088000)
+#define BTWF_APB_SIZE			(0x28C)
+#define AON_CLK_ADDR			(0x40844200)
+#define AON_CLK_SIZE			(0x144)
+#define PRE_DIV_CLK_ADDR		(0x40844000)
+#define PRE_DIV_CLK_SIZE		(0x48)
+
+#define DUMP_APB_ADDR			(0)
+#define DUMP_DMA_ADDR			(0)
+#define DUMP_AHB_ADDR			(0)
+#define DUMP_REG_SIZE			(0X10000)
+
+#define SMP_HEADERFLAG 0X7E7E7E7E
+#define SMP_RESERVEDFLAG 0X5A5A
+#define SMP_DSP_CHANNEL_NUM 0X88
+#define SMP_DSP_TYPE 0X9D
+#define SMP_DSP_DUMP_TYPE 0X32
+
+#define SYSNC_CODE_LEN 0X4
+#define CHKSUM_LEN 0X2
+#define ARMLOG_HEAD 9
+
+/* For GNSS */
+#define GNSS_CP_START_ADDR	0x40A20000
+#define GNSS_CP_RESET_REG	0x40BC8280
+#define GNSS_FIRMWARE_MAX_SIZE 0x58000
+#define GNSS_CHIPID_REG 0x603003fc
+
+/* For MARLIN3 DCACHE */
+#define DCACHE_CMD_ISSUE_START 0X80000000
+#define DCACHE_CMD_CLEAN_ALL 0X00000000
+#define DCACHE_CMD_CLEAN_INVALID_ALL 0X00000008
+#define DCACHE_REG_BASE 0X401E0000
+#define DCACHE_CFG0 (DCACHE_REG_BASE + 0X0040)
+#define DCACHE_CMD_CFG2 (DCACHE_REG_BASE + 0X0058)
+#define DCACHE_INT_RAW_STS (DCACHE_REG_BASE + 0X0064)
+#define DCACHE_INT_CLR (DCACHE_REG_BASE + 0X006C)
+#define DCACHE_CMD_IRQ_CLR 0X00000001
+#define DCACHE_CMD_CFG2_MASK 0X8000003F
+#define DCACHE_DEBUG_EN 0X80000000
+#define DCACHE_SIZE_32K 0X3
+#define DCACHE_SIZE_SEL_MASK 0X30000000
+
+
+/* For MARLIN3 MEM PD  */
+#define CTL_BASE_AON_APB 0X4083C000
+#define REG_AON_APB_CHIP_MEM_AUTO_EN (CTL_BASE_AON_APB + 0X0198)
+#define REG_AON_APB_BTWF_MEM_CGG1 (CTL_BASE_AON_APB + 0X010C)
+/* SHUTDOWN IRAM [0...15]*32K=512K,FORCE SHUTDOWN IRAM [16...31]*32K=512K */
+#define REG_AON_APB_BTWF_MEM_CGG2 (CTL_BASE_AON_APB + 0X0110)
+/* RETENTION IRAM [0...15]*32K=512K,FORCE RETENTION IRAM [16...31]*32K=512K */
+#define REG_AON_APB_BTWF_MEM_CGG3 (CTL_BASE_AON_APB + 0X0114)
+/* SHUTDOWN IRAM [0...13]*32K=448K,[14]mean 3k; */
+#define REG_AON_APB_BTWF_MEM_CGG4 (CTL_BASE_AON_APB + 0X0118)
+
+
+/* for dump arm register */
+#define AON_APB_BASE_ADDR 0X4083C000
+
+#define ARM_DAP_BASE_ADDR 0X4085C000
+#define ARM_DAP_REG1 0X4085C000
+#define ARM_DAP_REG2 0X4085C004
+#define ARM_DAP_REG3 0X4085C00C
+
+#define BTWF_STATUS_REG 0x4085c0fc
+#define BTWF_OK_VALUE 0x24770011
+#define GNSS_OK 0x408600fc
+
+#define DJTAG_DAP_SEL (AON_APB_BASE_ADDR + 0X0064)
+#define APB_RST (AON_APB_BASE_ADDR + 0x0000)
+#define APB_EB  (AON_APB_BASE_ADDR + 0x0024)
+#define CM4_DAP_SEL_BTWF 0X00000001	/* bit0 */
+#define CM4_DAP_SEL_GNSS 0X00000002	/* bit1 */
+#define CM4_DAP0_SOFT_RST 0X10000000	/* BIT28 */
+#define CM4_DAP1_SOFT_RST 0X20000000	/* BIT29 */
+#define CM4_DAP0_EB 0X40000000	/* BIT30 */
+#define CM4_DAP1_EB 0X80000000	/* BIT31 */
+
+#define PD_GNSS_SS_AON_CFG4 (AON_APB_BASE_ADDR + 0X00c8)
+#define PD_AUTO_EN		(1 << 12)
+#define FORCE_DEEP_SLEEP	(1 << 3)
+#define GNSS_SS_POWER_DOWN	(1 << 2)/* NO USE */
+#define CHIP_DEEP_SLP_EN	(1 << 1)
+
+#define SYNC_ADDR		0x405F0BB0
+#define SYNC_IN_PROGRESS	0xF0F0F0F0
+#define SYNC_CALI_WAITING	0xF0F0F0F1
+#define SYNC_CALI_WRITE_DONE	0xF0F0F0F2
+#define SYNC_CALI_FINISHED	0xF0F0F0F3
+#define SYNC_SDIO_REINIT_DONE	0xF0F0F0F4
+#define SYNC_SDIO_IS_READY	0xF0F0F0F5
+#define SYNC_VERIFY_WAITING	0xF0F0F0F6
+#define SYNC_VERIFY_WRITE_DONE	0xF0F0F0F7
+#define SYNC_VERIFY_FINISHED	0xF0F0F0F8
+#define SYNC_ALL_FINISHED	0xF0F0F0FF
+#define CHIP_SLP_REG		(AON_APB_BASE_ADDR + 0X000c)
+#define GNSS_SS_PWRON_FINISH	(1 << 12)
+#define GNSS_PWR_FINISH	(1 << 13)
+
+#define CGM_GNSS_FAKE_CFG (0x40844200 + 0X0104)
+#define CGM_GNSS_FAKE_SEL (0x3)
+
+/* for sleep/wakeup */
+#define REG_CP_SLP_CTL		0x1a2
+#define REG_AP_INT_CP0		0x1b0
+#define REG_PUB_INT_EN0		0x1c0
+#define REG_PUB_INT_CLR0	0x1d0
+#define REG_PUB_INT_STS0	0x1f0
+/* BIT4~7, if value 0, stand for in deepsleep */
+#define REG_BTWF_SLP_STS	0x148
+#define BTWF_IN_DEEPSLEEP	0x0
+/* fm playing in deep, and xtl on */
+#define BTWF_IN_DEEPSLEEP_XLT_ON	0x30
+#define  SLEEP_STATUS_FLAG 0xF0
+/* For power save */
+#define REG_WIFI_MEM_CFG1	0x4083c130
+#define FORCE_SHUTDOWN_BTRAM	(1 << 22)
+
+/* For FM Spue freq */
+#define FM_REG_SPUR_FEQ1_ADDR			0x40098104
+#define FM_DISABLE_SPUR_REMOVE_VALUE		0x06DC063C
+#define FM_ENABLE_SPUR_REMOVE_FREQ2_VALUE	0x06DCAB7C
+
+/*
+ * For SPI interface
+ * bit[15]:1'b0: TCXO mode, outside clock
+ * bit[15]:1'b1: Crystal/TSX mode
+ */
+#define SPI_BASE_ADDR		0x408a0000
+#define AD_DCXO_BONDING_OPT	0x5030
+#define tsx_mode		(1 << 15)
+#define SPI_BIT31		(1 << 31)
+
+#define AON_APB_TEST_READ_REG	AON_APB_BASE_ADDR
+
+/* for debug dump */
+#define WIFI_AON_MAC_SIZE	0x108
+#define WIFI_RAM_SIZE		0x58000
+#define WIFI_GLB_REG_SIZE	0x4c
+
+#define RESET_BIT		(1<<0)
+#endif
diff --git a/drivers/net/wireless/uwe5622/unisocwcn/include/uwe5622_glb.h b/drivers/net/wireless/uwe5622/unisocwcn/include/uwe5622_glb.h
new file mode 100644
index 000000000000..3d6a1024f5f0
--- /dev/null
+++ b/drivers/net/wireless/uwe5622/unisocwcn/include/uwe5622_glb.h
@@ -0,0 +1,121 @@
+#ifndef __UWE5622_GLB_H__
+#define __UWE5622_GLB_H__
+
+/* UWE5622 is the lite of uwe5621 */
+#include "uwe5621_glb.h"
+
+
+#ifdef MARLIN_AA_CHIPID
+#undef MARLIN_AA_CHIPID
+#define MARLIN_AA_CHIPID 0x2355B000
+#endif
+
+#ifdef MARLIN_AB_CHIPID
+#undef MARLIN_AB_CHIPID
+#define MARLIN_AB_CHIPID 0x2355B001
+#endif
+
+#ifdef MARLIN_AC_CHIPID
+#undef MARLIN_AC_CHIPID
+#define MARLIN_AC_CHIPID 0x2355B002
+#endif
+
+#ifdef MARLIN_AD_CHIPID
+#undef MARLIN_AD_CHIPID
+#define MARLIN_AD_CHIPID 0x2355B003
+#endif
+
+#ifdef MARLIN3_AA_CHIPID
+#undef MARLIN3_AA_CHIPID
+#undef MARLIN3L_AA_CHIPID
+#undef MARLIN3E_AA_CHIPID
+#define MARLIN3_AA_CHIPID	0
+#define MARLIN3L_AA_CHIPID	MARLIN_AA_CHIPID
+#define MARLIN3E_AA_CHIPID	0
+#endif
+
+/**************GNSS BEG**************/
+#ifdef GNSS_CP_START_ADDR
+#undef GNSS_CP_START_ADDR
+#define GNSS_CP_START_ADDR 0x40A50000
+#endif
+
+#ifdef GNSS_FIRMWARE_MAX_SIZE
+#undef GNSS_FIRMWARE_MAX_SIZE
+#define GNSS_FIRMWARE_MAX_SIZE 0x2B000
+#endif
+/**************GNSS END**************/
+
+/**************WCN BEG**************/
+#ifdef FIRMWARE_MAX_SIZE
+#undef FIRMWARE_MAX_SIZE
+#define FIRMWARE_MAX_SIZE 0xe7400
+#endif
+
+#ifdef SYNC_ADDR
+#undef SYNC_ADDR
+#define SYNC_ADDR 0x405E73B0
+#endif
+
+#ifdef ARM_DAP_BASE_ADDR
+#undef ARM_DAP_BASE_ADDR
+#define ARM_DAP_BASE_ADDR 0X40060000
+#endif
+
+#ifdef ARM_DAP_REG1
+#undef ARM_DAP_REG1
+#define ARM_DAP_REG1 0X40060000
+#endif
+
+#ifdef ARM_DAP_REG2
+#undef ARM_DAP_REG2
+#define ARM_DAP_REG2 0X40060004
+#endif
+
+#ifdef ARM_DAP_REG3
+#undef ARM_DAP_REG3
+#define ARM_DAP_REG3 0X4006000C
+#endif
+
+#ifdef BTWF_STATUS_REG
+#undef BTWF_STATUS_REG
+#define BTWF_STATUS_REG 0x400600fc
+#endif
+
+#ifdef WIFI_AON_MAC_SIZE
+#undef WIFI_AON_MAC_SIZE
+#define WIFI_AON_MAC_SIZE 0x120
+#endif
+
+#ifdef WIFI_RAM_SIZE
+#undef WIFI_RAM_SIZE
+#define WIFI_RAM_SIZE 0x4a800
+#endif
+
+#ifdef WIFI_GLB_REG_SIZE
+#undef WIFI_GLB_REG_SIZE
+#define WIFI_GLB_REG_SIZE 0x58
+#endif
+
+#ifdef BT_ACC_SIZE
+#undef BT_ACC_SIZE
+#define BT_ACC_SIZE 0x8f4
+#endif
+
+#ifdef BT_MODEM_SIZE
+#undef BT_MODEM_SIZE
+#define BT_MODEM_SIZE 0x310
+#endif
+
+/* for marlin3Lite */
+#define APB_ENB1			0x4008801c
+#define DBG_CM4_EB			BIT(10)
+#define DAP_CTRL			0x4008828c
+#define CM4_DAP_SEL_BTWF_LITE		BIT(1)
+
+#define BTWF_XLT_WAIT		0x10
+#define BTWF_XLTBUF_WAIT	0x20
+#define BTWF_PLL_PWR_WAIT	0x40
+/**************WCN END**************/
+
+#endif
diff --git a/drivers/net/wireless/uwe5622/unisocwcn/include/uwe5623_glb.h b/drivers/net/wireless/uwe5622/unisocwcn/include/uwe5623_glb.h
new file mode 100644
index 000000000000..8c0278d6f42c
--- /dev/null
+++ b/drivers/net/wireless/uwe5622/unisocwcn/include/uwe5623_glb.h
@@ -0,0 +1,307 @@
+#ifndef __UWE5623_GLB_H__
+#define __UWE5623_GLB_H__
+
+#include "../sleep/slp_mgr.h"
+
+/* log buf size */
+#define MDBG_RX_RING_SIZE		(64*1024)
+
+#define CP_START_ADDR		0x40500000
+#define CP_RESET_REG		0x40930004
+#define CP_SDIO_PRIORITY_ADDR 0x40130150
+
+/* set sdio higher priority to visit iram */
+#define M6_TO_S0_HIGH_PRIORITY 0X80000000
+
+#define PACKET_SIZE		(32*1024)
+/* time out in waiting wifi to come up */
+#define POWERUP_WAIT_MS	30000
+#define POWERUP_DELAY		200
+#define RESET_DELAY		1
+
+#define FIRMWARE_MAX_SIZE 0xf0c00
+#define WIFI_REG 0x60300004
+#define CHIPID_REG 0x4082c208
+#define CALI_REG 0x70040000
+#define CALI_OFSET_REG 0x70040010
+#define MARLIN_AA_CHIPID 0x56630000
+#define MARLIN_AB_CHIPID 0x56630001
+#define MARLIN_AC_CHIPID 0x56630002
+#define MARLIN_AD_CHIPID 0x56630003
+#define MARLIN3_AA_CHIPID	0
+#define MARLIN3L_AA_CHIPID	0
+#define MARLIN3E_AA_CHIPID	MARLIN_AA_CHIPID
+
+#define CARD_DETECT_WAIT_MS	3000
+
+#define DCACHE_CMD_ISSUE_START 0X80000000
+#define DCACHE_CMD_CLEAN_ALL 0X00000000
+#define DCACHE_CMD_CLEAN_INVALID_ALL 0X00000008
+#define DCACHE_REG_BASE 0X401E0000
+#define DCACHE_REG_ENABLE (DCACHE_REG_BASE)
+#define DCACHE_CFG0 (DCACHE_REG_BASE + 0X0040)
+#define DCACHE_CMD_CFG2 (DCACHE_REG_BASE + 0X0058)
+#define DCACHE_INT_RAW_STS (DCACHE_REG_BASE + 0X0064)
+#define DCACHE_INT_CLR (DCACHE_REG_BASE + 0X006C)
+#define DCACHE_CMD_IRQ_CLR 0X00000001
+#define DCACHE_CMD_CFG2_MASK 0X8000003F
+#define DCACHE_ENABLE_MASK 0XFFFFFFFF
+#define DCACHE_DEBUG_EN 0X80000000
+#define DCACHE_SIZE_32K 0X3
+#define DCACHE_SIZE_SEL_MASK 0X30000000
+
+#define DUMP_PACKET_SIZE		(32 * 1024)
+#define DUMP_SDIO_ADDR			(0x40140000)
+#define DUMP_SDIO_ADDR_SIZE		(0x10000)
+/* for wifi */
+#define DUMP_WIFI_AON_MAC_ADDR			(0x400f0000)
+#define WIFI_AON_MAC_SIZE		(0x108)
+#define DUMP_WIFI_REF_ADDR			(0x4083c000)
+#define DUMP_WIFI_REF_ADDR_SIZE			(0x350)
+#define DUMP_WIFI_RTN_PD_MAC_ADDR		(0x400f1000)
+#define DUMP_WIFI_RTN_PD_MAC_ADDR_SIZE		(0xD100)
+#define DUMP_WIFI_352K_RAM_ADDR			(0x40300000)
+#define WIFI_RAM_SIZE		(0x58000)
+#define WIFI_GLB_REG_SIZE	0x4c
+#define CHIP_SLP				(0X4083C00C)
+#define WIFI_WRAP_PWRON				(1 << 14)
+#define WIFI_PHY_PWRON				(1 << 15)
+#define WIFI_MAC_PWRON				(1 << 16)
+#define WIFI_ALL_PWRON	(WIFI_MAC_PWRON | WIFI_WRAP_PWRON)
+#define PD_WIFI_AON_CFG4			(0x4083c088)
+#define PD_WIFI_MAC_AON_CFG4			(0X4083C0A8)
+#define PD_WIFI_PHY_AON_CFG4			(0x4083C0B8)
+#define WIFI_MAC_RTN_SLEEPPS_CTL		(0x400f4704)
+#define WIFI_RETENTION				(1 << 0)
+#define WIFI_WRAP_PWR_DOWN			(1 << 1)
+#define WIFI_MAC_PWR_DOWN			(1 << 2)
+#define WIFI_PHY_PWR_DOWN			(1 << 2)
+#define WIFI_ENABLE				(0x40130004)
+#define AHB_EB0					(0x40130004)
+#define WIFI_EN					(1 << 5)
+#define BT_EN					(1 << 4)
+#define WIFI_MAC_EN				(1 << 9)
+#define WIFI_ALL_EN		(WIFI_EN | WIFI_MAC_EN)
+#define CLK_CTRL0			0x4083c040
+#define APLL_PDN			(1 << 0)
+#define BPLL_PDN			(1 << 1)
+
+/* AON_APB */
+#define CLK_CTL3			0x4083c04c
+#define BT_32M_EB			(1 << 18)
+#define BT_64M_EB			(1 << 19)
+
+/* for BT */
+#define BT_ACC_ADDR			(0x40240000)
+#define BT_ACC_SIZE			(0x8d8)
+#define BT_JAL_ADDR			(0x40246000)
+#define BT_JAL_SIZE			(0x738)
+#define BT_HAB_ADDR			(0x40248000)
+#define BT_HAB_SIZE			(0xA0)
+#define BT_LEJAL_ADDR			(0x4024A000)
+#define BT_LEJAL_SIZE			(0x21C)
+#define BT_MODEM_ADDR			(0x4024F000)
+#define BT_MODEM_SIZE			(0x300)
+/* for BT (HW DEC and BB) Buffer */
+#define HCI_ARM_WR_RD_MODE		(0x40240600)
+#define HCI_ARM_WR_RD_VALUE		(0xFFFF)
+
+#define BT_CMD_BUF_ADDR		(0x40200000)
+#define BT_CMD_BUF_SIZE		(0x200)
+#define BT_EVENT_BUF_ADDR		(0x40204000)
+#define BT_EVENT_BUF_SIZE		(0x200)
+#define BT_LMP_TX_BUF_ADDR		(0x40208000)
+#define BT_LMP_TX_BUF_SIZE		(0x12A4)
+#define BT_LMP_RX_BUF_ADDR		(0x40200C00)
+#define BT_LMP_RX_BUF_SIZE		(0xB744)
+#define BT_ACL_TX_BUF_ADDR		(0x40210000)
+#define BT_ACL_TX_BUF_SIZE		(0x3000)
+#define BT_ACL_RX_BUF_ADDR		(0x40214000)
+#define BT_ACL_RX_BUF_SIZE		(0x3000)
+#define BT_SCO_TX_BUF_ADDR		(0x40218000)
+#define BT_SCO_TX_BUF_SIZE		(0x2D0)
+#define BT_SCO_RX_BUF_ADDR		(0x4021C000)
+#define BT_SCO_RX_BUF_SIZE		(0x5C0)
+#define BT_BB_TX_BUF_ADDR		(0x40241000)
+#define BT_BB_TX_BUF_SIZE		(0x400)
+#define BT_BB_RX_BUF_ADDR		(0x40242000)
+#define BT_BB_RX_BUF_SIZE		(0x400)
+
+#define DUMP_BT_ADDR			(0)
+#define DUMP_BT_ADDR_SIZE		(0)
+/* for fm */
+#define DUMP_FM1_ADDR			(0x40098000)
+#define DUMP_FM1_ADDR_SIZE		(0x238)
+#define DUMP_FM_RDS_ADDR		(0x40098800)
+#define DUMP_FM_RDS_ADDR_SIZE		(0x4c)
+#define DUMP_FM_ADDR			(0x40098000)
+#define DUMP_FM_ADDR_SIZE		(0xabc)
+
+#define DUMP_INTC_ADDR			(0)
+#define DUMP_SYSTIMER_ADDR		(0)
+/* need check, not need to dump it */
+#define DUMP_WDG_ADDR			0
+#define DUMP_WIFI_ADDR			0
+#define DUMP_WIFI_ADDR_SIZE		0
+#define DUMP_BT_CMD_ADDR		0
+#define DUMP_BT_CMD_ADDR_SIZE	0
+
+/* For TOP */
+#define AON_AHB_ADDR			(0x40880000)
+#define AON_AHB_SIZE			(0x54)
+#define AON_APB_ADDR			(0x4083C000)
+#define AON_APB_SIZE			(0x354)
+#define BTWF_AHB_ADDR			(0x40130000)
+#define BTWF_AHB_SIZE			(0x400)
+#define BTWF_APB_ADDR			(0x40088000)
+#define BTWF_APB_SIZE			(0x28C)
+#define AON_CLK_ADDR			(0x40844200)
+#define AON_CLK_SIZE			(0x144)
+#define PRE_DIV_CLK_ADDR		(0x40844000)
+#define PRE_DIV_CLK_SIZE		(0x48)
+
+#define DUMP_APB_ADDR			(0)
+#define DUMP_DMA_ADDR			(0)
+#define DUMP_AHB_ADDR			(0)
+#define DUMP_REG_SIZE			(0X10000)
+
+#define SMP_HEADERFLAG 0X7E7E7E7E
+#define SMP_RESERVEDFLAG 0X5A5A
+#define SMP_DSP_CHANNEL_NUM 0X88
+#define SMP_DSP_TYPE 0X9D
+#define SMP_DSP_DUMP_TYPE 0X32
+
+#define SYSNC_CODE_LEN 0X4
+#define CHKSUM_LEN 0X2
+#define ARMLOG_HEAD 9
+
+/* For GNSS */
+#define GNSS_CP_START_ADDR	0x40A20000
+#define GNSS_CP_RESET_REG	0x40BC8280
+#define GNSS_FIRMWARE_MAX_SIZE 0x58000
+#define GNSS_CHIPID_REG 0x603003fc
+
+/* For MARLIN3 DCACHE */
+#define DCACHE_CMD_ISSUE_START 0X80000000
+#define DCACHE_CMD_CLEAN_ALL 0X00000000
+#define DCACHE_CMD_CLEAN_INVALID_ALL 0X00000008
+#define DCACHE_REG_BASE 0X401E0000
+#define DCACHE_CFG0 (DCACHE_REG_BASE + 0X0040)
+#define DCACHE_CMD_CFG2 (DCACHE_REG_BASE + 0X0058)
+#define DCACHE_INT_RAW_STS (DCACHE_REG_BASE + 0X0064)
+#define DCACHE_INT_CLR (DCACHE_REG_BASE + 0X006C)
+#define DCACHE_CMD_IRQ_CLR 0X00000001
+#define DCACHE_CMD_CFG2_MASK 0X8000003F
+#define DCACHE_DEBUG_EN 0X80000000
+#define DCACHE_SIZE_32K 0X3
+#define DCACHE_SIZE_SEL_MASK 0X30000000
+
+
+/* For MARLIN3 MEM PD  */
+#define CTL_BASE_AON_APB 0X4083C000
+#define REG_AON_APB_CHIP_MEM_AUTO_EN (CTL_BASE_AON_APB + 0X0198)
+#define REG_AON_APB_BTWF_MEM_CGG1 (CTL_BASE_AON_APB + 0X010C)
+/* SHUTDOWN IRAM [0...15]*32K=512K,FORCE SHUTDOWN IRAM [16...31]*32K=512K */
+#define REG_AON_APB_BTWF_MEM_CGG2 (CTL_BASE_AON_APB + 0X0110)
+/* RETENTION IRAM [0...15]*32K=512K,FORCE RETENTION IRAM [16...31]*32K=512K */
+#define REG_AON_APB_BTWF_MEM_CGG3 (CTL_BASE_AON_APB + 0X0114)
+/* SHUTDOWN IRAM [0...13]*32K=448K,[14]mean 3k; */
+#define REG_AON_APB_BTWF_MEM_CGG4 (CTL_BASE_AON_APB + 0X0118)
+
+
+/* for dump arm register */
+#define AON_APB_BASE_ADDR 0X4083C000
+
+#define ARM_DAP_BASE_ADDR 0X4085C000
+#define ARM_DAP_REG1 0X4085C000
+#define ARM_DAP_REG2 0X4085C004
+#define ARM_DAP_REG3 0X4085C00C
+
+#define BTWF_STATUS_REG 0x4085c0fc
+#define BTWF_OK_VALUE 0x24770011
+#define GNSS_OK 0x408600fc
+
+#define DJTAG_DAP_SEL (AON_APB_BASE_ADDR + 0X0064)
+#define APB_RST (AON_APB_BASE_ADDR + 0x0000)
+#define APB_EB  (AON_APB_BASE_ADDR + 0x0024)
+#define CM4_DAP_SEL_BTWF 0X00000001	/* bit0 */
+#define CM4_DAP_SEL_GNSS 0X00000002	/* bit1 */
+#define CM4_DAP0_SOFT_RST 0X10000000	/* BIT28 */
+#define CM4_DAP1_SOFT_RST 0X20000000	/* BIT29 */
+#define CM4_DAP0_EB 0X40000000	/* BIT30 */
+#define CM4_DAP1_EB 0X80000000	/* BIT31 */
+
+#define PD_GNSS_SS_AON_CFG4 (AON_APB_BASE_ADDR + 0X00c8)
+#define PD_AUTO_EN		(1 << 12)
+#define FORCE_DEEP_SLEEP	(1 << 3)
+#define GNSS_SS_POWER_DOWN	(1 << 2)/* NO USE */
+#define CHIP_DEEP_SLP_EN	(1 << 1)
+
+#define SYNC_ADDR		0x40525FA0
+#define SYNC_IN_PROGRESS	0xF0F0F0F0
+#define SYNC_CALI_WAITING	0xF0F0F0F1
+#define SYNC_CALI_WRITE_DONE	0xF0F0F0F2
+#define SYNC_CALI_FINISHED	0xF0F0F0F3
+#define SYNC_SDIO_REINIT_DONE	0xF0F0F0F4
+#define SYNC_SDIO_IS_READY	0xF0F0F0F5
+#define SYNC_VERIFY_WAITING	0xF0F0F0F6
+#define SYNC_VERIFY_WRITE_DONE	0xF0F0F0F7
+#define SYNC_VERIFY_FINISHED	0xF0F0F0F8
+#define SYNC_ALL_FINISHED	0xF0F0F0FF
+#define CHIP_SLP_REG		(AON_APB_BASE_ADDR + 0X000c)
+#define GNSS_SS_PWRON_FINISH	(1 << 12)
+#define GNSS_PWR_FINISH	(1 << 13)
+
+#define CGM_GNSS_FAKE_CFG (0x40844200 + 0X0104)
+#define CGM_GNSS_FAKE_SEL (0x3)
+#define REG_CP_RST_CHIP		0x1a8
+
+/* for sleep/wakeup */
+#define REG_CP_SLP_CTL		0x1aa
+#define REG_CP_PMU_SEL_CTL	0x1a3
+#define REG_AP_INT_CP0		0x1b0
+#define REG_PUB_INT_EN0		0x1c0
+#define REG_PUB_INT_CLR0	0x1d0
+#define REG_PUB_INT_STS0	0x1f0
+/* BIT4~7, if value 0, stand for in deepsleep */
+#define REG_BTWF_SLP_STS	0x143
+#define BTWF_IN_DEEPSLEEP	0x0
+/* fm playing in deep, and xtl on */
+#define BTWF_IN_DEEPSLEEP_XLT_ON	0x3
+#define BTWF_XLT_WAIT		0x1
+#define BTWF_XLTBUF_WAIT	0x2
+#define BTWF_PLL_PWR_WAIT	0x4
+#define  SLEEP_STATUS_FLAG     0x0F
+#define CP_M5_STOP		0x4093000c
+#define CP_WAKE_STATUS	CP_M5_STOP
+#define IS_BYPASS_WAKE(addr) ((addr == CP_WAKE_STATUS) ? true : false)
+
+/* For power save */
+#define REG_WIFI_MEM_CFG1	0x4083c130
+#define FORCE_SHUTDOWN_BTRAM	(1 << 22)
+
+/* For FM Spue freq */
+#define FM_REG_SPUR_FEQ1_ADDR			0x40098104
+#define FM_DISABLE_SPUR_REMOVE_VALUE		0x06DC063C
+#define FM_ENABLE_SPUR_REMOVE_FREQ2_VALUE	0x06DCAB7C
+
+/*
+ * For SPI interface
+ * bit[15]:1'b0: TCXO mode, outside clock
+ * bit[15]:1'b1: Crystal/TSX mode
+ */
+#define SPI_BASE_ADDR		0x408a0000
+#define AD_DCXO_BONDING_OPT	0x5030
+#define tsx_mode		(1 << 15)
+#define SPI_BIT31		(1 << 31)
+
+#define AON_APB_BOOT_CAUSE_FLAG_REG	0x4082C3A8
+#define AON_APB_TEST_READ_REG	AON_APB_BOOT_CAUSE_FLAG_REG
+
+#ifdef CONFIG_UWE5623
+#define RESET_BIT		(1<<20)
+#else
+#define RESET_BIT		(1<<0)
+#endif
+
+#endif
diff --git a/drivers/net/wireless/uwe5622/unisocwcn/include/uwe562x_glb.h b/drivers/net/wireless/uwe5622/unisocwcn/include/uwe562x_glb.h
new file mode 100644
index 000000000000..e063793c6912
--- /dev/null
+++ b/drivers/net/wireless/uwe5622/unisocwcn/include/uwe562x_glb.h
@@ -0,0 +1,419 @@
+#ifndef __UWE562X_GLB_H__
+#define __UWE562X_GLB_H__
+
+#include "../sleep/slp_mgr.h"
+
+static inline unsigned int reg_value(unsigned int marlin3reg,
+	unsigned int marlin3lreg, unsigned int marlin3ereg) {
+	if (wcn_get_chip_model() == WCN_CHIP_MARLIN3)
+		return marlin3reg;
+	else if (wcn_get_chip_model() == WCN_CHIP_MARLIN3L)
+		return marlin3lreg;
+	else if (wcn_get_chip_model() == WCN_CHIP_MARLIN3E)
+		return marlin3ereg;
+	else
+		return 0xFFFFFFFF;
+}
+
+#define SET_REG_VALUE(marlin3reg, marlin3lreg, marlin3ereg) \
+	reg_value(marlin3reg, marlin3lreg, marlin3ereg)
+
+/*********** for marlin3Lite only***********/
+#define APB_ENB1			0x4008801c
+#define DBG_CM4_EB			BIT(10)
+#define DAP_CTRL			0x4008828c
+#define CM4_DAP_SEL_BTWF_LITE		BIT(1)
+/******************************************/
+
+/* log buf size */
+#define MDBG_RX_RING_SIZE		(64*1024)
+
+#define CP_START_ADDR		0x40500000
+#define CP_RESET_REG_M3_M3L	0x40088288
+#define CP_RESET_REG_M3E	0x40930004
+#define CP_RESET_REG	SET_REG_VALUE(CP_RESET_REG_M3_M3L,\
+	CP_RESET_REG_M3_M3L, CP_RESET_REG_M3E)
+
+#define CP_SDIO_PRIORITY_ADDR 0x40130150
+
+/* set sdio higher priority to visit iram */
+#define M6_TO_S0_HIGH_PRIORITY 0X80000000
+
+#define PACKET_SIZE		(32*1024)
+/* time out in waiting wifi to come up */
+#define POWERUP_WAIT_MS	30000
+#define POWERUP_DELAY		200
+#define RESET_DELAY		1
+
+#define FIRMWARE_MAX_SIZE_M3L 0xe7400
+#define FIRMWARE_MAX_SIZE_M3_M3E 0xf0c00
+#define FIRMWARE_MAX_SIZE \
+	SET_REG_VALUE(FIRMWARE_MAX_SIZE_M3_M3E, FIRMWARE_MAX_SIZE_M3L,\
+	FIRMWARE_MAX_SIZE_M3_M3E)
+
+#define WIFI_REG 0x60300004
+
+#define CHIPID_REG_M3_M3L 0x4083c208
+#define CHIPID_REG_M3E 0x4082c208
+#define CHIPID_REG SET_REG_VALUE(CHIPID_REG_M3_M3L, CHIPID_REG_M3_M3L,\
+	CHIPID_REG_M3E)
+
+#define CALI_REG 0x70040000
+#define CALI_OFSET_REG 0x70040010
+
+#define MARLIN3_AA_CHIPID 0x23550000
+#define MARLIN3_AB_CHIPID 0x23550001
+#define MARLIN3_AC_CHIPID 0x23550002
+#define MARLIN3_AD_CHIPID 0x23550003
+
+#define MARLIN3L_AA_CHIPID 0x2355B000
+#define MARLIN3L_AB_CHIPID 0x2355B001
+#define MARLIN3L_AC_CHIPID 0x2355B002
+#define MARLIN3L_AD_CHIPID 0x2355B003
+
+#define MARLIN3E_AA_CHIPID 0x56630000
+#define MARLIN3E_AB_CHIPID 0x56630001
+#define MARLIN3E_AC_CHIPID 0x56630002
+#define MARLIN3E_AD_CHIPID 0x56630003
+
+#define CARD_DETECT_WAIT_MS	3000
+
+#define DCACHE_CMD_ISSUE_START 0X80000000
+#define DCACHE_CMD_CLEAN_ALL 0X00000000
+#define DCACHE_CMD_CLEAN_INVALID_ALL 0X00000008
+#define DCACHE_REG_BASE 0X401E0000
+#define DCACHE_REG_ENABLE (DCACHE_REG_BASE)
+#define DCACHE_CFG0 (DCACHE_REG_BASE + 0X0040)
+#define DCACHE_CMD_CFG2 (DCACHE_REG_BASE + 0X0058)
+#define DCACHE_INT_RAW_STS (DCACHE_REG_BASE + 0X0064)
+#define DCACHE_INT_CLR (DCACHE_REG_BASE + 0X006C)
+#define DCACHE_CMD_IRQ_CLR 0X00000001
+#define DCACHE_CMD_CFG2_MASK 0X8000003F
+#define DCACHE_ENABLE_MASK 0XFFFFFFFF
+#define DCACHE_DEBUG_EN 0X80000000
+#define DCACHE_SIZE_32K 0X3
+#define DCACHE_SIZE_SEL_MASK 0X30000000
+
+#define DUMP_PACKET_SIZE		(32 * 1024)
+#define DUMP_SDIO_ADDR			(0x40140000)
+#define DUMP_SDIO_ADDR_SIZE		(0x10000)
+/* for wifi */
+#define DUMP_WIFI_AON_MAC_ADDR			(0x400f0000)
+
+#define WIFI_AON_MAC_SIZE_M3L	(0x120)
+#define WIFI_AON_MAC_SIZE_M3_M3E	(0x108)
+#define DUMP_WIFI_REF_ADDR			(0x4083c000)
+#define DUMP_WIFI_REF_ADDR_SIZE			(0x350)
+#define DUMP_WIFI_RTN_PD_MAC_ADDR		(0x400f1000)
+#define DUMP_WIFI_RTN_PD_MAC_ADDR_SIZE		(0xD100)
+#define DUMP_WIFI_352K_RAM_ADDR			(0x40300000)
+#define DUMP_WIFI_AON_MAC_ADDR_SIZE		(0x108)
+#define DUMP_WIFI_352K_RAM_ADDR_SIZE		(0x58000)
+
+#define WIFI_RAM_SIZE_M3L	0x4a800
+#define WIFI_RAM_SIZE_M3_M3E	(0x58000)
+#define WIFI_GLB_REG_SIZE_M3L 0x58
+#define WIFI_GLB_REG_SIZE_M3_M3E	0x4c
+#define CHIP_SLP				(0X4083C00C)
+#define WIFI_WRAP_PWRON				(1 << 14)
+#define WIFI_PHY_PWRON				(1 << 15)
+#define WIFI_MAC_PWRON				(1 << 16)
+#define WIFI_ALL_PWRON	(WIFI_MAC_PWRON | WIFI_WRAP_PWRON)
+#define PD_WIFI_AON_CFG4			(0x4083c088)
+#define PD_WIFI_MAC_AON_CFG4			(0X4083C0A8)
+#define PD_WIFI_PHY_AON_CFG4			(0x4083C0B8)
+#define WIFI_MAC_RTN_SLEEPPS_CTL		(0x400f4704)
+#define WIFI_RETENTION				(1 << 0)
+#define WIFI_WRAP_PWR_DOWN			(1 << 1)
+#define WIFI_MAC_PWR_DOWN			(1 << 2)
+#define WIFI_PHY_PWR_DOWN			(1 << 2)
+#define WIFI_ENABLE				(0x40130004)
+#define AHB_EB0					(0x40130004)
+#define WIFI_EN					(1 << 5)
+#define BT_EN					(1 << 4)
+#define WIFI_MAC_EN				(1 << 9)
+#define WIFI_ALL_EN		(WIFI_EN | WIFI_MAC_EN)
+#define CLK_CTRL0			0x4083c040
+#define APLL_PDN			(1 << 0)
+#define BPLL_PDN			(1 << 1)
+
+/* AON_APB */
+#define CLK_CTL3			0x4083c04c
+#define BT_32M_EB			(1 << 18)
+#define BT_64M_EB			(1 << 19)
+
+/* for BT */
+#define BT_ACC_ADDR			(0x40240000)
+
+#define BT_ACC_SIZE_M3L		(0x8f4)
+#define BT_ACC_SIZE_M3_M3E	(0x8d8)
+#define BT_ACC_SIZE SET_REG_VALUE(BT_ACC_SIZE_M3_M3E, BT_ACC_SIZE_M3L,\
+	BT_ACC_SIZE_M3_M3E)
+#define BT_JAL_ADDR			(0x40246000)
+#define BT_JAL_SIZE			(0x738)
+#define BT_HAB_ADDR			(0x40248000)
+#define BT_HAB_SIZE			(0xA0)
+#define BT_LEJAL_ADDR			(0x4024A000)
+#define BT_LEJAL_SIZE			(0x21C)
+#define BT_MODEM_ADDR			(0x4024F000)
+
+#define BT_MODEM_SIZE_M3L		(0x310)
+#define BT_MODEM_SIZE_M3_M3E	(0x300)
+#define BT_MODEM_SIZE SET_REG_VALUE(BT_MODEM_SIZE_M3_M3E, BT_MODEM_SIZE_M3L,\
+	BT_MODEM_SIZE_M3_M3E)
+
+/* for BT (HW DEC and BB) Buffer */
+#define HCI_ARM_WR_RD_MODE		(0x40240600)
+#define HCI_ARM_WR_RD_VALUE		(0xFFFF)
+
+#define BT_CMD_BUF_ADDR		(0x40200000)
+#define BT_CMD_BUF_SIZE		(0x200)
+#define BT_EVENT_BUF_ADDR		(0x40204000)
+#define BT_EVENT_BUF_SIZE		(0x200)
+#define BT_LMP_TX_BUF_ADDR		(0x40208000)
+#define BT_LMP_TX_BUF_SIZE		(0x12A4)
+#define BT_LMP_RX_BUF_ADDR		(0x40200C00)
+#define BT_LMP_RX_BUF_SIZE		(0xB744)
+#define BT_ACL_TX_BUF_ADDR		(0x40210000)
+#define BT_ACL_TX_BUF_SIZE		(0x3000)
+#define BT_ACL_RX_BUF_ADDR		(0x40214000)
+#define BT_ACL_RX_BUF_SIZE		(0x3000)
+#define BT_SCO_TX_BUF_ADDR		(0x40218000)
+#define BT_SCO_TX_BUF_SIZE		(0x2D0)
+#define BT_SCO_RX_BUF_ADDR		(0x4021C000)
+#define BT_SCO_RX_BUF_SIZE		(0x5C0)
+#define BT_BB_TX_BUF_ADDR		(0x40241000)
+#define BT_BB_TX_BUF_SIZE		(0x400)
+#define BT_BB_RX_BUF_ADDR		(0x40242000)
+#define BT_BB_RX_BUF_SIZE		(0x400)
+
+#define DUMP_BT_ADDR			(0)
+#define DUMP_BT_ADDR_SIZE		(0)
+/* for fm */
+#define DUMP_FM1_ADDR			(0x40098000)
+#define DUMP_FM1_ADDR_SIZE		(0x238)
+#define DUMP_FM_RDS_ADDR		(0x40098800)
+#define DUMP_FM_RDS_ADDR_SIZE		(0x4c)
+#define DUMP_FM_ADDR			(0x40098000)
+#define DUMP_FM_ADDR_SIZE		(0xabc)
+
+#define DUMP_INTC_ADDR			(0)
+#define DUMP_SYSTIMER_ADDR		(0)
+/* need check, not need to dump it */
+#define DUMP_WDG_ADDR			0
+#define DUMP_WIFI_ADDR			0
+#define DUMP_WIFI_ADDR_SIZE		0
+#define DUMP_BT_CMD_ADDR		0
+#define DUMP_BT_CMD_ADDR_SIZE	0
+
+/* For TOP */
+#define AON_AHB_ADDR			(0x40880000)
+#define AON_AHB_SIZE			(0x54)
+#define AON_APB_ADDR			(0x4083C000)
+#define AON_APB_SIZE			(0x354)
+#define BTWF_AHB_ADDR			(0x40130000)
+#define BTWF_AHB_SIZE			(0x400)
+#define BTWF_APB_ADDR			(0x40088000)
+#define BTWF_APB_SIZE			(0x28C)
+#define AON_CLK_ADDR			(0x40844200)
+#define AON_CLK_SIZE			(0x144)
+#define PRE_DIV_CLK_ADDR		(0x40844000)
+#define PRE_DIV_CLK_SIZE		(0x48)
+
+#define DUMP_APB_ADDR			(0)
+#define DUMP_DMA_ADDR			(0)
+#define DUMP_AHB_ADDR			(0)
+#define DUMP_REG_SIZE			(0X10000)
+
+#define SMP_HEADERFLAG 0X7E7E7E7E
+#define SMP_RESERVEDFLAG 0X5A5A
+#define SMP_DSP_CHANNEL_NUM 0X88
+#define SMP_DSP_TYPE 0X9D
+#define SMP_DSP_DUMP_TYPE 0X32
+
+#define SYSNC_CODE_LEN 0X4
+#define CHKSUM_LEN 0X2
+#define ARMLOG_HEAD 9
+
+/* For GNSS */
+#define GNSS_CP_START_ADDR_M3L 0x40A50000
+#define GNSS_CP_START_ADDR_M3_M3E	0x40A20000
+#define GNSS_CP_START_ADDR \
+	SET_REG_VALUE(GNSS_CP_START_ADDR_M3_M3E, GNSS_CP_START_ADDR_M3L,\
+	GNSS_CP_START_ADDR_M3_M3E)\
+
+#define GNSS_CP_RESET_REG	0x40BC8280
+//#define GNSS_FIRMWARE_MAX_SIZE 0x58000
+#define GNSS_FIRMWARE_MAX_SIZE_M3L 0x2B000
+#define GNSS_FIRMWARE_MAX_SIZE_M3_M3E 0x58000
+#define	GNSS_FIRMWARE_MAX_SIZE \
+	SET_REG_VALUE(GNSS_FIRMWARE_MAX_SIZE_M3_M3E,\
+	GNSS_FIRMWARE_MAX_SIZE_M3L, GNSS_FIRMWARE_MAX_SIZE_M3_M3E)\
+
+#define GNSS_CHIPID_REG 0x603003fc
+
+/* For MARLIN3 DCACHE */
+#define DCACHE_CMD_ISSUE_START 0X80000000
+#define DCACHE_CMD_CLEAN_ALL 0X00000000
+#define DCACHE_CMD_CLEAN_INVALID_ALL 0X00000008
+#define DCACHE_REG_BASE 0X401E0000
+#define DCACHE_CFG0 (DCACHE_REG_BASE + 0X0040)
+#define DCACHE_CMD_CFG2 (DCACHE_REG_BASE + 0X0058)
+#define DCACHE_INT_RAW_STS (DCACHE_REG_BASE + 0X0064)
+#define DCACHE_INT_CLR (DCACHE_REG_BASE + 0X006C)
+#define DCACHE_CMD_IRQ_CLR 0X00000001
+#define DCACHE_CMD_CFG2_MASK 0X8000003F
+#define DCACHE_DEBUG_EN 0X80000000
+#define DCACHE_SIZE_32K 0X3
+#define DCACHE_SIZE_SEL_MASK 0X30000000
+
+
+/* For MARLIN3 MEM PD  */
+#define CTL_BASE_AON_APB 0X4083C000
+#define REG_AON_APB_CHIP_MEM_AUTO_EN (CTL_BASE_AON_APB + 0X0198)
+#define REG_AON_APB_BTWF_MEM_CGG1 (CTL_BASE_AON_APB + 0X010C)
+/* SHUTDOWN IRAM [0...15]*32K=512K,FORCE SHUTDOWN IRAM [16...31]*32K=512K */
+#define REG_AON_APB_BTWF_MEM_CGG2 (CTL_BASE_AON_APB + 0X0110)
+/* RETENTION IRAM [0...15]*32K=512K,FORCE RETENTION IRAM [16...31]*32K=512K */
+#define REG_AON_APB_BTWF_MEM_CGG3 (CTL_BASE_AON_APB + 0X0114)
+/* SHUTDOWN IRAM [0...13]*32K=448K,[14]mean 3k; */
+#define REG_AON_APB_BTWF_MEM_CGG4 (CTL_BASE_AON_APB + 0X0118)
+
+
+/* for dump arm register */
+#define AON_APB_BASE_ADDR 0X4083C000
+
+#define ARM_DAP_BASE_ADDR_M3L 0X40060000
+#define ARM_DAP_REG1_M3L 0X40060000
+#define ARM_DAP_REG2_M3L 0X40060004
+#define ARM_DAP_REG3_M3L 0X4006000C
+#define ARM_DAP_BASE_ADDR_M3_M3E 0X4085C000
+#define ARM_DAP_REG1_M3_M3E 0X4085C000
+#define ARM_DAP_REG2_M3_M3E 0X4085C004
+#define ARM_DAP_REG3_M3_M3E 0X4085C00C
+#define ARM_DAP_REG1 SET_REG_VALUE(ARM_DAP_REG1_M3_M3E, ARM_DAP_REG1_M3L,\
+	ARM_DAP_REG1_M3_M3E)
+#define ARM_DAP_REG2 SET_REG_VALUE(ARM_DAP_REG2_M3_M3E, ARM_DAP_REG2_M3L,\
+	ARM_DAP_REG2_M3_M3E)
+#define ARM_DAP_REG3 SET_REG_VALUE(ARM_DAP_REG3_M3_M3E, ARM_DAP_REG3_M3L,\
+	ARM_DAP_REG3_M3_M3E)
+
+#define BTWF_STATUS_REG_M3L 0x400600fc
+#define BTWF_STATUS_REG_M3_M3E 0x4085c0fc
+#define BTWF_STATUS_REG SET_REG_VALUE(BTWF_STATUS_REG_M3_M3E, \
+	BTWF_STATUS_REG_M3L, BTWF_STATUS_REG_M3_M3E)
+
+#define BTWF_OK_VALUE 0x24770011
+#define GNSS_OK 0x408600fc
+
+#define DJTAG_DAP_SEL (AON_APB_BASE_ADDR + 0X0064)
+#define APB_RST (AON_APB_BASE_ADDR + 0x0000)
+#define APB_EB  (AON_APB_BASE_ADDR + 0x0024)
+#define CM4_DAP_SEL_BTWF 0X00000001	/* bit0 */
+#define CM4_DAP_SEL_GNSS 0X00000002	/* bit1 */
+#define CM4_DAP0_SOFT_RST 0X10000000	/* BIT28 */
+#define CM4_DAP1_SOFT_RST 0X20000000	/* BIT29 */
+#define CM4_DAP0_EB 0X40000000	/* BIT30 */
+#define CM4_DAP1_EB 0X80000000	/* BIT31 */
+
+#define PD_GNSS_SS_AON_CFG4 (AON_APB_BASE_ADDR + 0X00c8)
+#define PD_AUTO_EN		(1 << 12)
+#define FORCE_DEEP_SLEEP	(1 << 3)
+#define GNSS_SS_POWER_DOWN	(1 << 2)/* NO USE */
+#define CHIP_DEEP_SLP_EN	(1 << 1)
+
+#define SYNC_ADDR_M3		0x405F0BB0
+#define SYNC_ADDR_M3L		0x405E73B0
+#define SYNC_ADDR_M3E		0x40525FA0
+#define SYNC_ADDR SET_REG_VALUE(SYNC_ADDR_M3, SYNC_ADDR_M3L, SYNC_ADDR_M3E)
+
+#define SYNC_IN_PROGRESS	0xF0F0F0F0
+#define SYNC_CALI_WAITING	0xF0F0F0F1
+#define SYNC_CALI_WRITE_DONE	0xF0F0F0F2
+#define SYNC_CALI_FINISHED	0xF0F0F0F3
+#define SYNC_SDIO_REINIT_DONE	0xF0F0F0F4
+#define SYNC_SDIO_IS_READY	0xF0F0F0F5
+#define SYNC_VERIFY_WAITING	0xF0F0F0F6
+#define SYNC_VERIFY_WRITE_DONE	0xF0F0F0F7
+#define SYNC_VERIFY_FINISHED	0xF0F0F0F8
+#define SYNC_ALL_FINISHED	0xF0F0F0FF
+#define CHIP_SLP_REG		(AON_APB_BASE_ADDR + 0X000c)
+#define GNSS_SS_PWRON_FINISH	(1 << 12)
+#define GNSS_PWR_FINISH	(1 << 13)
+
+#define CGM_GNSS_FAKE_CFG (0x40844200 + 0X0104)
+#define CGM_GNSS_FAKE_SEL (0x3)
+
+/* for sleep/wakeup */
+#define REG_CP_SLP_CTL_M3_M3L	0x1a2
+#define REG_CP_SLP_CTL_M3E		0x1aa
+#define REG_CP_SLP_CTL SET_REG_VALUE(REG_CP_SLP_CTL_M3_M3L,\
+	REG_CP_SLP_CTL_M3_M3L, REG_CP_SLP_CTL_M3E)
+
+/***************for marlin3E only*****************/
+#define REG_CP_RST_CHIP		0x1a8
+#define REG_CP_PMU_SEL_CTL	0x1a3
+#define BTWF_XLT_WAIT		0x1
+#define BTWF_XLTBUF_WAIT	0x2
+#define BTWF_PLL_PWR_WAIT	0x4
+#define BTWF_XLT_WAIT_M3L		0x10
+#define BTWF_XLTBUF_WAIT_M3L	0x20
+#define BTWF_PLL_PWR_WAIT_M3L	0x40
+/**************************************************/
+
+#define REG_AP_INT_CP0		0x1b0
+#define REG_PUB_INT_EN0		0x1c0
+#define REG_PUB_INT_CLR0	0x1d0
+#define REG_PUB_INT_STS0	0x1f0
+/* BIT4~7, if value 0, stand for in deepsleep */
+#define REG_BTWF_SLP_STS_M3_M3L	0x148
+#define REG_BTWF_SLP_STS_M3E	0x143
+#define REG_BTWF_SLP_STS SET_REG_VALUE(REG_BTWF_SLP_STS_M3_M3L,\
+	REG_BTWF_SLP_STS_M3_M3L, REG_BTWF_SLP_STS_M3E)
+
+#define BTWF_IN_DEEPSLEEP	0x0
+/* fm playing in deep, and xtl on */
+#define BTWF_IN_DEEPSLEEP_XLT_ON_M3_M3L	0x30
+#define BTWF_IN_DEEPSLEEP_XLT_ON_M3E	0x3
+#define BTWF_IN_DEEPSLEEP_XLT_ON SET_REG_VALUE(BTWF_IN_DEEPSLEEP_XLT_ON_M3_M3L,\
+	BTWF_IN_DEEPSLEEP_XLT_ON_M3_M3L, BTWF_IN_DEEPSLEEP_XLT_ON_M3E)
+
+#define SLEEP_STATUS_FLAG_M3_M3L	0xF0
+#define SLEEP_STATUS_FLAG_M3E     0x0F
+#define SLEEP_STATUS_FLAG SET_REG_VALUE(SLEEP_STATUS_FLAG_M3_M3L, \
+	SLEEP_STATUS_FLAG_M3_M3L, SLEEP_STATUS_FLAG_M3E)
+
+/* For power save */
+#define REG_WIFI_MEM_CFG1	0x4083c130
+#define FORCE_SHUTDOWN_BTRAM	(1 << 22)
+
+/* For FM Spue freq */
+#define FM_REG_SPUR_FEQ1_ADDR			0x40098104
+#define FM_DISABLE_SPUR_REMOVE_VALUE		0x06DC063C
+#define FM_ENABLE_SPUR_REMOVE_FREQ2_VALUE	0x06DCAB7C
+
+/*
+ * For SPI interface
+ * bit[15]:1'b0: TCXO mode, outside clock
+ * bit[15]:1'b1: Crystal/TSX mode
+ */
+#define SPI_BASE_ADDR		0x408a0000
+#define AD_DCXO_BONDING_OPT	0x5030
+#define tsx_mode		(1 << 15)
+#define SPI_BIT31		(1 << 31)
+
+#define AON_APB_BOOT_CAUSE_FLAG_REG_M3E	0x4082C3A8
+#define AON_APB_TEST_READ_REG	SET_REG_VALUE(AON_APB_BASE_ADDR,\
+	AON_APB_BASE_ADDR, AON_APB_BOOT_CAUSE_FLAG_REG_M3E)
+
+#define RESET_BIT_M3E		(1<<20)
+#define RESET_BIT_M3_M3L	(1<<0)
+#define RESET_BIT SET_REG_VALUE(RESET_BIT_M3_M3L, RESET_BIT_M3_M3L,\
+	RESET_BIT_M3E)
+
+/*For sync cp status when wakeup, only for marlin3e */
+#define CP_M5_STOP		0x4093000c
+#define CP_WAKE_STATUS	CP_M5_STOP
+#define IS_BYPASS_WAKE(addr) ((addr == CP_WAKE_STATUS) ? true : false)
+
+#endif //EOF __UWE562X_GLB_H__
diff --git a/drivers/net/wireless/uwe5622/unisocwcn/include/wcn_bus.h b/drivers/net/wireless/uwe5622/unisocwcn/include/wcn_bus.h
new file mode 100644
index 000000000000..95ad9b55a66d
--- /dev/null
+++ b/drivers/net/wireless/uwe5622/unisocwcn/include/wcn_bus.h
@@ -0,0 +1,605 @@
+#ifndef __WCN_BUS_H__
+#define __WCN_BUS_H__
+
+#define HW_TYPE_SDIO 0
+#define HW_TYPE_PCIE 1
+#define HW_TYPE_SIPC 2
+#define HW_TYPE_USB 3
+#define CHN_MAX_NUM 32
+
+#ifdef CONFIG_SDIOHAL
+#define PUB_HEAD_RSV 4
+#else
+#define PUB_HEAD_RSV 0
+#endif
+
+enum WCN_VENDOR_ID {
+	/* NOT pull chipen, NOT reset sdio after resume. */
+	WCN_VENDOR_DEFAULT = 0,
+	/* PULL chipen after resume. */
+	WCN_VENDOR_RESUME_POWER_DOWN,
+	/* NOT pull chipen, reset sdio after resume. */
+	WCN_VENDOR_RESUME_KEEPPWR_RESETSDIO,
+
+	WCN_VENDOR_MAX = 8
+};
+
+enum slp_subsys {
+	PACKER_TX = 0,
+	PACKER_RX,
+	PACKER_DT_TX,
+	PACKER_DT_RX,
+	DT_WRITEL,
+	DT_READL,
+	DT_WRITE,
+	DT_READ,
+	WIFI,
+	DOWNLOAD,
+	DBG_TOOL,
+	SUBSYS_MAX,
+};
+
+struct mbuf_t {
+	struct mbuf_t *next;
+	unsigned char *buf;
+	unsigned long  phy;
+	unsigned short len;
+	unsigned short rsvd;
+	unsigned int   seq;
+};
+
+struct mchn_ops_t {
+	int channel;
+	/* hardware interface type */
+	int hif_type;
+	/* inout=1 tx side, inout=0 rx side */
+	int inout;
+	/* set callback pop_link/push_link frequency */
+	int intr_interval;
+	/* data buffer size */
+	int buf_size;
+	/* mbuf pool size */
+	int pool_size;
+	/* The large number of trans */
+	int once_max_trans;
+	/* rx side threshold */
+	int rx_threshold;
+	/* tx timeout */
+	int timeout;
+	/* callback in top tophalf */
+	int cb_in_irq;
+	/* pending link num */
+	int max_pending;
+	/*
+	 * pop link list, (1)chn id, (2)mbuf link head
+	 * (3) mbuf link tail (4)number of node
+	 */
+	int (*pop_link)(int, struct mbuf_t *, struct mbuf_t *, int);
+	/* ap don't need to implementation */
+	int (*push_link)(int, struct mbuf_t **, struct mbuf_t **, int *);
+	/* (1)channel id (2)trans time, -1 express timeout */
+	int (*tx_complete)(int, int);
+	int (*power_notify)(int, int);
+};
+
+struct sdio_puh_t {
+#ifdef CONFIG_SDIOM
+	unsigned int pad:7;
+#else
+	unsigned int pad:6;
+	unsigned int check_sum:1;
+#endif
+	unsigned int len:16;
+	unsigned int eof:1;
+	unsigned int subtype:4;
+	unsigned int type:4;
+}; /* 32bits public header */
+
+struct bus_puh_t {
+#ifdef CONFIG_SDIOM
+	unsigned int pad:7;
+#else
+	unsigned int pad:6;
+	unsigned int check_sum:1;
+#endif
+	unsigned int len:16;
+	unsigned int eof:1;
+	unsigned int subtype:4;
+	unsigned int type:4;
+}; /* 32bits public header */
+
+struct sprdwcn_bus_ops {
+	int (*preinit)(void);
+	void (*deinit)(void);
+
+	int (*chn_init)(struct mchn_ops_t *ops);
+	int (*chn_deinit)(struct mchn_ops_t *ops);
+
+	/*
+	 * For sdio:
+	 * list_alloc and list_free only tx available.
+	 * TX: module manage buf, RX: SDIO unified manage buf
+	 */
+	int (*list_alloc)(int chn, struct mbuf_t **head,
+			  struct mbuf_t **tail, int *num);
+	int (*list_free)(int chn, struct mbuf_t *head,
+			 struct mbuf_t *tail, int num);
+
+	/* For sdio: TX(send data) and RX(give back list to SDIO) */
+	int (*push_list)(int chn, struct mbuf_t *head,
+			 struct mbuf_t *tail, int num);
+	int (*push_list_direct)(int chn, struct mbuf_t *head,
+			 struct mbuf_t *tail, int num);
+	unsigned char (*get_tx_mode)(void);
+	unsigned char (*get_rx_mode)(void);
+	unsigned char (*get_irq_type)(void);
+	unsigned int (*get_blk_size)(void);
+
+	/*
+	 * for pcie
+	 * push link list, Using a blocking mode,
+	 * Timeout wait for tx_complete
+	 */
+	int (*push_link_wait_complete)(int chn, struct mbuf_t *head,
+				       struct mbuf_t *tail, int num,
+				       int timeout);
+	int (*hw_pop_link)(int chn, void *head, void *tail, int num);
+	int (*hw_tx_complete)(int chn, int timeout);
+	int (*hw_req_push_link)(int chn, int need);
+
+	int (*direct_read)(unsigned int addr, void *buf, unsigned int len);
+	int (*direct_write)(unsigned int addr, void *buf, unsigned int len);
+
+	int (*readbyte)(unsigned int addr, unsigned char *val);
+	int (*writebyte)(unsigned int addr, unsigned char val);
+
+	int (*write_l)(unsigned int system_addr, void *buf);
+	int (*read_l)(unsigned int system_addr, void *buf);
+
+	unsigned int (*get_carddump_status)(void);
+	void (*set_carddump_status)(unsigned int flag);
+	unsigned long long (*get_rx_total_cnt)(void);
+
+	/* for runtime */
+	int (*runtime_get)(void);
+	int (*runtime_put)(void);
+
+	int (*rescan)(void);
+	void (*register_rescan_cb)(void *);
+	void (*remove_card)(void);
+	/* for module to know hif_type */
+	int (*get_hif_type)(void);
+	int (*driver_register)(void);
+	void (*driver_unregister)(void);
+	void (*allow_sleep)(enum slp_subsys subsys);
+	void (*sleep_wakeup)(enum slp_subsys subsys);
+
+	/* for usb check cp status */
+	int (*check_cp_ready)(unsigned int addr, int timeout);
+};
+
+extern void module_bus_init(void);
+extern void module_bus_deinit(void);
+extern struct sprdwcn_bus_ops *get_wcn_bus_ops(void);
+
+static inline
+int sprdwcn_bus_get_hif_type(void)
+{
+	struct sprdwcn_bus_ops *bus_ops = get_wcn_bus_ops();
+
+	if (!bus_ops || !bus_ops->get_hif_type)
+		return 0;
+
+	return bus_ops->get_hif_type();
+}
+
+static inline
+int sprdwcn_bus_preinit(void)
+{
+	struct sprdwcn_bus_ops *bus_ops = get_wcn_bus_ops();
+
+	if (!bus_ops || !bus_ops->preinit)
+		return 0;
+
+	return bus_ops->preinit();
+}
+
+static inline
+void sprdwcn_bus_deinit(void)
+{
+	struct sprdwcn_bus_ops *bus_ops = get_wcn_bus_ops();
+
+	if (!bus_ops || !bus_ops->deinit)
+		return;
+
+	bus_ops->deinit();
+}
+
+static inline
+int sprdwcn_bus_chn_init(struct mchn_ops_t *ops)
+{
+	struct sprdwcn_bus_ops *bus_ops = get_wcn_bus_ops();
+
+	if (!bus_ops || !bus_ops->chn_init)
+		return 0;
+
+	return bus_ops->chn_init(ops);
+}
+
+static inline
+int sprdwcn_bus_chn_deinit(struct mchn_ops_t *ops)
+{
+	struct sprdwcn_bus_ops *bus_ops = get_wcn_bus_ops();
+
+	if (!bus_ops || !bus_ops->chn_deinit)
+		return 0;
+
+	return bus_ops->chn_deinit(ops);
+}
+
+static inline
+int sprdwcn_bus_list_alloc(int chn, struct mbuf_t **head,
+			   struct mbuf_t **tail, int *num)
+{
+	struct sprdwcn_bus_ops *bus_ops = get_wcn_bus_ops();
+
+	if (!bus_ops || !bus_ops->list_alloc)
+		return 0;
+
+	return bus_ops->list_alloc(chn, head, tail, num);
+}
+
+static inline
+int sprdwcn_bus_list_free(int chn, struct mbuf_t *head,
+			  struct mbuf_t *tail, int num)
+{
+	struct sprdwcn_bus_ops *bus_ops = get_wcn_bus_ops();
+
+	if (!bus_ops || !bus_ops->list_free)
+		return 0;
+
+	return bus_ops->list_free(chn, head, tail, num);
+}
+
+static inline
+int sprdwcn_bus_push_list(int chn, struct mbuf_t *head,
+			  struct mbuf_t *tail, int num)
+{
+	struct sprdwcn_bus_ops *bus_ops = get_wcn_bus_ops();
+
+	if (!bus_ops || !bus_ops->push_list)
+		return 0;
+
+	return bus_ops->push_list(chn, head, tail, num);
+}
+
+static inline
+int sprdwcn_bus_push_list_direct(int chn, struct mbuf_t *head,
+				 struct mbuf_t *tail, int num)
+{
+	struct sprdwcn_bus_ops *bus_ops = get_wcn_bus_ops();
+
+	if (!bus_ops || !bus_ops->push_list_direct)
+		return 0;
+
+	return bus_ops->push_list_direct(chn, head, tail, num);
+}
+
+static inline
+int sprdwcn_bus_push_link_wait_complete(int chn, struct mbuf_t *head,
+					struct mbuf_t *tail, int num,
+					int timeout)
+{
+	struct sprdwcn_bus_ops *bus_ops = get_wcn_bus_ops();
+
+	if (!bus_ops || !bus_ops->push_link_wait_complete)
+		return 0;
+
+	return bus_ops->push_link_wait_complete(chn, head,
+						    tail, num, timeout);
+}
+
+static inline
+int sprdwcn_bus_hw_pop_link(int chn, void *head, void *tail, int num)
+{
+	struct sprdwcn_bus_ops *bus_ops = get_wcn_bus_ops();
+
+	if (!bus_ops || !bus_ops->hw_pop_link)
+		return 0;
+
+	return bus_ops->hw_pop_link(chn, head, tail, num);
+}
+
+static inline
+int sprdwcn_bus_hw_tx_complete(int chn, int timeout)
+{
+	struct sprdwcn_bus_ops *bus_ops = get_wcn_bus_ops();
+
+	if (!bus_ops || !bus_ops->hw_tx_complete)
+		return 0;
+
+	return bus_ops->hw_tx_complete(chn, timeout);
+}
+
+static inline
+int sprdwcn_bus_hw_req_push_link(int chn, int need)
+{
+	struct sprdwcn_bus_ops *bus_ops = get_wcn_bus_ops();
+
+	if (!bus_ops || !bus_ops->hw_req_push_link)
+		return 0;
+
+	return bus_ops->hw_req_push_link(chn, need);
+}
+
+static inline
+int sprdwcn_bus_direct_read(unsigned int addr,
+			    void *buf, unsigned int len)
+{
+	struct sprdwcn_bus_ops *bus_ops = get_wcn_bus_ops();
+
+	if (!bus_ops || !bus_ops->direct_read)
+		return 0;
+
+	return bus_ops->direct_read(addr, buf, len);
+}
+
+static inline
+int sprdwcn_bus_direct_write(unsigned int addr,
+			     void *buf, unsigned int len)
+{
+	struct sprdwcn_bus_ops *bus_ops = get_wcn_bus_ops();
+
+	if (!bus_ops || !bus_ops->direct_write)
+		return 0;
+
+	return bus_ops->direct_write(addr, buf, len);
+}
+
+static inline
+int sprdwcn_bus_reg_read(unsigned int addr,
+			    void *buf, unsigned int len)
+{
+	struct sprdwcn_bus_ops *bus_ops = get_wcn_bus_ops();
+
+	if (!bus_ops || !bus_ops->read_l)
+		return 0;
+
+	return bus_ops->read_l(addr, buf);
+}
+
+static inline
+int sprdwcn_bus_reg_write(unsigned int addr,
+			     void *buf, unsigned int len)
+{
+	struct sprdwcn_bus_ops *bus_ops = get_wcn_bus_ops();
+
+	if (!bus_ops || !bus_ops->write_l)
+		return 0;
+
+	return bus_ops->write_l(addr, buf);
+}
+
+static inline
+int sprdwcn_bus_aon_readb(unsigned int addr, unsigned char *val)
+{
+	struct sprdwcn_bus_ops *bus_ops = get_wcn_bus_ops();
+
+	if (!bus_ops || !bus_ops->readbyte)
+		return 0;
+
+	return bus_ops->readbyte(addr, val);
+}
+
+static inline
+int sprdwcn_bus_aon_writeb(unsigned int addr, unsigned char val)
+{
+	struct sprdwcn_bus_ops *bus_ops = get_wcn_bus_ops();
+
+	if (!bus_ops || !bus_ops->writebyte)
+		return 0;
+
+	return bus_ops->writebyte(addr, val);
+}
+
+static inline
+unsigned int sprdwcn_bus_get_carddump_status(void)
+{
+	struct sprdwcn_bus_ops *bus_ops = get_wcn_bus_ops();
+
+	if (!bus_ops || !bus_ops->get_carddump_status)
+		return 0;
+
+	return bus_ops->get_carddump_status();
+}
+
+static inline
+void sprdwcn_bus_set_carddump_status(unsigned int flag)
+{
+	struct sprdwcn_bus_ops *bus_ops = get_wcn_bus_ops();
+
+	if (!bus_ops || !bus_ops->set_carddump_status)
+		return;
+
+	bus_ops->set_carddump_status(flag);
+}
+
+static inline
+unsigned long long sprdwcn_bus_get_rx_total_cnt(void)
+{
+	struct sprdwcn_bus_ops *bus_ops = get_wcn_bus_ops();
+
+	if (!bus_ops || !bus_ops->get_rx_total_cnt)
+		return 0;
+
+	return bus_ops->get_rx_total_cnt();
+}
+
+static inline
+int sprdwcn_bus_runtime_get(void)
+{
+	struct sprdwcn_bus_ops *bus_ops = get_wcn_bus_ops();
+
+	if (!bus_ops || !bus_ops->runtime_get)
+		return 0;
+
+	return bus_ops->runtime_get();
+}
+
+static inline
+int sprdwcn_bus_runtime_put(void)
+{
+	struct sprdwcn_bus_ops *bus_ops = get_wcn_bus_ops();
+
+	if (!bus_ops || !bus_ops->runtime_put)
+		return 0;
+
+	return bus_ops->runtime_put();
+}
+
+static inline
+int sprdwcn_bus_rescan(void)
+{
+	struct sprdwcn_bus_ops *bus_ops = get_wcn_bus_ops();
+
+	if (!bus_ops || !bus_ops->rescan)
+		return 0;
+
+	return bus_ops->rescan();
+}
+
+static inline
+void sprdwcn_bus_register_rescan_cb(void *func)
+{
+	struct sprdwcn_bus_ops *bus_ops = get_wcn_bus_ops();
+
+	if (!bus_ops || !bus_ops->register_rescan_cb)
+		return;
+
+	bus_ops->register_rescan_cb(func);
+}
+
+static inline
+void sprdwcn_bus_remove_card(void)
+{
+	struct sprdwcn_bus_ops *bus_ops = get_wcn_bus_ops();
+
+	if (!bus_ops || !bus_ops->remove_card)
+		return;
+
+	bus_ops->remove_card();
+}
+
+static inline
+unsigned char sprdwcn_bus_get_tx_mode(void)
+{
+	struct sprdwcn_bus_ops *bus_ops = get_wcn_bus_ops();
+
+	if (!bus_ops || !bus_ops->get_tx_mode)
+		return 0;
+
+	return bus_ops->get_tx_mode();
+}
+
+static inline
+unsigned char sprdwcn_bus_get_rx_mode(void)
+{
+	struct sprdwcn_bus_ops *bus_ops = get_wcn_bus_ops();
+
+	if (!bus_ops || !bus_ops->get_rx_mode)
+		return 0;
+
+	return bus_ops->get_rx_mode();
+}
+
+static inline
+unsigned char sprdwcn_bus_get_irq_type(void)
+{
+	struct sprdwcn_bus_ops *bus_ops = get_wcn_bus_ops();
+
+	if (!bus_ops || !bus_ops->get_irq_type)
+		return 0;
+
+	return bus_ops->get_irq_type();
+}
+
+static inline
+unsigned int sprdwcn_bus_get_blk_size(void)
+{
+	struct sprdwcn_bus_ops *bus_ops = get_wcn_bus_ops();
+
+	if (!bus_ops || !bus_ops->get_blk_size)
+		return 0;
+
+	return bus_ops->get_blk_size();
+}
+
+static inline
+void sprdwcn_bus_allow_sleep(enum slp_subsys subsys)
+{
+	struct sprdwcn_bus_ops *bus_ops = get_wcn_bus_ops();
+
+	if (!bus_ops || !bus_ops->allow_sleep)
+		return;
+
+	bus_ops->allow_sleep(subsys);
+}
+
+static inline
+void sprdwcn_bus_sleep_wakeup(enum slp_subsys subsys)
+{
+	struct sprdwcn_bus_ops *bus_ops = get_wcn_bus_ops();
+
+	if (!bus_ops || !bus_ops->sleep_wakeup)
+		return;
+
+	bus_ops->sleep_wakeup(subsys);
+}
+
+static inline
+int sprdwcn_bus_driver_register(void)
+{
+	struct sprdwcn_bus_ops *bus_ops = get_wcn_bus_ops();
+
+	if (!bus_ops || !bus_ops->driver_register)
+		return 0;
+
+	return bus_ops->driver_register();
+}
+
+static inline
+void sprdwcn_bus_driver_unregister(void)
+{
+	struct sprdwcn_bus_ops *bus_ops = get_wcn_bus_ops();
+
+	if (!bus_ops || !bus_ops->driver_unregister)
+		return;
+
+	bus_ops->driver_unregister();
+}
+
+static inline
+int sprdwcn_check_cp_ready(unsigned int addr, int timeout)
+{
+	struct sprdwcn_bus_ops *bus_ops = get_wcn_bus_ops();
+
+	if (!bus_ops || !bus_ops->check_cp_ready)
+		return 0;
+
+	return bus_ops->check_cp_ready(addr, timeout);
+}
+
+static inline
+int wcn_bus_init(void)
+{
+	module_bus_init();
+	return 0;
+}
+
+static inline
+void wcn_bus_deinit(void)
+{
+	module_bus_deinit();
+}
+
+#endif
diff --git a/drivers/net/wireless/uwe5622/unisocwcn/include/wcn_glb.h b/drivers/net/wireless/uwe5622/unisocwcn/include/wcn_glb.h
new file mode 100644
index 000000000000..5b29eac42aa8
--- /dev/null
+++ b/drivers/net/wireless/uwe5622/unisocwcn/include/wcn_glb.h
@@ -0,0 +1,26 @@
+#ifndef __WCN_GLB_H__
+#define __WCN_GLB_H__
+
+#include <marlin_platform.h>
+#include "wcn_txrx.h"
+
+#ifndef CONFIG_CHECK_DRIVER_BY_CHIPID
+#ifdef CONFIG_UWE5621
+#include "uwe5621_glb.h"
+#endif
+
+#ifdef CONFIG_UWE5622
+#include "uwe5622_glb.h"
+#endif
+
+#ifdef CONFIG_UWE5623
+#include "uwe5623_glb.h"
+#endif
+
+#else
+#include "uwe562x_glb.h"
+#endif
+
+#include "loopcheck.h"
+
+#endif
diff --git a/drivers/net/wireless/uwe5622/unisocwcn/include/wcn_glb_reg.h b/drivers/net/wireless/uwe5622/unisocwcn/include/wcn_glb_reg.h
new file mode 100644
index 000000000000..1db4e9a94795
--- /dev/null
+++ b/drivers/net/wireless/uwe5622/unisocwcn/include/wcn_glb_reg.h
@@ -0,0 +1,31 @@
+/*
+ * Copyright (C) 2017 Spreadtrum Communications Inc.
+ *
+ * This file is dual-licensed: you can use it either under the terms
+ * of the GPL or the X11 license, at your option. Note that this dual
+ * licensing only applies to this file, and not this project as a
+ * whole.
+ *
+ */
+#ifndef _WCN_GLB_REG_H_
+#define _WCN_GLB_REG_H_
+
+
+#ifndef CONFIG_CHECK_DRIVER_BY_CHIPID
+#ifdef CONFIG_UWE5621
+#include "uwe5621_glb.h"
+#endif
+
+#ifdef CONFIG_UWE5622
+#include "uwe5622_glb.h"
+#endif
+
+#ifdef CONFIG_UWE5623
+#include "uwe5623_glb.h"
+#endif
+
+#else
+#include "uwe562x_glb.h"
+#endif
+
+#endif
diff --git a/drivers/net/wireless/uwe5622/unisocwcn/include/wcn_types.h b/drivers/net/wireless/uwe5622/unisocwcn/include/wcn_types.h
new file mode 100644
index 000000000000..2f2eb8d039e0
--- /dev/null
+++ b/drivers/net/wireless/uwe5622/unisocwcn/include/wcn_types.h
@@ -0,0 +1,12 @@
+#ifndef __WCN_TYPES_H__
+#define __WCN_TYPES_H__
+
+/* error return value */
+enum e_return_value {
+	E_DEFAULT = 1,
+	E_NULLPOINT,
+	E_NOMEM,
+	E_INVALIDPARA,
+};
+
+#endif
diff --git a/drivers/net/wireless/uwe5622/unisocwcn/platform/loopcheck.c b/drivers/net/wireless/uwe5622/unisocwcn/platform/loopcheck.c
new file mode 100644
index 000000000000..ad81fa2086c2
--- /dev/null
+++ b/drivers/net/wireless/uwe5622/unisocwcn/platform/loopcheck.c
@@ -0,0 +1,256 @@
+#include <linux/completion.h>
+#include <linux/workqueue.h>
+#include <linux/timer.h>
+
+#include "wcn_glb.h"
+#include "wcn_procfs.h"
+
+#define LOOPCHECK_TIMER_INTERVAL      5
+#define USERDEBUG	1
+#define WCN_LOOPCHECK_INIT	1
+#define WCN_LOOPCHECK_OPEN	2
+
+#ifdef CONFIG_WCN_LOOPCHECK
+struct wcn_loopcheck {
+	unsigned long status;
+	struct completion completion;
+	struct delayed_work work;
+	struct workqueue_struct *workqueue;
+};
+
+static struct wcn_loopcheck loopcheck;
+unsigned int (*cp_assert_cb_matrix[2])(unsigned int type) = {0};
+#endif
+static struct completion atcmd_completion;
+static struct mutex atcmd_lock;
+
+int at_cmd_send(char *buf, unsigned int len)
+{
+	unsigned char *send_buf = NULL;
+	struct mbuf_t *head, *tail;
+	int num = 1;
+
+	WCN_DEBUG("%s len=%d\n", __func__, len);
+	if (unlikely(marlin_get_module_status() != true)) {
+		WCN_ERR("WCN module have not open\n");
+		return -EIO;
+	}
+
+	send_buf = kzalloc(len + PUB_HEAD_RSV + 1, GFP_KERNEL);
+	if (!send_buf)
+		return -ENOMEM;
+	memcpy(send_buf + PUB_HEAD_RSV, buf, len);
+
+	if (!sprdwcn_bus_list_alloc(mdbg_proc_ops[MDBG_AT_TX_OPS].channel,
+				    &head, &tail, &num)) {
+		head->buf = send_buf;
+		head->len = len;
+		head->next = NULL;
+		sprdwcn_bus_push_list(mdbg_proc_ops[MDBG_AT_TX_OPS].channel,
+				      head, tail, num);
+	}
+	return 0;
+}
+
+#ifdef CONFIG_WCN_LOOPCHECK
+static void reset_cp(void)
+{
+	marlin_chip_en(0, 0);
+	if (cp_assert_cb_matrix[0])
+		cp_assert_cb_matrix[0](0);
+	if (cp_assert_cb_matrix[1])
+		cp_assert_cb_matrix[1](1);
+
+}
+
+static void loopcheck_work_queue(struct work_struct *work)
+{
+	int ret;
+	unsigned long timeleft;
+	char a[] = "at+loopcheck\r\n";
+
+	if (!test_bit(WCN_LOOPCHECK_OPEN, &loopcheck.status))
+		return;
+	mutex_lock(&atcmd_lock);
+	at_cmd_send(a, sizeof(a));
+
+	timeleft = wait_for_completion_timeout(&loopcheck.completion,
+					       (3 * HZ));
+	mutex_unlock(&atcmd_lock);
+	if (!test_bit(WCN_LOOPCHECK_OPEN, &loopcheck.status))
+		return;
+	if (!timeleft) {
+		stop_loopcheck();
+		WCN_ERR("didn't get loopcheck ack\n");
+		WCN_INFO("start dump CP2 mem\n");
+		if (USERDEBUG)
+			mdbg_assert_interface("loopcheck fail");
+		else
+			reset_cp();
+		return;
+	}
+
+	ret = queue_delayed_work(loopcheck.workqueue, &loopcheck.work,
+				 LOOPCHECK_TIMER_INTERVAL * HZ);
+}
+#endif
+
+void switch_cp2_log(bool flag)
+{
+	unsigned long timeleft;
+	char a[32];
+	unsigned char ret;
+
+	WCN_INFO("%s - %s entry!\n", __func__, (flag ? "open" : "close"));
+	mutex_lock(&atcmd_lock);
+	sprintf(a, "at+armlog=%d\r\n", (flag ? 1 : 0));
+	ret = at_cmd_send(a, sizeof(a));
+	if (ret) {
+		mutex_unlock(&atcmd_lock);
+		WCN_ERR("%s fail!\n", __func__);
+		return;
+	}
+	timeleft = wait_for_completion_timeout(&atcmd_completion, (3 * HZ));
+	mutex_unlock(&atcmd_lock);
+	if (!timeleft)
+		WCN_ERR("didn't get %s ack\n", __func__);
+}
+
+int get_board_ant_num(void)
+{
+	unsigned long timeleft;
+	char a[] = "at+getantnum\r\n";
+	unsigned char *at_cmd_buf;
+	unsigned char ret;
+
+	WCN_DEBUG("%s entry!\n", __func__);
+
+	/* 2. uwe5622 module:
+	 * Antenna num is fixed to one.
+	 */
+#ifndef CONFIG_CHECK_DRIVER_BY_CHIPID
+#ifdef CONFIG_UWE5622
+	WCN_INFO("%s [one_ant]\n", __func__);
+	return MARLIN_ONE_ANT;
+#endif
+#else /*CONFIG_CHECK_DRIVER_BY_CHIPID*/
+	if (wcn_get_chip_model() == WCN_CHIP_MARLIN3L) {
+		WCN_INFO("%s [one_ant]\n", __func__);
+		return MARLIN_ONE_ANT;
+	}
+#endif
+
+	/* 3. Other situations:
+	 * send at cmd to get antenna num.
+	 */
+	mutex_lock(&atcmd_lock);
+	ret = at_cmd_send(a, sizeof(a));
+	if (ret) {
+		mutex_unlock(&atcmd_lock);
+		WCN_ERR("%s fail!\n", __func__);
+		return ret;
+	}
+	timeleft = wait_for_completion_timeout(&atcmd_completion, (3 * HZ));
+	if (!timeleft) {
+		mutex_unlock(&atcmd_lock);
+		WCN_ERR("didn't get board ant num, default:[three_ant]\n");
+		return MARLIN_THREE_ANT;
+	}
+	at_cmd_buf = mdbg_get_at_cmd_buf();
+	mutex_unlock(&atcmd_lock);
+	if (at_cmd_buf[0] == '2') {
+		WCN_INFO("%s [two_ant]\n", __func__);
+		return MARLIN_TWO_ANT;
+	} else if (at_cmd_buf[0] == '3') {
+		WCN_INFO("%s [three_ant]\n", __func__);
+		return MARLIN_THREE_ANT;
+	}
+	WCN_ERR("%s read err:%s, default:[three_ant]\n",
+		__func__, at_cmd_buf);
+	return MARLIN_THREE_ANT;
+}
+
+void get_cp2_version(void)
+{
+	unsigned long timeleft;
+	char a[] = "at+spatgetcp2info\r\n";
+	unsigned char ret;
+
+	WCN_INFO("%s entry!\n", __func__);
+	mutex_lock(&atcmd_lock);
+	ret = at_cmd_send(a, sizeof(a));
+	if (ret) {
+		mutex_unlock(&atcmd_lock);
+		WCN_ERR("%s fail!\n", __func__);
+		return;
+	}
+	timeleft = wait_for_completion_timeout(&atcmd_completion, (3 * HZ));
+	mutex_unlock(&atcmd_lock);
+	if (!timeleft)
+		WCN_ERR("didn't get CP2 version\n");
+}
+
+#ifdef CONFIG_WCN_LOOPCHECK
+void start_loopcheck(void)
+{
+	if (!test_bit(WCN_LOOPCHECK_INIT, &loopcheck.status) ||
+	    test_and_set_bit(WCN_LOOPCHECK_OPEN, &loopcheck.status))
+		return;
+	WCN_INFO("%s\n", __func__);
+	reinit_completion(&loopcheck.completion);
+	queue_delayed_work(loopcheck.workqueue, &loopcheck.work, HZ);
+}
+
+void stop_loopcheck(void)
+{
+	if (!test_bit(WCN_LOOPCHECK_INIT, &loopcheck.status) ||
+	    !test_and_clear_bit(WCN_LOOPCHECK_OPEN, &loopcheck.status))
+		return;
+	WCN_INFO("%s\n", __func__);
+	complete_all(&loopcheck.completion);
+	cancel_delayed_work_sync(&loopcheck.work);
+}
+
+void complete_kernel_loopcheck(void)
+{
+	complete(&loopcheck.completion);
+}
+#endif
+
+void complete_kernel_atcmd(void)
+{
+	complete(&atcmd_completion);
+}
+
+int loopcheck_init(void)
+{
+#ifdef CONFIG_WCN_LOOPCHECK
+	WCN_DEBUG("loopcheck_init\n");
+	loopcheck.status = 0;
+	init_completion(&loopcheck.completion);
+	loopcheck.workqueue =
+			create_singlethread_workqueue("WCN_LOOPCHECK_QUEUE");
+	if (!loopcheck.workqueue) {
+		WCN_ERR("WCN_LOOPCHECK_QUEUE create failed");
+		return -ENOMEM;
+	}
+	set_bit(WCN_LOOPCHECK_INIT, &loopcheck.status);
+	INIT_DELAYED_WORK(&loopcheck.work, loopcheck_work_queue);
+#endif
+	init_completion(&atcmd_completion);
+	mutex_init(&atcmd_lock);
+
+	return 0;
+}
+
+int loopcheck_deinit(void)
+{
+#ifdef CONFIG_WCN_LOOPCHECK
+	stop_loopcheck();
+	destroy_workqueue(loopcheck.workqueue);
+	loopcheck.status = 0;
+#endif
+	mutex_destroy(&atcmd_lock);
+
+	return 0;
+}
diff --git a/drivers/net/wireless/uwe5622/unisocwcn/platform/loopcheck.h b/drivers/net/wireless/uwe5622/unisocwcn/platform/loopcheck.h
new file mode 100644
index 000000000000..4eb92a695b48
--- /dev/null
+++ b/drivers/net/wireless/uwe5622/unisocwcn/platform/loopcheck.h
@@ -0,0 +1,16 @@
+#ifndef _LOOPCHECK
+#define _LOOPCHECK
+
+#include <linux/types.h>
+
+void switch_cp2_log(bool flag);
+int get_board_ant_num(void);
+void get_cp2_version(void);
+void start_loopcheck(void);
+void stop_loopcheck(void);
+int loopcheck_init(void);
+int loopcheck_deinit(void);
+void complete_kernel_loopcheck(void);
+void complete_kernel_atcmd(void);
+
+#endif
diff --git a/drivers/net/wireless/uwe5622/unisocwcn/platform/mdbg_type.h b/drivers/net/wireless/uwe5622/unisocwcn/platform/mdbg_type.h
new file mode 100644
index 000000000000..21d0f2df8d04
--- /dev/null
+++ b/drivers/net/wireless/uwe5622/unisocwcn/platform/mdbg_type.h
@@ -0,0 +1,97 @@
+/*
+ * Copyright (C) 2015 Spreadtrum Communications Inc.
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ */
+
+#ifndef _MDBG_TYPE_H
+#define _MDBG_TYPE_H
+
+#include <linux/delay.h>
+#include <linux/fs.h>
+#include <linux/irq.h>
+#include <linux/input.h>
+#include <linux/init.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/miscdevice.h>
+#include <linux/miscdevice.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/slab.h>
+#include <linux/uaccess.h>
+
+#define WCN_DEBUG_ON 1
+#define WCN_DEBUG_OFF 0
+
+extern u32 wcn_print_level;
+
+#define MDBG_HEADER		"MDBG: "
+#define MDBG_HEADER_ERR		"WCN_MDBG_ERR: "
+#define MDBG_DEBUG_MODE		0
+
+#define WCN_HEADER		"WCN: "
+#define WCN_HEADER_ERR		"WCN_ERR: "
+#define WCN_HEADER_DEBUG		"WCN_DEBUG: "
+
+#define WCN_INFO(fmt, args...) \
+	pr_info(WCN_HEADER fmt, ## args)
+
+#define WCN_ERR(fmt, args...) \
+		pr_err(WCN_HEADER_ERR fmt,  ## args)
+
+#define WCN_DEBUG(fmt, args...) do { \
+	if (wcn_print_level ==  WCN_DEBUG_ON)\
+		pr_info(WCN_HEADER_DEBUG"%s: [%d]:" fmt"\n",\
+		__func__, __LINE__, ## args);\
+} while (0)
+
+#define MDBG_ERR(fmt, args...) \
+	pr_info(MDBG_HEADER_ERR fmt, ## args)
+
+#if MDBG_DEBUG_MODE
+#define MDBG_LOG(fmt, args...)	pr_err(MDBG_HEADER"%s  %d:" fmt \
+				"\n", __func__, __LINE__, ## args)
+#else
+#define MDBG_LOG(fmt, args...)
+#endif
+
+#ifdef CONFIG_PRINTK
+#define wcn_printk_ratelimited(inter, burst, now, fmt, ...)	\
+({								\
+	static DEFINE_RATELIMIT_STATE(_wcn_rs,			\
+				      (inter * HZ), burst);	\
+	static unsigned int _wcn_last;				\
+								\
+	if (__ratelimit(&_wcn_rs)) {				\
+		printk(fmt " [rate:%u]\n", ##__VA_ARGS__,	\
+		       (now - _wcn_last) / inter);		\
+		_wcn_last = now;				\
+	}							\
+})
+#else
+#define wcn_printk_ratelimited(inter, burst, now, fmt, ...)
+#endif
+
+#define wcn_pr_daterate(inter, burst, now, fmt, ...)		\
+	wcn_printk_ratelimited(inter, burst, now,		\
+			KERN_INFO "WCN: " pr_fmt(fmt), ##__VA_ARGS__)
+
+#define MDBG_FUNC_ENTERY	MDBG_LOG("ENTER.")
+#define MDBG_FUNC_EXIT		MDBG_LOG("EXIT.")
+
+#define MDBG_SUCCESS		0
+#define MDBG_ERR_RING_FULL	1
+#define MDBG_ERR_MALLOC_FAIL 2
+#define MDBG_ERR_BAD_PARAM	3
+#define MDBG_ERR_SDIO_ERR	4
+#define MDBG_ERR_TIMEOUT	5
+#define MDBG_ERR_NO_FILE	6
+
+#endif
diff --git a/drivers/net/wireless/uwe5622/unisocwcn/platform/wcn_boot.c b/drivers/net/wireless/uwe5622/unisocwcn/platform/wcn_boot.c
new file mode 100644
index 000000000000..88ea07ce9cd5
--- /dev/null
+++ b/drivers/net/wireless/uwe5622/unisocwcn/platform/wcn_boot.c
@@ -0,0 +1,2076 @@
+/*
+ * Copyright (C) 2015 Spreadtrum Communications Inc.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include <linux/clk.h>
+#include <linux/delay.h>
+#include <linux/fs.h>
+#include <linux/firmware.h>
+#include <linux/file.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/mfd/syscon.h>
+#include <linux/of_gpio.h>
+#include <linux/of_device.h>
+#include <linux/platform_device.h>
+#include <linux/regulator/consumer.h>
+#include <linux/regmap.h>
+#include <linux/slab.h>
+#include <linux/string.h>
+#include <linux/unistd.h>
+#include <linux/version.h>
+#include <linux/vmalloc.h>
+#include <linux/workqueue.h>
+#include <marlin_platform.h>
+#include <wcn_bus.h>
+
+#include "../sleep/sdio_int.h"
+#include "../sleep/slp_mgr.h"
+#include "wcn_misc.h"
+#include "wcn_procfs.h"
+#include "mdbg_type.h"
+#include "wcn_glb_reg.h"
+#include "wcn_glb.h"
+
+#define WCN_FW_NAME	"wcnmodem.bin"
+
+#ifndef REG_PMU_APB_XTL_WAIT_CNT0
+#define REG_PMU_APB_XTL_WAIT_CNT0 0xe42b00ac
+#endif
+
+struct wcn_sync_info_t {
+	unsigned int init_status;
+	unsigned int mem_pd_bt_start_addr;
+	unsigned int mem_pd_bt_end_addr;
+	unsigned int mem_pd_wifi_start_addr;
+	unsigned int mem_pd_wifi_end_addr;
+	unsigned int prj_type;
+	unsigned int tsx_dac_data;
+	unsigned int sdio_config;
+	unsigned int dcache_status;
+	unsigned int dcache_start_addr;
+	unsigned int dcache_end_addr;
+	unsigned int mem_pd_status;
+	unsigned int mem_ap_cmd;
+	unsigned int rsvd[3];
+	unsigned int bind_verify_data[4];
+};
+
+struct tsx_data {
+	u32 flag; /* cali flag ref */
+	u16 dac; /* AFC cali data */
+	u16 reserved;
+};
+
+struct tsx_cali {
+	u32 init_flag;
+	struct tsx_data tsxdata;
+};
+
+/*
+ * sdio config to cp side
+ * bit[31:24]: reserved
+ * bit[23]: wake_host_data_separation:
+ *	0: if BT_WAKEUP_HOST en or WL_WAKEUP_HOST en,
+ *	    wifi and bt packets can wake host;
+ *	1: if BT_WAKEUP_HOST en, ONLY bt packets can wake host;
+ *	    if WL_WAKEUP_HOST en, ONLY wifi packets can wake host
+ * bit[22:18]: wake_host_level_duration_10ms: BT_WAKEUP_HOST or WL_WAKEUP_HOST
+ *	      level dyration time per 10ms, example: 0:0ms; 3:30ms; 20:200ms
+ * bit[17:16]: wl_wake_host_trigger_type:
+ *	     00:WL_WAKEUP_HOST  trigger type low
+ *	     01:WL_WAKEUP_HOST  trigger type rising
+ *	     10:WL_WAKEUP_HOST  trigger type falling
+ *	     11:WL_WAKEUP_HOST  trigger type high
+ * bit[15]: wl_wake_host_en: 0: disable, 1: enable
+ * bit[14:13]: sdio_irq_trigger_type:
+ *	      00:pubint gpio irq trigger type low
+ *	      01:pubint gpio irq trigger type rising [NOT support]
+ *	      10:pubint gpio irq trigger type falling [NOT support]
+ *	      11:pubint gpio irq trigger type high
+ * bit[12:11]: sdio_irq_type:
+ *	      00:dedicated irq, gpio1
+ *	      01:inband data1 irq
+ *	      10:use BT_WAKEUP_HOST(pubint) pin as gpio irq
+ *	      11:use WL_WAKEUP_HOST(esmd3) pin as gpio irq
+ * bit[10:9]: bt_wake_host_trigger_type:
+ *	     00:BT_WAKEUP_HOST  trigger type low
+ *	     01:BT_WAKEUP_HOST  trigger type rising
+ *	     10:BT_WAKEUP_HOST  trigger type falling
+ *	     11:BT_WAKEUP_HOST  trigger type high
+ * bit[8]: bt_wake_host_en: 0: disable, 1: enable
+ * bit[7:5]: sdio_blk_size: 000: blocksize 840; 001: blocksize 512
+ * bit[4]: sdio_rx_mode: 0: adma; 1: sdma
+ * bit[3:1]: vendor_id: 000: default id, unisoc[0x0]
+ *		       001: hisilicon default version, pull chipen after resume
+ *		       010: hisilicon version, keep power (NOT pull chipen) and
+ *			    reset sdio after resume
+ * bit[0]: sdio_config_en: 0: disable sdio config
+ *		          1: enable sdio config
+ */
+union wcn_sdiohal_config {
+	unsigned int val;
+	struct {
+		unsigned char sdio_config_en:1;
+		unsigned char vendor_id:3;
+		unsigned char sdio_rx_mode:1;
+		unsigned char sdio_blk_size:3;
+		unsigned char bt_wake_host_en:1;
+		unsigned char bt_wake_host_trigger_type:2;
+		unsigned char sdio_irq_type:2;
+		unsigned char sdio_irq_trigger_type:2;
+		unsigned char wl_wake_host_en:1;
+		unsigned char wl_wake_host_trigger_type:2;
+		unsigned char wake_host_level_duration_10ms:5;
+		unsigned char wake_host_data_separation:1;
+		unsigned int  reserved:8;
+	} cfg;
+};
+
+struct marlin_device {
+	int wakeup_ap;
+	int reset;
+	int chip_en;
+	int int_ap;
+
+	struct mutex power_lock;
+	struct completion download_done;
+	unsigned long power_state;
+	char *write_buffer;
+	struct delayed_work power_wq;
+	struct work_struct download_wq;
+	bool no_power_off;
+	int wifi_need_download_ini_flag;
+	int first_power_on_flag;
+	unsigned char download_finish_flag;
+	unsigned char bt_wl_wake_host_en;
+	unsigned int bt_wake_host_int_num;
+	unsigned int wl_wake_host_int_num;
+	int loopcheck_status_change;
+	struct wcn_sync_info_t sync_f;
+	struct tsx_cali tsxcali;
+};
+
+marlin_reset_callback marlin_reset_func;
+void *marlin_callback_para;
+
+struct marlin_device *marlin_dev;
+
+unsigned char  flag_reset;
+char functionmask[8];
+
+#define IMG_HEAD_MAGIC "WCNM"
+#define IMG_HEAD_MAGIC_COMBINE "WCNE"
+
+#define IMG_MARLINAA_TAG "MLAA"
+#define IMG_MARLINAB_TAG "MLAB"
+#define IMG_MARLINAC_TAG "MLAC"
+#define IMG_MARLINAD_TAG "MLAD"
+
+#define IMG_MARLIN3_AA_TAG "30AA"
+#define IMG_MARLIN3_AB_TAG "30AB"
+#define IMG_MARLIN3_AC_TAG "30AC"
+#define IMG_MARLIN3_AD_TAG "30AD"
+
+#define IMG_MARLIN3L_AA_TAG "3LAA"
+#define IMG_MARLIN3L_AB_TAG "3LAB"
+#define IMG_MARLIN3L_AC_TAG "3LAC"
+#define IMG_MARLIN3L_AD_TAG "3LAD"
+
+#define IMG_MARLIN3E_AA_TAG "3EAA"
+#define IMG_MARLIN3E_AB_TAG "3EAB"
+#define IMG_MARLIN3E_AC_TAG "3EAC"
+#define IMG_MARLIN3E_AD_TAG "3EAD"
+
+#define MARLIN_MASK 0x27F
+#define AUTO_RUN_MASK 0X100
+
+#define AFC_CALI_FLAG 0x54463031 /* cali flag */
+#define AFC_CALI_READ_FINISH 0x12121212
+#define WCN_AFC_CALI_PATH "/productinfo/wcn/tsx_bt_data.txt"
+
+#define POWER_WQ_DELAYED_MS 7500
+
+/* #define E2S(x) { case x: return #x; } */
+
+struct head {
+	char magic[4];
+	unsigned int version;
+	unsigned int img_count;
+};
+
+struct imageinfo {
+	char tag[4];
+	unsigned int offset;
+	unsigned int size;
+};
+
+struct combin_img_info {
+	unsigned int addr;			/* image target address */
+	unsigned int offset;			/* image combin img offset */
+	unsigned int size;			/* image size */
+};
+
+unsigned long marlin_get_power_state(void)
+{
+	return marlin_dev->power_state;
+}
+EXPORT_SYMBOL_GPL(marlin_get_power_state);
+
+unsigned char marlin_get_bt_wl_wake_host_en(void)
+{
+	return marlin_dev->bt_wl_wake_host_en;
+}
+EXPORT_SYMBOL_GPL(marlin_get_bt_wl_wake_host_en);
+
+/* return chipid, for example:
+ * 0x2355000x: Marlin3 series
+ * 0x2355B00x: Marlin3 lite series
+ * 0x5663000x: Marlin3E series
+ * 0: read chipid fail or not unisoc module
+ */
+#define WCN_CHIPID_MASK (0xFFFFF000)
+unsigned int marlin_get_wcn_chipid(void)
+{
+	int ret;
+	static unsigned long int chip_id;
+
+	if (likely(chip_id))
+		return chip_id;
+
+	WCN_DEBUG("%s enter.\n", __func__);
+
+#ifndef CONFIG_CHECK_DRIVER_BY_CHIPID
+	ret = sprdwcn_bus_reg_read(CHIPID_REG, &chip_id, 4);
+	if (ret < 0) {
+		WCN_ERR("marlin read chip ID fail, ret=%d\n", ret);
+		return 0;
+	}
+
+#else
+	/* At first, read Marlin3E chipid register. */
+	ret = sprdwcn_bus_reg_read(CHIPID_REG_M3E, &chip_id, 4);
+	if (ret < 0) {
+		WCN_ERR("read marlin3E chip id fail, ret=%d\n", ret);
+		return 0;
+	}
+
+	/* If it is not Marlin3E, then read Marlin3 chipid register. */
+	if ((chip_id & WCN_CHIPID_MASK) != MARLIN3E_AA_CHIPID) {
+		ret = sprdwcn_bus_reg_read(CHIPID_REG_M3_M3L, &chip_id, 4);
+		if (ret < 0) {
+			WCN_ERR("read marlin3 chip id fail, ret=%d\n", ret);
+			return 0;
+		}
+	}
+#endif
+	WCN_INFO("%s: chipid: 0x%lx\n", __func__, chip_id);
+
+	return chip_id;
+}
+EXPORT_SYMBOL_GPL(marlin_get_wcn_chipid);
+
+/* return chip model, for example:
+ * 0: WCN_CHIP_INVALID
+ * 1: WCN_CHIP_MARLIN3
+ * 2: WCN_CHIP_MARLIN3L
+ * 3: WCN_CHIP_MARLIN3E
+ */
+enum wcn_chip_model wcn_get_chip_model(void)
+{
+	static enum wcn_chip_model chip_model = WCN_CHIP_INVALID;
+	unsigned int chip_id;
+	static const char *chip_model_str[] = {
+		"ERRO",
+		"Marlin3",
+		"Marlin3Lite",
+		"Marlin3E",
+	};
+
+	if (likely(chip_model))
+		return chip_model;
+
+	/* if read chipid fail or not unisoc module, chip_id is 0. */
+	chip_id = marlin_get_wcn_chipid();
+	if (chip_id == 0)
+		chip_model = WCN_CHIP_INVALID;
+	else if ((chip_id & WCN_CHIPID_MASK) == MARLIN3_AA_CHIPID)
+		chip_model = WCN_CHIP_MARLIN3;
+	else if ((chip_id & WCN_CHIPID_MASK) == MARLIN3L_AA_CHIPID)
+		chip_model = WCN_CHIP_MARLIN3L;
+	else if ((chip_id & WCN_CHIPID_MASK) == MARLIN3E_AA_CHIPID)
+		chip_model = WCN_CHIP_MARLIN3E;
+	else
+		chip_model = WCN_CHIP_INVALID;
+	WCN_DEBUG("%s: chip_model: %s\n", __func__, chip_model_str[chip_model]);
+
+	return chip_model;
+}
+EXPORT_SYMBOL_GPL(wcn_get_chip_model);
+
+/* return chip type, for example:
+ * 0: WCN_CHIP_ID_INVALID
+ * 1: WCN_CHIP_ID_AA
+ * 2: WCN_CHIP_ID_AB
+ * 3: WCN_CHIP_ID_AC
+ * 4: WCN_CHIP_ID_AD
+ */
+enum wcn_chip_id_type wcn_get_chip_type(void)
+{
+	static enum wcn_chip_id_type chip_type = WCN_CHIP_ID_INVALID;
+	unsigned int chip_id;
+	static const char *chip_type_str[] = {
+		"ERRO",
+		"AA",
+		"AB",
+		"AC",
+		"AD",
+	};
+
+	if (likely(chip_type))
+		return chip_type;
+
+	/* if read chipid fail or not unisoc module, chip_id is 0. */
+	chip_id = marlin_get_wcn_chipid();
+	if (chip_id == 0)
+		chip_type = WCN_CHIP_ID_INVALID;
+	else
+		chip_type = (chip_id & 0xF) + 1;
+	WCN_DEBUG("%s: chip_type: %s\n", __func__, chip_type_str[chip_type]);
+
+	return chip_type;
+}
+EXPORT_SYMBOL_GPL(wcn_get_chip_type);
+
+#define WCN_CHIP_NAME_UNKNOWN "UNKNOWN"
+
+/* Marlin3_AD_0x23550003 */
+const char *wcn_get_chip_name(void)
+{
+	unsigned int chip_id, pos = 0;
+	enum wcn_chip_model chip_model;
+	enum wcn_chip_id_type chip_type;
+	static char wcn_chip_name[32] = { 0 };
+	static const char *chip_model_str[] = {
+		"ERRO_",
+		"Marlin3_",
+		"Marlin3Lite_",
+		"Marlin3E_",
+	};
+	static const char *chip_type_str[] = {
+		"ERRO_",
+		"AA_",
+		"AB_",
+		"AC_",
+		"AD_",
+	};
+
+	if (wcn_chip_name[0])
+		return wcn_chip_name;
+
+	/* if read chipid fail or not unisoc module, chip_id is 0. */
+	chip_id = marlin_get_wcn_chipid();
+	if (chip_id == 0) {
+		memcpy((void *)wcn_chip_name, WCN_CHIP_NAME_UNKNOWN,
+		       strlen(WCN_CHIP_NAME_UNKNOWN));
+		goto out;
+	}
+
+	chip_model = wcn_get_chip_model();
+	if (chip_model == WCN_CHIP_INVALID) {
+		memcpy((void *)wcn_chip_name, WCN_CHIP_NAME_UNKNOWN,
+		       strlen(WCN_CHIP_NAME_UNKNOWN));
+		goto out;
+	}
+	sprintf((char *)wcn_chip_name, chip_model_str[chip_model]);
+	pos += strlen(chip_model_str[chip_model]);
+
+	chip_type = wcn_get_chip_type();
+	if (chip_type == WCN_CHIP_ID_INVALID) {
+		memcpy((void *)wcn_chip_name, WCN_CHIP_NAME_UNKNOWN,
+		       strlen(WCN_CHIP_NAME_UNKNOWN));
+		goto out;
+	}
+	sprintf((char *)(wcn_chip_name + pos), chip_type_str[chip_type]);
+	pos += strlen(chip_type_str[chip_type]);
+	sprintf((char *)(wcn_chip_name + pos), "0x%x", chip_id);
+
+out:
+	WCN_DEBUG("%s: chip_name: %s\n", __func__, wcn_chip_name);
+	return wcn_chip_name;
+}
+EXPORT_SYMBOL_GPL(wcn_get_chip_name);
+
+/* return number of marlin antennas
+ * MARLIN_TWO_ANT; MARLIN_THREE_ANT; ...
+ */
+int marlin_get_ant_num(void)
+{
+	return get_board_ant_num();
+}
+EXPORT_SYMBOL_GPL(marlin_get_ant_num);
+
+/* get the subsys string */
+const char *strno(int subsys)
+{
+	switch (subsys) {
+	case MARLIN_BLUETOOTH:
+		return "MARLIN_BLUETOOTH";
+	case MARLIN_FM:
+		return "MARLIN_FM";
+	case MARLIN_WIFI:
+		return "MARLIN_WIFI";
+	case MARLIN_WIFI_FLUSH:
+		return "MARLIN_WIFI_FLUSH";
+	case MARLIN_SDIO_TX:
+		return "MARLIN_SDIO_TX";
+	case MARLIN_SDIO_RX:
+		return "MARLIN_SDIO_RX";
+	case MARLIN_MDBG:
+		return "MARLIN_MDBG";
+	case WCN_AUTO:
+		return "WCN_AUTO";
+	case MARLIN_ALL:
+		return "MARLIN_ALL";
+	default: return "MARLIN_SUBSYS_UNKNOWN";
+	}
+/* #undef E2S */
+}
+
+/* tsx/dac init */
+int marlin_tsx_cali_data_read(struct tsx_data *p_tsx_data)
+{
+	u32 size = 0;
+	u32 read_len = 0;
+	struct file *file;
+	loff_t offset = 0;
+	char *pdata;
+
+	file = filp_open(WCN_AFC_CALI_PATH, O_RDONLY, 0);
+	if (IS_ERR(file)) {
+		WCN_ERR("open file error\n");
+		return -1;
+	}
+	WCN_INFO("open image "WCN_AFC_CALI_PATH" successfully\n");
+
+	/* read file to buffer */
+	size = sizeof(struct tsx_data);
+	pdata = (char *)p_tsx_data;
+	do {
+#if KERNEL_VERSION(4, 14, 0) <= LINUX_VERSION_CODE
+		read_len = kernel_read(file, (void *)pdata, size, &offset);
+#else
+		read_len = kernel_read(file, offset, pdata, size);
+#endif
+
+		if (read_len > 0) {
+			size -= read_len;
+			pdata += read_len;
+		}
+	} while ((read_len > 0) && (size > 0));
+	fput(file);
+	WCN_INFO("After read, data =%p dac value %02x\n", pdata,
+			 p_tsx_data->dac);
+
+	return 0;
+}
+
+static u16 marlin_tsx_cali_data_get(void)
+{
+	int ret;
+
+	return 0;
+
+	WCN_INFO("tsx cali init flag %d\n", marlin_dev->tsxcali.init_flag);
+
+	if (marlin_dev->tsxcali.init_flag == AFC_CALI_READ_FINISH)
+		return marlin_dev->tsxcali.tsxdata.dac;
+
+	ret = marlin_tsx_cali_data_read(&marlin_dev->tsxcali.tsxdata);
+	marlin_dev->tsxcali.init_flag = AFC_CALI_READ_FINISH;
+	if (ret != 0) {
+		marlin_dev->tsxcali.tsxdata.dac = 0xffff;
+		WCN_INFO("tsx cali read fail! default 0xffff\n");
+		return marlin_dev->tsxcali.tsxdata.dac;
+	}
+
+	if (marlin_dev->tsxcali.tsxdata.flag != AFC_CALI_FLAG) {
+		marlin_dev->tsxcali.tsxdata.dac = 0xffff;
+		WCN_INFO("tsx cali flag fail! default 0xffff\n");
+		return marlin_dev->tsxcali.tsxdata.dac;
+	}
+	WCN_INFO("dac flag %d value:0x%x\n",
+			    marlin_dev->tsxcali.tsxdata.flag,
+			    marlin_dev->tsxcali.tsxdata.dac);
+
+	return marlin_dev->tsxcali.tsxdata.dac;
+}
+
+#define marlin_firmware_get_combin_info(buffer) \
+		(struct combin_img_info *)(buffer + sizeof(struct head))
+
+#define bin_magic_is(data, magic_tag) \
+	!strncmp(((struct head *)data)->magic, magic_tag, strlen(magic_tag))
+
+#define marlin_fw_get_img_count(img) (((struct head *)img)->img_count)
+
+static const struct imageinfo *marlin_imageinfo_get_from_data(const char *tag,
+		const void *data)
+{
+	const struct imageinfo *imageinfo;
+	int imageinfo_count;
+	int i;
+
+	imageinfo = (struct imageinfo *)(data + sizeof(struct head));
+	imageinfo_count = marlin_fw_get_img_count(data);
+
+	for (i = 0; i < imageinfo_count; i++)
+		if (!strncmp(imageinfo[i].tag, tag, 4))
+			return &(imageinfo[i]);
+	return NULL;
+}
+
+static const struct imageinfo *marlin_judge_images(const unsigned char *buffer)
+{
+	unsigned long chip_id;
+	const struct imageinfo *image_info;
+
+	chip_id = marlin_get_wcn_chipid();
+	if (buffer == NULL)
+		return NULL;
+
+#ifndef CONFIG_CHECK_DRIVER_BY_CHIPID
+	if (wcn_get_chip_model() == WCN_CHIP_MARLIN3) {
+		switch (chip_id) {
+		case MARLIN_AA_CHIPID:
+			return marlin_imageinfo_get_from_data(IMG_MARLINAA_TAG,
+							      buffer);
+		case MARLIN_AB_CHIPID:
+			return marlin_imageinfo_get_from_data(IMG_MARLINAB_TAG,
+							      buffer);
+		case MARLIN_AC_CHIPID:
+		case MARLIN_AD_CHIPID:
+			/* bin of m3 AC and AD chip is the same. */
+			image_info = marlin_imageinfo_get_from_data(
+				IMG_MARLINAC_TAG, buffer);
+			if (image_info) {
+				WCN_INFO("%s find %s tag\n", __func__,
+					 IMG_MARLINAC_TAG);
+				return image_info;
+			}
+			return marlin_imageinfo_get_from_data(IMG_MARLINAD_TAG,
+							      buffer);
+		default:
+			WCN_ERR("Marlin can't find correct imginfo!\n");
+		}
+	}
+	if (wcn_get_chip_model() == WCN_CHIP_MARLIN3L) {
+		switch (chip_id) {
+		case MARLIN_AA_CHIPID:
+			return marlin_imageinfo_get_from_data(IMG_MARLINAA_TAG,
+							      buffer);
+		case MARLIN_AB_CHIPID:
+			return marlin_imageinfo_get_from_data(IMG_MARLINAB_TAG,
+							      buffer);
+		default:
+			WCN_ERR("Marlin can't find correct imginfo!\n");
+		}
+	}
+	if (wcn_get_chip_model() == WCN_CHIP_MARLIN3E) {
+		switch (chip_id) {
+		case MARLIN_AA_CHIPID:
+		case MARLIN_AB_CHIPID:
+			/* bin of m3e AA and AB chip is the same. */
+			image_info = marlin_imageinfo_get_from_data(
+				IMG_MARLINAA_TAG, buffer);
+			if (image_info) {
+				WCN_INFO("%s find %s tag\n", __func__,
+					 IMG_MARLINAA_TAG);
+				return image_info;
+			}
+			return marlin_imageinfo_get_from_data(IMG_MARLINAB_TAG,
+							      buffer);
+		default:
+			WCN_ERR("Marlin can't find correct imginfo!\n");
+		}
+	}
+
+#else  /*ELOF CONFIG_CHECK_DRIVER_BY_CHIPID*/
+
+	switch (chip_id) {
+	case MARLIN3_AA_CHIPID:
+		return marlin_imageinfo_get_from_data(
+			IMG_MARLIN3_AA_TAG, buffer);
+	case MARLIN3_AB_CHIPID:
+		return marlin_imageinfo_get_from_data(
+			IMG_MARLIN3_AB_TAG, buffer);
+	case MARLIN3_AC_CHIPID:
+	case MARLIN3_AD_CHIPID:
+		/* bin of m3 AC and AD chip is the same. */
+		image_info = marlin_imageinfo_get_from_data(
+			IMG_MARLIN3_AC_TAG, buffer);
+		if (image_info) {
+			WCN_INFO("%s find %s tag\n", __func__,
+				 IMG_MARLIN3_AC_TAG);
+			return image_info;
+		}
+		return marlin_imageinfo_get_from_data(
+			IMG_MARLIN3_AD_TAG, buffer);
+	case MARLIN3L_AA_CHIPID:
+		return marlin_imageinfo_get_from_data(
+			IMG_MARLIN3L_AA_TAG, buffer);
+	case MARLIN3L_AB_CHIPID:
+		return marlin_imageinfo_get_from_data(
+			IMG_MARLIN3L_AB_TAG, buffer);
+	case MARLIN3L_AC_CHIPID:
+		return marlin_imageinfo_get_from_data(
+			IMG_MARLIN3L_AC_TAG, buffer);
+	case MARLIN3L_AD_CHIPID:
+		return marlin_imageinfo_get_from_data(
+			IMG_MARLIN3L_AD_TAG, buffer);
+	case MARLIN3E_AA_CHIPID:
+	case MARLIN3E_AB_CHIPID:
+		/* bin of m3e AA and AB chip is the same. */
+		image_info = marlin_imageinfo_get_from_data(
+			IMG_MARLIN3E_AA_TAG, buffer);
+		if (image_info) {
+			WCN_INFO("%s find %s tag\n", __func__,
+				 IMG_MARLIN3E_AA_TAG);
+			return image_info;
+		}
+		return marlin_imageinfo_get_from_data(
+			IMG_MARLIN3E_AB_TAG, buffer);
+	case MARLIN3E_AC_CHIPID:
+		return marlin_imageinfo_get_from_data(
+			IMG_MARLIN3E_AC_TAG, buffer);
+	case MARLIN3E_AD_CHIPID:
+		return marlin_imageinfo_get_from_data(
+			IMG_MARLIN3E_AD_TAG, buffer);
+	default:
+		WCN_INFO("%s Cannot find Chip Firmware\n", __func__);
+		break;
+	}
+#endif /*EOF CONFIG_CHECK_DRIVER_BY_CHIPID*/
+	return NULL;
+}
+
+static int sprdwcn_bus_direct_write_dispack(unsigned int addr, const void *buf,
+		size_t buf_size, size_t packet_max_size)
+{
+	int ret = 0;
+	size_t offset = 0;
+	void *kbuf = marlin_dev->write_buffer;
+
+	while (offset < buf_size) {
+		size_t temp_size = min(packet_max_size, buf_size - offset);
+
+		memcpy(kbuf, buf + offset, temp_size);
+		ret = sprdwcn_bus_direct_write(addr + offset, kbuf, temp_size);
+		if (ret < 0)
+			goto OUT;
+
+		offset += temp_size;
+	}
+OUT:
+	if (ret < 0)
+		WCN_ERR(" %s: dt write error:%d\n", __func__, ret);
+	return ret;
+}
+
+struct marlin_firmware {
+	const u8 *data;
+	size_t size;
+	const void *priv;
+};
+
+/* this function __must__ be paired with marlin_firmware_release !*/
+/* Suggest use it like Documentation/firmware_class/README:65
+ *
+ *	if(marlin_request_firmware(&fw) == 0)
+ *		handle_this_firmware(fw);
+ *	marlin_release_firmware(fw);
+ */
+static int marlin_request_firmware(struct marlin_firmware **mfirmware_p)
+{
+	struct marlin_firmware *mfirmware;
+	const struct firmware *firmware;
+	int ret = 0;
+
+	*mfirmware_p = NULL;
+	mfirmware = kmalloc(sizeof(struct marlin_firmware), GFP_KERNEL);
+	if (!mfirmware)
+		return -ENOMEM;
+
+	WCN_INFO("%s from %s start!\n", __func__, WCN_FW_NAME);
+	ret = request_firmware(&firmware, WCN_FW_NAME, NULL);
+	if (ret < 0) {
+		WCN_ERR("%s not find %s errno:(%d)(ignore!!)\n",
+			__func__, WCN_FW_NAME, ret);
+		kfree(mfirmware);
+		return ret;
+	}
+
+	mfirmware->priv = (void *)firmware;
+	mfirmware->data = firmware->data;
+	mfirmware->size = firmware->size;
+
+	memcpy(functionmask, mfirmware->data, 8);
+	if ((functionmask[0] == 0x00) && (functionmask[1] == 0x00)) {
+		mfirmware->data += 8;
+		mfirmware->size -= 8;
+	} else {
+		functionmask[7] = 0;
+	}
+
+	*mfirmware_p = mfirmware;
+
+	return 0;
+}
+
+static int marlin_firmware_parse_image(struct marlin_firmware *mfirmware)
+{
+	if (bin_magic_is(mfirmware->data, IMG_HEAD_MAGIC)) {
+		const struct imageinfo *info;
+
+		WCN_INFO("%s imagepack is %s type,need parse it\n",
+			 __func__, IMG_HEAD_MAGIC);
+		info = marlin_judge_images(mfirmware->data);
+		if (!info) {
+			WCN_ERR("marlin:%s imginfo is NULL\n", __func__);
+			return -1;
+		}
+		mfirmware->size = info->size;
+		mfirmware->data += info->offset;
+	} else if (bin_magic_is(mfirmware->data, IMG_HEAD_MAGIC_COMBINE)) {
+		/* cal the combin size */
+		int img_count;
+		const struct combin_img_info *img_info;
+		int img_real_size = 0;
+
+		WCN_INFO("%s imagepack is %s type,need parse it\n",
+			 __func__, IMG_HEAD_MAGIC_COMBINE);
+
+		img_count = marlin_fw_get_img_count(mfirmware->data);
+		img_info = marlin_firmware_get_combin_info(mfirmware->data);
+
+		img_real_size =
+		img_info[img_count - 1].size + img_info[img_count - 1].offset;
+
+		mfirmware->size = img_real_size;
+	}
+
+	return 0;
+}
+
+static int marlin_firmware_write(struct marlin_firmware *mfirmware)
+{
+	int i = 0;
+	int combin_img_count;
+	const struct combin_img_info *imginfoe;
+	int err;
+
+	if (bin_magic_is(mfirmware->data, IMG_HEAD_MAGIC_COMBINE)) {
+		WCN_INFO("marlin %s imagepack is WCNE type,need parse it\n",
+			__func__);
+
+		combin_img_count = marlin_fw_get_img_count(mfirmware->data);
+		imginfoe = marlin_firmware_get_combin_info(mfirmware->data);
+		if (!imginfoe) {
+			WCN_ERR("marlin:%s imginfo is NULL\n", __func__);
+			return -1;
+		}
+
+		for (i = 0; i < combin_img_count; i++) {
+			if (imginfoe[i].size + imginfoe[i].offset >
+					mfirmware->size) {
+				WCN_ERR("%s memory crossover\n", __func__);
+				return -1;
+			}
+			err = sprdwcn_bus_direct_write_dispack(imginfoe[i].addr,
+					mfirmware->data + imginfoe[i].offset,
+					imginfoe[i].size, PACKET_SIZE);
+			if (err) {
+				WCN_ERR("%s download error\n", __func__);
+				return -1;
+			}
+		}
+	} else {
+		err = sprdwcn_bus_direct_write_dispack(CP_START_ADDR,
+				mfirmware->data, mfirmware->size, PACKET_SIZE);
+		if (err) {
+			WCN_ERR("%s download error\n", __func__);
+			return -1;
+		}
+	}
+	WCN_INFO("combin_img %d %s finish and successful\n", i, __func__);
+
+	return 0;
+}
+
+static void marlin_release_firmware(struct marlin_firmware *mfirmware)
+{
+	if (mfirmware) {
+		release_firmware(mfirmware->priv);
+		kfree(mfirmware);
+	}
+}
+
+/* BT WIFI FM download */
+static int btwifi_download_firmware(void)
+{
+	int ret;
+	struct marlin_firmware *mfirmware;
+
+	ret = marlin_request_firmware(&mfirmware);
+	if (ret) {
+		WCN_ERR("%s request firmware error\n", __func__);
+		goto OUT;
+	}
+
+	ret = marlin_firmware_parse_image(mfirmware);
+	if (ret) {
+		WCN_ERR("%s firmware parse AA\\AB error\n", __func__);
+		goto OUT;
+	}
+
+	ret = marlin_firmware_write(mfirmware);
+	if (ret) {
+		WCN_ERR("%s firmware write error\n", __func__);
+		goto OUT;
+	}
+
+OUT:
+	marlin_release_firmware(mfirmware);
+
+	return ret;
+}
+
+static int marlin_parse_dt(struct device *dev)
+{
+#ifdef CONFIG_WCN_PARSE_DTS
+	struct device_node *np = dev->of_node;
+#endif
+	int ret = -1;
+
+	if (!marlin_dev)
+		return ret;
+
+#ifdef CONFIG_WCN_PARSE_DTS
+	marlin_dev->chip_en = of_get_named_gpio(np, "wl-reg-on", 0);
+#else
+	marlin_dev->chip_en = 0;
+#endif
+	if (marlin_dev->chip_en > 0) {
+		WCN_INFO("%s chip_en gpio=%d\n", __func__,
+			 marlin_dev->chip_en);
+		if (!gpio_is_valid(marlin_dev->chip_en)) {
+			WCN_ERR("chip_en gpio is invalid: %d\n",
+				marlin_dev->chip_en);
+			return -EINVAL;
+		}
+		ret = gpio_request(marlin_dev->chip_en, "chip_en");
+		if (ret) {
+			WCN_ERR("gpio chip_en request err: %d\n",
+				marlin_dev->chip_en);
+			marlin_dev->chip_en = 0;
+		}
+	}
+
+#ifdef CONFIG_WCN_PARSE_DTS
+	marlin_dev->reset = of_get_named_gpio(np, "bt-reg-on", 0);
+#else
+	marlin_dev->reset = 0;
+#endif
+	if (marlin_dev->reset > 0) {
+		WCN_INFO("%s reset gpio=%d\n", __func__, marlin_dev->reset);
+		if (!gpio_is_valid(marlin_dev->reset)) {
+			WCN_ERR("reset gpio is invalid: %d\n",
+				marlin_dev->reset);
+			return -EINVAL;
+		}
+		ret = gpio_request(marlin_dev->reset, "reset");
+		if (ret) {
+			WCN_ERR("gpio reset request err: %d\n",
+				marlin_dev->reset);
+			marlin_dev->reset = 0;
+		}
+	}
+
+#ifdef CONFIG_WCN_PARSE_DTS
+	marlin_dev->int_ap = of_get_named_gpio(np, "pub-int-gpio", 0);
+#else
+	marlin_dev->int_ap = 0;
+#endif
+	if (marlin_dev->int_ap > 0) {
+		WCN_INFO("%s int gpio=%d\n", __func__, marlin_dev->int_ap);
+		if (!gpio_is_valid(marlin_dev->int_ap)) {
+			WCN_ERR("int irq is invalid: %d\n",
+				marlin_dev->int_ap);
+			return -EINVAL;
+		}
+		ret = gpio_request(marlin_dev->int_ap, "int_ap");
+		if (ret) {
+			WCN_ERR("int_ap request err: %d\n",
+				marlin_dev->int_ap);
+			marlin_dev->int_ap = 0;
+		}
+	}
+
+#ifdef CONFIG_WCN_PARSE_DTS
+	if (of_property_read_bool(np, "keep-power-on")) {
+		WCN_INFO("wcn config keep power on\n");
+		marlin_dev->no_power_off = true;
+	}
+
+	if (of_property_read_bool(np, "bt-wake-host")) {
+		int bt_wake_host_gpio;
+
+		WCN_INFO("wcn config bt wake host\n");
+		marlin_dev->bt_wl_wake_host_en |= BIT(BT_WAKE_HOST);
+		bt_wake_host_gpio =
+			of_get_named_gpio(np, "bt-wake-host-gpio", 0);
+		WCN_INFO("%s bt-wake-host-gpio=%d\n", __func__,
+			 bt_wake_host_gpio);
+		if (!gpio_is_valid(bt_wake_host_gpio)) {
+			WCN_ERR("int irq is invalid: %d\n",
+				bt_wake_host_gpio);
+			return -EINVAL;
+		}
+		ret = gpio_request(bt_wake_host_gpio, "bt-wake-host-gpio");
+		if (ret)
+			WCN_ERR("bt-wake-host-gpio request err: %d\n",
+				bt_wake_host_gpio);
+	}
+
+	if (of_property_read_bool(np, "wl-wake-host")) {
+		int wl_wake_host_gpio;
+
+		WCN_INFO("wcn config wifi wake host\n");
+		marlin_dev->bt_wl_wake_host_en |= BIT(WL_WAKE_HOST);
+		wl_wake_host_gpio =
+			of_get_named_gpio(np, "wl-wake-host-gpio", 0);
+		WCN_INFO("%s wl-wake-host-gpio=%d\n", __func__,
+			 wl_wake_host_gpio);
+		if (!gpio_is_valid(wl_wake_host_gpio)) {
+			WCN_ERR("int irq is invalid: %d\n",
+				wl_wake_host_gpio);
+			return -EINVAL;
+		}
+		ret = gpio_request(wl_wake_host_gpio, "wl-wake-host-gpio");
+		if (ret)
+			WCN_ERR("wl-wake-host-gpio request err: %d\n",
+				wl_wake_host_gpio);
+	}
+#endif
+
+	return 0;
+}
+
+static int marlin_gpio_free(void)
+{
+	if (!marlin_dev)
+		return -1;
+
+	if (marlin_dev->reset > 0)
+		gpio_free(marlin_dev->reset);
+	if (marlin_dev->chip_en > 0)
+		gpio_free(marlin_dev->chip_en);
+	if (marlin_dev->int_ap > 0)
+		gpio_free(marlin_dev->int_ap);
+
+	return 0;
+}
+
+#ifdef CONFIG_SDIOHAL
+static void marlin_send_sdio_config_to_cp_vendor(void)
+{
+	union wcn_sdiohal_config sdio_cfg = {0};
+
+#if (defined(CONFIG_AW_BOARD))
+	/* Vendor config */
+
+	/* bit[0]: sdio_config_en:
+	 * 0: disable sdio config
+	 * 1: enable sdio config
+	 */
+	sdio_cfg.cfg.sdio_config_en = 1;
+
+	/* bit[3:1]: vendor_id:
+	 * 000: default id, unisoc[0x0]
+	 * 001: hisilicon default version, pull chipen after resume
+	 * 010: hisilicon version, keep power (NOT pull chipen) and
+	 *      reset sdio after resume
+	 */
+	sdio_cfg.cfg.vendor_id = WCN_VENDOR_DEFAULT;
+
+	/* bit[4]: sdio_rx_mode: 0: adma; 1: sdma */
+	if (sprdwcn_bus_get_rx_mode()) {
+		sdio_cfg.cfg.sdio_rx_mode = 0;
+		WCN_DEBUG("sdio_config rx mode:[adma]\n");
+	} else {
+		sdio_cfg.cfg.sdio_rx_mode = 1;
+		WCN_INFO("sdio_config rx mode:[sdma]\n");
+	}
+
+	/* bit[7:5]: sdio_blk_size: 000: blocksize 840; 001: blocksize 512 */
+	if (sprdwcn_bus_get_blk_size() == 512) {
+		sdio_cfg.cfg.sdio_blk_size = 1;
+		WCN_INFO("sdio_config blksize:[512]\n");
+	} else
+		WCN_DEBUG("sdio_config blksize:[840]\n");
+
+	/*
+	 * bit[8]: bt_wake_host_en: 0: disable, 1: enable
+	 *
+	 * When bit[8] is 1, bit[10:9] region will be parsed:
+	 * bit[10:9]: bt_wake_host_trigger_type:
+	 * 00:BT_WAKEUP_HOST  trigger type low
+	 * 01:BT_WAKEUP_HOST  trigger type rising
+	 * 10:BT_WAKEUP_HOST  trigger type falling
+	 * 11:BT_WAKEUP_HOST  trigger type high
+	 */
+	if (marlin_get_bt_wl_wake_host_en() & BIT(BT_WAKE_HOST)) {
+		sdio_cfg.cfg.bt_wake_host_en = 1;
+		WCN_DEBUG("sdio_config bt_wake_host:[en]\n");
+		sdio_cfg.cfg.bt_wake_host_trigger_type = 3;
+		WCN_INFO("sdio_config bt_wake_host trigger:[high]\n");
+	}
+
+	/* bit[12:11]: sdio_irq_type:
+	 * 00:dedicated irq, gpio1
+	 * 01:inband data1 irq
+	 * 10:use BT_WAKEUP_HOST(pubint) pin as gpio irq
+	 * 11:use WL_WAKEUP_HOST(esmd3) pin as gpio irq
+	 */
+	if (sprdwcn_bus_get_irq_type() != 0) {
+		sdio_cfg.cfg.sdio_irq_type = 1;
+		WCN_INFO("sdio_config irq:[inband]\n");
+	} else {
+		WCN_INFO("sdio_config sdio_irq:[gpio1]\n");
+	}
+
+	/*
+	 * bit[15]: wl_wake_host_en: 0: disable, 1: enable
+	 *
+	 * When bit[15] is 1, bit[17:16] region will be parsed:
+	 * bit[17:16]: wl_wake_host_trigger_type:
+	 * 00:WL_WAKEUP_HOST  trigger type low
+	 * 01:WL_WAKEUP_HOST  trigger type rising
+	 * 10:WL_WAKEUP_HOST  trigger type falling
+	 * 11:WL_WAKEUP_HOST  trigger type high
+	 */
+	if (marlin_get_bt_wl_wake_host_en() & BIT(WL_WAKE_HOST)) {
+		sdio_cfg.cfg.wl_wake_host_en = 1;
+		WCN_DEBUG("sdio_config wl_wake_host:[en]\n");
+		sdio_cfg.cfg.wl_wake_host_trigger_type = 3;
+		WCN_INFO("sdio_config wl_wake_host trigger:[high]\n");
+	}
+
+	/*
+	 * bit[22:18]: wake_host_level_duration_10s: BT_WAKEUP_HOST or
+	 * WL_WAKEUP_HOST level dyration time per 10ms,
+	 * example: 0:0ms; 3:30ms; 20:200ms
+	 */
+	sdio_cfg.cfg.wake_host_level_duration_10ms = 2;
+	WCN_INFO("sdio_config wake_host_level_duration_time:[%dms]\n",
+		 (sdio_cfg.cfg.wake_host_level_duration_10ms * 10));
+
+	WCN_INFO("sdio_config wake_host_data_separation:[bt/wifi reuse]\n");
+#else
+	/* Default config */
+	sdio_cfg.val = 0;
+#endif
+
+	marlin_dev->sync_f.sdio_config = sdio_cfg.val;
+}
+
+static int marlin_send_sdio_config_to_cp(void)
+{
+	int sdio_config_off = 0;
+
+	sdio_config_off = (unsigned long)(&(marlin_dev->sync_f.sdio_config)) -
+		(unsigned long)(&(marlin_dev->sync_f));
+	WCN_DEBUG("sdio_config_offset:0x%x\n", sdio_config_off);
+
+	marlin_send_sdio_config_to_cp_vendor();
+
+	WCN_INFO("%s sdio_config:0x%x (%sable config)\n",
+		 __func__, marlin_dev->sync_f.sdio_config,
+		 (marlin_dev->sync_f.sdio_config & BIT(0)) ? "en" : "dis");
+
+	return sprdwcn_bus_reg_write(SYNC_ADDR + sdio_config_off,
+				     &(marlin_dev->sync_f.sdio_config), 4);
+}
+#endif
+static int marlin_write_cali_data(void)
+{
+	int ret = 0, init_state = 0, cali_data_offset = 0;
+	int i = 0;
+
+	//WCN_INFO("tsx_dac_data:%d\n", marlin_dev->tsxcali.tsxdata.dac);
+	cali_data_offset = (unsigned long)(&(marlin_dev->sync_f.tsx_dac_data))-
+		(unsigned long)(&(marlin_dev->sync_f));
+	WCN_DEBUG("cali_data_offset:0x%x\n", cali_data_offset);
+
+	do {
+		i++;
+		ret = sprdwcn_bus_reg_read(SYNC_ADDR, &init_state, 4);
+		if (ret < 0) {
+			WCN_ERR("%s marlin3 read SYNC_ADDR error:%d\n",
+				__func__, ret);
+			return ret;
+		}
+		WCN_INFO("%s sync init_state:0x%x\n", __func__, init_state);
+
+		if (init_state != SYNC_CALI_WAITING)
+			msleep(20);
+		/* wait cp in the state of waiting cali data */
+		else {
+			/*write cali data to cp*/
+#ifdef CONFIG_SDIOHAL
+			/*write sdio config to cp*/
+			ret = marlin_send_sdio_config_to_cp();
+			if (ret < 0) {
+				WCN_ERR("write sdio_config error:%d\n", ret);
+				return ret;
+			}
+#endif
+			/*tell cp2 can handle cali data*/
+			init_state = SYNC_CALI_WRITE_DONE;
+			ret = sprdwcn_bus_reg_write(SYNC_ADDR, &init_state, 4);
+			if (ret < 0) {
+				WCN_ERR("write cali_done flag error:%d\n", ret);
+				return ret;
+			}
+
+			i = 0;
+			WCN_INFO("marlin_write_cali_data finish\n");
+			return ret;
+		}
+
+		if (i > 10)
+			i = 0;
+	} while (i);
+
+	return ret;
+
+}
+
+static int spi_read_rf_reg(unsigned int addr, unsigned int *data)
+{
+	unsigned int reg_data = 0;
+	int ret;
+
+	reg_data = ((addr & 0x7fff) << 16) | SPI_BIT31;
+	ret = sprdwcn_bus_reg_write(SPI_BASE_ADDR, &reg_data, 4);
+	if (ret < 0) {
+		WCN_ERR("write SPI RF reg error:%d\n", ret);
+		return ret;
+	}
+
+	usleep_range(4000, 6000);
+
+	ret = sprdwcn_bus_reg_read(SPI_BASE_ADDR, &reg_data, 4);
+	if (ret < 0) {
+		WCN_ERR("read SPI RF reg error:%d\n", ret);
+		return ret;
+	}
+	*data = reg_data & 0xffff;
+
+	return 0;
+}
+
+static int check_cp_clock_mode(void)
+{
+	int ret = 0;
+	unsigned int temp_val;
+
+	WCN_DEBUG("%s\n", __func__);
+
+	ret = spi_read_rf_reg(AD_DCXO_BONDING_OPT, &temp_val);
+	if (ret < 0) {
+		WCN_ERR("read AD_DCXO_BONDING_OPT error:%d\n", ret);
+		return ret;
+	}
+	WCN_DEBUG("read AD_DCXO_BONDING_OPT val:0x%x\n", temp_val);
+	if ((temp_val & tsx_mode) == tsx_mode)
+		WCN_INFO("clock mode: TSX\n");
+	else {
+		WCN_INFO("clock mode: TCXO, outside clock\n");
+	}
+
+	return ret;
+}
+
+/* release CPU */
+static int marlin_start_run(void)
+{
+	int ret = 0;
+	unsigned int ss_val;
+
+	WCN_DEBUG("marlin_start_run\n");
+
+	marlin_tsx_cali_data_get();
+#ifdef CONFIG_WCN_SLP
+	sdio_pub_int_btwf_en0();
+	/* after chip power on, reset sleep status */
+	slp_mgr_reset();
+#endif
+
+	ret = sprdwcn_bus_reg_read(CP_RESET_REG, &ss_val, 4);
+	if (ret < 0) {
+		WCN_ERR("%s read reset reg error:%d\n", __func__, ret);
+		return ret;
+	}
+	WCN_INFO("%s read reset reg val:0x%x\n", __func__, ss_val);
+	ss_val  &= (~(RESET_BIT));
+	WCN_INFO("after do %s reset reg val:0x%x\n", __func__, ss_val);
+	ret = sprdwcn_bus_reg_write(CP_RESET_REG, &ss_val, 4);
+	if (ret < 0) {
+		WCN_ERR("%s write reset reg error:%d\n", __func__, ret);
+		return ret;
+	}
+	marlin_bootup_time_update();	/* update the time at once. */
+
+	ret = sprdwcn_bus_reg_read(CP_RESET_REG, &ss_val, 4);
+	if (ret < 0) {
+		WCN_ERR("%s read reset reg error:%d\n", __func__, ret);
+		return ret;
+	}
+	WCN_DEBUG("%s reset reg val:0x%x\n", __func__, ss_val);
+
+	return ret;
+}
+
+#ifdef CONFIG_AW_BIND_VERIFY
+#include <crypto/sha2.h>
+
+static void expand_seed(u8 *seed, u8 *out)
+{
+	unsigned char hash[64];
+	int i;
+
+	sha256(seed, 4, hash);
+
+	for (i = 0; i < 4; i++) {
+		memcpy(&out[i * 9], &hash[i * 8], 8);
+		out[i * 9 + 8] = seed[i];
+	}
+}
+
+static int wcn_bind_verify_calculate_verify_data(u8 *in, u8 *out)
+{
+	u8 seed[4], buf[36], a, b, c;
+	int i, n;
+
+	for (i = 0, n = 0; i < 4; i++) {
+		a = in[n++];
+		b = in[n++];
+		c = in[n++];
+		seed[i] = (a & b) ^ (a & c) ^ (b & c) ^ in[i + 12];
+	}
+
+	expand_seed(seed, buf);
+
+	for (i = 0, n = 0; i < 12; i++) {
+		a = buf[n++];
+		b = buf[n++];
+		c = buf[n++];
+		out[i] = (a & b) ^ (a & c) ^ (b & c);
+	}
+
+	for (i = 0, n = 0; i < 4; i++) {
+		a = out[n++];
+		b = out[n++];
+		c = out[n++];
+		seed[i] = (a & b) ^ (~a & c);
+	}
+
+	expand_seed(seed, buf);
+
+	for (i = 0, n = 0; i < 12; i++) {
+		a = buf[n++];
+		b = buf[n++];
+		c = buf[n++];
+		out[i] = (a & b) ^ (~a & c);
+	}
+
+	for (i = 0, n = 0; i < 4; i++) {
+		a = out[n++];
+		b = out[n++];
+		c = out[n++];
+		out[i + 12] = (a & b) ^ (a & c) ^ (b & c) ^ seed[i];
+	}
+
+	return 0;
+}
+
+static int marlin_bind_verify(void)
+{
+	unsigned char din[16], dout[16];
+	int bind_verify_data_off = 0, init_state, ret = 0;
+
+	/*transform confuse data to verify data*/
+	memcpy(din, &marlin_dev->sync_f.bind_verify_data[0], 16);
+	WCN_INFO("%s confuse data: 0x%02x%02x%02x%02x%02x%02x%02x%02x"
+		 "%02x%02x%02x%02x%02x%02x%02x%02x\n", __func__,
+		 din[0], din[1], din[2], din[3],
+		 din[4], din[5], din[6], din[7],
+		 din[8], din[9], din[10], din[11],
+		 din[12], din[13], din[14], din[15]);
+	wcn_bind_verify_calculate_verify_data(din, dout);
+	WCN_INFO("%s verify data: 0x%02x%02x%02x%02x%02x%02x%02x%02x"
+		 "%02x%02x%02x%02x%02x%02x%02x%02x\n", __func__,
+		 dout[0], dout[1], dout[2], dout[3],
+		 dout[4], dout[5], dout[6], dout[7],
+		 dout[8], dout[9], dout[10], dout[11],
+		 dout[12], dout[13], dout[14], dout[15]);
+
+	/*send bind verify data to cp2*/
+	memcpy(&marlin_dev->sync_f.bind_verify_data[0], dout, 16);
+	bind_verify_data_off = (unsigned long)
+		(&(marlin_dev->sync_f.bind_verify_data[0])) -
+		(unsigned long)(&(marlin_dev->sync_f));
+	ret = sprdwcn_bus_direct_write(SYNC_ADDR + bind_verify_data_off,
+		&(marlin_dev->sync_f.bind_verify_data[0]), 16);
+	if (ret < 0) {
+		WCN_ERR("write bind verify data error:%d\n", ret);
+		return ret;
+	}
+
+	/*tell cp2 can handle bind verify data*/
+	init_state = SYNC_VERIFY_WRITE_DONE;
+	ret = sprdwcn_bus_reg_write(SYNC_ADDR, &init_state, 4);
+	if (ret < 0) {
+		WCN_ERR("write bind verify flag error:%d\n", ret);
+		return ret;
+	}
+
+	return ret;
+}
+#endif
+
+static int check_cp_ready(void)
+{
+	int ret = 0;
+	int i = 0;
+
+	do {
+		i++;
+		ret = sprdwcn_bus_direct_read(SYNC_ADDR,
+			&(marlin_dev->sync_f), sizeof(struct wcn_sync_info_t));
+		if (ret < 0) {
+			WCN_ERR("%s marlin3 read SYNC_ADDR error:%d\n",
+				__func__, ret);
+			return ret;
+		}
+		WCN_INFO("%s sync val:0x%x, prj_type val:0x%x\n", __func__,
+				marlin_dev->sync_f.init_status,
+				marlin_dev->sync_f.prj_type);
+		if (marlin_dev->sync_f.init_status == SYNC_ALL_FINISHED)
+			i = 0;
+#ifdef CONFIG_AW_BIND_VERIFY
+		else if (marlin_dev->sync_f.init_status ==
+			SYNC_VERIFY_WAITING) {
+			ret = marlin_bind_verify();
+			if (ret != 0) {
+				WCN_ERR("%s bind verify error:%d\n",
+					__func__, ret);
+				return ret;
+			}
+		}
+#endif
+		else
+			msleep(20);
+		if (i > 10)
+			return -1;
+	} while (i);
+
+	return 0;
+}
+
+#if defined CONFIG_UWE5623 || defined CONFIG_CHECK_DRIVER_BY_CHIPID
+static int marlin_reset_by_128_bit(void)
+{
+	unsigned char reg;
+
+	WCN_INFO("%s entry\n", __func__);
+	if (sprdwcn_bus_aon_readb(REG_CP_RST_CHIP, &reg)) {
+		WCN_ERR("%s line:%d\n", __func__, __LINE__);
+		return -1;
+	}
+
+	reg |= 1;
+	if (sprdwcn_bus_aon_writeb(REG_CP_RST_CHIP, reg)) {
+		WCN_ERR("%s line:%d\n", __func__, __LINE__);
+		return -1;
+	}
+
+	return 0;
+}
+#endif
+
+static int marlin_reset(int val)
+{
+#ifndef CONFIG_CHECK_DRIVER_BY_CHIPID
+#ifdef CONFIG_UWE5623
+	marlin_reset_by_128_bit();
+#endif
+#else /*CONFIG_CHECK_DRIVER_BY_CHIPID*/
+	if (wcn_get_chip_model() == WCN_CHIP_MARLIN3E)
+		marlin_reset_by_128_bit();
+#endif
+
+	if (marlin_dev->reset > 0) {
+		if (gpio_is_valid(marlin_dev->reset)) {
+			gpio_direction_output(marlin_dev->reset, 0);
+			mdelay(RESET_DELAY);
+			gpio_direction_output(marlin_dev->reset, 1);
+		}
+	}
+
+	return 0;
+}
+
+static int chip_reset_release(int val)
+{
+	static unsigned int reset_count;
+
+	if (marlin_dev->reset <= 0)
+		return 0;
+
+	if (!gpio_is_valid(marlin_dev->reset)) {
+		WCN_ERR("reset gpio error\n");
+		return -1;
+	}
+	if (val) {
+		if (reset_count == 0)
+			gpio_direction_output(marlin_dev->reset, 1);
+		reset_count++;
+	} else {
+		gpio_direction_output(marlin_dev->reset, 0);
+		reset_count--;
+	}
+
+	return 0;
+}
+void marlin_chip_en(bool enable, bool reset)
+{
+	static unsigned int chip_en_count;
+
+	/*
+	 * Incar board pull chipen gpio at pin control.
+	 * Hisi board pull chipen gpio at hi_sdio_detect.ko.
+	 */
+	if (marlin_dev->chip_en <= 0)
+		return;
+
+	if (gpio_is_valid(marlin_dev->chip_en)) {
+		if (reset) {
+			gpio_direction_output(marlin_dev->chip_en, 0);
+			WCN_INFO("marlin gnss chip en reset\n");
+			msleep(100);
+			gpio_direction_output(marlin_dev->chip_en, 1);
+		} else if (enable) {
+			if (chip_en_count == 0) {
+				gpio_direction_output(marlin_dev->chip_en, 0);
+				mdelay(1);
+				gpio_direction_output(marlin_dev->chip_en, 1);
+				mdelay(1);
+				WCN_INFO("marlin chip en pull up\n");
+			}
+			chip_en_count++;
+		} else {
+			chip_en_count--;
+			if (chip_en_count == 0) {
+				gpio_direction_output(marlin_dev->chip_en, 0);
+				WCN_INFO("marlin chip en pull down\n");
+			}
+		}
+	}
+}
+EXPORT_SYMBOL_GPL(marlin_chip_en);
+
+/*
+ * MARLIN_AUTO no need loopcheck action
+ */
+static void power_state_notify_or_not(int subsys, int poweron)
+{
+#ifndef CONFIG_WCN_LOOPCHECK
+	return;
+#endif
+
+	if ((test_bit(MARLIN_BLUETOOTH, &marlin_dev->power_state) +
+	      test_bit(MARLIN_FM, &marlin_dev->power_state) +
+	      test_bit(MARLIN_WIFI, &marlin_dev->power_state) +
+	      test_bit(MARLIN_MDBG, &marlin_dev->power_state)) == 1) {
+#ifdef CONFIG_WCN_LOOPCHECK
+		WCN_DEBUG("only one module open, need to notify loopcheck\n");
+		start_loopcheck();
+#endif
+		marlin_dev->loopcheck_status_change = 1;
+		wakeup_loopcheck_int();
+	}
+
+	if (((marlin_dev->power_state) & MARLIN_MASK) == 0) {
+#ifdef CONFIG_WCN_LOOPCHECK
+		WCN_DEBUG("marlin close, need to notify loopcheck\n");
+		stop_loopcheck();
+#endif
+		marlin_dev->loopcheck_status_change = 1;
+		wakeup_loopcheck_int();
+
+	}
+}
+
+static void pre_btwifi_download_sdio(struct work_struct *work)
+{
+	wcn_get_chip_name();
+
+	if (btwifi_download_firmware() == 0 &&
+		marlin_start_run() == 0) {
+		check_cp_clock_mode();
+		marlin_write_cali_data();
+		/* check_cp_ready must be in front of mem_pd_save_bin,
+		 * save bin task is scheduled after verify.
+		 */
+		if (check_cp_ready() != 0) {
+			sprdwcn_bus_set_carddump_status(true);
+			return;
+		}
+		sprdwcn_bus_runtime_get();
+
+#ifndef CONFIG_WCND
+		get_cp2_version();
+		switch_cp2_log(false);
+#endif
+		complete(&marlin_dev->download_done);
+	}
+}
+
+/*
+ * RST_N (LOW)
+ * VDDIO -> DVDD12/11 ->CHIP_EN ->DVDD_CORE(inner)
+ * ->(>=550uS) RST_N (HIGH)
+ * ->(>=100uS) ADVV12
+ * ->(>=10uS)  AVDD33
+ */
+int chip_power_on(int subsys)
+{
+	WCN_DEBUG("%s\n", __func__);
+
+	marlin_chip_en(true, false);
+	msleep(20);
+	chip_reset_release(1);
+	sprdwcn_bus_driver_register();
+
+	loopcheck_first_boot_set();
+	if (marlin_dev->int_ap > 0)
+		sdio_pub_int_poweron(true);
+
+	return 0;
+}
+
+int chip_power_off(int subsys)
+{
+	WCN_INFO("%s\n", __func__);
+
+	sprdwcn_bus_driver_unregister();
+	marlin_chip_en(false, false);
+	chip_reset_release(0);
+	marlin_dev->wifi_need_download_ini_flag = 0;
+	marlin_dev->power_state = 0;
+	sprdwcn_bus_remove_card();
+	loopcheck_first_boot_clear();
+	if (marlin_dev->int_ap > 0)
+		sdio_pub_int_poweron(false);
+
+	return 0;
+}
+
+int open_power_ctl(void)
+{
+	marlin_dev->no_power_off = 0;
+	clear_bit(WCN_AUTO, &marlin_dev->power_state);
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(open_power_ctl);
+
+void marlin_schedule_download_wq(void)
+{
+	schedule_work(&marlin_dev->download_wq);
+}
+
+static int marlin_set_power(int subsys, int val)
+{
+	unsigned long timeleft;
+
+	WCN_DEBUG("mutex_lock\n");
+// 	mutex_lock(&marlin_dev->power_lock);
+
+	WCN_INFO("marlin power state:%lx, subsys: [%s] power %d\n",
+			marlin_dev->power_state, strno(subsys), val);
+	init_completion(&marlin_dev->download_done);
+
+	/*  power on */
+	if (val) {
+		/* 1. when the first open:
+		 * `- first download gnss, and then download btwifi
+		 */
+		marlin_dev->first_power_on_flag++;
+		if (marlin_dev->first_power_on_flag == 1) {
+			WCN_INFO("the first power on start\n");
+			if (chip_power_on(subsys) < 0) {
+				WCN_ERR("chip power on fail\n");
+				goto out;
+			}
+			set_bit(subsys, &marlin_dev->power_state);
+			WCN_INFO("then marlin start to download\n");
+			schedule_work(&marlin_dev->download_wq);
+			timeleft = wait_for_completion_timeout(
+				&marlin_dev->download_done,
+				msecs_to_jiffies(POWERUP_WAIT_MS));
+			if (!timeleft) {
+				WCN_ERR("marlin download timeout\n");
+				goto out;
+			}
+			marlin_dev->download_finish_flag = 1;
+			WCN_INFO("then marlin download finished and run ok\n");
+			marlin_dev->first_power_on_flag = 2;
+			WCN_DEBUG("mutex_unlock\n");
+			mutex_unlock(&marlin_dev->power_lock);
+			power_state_notify_or_not(subsys, val);
+			return 0;
+		}
+		/* 2. the second time, WCN_AUTO coming */
+		else if (subsys == WCN_AUTO) {
+			if (marlin_dev->no_power_off) {
+				WCN_INFO("have power on, no action\n");
+				set_bit(subsys, &marlin_dev->power_state);
+			}
+
+			else {
+
+				WCN_INFO("!1st,not to bkup gnss cal, no act\n");
+			}
+		}
+
+		/* 3. when GNSS open,
+		 *	  |- GNSS and MARLIN have power on and ready
+		 */
+		else if (((marlin_dev->power_state) & AUTO_RUN_MASK) != 0) {
+			WCN_INFO("GNSS and marlin have ready\n");
+			if (((marlin_dev->power_state) & MARLIN_MASK) == 0)
+				loopcheck_first_boot_set();
+			set_bit(subsys, &marlin_dev->power_state);
+
+			goto check_power_state_notify;
+		}
+		/* 4. when GNSS close, marlin open.
+		 *	  ->  subsys=gps,GNSS download
+		 */
+		else if (((marlin_dev->power_state) & MARLIN_MASK) != 0) {
+			if (subsys == WCN_AUTO) {
+				WCN_INFO("BTWF ready, GPS start to download\n");
+				set_bit(subsys, &marlin_dev->power_state);
+				WCN_INFO("GNSS download finished and ok\n");
+
+			} else {
+				WCN_INFO("marlin have open, GNSS is closed\n");
+				set_bit(subsys, &marlin_dev->power_state);
+
+				goto check_power_state_notify;
+			}
+		}
+		/* 5. when GNSS close, marlin close.no module to power on */
+		else {
+			WCN_INFO("no module to power on, start to power on\n");
+			if (chip_power_on(subsys) < 0) {
+				WCN_ERR("chip power on fail\n");
+				goto out;
+			}
+			set_bit(subsys, &marlin_dev->power_state);
+
+			/* 5.1 first download marlin, and then download gnss */
+			if (subsys == WCN_AUTO) {
+				WCN_INFO("marlin start to download\n");
+				schedule_work(&marlin_dev->download_wq);
+				timeleft = wait_for_completion_timeout(
+					&marlin_dev->download_done,
+					msecs_to_jiffies(POWERUP_WAIT_MS));
+				if (!timeleft) {
+					WCN_ERR("marlin download timeout\n");
+					goto out;
+				}
+				marlin_dev->download_finish_flag = 1;
+
+				WCN_INFO("marlin dl finished and run ok\n");
+
+			}
+			/* 5.2 only download marlin, and then
+			 * close gnss power domain
+			 */
+			else {
+				WCN_INFO("only marlin start to download\n");
+				schedule_work(&marlin_dev->download_wq);
+				if (wait_for_completion_timeout(
+					&marlin_dev->download_done,
+					msecs_to_jiffies(POWERUP_WAIT_MS))
+					<= 0) {
+
+					WCN_ERR("marlin download timeout\n");
+					goto out;
+				}
+				marlin_dev->download_finish_flag = 1;
+				WCN_INFO("BTWF download finished and run ok\n");
+			}
+		}
+		/* power on together's Action */
+		power_state_notify_or_not(subsys, val);
+
+		WCN_INFO("wcn chip power on and run finish: [%s]\n",
+				  strno(subsys));
+	/* power off */
+	} else {
+		if (marlin_dev->power_state == 0)
+			goto check_power_state_notify;
+
+		if (flag_reset)
+			marlin_dev->power_state = 0;
+
+		if (marlin_dev->no_power_off) {
+			if (!flag_reset) {
+				if (subsys != WCN_AUTO) {
+					/* in order to not download again */
+					set_bit(WCN_AUTO,
+						&marlin_dev->power_state);
+					clear_bit(subsys,
+						&marlin_dev->power_state);
+				}
+
+				MDBG_LOG("marlin reset flag_reset:%d\n",
+					flag_reset);
+
+				goto check_power_state_notify;
+			}
+		}
+
+		if (!marlin_dev->download_finish_flag)
+			goto check_power_state_notify;
+
+		clear_bit(subsys, &marlin_dev->power_state);
+		if (marlin_dev->power_state != 0) {
+			WCN_INFO("can not power off, other module is on\n");
+
+			goto check_power_state_notify;
+		}
+
+		power_state_notify_or_not(subsys, val);
+
+		WCN_INFO("wcn chip start power off!\n");
+		sprdwcn_bus_runtime_put();
+		chip_power_off(subsys);
+		WCN_INFO("marlin power off!\n");
+		marlin_dev->download_finish_flag = 0;
+		if (flag_reset)
+			flag_reset = FALSE;
+	} /* power off end */
+
+	/* power on off together's Action */
+	WCN_DEBUG("mutex_unlock\n");
+	mutex_unlock(&marlin_dev->power_lock);
+
+	return 0;
+
+out:
+	sprdwcn_bus_runtime_put();
+	sprdwcn_bus_driver_unregister();
+	chip_reset_release(0);
+	marlin_dev->power_state = 0;
+	WCN_DEBUG("mutex_unlock\n");
+	mutex_unlock(&marlin_dev->power_lock);
+
+	return -1;
+
+check_power_state_notify:
+	power_state_notify_or_not(subsys, val);
+	WCN_DEBUG("mutex_unlock\n");
+	mutex_unlock(&marlin_dev->power_lock);
+
+	return 0;
+}
+
+void marlin_power_off(enum marlin_sub_sys subsys)
+{
+	WCN_INFO("%s all\n", __func__);
+
+	marlin_dev->no_power_off = false;
+	set_bit(subsys, &marlin_dev->power_state);
+	marlin_set_power(subsys, false);
+}
+
+int marlin_get_power(enum marlin_sub_sys subsys)
+{
+	if (subsys == MARLIN_ALL)
+		return marlin_dev->power_state != 0;
+	else
+		return test_bit(subsys, &marlin_dev->power_state);
+}
+EXPORT_SYMBOL_GPL(marlin_get_power);
+
+bool marlin_get_download_status(void)
+{
+	return marlin_dev->download_finish_flag;
+}
+EXPORT_SYMBOL_GPL(marlin_get_download_status);
+
+int wcn_get_module_status_changed(void)
+{
+	return marlin_dev->loopcheck_status_change;
+}
+EXPORT_SYMBOL_GPL(wcn_get_module_status_changed);
+
+void wcn_set_module_status_changed(bool status)
+{
+	marlin_dev->loopcheck_status_change = status;
+}
+EXPORT_SYMBOL_GPL(wcn_set_module_status_changed);
+
+int marlin_get_module_status(void)
+{
+	if (test_bit(MARLIN_BLUETOOTH, &marlin_dev->power_state) ||
+		test_bit(MARLIN_FM, &marlin_dev->power_state) ||
+		test_bit(MARLIN_WIFI, &marlin_dev->power_state) ||
+		test_bit(MARLIN_MDBG, &marlin_dev->power_state) ||
+		test_bit(WCN_AUTO, &marlin_dev->power_state))
+		return 1;
+	else
+		return 0;
+}
+EXPORT_SYMBOL_GPL(marlin_get_module_status);
+
+int is_first_power_on(enum marlin_sub_sys subsys)
+{
+	if (marlin_dev->wifi_need_download_ini_flag == 1)
+		return 1;	/* the first */
+	else
+		return 0;	/* not the first */
+}
+EXPORT_SYMBOL_GPL(is_first_power_on);
+
+int cali_ini_need_download(enum marlin_sub_sys subsys)
+{
+	if (marlin_dev->wifi_need_download_ini_flag == 1) {
+		WCN_INFO("cali_ini_need_download return 1\n");
+		return 1;	/* the first */
+	}
+	return 0;	/* not the first */
+}
+EXPORT_SYMBOL_GPL(cali_ini_need_download);
+
+/* Temporary modification for UWE5623:
+ * cmd52 read/write timeout -110 issue.
+ */
+void marlin_read_test_after_reset(void)
+{
+	int ret;
+	unsigned int reg_addr = AON_APB_TEST_READ_REG, reg_val;
+
+	ret = sprdwcn_bus_reg_read(reg_addr, &reg_val, 4);
+	if (ret < 0)
+		WCN_ERR("%s read 0x%x error:%d\n", __func__, reg_addr, ret);
+	else
+		WCN_INFO("%s read 0x%x = 0x%x\n", __func__, reg_addr, reg_val);
+}
+
+int marlin_reset_reg(void)
+{
+	marlin_reset(true);
+	mdelay(1);
+
+	/* Temporary modification for UWE5623:
+	 * cmd52 read/write timeout -110 issue.
+	 */
+	marlin_read_test_after_reset();
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(marlin_reset_reg);
+
+int start_marlin(u32 subsys)
+{
+	WCN_INFO("%s [%s]\n", __func__, strno(subsys));
+	if (sprdwcn_bus_get_carddump_status() != 0) {
+		WCN_ERR("%s SDIO card dump\n", __func__);
+		return -1;
+	}
+
+	if (get_loopcheck_status()) {
+		WCN_ERR("%s loopcheck status is fail\n", __func__);
+		return -1;
+	}
+
+	if (subsys == MARLIN_WIFI) {
+		/* not need write cali */
+		if (marlin_dev->wifi_need_download_ini_flag == 0)
+			/* need write cali */
+			marlin_dev->wifi_need_download_ini_flag = 1;
+		else
+			/* not need write cali */
+			marlin_dev->wifi_need_download_ini_flag = 2;
+	}
+	marlin_set_power(subsys, true);
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(start_marlin);
+
+int stop_marlin(u32 subsys)
+{
+	if (sprdwcn_bus_get_carddump_status() != 0) {
+		WCN_ERR("%s SDIO card dump\n", __func__);
+		return -1;
+	}
+
+	if (get_loopcheck_status()) {
+		WCN_ERR("%s loopcheck status is fail\n", __func__);
+		return -1;
+	}
+
+	return marlin_set_power(subsys, false);
+}
+EXPORT_SYMBOL_GPL(stop_marlin);
+
+static void marlin_power_wq(struct work_struct *work)
+{
+	WCN_INFO("%s start\n", __func__);
+
+	/* WCN_AUTO is for auto backup gnss cali data */
+	marlin_set_power(WCN_AUTO, true);
+}
+
+int marlin_probe(struct device *dev)
+{
+	marlin_dev = devm_kzalloc(dev,
+			sizeof(struct marlin_device), GFP_KERNEL);
+	if (!marlin_dev)
+		return -ENOMEM;
+	marlin_dev->write_buffer = devm_kzalloc(dev,
+			PACKET_SIZE, GFP_KERNEL);
+	if (marlin_dev->write_buffer == NULL) {
+		devm_kfree(dev, marlin_dev);
+		WCN_ERR("marlin_probe write buffer low memory\n");
+		return -ENOMEM;
+	}
+	mutex_init(&(marlin_dev->power_lock));
+	marlin_dev->power_state = 0;
+	if (marlin_parse_dt(dev) < 0)
+		WCN_INFO("marlin2 parse_dt some para not config\n");
+	if (marlin_dev->reset > 0) {
+		if (gpio_is_valid(marlin_dev->reset))
+			gpio_direction_output(marlin_dev->reset, 0);
+	}
+#ifdef CONFIG_WCN_SLP
+	slp_mgr_init();
+#endif
+	/* register ops */
+	wcn_bus_init();
+	/* sdiom_init or pcie_init */
+	sprdwcn_bus_preinit();
+	if (marlin_dev->int_ap > 0)
+		sdio_pub_int_init(marlin_dev->int_ap);
+	proc_fs_init();
+	mdbg_atcmd_owner_init();
+#ifndef CONFIG_WCND
+	loopcheck_init();
+#endif
+
+	flag_reset = 0;
+
+	INIT_WORK(&marlin_dev->download_wq, pre_btwifi_download_sdio);
+	INIT_DELAYED_WORK(&marlin_dev->power_wq, marlin_power_wq);
+
+	WCN_INFO("marlin_probe ok!\n");
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(marlin_probe);
+
+int marlin_remove(struct device *dev)
+{
+	cancel_work_sync(&marlin_dev->download_wq);
+	cancel_delayed_work_sync(&marlin_dev->power_wq);
+#ifndef CONFIG_WCND
+	loopcheck_deinit();
+#endif
+	mdbg_atcmd_owner_deinit();
+	proc_fs_exit();
+	if (marlin_dev->int_ap > 0)
+		sdio_pub_int_deinit();
+
+	sprdwcn_bus_deinit();
+	if ((marlin_dev->power_state != 0) && (!marlin_dev->no_power_off)) {
+		WCN_INFO("marlin some subsys power is on, warning!\n");
+		marlin_chip_en(false, false);
+	}
+	wcn_bus_deinit();
+#ifdef CONFIG_WCN_SLP
+	slp_mgr_deinit();
+#endif
+	marlin_gpio_free();
+	mutex_destroy(&marlin_dev->power_lock);
+
+	WCN_INFO("marlin_remove ok!\n");
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(marlin_remove);
+
+void marlin_shutdown(void)
+{
+	/* When the following three conditions are met at the same time,
+	 * wcn chip will be powered off:
+	 * 1. chip has been powered on (power_state is not 0);
+	 * 2. config power up and down (not keep power on);
+	 * 3. bt/wifi wake host is disabled.
+	 */
+	if ((marlin_dev->power_state != 0) && (!marlin_dev->no_power_off) &&
+		(!marlin_get_bt_wl_wake_host_en())) {
+		WCN_INFO("marlin some subsys power is on, warning!\n");
+		marlin_chip_en(false, false);
+	}
+	WCN_INFO("marlin_shutdown end\n");
+}
+EXPORT_SYMBOL_GPL(marlin_shutdown);
+
+int marlin_reset_register_notify(void *callback_func, void *para)
+{
+	marlin_reset_func = (marlin_reset_callback)callback_func;
+	marlin_callback_para = para;
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(marlin_reset_register_notify);
+
+int marlin_reset_unregister_notify(void)
+{
+	marlin_reset_func = NULL;
+	marlin_callback_para = NULL;
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(marlin_reset_unregister_notify);
+
+MODULE_LICENSE("GPL v2");
+MODULE_DESCRIPTION("Spreadtrum  WCN Marlin Driver");
+MODULE_AUTHOR("Yufeng Yang <yufeng.yang@spreadtrum.com>");
diff --git a/drivers/net/wireless/uwe5622/unisocwcn/platform/wcn_misc.c b/drivers/net/wireless/uwe5622/unisocwcn/platform/wcn_misc.c
new file mode 100644
index 000000000000..e96d41a06a27
--- /dev/null
+++ b/drivers/net/wireless/uwe5622/unisocwcn/platform/wcn_misc.c
@@ -0,0 +1,120 @@
+/*
+ * Copyright (C) 2018 Spreadtrum Communications Inc.
+ *
+ * File:		wcn_misc.c
+ * Description:	WCN misc file for drivers. Some feature or function
+ * isn't easy to classify, then write it in this file.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the	1
+ * GNU General Public License for more details.
+ */
+
+#include <linux/mutex.h>
+#include <linux/version.h>
+#include <linux/time.h>
+#if KERNEL_VERSION(4, 14, 0) <= LINUX_VERSION_CODE
+#include <linux/sched/clock.h>
+#endif
+
+#include "wcn_misc.h"
+#include "wcn_procfs.h"
+#include "wcn_txrx.h"
+#include "mdbg_type.h"
+
+static struct atcmd_fifo s_atcmd_owner;
+static unsigned long int s_marlin_bootup_time;
+
+void mdbg_atcmd_owner_init(void)
+{
+	memset(&s_atcmd_owner, 0, sizeof(s_atcmd_owner));
+	mutex_init(&s_atcmd_owner.lock);
+}
+
+void mdbg_atcmd_owner_deinit(void)
+{
+	mutex_destroy(&s_atcmd_owner.lock);
+}
+
+static void mdbg_atcmd_owner_add(enum atcmd_owner owner)
+{
+	mutex_lock(&s_atcmd_owner.lock);
+	s_atcmd_owner.owner[s_atcmd_owner.tail % ATCMD_FIFO_MAX] = owner;
+	s_atcmd_owner.tail++;
+	mutex_unlock(&s_atcmd_owner.lock);
+}
+
+enum atcmd_owner mdbg_atcmd_owner_peek(void)
+{
+	enum atcmd_owner owner;
+
+	mutex_lock(&s_atcmd_owner.lock);
+	owner = s_atcmd_owner.owner[s_atcmd_owner.head % ATCMD_FIFO_MAX];
+	s_atcmd_owner.head++;
+	mutex_unlock(&s_atcmd_owner.lock);
+
+	WCN_DEBUG("owner=%d, head=%d\n", owner, s_atcmd_owner.head-1);
+	return owner;
+}
+
+void mdbg_atcmd_clean(void)
+{
+	mutex_lock(&s_atcmd_owner.lock);
+	memset(&s_atcmd_owner.owner[0], 0, ARRAY_SIZE(s_atcmd_owner.owner));
+	s_atcmd_owner.head = s_atcmd_owner.tail = 0;
+	mutex_unlock(&s_atcmd_owner.lock);
+}
+
+/*
+ * Until now, CP2 response every AT CMD to AP side
+ * without owner-id.AP side transfer every ATCMD
+ * response info to WCND.If AP send AT CMD on kernel layer,
+ * and the response info transfer to WCND,
+ * WCND deal other owner's response CMD.
+ * We'll not modify CP2 codes because some
+ * products already released to customer.
+ * We will save all of the owner-id to the atcmd fifo.
+ * and dispatch the response ATCMD info to the matched owner.
+ * We'd better send all of the ATCMD with this function
+ * or caused WCND error
+ */
+long int mdbg_send_atcmd(char *buf, long int len, enum atcmd_owner owner)
+{
+	long int sent_size = 0;
+
+	mdbg_atcmd_owner_add(owner);
+
+	/* confirm write finish */
+	mutex_lock(&s_atcmd_owner.lock);
+	sent_size = mdbg_send(buf, len, MDBG_SUBTYPE_AT);
+	mutex_unlock(&s_atcmd_owner.lock);
+
+	WCN_DEBUG("%s, owner=%d\n", buf, owner);
+
+	return sent_size;
+}
+
+/*
+ * Only marlin poweron and marlin starts to run,
+ * it can call this function.
+ * The time will be sent to marlin with loopcheck CMD.
+ * NOTES:If marlin power off, and power on again, it
+ * should call this function again.
+ */
+void marlin_bootup_time_update(void)
+{
+	s_marlin_bootup_time = local_clock();
+	WCN_INFO("s_marlin_bootup_time=%ld",
+		s_marlin_bootup_time);
+}
+
+unsigned long int marlin_bootup_time_get(void)
+{
+	return s_marlin_bootup_time;
+}
+
diff --git a/drivers/net/wireless/uwe5622/unisocwcn/platform/wcn_misc.h b/drivers/net/wireless/uwe5622/unisocwcn/platform/wcn_misc.h
new file mode 100644
index 000000000000..97a1124b6a38
--- /dev/null
+++ b/drivers/net/wireless/uwe5622/unisocwcn/platform/wcn_misc.h
@@ -0,0 +1,72 @@
+#ifndef __WCN_MISC_H__
+#define __WCN_MISC_H__
+
+#include <linux/mutex.h>
+#include <linux/types.h>
+
+/* Hours offset for GM and China-BeiJing */
+#define WCN_BTWF_TIME_OFFSET (8)
+
+#define ATCMD_FIFO_MAX	(16)
+
+/*
+ * AP use 64 bit for ns time.
+ * marlin use 32 bit for ms time
+ * we change ns to ms, and remove high bit value.
+ * 32bit ms is more than 42days, it's engough
+ * for loopcheck debug.
+ */
+#define MARLIN_64B_NS_TO_32B_MS(ns) ((unsigned int)(ns / 1000000))
+
+enum atcmd_owner {
+	/* default AT CMD reply to WCND */
+	WCN_ATCMD_WCND = 0x0,
+	/* Kernel not deal response info from CP2. 20180515 */
+	WCN_ATCMD_KERNEL,
+	WCN_ATCMD_LOG,
+};
+
+/*
+ * Until now, CP2 response every AT CMD to AP side
+ * without owner-id.
+ * AP side transfer every ATCMD response info to WCND.
+ * If AP send AT CMD on kernel layer, and the response
+ * info transfer to WCND and caused WCND deal error
+ * response CMD.
+ * We will save all of the owner-id to the fifo.
+ * and dispatch the response ATCMD info to the matched owner.
+ */
+struct atcmd_fifo {
+	enum atcmd_owner owner[ATCMD_FIFO_MAX];
+	unsigned int head;
+	unsigned int tail;
+	struct mutex lock;
+};
+
+struct wcn_tm {
+	int tm_msec;    /* mili seconds */
+	int tm_sec;     /* seconds */
+	int tm_min;     /* minutes */
+	int tm_hour;    /* hours */
+	int tm_mday;    /* day of the month */
+	int tm_mon;     /* month */
+	int tm_year;    /* year */
+};
+
+void mdbg_atcmd_owner_init(void);
+void mdbg_atcmd_owner_deinit(void);
+long int mdbg_send_atcmd(char *buf, long int len, enum atcmd_owner owner);
+enum atcmd_owner mdbg_atcmd_owner_peek(void);
+void mdbg_atcmd_clean(void);
+/* AP notify BTWF time by at+aptime=... cmd */
+long int wcn_ap_notify_btwf_time(void);
+/*
+ * Only marlin poweron, CP2 CPU tick starts to run,
+ * It can call this function.
+ * The time will be sent to marlin with loopcheck CMD.
+ * NOTES:If marlin power off, and power on again, it
+ * should call this function also.
+ */
+void marlin_bootup_time_update(void);
+unsigned long int marlin_bootup_time_get(void);
+#endif
diff --git a/drivers/net/wireless/uwe5622/unisocwcn/platform/wcn_procfs.c b/drivers/net/wireless/uwe5622/unisocwcn/platform/wcn_procfs.c
new file mode 100644
index 000000000000..212e63a93fc6
--- /dev/null
+++ b/drivers/net/wireless/uwe5622/unisocwcn/platform/wcn_procfs.c
@@ -0,0 +1,944 @@
+/*
+ * Copyright (C) 2015 Spreadtrum Communications Inc.
+ *
+ * File:		wcn_procfs.c
+ * Description:	Marlin Debug System main file. Module,device &
+ * driver related defination.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the	1
+ * GNU General Public License for more details.
+ */
+
+#include <linux/of.h>
+#include <linux/mutex.h>
+#include <linux/poll.h>
+#include <linux/proc_fs.h>
+#include <linux/sched.h>
+#include <linux/sched/clock.h>
+#include <linux/seq_file.h>
+#include <linux/version.h>
+#include <linux/wait.h>
+#include <wcn_bus.h>
+#include "wcn_glb.h"
+#include "wcn_misc.h"
+#include "wcn_procfs.h"
+#include "wcn_txrx.h"
+
+u32 wcn_print_level = WCN_DEBUG_OFF;
+extern unsigned char flag_reset;
+
+static u32 g_dumpmem_switch =  1;
+static u32 g_loopcheck_switch;
+
+struct mdbg_proc_entry {
+	char *name;
+	struct proc_dir_entry *entry;
+	struct completion completed;
+	wait_queue_head_t	rxwait;
+	unsigned int	rcv_len;
+	void *buf;
+};
+
+struct mdbg_proc_t {
+	char *dir_name;
+	struct proc_dir_entry		*procdir;
+	struct mdbg_proc_entry		assert;
+	struct mdbg_proc_entry		loopcheck;
+	struct mdbg_proc_entry		at_cmd;
+	struct mdbg_proc_entry		snap_shoot;
+	struct mutex		mutex;
+	char write_buf[MDBG_WRITE_SIZE];
+	int fail_count;
+	bool first_boot;
+};
+
+static struct mdbg_proc_t *mdbg_proc;
+
+unsigned char *mdbg_get_at_cmd_buf(void)
+{
+	return (unsigned char *)(mdbg_proc->at_cmd.buf);
+}
+
+void mdbg_assert_interface(char *str)
+{
+	int len = MDBG_ASSERT_SIZE;
+
+	if (strlen(str) <= MDBG_ASSERT_SIZE)
+		len = strlen(str);
+#ifndef CONFIG_SC2342_INTEG
+	if (flag_reset == 1) {
+		WCN_INFO("chip in reset...\n");
+		return;
+	}
+#endif
+
+#ifdef CONFIG_WCN_LOOPCHECK
+	stop_loopcheck();
+#endif
+
+	memset(mdbg_proc->assert.buf, 0, MDBG_ASSERT_SIZE);
+	strncpy(mdbg_proc->assert.buf, str, len);
+	WCN_INFO("mdbg_assert_interface:%s\n",
+		(char *)(mdbg_proc->assert.buf));
+
+	sprdwcn_bus_set_carddump_status(true);
+	mdbg_proc->assert.rcv_len = strlen(str);
+	mdbg_proc->fail_count++;
+	complete(&mdbg_proc->assert.completed);
+	wake_up_interruptible(&mdbg_proc->assert.rxwait);
+}
+EXPORT_SYMBOL_GPL(mdbg_assert_interface);
+
+#ifdef CONFIG_SDIOHAL
+/* this function get data length from buf head */
+static unsigned int mdbg_mbuf_get_datalength(struct mbuf_t *mbuf)
+{
+	struct bus_puh_t *puh = NULL;
+
+	puh = (struct bus_puh_t *)mbuf->buf;
+	return puh->len;
+}
+#else
+/* this function get data length from mbuf->len */
+static unsigned int mdbg_mbuf_get_datalength(struct mbuf_t *mbuf)
+{
+	return mbuf->len;
+}
+#endif
+
+static int mdbg_assert_read(int channel, struct mbuf_t *head,
+		     struct mbuf_t *tail, int num)
+{
+	unsigned int data_length;
+
+	data_length = mdbg_mbuf_get_datalength(head);
+	if (data_length > MDBG_ASSERT_SIZE) {
+		WCN_ERR("assert data len:%d,beyond max read:%d",
+			data_length, MDBG_ASSERT_SIZE);
+		sprdwcn_bus_push_list(channel, head, tail, num);
+		return -1;
+	}
+
+	memcpy(mdbg_proc->assert.buf, head->buf + PUB_HEAD_RSV, data_length);
+	mdbg_proc->assert.rcv_len = data_length;
+	WCN_INFO("mdbg_assert_read:%s,data length %d\n",
+		(char *)(mdbg_proc->assert.buf), data_length);
+#ifndef CONFIG_WCND
+	sprdwcn_bus_set_carddump_status(true);
+#endif
+	mdbg_proc->fail_count++;
+	complete(&mdbg_proc->assert.completed);
+	wake_up_interruptible(&mdbg_proc->assert.rxwait);
+	sprdwcn_bus_push_list(channel, head, tail, num);
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(mdbg_assert_read);
+
+static int mdbg_loopcheck_read(int channel, struct mbuf_t *head,
+			struct mbuf_t *tail, int num)
+{
+	unsigned int data_length;
+
+	data_length = mdbg_mbuf_get_datalength(head);
+	if (data_length > MDBG_LOOPCHECK_SIZE) {
+		WCN_ERR("The loopcheck data len:%d,beyond max read:%d",
+			data_length, MDBG_LOOPCHECK_SIZE);
+		sprdwcn_bus_push_list(channel, head, tail, num);
+		return -1;
+	}
+
+	memset(mdbg_proc->loopcheck.buf, 0, MDBG_LOOPCHECK_SIZE);
+	memcpy(mdbg_proc->loopcheck.buf, head->buf + PUB_HEAD_RSV, data_length);
+	mdbg_proc->loopcheck.rcv_len = data_length;
+
+	WCN_DEBUG("mdbg_loopcheck_read:%s\n",
+		  (char *)(mdbg_proc->loopcheck.buf));
+	mdbg_proc->fail_count = 0;
+	complete(&mdbg_proc->loopcheck.completed);
+#ifdef CONFIG_WCN_LOOPCHECK
+	complete_kernel_loopcheck();
+#endif
+	sprdwcn_bus_push_list(channel, head, tail, num);
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(mdbg_loopcheck_read);
+
+static int mdbg_at_cmd_read(int channel, struct mbuf_t *head,
+		     struct mbuf_t *tail, int num)
+{
+	unsigned int data_length;
+
+	data_length = mdbg_mbuf_get_datalength(head);
+	if (data_length > MDBG_AT_CMD_SIZE) {
+		WCN_ERR("The at cmd data len:%d,beyond max read:%d",
+			data_length, MDBG_AT_CMD_SIZE);
+		sprdwcn_bus_push_list(channel, head, tail, num);
+		return -1;
+	}
+
+	switch (mdbg_atcmd_owner_peek()) {
+	/* until now, KERNEL no need deal with the response from CP2 */
+	case WCN_ATCMD_KERNEL:
+	case WCN_ATCMD_LOG:
+		WCN_INFO("KERNEL at cmd %s\n",
+			(char *)head->buf + PUB_HEAD_RSV);
+		sprdwcn_bus_push_list(channel, head, tail, num);
+		break;
+
+	case WCN_ATCMD_WCND:
+	default:
+		memset(mdbg_proc->at_cmd.buf, 0, MDBG_AT_CMD_SIZE);
+		memcpy(mdbg_proc->at_cmd.buf, head->buf + PUB_HEAD_RSV,
+		       data_length);
+		mdbg_proc->at_cmd.rcv_len = data_length;
+		WCN_INFO("WCND at cmd read:%s\n",
+			(char *)(mdbg_proc->at_cmd.buf));
+		complete(&mdbg_proc->at_cmd.completed);
+#ifndef CONFIG_WCND
+		complete_kernel_atcmd();
+#endif
+		sprdwcn_bus_push_list(channel, head, tail, num);
+
+		break;
+	}
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(mdbg_at_cmd_read);
+
+static ssize_t mdbg_snap_shoot_seq_write(struct file *file,
+					 const char __user *buffer,
+					 size_t count, loff_t *ppos)
+{
+	/* nothing to do */
+	return count;
+}
+
+static void *mdbg_snap_shoot_seq_start(struct seq_file *m, loff_t *pos)
+{
+	u8 *pdata;
+	u8 *buf;
+	s32 ret = 0;
+
+	if (!*(u32 *)pos) {
+		buf = mdbg_proc->snap_shoot.buf;
+		memset(buf, 0, MDBG_SNAP_SHOOT_SIZE);
+#ifdef CONFIG_SC2342_INTEG
+		ret = mdbg_snap_shoot_iram(buf);
+		if (ret < 0) {
+			seq_puts(m, "==== IRAM DATA SNAP SHOOT FAIL ====\n");
+			return NULL;
+		}
+		seq_puts(m, "==== IRAM DATA SNAP SHOOT START ====\n");
+#else
+		WCN_ERR("not support iram snap shoot! ret %d\n", ret);
+		seq_puts(m, "==== IRAM DATA SNAP SHOOT NOT SUPPORT ====\n");
+		return NULL;
+#endif
+	}
+
+	pdata = mdbg_proc->snap_shoot.buf + *(u32 *)pos * 16;
+	(*(u32 *)pos)++;
+
+	if (*(u32 *)pos > 2048) {
+		seq_puts(m, "==== IRAM DATA SNAP SHOOT END    ====\n");
+		return NULL;
+	} else
+		return pdata;
+}
+
+static void *mdbg_snap_shoot_seq_next(struct seq_file *m, void *p, loff_t *pos)
+
+{
+	return mdbg_snap_shoot_seq_start(m, pos);
+}
+
+static void mdbg_snap_shoot_seq_stop(struct seq_file *m, void *p)
+{
+	/* nothing to do */
+}
+
+static int mdbg_snap_shoot_seq_show(struct seq_file *m, void *p)
+{
+	u8 *pdata;
+	u32 loop;
+
+	if (p) {
+		for (loop = 0; loop < 2; loop++) {
+			pdata = p + 8*loop;
+			seq_printf(m, "0x%02x%02x%02x%02x 0x%02x%02x%02x%02x ",
+					pdata[3], pdata[2], pdata[1], pdata[0],
+					pdata[7], pdata[6], pdata[5], pdata[4]);
+		}
+		seq_puts(m, "\n");
+	}
+
+	return 0;
+}
+
+static const struct seq_operations mdbg_snap_shoot_seq_ops = {
+	.start = mdbg_snap_shoot_seq_start,
+	.next = mdbg_snap_shoot_seq_next,
+	.stop = mdbg_snap_shoot_seq_stop,
+	.show = mdbg_snap_shoot_seq_show
+};
+
+static int mdbg_snap_shoot_seq_open(struct inode *inode, struct file *file)
+{
+	return seq_open(file, &mdbg_snap_shoot_seq_ops);
+}
+
+static const struct proc_ops mdbg_snap_shoot_seq_fops = {
+	.proc_open = mdbg_snap_shoot_seq_open,
+	.proc_read = seq_read,
+	.proc_write = mdbg_snap_shoot_seq_write,
+	.proc_lseek = seq_lseek,
+	.proc_release = seq_release
+};
+
+static int mdbg_proc_open(struct inode *inode, struct file *filp)
+{
+	struct mdbg_proc_entry *entry =
+		(struct mdbg_proc_entry *)PDE_DATA(inode);
+	filp->private_data = entry;
+
+	return 0;
+}
+
+static int mdbg_proc_release(struct inode *inode, struct file *filp)
+{
+	return 0;
+}
+
+static ssize_t mdbg_proc_read(struct file *filp,
+		char __user *buf, size_t count, loff_t *ppos)
+{
+	struct mdbg_proc_entry *entry =
+		(struct mdbg_proc_entry *)filp->private_data;
+	char *type = entry->name;
+	int timeout = -1;
+	int len = 0;
+	int ret;
+
+	if (filp->f_flags & O_NONBLOCK)
+		timeout = 0;
+
+	if (strcmp(type, "assert") == 0) {
+		if (timeout < 0) {
+			while (1) {
+				ret = wait_for_completion_timeout(
+						&mdbg_proc->assert.completed,
+						msecs_to_jiffies(1000));
+				if (ret != -ERESTARTSYS)
+					break;
+			}
+		}
+
+		if (copy_to_user((void __user *)buf,
+				mdbg_proc->assert.buf,
+				min(count, (size_t)MDBG_ASSERT_SIZE)))
+			WCN_ERR("Read assert info error\n");
+		len = mdbg_proc->assert.rcv_len;
+		mdbg_proc->assert.rcv_len = 0;
+		memset(mdbg_proc->assert.buf, 0, MDBG_ASSERT_SIZE);
+	}
+
+	if (strcmp(type, "loopcheck") == 0) {
+		if (unlikely(g_loopcheck_switch != 0)) {
+			if (marlin_get_module_status() == 1) {
+				WCN_INFO("fake loopcheck\n");
+				if (copy_to_user((void __user *)buf,
+							"loopcheck_ack", 13))
+					WCN_ERR("fake loopcheck reply error\n");
+				len = 13;
+			} else {
+				if (copy_to_user((void __user *)buf,
+							"poweroff", 8))
+					WCN_ERR("read loopcheck error\n");
+				len = 8;
+				WCN_INFO("loopcheck poweroff\n");
+			}
+			return len;
+		}
+
+		if (!marlin_get_module_status())
+			goto loopcheck_out;
+		if (timeout < 0) {
+			while (1) {
+				ret = wait_for_completion_timeout(
+						&mdbg_proc->loopcheck.completed,
+						msecs_to_jiffies(1000));
+				if (ret != -ERESTARTSYS)
+					break;
+			}
+		}
+		if (marlin_get_module_status() == 1) {
+			if (mdbg_proc->first_boot) {
+				if (copy_to_user((void __user *)buf,
+					"loopcheck_ack", 13))
+					WCN_ERR("loopcheck first error\n");
+				loopcheck_first_boot_clear();
+				WCN_INFO("CP power on first time\n");
+				len = 13;
+			} else
+			if (mdbg_rx_count_change()) {
+			/* fix the error(ack slow),use rx count to verify CP */
+				WCN_INFO("CP run well with rx_cnt change\n");
+				if (copy_to_user((void __user *)buf,
+							"loopcheck_ack", 13))
+					WCN_ERR("loopcheck rx count error\n");
+				len = 13;
+			} else {
+				if (copy_to_user((void __user *)buf,
+					mdbg_proc->loopcheck.buf, min(count,
+						(size_t)MDBG_LOOPCHECK_SIZE)))
+					WCN_ERR("loopcheck cp ack error\n");
+				len = mdbg_proc->loopcheck.rcv_len;
+				/*
+				 * LP: ERROR!
+				 * WORK-AROUND for old CP2 project which
+				 * one already released to customer and can't
+				 * change code.
+				 */
+				if ((strncmp(mdbg_proc->loopcheck.buf,
+					"loopcheck_ack", 13) != 0) &&
+					(strncmp(mdbg_proc->loopcheck.buf,
+					"LP: ERROR!", 10) != 0))
+					mdbg_proc->fail_count++;
+				WCN_INFO("loopcheck status:%d\n",
+					mdbg_proc->fail_count);
+			}
+		} else {
+loopcheck_out:
+			if (copy_to_user((void __user *)buf, "poweroff", 8))
+				WCN_ERR("Read loopcheck poweroff error\n");
+			len = 8;
+			WCN_INFO("mdbg loopcheck poweroff\n");
+		}
+		memset(mdbg_proc->loopcheck.buf, 0, MDBG_LOOPCHECK_SIZE);
+		mdbg_proc->loopcheck.rcv_len = 0;
+	}
+
+	if (strcmp(type, "at_cmd") == 0) {
+		if (timeout < 0) {
+			while (1) {
+				ret = wait_for_completion_timeout(
+						&mdbg_proc->at_cmd.completed,
+						msecs_to_jiffies(1000));
+				if (ret != -ERESTARTSYS)
+					break;
+			}
+		}
+
+		if (copy_to_user((void __user *)buf,
+					mdbg_proc->at_cmd.buf,
+					min(count, (size_t)MDBG_AT_CMD_SIZE)))
+			WCN_ERR("Read at cmd ack info error\n");
+
+		len = mdbg_proc->at_cmd.rcv_len;
+		mdbg_proc->at_cmd.rcv_len = 0;
+		memset(mdbg_proc->at_cmd.buf, 0, MDBG_AT_CMD_SIZE);
+	}
+
+	return len;
+}
+/**************************************************
+ * marlin2 crash
+ *   |-user:       rebootmarlin
+ *   `-userdebug : dumpmem for btwifi
+ *
+ * GNSS2 crash
+ *   |-user:       rebootwcn
+ *   `-userdebug : no action(libgps and gnss dbg will do)
+ *
+ * marlin3 crash
+ *   |-user:       rebootmarlin
+ *   `-userdebug : dumpmem for btwifi
+ *
+ * GNSS3 crash
+ *   |-user:       rebootwcn
+ *   `-userdebug : dumpmem for gnss
+ *
+ *  rebootmarlin: reset gpio enable
+ *  rebootwcn :   chip_en gpio and reset gpio enable
+ *****************************************************/
+static ssize_t mdbg_proc_write(struct file *filp,
+		const char __user *buf, size_t count, loff_t *ppos)
+{
+	char x;
+#ifdef MDBG_PROC_CMD_DEBUG
+	char *tempbuf = NULL;
+	int i;
+#endif
+
+	if (count < 1)
+		return -EINVAL;
+	if (copy_from_user(&x, buf, 1))
+		return -EFAULT;
+#ifdef MDBG_PROC_CMD_DEBUG
+/* for test boot */
+
+	if (x == '0')
+		dump_arm_reg();
+
+	if (x == 'B') {
+		WCN_INFO("wsh proc write =%c\n", x);
+		tempbuf = kzalloc(10, GFP_KERNEL);
+		memset(tempbuf, 0, 10);
+		ret = sprdwcn_bus_direct_read(CP_START_ADDR, tempbuf, 10);
+		if (ret < 0)
+			WCN_ERR("wsh debug CP_START_ADDR error:%d\n", ret);
+		WCN_INFO("\nwsh debug CP_START_ADDR(10) :\n");
+		for (i = 0; i < 10; i++)
+			WCN_INFO("0x%x\n", tempbuf[i]);
+
+		memset(tempbuf, 0, 10);
+		ret = sprdwcn_bus_reg_read(CP_RESET_REG, tempbuf, 4);
+		if (ret < 0)
+			WCN_ERR("wsh debug CP_RESET_REG error:%d\n", ret);
+		WCN_INFO("\nwsh debug CP_RESET_REG(4) :\n");
+		for (i = 0; i < 4; i++)
+			WCN_INFO(":0x%x\n", tempbuf[i]);
+
+		memset(tempbuf, 0, 10);
+		ret = sprdwcn_bus_direct_read(GNSS_CP_START_ADDR, tempbuf, 10);
+		if (ret < 0)
+			WCN_ERR("wsh debug GNSS_CP_START_ADDR error:%d\n", ret);
+		WCN_INFO("\nwsh debug GNSS_CP_START_ADDR(10) :\n");
+		for (i = 0; i < 10; i++)
+			WCN_INFO(":0x%x\n", tempbuf[i]);
+
+		memset(tempbuf, 0, 10);
+		ret = sprdwcn_bus_reg_read(GNSS_CP_RESET_REG, tempbuf, 4);
+		if (ret < 0)
+			WCN_ERR("wsh debug GNSS_CP_RESET_REG error:%d\n", ret);
+		WCN_INFO("\nwsh debug GNSS_CP_RESET_REG(4) :\n");
+		for (i = 0; i < 4; i++)
+			WCN_INFO(":0x%x\n", tempbuf[i]);
+
+		kfree(tempbuf);
+	}
+
+#ifdef MDBG_PROC_CMD_DEBUG
+/* for test cdev */
+	if (x == '1') {
+		WCN_INFO("wsh proc write =%c\n", x);
+		WCN_INFO("start char release test\n");
+		log_cdev_exit();
+	}
+	if (x == '2') {
+		WCN_INFO("wsh proc write =%c\n", x);
+		WCN_INFO("start char register test\n");
+		log_cdev_init();
+	}
+#endif
+/* for test power on/off frequently */
+#ifdef MDBG_PROC_CMD_DEBUG
+	if (x == '0')
+		start_marlin(MARLIN_BLUETOOTH);
+	if (x == '1')
+		start_marlin(MARLIN_FM);
+	if (x == '2')
+		start_marlin(MARLIN_WIFI);
+	if (x == '3')
+		start_marlin(MARLIN_MDBG);
+	if (x == '4')
+		start_marlin(MARLIN_GNSS);
+
+	if (x == '5')
+		stop_marlin(MARLIN_BLUETOOTH);
+	if (x == '6')
+		stop_marlin(MARLIN_FM);
+	if (x == '7')
+		stop_marlin(MARLIN_WIFI);
+	if (x == '8')
+		stop_marlin(MARLIN_MDBG);
+	if (x == '9')
+		stop_marlin(MARLIN_GNSS);
+	if (x == 'x')
+		open_power_ctl();
+#endif
+	if (x == 'Z')
+		slp_mgr_drv_sleep(DBG_TOOL, FALSE);
+	if (x == 'Y')
+		slp_mgr_wakeup(DBG_TOOL);
+	if (x == 'W')
+		slp_mgr_drv_sleep(DBG_TOOL, TRUE);
+	if (x == 'U')
+		sprdwcn_bus_aon_writeb(0X1B0, 0X10);
+	if (x == 'N')
+		start_marlin(MARLIN_WIFI);
+	if (x == 'R')
+		stop_marlin(MARLIN_WIFI);
+
+#endif
+	if (count > MDBG_WRITE_SIZE) {
+		WCN_ERR("mdbg_proc_write count > MDBG_WRITE_SIZE\n");
+		return -ENOMEM;
+	}
+	memset(mdbg_proc->write_buf, 0, MDBG_WRITE_SIZE);
+
+	if (copy_from_user(mdbg_proc->write_buf, buf, count))
+		return -EFAULT;
+
+	WCN_INFO("mdbg_proc->write_buf:%s\n", mdbg_proc->write_buf);
+
+	if (strncmp(mdbg_proc->write_buf, "startwcn", 8) == 0) {
+		if (start_marlin(MARLIN_MDBG)) {
+			WCN_ERR("%s power on failed\n", __func__);
+			return -EIO;
+		}
+		return count;
+	}
+
+	if (strncmp(mdbg_proc->write_buf, "stopwcn", 7) == 0) {
+		if (stop_marlin(MARLIN_MDBG)) {
+			WCN_ERR("%s power off failed\n", __func__);
+			return -EIO;
+		}
+		return count;
+	}
+
+	if (strncmp(mdbg_proc->write_buf, "disabledumpmem",
+		strlen("disabledumpmem")) == 0) {
+		g_dumpmem_switch = 0;
+		WCN_INFO("hold mdbg dumpmem function:switch(%d)\n",
+				g_dumpmem_switch);
+		return count;
+	}
+	if (strncmp(mdbg_proc->write_buf, "enabledumpmem",
+		strlen("enabledumpmem")) == 0) {
+		g_dumpmem_switch = 1;
+		WCN_INFO("release mdbg dumpmem function:switch(%d)\n",
+				g_dumpmem_switch);
+		return count;
+	}
+	if (strncmp(mdbg_proc->write_buf, "debugloopcheckon",
+		strlen("debugloopcheckon")) == 0) {
+		g_loopcheck_switch = 1;
+		WCN_INFO("loopcheck debug:switch(%d)\n",
+				g_loopcheck_switch);
+		return count;
+	}
+	if (strncmp(mdbg_proc->write_buf, "debugloopcheckoff",
+		strlen("debugloopcheckoff")) == 0) {
+		g_loopcheck_switch = 0;
+		WCN_INFO("loopcheck debug:switch(%d)\n",
+				g_loopcheck_switch);
+		return count;
+	}
+
+#ifdef CONFIG_SC2342_INTEG
+	if (strncmp(mdbg_proc->write_buf, "holdcp2cpu",
+		strlen("holdcp2cpu")) == 0) {
+		mdbg_hold_cpu();
+		WCN_INFO("hold cp cpu\n");
+		return count;
+	}
+	if (strncmp(mdbg_proc->write_buf, "rebootwcn", 9) == 0 ||
+		strncmp(mdbg_proc->write_buf, "rebootmarlin", 12) == 0) {
+		WCN_INFO("marlin gnss need reset\n");
+		WCN_INFO("fail_count is value %d\n", mdbg_proc->fail_count);
+		mdbg_proc->fail_count = 0;
+		sprdwcn_bus_set_carddump_status(false);
+		wcn_device_poweroff();
+		WCN_INFO("marlin gnss  reset finish!\n");
+		return count;
+	}
+#else
+
+	if (strncmp(mdbg_proc->write_buf, "poweroff_wcn", 12) == 0) {
+		marlin_power_off(MARLIN_ALL);
+		return count;
+	}
+
+	if (strncmp(mdbg_proc->write_buf, "rebootmarlin", 12) == 0) {
+		flag_reset = 1;
+		WCN_INFO("marlin need reset\n");
+		WCN_INFO("fail_count is value %d\n", mdbg_proc->fail_count);
+		WCN_INFO("fail_reset is value %d\n", flag_reset);
+		mdbg_proc->fail_count = 0;
+		sprdwcn_bus_set_carddump_status(false);
+		if (marlin_reset_func != NULL)
+			marlin_reset_func(marlin_callback_para);
+		return count;
+	}
+	if (strncmp(mdbg_proc->write_buf, "rebootwcn", 9) == 0) {
+		flag_reset = 1;
+		WCN_INFO("marlin gnss need reset\n");
+		WCN_INFO("fail_count is value %d\n", mdbg_proc->fail_count);
+		mdbg_proc->fail_count = 0;
+		sprdwcn_bus_set_carddump_status(false);
+		marlin_chip_en(false, true);
+		if (marlin_reset_func != NULL)
+			marlin_reset_func(marlin_callback_para);
+		return count;
+	}
+	if (strncmp(mdbg_proc->write_buf, "at+getchipversion", 17) == 0) {
+		struct device_node *np_marlin2 = NULL;
+
+		WCN_INFO("marlin get chip version\n");
+		np_marlin2 = of_find_node_by_name(NULL, "sprd-marlin2");
+		if (np_marlin2) {
+			if (of_get_property(np_marlin2,
+				"common_chip_en", NULL)) {
+				WCN_INFO("marlin common_chip_en\n");
+				memcpy(mdbg_proc->at_cmd.buf,
+					"2342B", strlen("2342B"));
+				mdbg_proc->at_cmd.rcv_len = strlen("2342B");
+			}
+		}
+		return count;
+	}
+#endif
+
+	/*
+	 * One AP Code used for many different CP2.
+	 * But some CP2 already producted, it can't
+	 * change code any more, so use the macro
+	 * to disable SharkLE-Marlin2/SharkL3-Marlin2
+	 * Pike2-Marlin2.
+	 */
+#ifndef CONFIG_SC2342_INTEG
+	/* loopcheck add kernel time ms/1000 */
+	if (strncmp(mdbg_proc->write_buf, "at+loopcheck", 12) == 0) {
+		/* struct timespec now; */
+		unsigned long int ns = local_clock();
+		unsigned long int time = marlin_bootup_time_get();
+		unsigned int ap_t = MARLIN_64B_NS_TO_32B_MS(ns);
+		unsigned int marlin_boot_t = MARLIN_64B_NS_TO_32B_MS(time);
+
+		sprintf(mdbg_proc->write_buf, "at+loopcheck=%u,%u\r",
+			ap_t, marlin_boot_t);
+		/* Be care the count value changed here before send to CP2 */
+		count = strlen(mdbg_proc->write_buf);
+		WCN_INFO("%s, count = %d", mdbg_proc->write_buf, (int)count);
+	}
+#endif
+
+	if (marlin_get_power_state())
+		mdbg_send_atcmd(mdbg_proc->write_buf, count, WCN_ATCMD_WCND);
+	return count;
+}
+
+static unsigned int mdbg_proc_poll(struct file *filp, poll_table *wait)
+{
+	struct mdbg_proc_entry *entry =
+		(struct mdbg_proc_entry *)filp->private_data;
+	char *type = entry->name;
+	unsigned int mask = 0;
+
+	if (strcmp(type, "assert") == 0) {
+		poll_wait(filp, &mdbg_proc->assert.rxwait, wait);
+		if (mdbg_proc->assert.rcv_len > 0)
+			mask |= POLLIN | POLLRDNORM;
+	}
+
+	if (strcmp(type, "loopcheck") == 0) {
+		poll_wait(filp, &mdbg_proc->loopcheck.rxwait, wait);
+		MDBG_LOG("loopcheck:power_state_changed:%d\n",
+					wcn_get_module_status_changed());
+		if (wcn_get_module_status_changed()) {
+			wcn_set_module_status_changed(false);
+			mask |= POLLIN | POLLRDNORM;
+		}
+	}
+
+	return mask;
+}
+
+static const struct proc_ops mdbg_proc_fops = {
+	.proc_open	= mdbg_proc_open,
+	.proc_release	= mdbg_proc_release,
+	.proc_read	= mdbg_proc_read,
+	.proc_write	= mdbg_proc_write,
+	.proc_poll	= mdbg_proc_poll,
+};
+
+int mdbg_memory_alloc(void)
+{
+	mdbg_proc->assert.buf =  kzalloc(MDBG_ASSERT_SIZE, GFP_KERNEL);
+	if (!mdbg_proc->assert.buf)
+		return -ENOMEM;
+
+	mdbg_proc->loopcheck.buf =  kzalloc(MDBG_LOOPCHECK_SIZE, GFP_KERNEL);
+	if (!mdbg_proc->loopcheck.buf) {
+		kfree(mdbg_proc->assert.buf);
+		return -ENOMEM;
+	}
+	mdbg_proc->at_cmd.buf =  kzalloc(MDBG_AT_CMD_SIZE, GFP_KERNEL);
+	if (!mdbg_proc->at_cmd.buf) {
+		kfree(mdbg_proc->assert.buf);
+		kfree(mdbg_proc->loopcheck.buf);
+		return -ENOMEM;
+	}
+
+	mdbg_proc->snap_shoot.buf =  kzalloc(MDBG_SNAP_SHOOT_SIZE, GFP_KERNEL);
+	if (!mdbg_proc->snap_shoot.buf) {
+		kfree(mdbg_proc->assert.buf);
+		kfree(mdbg_proc->loopcheck.buf);
+		kfree(mdbg_proc->at_cmd.buf);
+		return -ENOMEM;
+	}
+
+	return 0;
+}
+
+/*
+ * TX: pop_link(tx_cb), tx_complete(all_node_finish_tx_cb)
+ * Rx: pop_link(rx_cb), push_link(prepare free buf)
+ */
+struct mchn_ops_t mdbg_proc_ops[MDBG_ASSERT_RX_OPS + 1] = {
+	{
+		.channel = WCN_AT_TX,
+		.inout = WCNBUS_TX,
+		.pool_size = 5,
+		.pop_link = mdbg_tx_cb,
+		.power_notify = mdbg_tx_power_notify,
+	},
+	{
+		.channel = WCN_LOOPCHECK_RX,
+		.inout = WCNBUS_RX,
+		.pool_size = 1,
+		.pop_link = mdbg_loopcheck_read,
+	},
+	{
+		.channel = WCN_AT_RX,
+		.inout = WCNBUS_RX,
+		.pool_size = 1,
+		.pop_link = mdbg_at_cmd_read,
+	},
+	{
+		.channel = WCN_ASSERT_RX,
+		.inout = WCNBUS_RX,
+		.pool_size = 1,
+		.pop_link = mdbg_assert_read,
+	},
+};
+
+static void mdbg_fs_channel_destroy(void)
+{
+	int i;
+
+	for (i = 0; i <= MDBG_ASSERT_RX_OPS; i++)
+		sprdwcn_bus_chn_deinit(&mdbg_proc_ops[i]);
+}
+
+static void mdbg_fs_channel_init(void)
+{
+	int i;
+
+	for (i = 0; i <= MDBG_ASSERT_RX_OPS; i++)
+		sprdwcn_bus_chn_init(&mdbg_proc_ops[i]);
+}
+
+static  void mdbg_memory_free(void)
+{
+	kfree(mdbg_proc->snap_shoot.buf);
+	mdbg_proc->snap_shoot.buf = NULL;
+
+	kfree(mdbg_proc->assert.buf);
+	mdbg_proc->assert.buf = NULL;
+
+	kfree(mdbg_proc->loopcheck.buf);
+	mdbg_proc->loopcheck.buf = NULL;
+
+	kfree(mdbg_proc->at_cmd.buf);
+	mdbg_proc->at_cmd.buf = NULL;
+}
+
+int proc_fs_init(void)
+{
+	mdbg_proc = kzalloc(sizeof(struct mdbg_proc_t), GFP_KERNEL);
+	if (!mdbg_proc)
+		return -ENOMEM;
+
+	mdbg_proc->dir_name = "mdbg";
+	mdbg_proc->procdir = proc_mkdir(mdbg_proc->dir_name, NULL);
+
+	mdbg_proc->assert.name = "assert";
+	mdbg_proc->assert.entry = proc_create_data(mdbg_proc->assert.name,
+						0600,
+						mdbg_proc->procdir,
+						&mdbg_proc_fops,
+						&(mdbg_proc->assert));
+
+	mdbg_proc->loopcheck.name = "loopcheck";
+	mdbg_proc->loopcheck.entry = proc_create_data(mdbg_proc->loopcheck.name,
+						0600,
+						mdbg_proc->procdir,
+						&mdbg_proc_fops,
+						&(mdbg_proc->loopcheck));
+
+	mdbg_proc->at_cmd.name = "at_cmd";
+	mdbg_proc->at_cmd.entry = proc_create_data(mdbg_proc->at_cmd.name,
+						0600,
+						mdbg_proc->procdir,
+						&mdbg_proc_fops,
+						&(mdbg_proc->at_cmd));
+
+	mdbg_proc->snap_shoot.name = "snap_shoot";
+	mdbg_proc->snap_shoot.entry = proc_create_data(
+						mdbg_proc->snap_shoot.name,
+						0600,
+						mdbg_proc->procdir,
+						&mdbg_snap_shoot_seq_fops,
+						&(mdbg_proc->snap_shoot));
+
+	mdbg_fs_channel_init();
+
+	init_completion(&mdbg_proc->assert.completed);
+	init_completion(&mdbg_proc->loopcheck.completed);
+	init_completion(&mdbg_proc->at_cmd.completed);
+	init_waitqueue_head(&mdbg_proc->assert.rxwait);
+	init_waitqueue_head(&mdbg_proc->loopcheck.rxwait);
+	mutex_init(&mdbg_proc->mutex);
+
+	if (mdbg_memory_alloc() < 0)
+		return -ENOMEM;
+
+	return 0;
+}
+
+void proc_fs_exit(void)
+{
+	mdbg_memory_free();
+	mutex_destroy(&mdbg_proc->mutex);
+	mdbg_fs_channel_destroy();
+	remove_proc_entry(mdbg_proc->snap_shoot.name, mdbg_proc->procdir);
+	remove_proc_entry(mdbg_proc->assert.name, mdbg_proc->procdir);
+	remove_proc_entry(mdbg_proc->loopcheck.name, mdbg_proc->procdir);
+	remove_proc_entry(mdbg_proc->at_cmd.name, mdbg_proc->procdir);
+	remove_proc_entry(mdbg_proc->dir_name, NULL);
+
+	kfree(mdbg_proc);
+	mdbg_proc = NULL;
+}
+
+int get_loopcheck_status(void)
+{
+	return mdbg_proc->fail_count;
+}
+
+void wakeup_loopcheck_int(void)
+{
+	wake_up_interruptible(&mdbg_proc->loopcheck.rxwait);
+}
+
+void loopcheck_first_boot_clear(void)
+{
+	mdbg_proc->first_boot = false;
+}
+
+void loopcheck_first_boot_set(void)
+{
+	mdbg_proc->first_boot = true;
+}
diff --git a/drivers/net/wireless/uwe5622/unisocwcn/platform/wcn_procfs.h b/drivers/net/wireless/uwe5622/unisocwcn/platform/wcn_procfs.h
new file mode 100644
index 000000000000..0e42a6772b26
--- /dev/null
+++ b/drivers/net/wireless/uwe5622/unisocwcn/platform/wcn_procfs.h
@@ -0,0 +1,19 @@
+#ifndef _WCN_PROCFS
+#define _WCN_PROCFS
+
+#define MDBG_SNAP_SHOOT_SIZE		(32*1024)
+#define MDBG_WRITE_SIZE			(64)
+#define MDBG_ASSERT_SIZE		(1024)
+#define MDBG_LOOPCHECK_SIZE		(128)
+#define MDBG_AT_CMD_SIZE		(128)
+
+unsigned char *mdbg_get_at_cmd_buf(void);
+int proc_fs_init(void);
+int mdbg_memory_alloc(void);
+void proc_fs_exit(void);
+int get_loopcheck_status(void);
+void wakeup_loopcheck_int(void);
+void loopcheck_first_boot_clear(void);
+void loopcheck_first_boot_set(void);
+int prepare_free_buf(int chn, int size, int num);
+#endif
diff --git a/drivers/net/wireless/uwe5622/unisocwcn/platform/wcn_txrx.c b/drivers/net/wireless/uwe5622/unisocwcn/platform/wcn_txrx.c
new file mode 100644
index 000000000000..7a8350cecdba
--- /dev/null
+++ b/drivers/net/wireless/uwe5622/unisocwcn/platform/wcn_txrx.c
@@ -0,0 +1,163 @@
+/*
+ * Copyright (C) 2015 Spreadtrum Communications Inc.
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ */
+#include <wcn_bus.h>
+
+#include "loopcheck.h"
+#include "wcn_glb.h"
+#include "wcn_procfs.h"
+
+int mdbg_log_read(int channel, struct mbuf_t *head,
+		  struct mbuf_t *tail, int num);
+
+static struct ring_device *ring_dev;
+static unsigned long long rx_count;
+static unsigned long long rx_count_last;
+
+bool mdbg_rx_count_change(void)
+{
+	rx_count = sprdwcn_bus_get_rx_total_cnt();
+
+	WCN_INFO("rx_count:0x%llx rx_count_last:0x%llx\n",
+		rx_count, rx_count_last);
+
+	if ((rx_count == 0) && (rx_count_last == 0)) {
+		return true;
+	} else if (rx_count != rx_count_last) {
+		rx_count_last = rx_count;
+		return true;
+	} else {
+		return false;
+	}
+}
+
+static long int mdbg_comm_write(char *buf,
+				long int len, unsigned int subtype)
+{
+	unsigned char *send_buf = NULL;
+	char *str = NULL;
+	struct mbuf_t *head, *tail;
+	int num = 1;
+
+	if (unlikely(marlin_get_module_status() != true)) {
+		WCN_ERR("WCN module have not open\n");
+		return -EIO;
+	}
+	send_buf = kzalloc(len + PUB_HEAD_RSV + 1, GFP_KERNEL);
+	if (!send_buf)
+		return -ENOMEM;
+	memcpy(send_buf + PUB_HEAD_RSV, buf, len);
+
+	str = strstr(send_buf + PUB_HEAD_RSV, SMP_HEAD_STR);
+	if (!str)
+		str = strstr(send_buf + PUB_HEAD_RSV + ARMLOG_HEAD,
+			     SMP_HEAD_STR);
+
+	if (str) {
+		int ret;
+
+		/* for arm log to pc */
+		WCN_INFO("smp len:%ld,str:%s\n", len, str);
+		str[sizeof(SMP_HEAD_STR)] = 0;
+		ret = kstrtol(&str[sizeof(SMP_HEAD_STR) - 1], 10,
+							&ring_dev->flag_smp);
+		WCN_INFO("smp ret:%d, flag_smp:%ld\n", ret,
+			 ring_dev->flag_smp);
+		kfree(send_buf);
+	} else {
+		if (!sprdwcn_bus_list_alloc(
+				mdbg_proc_ops[MDBG_AT_TX_OPS].channel,
+				&head, &tail, &num)) {
+			head->buf = send_buf;
+			head->len = len;
+			head->next = NULL;
+			sprdwcn_bus_push_list(
+				mdbg_proc_ops[MDBG_AT_TX_OPS].channel,
+				head, tail, num);
+		}
+	}
+
+	return len;
+}
+
+int mdbg_log_read(int channel, struct mbuf_t *head,
+		  struct mbuf_t *tail, int num)
+{
+	struct ring_rx_data *rx;
+
+	if (ring_dev) {
+		mutex_lock(&ring_dev->mdbg_read_mutex);
+		rx = kmalloc(sizeof(*rx), GFP_KERNEL);
+		if (!rx) {
+			WCN_ERR("mdbg ring low memory\n");
+			mutex_unlock(&ring_dev->mdbg_read_mutex);
+			sprdwcn_bus_push_list(channel, head, tail, num);
+			return 0;
+		}
+		mutex_unlock(&ring_dev->mdbg_read_mutex);
+		spin_lock_bh(&ring_dev->rw_lock);
+		rx->channel = channel;
+		rx->head = head;
+		rx->tail = tail;
+		rx->num = num;
+		list_add_tail(&rx->entry, &ring_dev->rx_head);
+		spin_unlock_bh(&ring_dev->rw_lock);
+		schedule_work(&ring_dev->rx_task);
+	}
+
+	return 0;
+}
+
+long int mdbg_send(char *buf, long int len, unsigned int subtype)
+{
+	long int sent_size = 0;
+
+	WCN_DEBUG("BYTE MODE");
+	__pm_stay_awake(ring_dev->rw_wake_lock);
+	sent_size = mdbg_comm_write(buf, len, subtype);
+	__pm_relax(ring_dev->rw_wake_lock);
+
+	return sent_size;
+}
+EXPORT_SYMBOL_GPL(mdbg_send);
+
+int mdbg_tx_cb(int channel, struct mbuf_t *head,
+	       struct mbuf_t *tail, int num)
+{
+	struct mbuf_t *mbuf_node;
+	int i;
+
+	mbuf_node = head;
+	for (i = 0; i < num; i++, mbuf_node = mbuf_node->next) {
+		kfree(mbuf_node->buf);
+		mbuf_node->buf = NULL;
+	}
+
+	sprdwcn_bus_list_free(channel, head, tail, num);
+
+	return 0;
+}
+
+int mdbg_tx_power_notify(int chn, int flag)
+{
+	if (flag) {
+		WCN_DEBUG("%s resume\n", __func__);
+#ifdef CONFIG_WCN_LOOPCHECK
+		start_loopcheck();
+#endif
+	} else {
+		WCN_DEBUG("%s suspend\n", __func__);
+#ifdef CONFIG_WCN_LOOPCHECK
+		stop_loopcheck();
+#endif
+	}
+	return 0;
+}
diff --git a/drivers/net/wireless/uwe5622/unisocwcn/platform/wcn_txrx.h b/drivers/net/wireless/uwe5622/unisocwcn/platform/wcn_txrx.h
new file mode 100644
index 000000000000..98116525ad6c
--- /dev/null
+++ b/drivers/net/wireless/uwe5622/unisocwcn/platform/wcn_txrx.h
@@ -0,0 +1,134 @@
+/*
+ * Copyright (C) 2015 Spreadtrum Communications Inc.
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ */
+
+#ifndef __WCN_TXRX_H__
+#define __WCN_TXRX_H__
+#include <linux/interrupt.h>
+#include <linux/mutex.h>
+#include <linux/sched.h>
+#include <linux/types.h>
+#include <linux/version.h>
+#include <linux/wait.h>
+
+#include "mdbg_type.h"
+#include <wcn_bus.h>
+
+#define SMP_HEADERFLAG 0X7E7E7E7E
+#define SMP_RESERVEDFLAG 0X5A5A
+#define SMP_DSP_CHANNEL_NUM 0X88
+#define SMP_DSP_TYPE 0X9D
+#define SMP_DSP_DUMP_TYPE 0X32
+
+#define SYSNC_CODE_LEN 0X4
+#define CHKSUM_LEN 0X2
+#define ARMLOG_HEAD 9
+
+#define SMP_HEAD_STR "at+smphead="
+
+struct ring_rx_data {
+	unsigned char		*addr;
+	unsigned int		len;
+	unsigned int		fifo_id;
+	struct list_head	entry;
+	int channel;
+	struct mbuf_t *head;
+	struct mbuf_t *tail;
+	int num;
+};
+
+struct ring_device {
+	struct mdbg_ring_t	*ring;
+	struct wakeup_source	*rw_wake_lock;
+	spinlock_t		rw_lock;
+	struct mutex mdbg_read_mutex;
+	struct list_head	rx_head;
+	struct work_struct	rx_task;
+	long int flag_smp;
+};
+
+struct sme_head_tag {
+	unsigned int seq_num;
+	unsigned short len;
+	unsigned char type;
+	unsigned char subtype;
+};
+
+struct smp_head {
+	unsigned int sync_code;
+	unsigned short length;
+	unsigned char channel_num;
+	unsigned char packet_type;
+	unsigned short reserved;
+	unsigned short check_sum;
+};
+
+enum smp_diag_subtype_t {
+	NORMAL_INFO = 0X0,
+	DUMP_MEM_DATA,
+	DUMP_MEM_END,
+};
+
+#define WCNBUS_TX 1
+#define WCNBUS_RX 0
+#ifdef CONFIG_WCN_SIPC
+enum wcnbus_channel_t {
+	WCN_AT_TX = 0,
+	WCN_LOOPCHECK_RX = 2,
+	WCN_AT_RX = 1,
+	WCN_ASSERT_RX = 3,
+	WCN_RING_RX = 4,
+	WCN_RSV_RX,
+};
+#else
+enum wcnbus_channel_t {
+	WCN_AT_TX = 0,
+	WCN_LOOPCHECK_RX = 12,
+	WCN_AT_RX,
+	WCN_ASSERT_RX,
+	WCN_RING_RX,
+	/* TODO: The port num is temp,need to consult with cp */
+	WCN_ADSP_RING_RX = 19,
+	WCN_RSV_RX,
+};
+#endif
+
+enum mdbg_channel_ops_t {
+	MDBG_AT_TX_OPS = 0,
+	MDBG_AT_RX_OPS,
+	MDBG_LOOPCHECK_RX_OPS,
+	MDBG_ASSERT_RX_OPS,
+	MDBG_RING_RX_OPS,
+	MDBG_ADSP_RING_RX_OPS,
+	MDBG_RSV_OPS,
+};
+
+enum {
+	MDBG_SUBTYPE_RING = 0,
+	MDBG_SUBTYPE_LOOPCHECK,
+	MDBG_SUBTYPE_AT,
+	MDBG_SUBTYPE_ASSERT,
+};
+
+extern struct mchn_ops_t mdbg_proc_ops[MDBG_ASSERT_RX_OPS + 1];
+
+int mdbg_ring_init(void);
+void mdbg_ring_remove(void);
+long int mdbg_send(char *buf, long int len, unsigned int subtype);
+long int mdbg_receive(void *buf, long int len);
+int mdbg_tx_cb(int channel, struct mbuf_t *head,
+	       struct mbuf_t *tail, int num);
+int mdbg_tx_power_notify(int chn, int flag);
+long mdbg_content_len(void);
+int mdbg_read_release(unsigned int fifo_id);
+bool mdbg_rx_count_change(void);
+
+#endif
diff --git a/drivers/net/wireless/uwe5622/unisocwcn/sdio/sdio_v3.c b/drivers/net/wireless/uwe5622/unisocwcn/sdio/sdio_v3.c
new file mode 100644
index 000000000000..96bbcccc6088
--- /dev/null
+++ b/drivers/net/wireless/uwe5622/unisocwcn/sdio/sdio_v3.c
@@ -0,0 +1,166 @@
+#include <wcn_bus.h>
+
+#include "bus_common.h"
+#include "sdiohal.h"
+
+static int sdio_get_hif_type(void)
+{
+	return HW_TYPE_SDIO;
+}
+
+static int sdio_preinit(void)
+{
+	sdiohal_init();
+	return 0;
+}
+
+static void sdio_preexit(void)
+{
+	sdiohal_exit();
+}
+
+static int sdio_buf_list_alloc(int chn, struct mbuf_t **head,
+			       struct mbuf_t **tail, int *num)
+{
+	return buf_list_alloc(chn, head, tail, num);
+}
+
+static int sdio_buf_list_free(int chn, struct mbuf_t *head,
+			      struct mbuf_t *tail, int num)
+{
+	return buf_list_free(chn, head, tail, num);
+}
+
+static int sdio_list_push(int chn, struct mbuf_t *head,
+			  struct mbuf_t *tail, int num)
+{
+	return sdiohal_list_push(chn, head, tail, num);
+}
+
+static int sdio_list_push_direct(int chn, struct mbuf_t *head,
+				 struct mbuf_t *tail, int num)
+{
+	return sdiohal_list_direct_write(chn, head, tail, num);
+}
+
+static int sdio_chn_init(struct mchn_ops_t *ops)
+{
+	return bus_chn_init(ops, HW_TYPE_SDIO);
+}
+
+static int sdio_chn_deinit(struct mchn_ops_t *ops)
+{
+	return bus_chn_deinit(ops);
+}
+
+static int sdio_direct_read(unsigned int addr,
+				void *buf, unsigned int len)
+{
+	return sdiohal_dt_read(addr, buf, len);
+}
+
+static int sdio_direct_write(unsigned int addr,
+				void *buf, unsigned int len)
+{
+	return sdiohal_dt_write(addr, buf, len);
+}
+
+static int sdio_readbyte(unsigned int addr, unsigned char *val)
+{
+	return sdiohal_aon_readb(addr, val);
+}
+
+static int sdio_writebyte(unsigned int addr, unsigned char val)
+{
+	return sdiohal_aon_writeb(addr, val);
+}
+
+static unsigned int sdio_get_carddump_status(void)
+{
+	return sdiohal_get_carddump_status();
+}
+
+static void sdio_set_carddump_status(unsigned int flag)
+{
+	return sdiohal_set_carddump_status(flag);
+}
+
+static unsigned long long sdio_get_rx_total_cnt(void)
+{
+	return sdiohal_get_rx_total_cnt();
+}
+
+static int sdio_runtime_get(void)
+{
+	return sdiohal_runtime_get();
+}
+
+static int sdio_runtime_put(void)
+{
+	return sdiohal_runtime_put();
+}
+
+static void sdio_remove_card(void)
+{
+	return sdiohal_remove_card();
+}
+
+static void sdiohal_cp_allow_sleep(enum slp_subsys subsys)
+{
+#ifdef CONFIG_WCN_SLP
+	slp_mgr_drv_sleep(subsys, true);
+#endif
+}
+
+static void sdiohal_cp_sleep_wakeup(enum slp_subsys subsys)
+{
+#ifdef CONFIG_WCN_SLP
+	slp_mgr_drv_sleep(subsys, false);
+	slp_mgr_wakeup(subsys);
+#endif
+}
+
+static struct sprdwcn_bus_ops sdiohal_bus_ops = {
+	.preinit = sdio_preinit,
+	.deinit = sdio_preexit,
+	.chn_init = sdio_chn_init,
+	.chn_deinit = sdio_chn_deinit,
+	.list_alloc = sdio_buf_list_alloc,
+	.list_free = sdio_buf_list_free,
+	.push_list = sdio_list_push,
+	.push_list_direct = sdio_list_push_direct,
+	.direct_read = sdio_direct_read,
+	.direct_write = sdio_direct_write,
+	.readbyte = sdio_readbyte,
+	.writebyte = sdio_writebyte,
+	.read_l = sdiohal_readl,
+	.write_l = sdiohal_writel,
+
+	.get_carddump_status = sdio_get_carddump_status,
+	.set_carddump_status = sdio_set_carddump_status,
+	.get_rx_total_cnt = sdio_get_rx_total_cnt,
+
+	.runtime_get = sdio_runtime_get,
+	.runtime_put = sdio_runtime_put,
+
+	.remove_card = sdio_remove_card,
+	.get_tx_mode = sdiohal_get_tx_mode,
+	.get_rx_mode = sdiohal_get_rx_mode,
+	.get_irq_type = sdiohal_get_irq_type,
+	.get_blk_size = sdiohal_get_blk_size,
+	.get_hif_type = sdio_get_hif_type,
+	.allow_sleep = sdiohal_cp_allow_sleep,
+	.sleep_wakeup = sdiohal_cp_sleep_wakeup,
+};
+
+void module_bus_init(void)
+{
+	module_ops_register(&sdiohal_bus_ops);
+}
+EXPORT_SYMBOL(module_bus_init);
+
+void module_bus_deinit(void)
+{
+	module_ops_unregister();
+}
+EXPORT_SYMBOL(module_bus_deinit);
diff --git a/drivers/net/wireless/uwe5622/unisocwcn/sdio/sdiohal.h b/drivers/net/wireless/uwe5622/unisocwcn/sdio/sdiohal.h
new file mode 100644
index 000000000000..282a4924aeb9
--- /dev/null
+++ b/drivers/net/wireless/uwe5622/unisocwcn/sdio/sdiohal.h
@@ -0,0 +1,522 @@
+#ifndef __SDIOHAL_H__
+#define __SDIOHAL_H__
+
+#include <linux/delay.h>
+#include <linux/device.h>
+#include <linux/scatterlist.h>
+#include <linux/slab.h>
+#include <linux/version.h>
+#if KERNEL_VERSION(4, 14, 0) <= LINUX_VERSION_CODE
+#include <uapi/linux/sched/types.h>
+#else
+#include <linux/sched.h>
+#endif
+#include <wcn_bus.h>
+#ifdef CONFIG_WCN_SLP
+#include "../sleep/sdio_int.h"
+#include "../sleep/slp_mgr.h"
+#endif
+
+#define PERFORMANCE_COUNT 100
+#define SDIOHAL_PRINTF_LEN (16)
+#define SDIOHAL_NORMAL_LEVEL (0x01)
+#define SDIOHAL_DEBUG_LEVEL (0x02)
+#define SDIOHAL_LIST_LEVEL (0x04)
+#define SDIOHAL_DATA_LEVEL (0x08)
+#define SDIOHAL_PERF_LEVEL (0x10)
+
+#define sdiohal_info(fmt, args...) \
+	pr_info("sdiohal:" fmt, ## args)
+#define sdiohal_err(fmt, args...) \
+	pr_err("sdiohal err:" fmt, ## args)
+
+#ifdef CONFIG_DEBUG_FS
+extern long int sdiohal_log_level;
+
+#define sdiohal_normal(fmt, args...) \
+	do { if (sdiohal_log_level & SDIOHAL_NORMAL_LEVEL) \
+		sdiohal_info(fmt, ## args); \
+	} while (0)
+#define sdiohal_debug(fmt, args...) \
+	do { if (sdiohal_log_level & SDIOHAL_DEBUG_LEVEL) \
+		sdiohal_info(fmt, ## args); \
+	} while (0)
+#define sdiohal_pr_list(loglevel, fmt, args...) \
+	do { if (sdiohal_log_level & loglevel) \
+		sdiohal_info(fmt, ## args); \
+	} while (0)
+#define sdiohal_pr_data(level, prefix_str, prefix_type, \
+			rowsize, groupsize, buf, len, ascii, loglevel) \
+	do { if (sdiohal_log_level & loglevel) \
+		print_hex_dump(level, prefix_str, prefix_type, \
+			       rowsize, groupsize, buf, len, ascii); \
+	} while (0)
+#define sdiohal_pr_perf(fmt, args...) \
+	do { if (sdiohal_log_level & SDIOHAL_PERF_LEVEL) \
+		trace_printk(fmt, ## args); \
+	} while (0)
+#else
+#define sdiohal_normal(fmt, args...)
+#define sdiohal_debug(fmt, args...)
+#define sdiohal_pr_list(loglevel, fmt, args...)
+#define	sdiohal_pr_data(level, prefix_str, prefix_type, \
+			rowsize, groupsize, buf, len, ascii, loglevel)
+#define sdiohal_pr_perf(fmt, args...)
+#endif
+
+#define SDIOHAL_SDMA	0
+#define SDIOHAL_ADMA	1
+
+#define SDIOHAL_RX_EXTERNAL_IRQ	0
+#define SDIOHAL_RX_INBAND_IRQ	1
+#define SDIOHAL_RX_POLLING	2
+
+#ifdef CONFIG_UWE5623
+#define SDIO_RESET_ENABLE 0x40930040
+#endif
+
+/* channel numbers */
+#define SDIO_CHN_TX_NUM 12
+#define SDIO_CHN_RX_NUM 14
+
+#define SDIO_CHANNEL_NUM (SDIO_CHN_TX_NUM + SDIO_CHN_RX_NUM)
+
+/* dump designated channel data when assert happened */
+#define SDIO_DUMP_CHANNEL_DATA		1
+#define SDIO_DUMP_TX_CHANNEL_NUM	8
+#define SDIO_DUMP_RX_CHANNEL_NUM	22
+#define SDIO_DUMP_RX_WIFI_EVENT_MIN	(0x80)
+
+/* list bumber */
+#define SDIO_TX_LIST_NUM SDIO_CHN_TX_NUM
+#define SDIO_RX_LIST_NUM SDIO_CHN_RX_NUM
+#define MAX_CHAIN_NODE_NUM 100
+
+/* task prio */
+#define SDIO_TX_TASK_PRIO 89
+#define SDIO_RX_TASK_PRIO 90
+
+/* mbuf max size */
+#define MAX_MBUF_SIZE (2 << 10)
+
+#ifdef CONFIG_SDIO_BLKSIZE_512
+/* cp blk size */
+#define SDIOHAL_BLK_SIZE 512
+/* each pac data max size,cp align size */
+#define MAX_PAC_SIZE (SDIOHAL_BLK_SIZE * 4)
+#elif defined(CONFIG_WCN_PARSE_DTS)
+/* cp blk size */
+#define SDIOHAL_BLK_SIZE (sprdwcn_bus_get_blk_size())
+/* each pac data max size,cp align size */
+#define MAX_PAC_SIZE ((SDIOHAL_BLK_SIZE == 512) ? \
+	(SDIOHAL_BLK_SIZE * 4) : (SDIOHAL_BLK_SIZE * 2))
+#else
+/* cp blk size */
+#define SDIOHAL_BLK_SIZE 840
+/* each pac data max size,cp align size */
+#define MAX_PAC_SIZE (SDIOHAL_BLK_SIZE * 2)
+#endif
+
+/* pub header size */
+#define SDIO_PUB_HEADER_SIZE (4)
+#define SDIOHAL_DTBS_BUF_SIZE SDIOHAL_BLK_SIZE
+
+/* for rx buf */
+#define SDIOHAL_RX_NODE_NUM (12 << 10)
+
+/* for 64 bit sys */
+#define SDIOHAL_RX_RECVBUF_LEN (MAX_CHAIN_NODE_NUM * MAX_MBUF_SIZE)
+#define SDIOHAL_FRAG_PAGE_MAX_ORDER \
+	get_order(SDIOHAL_RX_RECVBUF_LEN)
+
+/* for 32 bit sys */
+#define SDIOHAL_32_BIT_RX_RECVBUF_LEN (16 << 10)
+#define SDIOHAL_FRAG_PAGE_MAX_ORDER_32_BIT \
+	get_order(SDIOHAL_32_BIT_RX_RECVBUF_LEN)
+
+#define SDIOHAL_FRAG_PAGE_MAX_SIZE \
+	(PAGE_SIZE << SDIOHAL_FRAG_PAGE_MAX_ORDER)
+#define SDIOHAL_PAGECNT_MAX_BIAS SDIOHAL_FRAG_PAGE_MAX_SIZE
+
+/* tx buf size for normal dma mode */
+#define SDIOHAL_TX_SENDBUF_LEN (MAX_CHAIN_NODE_NUM * MAX_MBUF_SIZE)
+
+/* temp for marlin2 */
+#define WIFI_MIN_RX 8
+#define WIFI_MAX_RX 9
+
+/* for adma */
+#define SDIOHAL_READ 0 /* Read request */
+#define SDIOHAL_WRITE 1 /* Write request */
+#define SDIOHAL_DATA_FIX 0 /* Fixed addressing */
+#define SDIOHAL_DATA_INC 1 /* Incremental addressing */
+#define MAX_IO_RW_BLK 511
+
+/* fun num */
+#define FUNC_0  0
+#define FUNC_1  1
+#define SDIOHAL_MAX_FUNCS 2
+
+/* cp sdio reg addr */
+#define SDIOHAL_DT_MODE_ADDR	0x0f
+#define SDIOHAL_PK_MODE_ADDR	0x20
+#define SDIOHAL_CCCR_ABORT		0x06
+#define VAL_ABORT_TRANS			0x01
+#define SDIOHAL_FBR_SYSADDR0	0x15c
+#define SDIOHAL_FBR_SYSADDR1	0x15d
+#define SDIOHAL_FBR_SYSADDR2	0x15e
+#define SDIOHAL_FBR_SYSADDR3	0x15f
+#define SDIOHAL_FBR_APBRW0		0x180
+#define SDIOHAL_FBR_APBRW1		0x181
+#define SDIOHAL_FBR_APBRW2		0x182
+#define SDIOHAL_FBR_APBRW3		0x183
+#define SDIOHAL_FBR_STBBA0		0x1bc
+#define SDIOHAL_FBR_STBBA1		0x1bd
+#define SDIOHAL_FBR_STBBA2		0x1be
+#define SDIOHAL_FBR_STBBA3		0x1bf
+#define SDIOHAL_FBR_DEINT_EN	0x1ca
+#define VAL_DEINT_ENABLE		0x3
+#define SDIOHAL_FBR_PUBINT_RAW4	0x1e8
+
+#define SDIOHAL_ALIGN_4BYTE(a)  (((a)+3)&(~3))
+#ifdef CONFIG_SDIO_BLKSIZE_512
+#define SDIOHAL_ALIGN_BLK(a)  (((a)+511)&(~511))
+#elif defined(CONFIG_WCN_PARSE_DTS)
+#define SDIOHAL_ALIGN_BLK(a) ((SDIOHAL_BLK_SIZE == 512) ? \
+	(((a)+511)&(~511)) : (((a)%SDIOHAL_BLK_SIZE) ? \
+	(((a)/SDIOHAL_BLK_SIZE + 1)*SDIOHAL_BLK_SIZE) : (a)))
+#else
+#define SDIOHAL_ALIGN_BLK(a) (((a)%SDIOHAL_BLK_SIZE) ? \
+	(((a)/SDIOHAL_BLK_SIZE + 1)*SDIOHAL_BLK_SIZE) : (a))
+#endif
+
+#define WCN_128BIT_CTL_BASE 0x1a0
+#define WCN_128BIT_STAT_BASE 0x140
+#define CP_128BIT_SIZE	(0x0f)
+
+#define WCN_CTL_REG_0 (WCN_128BIT_CTL_BASE + 0X00)
+#define WCN_CTL_REG_1 (WCN_128BIT_CTL_BASE + 0X01)
+#define WCN_CTL_REG_2 (WCN_128BIT_CTL_BASE + 0X02)
+#define WCN_CTL_REG_3 (WCN_128BIT_CTL_BASE + 0X03)
+#define WCN_CTL_REG_4 (WCN_128BIT_CTL_BASE + 0X04)
+#define WCN_CTL_REG_5 (WCN_128BIT_CTL_BASE + 0X05)
+#define WCN_CTL_REG_6 (WCN_128BIT_CTL_BASE + 0X06)
+#define WCN_CTL_REG_7 (WCN_128BIT_CTL_BASE + 0X07)
+#define WCN_CTL_REG_8 (WCN_128BIT_CTL_BASE + 0X08)
+#define WCN_CTL_REG_9 (WCN_128BIT_CTL_BASE + 0X09)
+#define WCN_CTL_REG_10 (WCN_128BIT_CTL_BASE + 0X0a)
+#define WCN_CTL_REG_11 (WCN_128BIT_CTL_BASE + 0X0b)
+#define WCN_CTL_REG_12 (WCN_128BIT_CTL_BASE + 0X0c)
+#define WCN_CTL_REG_13 (WCN_128BIT_CTL_BASE + 0X0d)
+#define WCN_CTL_REG_14 (WCN_128BIT_CTL_BASE + 0X0e)
+#define WCN_CTL_REG_15 (WCN_128BIT_CTL_BASE + 0X0f)
+
+#define WCN_STATE_REG_0 (WCN_128BIT_STAT_BASE + 0X00)
+#define WCN_STATE_REG_1 (WCN_128BIT_STAT_BASE + 0X01)
+#define WCN_STATE_REG_2 (WCN_128BIT_STAT_BASE + 0X02)
+#define WCN_STATE_REG_3 (WCN_128BIT_STAT_BASE + 0X03)
+#define WCN_STATE_REG_4 (WCN_128BIT_STAT_BASE + 0X04)
+#define WCN_STATE_REG_5 (WCN_128BIT_STAT_BASE + 0X05)
+#define WCN_STATE_REG_6 (WCN_128BIT_STAT_BASE + 0X06)
+#define WCN_STATE_REG_7 (WCN_128BIT_STAT_BASE + 0X07)
+#define WCN_STATE_REG_8 (WCN_128BIT_STAT_BASE + 0X08)
+#define WCN_STATE_REG_9 (WCN_128BIT_STAT_BASE + 0X09)
+#define WCN_STATE_REG_10 (WCN_128BIT_STAT_BASE + 0X0a)
+#define WCN_STATE_REG_11 (WCN_128BIT_STAT_BASE + 0X0b)
+#define WCN_STATE_REG_12 (WCN_128BIT_STAT_BASE + 0X0c)
+#define WCN_STATE_REG_13 (WCN_128BIT_STAT_BASE + 0X0d)
+#define WCN_STATE_REG_14 (WCN_128BIT_STAT_BASE + 0X0e)
+#define WCN_STATE_REG_15 (WCN_128BIT_STAT_BASE + 0X0f)
+
+#define SDIO_VER_CCCR	(0X0)
+
+#define SDIO_CP_INT_EN (DUMP_SDIO_ADDR + 0x58)
+
+/* for marlin3 */
+#define CP_PMU_STATUS	(WCN_STATE_REG_0)
+#define CP_SWITCH_SGINAL (WCN_CTL_REG_4)
+#define CP_RESET_SLAVE  (WCN_CTL_REG_8)
+#define CP_BUS_HREADY	(WCN_STATE_REG_4)
+#define CP_HREADY_SIZE	(0x04)
+
+/* for malrin3e */
+#define WCN_CTL_EN	BIT(7)
+#define WCN_SYS_MASK	(0xf)
+#define WCN_MODE_MASK	(0x3 << 4)
+#define WCN_DEBUG_CTL_REG (WCN_CTL_REG_2)
+#define WCN_DEBUG_MODE_SYS_REG (WCN_CTL_REG_1)
+#define WCN_SEL_SIG_REG	(WCN_CTL_REG_0)
+#define WCN_SIG_STATE	(WCN_STATE_REG_0)
+
+#define SDIOHAL_REMOVE_CARD_VAL 0x8000
+#define WCN_CARD_EXIST(xmit) \
+	(atomic_read(xmit) < SDIOHAL_REMOVE_CARD_VAL)
+
+struct sdiohal_frag_mg {
+	struct page_frag frag;
+	unsigned int pagecnt_bias;
+};
+
+struct sdiohal_list_t {
+	struct list_head head;
+	struct mbuf_t *mbuf_head;
+	struct mbuf_t *mbuf_tail;
+	unsigned int type;
+	unsigned int subtype;
+	unsigned int node_num;
+};
+
+struct buf_pool_t {
+	int size;
+	int free;
+	int payload;
+	void *head;
+	char *mem;
+	spinlock_t lock;
+};
+
+struct sdiohal_sendbuf_t {
+	unsigned int used_len;
+	unsigned char *buf;
+	unsigned int retry_len;
+	unsigned char *retry_buf;
+};
+
+struct sdiohal_data_bak_t {
+	unsigned int time;
+	unsigned char data_bk[SDIOHAL_PRINTF_LEN];
+};
+
+struct sdiohal_data_t {
+	struct task_struct *tx_thread;
+	struct task_struct *rx_thread;
+	struct completion tx_completed;
+	struct completion rx_completed;
+	struct wakeup_source *tx_ws;
+	struct wakeup_source *rx_ws;
+	atomic_t tx_wake_flag;
+	atomic_t rx_wake_flag;
+#ifdef CONFIG_WCN_SLP
+	atomic_t tx_wake_cp_count[SUBSYS_MAX];
+	atomic_t rx_wake_cp_count[SUBSYS_MAX];
+#endif
+	struct mutex xmit_lock;
+	struct mutex xmit_sdma;
+	spinlock_t tx_spinlock;
+	spinlock_t rx_spinlock;
+	atomic_t flag_resume;
+	atomic_t tx_mbuf_num;
+	atomic_t xmit_cnt;
+	atomic_t xmit_start;
+	bool exit_flag;
+	/* adma enable:1, disable:0 */
+	bool adma_tx_enable;
+	bool adma_rx_enable;
+	bool pwrseq;
+	/* blk_size: 0 840, 1 512 */
+	bool blk_size;
+	/* dt mode read or write fail flag */
+	bool dt_rw_fail;
+	/* EXTERNAL_IRQ 0, INBAND_IRQ 1, POLLING 2. */
+	unsigned char irq_type;
+
+	/* tx data list for send */
+	struct sdiohal_list_t tx_list_head;
+	/* tx data list for pop */
+	struct sdiohal_list_t *list_tx[SDIO_CHN_TX_NUM];
+	/* rx data list for dispatch */
+	struct sdiohal_list_t *list_rx[SDIO_CHN_RX_NUM];
+	/* mbuf list */
+	struct sdiohal_list_t list_rx_buf;
+	/* frag data buf */
+	struct sdiohal_frag_mg frag_ctl;
+	struct mchn_ops_t *ops[SDIO_CHANNEL_NUM];
+	struct mutex callback_lock[SDIO_CHANNEL_NUM];
+	struct buf_pool_t pool[SDIO_CHANNEL_NUM];
+
+	bool flag_init;
+	atomic_t flag_suspending;
+	int gpio_num;
+	unsigned int irq_num;
+	unsigned int irq_trigger_type;
+	atomic_t irq_cnt;
+	unsigned int card_dump_flag;
+	struct sdio_func *sdio_func[SDIOHAL_MAX_FUNCS];
+	struct mmc_host *sdio_dev_host;
+	struct scatterlist sg_list[MAX_CHAIN_NODE_NUM + 1];
+
+	unsigned int success_pac_num;
+	struct sdiohal_sendbuf_t send_buf;
+	unsigned char *eof_buf;
+
+	unsigned int dtbs;
+	unsigned int remain_pac_num;
+	unsigned long long rx_packer_cnt;
+	char *dtbs_buf;
+
+	/* for performance statics */
+	struct timespec64 tm_begin_sch;
+	struct timespec64 tm_end_sch;
+	struct timespec64 tm_begin_irq;
+	struct timespec64 tm_end_irq;
+
+	struct wakeup_source *scan_ws;
+	struct completion scan_done;
+	struct completion remove_done;
+	unsigned int sdio_int_reg;
+#if SDIO_DUMP_CHANNEL_DATA
+	struct sdiohal_data_bak_t chntx_push_old;
+	struct sdiohal_data_bak_t chntx_push_new;
+	struct sdiohal_data_bak_t chntx_denq_old;
+	struct sdiohal_data_bak_t chntx_denq_new;
+	struct sdiohal_data_bak_t chnrx_dispatch_old;
+	struct sdiohal_data_bak_t chnrx_dispatch_new;
+#endif
+	int printlog_txchn;
+	int printlog_rxchn;
+};
+
+struct sdiohal_data_t *sdiohal_get_data(void);
+unsigned char sdiohal_get_tx_mode(void);
+unsigned char sdiohal_get_rx_mode(void);
+unsigned char sdiohal_get_irq_type(void);
+unsigned int sdiohal_get_blk_size(void);
+
+/* for list manger */
+void sdiohal_atomic_add(int count, atomic_t *value);
+void sdiohal_atomic_sub(int count, atomic_t *value);
+
+/* seam for thread */
+void sdiohal_tx_down(void);
+void sdiohal_tx_up(void);
+void sdiohal_rx_down(void);
+void sdiohal_rx_up(void);
+int sdiohal_tx_thread(void *data);
+int sdiohal_rx_thread(void *data);
+
+/* for wakup event */
+void sdiohal_lock_tx_ws(void);
+void sdiohal_unlock_tx_ws(void);
+void sdiohal_lock_rx_ws(void);
+void sdiohal_unlock_rx_ws(void);
+void sdiohal_lock_scan_ws(void);
+void sdiohal_unlock_scan_ws(void);
+
+/* for api mutex */
+void sdiohal_callback_lock(struct mutex *mutex);
+void sdiohal_callback_unlock(struct mutex *mutex);
+
+/* for sleep */
+#ifdef CONFIG_WCN_SLP
+void sdiohal_cp_tx_sleep(enum slp_subsys subsys);
+void sdiohal_cp_tx_wakeup(enum slp_subsys subsys);
+void sdiohal_cp_rx_sleep(enum slp_subsys subsys);
+void sdiohal_cp_rx_wakeup(enum slp_subsys subsys);
+#else
+#define sdiohal_cp_tx_sleep(args...) do {} while (0)
+#define sdiohal_cp_tx_wakeup(args...) do {} while (0)
+#define sdiohal_cp_rx_sleep(args...) do {} while (0)
+#define sdiohal_cp_rx_wakeup(args...) do {} while (0)
+#endif
+
+void sdiohal_resume_check(void);
+void sdiohal_resume_wait(void);
+void sdiohal_op_enter(void);
+void sdiohal_op_leave(void);
+void sdiohal_sdma_enter(void);
+void sdiohal_sdma_leave(void);
+void sdiohal_channel_to_hwtype(int inout, int chn,
+			       unsigned int *type, unsigned int *subtype);
+int sdiohal_hwtype_to_channel(int inout, unsigned int type,
+			      unsigned int subtype);
+
+/* for list manger */
+bool sdiohal_is_tx_list_empty(void);
+int sdiohal_tx_packer(struct sdiohal_sendbuf_t *send_buf,
+		      struct sdiohal_list_t *data_list,
+		      struct mbuf_t *mbuf_node);
+int sdiohal_tx_set_eof(struct sdiohal_sendbuf_t *send_buf,
+		       unsigned char *eof_buf);
+void sdiohal_tx_list_enq(int channel, struct mbuf_t *head,
+			 struct mbuf_t *tail, int num);
+void sdiohal_tx_find_data_list(struct sdiohal_list_t *data_list);
+int sdiohal_tx_list_denq(struct sdiohal_list_t *data_list);
+int sdiohal_rx_list_free(struct mbuf_t *mbuf_head,
+			 struct mbuf_t *mbuf_tail, int num);
+struct sdiohal_list_t *sdiohal_get_rx_mbuf_list(int num);
+struct sdiohal_list_t *sdiohal_get_rx_mbuf_node(int num);
+int sdiohal_rx_list_dispatch(void);
+struct sdiohal_list_t *sdiohal_get_rx_channel_list(int channel);
+void *sdiohal_get_rx_free_buf(unsigned int *alloc_size);
+void sdiohal_tx_init_retrybuf(void);
+int sdiohal_misc_init(void);
+void sdiohal_misc_deinit(void);
+
+/* sdiohal main.c */
+void sdiohal_sdio_tx_status(void);
+unsigned int sdiohal_get_trans_pac_num(void);
+int sdiohal_sdio_pt_write(unsigned char *src, unsigned int datalen);
+int sdiohal_sdio_pt_read(unsigned char *src, unsigned int datalen);
+int sdiohal_adma_pt_write(struct sdiohal_list_t *data_list);
+int sdiohal_adma_pt_read(struct sdiohal_list_t *data_list);
+int sdiohal_tx_data_list_send(struct sdiohal_list_t *data_list,
+			      bool pop_flag);
+void sdiohal_enable_rx_irq(void);
+
+/* for debugfs */
+#ifdef CONFIG_DEBUG_FS
+void sdiohal_debug_init(void);
+void sdiohal_debug_deinit(void);
+#endif
+
+
+void sdiohal_print_list_data(int channel, struct sdiohal_list_t *data_list,
+			     const char *func, int loglevel);
+void sdiohal_print_mbuf_data(int channel, struct mbuf_t *head,
+			     struct mbuf_t *tail, int num, const char *func,
+			     int loglevel);
+
+void sdiohal_list_check(struct sdiohal_list_t *data_list,
+			const char *func, bool dir);
+void sdiohal_mbuf_list_check(int channel, struct mbuf_t *head,
+			     struct mbuf_t *tail, int num,
+			     const char *func, bool dir, int loglevel);
+
+int sdiohal_init(void);
+void sdiohal_exit(void);
+int sdiohal_list_push(int chn, struct mbuf_t *head,
+		      struct mbuf_t *tail, int num);
+int sdiohal_list_direct_write(int channel, struct mbuf_t *head,
+			      struct mbuf_t *tail, int num);
+
+/* driect mode,reg access.etc */
+int sdiohal_dt_read(unsigned int addr, void *buf, unsigned int len);
+int sdiohal_dt_write(unsigned int addr, void *buf, unsigned int len);
+int sdiohal_aon_readb(unsigned int addr, unsigned char *val);
+int sdiohal_aon_writeb(unsigned int addr, unsigned char val);
+int sdiohal_writel(unsigned int system_addr, void *buf);
+int sdiohal_readl(unsigned int system_addr, void *buf);
+void sdiohal_dump_aon_reg(void);
+
+/* for dumpmem */
+unsigned int sdiohal_get_carddump_status(void);
+void sdiohal_set_carddump_status(unsigned int flag);
+
+/* for loopcheck */
+unsigned long long sdiohal_get_rx_total_cnt(void);
+
+/* for power on/off */
+int sdiohal_runtime_get(void);
+int sdiohal_runtime_put(void);
+
+void sdiohal_register_scan_notify(void *func);
+int sdiohal_scan_card(void);
+void sdiohal_remove_card(void);
+
+#ifdef SDIO_RESET_DEBUG
+/* Some custome platform not export sdio_reset_comm symbol. */
+extern int sdio_reset_comm(struct mmc_card *card);
+int sdiohal_disable_apb_reset(void);
+void sdiohal_reset(bool full_reset);
+#endif
+#endif
diff --git a/drivers/net/wireless/uwe5622/unisocwcn/sdio/sdiohal_common.c b/drivers/net/wireless/uwe5622/unisocwcn/sdio/sdiohal_common.c
new file mode 100644
index 000000000000..bab8b98cdcb7
--- /dev/null
+++ b/drivers/net/wireless/uwe5622/unisocwcn/sdio/sdiohal_common.c
@@ -0,0 +1,1465 @@
+#include <linux/version.h>
+#include "bus_common.h"
+#include "sdiohal.h"
+
+void sdiohal_print_list_data(int channel, struct sdiohal_list_t *data_list,
+			     const char *func, int loglevel)
+{
+	struct sdiohal_data_t *p_data = sdiohal_get_data();
+	struct mbuf_t *node;
+	int i;
+	unsigned short print_len;
+	char print_str[64];
+
+	if (!data_list || !data_list->mbuf_head) {
+		sdiohal_err("%s, data_list:%p,data_list->mbuf_head:%p",
+			    __func__, data_list, data_list->mbuf_head);
+		WARN_ON(1);
+		return;
+	}
+
+	sprintf(print_str, "%s list: ", func);
+	node = data_list->mbuf_head;
+	for (i = 0; i < data_list->node_num; i++, node = node->next) {
+		if (!node)
+			break;
+		print_len = node->len + SDIO_PUB_HEADER_SIZE;
+		if ((channel == p_data->printlog_txchn) ||
+		    (channel == p_data->printlog_rxchn)) {
+			print_hex_dump(KERN_WARNING, print_str,
+				       DUMP_PREFIX_NONE, 16, 1, node->buf,
+				       (print_len < SDIOHAL_PRINTF_LEN ?
+				       print_len : SDIOHAL_PRINTF_LEN), true);
+		} else {
+			sdiohal_pr_data(KERN_WARNING, print_str,
+					DUMP_PREFIX_NONE, 16, 1, node->buf,
+					(print_len < SDIOHAL_PRINTF_LEN ?
+					print_len : SDIOHAL_PRINTF_LEN), true,
+					loglevel);
+		}
+	}
+}
+
+void sdiohal_print_mbuf_data(int channel, struct mbuf_t *head,
+			     struct mbuf_t *tail, int num, const char *func,
+			     int loglevel)
+{
+	struct sdiohal_data_t *p_data = sdiohal_get_data();
+	struct mbuf_t *node;
+	int i;
+	unsigned short print_len;
+	char print_str[64];
+
+	if (!head) {
+		WARN_ON(1);
+		return;
+	}
+
+	sprintf(print_str, "%s mbuf: ", func);
+
+	node = head;
+	for (i = 0; i < num; i++, node = node->next) {
+		if (!node)
+			break;
+		print_len = node->len + SDIO_PUB_HEADER_SIZE;
+		if ((channel == p_data->printlog_txchn) ||
+		    (channel == p_data->printlog_rxchn)) {
+			print_hex_dump(KERN_WARNING, print_str,
+				       DUMP_PREFIX_NONE, 16, 1, node->buf,
+				       (print_len < SDIOHAL_PRINTF_LEN ?
+				       print_len : SDIOHAL_PRINTF_LEN), true);
+		} else {
+			sdiohal_pr_data(KERN_WARNING, print_str,
+					DUMP_PREFIX_NONE, 16, 1, node->buf,
+					(print_len < SDIOHAL_PRINTF_LEN ?
+					print_len : SDIOHAL_PRINTF_LEN), true,
+					loglevel);
+		}
+	}
+}
+
+void sdiohal_list_check(struct sdiohal_list_t *data_list,
+			const char *func, bool dir)
+{
+	struct mbuf_t *node;
+	int i;
+
+	if (!data_list) {
+		WARN_ON(1);
+		return;
+	}
+
+	sdiohal_pr_list(SDIOHAL_LIST_LEVEL,
+			"%s dir:%s data_list:%p node_num:%d,\n",
+			func, dir ? "tx" : "rx", data_list,
+			data_list->node_num);
+	node = data_list->mbuf_head;
+	for (i = 0; i < data_list->node_num; i++, node = node->next) {
+		WARN_ON(!node);
+		sdiohal_pr_list(SDIOHAL_LIST_LEVEL, "%s node:%p buf:%p\n",
+				func, node, node->buf);
+	}
+
+	if (node) {
+		sdiohal_err("%s node:%p buf:%p\n", func, node, node->buf);
+		WARN_ON(1);
+	}
+}
+
+void sdiohal_mbuf_list_check(int channel, struct mbuf_t *head,
+			     struct mbuf_t *tail, int num,
+			     const char *func, bool dir, int loglevel)
+{
+	struct mbuf_t *node;
+	int i;
+
+	if (!head) {
+		WARN_ON(1);
+		return;
+	}
+
+	sdiohal_pr_list(loglevel, "%s dir:%s chn:%d head:%p tail:%p num:%d\n",
+			func, dir ? "tx" : "rx", channel, head, tail, num);
+	node = head;
+	for (i = 0; i < num; i++, node = node->next) {
+		WARN_ON(!node);
+		sdiohal_pr_list(SDIOHAL_LIST_LEVEL, "%s node:%p buf:%p\n",
+				func, node, node->buf);
+	}
+
+	if (node) {
+		sdiohal_err("%s node:%p buf:%p\n", func, node, node->buf);
+		WARN_ON(1);
+	}
+}
+
+/* for list manger */
+void sdiohal_atomic_add(int count, atomic_t *value)
+{
+	atomic_add(count, value);
+}
+
+void sdiohal_atomic_sub(int count, atomic_t *value)
+{
+	if (atomic_read(value) == 0)
+		return;
+
+	atomic_sub(count, value);
+}
+
+/* seam for thread */
+void sdiohal_tx_down(void)
+{
+	struct sdiohal_data_t *p_data = sdiohal_get_data();
+
+	/* wait_for_completion may cause hung_task_timeout_secs
+	 * with message of task blocked for more than 120 seconds.
+	 */
+	wait_for_completion_interruptible(&p_data->tx_completed);
+}
+
+void sdiohal_tx_up(void)
+{
+	struct sdiohal_data_t *p_data = sdiohal_get_data();
+
+	complete(&p_data->tx_completed);
+}
+
+void sdiohal_rx_down(void)
+{
+	struct sdiohal_data_t *p_data = sdiohal_get_data();
+
+	/* wait_for_completion may cause hung_task_timeout_secs
+	 * with message of task blocked for more than 120 seconds.
+	 */
+	wait_for_completion_interruptible(&p_data->rx_completed);
+}
+
+void sdiohal_rx_up(void)
+{
+	struct sdiohal_data_t *p_data = sdiohal_get_data();
+
+	complete(&p_data->rx_completed);
+}
+
+void sdiohal_completion_init(void)
+{
+	struct sdiohal_data_t *p_data = sdiohal_get_data();
+
+	init_completion(&p_data->tx_completed);
+	init_completion(&p_data->rx_completed);
+	init_completion(&p_data->scan_done);
+}
+
+void sdiohal_lock_tx_ws(void)
+{
+	struct sdiohal_data_t *p_data = sdiohal_get_data();
+
+	if (atomic_read(&p_data->flag_suspending))
+		return;
+
+	sdiohal_atomic_add(1, &p_data->tx_wake_flag);
+	if (atomic_read(&p_data->tx_wake_flag) > 1)
+		return;
+
+	__pm_stay_awake(p_data->tx_ws);
+}
+
+void sdiohal_unlock_tx_ws(void)
+{
+	struct sdiohal_data_t *p_data = sdiohal_get_data();
+
+	sdiohal_atomic_sub(1, &p_data->tx_wake_flag);
+	if (atomic_read(&p_data->tx_wake_flag))
+		return;
+
+	__pm_relax(p_data->tx_ws);
+}
+
+void sdiohal_lock_rx_ws(void)
+{
+	struct sdiohal_data_t *p_data = sdiohal_get_data();
+
+	if (atomic_read(&p_data->flag_suspending) ||
+		atomic_read(&p_data->rx_wake_flag))
+		return;
+
+	atomic_set(&p_data->rx_wake_flag, 1);
+	__pm_stay_awake(p_data->rx_ws);
+}
+
+void sdiohal_unlock_rx_ws(void)
+{
+	struct sdiohal_data_t *p_data = sdiohal_get_data();
+
+	if (!atomic_read(&p_data->rx_wake_flag))
+		return;
+
+	atomic_set(&p_data->rx_wake_flag, 0);
+	__pm_relax(p_data->rx_ws);
+}
+
+void sdiohal_lock_scan_ws(void)
+{
+	struct sdiohal_data_t *p_data = sdiohal_get_data();
+
+	__pm_stay_awake(p_data->scan_ws);
+}
+
+void sdiohal_unlock_scan_ws(void)
+{
+	struct sdiohal_data_t *p_data = sdiohal_get_data();
+
+	__pm_relax(p_data->scan_ws);
+}
+
+void sdiohal_wakelock_init(void)
+{
+	struct sdiohal_data_t *p_data = sdiohal_get_data();
+
+	p_data->tx_ws = wakeup_source_register(NULL, "sdiohal_tx_wakelock");
+	p_data->rx_ws = wakeup_source_register(NULL, "sdiohal_rx_wakelock");
+	p_data->scan_ws = wakeup_source_register(NULL, "sdiohal_scan_wakelock");
+}
+
+void sdiohal_wakelock_deinit(void)
+{
+	struct sdiohal_data_t *p_data = sdiohal_get_data();
+
+	wakeup_source_unregister(p_data->tx_ws);
+	wakeup_source_unregister(p_data->rx_ws);
+	wakeup_source_unregister(p_data->scan_ws);
+}
+
+/* for callback */
+void sdiohal_callback_lock(struct mutex *callback_mutex)
+{
+	mutex_lock(callback_mutex);
+}
+
+void sdiohal_callback_unlock(struct mutex *callback_mutex)
+{
+	mutex_unlock(callback_mutex);
+}
+
+void sdiohal_callback_lock_init(void)
+{
+	struct sdiohal_data_t *p_data = sdiohal_get_data();
+	struct mutex *chn_callback = p_data->callback_lock;
+	int channel;
+
+	for (channel = 0; channel < SDIO_CHANNEL_NUM; channel++)
+		mutex_init(&chn_callback[channel]);
+}
+
+void sdiohal_callback_lock_deinit(void)
+{
+	struct sdiohal_data_t *p_data = sdiohal_get_data();
+	struct mutex *chn_callback = p_data->callback_lock;
+	int channel;
+
+	for (channel = 0; channel < SDIO_CHANNEL_NUM; channel++)
+		mutex_destroy(&chn_callback[channel]);
+}
+
+void sdiohal_spinlock_init(void)
+{
+	struct sdiohal_data_t *p_data = sdiohal_get_data();
+
+	spin_lock_init(&p_data->tx_spinlock);
+	spin_lock_init(&p_data->rx_spinlock);
+}
+
+/* for sleep */
+#ifdef CONFIG_WCN_SLP
+void sdiohal_cp_tx_sleep(enum slp_subsys subsys)
+{
+	struct sdiohal_data_t *p_data = sdiohal_get_data();
+
+	sdiohal_debug("%s subsys:%d count:%d\n",
+		      __func__, subsys,
+		      atomic_read(&p_data->tx_wake_cp_count[subsys]));
+
+	sdiohal_atomic_sub(1, &p_data->tx_wake_cp_count[subsys]);
+	if (atomic_read(&p_data->tx_wake_cp_count[subsys]))
+		return;
+
+	slp_mgr_drv_sleep(subsys, true);
+}
+
+void sdiohal_cp_tx_wakeup(enum slp_subsys subsys)
+{
+	struct sdiohal_data_t *p_data = sdiohal_get_data();
+
+	sdiohal_debug("%s subsys:%d count:%d\n",
+		      __func__, subsys,
+		      atomic_read(&p_data->tx_wake_cp_count[subsys]));
+
+	sdiohal_atomic_add(1, &p_data->tx_wake_cp_count[subsys]);
+	slp_mgr_drv_sleep(subsys, false);
+	slp_mgr_wakeup(subsys);
+}
+
+void sdiohal_cp_rx_sleep(enum slp_subsys subsys)
+{
+	struct sdiohal_data_t *p_data = sdiohal_get_data();
+
+	sdiohal_debug("%s subsys:%d count:%d\n",
+		      __func__, subsys,
+		      atomic_read(&p_data->rx_wake_cp_count[subsys]));
+
+	sdiohal_atomic_sub(1, &p_data->rx_wake_cp_count[subsys]);
+	if (atomic_read(&p_data->rx_wake_cp_count[subsys]))
+		return;
+
+	slp_mgr_drv_sleep(subsys, true);
+}
+
+void sdiohal_cp_rx_wakeup(enum slp_subsys subsys)
+{
+	struct sdiohal_data_t *p_data = sdiohal_get_data();
+
+	sdiohal_debug("%s subsys:%d count:%d\n",
+		      __func__, subsys,
+		      atomic_read(&p_data->rx_wake_cp_count[subsys]));
+
+	sdiohal_atomic_add(1, &p_data->rx_wake_cp_count[subsys]);
+	slp_mgr_drv_sleep(subsys, false);
+	slp_mgr_wakeup(subsys);
+}
+#endif
+
+void sdiohal_resume_check(void)
+{
+	struct sdiohal_data_t *p_data = sdiohal_get_data();
+	unsigned int cnt = 0;
+
+	while ((!atomic_read(&p_data->flag_resume)) && (cnt++ < 5000)) {
+		if (cnt == 0) {
+			sdiohal_err("wait sdio resume %s\n", __func__);
+			dump_stack();
+		}
+		usleep_range(4000, 6000);
+	}
+}
+
+void sdiohal_resume_wait(void)
+{
+	struct sdiohal_data_t *p_data = sdiohal_get_data();
+	unsigned int cnt = 0;
+
+	while ((!atomic_read(&p_data->flag_resume)) && (cnt++ < 5000)) {
+		sdiohal_err("sleep 5ms wait for sdio resume, %d\n", cnt);
+		usleep_range(4000, 6000);
+	}
+}
+
+void sdiohal_op_enter(void)
+{
+	struct sdiohal_data_t *p_data = sdiohal_get_data();
+
+	mutex_lock(&p_data->xmit_lock);
+}
+
+void sdiohal_op_leave(void)
+{
+	struct sdiohal_data_t *p_data = sdiohal_get_data();
+
+	mutex_unlock(&p_data->xmit_lock);
+}
+
+void sdiohal_sdma_enter(void)
+{
+	struct sdiohal_data_t *p_data = sdiohal_get_data();
+
+	mutex_lock(&p_data->xmit_sdma);
+}
+
+void sdiohal_sdma_leave(void)
+{
+	struct sdiohal_data_t *p_data = sdiohal_get_data();
+
+	mutex_unlock(&p_data->xmit_sdma);
+}
+
+void sdiohal_mutex_init(void)
+{
+	struct sdiohal_data_t *p_data = sdiohal_get_data();
+
+	mutex_init(&p_data->xmit_lock);
+	mutex_init(&p_data->xmit_sdma);
+}
+
+void sdiohal_mutex_deinit(void)
+{
+	struct sdiohal_data_t *p_data = sdiohal_get_data();
+
+	mutex_destroy(&p_data->xmit_lock);
+	mutex_destroy(&p_data->xmit_sdma);
+}
+
+void sdiohal_sleep_flag_init(void)
+{
+	struct sdiohal_data_t *p_data = sdiohal_get_data();
+
+	atomic_set(&p_data->flag_resume, 1);
+}
+
+void sdiohal_channel_to_hwtype(int inout, int channel,
+	unsigned int *type, unsigned int *subtype)
+{
+	if (!inout)
+		channel -= SDIO_CHN_TX_NUM;
+	*type = 0;
+	*subtype = channel;
+
+	sdiohal_debug("%s type:%d, subtype:%d\n", __func__, *type, *subtype);
+}
+
+int sdiohal_hwtype_to_channel(int inout, unsigned int type,
+	unsigned int subtype)
+{
+	int channel = -1;
+
+	if (inout)
+		channel = subtype;
+	else
+		channel = subtype + SDIO_CHN_TX_NUM;
+
+	sdiohal_debug("%s channel:%d,inout:%d\n", __func__, channel, inout);
+
+	return channel;
+}
+
+bool sdiohal_is_tx_list_empty(void)
+{
+	struct sdiohal_data_t *p_data = sdiohal_get_data();
+
+	if (atomic_read(&p_data->tx_mbuf_num) != 0)
+		return false;
+
+	return true;
+}
+
+int sdiohal_tx_packer(struct sdiohal_sendbuf_t *send_buf,
+		      struct sdiohal_list_t *data_list,
+		      struct mbuf_t *mbuf_node)
+{
+	if ((!send_buf) || (!data_list) || (!mbuf_node))
+		return -EINVAL;
+
+	memcpy(send_buf->buf + send_buf->used_len,
+	       mbuf_node->buf, mbuf_node->len + sizeof(struct sdio_puh_t));
+
+	send_buf->used_len += sizeof(struct sdio_puh_t) +
+		SDIOHAL_ALIGN_4BYTE(mbuf_node->len);
+
+	return 0;
+}
+
+int sdiohal_tx_set_eof(struct sdiohal_sendbuf_t *send_buf,
+	unsigned char *eof_buf)
+{
+	if ((!send_buf) || (!eof_buf))
+		return -EINVAL;
+
+	memcpy((void *)(send_buf->buf + send_buf->used_len),
+	       (void *)eof_buf, sizeof(struct sdio_puh_t));
+	send_buf->used_len += sizeof(struct sdio_puh_t);
+
+	return 0;
+}
+
+static int sdiohal_tx_fill_puh(int channel, struct mbuf_t *head,
+			       struct mbuf_t *tail, int num)
+{
+	struct sdio_puh_t *puh = NULL;
+	struct mbuf_t *mbuf_node;
+	unsigned int type = 0, subtype = 0;
+	int inout = 1;
+	int i;
+
+	sdiohal_channel_to_hwtype(inout, channel, &type, &subtype);
+
+	mbuf_node = head;
+	for (i = 0; i < num; i++, mbuf_node = mbuf_node->next) {
+		if (!mbuf_node) {
+			sdiohal_err("%s tx fill puh, mbuf ptr error:%p\n",
+				    __func__, mbuf_node);
+
+			return -EFAULT;
+		}
+		puh = (struct sdio_puh_t *)mbuf_node->buf;
+		puh->type = type;
+		puh->subtype = subtype;
+		puh->len = mbuf_node->len;
+		puh->eof = 0;
+		puh->pad = 0;
+	}
+
+	return 0;
+}
+
+void sdiohal_tx_list_enq(int channel, struct mbuf_t *head,
+			 struct mbuf_t *tail, int num)
+{
+	struct sdiohal_data_t *p_data = sdiohal_get_data();
+
+	sdiohal_tx_fill_puh(channel, head, tail, num);
+
+	spin_lock_bh(&p_data->tx_spinlock);
+	if (atomic_read(&p_data->tx_mbuf_num) == 0)
+		p_data->tx_list_head.mbuf_head = head;
+	else
+		p_data->tx_list_head.mbuf_tail->next = head;
+	p_data->tx_list_head.mbuf_tail = tail;
+	p_data->tx_list_head.mbuf_tail->next = NULL;
+	p_data->tx_list_head.node_num += num;
+	sdiohal_atomic_add(num, &p_data->tx_mbuf_num);
+	spin_unlock_bh(&p_data->tx_spinlock);
+}
+
+void sdiohal_tx_find_data_list(struct sdiohal_list_t *data_list)
+{
+	struct sdiohal_data_t *p_data = sdiohal_get_data();
+	struct mbuf_t *mbuf_node;
+	int num, i;
+
+	spin_lock_bh(&p_data->tx_spinlock);
+	num = p_data->tx_list_head.node_num;
+	if (num > MAX_CHAIN_NODE_NUM)
+		num = MAX_CHAIN_NODE_NUM;
+
+	mbuf_node = p_data->tx_list_head.mbuf_head;
+	for (i = 1; i < num; i++)
+		mbuf_node = mbuf_node->next;
+
+	data_list->mbuf_head = p_data->tx_list_head.mbuf_head;
+	data_list->mbuf_tail = mbuf_node;
+	data_list->node_num = num;
+
+	p_data->tx_list_head.node_num -= num;
+	sdiohal_atomic_sub(num, &p_data->tx_mbuf_num);
+	if (atomic_read(&p_data->tx_mbuf_num) == 0) {
+		p_data->tx_list_head.mbuf_head = NULL;
+		p_data->tx_list_head.mbuf_tail = NULL;
+	} else
+		p_data->tx_list_head.mbuf_head = mbuf_node->next;
+	data_list->mbuf_tail->next = NULL;
+	spin_unlock_bh(&p_data->tx_spinlock);
+	sdiohal_list_check(data_list, __func__, SDIOHAL_WRITE);
+}
+
+static int sdiohal_tx_pop_assignment(struct sdiohal_list_t *data_list)
+{
+	struct sdiohal_data_t *p_data = sdiohal_get_data();
+	struct sdiohal_list_t *tx_list = NULL;
+	struct sdio_puh_t *puh = NULL;
+	struct mbuf_t *mbuf_node, *mbuf_next;
+	int inout = 1, channel = 0;
+	unsigned int node_num, i;
+
+	sdiohal_list_check(data_list, __func__, SDIOHAL_WRITE);
+	node_num = data_list->node_num;
+	mbuf_next = data_list->mbuf_head;
+	for (i = 0; i < node_num; i++) {
+		mbuf_node = mbuf_next;
+		if (!mbuf_node) {
+			sdiohal_err("%s tx pop mbuf ptr error:%p\n",
+				    __func__, mbuf_node);
+
+			return -EFAULT;
+		}
+		mbuf_next = mbuf_next->next;
+		puh = (struct sdio_puh_t *)mbuf_node->buf;
+		channel = sdiohal_hwtype_to_channel(inout,
+			puh->type, puh->subtype);
+		if (channel >= SDIO_CHN_TX_NUM) {
+			sdiohal_err("%s tx pop channel error:%d\n",
+				    __func__, channel);
+			continue;
+		}
+
+		tx_list = p_data->list_tx[channel];
+		mbuf_node->next = NULL;
+		if (tx_list->node_num == 0)
+			tx_list->mbuf_head = mbuf_node;
+		else
+			tx_list->mbuf_tail->next = mbuf_node;
+
+		tx_list->mbuf_tail = mbuf_node;
+		tx_list->type = puh->type;
+		tx_list->subtype = puh->subtype;
+		tx_list->node_num++;
+	}
+
+	return 0;
+}
+
+int sdiohal_tx_list_denq(struct sdiohal_list_t *data_list)
+{
+	struct list_head *list_head, *pos;
+	struct sdiohal_list_t *tx_list;
+	int channel, inout = 1;
+	struct sdiohal_data_t *p_data = sdiohal_get_data();
+	struct mutex *chn_callback = p_data->callback_lock;
+	struct mchn_ops_t *sdiohal_ops;
+
+	struct timespec64 tm_begin, tm_end;
+	static long time_total_ns;
+	static int times_count;
+
+	sdiohal_tx_pop_assignment(data_list);
+
+	list_head = &p_data->list_tx[0]->head;
+	for (pos = list_head; pos->next != list_head; pos = pos->next) {
+		tx_list = (struct sdiohal_list_t *)list_entry(pos,
+				struct sdiohal_list_t, head);
+		if (tx_list->node_num == 0)
+			continue;
+
+		sdiohal_list_check(tx_list, __func__, SDIOHAL_WRITE);
+		channel = sdiohal_hwtype_to_channel(inout, tx_list->type,
+						    tx_list->subtype);
+		sdiohal_print_list_data(channel, tx_list, __func__,
+					SDIOHAL_NORMAL_LEVEL);
+		if (channel >= SDIO_CHN_TX_NUM) {
+			sdiohal_err("%s tx pop channel error:%d\n",
+				    __func__, channel);
+			continue;
+		}
+
+		ktime_get_real_ts64(&tm_begin);
+
+		sdiohal_callback_lock(&chn_callback[channel]);
+		sdiohal_ops = chn_ops(channel);
+		sdiohal_mbuf_list_check(channel, tx_list->mbuf_head,
+					tx_list->mbuf_tail,
+					tx_list->node_num,
+					__func__, SDIOHAL_WRITE,
+					SDIOHAL_NORMAL_LEVEL);
+
+#if SDIO_DUMP_CHANNEL_DATA
+		if (channel == SDIO_DUMP_TX_CHANNEL_NUM) {
+			p_data->chntx_denq_old.time =
+				p_data->chntx_denq_new.time;
+			memcpy(p_data->chntx_denq_old.data_bk,
+			       p_data->chntx_denq_new.data_bk,
+			       SDIOHAL_PRINTF_LEN);
+			memcpy(p_data->chntx_denq_new.data_bk,
+			       tx_list->mbuf_tail->buf,
+			       SDIOHAL_PRINTF_LEN);
+			p_data->chntx_denq_new.time =
+				(unsigned int)ktime_to_ms(ktime_get());
+		}
+#endif
+
+		if (sdiohal_ops && sdiohal_ops->pop_link) {
+			sdiohal_ops->pop_link(channel, tx_list->mbuf_head,
+					      tx_list->mbuf_tail,
+					      tx_list->node_num);
+		} else
+			sdiohal_err("%s no tx ops channel:%d\n",
+				    __func__, channel);
+
+		tx_list->node_num = 0;
+		sdiohal_callback_unlock(&chn_callback[channel]);
+
+		ktime_get_real_ts64(&tm_end);
+		time_total_ns += timespec64_to_ns(&tm_end)
+			- timespec64_to_ns(&tm_begin);
+		times_count++;
+		if (!(times_count % PERFORMANCE_COUNT)) {
+			sdiohal_pr_perf("tx pop callback,avg time:%ld\n",
+					(time_total_ns / PERFORMANCE_COUNT));
+			time_total_ns = 0;
+			times_count = 0;
+		}
+	}
+
+	return 0;
+}
+
+int sdiohal_rx_list_dispatch(void)
+{
+	struct list_head *list_head, *pos;
+	struct sdiohal_list_t *rx_list;
+	int inout = 0, channel;
+	struct sdiohal_data_t *p_data = sdiohal_get_data();
+	struct mutex *chn_callback = p_data->callback_lock;
+	struct mchn_ops_t *sdiohal_ops;
+
+	struct timespec64 tm_begin, tm_end;
+	static long time_total_ns;
+	static int times_count;
+
+	if (unlikely(p_data->flag_init != true))
+		return -ENODEV;
+
+	list_head = &p_data->list_rx[0]->head;
+	for (pos = list_head; pos->next != list_head; pos = pos->next) {
+		rx_list = (struct sdiohal_list_t *)list_entry(pos,
+				struct sdiohal_list_t, head);
+		if (rx_list->node_num == 0)
+			continue;
+
+		sdiohal_list_check(rx_list, __func__, SDIOHAL_READ);
+		channel = sdiohal_hwtype_to_channel(inout, rx_list->type,
+						    rx_list->subtype);
+		sdiohal_print_list_data(channel, rx_list, __func__,
+					SDIOHAL_NORMAL_LEVEL);
+		if (channel >= SDIO_CHANNEL_NUM) {
+			sdiohal_err("%s rx pop channel error:%d\n",
+				    __func__, channel);
+			continue;
+		}
+
+		ktime_get_real_ts64(&tm_begin);
+
+		sdiohal_callback_lock(&chn_callback[channel]);
+		sdiohal_ops = chn_ops(channel);
+		sdiohal_mbuf_list_check(channel, rx_list->mbuf_head,
+					rx_list->mbuf_tail,
+					rx_list->node_num,
+					__func__, SDIOHAL_READ,
+					SDIOHAL_NORMAL_LEVEL);
+
+#if SDIO_DUMP_CHANNEL_DATA
+		if ((channel == SDIO_DUMP_RX_CHANNEL_NUM) &&
+		    (rx_list->mbuf_tail->buf[SDIO_PUB_HEADER_SIZE + 1] <
+		     SDIO_DUMP_RX_WIFI_EVENT_MIN)) {
+			p_data->chnrx_dispatch_old.time =
+				p_data->chnrx_dispatch_new.time;
+			memcpy(p_data->chnrx_dispatch_old.data_bk,
+			       p_data->chnrx_dispatch_new.data_bk,
+			       SDIOHAL_PRINTF_LEN);
+			memcpy(p_data->chnrx_dispatch_new.data_bk,
+			       rx_list->mbuf_tail->buf,
+			       SDIOHAL_PRINTF_LEN);
+			p_data->chnrx_dispatch_new.time =
+				(unsigned int)ktime_to_ms(ktime_get());
+		}
+#endif
+
+		if (sdiohal_ops && sdiohal_ops->pop_link) {
+			sdiohal_ops->pop_link(channel, rx_list->mbuf_head,
+					      rx_list->mbuf_tail,
+					      rx_list->node_num);
+		} else {
+			sdiohal_err("%s no rx ops channel:%d\n",
+				    __func__, channel);
+			sdiohal_rx_list_free(rx_list->mbuf_head,
+					     rx_list->mbuf_tail,
+					     rx_list->node_num);
+		}
+		rx_list->node_num = 0;
+		sdiohal_callback_unlock(&chn_callback[channel]);
+
+		ktime_get_real_ts64(&tm_end);
+		time_total_ns += timespec64_to_ns(&tm_end)
+			- timespec64_to_ns(&tm_begin);
+		times_count++;
+		if (!(times_count % PERFORMANCE_COUNT)) {
+			sdiohal_pr_perf("rx pop callback,avg time:%ld\n",
+					(time_total_ns / PERFORMANCE_COUNT));
+			time_total_ns = 0;
+			times_count = 0;
+		}
+	}
+
+	return 0;
+}
+
+struct sdiohal_list_t *sdiohal_get_rx_channel_list(int channel)
+{
+	struct sdiohal_data_t *p_data = sdiohal_get_data();
+
+	if (unlikely(p_data->flag_init != true))  {
+		sdiohal_err("%s sdiohal not init\n", __func__);
+		return NULL;
+	}
+
+	channel -= SDIO_CHN_TX_NUM;
+	if (channel >= SDIO_CHN_RX_NUM) {
+		sdiohal_err("%s rx error channel:%d\n", __func__, channel);
+		return NULL;
+	}
+
+	return p_data->list_rx[channel];
+}
+
+int sdiohal_rx_list_free(struct mbuf_t *mbuf_head,
+			 struct mbuf_t *mbuf_tail, int num)
+{
+	struct sdiohal_data_t *p_data = sdiohal_get_data();
+	void *data = NULL;
+	struct mbuf_t *mbuf_node;
+	int i;
+
+	mbuf_node = mbuf_head;
+	for (i = 0; i < num; i++, mbuf_node = mbuf_node->next) {
+		if (mbuf_node->buf) {
+			data = mbuf_node->buf;
+			sdiohal_debug("%s, before put page addr:%p,count:%d\n",
+				__func__, virt_to_head_page(data),
+#if KERNEL_VERSION(4, 7, 0) <= LINUX_VERSION_CODE
+				atomic_read(
+					&virt_to_head_page(data)->_refcount));
+#else
+				atomic_read(&virt_to_head_page(data)->_count));
+#endif
+			put_page(virt_to_head_page(data));
+			/* After put_page, count will be subtracted 1. */
+			sdiohal_debug("%s, after put page addr:%p,count:%d\n",
+				__func__, virt_to_head_page(data),
+#if KERNEL_VERSION(4, 7, 0) <= LINUX_VERSION_CODE
+				atomic_read(
+					&virt_to_head_page(data)->_refcount));
+#else
+				atomic_read(&virt_to_head_page(data)->_count));
+#endif
+
+			mbuf_node->buf = NULL;
+		}
+		mbuf_node->len = 0;
+	}
+
+	spin_lock_bh(&p_data->rx_spinlock);
+	if (p_data->list_rx_buf.node_num == 0)
+		p_data->list_rx_buf.mbuf_head = mbuf_head;
+	else
+		p_data->list_rx_buf.mbuf_tail->next = mbuf_head;
+	p_data->list_rx_buf.mbuf_tail = mbuf_tail;
+	p_data->list_rx_buf.node_num += num;
+	spin_unlock_bh(&p_data->rx_spinlock);
+
+	return 0;
+}
+
+/*
+ * fragsz: size of frag need to alloc
+ * gfp_mask: GFP mask
+ * ignore_alloc_fail:
+ *	If alloc_pages fail (size < fragsz), not put_page, fill alloc_size.
+ *	For example:
+ *	Need to alloc fragsz = 0x32000, but alloc 0x20000 mem actually.
+ *	ignore_alloc_fail=1: alloc_size=0x20000;
+ *	ignore_alloc_fail=0: put_page and return fail.
+ * alloc_size: alloc mem size actually.
+ */
+static void *sdiohal_alloc_frag(unsigned int fragsz, gfp_t gfp_mask,
+	unsigned char ignore_alloc_fail, unsigned int *alloc_size)
+{
+	struct sdiohal_data_t *p_data = sdiohal_get_data();
+	struct sdiohal_frag_mg *frag_ctl;
+	void *data = NULL;
+	int order;
+	unsigned long flags;
+
+	if (ignore_alloc_fail)
+		*alloc_size = fragsz;
+
+	local_irq_save(flags);
+	frag_ctl = &p_data->frag_ctl;
+	if (unlikely(!frag_ctl->frag.page)) {
+refill:
+#if (BITS_PER_LONG > 32) || (PAGE_SIZE >= 65536)
+		order = SDIOHAL_FRAG_PAGE_MAX_ORDER;
+#else
+		order = SDIOHAL_FRAG_PAGE_MAX_ORDER_32_BIT;
+#endif
+		for (; ;) {
+			gfp_t gfp = gfp_mask;
+
+			if (order)
+				gfp |= __GFP_COMP | __GFP_NOWARN;
+			/* alloc_pages will initialize count to 1. */
+			frag_ctl->frag.page = alloc_pages(gfp, order);
+			if (likely(frag_ctl->frag.page))
+				break;
+			if (--order < 0)
+				goto fail;
+		}
+		frag_ctl->frag.size = PAGE_SIZE << order;
+		if (frag_ctl->frag.size < fragsz) {
+			sdiohal_info("BITS_PER_LONG=%d,PAGE_SIZE=%ld,order=%d\n",
+				     BITS_PER_LONG, PAGE_SIZE, order);
+			sdiohal_info("alloc 0x%x mem, need:0x%x\n",
+				     frag_ctl->frag.size, fragsz);
+			if (ignore_alloc_fail) {
+				/* alloc fail, not put_page, fill frag size. */
+				*alloc_size = frag_ctl->frag.size;
+			} else {
+				put_page(frag_ctl->frag.page);
+				goto fail;
+			}
+		}
+
+		/*
+		 * Even if we own the page, we do not use atomic_set().
+		 * This would break get_page_unless_zero() users.
+		 */
+		atomic_add(SDIOHAL_PAGECNT_MAX_BIAS - 1,
+#if KERNEL_VERSION(4, 7, 0) <= LINUX_VERSION_CODE
+			   &frag_ctl->frag.page->_refcount);
+#else
+			   &frag_ctl->frag.page->_count);
+#endif
+		frag_ctl->pagecnt_bias = SDIOHAL_PAGECNT_MAX_BIAS;
+		frag_ctl->frag.offset = 0;
+	}
+
+	if (frag_ctl->frag.offset + fragsz > frag_ctl->frag.size) {
+#if KERNEL_VERSION(4, 7, 0) <= LINUX_VERSION_CODE
+		if (atomic_read(&frag_ctl->frag.page->_refcount) !=
+			frag_ctl->pagecnt_bias)
+#else
+		if (atomic_read(&frag_ctl->frag.page->_count) !=
+			frag_ctl->pagecnt_bias)
+#endif
+		{
+			if (!atomic_sub_and_test(frag_ctl->pagecnt_bias,
+#if KERNEL_VERSION(4, 7, 0) <= LINUX_VERSION_CODE
+				&frag_ctl->frag.page->_refcount))
+#else
+				&frag_ctl->frag.page->_count))
+#endif
+				goto refill;
+			/* OK, page count is 0, we can safely set it */
+#if KERNEL_VERSION(4, 7, 0) <= LINUX_VERSION_CODE
+			atomic_set(&frag_ctl->frag.page->_refcount,
+				   SDIOHAL_PAGECNT_MAX_BIAS);
+#else
+			atomic_set(&frag_ctl->frag.page->_count,
+				   SDIOHAL_PAGECNT_MAX_BIAS);
+#endif
+		} else {
+			atomic_add(SDIOHAL_PAGECNT_MAX_BIAS -
+				frag_ctl->pagecnt_bias,
+#if KERNEL_VERSION(4, 7, 0) <= LINUX_VERSION_CODE
+				&frag_ctl->frag.page->_refcount);
+#else
+				&frag_ctl->frag.page->_count);
+#endif
+		}
+		frag_ctl->pagecnt_bias = SDIOHAL_PAGECNT_MAX_BIAS;
+		frag_ctl->frag.offset = 0;
+	}
+
+	data = page_address(frag_ctl->frag.page) + frag_ctl->frag.offset;
+	frag_ctl->frag.offset += fragsz;
+	if (p_data->adma_rx_enable)
+		frag_ctl->pagecnt_bias--;
+
+	local_irq_restore(flags);
+	return data;
+fail:
+	local_irq_restore(flags);
+	sdiohal_err("alloc mem fail\n");
+	return NULL;
+}
+
+/* mbuf node no data buf pointer */
+struct sdiohal_list_t *sdiohal_get_rx_mbuf_node(int num)
+{
+	struct sdiohal_data_t *p_data = sdiohal_get_data();
+	struct sdiohal_list_t *idle_list;
+	struct mbuf_t *mbuf_head, *mbuf_tail;
+	int i;
+
+	if (num == 0) {
+		sdiohal_err("num err:%d\n", num);
+		goto err;
+	}
+
+	if (num > p_data->list_rx_buf.node_num) {
+		sdiohal_err("no rx mbuf node, need num:%d, list node num:%d\n",
+			    num, p_data->list_rx_buf.node_num);
+		goto err;
+	}
+
+	idle_list = kzalloc(sizeof(struct sdiohal_list_t), GFP_KERNEL);
+	if (!idle_list)
+		goto err;
+
+	spin_lock_bh(&p_data->rx_spinlock);
+	mbuf_head = mbuf_tail = p_data->list_rx_buf.mbuf_head;
+	for (i = 1; i < num; i++)
+		mbuf_tail = mbuf_tail->next;
+
+	p_data->list_rx_buf.node_num -= num;
+	if (p_data->list_rx_buf.node_num == 0) {
+		p_data->list_rx_buf.mbuf_head = NULL;
+		p_data->list_rx_buf.mbuf_tail = NULL;
+	} else
+		p_data->list_rx_buf.mbuf_head = mbuf_tail->next;
+
+	idle_list->mbuf_head = mbuf_head;
+	idle_list->mbuf_tail = mbuf_tail;
+	idle_list->mbuf_tail->next = NULL;
+	idle_list->node_num = num;
+	spin_unlock_bh(&p_data->rx_spinlock);
+
+	return idle_list;
+
+err:
+	return NULL;
+}
+
+/* for adma,mbuf list had data buf pointer */
+struct sdiohal_list_t *sdiohal_get_rx_mbuf_list(int num)
+{
+	struct sdiohal_list_t *idle_list;
+	struct mbuf_t *mbuf_temp;
+	int i;
+
+	idle_list = sdiohal_get_rx_mbuf_node(num);
+	if (!idle_list)
+		goto err;
+
+	mbuf_temp = idle_list->mbuf_head;
+	for (i = 0; i < num; i++) {
+		mbuf_temp->buf = sdiohal_alloc_frag(MAX_MBUF_SIZE,
+#if KERNEL_VERSION(4, 14, 0) <= LINUX_VERSION_CODE
+			GFP_ATOMIC,
+#else
+			GFP_ATOMIC | __GFP_COLD,
+#endif
+			0, NULL);
+		if (!mbuf_temp->buf) {
+			sdiohal_rx_list_free(idle_list->mbuf_head,
+					     idle_list->mbuf_tail, num);
+			kfree(idle_list);
+			goto err;
+		}
+		WARN_ON(((unsigned long int)mbuf_temp->buf) % 64);
+		mbuf_temp = mbuf_temp->next;
+	}
+
+	sdiohal_list_check(idle_list, __func__, SDIOHAL_READ);
+
+	return idle_list;
+err:
+	return NULL;
+}
+
+/* for normal dma idle buf */
+void *sdiohal_get_rx_free_buf(unsigned int *alloc_size)
+{
+	void *p;
+	unsigned int fragsz;
+
+#if (BITS_PER_LONG > 32) || (PAGE_SIZE >= 65536)
+	fragsz = SDIOHAL_RX_RECVBUF_LEN;
+
+#else
+	fragsz = SDIOHAL_32_BIT_RX_RECVBUF_LEN;
+#endif
+	p = sdiohal_alloc_frag(fragsz,
+#if KERNEL_VERSION(4, 14, 0) <= LINUX_VERSION_CODE
+			       GFP_ATOMIC,
+#else
+			       GFP_ATOMIC | __GFP_COLD,
+#endif
+			       1, alloc_size);
+
+	WARN_ON(((unsigned long int)p) % 64);
+
+	return p;
+}
+
+static int sdiohal_alloc_rx_mbuf_nodes(int num)
+{
+	struct sdiohal_data_t *p_data = sdiohal_get_data();
+	struct mbuf_t *mbuf_node, *mbuf_temp = NULL;
+	int i;
+
+	for (i = 0; i < num; i++) {
+		mbuf_node = kzalloc(sizeof(struct mbuf_t), GFP_KERNEL);
+		if (i == 0) {
+			p_data->list_rx_buf.mbuf_head = mbuf_node;
+			p_data->list_rx_buf.mbuf_tail = mbuf_node;
+		} else
+			mbuf_temp->next = mbuf_node;
+
+		mbuf_temp = mbuf_node;
+		p_data->list_rx_buf.node_num++;
+	}
+	mbuf_temp->next = NULL;
+	p_data->list_rx_buf.mbuf_tail = mbuf_temp;
+
+	return 0;
+}
+
+static void sdiohal_rx_buf_init(void)
+{
+	sdiohal_alloc_rx_mbuf_nodes(SDIOHAL_RX_NODE_NUM);
+}
+
+static int sdiohal_free_rx_mbuf_nodes(int num)
+{
+	struct sdiohal_data_t *p_data = sdiohal_get_data();
+	struct mbuf_t *mbuf_node = NULL, *mbuf_temp = NULL;
+	int i;
+
+	mbuf_temp = p_data->list_rx_buf.mbuf_head;
+	for (i = 0; i < num; i++) {
+		if (mbuf_temp->next)
+			mbuf_node = mbuf_temp->next;
+		mbuf_temp->next = NULL;
+		kfree(mbuf_temp);
+		mbuf_temp = mbuf_node;
+	}
+
+	p_data->list_rx_buf.mbuf_head = NULL;
+	p_data->list_rx_buf.mbuf_tail = NULL;
+	p_data->list_rx_buf.node_num = 0;
+
+	return 0;
+}
+
+static void sdiohal_rx_buf_deinit(void)
+{
+	sdiohal_free_rx_mbuf_nodes(SDIOHAL_RX_NODE_NUM);
+}
+
+int sdiohal_list_push(int channel, struct mbuf_t *head,
+		      struct mbuf_t *tail, int num)
+{
+	struct sdiohal_data_t *p_data = sdiohal_get_data();
+	struct timespec64 tm_begin, tm_end;
+	static long time_total_ns;
+	static int times_count;
+	struct mbuf_t *mbuf_node;
+	int i;
+
+	ktime_get_real_ts64(&tm_begin);
+
+	if (unlikely(p_data->flag_init != true))
+		return -ENODEV;
+
+	if (unlikely(p_data->card_dump_flag == true))
+		return -ENODEV;
+
+	sdiohal_mbuf_list_check(channel, head, tail, num, __func__,
+				(channel < SDIO_CHN_TX_NUM ?
+				SDIOHAL_WRITE : SDIOHAL_READ),
+				(channel < SDIO_CHN_TX_NUM ?
+				SDIOHAL_NORMAL_LEVEL :
+				SDIOHAL_LIST_LEVEL));
+	if ((channel < 0) || (channel >= SDIO_CHANNEL_NUM) ||
+		(!head) || (!tail) || (num <= 0)) {
+		sdiohal_err("%s Invalid argument\n", __func__);
+		dump_stack();
+		return -EINVAL;
+	}
+
+	mbuf_node = head;
+	for (i = 0; i < num; i++, mbuf_node = mbuf_node->next) {
+		if (!mbuf_node) {
+			sdiohal_err("%s mbuf list error\n", __func__);
+			dump_stack();
+			return -EFAULT;
+		}
+	}
+
+	if (channel < SDIO_CHN_TX_NUM) {
+		if (!atomic_read(&p_data->flag_resume)) {
+			sdiohal_err("%s chn=%d, in suspend, can't send data\n",
+				    __func__, channel);
+			return -EFAULT;
+		}
+		sdiohal_print_mbuf_data(channel, head, tail, num,
+					__func__, SDIOHAL_DATA_LEVEL);
+
+#if SDIO_DUMP_CHANNEL_DATA
+		if (channel == SDIO_DUMP_TX_CHANNEL_NUM) {
+			p_data->chntx_push_old.time =
+				p_data->chntx_push_new.time;
+			memcpy(p_data->chntx_push_old.data_bk,
+			       p_data->chntx_push_new.data_bk,
+			       SDIOHAL_PRINTF_LEN);
+			memcpy(p_data->chntx_push_new.data_bk,
+			       tail->buf,
+			       SDIOHAL_PRINTF_LEN);
+			p_data->chntx_push_new.time =
+				(unsigned int)ktime_to_ms(ktime_get());
+		}
+#endif
+
+		sdiohal_tx_list_enq(channel, head, tail, num);
+
+		ktime_get_real_ts64(&tm_end);
+		time_total_ns += timespec64_to_ns(&tm_end)
+			- timespec64_to_ns(&tm_begin);
+		times_count++;
+		if (!(times_count % PERFORMANCE_COUNT)) {
+			sdiohal_pr_perf("tx avg time:%ld\n",
+					(time_total_ns / PERFORMANCE_COUNT));
+			time_total_ns = 0;
+			times_count = 0;
+		}
+		ktime_get_real_ts64(&p_data->tm_begin_sch);
+
+		sdiohal_tx_up();
+	} else
+		sdiohal_rx_list_free(head, tail, num);
+
+	return 0;
+}
+
+/* tx send (write) directly not through sdio tx thread and
+ * not calling tx_pop callback when working in sdma mode.
+ */
+int sdiohal_list_direct_write(int channel, struct mbuf_t *head,
+			      struct mbuf_t *tail, int num)
+{
+	struct sdiohal_data_t *p_data = sdiohal_get_data();
+	struct sdiohal_list_t data_list;
+
+	sdiohal_lock_tx_ws();
+	sdiohal_resume_check();
+	sdiohal_cp_tx_wakeup(PACKER_DT_TX);
+	sdiohal_tx_fill_puh(channel, head, tail, num);
+
+	data_list.mbuf_head = head;
+	data_list.mbuf_tail = tail;
+	data_list.node_num = num;
+	data_list.mbuf_tail->next = NULL;
+
+	if (p_data->adma_tx_enable)
+		sdiohal_adma_pt_write(&data_list);
+	else
+		sdiohal_tx_data_list_send(&data_list, false);
+
+	sdiohal_cp_tx_sleep(PACKER_DT_TX);
+	sdiohal_unlock_tx_ws();
+
+	return 0;
+}
+
+static int sdiohal_list_init(void)
+{
+	struct sdiohal_data_t *p_data = sdiohal_get_data();
+	unsigned int channel = 0;
+
+	for (channel = 0; channel < SDIO_TX_LIST_NUM; channel++) {
+		p_data->list_tx[channel] =
+			kzalloc(sizeof(struct sdiohal_list_t), GFP_KERNEL);
+		if (!p_data->list_tx[channel])
+			return -ENOMEM;
+
+		if (channel == 0)
+			INIT_LIST_HEAD(&p_data->list_tx[channel]->head);
+		else
+			list_add_tail(&p_data->list_tx[channel]->head,
+				&p_data->list_tx[0]->head);
+		p_data->list_tx[channel]->node_num = 0;
+		p_data->list_tx[channel]->mbuf_head = NULL;
+	}
+
+	for (channel = 0; channel < SDIO_RX_LIST_NUM; channel++) {
+		p_data->list_rx[channel] =
+			kzalloc(sizeof(struct sdiohal_list_t), GFP_KERNEL);
+		if (!p_data->list_rx[channel])
+			return -ENOMEM;
+
+		if (channel == 0)
+			INIT_LIST_HEAD(&p_data->list_rx[channel]->head);
+		else
+			list_add_tail(&p_data->list_rx[channel]->head,
+				&p_data->list_rx[0]->head);
+		p_data->list_rx[channel]->node_num = 0;
+		p_data->list_rx[channel]->mbuf_head = NULL;
+	}
+
+	return 0;
+}
+
+static void sdiohal_list_deinit(void)
+{
+	struct sdiohal_data_t *p_data = sdiohal_get_data();
+	unsigned int channel = 0;
+	struct list_head *pos, *next;
+
+	for (channel = 0; channel < SDIO_TX_LIST_NUM; channel++) {
+		list_for_each_safe(pos, next, &p_data->list_tx[channel]->head) {
+			list_del_init(pos);
+		}
+		kfree(p_data->list_tx[channel]);
+	}
+
+	for (channel = 0; channel < SDIO_RX_LIST_NUM; channel++) {
+		list_for_each_safe(pos, next, &p_data->list_rx[channel]->head) {
+			list_del_init(pos);
+		}
+		kfree(p_data->list_rx[channel]);
+	}
+}
+
+static int sdiohal_tx_sendbuf_init(void)
+{
+	struct sdiohal_data_t *p_data = sdiohal_get_data();
+
+	p_data->send_buf.buf =
+		kzalloc(SDIOHAL_TX_SENDBUF_LEN, GFP_KERNEL);
+	if (!p_data->send_buf.buf)
+		return -ENOMEM;
+
+	return 0;
+}
+
+static void sdiohal_tx_sendbuf_deinit(void)
+{
+	struct sdiohal_data_t *p_data = sdiohal_get_data();
+
+	kfree(p_data->send_buf.buf);
+	p_data->send_buf.buf = NULL;
+	p_data->send_buf.retry_buf = NULL;
+}
+
+void sdiohal_tx_init_retrybuf(void)
+{
+	struct sdiohal_data_t *p_data = sdiohal_get_data();
+
+	p_data->send_buf.retry_buf = p_data->send_buf.buf;
+	p_data->send_buf.retry_len = p_data->send_buf.used_len;
+}
+
+static int sdiohal_eof_buf_init(void)
+{
+	struct sdiohal_data_t *p_data = sdiohal_get_data();
+
+	struct sdio_puh_t *puh = NULL;
+
+	p_data->eof_buf = kzalloc(MAX_MBUF_SIZE, GFP_KERNEL);
+	if (!p_data->eof_buf)
+		return -ENOMEM;
+
+	puh = (struct sdio_puh_t *)(p_data->eof_buf);
+	puh->type = 0;
+	puh->subtype = 0;
+	puh->len = 0;
+	puh->eof = 1;
+	puh->pad = 0;
+
+	return 0;
+}
+
+static void sdiohal_eof_buf_deinit(void)
+{
+	struct sdiohal_data_t *p_data = sdiohal_get_data();
+
+	kfree(p_data->eof_buf);
+}
+
+static int sdiohal_dtbs_buf_init(void)
+{
+	struct sdiohal_data_t *p_data = sdiohal_get_data();
+
+	p_data->dtbs_buf = sdiohal_alloc_frag(MAX_MBUF_SIZE,
+#if KERNEL_VERSION(4, 14, 0) <= LINUX_VERSION_CODE
+					      GFP_ATOMIC,
+#else
+					      GFP_ATOMIC | __GFP_COLD,
+#endif
+					      0, NULL);
+	if (!p_data->dtbs_buf)
+		return -ENOMEM;
+
+	WARN_ON(((unsigned long int)p_data->dtbs_buf) % 64);
+
+	return 0;
+}
+
+static int sdiohal_dtbs_buf_deinit(void)
+{
+	struct sdiohal_data_t *p_data = sdiohal_get_data();
+	int order;
+
+	if (!p_data->dtbs_buf)
+		return -ENOMEM;
+
+#if (BITS_PER_LONG > 32) || (PAGE_SIZE >= 65536)
+	order = SDIOHAL_FRAG_PAGE_MAX_ORDER;
+#else
+	order = SDIOHAL_FRAG_PAGE_MAX_ORDER_32_BIT;
+#endif
+	free_pages((unsigned long)p_data->dtbs_buf, order);
+	p_data->dtbs_buf = NULL;
+
+	return 0;
+}
+
+int sdiohal_misc_init(void)
+{
+	int ret = 0;
+
+	sdiohal_completion_init();
+	sdiohal_wakelock_init();
+	sdiohal_callback_lock_init();
+	sdiohal_spinlock_init();
+	sdiohal_sleep_flag_init();
+	sdiohal_mutex_init();
+	sdiohal_rx_buf_init();
+	sdiohal_dtbs_buf_init();
+	ret = sdiohal_list_init();
+	if (ret < 0)
+		sdiohal_err("alloc list err\n");
+	sdiohal_tx_sendbuf_init();
+	ret = sdiohal_eof_buf_init();
+
+	return ret;
+}
+
+void sdiohal_misc_deinit(void)
+{
+	sdiohal_eof_buf_deinit();
+	sdiohal_tx_sendbuf_deinit();
+	sdiohal_list_deinit();
+	sdiohal_dtbs_buf_deinit();
+	sdiohal_rx_buf_deinit();
+	sdiohal_mutex_deinit();
+	sdiohal_callback_lock_deinit();
+	sdiohal_wakelock_deinit();
+}
diff --git a/drivers/net/wireless/uwe5622/unisocwcn/sdio/sdiohal_ctl.c b/drivers/net/wireless/uwe5622/unisocwcn/sdio/sdiohal_ctl.c
new file mode 100644
index 000000000000..2908de8321d3
--- /dev/null
+++ b/drivers/net/wireless/uwe5622/unisocwcn/sdio/sdiohal_ctl.c
@@ -0,0 +1,1241 @@
+#include <linux/debugfs.h>
+#include <linux/file.h>
+#include <linux/interrupt.h>
+#include <linux/irq.h>
+#include <linux/kthread.h>
+#include <linux/mmc/host.h>
+#include <linux/of_gpio.h>
+#include <linux/slab.h>
+#include <linux/uaccess.h>
+#include <linux/version.h>
+#include <linux/vmalloc.h>
+#include <wcn_bus.h>
+
+#include "sdiohal.h"
+
+/*
+ * TCP_TEST_RX clear 0: TX send packets ceaselessly; set to 1:
+ * RX received one or two big packets (depend on TCP_TEST_1VS2)
+ * then TX send one short packet (1*100bytes)
+ */
+#define TCP_TEST_RX 0
+#define TCP_TEST_1VS2 0
+
+#define SDIOHAL_WRITE_SIZE 64
+#define SDIOHAL_DIR_TX 1
+#define SDIOHAL_DIR_RX 0
+
+#define TX_MULTI_BUF_SIZE 200
+
+#define TP_TX_BUF_CNT 520
+#define TP_TX_BUF_LEN 2044
+#define TP_TX_POOL_SIZE 100
+
+#define FIRMWARE_PATH "/dev/block/platform/sdio_emmc/by-name/wcnmodem"
+#define FIRMWARE_MAX_SIZE 0x7ac00
+#define PACKET_SIZE		(32*1024)
+#define CP_START_ADDR		0x100000
+
+#define AT_TX_CHANNEL CHANNEL_2
+#define AT_RX_CHANNEL CHANNEL_16
+
+/* for sdio int test */
+#define REG_TO_CP0_REQ0	0x1b0
+#define REG_TO_CP0_REQ1	0x1b1
+
+#define REG_TO_AP_ENABLE_0	0x1c0
+#define REG_TO_AP_ENABLE_1	0x1c1
+#define REG_TO_AP_INT_CLR0	0x1d0
+#define REG_TO_AP_INT_CLR1	0x1d1
+#define REG_TO_AP_PUB_STS0	0x1f0
+#define REG_TO_AP_PUB_STS1	0x1f1
+
+#define SDIOHAL_INT_PWR_FUNC	0
+#define SDIOHAL_GNSS_DUMP_FUNC	1
+#define GNSS_DUMP_WIFI_RAM_ADDR	0x40580000
+#define GNSS_DUMP_DATA_SIZE	0x38000
+
+enum {
+	/* SDIO TX */
+	CHANNEL_TX_BASE = 0,
+	CHANNEL_0 = CHANNEL_TX_BASE,
+	CHANNEL_1,
+	CHANNEL_2,
+	CHANNEL_3,
+	CHANNEL_4,
+	CHANNEL_5,
+	CHANNEL_6,
+	CHANNEL_7,
+	CHANNEL_8,
+	CHANNEL_9,
+	CHANNEL_10,
+	CHANNEL_11,
+
+	/* SDIO RX */
+	CHANNEL_RX_BASE = 12,
+	CHANNEL_12 = CHANNEL_RX_BASE,
+	CHANNEL_13,
+	CHANNEL_14,
+	CHANNEL_15,
+	CHANNEL_16,
+	CHANNEL_17,
+	CHANNEL_18,
+	CHANNEL_19,
+	CHANNEL_20,
+	CHANNEL_21,
+	CHANNEL_22,
+	CHANNEL_23,
+	CHANNEL_24,
+	CHANNEL_25,
+	CHANNEL_26,
+	CHANNEL_27,
+};
+
+char cmd_buf[SDIOHAL_WRITE_SIZE + PUB_HEAD_RSV];
+char *tp_tx_buf[TP_TX_BUF_CNT];
+
+struct mchn_ops_t at_tx_ops;
+struct mchn_ops_t at_rx_ops;
+u64 tp_tx_start_time;
+u64 tp_tx_stop_time;
+int tp_tx_cnt;
+int tp_tx_flag;
+int tp_tx_buf_cnt = TP_TX_BUF_CNT;
+int tp_tx_buf_len = TP_TX_BUF_LEN;
+int rx_pop_cnt;
+#ifdef CONFIG_SPRD_DEBUG
+long int sdiohal_log_level = SDIOHAL_NORMAL_LEVEL;
+#else
+long int sdiohal_log_level;
+#endif
+
+#if TCP_TEST_RX
+struct completion tp_rx_completed;
+
+static void sdiohal_tp_rx_up(void)
+{
+	complete(&tp_rx_completed);
+}
+
+static void sdiohal_tp_rx_down(void)
+{
+	wait_for_completion(&tp_rx_completed);
+}
+#endif
+
+static int sdiohal_extract_num(char *p, int cur)
+{
+	int i, num = 0;
+
+	for (i = cur + 1; i < SDIOHAL_WRITE_SIZE; i++) {
+		if ((p[i] >= '0') && (p[i] <= '9')) {
+			num *= 10;
+			num += p[i] - '0';
+		} else
+			break;
+	}
+
+	return num;
+}
+
+/*
+ * comma_cnt: buf_cnt
+ * star_len: buf_len
+ * eg.
+ * echo "tp,10*52424\r" >/d/sdiohal_debug/at_cmd
+ * comma_cnt: buf_cnt = 10
+ * star_len: buf_len = 52424
+ */
+static void sdiohal_find_num(char *p, int *comma_cnt, int *star_len)
+{
+	int i;
+
+	for (i = 0; i < SDIOHAL_WRITE_SIZE; i++) {
+		if (p[i] == '*') {
+			/* '*' with buf len */
+			*star_len = sdiohal_extract_num(p, i);
+		} else if (p[i] == ',') {
+			/* ',' with buf cnt */
+			*comma_cnt = sdiohal_extract_num(p, i);
+		} else if (p[i] == '\0')
+			break;
+	}
+}
+
+static int sdiohal_throughput_tx_alloc(void)
+{
+	int i, j;
+
+	for (i = 0; i < TP_TX_BUF_CNT; i++) {
+		tp_tx_buf[i] = kzalloc(TP_TX_BUF_LEN + PUB_HEAD_RSV,
+				       GFP_KERNEL);
+		if (!tp_tx_buf[i]) {
+			for (j = 0; j < i; j++) {
+				kfree(tp_tx_buf[j]);
+				tp_tx_buf[j] = NULL;
+			}
+			return -ENOMEM;
+		}
+	}
+	return 0;
+}
+
+static int sdiohal_throughput_tx(void)
+{
+	struct mbuf_t *head, *tail, *temp;
+	int tx_debug_num = tp_tx_buf_cnt;
+	int i = 0;
+	int buf_len = tp_tx_buf_len;
+	int ret = 0;
+
+	if (!sprdwcn_bus_list_alloc(AT_TX_CHANNEL,
+				    &head, &tail, &tx_debug_num)) {
+		if (tx_debug_num >= tp_tx_buf_cnt) {
+			/* linked list */
+			temp = head;
+			for (i = 0; i < tp_tx_buf_cnt; i++) {
+				temp->buf = tp_tx_buf[i];
+				temp->len = buf_len;
+				if ((i + 1) < tp_tx_buf_cnt)
+					temp = temp->next;
+				else
+					temp->next = NULL;
+			}
+			ret = sprdwcn_bus_push_list(AT_TX_CHANNEL,
+						    head, tail, tx_debug_num);
+			if (ret)
+				sdiohal_info("send_data_func failed!!!\n");
+			return 0;
+		}
+
+		sprdwcn_bus_list_free(AT_TX_CHANNEL, head, tail,
+				      tx_debug_num);
+		sdiohal_info("%s tx_debug_num=%d < %d\n",
+			     __func__, tx_debug_num, tp_tx_buf_cnt);
+
+		return -ENOMEM;
+	}
+
+	return -ENOMEM;
+}
+
+static void sdiohal_throughput_tx_compute_time(void)
+{
+	static signed long long times_count;
+
+	if (tp_tx_flag != 1)
+		return;
+
+	/* throughput test */
+	tp_tx_cnt++;
+	if (tp_tx_cnt % 500 == 0) {
+		tp_tx_stop_time = ktime_get_ns();
+		times_count = tp_tx_stop_time - tp_tx_start_time;
+		sdiohal_info("tx->times(500c) is %lldns, tx %d, rx %d\n",
+			     times_count, tp_tx_cnt, rx_pop_cnt);
+		tp_tx_cnt = 0;
+		tp_tx_start_time = ktime_get_ns();
+	}
+	sdiohal_throughput_tx();
+}
+
+static int sdiohal_throughput_rx(void)
+{
+	return 0;
+}
+
+#if TCP_TEST_RX
+static int sdiohal_throughput_tx_thread(void *data)
+{
+	int i = 0, rx_pop_cnt_old = 0;
+
+	while (1) {
+		sdiohal_tp_rx_down();
+		rx_pop_cnt_old = rx_pop_cnt - rx_pop_cnt_old;
+		tp_tx_buf_cnt = 1;
+		tp_tx_buf_len = 100;
+		for (i = 0; i < rx_pop_cnt_old;
+		     i = i + (TCP_TEST_1VS2 ? 2 : 1))
+			sdiohal_throughput_tx_compute_time();
+	}
+
+	return 0;
+}
+
+static void sdiohal_launch_tp_tx_thread(void)
+{
+	struct task_struct *tx_thread = NULL;
+
+	init_completion(&tp_rx_completed);
+
+	tx_thread =
+		kthread_create(sdiohal_throughput_tx_thread,
+			       NULL, "sdiohal_tp_tx_thread");
+	if (tx_thread)
+		wake_up_process(tx_thread);
+	else
+		sdiohal_err("create sdiohal_tp_tx_thread fail\n");
+}
+#endif
+
+static void sdiohal_tx_send(int chn);
+
+static int sdiohal_tx_thread_chn6(void *data)
+{
+	do {
+		sdiohal_tx_send(6);
+	} while (1);
+
+	return 0;
+}
+
+static int sdiohal_tx_thread_chn7(void *data)
+{
+	do {
+		sdiohal_tx_send(7);
+	} while (1);
+
+	return 0;
+}
+
+static int sdiohal_tx_thread_chn8(void *data)
+{
+	do {
+		sdiohal_tx_send(8);
+	} while (1);
+
+	return 0;
+}
+
+static int sdiohal_tx_thread_chn9(void *data)
+{
+	do {
+		sdiohal_tx_send(9);
+	} while (1);
+
+	return 0;
+}
+
+static int sdiohal_tx_thread_chn10(void *data)
+{
+	do {
+		sdiohal_tx_send(10);
+	} while (1);
+
+	return 0;
+}
+
+static int sdiohal_tx_thread_chn11(void *data)
+{
+	do {
+		sdiohal_tx_send(11);
+	} while (1);
+
+	return 0;
+}
+
+struct sdiohal_test_thread_info_t {
+	char *thread_name;
+	int (*thread_func)(void *data);
+	struct completion tx_completed;
+};
+
+struct sdiohal_test_thread_info_t sdiohal_thread_info[] = {
+	{
+		.thread_name = "sdiohal_tx_thread_chn6",
+		.thread_func = sdiohal_tx_thread_chn6,
+	},
+	{
+		.thread_name = "sdiohal_tx_thread_chn7",
+		.thread_func = sdiohal_tx_thread_chn7,
+	},
+	{
+		.thread_name = "sdiohal_tx_thread_chn8",
+		.thread_func = sdiohal_tx_thread_chn8,
+	},
+	{
+		.thread_name = "sdiohal_tx_thread_chn9",
+		.thread_func = sdiohal_tx_thread_chn9,
+	},
+	{
+		.thread_name = "sdiohal_tx_thread_chn10",
+		.thread_func = sdiohal_tx_thread_chn10,
+	},
+	{
+		.thread_name = "sdiohal_tx_thread_chn11",
+		.thread_func = sdiohal_tx_thread_chn11,
+	},
+
+};
+
+static void sdiohal_tx_send(int chn)
+{
+	struct mbuf_t *head, *tail, *mbuf_node;
+	int num = 5;
+	int ret, i;
+
+	wait_for_completion(&sdiohal_thread_info[chn - 6].tx_completed);
+
+	if (!sprdwcn_bus_list_alloc(chn, &head, &tail, &num)) {
+		if (num >= 5) {
+			mbuf_node = head;
+			for (i = 0; i < num; i++) {
+				mbuf_node->buf = kzalloc(TX_MULTI_BUF_SIZE +
+							 PUB_HEAD_RSV,
+							 GFP_KERNEL);
+				mbuf_node->len = TX_MULTI_BUF_SIZE;
+				if ((i + 1) < num)
+					mbuf_node = mbuf_node->next;
+				else
+					mbuf_node->next = NULL;
+			}
+
+			sdiohal_info("%s channel:%d num:%d\n",
+				     __func__, chn, num);
+
+			ret = sprdwcn_bus_push_list(chn, head, tail, num);
+			if (ret)
+				sdiohal_err("send_data_func failed, num:%d\n",
+					    num);
+		} else
+			sdiohal_info("%s alloced mbuf num=%d < 8\n",
+				     __func__,	num);
+	}
+
+}
+
+int sdiohal_tx_muti_channel_pop(int channel, struct mbuf_t *head,
+		   struct mbuf_t *tail, int num)
+{
+	struct mbuf_t *mbuf_node;
+	int i;
+
+	sdiohal_debug("%s channel:%d head:%p tail:%p num:%d\n",
+		__func__, channel, head, tail, num);
+
+	if (channel < 12) {
+		for (mbuf_node = head, i = 0; i < num; i++,
+			mbuf_node = mbuf_node->next) {
+			kfree(mbuf_node->buf);
+			mbuf_node->buf = NULL;
+		}
+		sprdwcn_bus_list_free(channel, head, tail, num);
+		complete(&sdiohal_thread_info[channel - 6].tx_completed);
+	} else
+		sdiohal_err("channel err:%d\n", channel);
+
+	return 0;
+}
+
+static void sdiohal_tx_test_init(void)
+{
+	struct task_struct *tx_thread = NULL;
+	struct mchn_ops_t *tx_test_ops;
+	int chn_num = 6, chn;
+
+
+	for (chn = 0; chn < chn_num; chn++) {
+		tx_test_ops = kzalloc(sizeof(struct mchn_ops_t), GFP_KERNEL);
+		if (!tx_test_ops) {
+			sdiohal_err("sdio tx test,alloc mem fail\n");
+			return;
+		}
+
+		tx_test_ops->channel = chn + chn_num;
+		tx_test_ops->hif_type = HW_TYPE_SDIO;
+		tx_test_ops->inout = SDIOHAL_DIR_TX;
+		tx_test_ops->pool_size = 5;
+		tx_test_ops->pop_link = sdiohal_tx_muti_channel_pop;
+
+		if (sprdwcn_bus_chn_init(tx_test_ops)) {
+			sprdwcn_bus_chn_deinit(tx_test_ops);
+			sprdwcn_bus_chn_init(tx_test_ops);
+		}
+
+		init_completion(&sdiohal_thread_info[chn].tx_completed);
+		tx_thread =
+			kthread_create(sdiohal_thread_info[chn].thread_func,
+				       NULL,
+				       sdiohal_thread_info[chn].thread_name);
+		if (tx_thread)
+			wake_up_process(tx_thread);
+		else {
+			sdiohal_err("create sdiohal_tx_thread fail\n");
+			return;
+		}
+		complete(&sdiohal_thread_info[chn].tx_completed);
+	}
+}
+
+int sdiohal_rx_muti_channel_pop(int channel, struct mbuf_t *head,
+		   struct mbuf_t *tail, int num)
+{
+	int i;
+
+	sdiohal_info("%s channel:%d head:%p tail:%p num:%d\n",
+		     __func__, channel, head, tail, num);
+
+	for (i = 0; i < (head->len < 80 ? head->len:80); i++)
+		sdiohal_info("%s i%d 0x%x\n", __func__, i, head->buf[i]);
+
+	sprdwcn_bus_push_list(channel, head, tail, num);
+
+	return 0;
+}
+
+static void sdiohal_rx_test_init(void)
+{
+	struct mchn_ops_t *rx_test_ops;
+	int chn_num = 6, chn;
+
+
+	for (chn = 0; chn < chn_num; chn++) {
+		rx_test_ops = kzalloc(sizeof(struct mchn_ops_t), GFP_KERNEL);
+		if (!rx_test_ops) {
+			sdiohal_err("sdio tx test,alloc mem fail\n");
+			return;
+		}
+
+		rx_test_ops->channel = chn + 8 + 12;
+		rx_test_ops->hif_type = HW_TYPE_SDIO;
+		rx_test_ops->inout = SDIOHAL_DIR_RX;
+		rx_test_ops->pool_size = 1;
+		rx_test_ops->pop_link = sdiohal_rx_muti_channel_pop;
+
+		if (sprdwcn_bus_chn_init(rx_test_ops)) {
+			sprdwcn_bus_chn_deinit(rx_test_ops);
+			sprdwcn_bus_chn_init(rx_test_ops);
+		}
+	}
+}
+
+int at_list_tx_pop(int channel, struct mbuf_t *head,
+		   struct mbuf_t *tail, int num)
+{
+	struct mbuf_t *mbuf_node;
+	int i;
+
+	sdiohal_debug("%s channel:%d head:%p tail:%p num:%d\n",
+		      __func__, channel, head, tail, num);
+	sdiohal_debug("%s len:%d buf:%s\n",
+		      __func__, head->len, head->buf + 4);
+
+	if (tp_tx_flag != 1) {
+		mbuf_node = head;
+		for (i = 0; i < num; i++, mbuf_node = mbuf_node->next) {
+			kfree(mbuf_node->buf);
+			mbuf_node->buf = NULL;
+		}
+	}
+
+	sprdwcn_bus_list_free(channel, head, tail, num);
+
+#if (!TCP_TEST_RX)
+	sdiohal_throughput_tx_compute_time();
+#endif
+
+	return 0;
+}
+
+int tp_rx_cnt;
+u64 tp_rx_start_time;
+u64 tp_rx_stop_time;
+int at_list_rx_pop(int channel, struct mbuf_t *head,
+		   struct mbuf_t *tail, int num)
+{
+	static signed long long times_count;
+
+	sdiohal_debug("%s channel:%d head:%p tail:%p num:%d\n",
+		     __func__, channel, head, tail, num);
+	sdiohal_debug("%s len:%d buf:%s\n",
+		     __func__, head->len, head->buf + 4);
+
+	sprdwcn_bus_push_list(at_rx_ops.channel, head, tail, num);
+	rx_pop_cnt += num;
+
+#if TCP_TEST_RX
+	sdiohal_tp_rx_up();
+#endif
+
+	/* throughput test */
+	tp_rx_cnt += num;
+	if (tp_rx_cnt / (500*64) == 1) {
+		tp_rx_stop_time = ktime_get_ns();
+		times_count = tp_rx_stop_time - tp_rx_start_time;
+		sdiohal_info("rx->times(%dc) is %lldns, tx %d, rx %d\n",
+			     tp_rx_cnt, times_count, tp_tx_cnt, rx_pop_cnt);
+		tp_rx_cnt = 0;
+		tp_rx_start_time = ktime_get_ns();
+	}
+
+	return 0;
+}
+
+struct mchn_ops_t at_tx_ops = {
+	.channel = AT_TX_CHANNEL,
+	.hif_type = HW_TYPE_SDIO,
+	.inout = SDIOHAL_DIR_TX,
+	.pool_size = 13,
+	.pop_link = at_list_tx_pop,
+};
+
+struct mchn_ops_t at_rx_ops = {
+	.channel = AT_RX_CHANNEL,
+	.hif_type = HW_TYPE_SDIO,
+	.inout = SDIOHAL_DIR_RX,
+	.pool_size = 1,
+	.pop_link = at_list_rx_pop,
+};
+
+static int at_cmd_init(void)
+{
+	sprdwcn_bus_chn_init(&at_tx_ops);
+	sprdwcn_bus_chn_init(&at_rx_ops);
+
+	return 0;
+}
+
+static int at_cmd_deinit(void)
+{
+	sprdwcn_bus_chn_deinit(&at_tx_ops);
+	sprdwcn_bus_chn_deinit(&at_rx_ops);
+
+	return 0;
+}
+
+static char *sdiohal_firmware_data(unsigned long int imag_size)
+{
+	int read_len, size;
+	char *buffer = NULL;
+	char *data = NULL;
+	struct file *file;
+	loff_t pos = 0;
+
+	sdiohal_info("%s entry\n", __func__);
+	file = filp_open(FIRMWARE_PATH, O_RDONLY, 0);
+	if (IS_ERR(file)) {
+		sdiohal_err("%s open file %s error\n",
+			    FIRMWARE_PATH, __func__);
+		return NULL;
+	}
+	sdiohal_info("marlin %s open image file  successfully\n", __func__);
+	size = imag_size;
+	buffer = vmalloc(size);
+	if (!buffer) {
+		fput(file);
+		sdiohal_err("%s no memory\n", __func__);
+		return NULL;
+	}
+
+	data = buffer;
+	do {
+#if KERNEL_VERSION(4, 14, 0) <= LINUX_VERSION_CODE
+		read_len = kernel_read(file, (void *)buffer, size, &pos);
+#else
+		read_len = kernel_read(file, pos, buffer, size);
+#endif
+		if (read_len > 0) {
+			size -= read_len;
+			buffer += read_len;
+		}
+	} while ((read_len > 0) && (size > 0));
+	fput(file);
+	sdiohal_info("%s finish read_Len:%d\n", __func__, read_len);
+
+	return data;
+}
+
+static int sdiohal_download_firmware(void)
+{
+	int err, len, trans_size;
+	unsigned long int img_size;
+	char *buffer = NULL;
+	char *temp_buf;
+
+	img_size = FIRMWARE_MAX_SIZE;
+
+	sdiohal_info("%s entry\n", __func__);
+	buffer = sdiohal_firmware_data(img_size);
+	if (!buffer) {
+		sdiohal_err("%s buff is NULL\n", __func__);
+		return -1;
+	}
+
+	len = 0;
+	temp_buf = kzalloc(PACKET_SIZE, GFP_KERNEL);
+	while (len < img_size) {
+		trans_size = (img_size - len) > PACKET_SIZE ?
+				PACKET_SIZE : (img_size - len);
+		memcpy(temp_buf, buffer + len, trans_size);
+		err = sprdwcn_bus_direct_write(CP_START_ADDR + len,
+			temp_buf, trans_size);
+		if (err < 0) {
+			sdiohal_err("marlin %s error:%d\n", __func__, err);
+			vfree(buffer);
+			kfree(temp_buf);
+			return -1;
+		}
+		len += PACKET_SIZE;
+	}
+	vfree(buffer);
+	kfree(temp_buf);
+	sdiohal_info("%s finish\n", __func__);
+
+	return 0;
+}
+
+static int sdiohal_public_irq;
+struct work_struct sdiohal_int_wq;
+
+static void sdiohal_int_power_wq(struct work_struct *work)
+{
+	unsigned char reg_pub_int_sts0 = 0;
+	unsigned char reg_pub_int_sts1 = 0;
+
+	sdiohal_info("%s entry\n", __func__);
+	/* read public interrupt status register */
+	sprdwcn_bus_aon_readb(REG_TO_AP_PUB_STS0, &reg_pub_int_sts0);
+	sprdwcn_bus_aon_readb(REG_TO_AP_PUB_STS1, &reg_pub_int_sts1);
+
+	sprdwcn_bus_aon_writeb(REG_TO_AP_INT_CLR0, 0xff);
+	sprdwcn_bus_aon_writeb(REG_TO_AP_INT_CLR1, 0xff);
+
+	sdiohal_info("PUB INT_STS0-0x%x\n", reg_pub_int_sts0);
+	sdiohal_info("PUB INT_STS1-0x%x\n", reg_pub_int_sts1);
+
+	enable_irq(sdiohal_public_irq);
+}
+
+/* below is used for gnss data capture function */
+static void sdiohal_gnss_dump_wq(struct work_struct *work)
+{
+	int i = 0, ret = 0;
+	unsigned int *reg_val;
+
+	reg_val = kzalloc(GNSS_DUMP_DATA_SIZE, GFP_KERNEL);
+	ret = sprdwcn_bus_direct_read(GNSS_DUMP_WIFI_RAM_ADDR,
+		reg_val, GNSS_DUMP_DATA_SIZE);
+	if (ret < 0) {
+		sdiohal_err("%s read reg error:%d\n", __func__, ret);
+		return;
+	}
+	for (i = 0; i < 2000; i++)
+		sdiohal_info("%d 0x%x\n", i, reg_val[i]);
+}
+
+static irqreturn_t sdiohal_public_isr(int irq, void *para)
+{
+	disable_irq_nosync(irq);
+	schedule_work(&sdiohal_int_wq);
+
+	return IRQ_HANDLED;
+}
+
+static int sdiohal_test_int_init(unsigned char func_tag)
+{
+#ifdef CONFIG_WCN_PARSE_DTS
+	struct device_node *np;
+#endif
+	unsigned int pub_gpio_num = 0;
+	unsigned char reg_int_en = 0;
+	int ret;
+
+	if (func_tag == SDIOHAL_INT_PWR_FUNC)
+		INIT_WORK(&sdiohal_int_wq, sdiohal_int_power_wq);
+	else if (func_tag == SDIOHAL_GNSS_DUMP_FUNC)
+		INIT_WORK(&sdiohal_int_wq, sdiohal_gnss_dump_wq);
+
+#ifdef CONFIG_WCN_PARSE_DTS
+	np = of_find_node_by_name(NULL, "uwe-bsp");
+	if (!np) {
+		sdiohal_err("dts node not found");
+		return -1;
+	}
+	pub_gpio_num = of_get_named_gpio(np, "int-gpio", 0);
+#endif
+	sdiohal_info("pub_gpio_num:%d\n", pub_gpio_num);
+	ret = gpio_request(pub_gpio_num, "sdiohal_int_gpio");
+	if (ret < 0) {
+		sdiohal_err("req gpio irq = %d fail!!!", pub_gpio_num);
+		return ret;
+	}
+
+	ret = gpio_direction_input(pub_gpio_num);
+	if (ret < 0) {
+		sdiohal_err("public_int, gpio-%d input set fail!!!",
+			pub_gpio_num);
+		return ret;
+	}
+
+	sdiohal_public_irq = gpio_to_irq(pub_gpio_num);
+
+	ret = request_irq(sdiohal_public_irq,
+			sdiohal_public_isr,
+			IRQF_TRIGGER_HIGH | IRQF_NO_SUSPEND,
+			"sdiohal_test_irq",
+			NULL);
+
+	/* enable sdio cp to ap int */
+	sprdwcn_bus_aon_writeb(REG_TO_AP_ENABLE_0, 0xff);
+	sprdwcn_bus_aon_readb(REG_TO_AP_ENABLE_0, &reg_int_en);
+	sdiohal_info("REG_TO_AP_ENABLE_0-0x%x\n", reg_int_en);
+
+	sprdwcn_bus_aon_writeb(REG_TO_AP_ENABLE_1, 0xff);
+	sprdwcn_bus_aon_readb(REG_TO_AP_ENABLE_1, &reg_int_en);
+	sdiohal_info("REG_TO_AP_ENABLE_1-0x%x\n", reg_int_en);
+
+	return 0;
+}
+
+static void sdiohal_change_to_sdr104(void)
+{
+	struct sdiohal_data_t *p_data = sdiohal_get_data();
+
+	sdiohal_info("%s entry\n", __func__);
+
+	if (!p_data->sdio_dev_host) {
+		sdiohal_err("%s get host failed!\n", __func__);
+		return;
+	}
+	p_data->sdio_dev_host->caps |= MMC_CAP_UHS_SDR104;
+}
+
+static int at_cmd_open(struct inode *inode, struct file *filp)
+{
+	return 0;
+}
+
+static ssize_t at_cmd_read(struct file *filp,
+	char __user *user_buf, size_t count, loff_t *pos)
+{
+	return count;
+}
+
+static ssize_t at_cmd_write(struct file *filp,
+		const char __user *user_buf, size_t count, loff_t *pos)
+{
+	struct sdiohal_data_t *p_data = sdiohal_get_data();
+	struct mbuf_t *head, *tail, *mbuf_node;
+	int num = 1, i;
+	long int long_data;
+	int ret;
+	unsigned char *send_buf = NULL;
+
+	if (count > SDIOHAL_WRITE_SIZE) {
+		sdiohal_err("%s write size > %d\n",
+			__func__, SDIOHAL_WRITE_SIZE);
+		return -ENOMEM;
+	}
+
+	memset(cmd_buf, 0, SDIOHAL_WRITE_SIZE);
+	if (copy_from_user(cmd_buf + PUB_HEAD_RSV, user_buf, count))
+		return -EFAULT;
+
+	sdiohal_info("%s write :%s\n", __func__, cmd_buf + PUB_HEAD_RSV);
+
+	if (strncmp(cmd_buf + PUB_HEAD_RSV, "download", 8) == 0) {
+		sdiohal_download_firmware();
+		return count;
+	}
+
+	/* read cp2 register by direct mode: "readreg 0x40844220" */
+	if (strncmp(cmd_buf + PUB_HEAD_RSV, "readreg 0x", 10) == 0) {
+		long int reg_addr_read;
+		unsigned int reg_addr, reg_val;
+
+		cmd_buf[SDIOHAL_WRITE_SIZE + PUB_HEAD_RSV - 1] = 0;
+		ret = kstrtol(&cmd_buf[PUB_HEAD_RSV + sizeof("readreg 0x") - 1],
+			      16, &reg_addr_read);
+		reg_addr = reg_addr_read & 0xFFFFFFFF;
+		ret = sprdwcn_bus_reg_read(reg_addr, &reg_val, 4);
+		if (ret < 0)
+			sdiohal_err("%s read 0x%x error:%d\n",
+				    __func__, reg_addr, ret);
+		sdiohal_info("%s read reg_addr 0x%x=0x%x\n",
+			     __func__, reg_addr, reg_val);
+		return count;
+	}
+
+	/* read cp2 block memory by direct mode: "readregblock 0x40844220 100"
+	 * the unit of len is byte, and len must be a multiple of 4
+	 */
+	if (strncmp(cmd_buf + PUB_HEAD_RSV, "readregblock 0x", 15) == 0) {
+		long int reg_addr_read;
+		unsigned int reg_addr, reg_val;
+		int i = 0;
+		char pk[16] = {0};
+		long int len = 0;
+		int line = 0;
+		char addr[12] = {0};
+
+		cmd_buf[SDIOHAL_WRITE_SIZE + PUB_HEAD_RSV - 1] = 0;
+		cmd_buf[PUB_HEAD_RSV + sizeof("readregblock 0x") + 7] = '\0';
+		ret = kstrtol(&cmd_buf[PUB_HEAD_RSV +
+			      sizeof("readregblock 0x") - 1], 16,
+			      &reg_addr_read);
+		reg_addr = reg_addr_read & 0xFFFFFFFF;
+		ret = kstrtol(&cmd_buf[PUB_HEAD_RSV +
+			      sizeof("readregblock 0x") + 8], 10, &len);
+
+		sdiohal_info("%s read reg_addr 0x%x: len:%ld\n",
+			     __func__, reg_addr, len);
+
+		if (len % 16)
+			line = len / 16 + 1;
+		else
+			line = len / 16;
+		for (i = 0; i < line; i++) {
+			int j = 0;
+			int init_reg = reg_addr;
+			char read_times = 4;
+
+			if ((i == (line - 1)) && (len % 16))
+				read_times = (len % 16) / 4;
+			memset(pk, 0, 16);
+
+			for (j = 0; j < read_times; j++) {
+				ret = sprdwcn_bus_reg_read(reg_addr, &reg_val,
+							   4);
+				if (ret < 0) {
+					sdiohal_err("%s read 0x%x error:%d\n",
+					    __func__, reg_addr, ret);
+					break;
+				}
+				pk[j * 4] = reg_val & 0xFF;
+				pk[j * 4 + 1] = (reg_val >> 8) & 0xFF;
+				pk[j * 4 + 2] = (reg_val >> 16) & 0xFF;
+				pk[j * 4 + 3] = (reg_val >> 24) & 0xFF;
+				reg_addr += 4;
+			}
+
+			sprintf(addr, "0x%08x:", init_reg);
+			print_hex_dump(KERN_ERR, addr, DUMP_PREFIX_NONE, 16, 1,
+				pk, read_times * 4, true);
+		}
+		return count;
+	}
+
+	/* write cp2 register by direct mode: "writereg 0x40844220 0x0" */
+	if (strncmp(cmd_buf + PUB_HEAD_RSV, "writereg 0x", 11) == 0) {
+		long int reg_addr_read, reg_val_read;
+		unsigned int reg_addr, reg_val;
+
+		cmd_buf[SDIOHAL_WRITE_SIZE + PUB_HEAD_RSV - 1] = 0;
+		cmd_buf[PUB_HEAD_RSV + sizeof("writereg 0x00000000") - 1] = 0;
+		ret = kstrtol(&cmd_buf[PUB_HEAD_RSV + sizeof("writereg 0x") -
+			      1], 16, &reg_addr_read);
+		reg_addr = reg_addr_read & 0xFFFFFFFF;
+		ret = kstrtol(&cmd_buf[PUB_HEAD_RSV +
+			      sizeof("writereg 0x00000000 0x") - 1], 16,
+			      &reg_val_read);
+		reg_val = reg_val_read & 0xFFFFFFFF;
+		ret = sprdwcn_bus_reg_write(reg_addr, &reg_val, 4);
+		if (ret < 0)
+			sdiohal_err("%s write 0x%x error:%d\n",
+				    __func__, reg_addr, ret);
+		sdiohal_info("%s write reg_addr 0x%x=0x%x\n",
+			     __func__, reg_addr, reg_val);
+		return count;
+	}
+
+#ifdef SDIO_RESET_DEBUG
+	if (strncmp(cmd_buf + PUB_HEAD_RSV, "reset", 5) == 0) {
+		if ((strncmp(cmd_buf + PUB_HEAD_RSV, "reset_disable_apb",
+			17) == 0))
+			sdiohal_disable_apb_reset();
+		else if (strncmp(cmd_buf + PUB_HEAD_RSV, "reset_full", 10) == 0)
+			sdiohal_reset(1);
+		else
+			sdiohal_reset(0);
+		return count;
+	}
+#endif
+
+	if (strncmp(cmd_buf + PUB_HEAD_RSV, "rst_test", 8) == 0) {
+		marlin_reset_reg();
+		return count;
+	}
+
+	/* change sdio rx irq to polling */
+	if (strncmp(cmd_buf + PUB_HEAD_RSV, "switch_irq", 10) == 0) {
+		p_data->irq_type = SDIOHAL_RX_POLLING;
+		sdiohal_info("%s switch irq to [%d][rx polling]\n",
+			     __func__, p_data->irq_type);
+		sdiohal_rx_up();
+
+		return count;
+	}
+
+	if (strncmp(cmd_buf + PUB_HEAD_RSV, "dump_128bit", 11) == 0) {
+		sdiohal_dump_aon_reg();
+		return count;
+	}
+	if (strncmp(cmd_buf + PUB_HEAD_RSV, "tx_multi_task", 13) == 0) {
+		sdiohal_tx_test_init();
+		return count;
+	}
+
+	if (strncmp(cmd_buf + PUB_HEAD_RSV, "rx_multi_task", 13) == 0) {
+		sdiohal_rx_test_init();
+		return count;
+	}
+
+	if (strncmp(cmd_buf + PUB_HEAD_RSV, "log_level=", 10) == 0) {
+		cmd_buf[SDIOHAL_WRITE_SIZE + PUB_HEAD_RSV - 1] = 0;
+		ret = kstrtol(&cmd_buf[PUB_HEAD_RSV + sizeof("log_level=") - 1],
+			10, &sdiohal_log_level);
+		sdiohal_info("%s sdiohal_log_level:%ld\n",
+			__func__, sdiohal_log_level);
+		return count;
+	}
+
+	if (strncmp(cmd_buf + PUB_HEAD_RSV, "printlog_chn=",
+		strlen("printlog_chn=")) == 0) {
+		cmd_buf[SDIOHAL_WRITE_SIZE + PUB_HEAD_RSV - 1] = 0;
+		ret = kstrtol(
+			&cmd_buf[PUB_HEAD_RSV + sizeof("printlog_chn=") - 1],
+			10, &long_data);
+		num = (int)long_data;
+		if (num < SDIO_CHN_TX_NUM) {
+			p_data->printlog_txchn = num;
+			sdiohal_info("%s printlog_txchn:%d\n", __func__,
+				     p_data->printlog_txchn);
+		} else if (num < SDIO_CHANNEL_NUM) {
+			p_data->printlog_rxchn = num;
+			sdiohal_info("%s printlog_rxchn:%d\n", __func__,
+				     p_data->printlog_rxchn);
+		} else {
+			p_data->printlog_txchn = SDIO_CHANNEL_NUM;
+			p_data->printlog_rxchn = SDIO_CHANNEL_NUM;
+			sdiohal_info("%s para invalid, close log\n", __func__);
+		}
+
+		return count;
+	}
+
+	if (strncmp(cmd_buf + PUB_HEAD_RSV, "printlog_txchn=",
+		strlen("printlog_txchn=")) == 0) {
+		cmd_buf[SDIOHAL_WRITE_SIZE + PUB_HEAD_RSV - 1] = 0;
+		ret = kstrtol(
+			&cmd_buf[PUB_HEAD_RSV + sizeof("printlog_txchn=") - 1],
+			10, &long_data);
+		p_data->printlog_txchn = (int)long_data;
+		sdiohal_info("%s printlog_txchn:%d\n", __func__,
+			     p_data->printlog_txchn);
+
+		return count;
+	}
+
+	if (strncmp(cmd_buf + PUB_HEAD_RSV, "printlog_rxchn=",
+		strlen("printlog_rxchn=")) == 0) {
+		cmd_buf[SDIOHAL_WRITE_SIZE + PUB_HEAD_RSV - 1] = 0;
+		ret = kstrtol(
+			&cmd_buf[PUB_HEAD_RSV + sizeof("printlog_rxchn=") - 1],
+			10, &long_data);
+		p_data->printlog_rxchn = (int)long_data;
+		sdiohal_info("%s printlog_rxchn:%d\n", __func__,
+			     p_data->printlog_rxchn);
+
+		return count;
+	}
+
+	if (strncmp(cmd_buf + PUB_HEAD_RSV, "sdio_int", 8) == 0) {
+		unsigned long int int_bitmap;
+		unsigned int addr;
+
+		if (strncmp(cmd_buf + PUB_HEAD_RSV, "sdio_int_rx", 11) == 0)
+			sdiohal_test_int_init(SDIOHAL_INT_PWR_FUNC);
+		else if (strncmp(cmd_buf + PUB_HEAD_RSV,
+				"sdio_int_tx", 11) == 0) {
+			cmd_buf[SDIOHAL_WRITE_SIZE + PUB_HEAD_RSV - 1] = 0;
+			ret = kstrtol(&cmd_buf[PUB_HEAD_RSV +
+				sizeof("sdio_int_tx=") - 1], 10, &int_bitmap);
+
+			sdiohal_info("%s int_bitmap:%ld\n",
+				__func__, int_bitmap);
+
+			if (int_bitmap & 0xff)
+				addr = REG_TO_CP0_REQ0;
+			sprdwcn_bus_aon_writeb(addr, int_bitmap & 0xff);
+
+			if (int_bitmap & 0xff00)
+				addr = REG_TO_CP0_REQ1;
+			sprdwcn_bus_aon_writeb(addr, int_bitmap >> 8);
+		}
+
+		return count;
+	}
+
+	if (strncmp(cmd_buf + PUB_HEAD_RSV, "at_init tx chn=", 15) == 0) {
+		cmd_buf[SDIOHAL_WRITE_SIZE + PUB_HEAD_RSV - 1] = 0;
+		ret = kstrtol(&cmd_buf[PUB_HEAD_RSV +
+			sizeof("at_init tx chn=") - 1], 10, &long_data);
+		sdiohal_info("%s tx channel:%ld\n", __func__, long_data);
+		at_tx_ops.channel = long_data;
+		sprdwcn_bus_chn_init(&at_tx_ops);
+		return count;
+	}
+
+	if (strncmp(cmd_buf + PUB_HEAD_RSV, "at_init rx chn=", 15) == 0) {
+		cmd_buf[SDIOHAL_WRITE_SIZE + PUB_HEAD_RSV - 1] = 0;
+		ret = kstrtol(&cmd_buf[PUB_HEAD_RSV +
+			sizeof("at_init rx chn=") - 1], 10, &long_data);
+		sdiohal_info("%s rx channel:%ld\n", __func__, long_data);
+		at_rx_ops.channel = long_data;
+		sprdwcn_bus_chn_init(&at_rx_ops);
+		return count;
+	}
+
+	if (strncmp(cmd_buf + PUB_HEAD_RSV, "at_deinit", 8) == 0) {
+		sprdwcn_bus_chn_deinit(&at_tx_ops);
+		sprdwcn_bus_chn_deinit(&at_rx_ops);
+		return count;
+	}
+
+	/* below is used for gnss data capture function, irq TBD */
+	if (strncmp(cmd_buf + PUB_HEAD_RSV, "gnss_data_cap", 13) == 0) {
+		sdiohal_test_int_init(SDIOHAL_GNSS_DUMP_FUNC);
+		return count;
+	}
+
+	/* change sdio mode */
+	if (strncmp(cmd_buf + PUB_HEAD_RSV, "sdr104", 6) == 0) {
+		sdiohal_change_to_sdr104();
+		return count;
+	}
+
+	/* sdio throughput test */
+	if (strstr((cmd_buf + PUB_HEAD_RSV), "tp")) {
+		sdiohal_find_num(cmd_buf + PUB_HEAD_RSV,
+			&tp_tx_buf_cnt, &tp_tx_buf_len);
+		sdiohal_info("%s buf_cnt=%d buf_len=%d\n",
+			__func__, tp_tx_buf_cnt, tp_tx_buf_len);
+		tp_tx_flag = 1;
+		tp_tx_cnt = 0;
+		tp_tx_start_time = ktime_get_ns();
+		if ((tp_tx_buf_cnt <= TP_TX_BUF_CNT) &&
+			(tp_tx_buf_len <= TP_TX_BUF_LEN)) {
+			sprdwcn_bus_chn_deinit(&at_tx_ops);
+			at_tx_ops.pool_size = TP_TX_POOL_SIZE;
+			sprdwcn_bus_chn_init(&at_tx_ops);
+#if TCP_TEST_RX
+			sdiohal_launch_tp_tx_thread();
+#endif
+			if (!sdiohal_throughput_tx_alloc()) {
+				sdiohal_log_level = 0;
+				sdiohal_throughput_tx();
+			} else {
+				sdiohal_err("%s kzalloc send buf fail\n",
+					    __func__);
+				return -ENOMEM;
+			}
+		} else
+			sdiohal_info("%s buf_cnt or buf_len false!!\n",
+			__func__);
+		return count;
+	} else if (strstr((cmd_buf + PUB_HEAD_RSV), "tp_test_rx")) {
+		sdiohal_throughput_rx();
+		return count;
+	}
+
+	if (!sprdwcn_bus_list_alloc(at_tx_ops.channel, &head, &tail, &num)) {
+		mbuf_node = head;
+		for (i = 0; i < num; i++) {
+			send_buf = kzalloc(count + PUB_HEAD_RSV, GFP_KERNEL);
+			if (!send_buf) {
+				sdiohal_err("%s kzalloc send buf fail\n",
+					    __func__);
+				return -ENOMEM;
+			}
+			memcpy(send_buf, cmd_buf, count + PUB_HEAD_RSV);
+			mbuf_node->buf = send_buf;
+			mbuf_node->len = count;
+			if ((i+1) < num)
+				mbuf_node = mbuf_node->next;
+			else
+				mbuf_node->next = NULL;
+		}
+
+		sprdwcn_bus_push_list(at_tx_ops.channel, head, tail, num);
+	}
+
+	return count;
+}
+
+static int at_cmd_release(struct inode *inode, struct file *filp)
+{
+	return 0;
+}
+
+static const struct file_operations at_cmd_fops = {
+	.open = at_cmd_open,
+	.read = at_cmd_read,
+	.write = at_cmd_write,
+	.release = at_cmd_release,
+};
+
+static int debug_help_open(struct inode *inode, struct file *filp)
+{
+	return 0;
+}
+
+static ssize_t debug_help_read(struct file *filp,
+	char __user *user_buf, size_t count, loff_t *pos)
+{
+	return count;
+}
+
+static int debug_help_release(struct inode *inode, struct file *filp)
+{
+	return 0;
+}
+
+static const struct file_operations debug_help = {
+	.open = debug_help_open,
+	.read = debug_help_read,
+	.release = debug_help_release,
+};
+
+struct entry_file {
+	const char *name;
+	const struct file_operations *file_ops;
+};
+
+static struct entry_file entry_table[] = {
+	{
+		.name = "help",
+		.file_ops = &debug_help,
+	},
+	{
+		.name = "at_cmd",
+		.file_ops = &at_cmd_fops,
+	},
+};
+
+static struct dentry *debug_root;
+void sdiohal_debug_init(void)
+{
+	int i;
+
+	/* create debugfs */
+	debug_root = debugfs_create_dir("sdiohal_debug", NULL);
+	for (i = 0; i < ARRAY_SIZE(entry_table); i++) {
+		if (!debugfs_create_file(entry_table[i].name, 0444,
+					 debug_root, NULL,
+					 entry_table[i].file_ops)) {
+			sdiohal_err("%s debugfs_create_file[%d] fail!!\n",
+				    __func__, i);
+			debugfs_remove_recursive(debug_root);
+			return;
+		}
+	}
+
+	at_cmd_init();
+}
+
+void sdiohal_debug_deinit(void)
+{
+	debugfs_remove_recursive(debug_root);
+	at_cmd_deinit();
+}
+
diff --git a/drivers/net/wireless/uwe5622/unisocwcn/sdio/sdiohal_main.c b/drivers/net/wireless/uwe5622/unisocwcn/sdio/sdiohal_main.c
new file mode 100644
index 000000000000..7d664f1b1018
--- /dev/null
+++ b/drivers/net/wireless/uwe5622/unisocwcn/sdio/sdiohal_main.c
@@ -0,0 +1,2069 @@
+/*
+ * Copyright (C) 2017 Spreadtrum Communications Inc.
+ *
+ * Filename : sdiohal.c
+ * Abstract : This file is a implementation for wcn sdio hal function
+ *
+ * Authors	:
+ *
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include <linux/interrupt.h>
+#include <linux/irq.h>
+#include <linux/kthread.h>
+#include <linux/module.h>
+#include <linux/of_device.h>
+#include <linux/of_gpio.h>
+#include <linux/pm_runtime.h>
+#include <linux/mmc/card.h>
+#include <linux/mmc/core.h>
+#include <linux/mmc/host.h>
+#include <linux/mmc/sdio.h>
+#include <linux/mmc/sdio_func.h>
+
+#include "bus_common.h"
+#include "sdiohal.h"
+#include "wcn_glb.h"
+
+#ifndef MMC_CAP2_SDIO_IRQ_NOTHREAD
+#define MMC_CAP2_SDIO_IRQ_NOTHREAD (1 << 17)
+#endif
+
+#define CP_GPIO1_REG 0x40840014
+#define CP_PIN_FUNC_WPU BIT(8)
+
+#define CP_GPIO1_DATA_BASE 0x40804000
+#define CP_GPIO1_BIT BIT(1)
+
+#ifndef IS_BYPASS_WAKE
+#define IS_BYPASS_WAKE(addr) (false)
+#endif
+
+struct sdiohal_data_t *sdiohal_data;
+static struct sdio_driver sdiohal_driver;
+static struct mmc_host *host;
+
+static int sdiohal_card_lock(struct sdiohal_data_t *p_data,
+	const char *func)
+{
+	if ((atomic_inc_return(&p_data->xmit_cnt) >=
+		SDIOHAL_REMOVE_CARD_VAL) ||
+		!atomic_read(&p_data->xmit_start)) {
+		atomic_dec(&p_data->xmit_cnt);
+		sdiohal_err("%s xmit_cnt:%d xmit_start:%d,not have card\n",
+			    func, atomic_read(&p_data->xmit_cnt),
+			    atomic_read(&p_data->xmit_start));
+		return -1;
+	}
+
+	return 0;
+}
+
+static void sdiohal_card_unlock(struct sdiohal_data_t *p_data)
+{
+	atomic_dec(&p_data->xmit_cnt);
+}
+
+struct sdiohal_data_t *sdiohal_get_data(void)
+{
+	return sdiohal_data;
+}
+
+unsigned char sdiohal_get_tx_mode(void)
+{
+	struct sdiohal_data_t *p_data = sdiohal_get_data();
+
+	return ((p_data->adma_tx_enable == true) ?
+		SDIOHAL_ADMA : SDIOHAL_SDMA);
+}
+
+unsigned char sdiohal_get_rx_mode(void)
+{
+	struct sdiohal_data_t *p_data = sdiohal_get_data();
+
+	return ((p_data->adma_rx_enable == true) ?
+		SDIOHAL_ADMA : SDIOHAL_SDMA);
+}
+
+unsigned char sdiohal_get_irq_type(void)
+{
+	struct sdiohal_data_t *p_data = sdiohal_get_data();
+
+	return p_data->irq_type;
+}
+
+unsigned int sdiohal_get_blk_size(void)
+{
+	struct sdiohal_data_t *p_data = sdiohal_get_data();
+
+	return p_data->blk_size ? 512 : 840;
+}
+
+void sdiohal_sdio_tx_status(void)
+{
+	struct sdiohal_data_t *p_data = sdiohal_get_data();
+	unsigned char stbba0, stbba1, stbba2, stbba3;
+	unsigned char apbrw0, apbrw1, apbrw2, apbrw3;
+	unsigned char pubint_raw4;
+	int err;
+
+	sdiohal_resume_check();
+	sdiohal_op_enter();
+	sdio_claim_host(p_data->sdio_func[FUNC_0]);
+	stbba0 = sdio_readb(p_data->sdio_func[FUNC_0],
+			    SDIOHAL_FBR_STBBA0, &err);
+	stbba1 = sdio_readb(p_data->sdio_func[FUNC_0],
+			    SDIOHAL_FBR_STBBA1, &err);
+	stbba2 = sdio_readb(p_data->sdio_func[FUNC_0],
+			    SDIOHAL_FBR_STBBA2, &err);
+	stbba3 = sdio_readb(p_data->sdio_func[FUNC_0],
+			    SDIOHAL_FBR_STBBA3, &err);
+	pubint_raw4 = sdio_readb(p_data->sdio_func[FUNC_0],
+				 SDIOHAL_FBR_PUBINT_RAW4, &err);
+	apbrw0 = sdio_readb(p_data->sdio_func[FUNC_0],
+			    SDIOHAL_FBR_APBRW0, &err);
+	apbrw1 = sdio_readb(p_data->sdio_func[FUNC_0],
+			    SDIOHAL_FBR_APBRW1, &err);
+	apbrw2 = sdio_readb(p_data->sdio_func[FUNC_0],
+			    SDIOHAL_FBR_APBRW2, &err);
+	apbrw3 = sdio_readb(p_data->sdio_func[FUNC_0],
+			    SDIOHAL_FBR_APBRW3, &err);
+	sdio_release_host(p_data->sdio_func[FUNC_0]);
+	sdiohal_op_leave();
+
+	sdiohal_info("byte:[0x%x][0x%x][0x%x][0x%x];[0x%x]\n",
+		stbba0, stbba1, stbba2, stbba3, pubint_raw4);
+	sdiohal_info("byte:[0x%x][0x%x][0x%x][0x%x]\n",
+		apbrw0, apbrw1, apbrw2, apbrw3);
+}
+
+static void sdiohal_abort(void)
+{
+	struct sdiohal_data_t *p_data = sdiohal_get_data();
+	int err;
+	unsigned char val;
+
+	sdiohal_info("sdiohal_abort\n");
+
+#ifdef CONFIG_ARCH_SUNXI
+	sprdwcn_bus_set_carddump_status(true);
+	return;
+#endif
+
+	sdio_claim_host(p_data->sdio_func[FUNC_0]);
+
+	val = sdio_readb(p_data->sdio_func[FUNC_0], 0x0, &err);
+	sdiohal_info("before abort, SDIO_VER_CCCR:0x%x\n", val);
+
+	sdio_writeb(p_data->sdio_func[FUNC_0], VAL_ABORT_TRANS,
+		SDIOHAL_CCCR_ABORT, &err);
+
+	val = sdio_readb(p_data->sdio_func[FUNC_0], 0x0, &err);
+	sdiohal_info("after abort, SDIO_VER_CCCR:0x%x\n", val);
+
+	sdio_release_host(p_data->sdio_func[FUNC_0]);
+}
+
+/* Get Success Transfer pac num Before Abort */
+static void sdiohal_success_trans_pac_num(void)
+{
+	struct sdiohal_data_t *p_data = sdiohal_get_data();
+	unsigned char stbba0;
+	unsigned char stbba1;
+	unsigned char stbba2;
+	unsigned char stbba3;
+	int err;
+
+	sdio_claim_host(p_data->sdio_func[FUNC_0]);
+	stbba0 = sdio_readb(p_data->sdio_func[FUNC_0],
+			    SDIOHAL_FBR_STBBA0, &err);
+	stbba1 = sdio_readb(p_data->sdio_func[FUNC_0],
+			    SDIOHAL_FBR_STBBA1, &err);
+	stbba2 = sdio_readb(p_data->sdio_func[FUNC_0],
+			    SDIOHAL_FBR_STBBA2, &err);
+	stbba3 = sdio_readb(p_data->sdio_func[FUNC_0],
+			    SDIOHAL_FBR_STBBA3, &err);
+	p_data->success_pac_num = stbba0 | (stbba1 << 8) |
+	    (stbba2 << 16) | (stbba3 << 24);
+	sdio_release_host(p_data->sdio_func[FUNC_0]);
+
+	sdiohal_info("success num:[%d]\n",
+		p_data->success_pac_num);
+}
+
+unsigned int sdiohal_get_trans_pac_num(void)
+{
+	struct sdiohal_data_t *p_data = sdiohal_get_data();
+
+	return p_data->success_pac_num;
+}
+
+int sdiohal_sdio_pt_write(unsigned char *src, unsigned int datalen)
+{
+	struct sdiohal_data_t *p_data = sdiohal_get_data();
+	int ret = 0;
+	struct timespec64 tm_begin, tm_end;
+	static long time_total_ns;
+	static int times_count;
+
+	ktime_get_real_ts64(&tm_begin);
+	if (unlikely(p_data->card_dump_flag == true)) {
+		sdiohal_err("%s line %d dump happened\n", __func__, __LINE__);
+		return -ENODEV;
+	}
+
+	if (datalen % 4 != 0) {
+		sdiohal_err("%s datalen not aligned to 4 byte\n", __func__);
+		return -1;
+	}
+
+	if (sdiohal_card_lock(p_data, __func__))
+		return -1;
+
+	sdiohal_resume_check();
+	sdiohal_op_enter();
+	sdio_claim_host(p_data->sdio_func[FUNC_1]);
+	ret = sdio_writesb(p_data->sdio_func[FUNC_1],
+		SDIOHAL_PK_MODE_ADDR, src, datalen);
+	sdio_release_host(p_data->sdio_func[FUNC_1]);
+	if (ret != 0) {
+		sdiohal_success_trans_pac_num();
+		sdiohal_abort();
+	}
+	sdiohal_op_leave();
+	sdiohal_card_unlock(p_data);
+
+	ktime_get_real_ts64(&tm_end);
+	time_total_ns += timespec64_to_ns(&tm_end) - timespec64_to_ns(&tm_begin);
+	times_count++;
+	if (!(times_count % PERFORMANCE_COUNT)) {
+		sdiohal_pr_perf("tx avg time:%ld len=%d\n",
+			(time_total_ns / PERFORMANCE_COUNT), datalen);
+		time_total_ns = 0;
+		times_count = 0;
+	}
+
+	return ret;
+}
+
+int sdiohal_sdio_pt_read(unsigned char *src, unsigned int datalen)
+{
+	struct sdiohal_data_t *p_data = sdiohal_get_data();
+	int ret = 0;
+	struct timespec64 tm_begin, tm_end;
+	static long time_total_ns;
+	static int times_count;
+
+	ktime_get_real_ts64(&tm_begin);
+
+	if (unlikely(p_data->card_dump_flag == true)) {
+		sdiohal_err("%s line %d dump happened\n", __func__, __LINE__);
+		return -ENODEV;
+	}
+
+	if (sdiohal_card_lock(p_data, __func__))
+		return -1;
+
+	sdiohal_resume_check();
+	sdiohal_op_enter();
+	sdio_claim_host(p_data->sdio_func[FUNC_1]);
+	ret = sdio_readsb(p_data->sdio_func[FUNC_1], src,
+		SDIOHAL_PK_MODE_ADDR, datalen);
+	sdio_release_host(p_data->sdio_func[FUNC_1]);
+	if (ret != 0)
+		sdiohal_abort();
+	sdiohal_op_leave();
+	sdiohal_card_unlock(p_data);
+
+	ktime_get_real_ts64(&tm_end);
+	time_total_ns += timespec64_to_ns(&tm_end) - timespec64_to_ns(&tm_begin);
+	times_count++;
+	if (!(times_count % PERFORMANCE_COUNT)) {
+		sdiohal_pr_perf("rx avg time:%ld len=%d\n",
+			(time_total_ns / PERFORMANCE_COUNT), datalen);
+		time_total_ns = 0;
+		times_count = 0;
+	}
+
+	return ret;
+}
+
+static int sdiohal_config_packer_chain(struct sdiohal_list_t *data_list,
+	struct sdio_func *sdio_func, uint fix_inc, bool dir, uint addr)
+{
+	struct sdiohal_data_t *p_data = sdiohal_get_data();
+	struct mmc_request mmc_req;
+	struct mmc_command mmc_cmd;
+	struct mmc_data mmc_dat;
+	struct mmc_host *host = sdio_func->card->host;
+	bool fifo = (fix_inc == SDIOHAL_DATA_FIX);
+	uint fn_num = sdio_func->num;
+	uint blk_num, blk_size, max_blk_count, max_req_size;
+	struct mbuf_t *mbuf_node;
+	unsigned int sg_count, sg_data_size;
+	unsigned int i, ttl_len = 0, node_num;
+	int err_ret = 0;
+
+	node_num = data_list->node_num;
+	if (node_num > MAX_CHAIN_NODE_NUM)
+		node_num = MAX_CHAIN_NODE_NUM;
+
+	sdiohal_list_check(data_list, __func__, dir);
+
+	blk_size = SDIOHAL_BLK_SIZE;
+	max_blk_count = min_t(unsigned int,
+			      host->max_blk_count, (uint)MAX_IO_RW_BLK);
+	max_req_size = min_t(unsigned int,
+			     max_blk_count * blk_size, host->max_req_size);
+
+	sg_count = 0;
+	memset(&mmc_req, 0, sizeof(struct mmc_request));
+	memset(&mmc_cmd, 0, sizeof(struct mmc_command));
+	memset(&mmc_dat, 0, sizeof(struct mmc_data));
+	sg_init_table(p_data->sg_list, ARRAY_SIZE(p_data->sg_list));
+
+	mbuf_node = data_list->mbuf_head;
+	for (i = 0; i < node_num; i++, mbuf_node = mbuf_node->next) {
+		if (!mbuf_node) {
+			sdiohal_err("%s tx config adma, mbuf ptr error:%p\n",
+				__func__, mbuf_node);
+			return -1;
+		}
+
+		if (sg_count >= ARRAY_SIZE(p_data->sg_list)) {
+			sdiohal_err("%s:sg list exceed limit\n", __func__);
+			return -1;
+		}
+
+		if (dir)
+			sg_data_size = SDIOHAL_ALIGN_4BYTE(mbuf_node->len +
+				sizeof(struct sdio_puh_t));
+		else
+			sg_data_size = MAX_PAC_SIZE;
+		if (sg_data_size > MAX_PAC_SIZE) {
+			sdiohal_err("pac size > cp buf size,len %d\n",
+				sg_data_size);
+			return -1;
+		}
+
+		if (sg_data_size > host->max_seg_size)
+			sg_data_size = host->max_seg_size;
+
+		sg_set_buf(&p_data->sg_list[sg_count++], mbuf_node->buf,
+			sg_data_size);
+		ttl_len += sg_data_size;
+	}
+
+	if (dir) {
+		sg_data_size = SDIOHAL_ALIGN_BLK(ttl_len +
+			SDIO_PUB_HEADER_SIZE) - ttl_len;
+		if (sg_data_size > MAX_PAC_SIZE) {
+			sdiohal_err("eof pac size > cp buf size,len %d\n",
+				sg_data_size);
+			return -1;
+		}
+		sg_set_buf(&p_data->sg_list[sg_count++],
+			p_data->eof_buf, sg_data_size);
+		ttl_len = SDIOHAL_ALIGN_BLK(ttl_len
+			+ SDIO_PUB_HEADER_SIZE);
+	} else {
+		sg_data_size = SDIOHAL_DTBS_BUF_SIZE;
+		sg_set_buf(&p_data->sg_list[sg_count++],
+			p_data->dtbs_buf, sg_data_size);
+		ttl_len += sg_data_size;
+	}
+
+	if (ttl_len % blk_size != 0) {
+		sdiohal_err("ttl_len %d not aligned to blk size\n", ttl_len);
+		return -1;
+	}
+
+	sdiohal_debug("ttl len:%d sg_count:%d\n", ttl_len, sg_count);
+
+	blk_num = ttl_len / blk_size;
+	mmc_dat.sg = p_data->sg_list;
+	mmc_dat.sg_len = sg_count;
+	mmc_dat.blksz = blk_size;
+	mmc_dat.blocks = blk_num;
+	mmc_dat.flags = dir ? MMC_DATA_WRITE : MMC_DATA_READ;
+	mmc_cmd.opcode = 53; /* SD_IO_RW_EXTENDED */
+	mmc_cmd.arg = dir ? 1<<31 : 0;
+	mmc_cmd.arg |= (fn_num & 0x7) << 28;
+	mmc_cmd.arg |= 1<<27;
+	mmc_cmd.arg |= fifo ? 0 : 1<<26;
+	mmc_cmd.arg |= (addr & 0x1FFFF) << 9;
+	mmc_cmd.arg |= blk_num & 0x1FF;
+	mmc_cmd.flags = MMC_RSP_SPI_R5 | MMC_RSP_R5 | MMC_CMD_ADTC;
+	mmc_req.cmd = &mmc_cmd;
+	mmc_req.data = &mmc_dat;
+	if (!fifo)
+		addr += ttl_len;
+
+	sdio_claim_host(sdio_func);
+	mmc_set_data_timeout(&mmc_dat, sdio_func->card);
+	mmc_wait_for_req(host, &mmc_req);
+	sdio_release_host(sdio_func);
+
+	err_ret = mmc_cmd.error ? mmc_cmd.error : mmc_dat.error;
+	if (err_ret != 0) {
+		sdiohal_err("%s:CMD53 %s failed with code %d\n",
+			__func__, dir ? "write" : "read", err_ret);
+		print_hex_dump(KERN_WARNING, "sdio packer: ",
+			       DUMP_PREFIX_NONE, 16, 1,
+			       data_list->mbuf_head->buf,
+			       SDIOHAL_PRINTF_LEN, true);
+		return -1;
+	}
+
+	return 0;
+}
+
+int sdiohal_adma_pt_write(struct sdiohal_list_t *data_list)
+{
+	struct sdiohal_data_t *p_data = sdiohal_get_data();
+	int ret = 0;
+	struct timespec64 tm_begin, tm_end;
+	static long time_total_ns;
+	static int times_count;
+
+	ktime_get_real_ts64(&tm_begin);
+
+	if (unlikely(p_data->card_dump_flag == true)) {
+		sdiohal_err("%s line %d dump happened\n", __func__, __LINE__);
+		return -ENODEV;
+	}
+
+	if (sdiohal_card_lock(p_data, __func__))
+		return -1;
+
+	sdiohal_resume_check();
+	sdiohal_op_enter();
+	ret = sdiohal_config_packer_chain(data_list,
+					  p_data->sdio_func[FUNC_1],
+					  SDIOHAL_DATA_FIX, SDIOHAL_WRITE,
+					  SDIOHAL_PK_MODE_ADDR);
+	if (ret != 0) {
+		sdiohal_success_trans_pac_num();
+		sdiohal_abort();
+	}
+	sdiohal_op_leave();
+	sdiohal_card_unlock(p_data);
+
+	ktime_get_real_ts64(&tm_end);
+	time_total_ns += timespec64_to_ns(&tm_end) - timespec64_to_ns(&tm_begin);
+	times_count++;
+	if (!(times_count % PERFORMANCE_COUNT)) {
+		sdiohal_pr_perf("tx avg time:%ld\n",
+			(time_total_ns / PERFORMANCE_COUNT));
+		time_total_ns = 0;
+		times_count = 0;
+	}
+
+	return ret;
+}
+
+int sdiohal_adma_pt_read(struct sdiohal_list_t *data_list)
+{
+	struct sdiohal_data_t *p_data = sdiohal_get_data();
+	int ret = 0;
+	struct timespec64 tm_begin, tm_end;
+	static long time_total_ns;
+	static int times_count;
+
+	ktime_get_real_ts64(&tm_begin);
+
+	if (unlikely(p_data->card_dump_flag == true)) {
+		sdiohal_err("%s line %d dump happened\n", __func__, __LINE__);
+		return -ENODEV;
+	}
+
+	if (sdiohal_card_lock(p_data, __func__))
+		return -1;
+
+	sdiohal_resume_check();
+	sdiohal_op_enter();
+	ret = sdiohal_config_packer_chain(data_list,
+					  p_data->sdio_func[FUNC_1],
+					  SDIOHAL_DATA_FIX, SDIOHAL_READ,
+					  SDIOHAL_PK_MODE_ADDR);
+	if (ret != 0)
+		sdiohal_abort();
+	sdiohal_op_leave();
+	sdiohal_card_unlock(p_data);
+
+	ktime_get_real_ts64(&tm_end);
+	time_total_ns += timespec64_to_ns(&tm_end) - timespec64_to_ns(&tm_begin);
+	times_count++;
+	if (!(times_count % PERFORMANCE_COUNT)) {
+		sdiohal_pr_perf("rx avg time:%ld\n",
+			(time_total_ns / PERFORMANCE_COUNT));
+		time_total_ns = 0;
+		times_count = 0;
+	}
+
+	return ret;
+}
+
+static int sdiohal_dt_set_addr(unsigned int addr)
+{
+	struct sdiohal_data_t *p_data = sdiohal_get_data();
+	unsigned char address[4];
+	int err = 0;
+	int i;
+
+	for (i = 0; i < 4; i++)
+		address[i] = (addr >> (8 * i)) & 0xFF;
+
+	sdio_claim_host(p_data->sdio_func[FUNC_0]);
+	sdio_writeb(p_data->sdio_func[FUNC_0], address[0],
+		    SDIOHAL_FBR_SYSADDR0, &err);
+	if (err != 0)
+		goto exit;
+
+	sdio_writeb(p_data->sdio_func[FUNC_0], address[1],
+		    SDIOHAL_FBR_SYSADDR1, &err);
+	if (err != 0)
+		goto exit;
+
+	sdio_writeb(p_data->sdio_func[FUNC_0], address[2],
+		    SDIOHAL_FBR_SYSADDR2, &err);
+	if (err != 0)
+		goto exit;
+
+	sdio_writeb(p_data->sdio_func[FUNC_0], address[3],
+		    SDIOHAL_FBR_SYSADDR3, &err);
+	if (err != 0)
+		goto exit;
+
+exit:
+	sdio_release_host(p_data->sdio_func[FUNC_0]);
+
+	return err;
+}
+
+struct debug_bus_t {
+	char name[32];
+	/*
+	 * 0:[23:0]
+	 * 1:[15:8],[7:0],[23:16]
+	 * 2:[7:0],[23:16],[15:8]
+	 * 3:[23:0]
+	 */
+	int mode;
+	int sys;
+	int size;
+};
+
+struct debug_bus_t bus_config[] = {
+	//{"aon",			0x00, 0x0, 0x0d + 1}, /* 23 bit*/
+	//{"pcie_usb",	0x00, 0x1, 0x17 + 1}, /* 23 bit*/
+	{"wifi",		0x00, 0x2, 0x07 + 1}, /* 23 bit*/
+	{"btwyf",		0x00, 0x3, 0x23 + 1}, /* 23 bit*/
+	//{"ap",			0x00, 0x4, 0xac + 1}, /* 7 bit*/
+	{"bt",			0x00, 0x5, 0x0f + 1}, /* 23 bit*/
+	{"pmu",			0x00, 0x6, 0x33 + 1}, /* 16 bit*/
+	{"bushang",		0x00, 0x7, 0x0d + 1}, /* 23 bit*/
+	//{"aon_core",	0x00, 0x8, 0x0d}, /* 23 bit*/
+	//{"wifi_axi_mtx",0x00, 0x9, 0x00},
+
+};
+
+static void sdiohal_debug_en(bool enable)
+{
+	unsigned char reg_val = 0;
+
+	/* ctl en */
+	sdiohal_aon_readb(WCN_DEBUG_CTL_REG, &reg_val);
+	if (enable)
+		reg_val |= WCN_CTL_EN;
+	else
+		reg_val &= ~WCN_CTL_EN;
+	sdiohal_aon_writeb(WCN_DEBUG_CTL_REG, reg_val);
+}
+
+static void sdiohal_dump_sys_signal(int index, struct debug_bus_t *config)
+{
+	unsigned char reg_val = 0;
+	unsigned char *data_buf;
+	char prefix_str[64];
+	int sig_offset;
+
+	sdiohal_info("%s name:%s, mode:0x%x, sys:0x%x, size:0x%x\n",
+		     __func__, config[index].name,
+		     config[index].mode, config[index].sys,
+		     config[index].size);
+
+	sdiohal_aon_readb(WCN_DEBUG_MODE_SYS_REG, &reg_val);
+	/* sel bus mode */
+	reg_val &= ~WCN_MODE_MASK;
+	reg_val |= (config[index].mode << 4);
+
+	/* sel bus sys */
+	reg_val &= ~WCN_SYS_MASK;
+	reg_val |= config[index].sys;
+	sdiohal_aon_writeb(WCN_DEBUG_MODE_SYS_REG, reg_val);
+
+	data_buf = kzalloc(config[index].size * 4, GFP_KERNEL);
+	for (sig_offset = 0; sig_offset < config[index].size; sig_offset++) {
+		unsigned char *buf_p = &data_buf[sig_offset * 4];
+
+		sdiohal_aon_writeb(WCN_SEL_SIG_REG, sig_offset);
+		sdiohal_aon_readb(WCN_SIG_STATE + 0x0, &buf_p[0]);
+		sdiohal_aon_readb(WCN_SIG_STATE + 0x1, &buf_p[1]);
+		sdiohal_aon_readb(WCN_SIG_STATE + 0x2, &buf_p[2]);
+	}
+
+	sprintf(prefix_str, "%s: ", config[index].name);
+	print_hex_dump(KERN_WARNING, prefix_str,
+				   DUMP_PREFIX_OFFSET, 16, 4,
+				   data_buf, config[index].size * 4, false);
+}
+
+void sdiohal_dump_debug_bus(void)
+{
+	unsigned char index;
+	struct debug_bus_t *config = bus_config;
+	int arry_size = sizeof(bus_config) / sizeof(struct debug_bus_t);
+
+	sdiohal_info("%s entry\n", __func__);
+
+	sdiohal_debug_en(true);
+	for (index = 0; index < arry_size; index++)
+		sdiohal_dump_sys_signal(index, config);
+	sdiohal_debug_en(false);
+
+	sdiohal_info("%s end\n", __func__);
+}
+
+static char *sdiohal_haddr[8] = {
+	"cm4d",
+	"cm4i",
+	"cm4s",
+	"dmaw",
+	"dmar",
+	"aon_to_ahb",
+	"axi_to_ahb",
+	"hready_status",
+};
+
+void sdiohal_dump_aon_reg(void)
+{
+	unsigned char reg_buf[16];
+	unsigned char i, j, val = 0;
+
+	sdiohal_info("sdio dump_aon_reg entry\n");
+
+#ifndef CONFIG_CHECK_DRIVER_BY_CHIPID
+#ifdef CONFIG_UWE5623
+	sdiohal_dump_debug_bus();
+	return;
+#endif
+#else /*CONFIG_CHECK_DRIVER_BY_CHIPID*/
+	if (wcn_get_chip_model() == WCN_CHIP_MARLIN3E) {
+		sdiohal_dump_debug_bus();
+		return;
+	}
+#endif
+
+	for (i = 0; i <= CP_128BIT_SIZE; i++) {
+		sdiohal_aon_readb(CP_PMU_STATUS + i, &reg_buf[i]);
+		sdiohal_info("pmu sdio status:[0x%x]:0x%x\n",
+			     CP_PMU_STATUS + i, reg_buf[i]);
+	}
+
+	for (i = 0; i < 8; i++) {
+		sdiohal_aon_readb(CP_SWITCH_SGINAL, &val);
+		val &= ~BIT(4);
+		sdiohal_aon_writeb(CP_SWITCH_SGINAL, val);
+
+		/* bit3:0 bt wifi sys, 1:gnss sys */
+		val &= ~(BIT(0) | BIT(1) | BIT(2) | BIT(3));
+		val |= i;
+		sdiohal_aon_writeb(CP_SWITCH_SGINAL, val);
+
+		val |= BIT(4);
+		sdiohal_aon_writeb(CP_SWITCH_SGINAL, val);
+
+		for (j = 0; j < CP_HREADY_SIZE; j++) {
+			sdiohal_aon_readb(CP_BUS_HREADY + j, &reg_buf[j]);
+			sdiohal_info("%s haddr %d:[0x%x]:0x%x\n",
+				     sdiohal_haddr[i], i,
+				     CP_BUS_HREADY + j, reg_buf[j]);
+		}
+	}
+
+	/* check hready_status, if bt hung the bus, reset it.
+	 * BIT(2):bt2 hready out
+	 * BIT(3):bt2 hready
+	 * BIT(4):bt1 hready out
+	 * BIT(5):bt1 hready
+	 */
+	val = (reg_buf[0] & (BIT(2) | BIT(3) | BIT(4) | BIT(5)));
+	sdiohal_info("val:0x%x\n", val);
+	if ((val >> 2) != 0xf) {
+		sdiohal_aon_readb(CP_RESET_SLAVE, &val);
+		val |=  BIT(5) | BIT(6);
+		sdiohal_aon_writeb(CP_RESET_SLAVE, val);
+
+		for (i = 0; i < CP_HREADY_SIZE; i++) {
+			sdiohal_aon_readb(CP_BUS_HREADY + i, &reg_buf[i]);
+			sdiohal_info("after reset hready status:[0x%x]:0x%x\n",
+				     CP_BUS_HREADY + i, reg_buf[i]);
+		}
+	}
+
+	sdiohal_info("sdio dump_aon_reg end\n\n");
+}
+EXPORT_SYMBOL_GPL(sdiohal_dump_aon_reg);
+
+#if SDIO_DUMP_CHANNEL_DATA
+/* dump designated channel data when assert happened.
+ * wifi cmd header struct as defined below:
+ * struct sprdwl_cmd_hdr_t {
+ *	u8 common;
+ *	u8 cmd_id;
+ *	__le16 plen;
+ *	__le32 mstime;
+ *	s8 status;
+ *	u8 rsp_cnt;
+ *	u8 reserv[2];
+ *	u8 paydata[0];
+ * } __packed;
+ */
+static void sdiohal_dump_channel_data(int channel,
+	struct sdiohal_data_bak_t *chn_data, char *chn_str)
+{
+	char print_str[64];
+	unsigned int mstime;
+
+	mstime = chn_data->data_bk[SDIO_PUB_HEADER_SIZE + 4] +
+		 (chn_data->data_bk[SDIO_PUB_HEADER_SIZE + 5] << 8) +
+		 (chn_data->data_bk[SDIO_PUB_HEADER_SIZE + 6] << 16) +
+		 (chn_data->data_bk[SDIO_PUB_HEADER_SIZE + 7] << 24);
+	sdiohal_info("chn%d %s, cmdid=%d, mstime=%d, record_time=%d\n",
+		     channel, chn_str,
+		     chn_data->data_bk[SDIO_PUB_HEADER_SIZE + 1],
+		     mstime,
+		     chn_data->time);
+	sprintf(print_str, "chn%d %s: ", channel, chn_str);
+	print_hex_dump(KERN_WARNING, print_str, DUMP_PREFIX_NONE, 16,
+		       1, chn_data->data_bk,
+		       SDIOHAL_PRINTF_LEN, true);
+}
+#endif
+
+int sdiohal_writel(unsigned int system_addr, void *buf)
+{
+	struct sdiohal_data_t *p_data = sdiohal_get_data();
+	int ret = 0;
+
+	if (sdiohal_card_lock(p_data, __func__))
+		return -1;
+
+#ifdef CONFIG_ARCH_SUNXI
+	if (p_data->dt_rw_fail)
+		return -1;
+#endif
+
+	sdiohal_resume_check();
+	sdiohal_cp_tx_wakeup(DT_WRITEL);
+	sdiohal_op_enter();
+
+	ret = sdiohal_dt_set_addr(system_addr);
+	if (ret != 0) {
+		sdiohal_op_leave();
+		sdiohal_cp_tx_sleep(DT_WRITEL);
+		sdiohal_card_unlock(p_data);
+		return ret;
+	}
+
+	sdio_claim_host(p_data->sdio_func[FUNC_1]);
+	sdio_writel(p_data->sdio_func[FUNC_1],
+		*(unsigned int *)buf, SDIOHAL_DT_MODE_ADDR, &ret);
+
+	sdio_release_host(p_data->sdio_func[FUNC_1]);
+	sdiohal_op_leave();
+	sdiohal_cp_tx_sleep(DT_WRITEL);
+
+	if (ret != 0) {
+		sdiohal_err("dt writel fail ret:%d, system_addr=0x%x\n",
+			    ret, system_addr);
+		p_data->dt_rw_fail = 1;
+		sdiohal_dump_aon_reg();
+		sdiohal_abort();
+	}
+	sdiohal_card_unlock(p_data);
+
+	return ret;
+}
+
+int sdiohal_readl(unsigned int system_addr, void *buf)
+{
+	struct sdiohal_data_t *p_data = sdiohal_get_data();
+	int ret = 0;
+
+	if (sdiohal_card_lock(p_data, __func__))
+		return -1;
+
+#ifdef CONFIG_ARCH_SUNXI
+	if (p_data->dt_rw_fail)
+		return -1;
+#endif
+
+	sdiohal_resume_check();
+#ifdef CONFIG_CHECK_DRIVER_BY_CHIPID
+	/* If defined this macro, the driver will read chipid register firstly.
+	 * Because sleep and wakeup function need to know register address
+	 * by chipid. Because of getting slp_mgr.drv_slp_lock mutex lock,
+	 * this logic will cause deadlock.
+	 */
+	if ((!IS_BYPASS_WAKE(system_addr)) &&
+		(system_addr != CHIPID_REG_M3E) &&
+		(system_addr != CHIPID_REG_M3_M3L))
+#else
+	if (!IS_BYPASS_WAKE(system_addr))
+#endif
+		sdiohal_cp_rx_wakeup(DT_READL);
+	sdiohal_op_enter();
+	ret = sdiohal_dt_set_addr(system_addr);
+	if (ret != 0) {
+		sdiohal_op_leave();
+		sdiohal_cp_rx_sleep(DT_READL);
+		sdiohal_card_unlock(p_data);
+		return ret;
+	}
+
+	sdio_claim_host(p_data->sdio_func[FUNC_1]);
+
+	*(unsigned int *)buf = sdio_readl(p_data->sdio_func[FUNC_1],
+					  SDIOHAL_DT_MODE_ADDR, &ret);
+
+	sdio_release_host(p_data->sdio_func[FUNC_1]);
+	sdiohal_op_leave();
+#ifdef CONFIG_CHECK_DRIVER_BY_CHIPID
+	/* If defined this macro, the driver will read chipid register firstly.
+	 * Because sleep and wakeup function need to know register address
+	 * by chipid. Because of getting slp_mgr.drv_slp_lock mutex lock,
+	 * this logic will cause deadlock.
+	 */
+	if ((!IS_BYPASS_WAKE(system_addr)) &&
+		(system_addr != CHIPID_REG_M3E) &&
+		(system_addr != CHIPID_REG_M3_M3L))
+#else
+	if (!IS_BYPASS_WAKE(system_addr))
+#endif
+		sdiohal_cp_rx_sleep(DT_READL);
+	if (ret != 0) {
+		sdiohal_err("dt readl fail ret:%d, system_addr=0x%x\n",
+			    ret, system_addr);
+		p_data->dt_rw_fail = 1;
+		sdiohal_dump_aon_reg();
+		sdiohal_abort();
+	}
+	sdiohal_card_unlock(p_data);
+
+	return ret;
+}
+
+static int sdiohal_blksz_for_byte_mode(const struct mmc_card *c)
+{
+	return c->quirks & MMC_QUIRK_BLKSZ_FOR_BYTE_MODE;
+}
+
+static int sdiohal_card_broken_byte_mode_512(
+	const struct mmc_card *c)
+{
+	return c->quirks & MMC_QUIRK_BROKEN_BYTE_MODE_512;
+}
+
+static unsigned int max_bytes(struct sdio_func *func)
+{
+	unsigned int mval = func->card->host->max_blk_size;
+
+	if (sdiohal_blksz_for_byte_mode(func->card))
+		mval = min(mval, func->cur_blksize);
+	else
+		mval = min(mval, func->max_blksize);
+
+	if (sdiohal_card_broken_byte_mode_512(func->card))
+		return min(mval, 511u);
+
+	/* maximum size for byte mode */
+	return min(mval, 512u);
+}
+
+int sdiohal_dt_write(unsigned int system_addr,
+			    void *buf, unsigned int len)
+{
+	struct sdiohal_data_t *p_data = sdiohal_get_data();
+	unsigned int remainder = len;
+	unsigned int trans_len;
+	int ret = 0;
+
+	if (sdiohal_card_lock(p_data, __func__))
+		return -1;
+
+#ifdef CONFIG_ARCH_SUNXI
+	if (p_data->dt_rw_fail)
+		return -1;
+#endif
+
+	sdiohal_resume_check();
+	sdiohal_cp_tx_wakeup(DT_WRITE);
+	sdiohal_op_enter();
+
+	ret = sdiohal_dt_set_addr(system_addr);
+	if (ret != 0) {
+		sdiohal_op_leave();
+		sdiohal_cp_tx_sleep(DT_WRITE);
+		sdiohal_card_unlock(p_data);
+		return ret;
+	}
+
+	sdio_claim_host(p_data->sdio_func[FUNC_1]);
+	while (remainder > 0) {
+		if (remainder >= p_data->sdio_func[FUNC_1]->cur_blksize)
+			trans_len = p_data->sdio_func[FUNC_1]->cur_blksize;
+		else
+			trans_len = min(remainder,
+					max_bytes(p_data->sdio_func[FUNC_1]));
+		ret = sdio_memcpy_toio(p_data->sdio_func[FUNC_1],
+				       SDIOHAL_DT_MODE_ADDR, buf, trans_len);
+		if (ret)
+			break;
+
+		remainder -= trans_len;
+		buf += trans_len;
+	}
+	sdio_release_host(p_data->sdio_func[FUNC_1]);
+	sdiohal_op_leave();
+	sdiohal_cp_tx_sleep(DT_WRITE);
+	if (ret != 0) {
+		sdiohal_err("dt write fail ret:%d, system_addr=0x%x\n",
+			    ret, system_addr);
+		p_data->dt_rw_fail = 1;
+		sdiohal_dump_aon_reg();
+		sdiohal_abort();
+	}
+	sdiohal_card_unlock(p_data);
+
+	return ret;
+}
+
+int sdiohal_dt_read(unsigned int system_addr, void *buf,
+			   unsigned int len)
+{
+	struct sdiohal_data_t *p_data = sdiohal_get_data();
+	unsigned int remainder = len;
+	unsigned int trans_len;
+	int ret = 0;
+
+	if (sdiohal_card_lock(p_data, __func__))
+		return -1;
+
+#ifdef CONFIG_ARCH_SUNXI
+	if (p_data->dt_rw_fail)
+		return -1;
+#endif
+
+	sdiohal_resume_check();
+	sdiohal_cp_rx_wakeup(DT_READ);
+	sdiohal_op_enter();
+	ret = sdiohal_dt_set_addr(system_addr);
+	if (ret != 0) {
+		sdiohal_op_leave();
+		sdiohal_cp_rx_sleep(DT_READ);
+		sdiohal_card_unlock(p_data);
+		return ret;
+	}
+
+	sdio_claim_host(p_data->sdio_func[FUNC_1]);
+	while (remainder > 0) {
+		if (remainder >= p_data->sdio_func[FUNC_1]->cur_blksize)
+			trans_len = p_data->sdio_func[FUNC_1]->cur_blksize;
+		else
+			trans_len = min(remainder,
+					max_bytes(p_data->sdio_func[FUNC_1]));
+		ret = sdio_memcpy_fromio(p_data->sdio_func[FUNC_1],
+					 buf, SDIOHAL_DT_MODE_ADDR, trans_len);
+		if (ret)
+			break;
+
+		remainder -= trans_len;
+		buf += trans_len;
+	}
+	sdio_release_host(p_data->sdio_func[FUNC_1]);
+	sdiohal_op_leave();
+	sdiohal_cp_rx_sleep(DT_READ);
+	if (ret != 0) {
+		sdiohal_err("dt read fail ret:%d, system_addr=0x%x\n",
+			    ret, system_addr);
+		p_data->dt_rw_fail = 1;
+		sdiohal_dump_aon_reg();
+		sdiohal_abort();
+	}
+	sdiohal_card_unlock(p_data);
+
+	return ret;
+}
+
+int sdiohal_aon_readb(unsigned int addr, unsigned char *val)
+{
+	struct sdiohal_data_t *p_data = sdiohal_get_data();
+	int err = 0;
+	unsigned char reg_val = 0;
+
+	if (sdiohal_card_lock(p_data, __func__))
+		return -1;
+
+	sdiohal_resume_check();
+	sdiohal_op_enter();
+	sdio_claim_host(p_data->sdio_func[FUNC_0]);
+	reg_val = sdio_readb(p_data->sdio_func[FUNC_0], addr, &err);
+	if (val)
+		*val = reg_val;
+	sdio_release_host(p_data->sdio_func[FUNC_0]);
+	sdiohal_op_leave();
+	sdiohal_card_unlock(p_data);
+
+	return err;
+}
+
+int sdiohal_aon_writeb(unsigned int addr, unsigned char val)
+{
+	struct sdiohal_data_t *p_data = sdiohal_get_data();
+	int err = 0;
+
+	if (sdiohal_card_lock(p_data, __func__))
+		return -1;
+
+	sdiohal_resume_check();
+	sdiohal_op_enter();
+	sdio_claim_host(p_data->sdio_func[FUNC_0]);
+	sdio_writeb(p_data->sdio_func[FUNC_0], val, addr, &err);
+	sdio_release_host(p_data->sdio_func[FUNC_0]);
+	sdiohal_op_leave();
+	sdiohal_card_unlock(p_data);
+
+	return err;
+}
+
+unsigned long long sdiohal_get_rx_total_cnt(void)
+{
+	struct sdiohal_data_t *p_data = sdiohal_get_data();
+
+	return p_data->rx_packer_cnt;
+}
+
+void sdiohal_set_carddump_status(unsigned int flag)
+{
+	struct sdiohal_data_t *p_data = sdiohal_get_data();
+
+	sdiohal_info("carddump flag set[%d]\n", flag);
+	if (flag == true) {
+		if (p_data->irq_type == SDIOHAL_RX_INBAND_IRQ) {
+			sdio_claim_host(p_data->sdio_func[FUNC_1]);
+			sdio_release_irq(p_data->sdio_func[FUNC_1]);
+			sdio_release_host(p_data->sdio_func[FUNC_1]);
+		} else if ((p_data->irq_type == SDIOHAL_RX_EXTERNAL_IRQ) &&
+			(p_data->irq_num > 0))
+			disable_irq(p_data->irq_num);
+		sdiohal_info("disable rx int for dump\n");
+	}
+
+#if SDIO_DUMP_CHANNEL_DATA
+	sdiohal_dump_channel_data(SDIO_DUMP_TX_CHANNEL_NUM,
+				  &p_data->chntx_push_old,
+				  "tx push old");
+	sdiohal_dump_channel_data(SDIO_DUMP_TX_CHANNEL_NUM,
+				  &p_data->chntx_denq_old,
+				  "tx denq old");
+	sdiohal_dump_channel_data(SDIO_DUMP_RX_CHANNEL_NUM,
+				  &p_data->chnrx_dispatch_old,
+				  "rx dispatch old");
+	sdiohal_dump_channel_data(SDIO_DUMP_TX_CHANNEL_NUM,
+				  &p_data->chntx_push_new,
+				  "tx push new");
+	sdiohal_dump_channel_data(SDIO_DUMP_TX_CHANNEL_NUM,
+				  &p_data->chntx_denq_new,
+				  "tx denq new");
+	sdiohal_dump_channel_data(SDIO_DUMP_RX_CHANNEL_NUM,
+				  &p_data->chnrx_dispatch_new,
+				  "rx dispatch new");
+#endif
+	p_data->card_dump_flag = flag;
+}
+
+unsigned int sdiohal_get_carddump_status(void)
+{
+	struct sdiohal_data_t *p_data = sdiohal_get_data();
+
+	return p_data->card_dump_flag;
+}
+
+static void sdiohal_disable_rx_irq(int irq)
+{
+	struct sdiohal_data_t *p_data = sdiohal_get_data();
+
+	if (p_data->irq_type != SDIOHAL_RX_EXTERNAL_IRQ)
+		return;
+
+	sdiohal_atomic_add(1, &p_data->irq_cnt);
+	disable_irq_nosync(irq);
+}
+
+void sdiohal_enable_rx_irq(void)
+{
+	struct sdiohal_data_t *p_data = sdiohal_get_data();
+
+	if (p_data->irq_type != SDIOHAL_RX_EXTERNAL_IRQ)
+		return;
+
+	sdiohal_atomic_sub(1, &p_data->irq_cnt);
+	if (p_data->irq_num > 0) {
+		irq_set_irq_type(p_data->irq_num, p_data->irq_trigger_type);
+		enable_irq(p_data->irq_num);
+	}
+}
+
+static irqreturn_t sdiohal_irq_handler(int irq, void *para)
+{
+	struct sdiohal_data_t *p_data = sdiohal_get_data();
+
+	sdiohal_debug("%s entry\n", __func__);
+
+	sdiohal_lock_rx_ws();
+	sdiohal_disable_rx_irq(irq);
+
+	ktime_get_real_ts64(&p_data->tm_begin_irq);
+	sdiohal_rx_up();
+
+	return IRQ_HANDLED;
+}
+
+static int sdiohal_enable_slave_irq(void)
+{
+	struct sdiohal_data_t *p_data = sdiohal_get_data();
+	int err;
+	unsigned char reg_val;
+
+	/* set func1 dedicated0,1 int to ap enable */
+
+	if (p_data->irq_type != SDIOHAL_RX_EXTERNAL_IRQ)
+		return 0;
+
+	sdiohal_resume_check();
+	sdiohal_op_enter();
+	sdio_claim_host(p_data->sdio_func[FUNC_0]);
+	reg_val = sdio_readb(p_data->sdio_func[FUNC_0],
+			     SDIOHAL_FBR_DEINT_EN, &err);
+	sdio_writeb(p_data->sdio_func[FUNC_0],
+		    reg_val | VAL_DEINT_ENABLE, SDIOHAL_FBR_DEINT_EN, &err);
+	reg_val = sdio_readb(p_data->sdio_func[FUNC_0],
+			     SDIOHAL_FBR_DEINT_EN, &err);
+	sdio_release_host(p_data->sdio_func[FUNC_0]);
+	sdiohal_op_leave();
+
+	return 0;
+}
+
+static int sdiohal_host_irq_init(unsigned int irq_gpio_num)
+{
+	struct sdiohal_data_t *p_data = sdiohal_get_data();
+	int ret = 0;
+
+	sdiohal_debug("%s enter\n", __func__);
+
+	if (irq_gpio_num == 0)
+		return ret;
+
+	ret = gpio_request(irq_gpio_num, "sdiohal_gpio");
+	if (ret < 0) {
+		sdiohal_err("req gpio irq = %d fail!!!", irq_gpio_num);
+		return ret;
+	}
+
+	ret = gpio_direction_input(irq_gpio_num);
+	if (ret < 0) {
+		sdiohal_err("gpio:%d input set fail!!!", irq_gpio_num);
+		return ret;
+	}
+
+	p_data->irq_num = gpio_to_irq(irq_gpio_num);
+	p_data->irq_trigger_type = IRQF_TRIGGER_HIGH;
+
+	return ret;
+}
+
+static int sdiohal_get_dev_func(struct sdio_func *func)
+{
+	struct sdiohal_data_t *p_data = sdiohal_get_data();
+
+	if (func->num >= SDIOHAL_MAX_FUNCS) {
+		sdiohal_err("func num err!!! func num is %d!!!",
+			func->num);
+		return -1;
+	}
+	sdiohal_debug("func num is %d.", func->num);
+
+	if (func->num == 1) {
+		p_data->sdio_func[FUNC_0] = kmemdup(func, sizeof(*func),
+							 GFP_KERNEL);
+		p_data->sdio_func[FUNC_0]->num = 0;
+		p_data->sdio_func[FUNC_0]->max_blksize = SDIOHAL_BLK_SIZE;
+	}
+
+	p_data->sdio_func[FUNC_1] = func;
+
+	return 0;
+}
+
+static int sdiohal_parse_dt(void)
+{
+	struct sdiohal_data_t *p_data = sdiohal_get_data();
+#ifdef CONFIG_WCN_PARSE_DTS
+	struct device_node *np;
+
+	np = of_find_node_by_name(NULL, "uwe-bsp");
+	if (!np) {
+		sdiohal_err("dts node not found");
+		return -1;
+	}
+#endif
+
+	/* adma_tx_enable and adma_rx_enable */
+#ifdef CONFIG_SDIO_TX_ADMA_MODE
+	p_data->adma_tx_enable = true;
+#endif
+#ifdef CONFIG_WCN_PARSE_DTS
+	if (of_get_property(np, "adma-tx", NULL))
+		p_data->adma_tx_enable = true;
+#endif
+
+#ifdef CONFIG_SDIO_RX_ADMA_MODE
+	p_data->adma_rx_enable = true;
+#endif
+#ifdef CONFIG_WCN_PARSE_DTS
+	if (of_get_property(np, "adma-rx", NULL))
+		p_data->adma_rx_enable = true;
+#endif
+
+	/* power seq */
+#ifdef CONFIG_SDIO_PWRSEQ
+	p_data->pwrseq = true;
+#endif
+#ifdef CONFIG_WCN_PARSE_DTS
+	if (of_get_property(np, "pwrseq", NULL))
+		p_data->pwrseq = true;
+#endif
+
+	/* irq type */
+#ifdef CONFIG_SDIO_INBAND_INT
+	p_data->irq_type = SDIOHAL_RX_INBAND_IRQ;
+#elif defined(CONFIG_SDIO_INBAND_POLLING)
+	p_data->irq_type = SDIOHAL_RX_POLLING;
+#else
+	p_data->irq_type = SDIOHAL_RX_EXTERNAL_IRQ;
+#endif
+#ifdef CONFIG_WCN_PARSE_DTS
+	if (of_get_property(np, "data-irq", NULL))
+		p_data->irq_type = SDIOHAL_RX_INBAND_IRQ;
+	else if (of_get_property(np, "rx-polling", NULL))
+		p_data->irq_type = SDIOHAL_RX_POLLING;
+	else {
+		p_data->irq_type = SDIOHAL_RX_EXTERNAL_IRQ;
+		p_data->gpio_num =
+			of_get_named_gpio(np, "sdio-ext-int-gpio", 0);
+		if (!gpio_is_valid(p_data->gpio_num)) {
+			sdiohal_err("can not get sdio int gpio%d\n",
+				    p_data->gpio_num);
+			p_data->gpio_num = 0;
+		}
+	}
+#else /* else of CONFIG_WCN_PARSE_DTS */
+	p_data->gpio_num = 0;
+#endif
+
+	/* block size */
+#ifdef CONFIG_SDIO_BLKSIZE_512
+	p_data->blk_size = true;
+#endif
+#ifdef CONFIG_WCN_PARSE_DTS
+	if (of_get_property(np, "blksz-512", NULL))
+		p_data->blk_size = true;
+#endif
+
+	sdiohal_info("%s adma_tx:%d, adma_rx:%d, pwrseq:%d, irq type:%s, "
+		     "gpio_num:%d, blksize:%d\n",
+		     __func__, p_data->adma_tx_enable,
+		     p_data->adma_rx_enable, p_data->pwrseq,
+		     ((p_data->irq_type == SDIOHAL_RX_EXTERNAL_IRQ) ? "gpio" :
+		     (((p_data->irq_type == SDIOHAL_RX_INBAND_IRQ) ?
+		     "data" : "polling"))), p_data->gpio_num,
+		     sprdwcn_bus_get_blk_size());
+
+	p_data->sdio_dev_host = host;
+	if (p_data->sdio_dev_host == NULL) {
+		sdiohal_err("get host failed!!!");
+		return -1;
+	}
+	sdiohal_info("get host ok!!!");
+
+	return 0;
+}
+
+static int sdiohal_set_cp_pin_status(void)
+{
+	int reg_value;
+
+	/* cp pin pull down on default except uwe5621 */
+#ifndef CONFIG_CHECK_DRIVER_BY_CHIPID
+#ifndef CONFIG_UWE5621
+	return 0;
+#endif
+#else /*CONFIG_CHECK_DRIVER_BY_CHIPID*/
+	if (wcn_get_chip_model() != WCN_CHIP_MARLIN3)
+		return 0;
+#endif
+	/*
+	 * Because of cp pin pull up on default, It's lead to
+	 * the sdio mistaken interruption before cp run,
+	 * So set the pin to no pull up on init.
+	 */
+	sdiohal_readl(CP_GPIO1_REG, &reg_value);
+	sdiohal_info("reg_value: 0x%x\n", reg_value);
+	reg_value &= ~(CP_PIN_FUNC_WPU);
+	reg_value |= (1<<7);
+	sdiohal_writel(CP_GPIO1_REG, &reg_value);
+
+	sdiohal_readl(CP_GPIO1_REG, &reg_value);
+	sdiohal_info("reg_value: 0x%x\n", reg_value);
+
+	/* gpio set low*/
+	sdiohal_readl(CP_GPIO1_DATA_BASE + 0x04, &reg_value);
+	sdiohal_info("reg_value 0x04: 0x%x\n", reg_value);
+	reg_value |= (1<<1);
+	sdiohal_writel(CP_GPIO1_DATA_BASE + 0x04, &reg_value);
+
+	sdiohal_readl(CP_GPIO1_DATA_BASE + 0x04, &reg_value);
+	sdiohal_info("reg_value 0x04: 0x%x\n", reg_value);
+
+	sdiohal_readl(CP_GPIO1_DATA_BASE + 0x08, &reg_value);
+	sdiohal_info("reg_value 0x08: 0x%x\n", reg_value);
+	reg_value |= (1<<1);
+	sdiohal_writel(CP_GPIO1_DATA_BASE + 0x08, &reg_value);
+
+	sdiohal_readl(CP_GPIO1_DATA_BASE, &reg_value);
+	sdiohal_info("reg_value 0x08: 0x%x\n", reg_value);
+
+	sdiohal_readl(CP_GPIO1_DATA_BASE + 0x0, &reg_value);
+	sdiohal_info("reg_value 0x0: 0x%x\n", reg_value);
+	reg_value &= ~(CP_PIN_FUNC_WPU);
+	reg_value |= (1<<1);
+	sdiohal_writel(CP_GPIO1_DATA_BASE, &reg_value);
+
+	sdiohal_readl(CP_GPIO1_DATA_BASE, &reg_value);
+	sdiohal_info("reg_value 0x0: 0x%x\n", reg_value);
+	return 0;
+}
+
+static void sdiohal_irq_handler_data(struct sdio_func *func)
+{
+	struct sdiohal_data_t *p_data = sdiohal_get_data();
+	int err;
+
+	sdiohal_debug("%s entry\n", __func__);
+
+	if (!WCN_CARD_EXIST(&p_data->xmit_cnt)) {
+		sdiohal_err("%s line %d not have card\n", __func__, __LINE__);
+		return;
+	}
+
+	sdiohal_resume_check();
+
+	/* send cmd to clear cp int status */
+	sdio_claim_host(p_data->sdio_func[FUNC_0]);
+	sdio_f0_readb(p_data->sdio_func[FUNC_0], SDIO_CCCR_INTx, &err);
+	sdio_release_host(p_data->sdio_func[FUNC_0]);
+	if (err < 0)
+		sdiohal_err("%s error %d\n", __func__, err);
+
+	sdiohal_lock_rx_ws();
+	sdiohal_rx_up();
+}
+
+static int sdiohal_suspend(struct device *dev)
+{
+	struct sdiohal_data_t *p_data = sdiohal_get_data();
+	struct mchn_ops_t *sdiohal_ops;
+	struct sdio_func *func;
+	int chn, ret = 0;
+
+	sdiohal_info("[%s]enter\n", __func__);
+
+#ifdef CONFIG_WCN_RESUME_KEEPPWR_RESETSDIO
+	/* After resume will reset sdio reg */
+	ret = sprdwcn_bus_reg_read(SDIO_CP_INT_EN, &p_data->sdio_int_reg, 4);
+	sdiohal_info("%s SDIO_CP_INT_EN(0x58):0x%x ret:%d\n", __func__,
+		     p_data->sdio_int_reg, ret);
+#endif
+
+	atomic_set(&p_data->flag_suspending, 1);
+	for (chn = 0; chn < SDIO_CHANNEL_NUM; chn++) {
+		sdiohal_ops = chn_ops(chn);
+		if (sdiohal_ops && sdiohal_ops->power_notify) {
+#ifdef CONFIG_WCN_SLP
+			sdio_record_power_notify(true);
+#endif
+			ret = sdiohal_ops->power_notify(chn, false);
+			if (ret != 0) {
+				sdiohal_info("[%s] chn:%d suspend fail\n",
+					     __func__, chn);
+				atomic_set(&p_data->flag_suspending, 0);
+				return ret;
+			}
+		}
+	}
+
+#ifdef CONFIG_WCN_SLP
+	sdio_wait_pub_int_done();
+	sdio_record_power_notify(false);
+#endif
+
+	if (marlin_get_bt_wl_wake_host_en()) {
+		/* Inform CP side that AP will enter into suspend status. */
+		sprdwcn_bus_aon_writeb(REG_AP_INT_CP0, (1 << AP_SUSPEND));
+	}
+
+	atomic_set(&p_data->flag_suspending, 0);
+	atomic_set(&p_data->flag_resume, 0);
+	if (atomic_read(&p_data->irq_cnt))
+		sdiohal_lock_rx_ws();
+
+	if (WCN_CARD_EXIST(&p_data->xmit_cnt)) {
+		func = container_of(dev, struct sdio_func, dev);
+		func->card->host->pm_flags |= MMC_PM_KEEP_POWER;
+		sdiohal_info("%s pm_flags=0x%x, caps=0x%x\n", __func__,
+			     func->card->host->pm_flags,
+			     func->card->host->caps);
+	}
+
+	if (p_data->irq_type == SDIOHAL_RX_INBAND_IRQ) {
+		sdio_claim_host(p_data->sdio_func[FUNC_1]);
+		sdio_release_irq(p_data->sdio_func[FUNC_1]);
+		sdio_release_host(p_data->sdio_func[FUNC_1]);
+	} else if ((p_data->irq_type == SDIOHAL_RX_EXTERNAL_IRQ) &&
+		(p_data->irq_num > 0))
+		disable_irq(p_data->irq_num);
+
+	if (WCN_CARD_EXIST(&p_data->xmit_cnt))
+		atomic_add(SDIOHAL_REMOVE_CARD_VAL, &p_data->xmit_cnt);
+
+	return 0;
+}
+
+static int sdiohal_resume(struct device *dev)
+{
+	struct sdiohal_data_t *p_data = sdiohal_get_data();
+	struct mchn_ops_t *sdiohal_ops;
+	struct sdio_func *func = p_data->sdio_func[FUNC_1];
+	int chn;
+	int ret = 0;
+#ifdef CONFIG_WCN_RESUME_KEEPPWR_RESETSDIO
+	int init_state = 0;
+#endif
+
+	sdiohal_info("[%s]enter\n", __func__);
+
+#if (defined(CONFIG_WCN_RESUME_KEEPPWR_RESETSDIO) ||\
+	defined(CONFIG_WCN_RESUME_POWER_DOWN))
+	/*
+	 * For hisi board, sdio host will power down.
+	 * So sdio slave need to reset and reinit.
+	 */
+	mmc_power_save_host(p_data->sdio_dev_host);
+	mdelay(5);
+	mmc_power_restore_host(p_data->sdio_dev_host);
+
+	if (!p_data->pwrseq) {
+		/* Enable Function 1 */
+		sdio_claim_host(p_data->sdio_func[FUNC_1]);
+		ret = sdio_enable_func(p_data->sdio_func[FUNC_1]);
+		sdio_set_block_size(p_data->sdio_func[FUNC_1],
+				    SDIOHAL_BLK_SIZE);
+		p_data->sdio_func[FUNC_1]->max_blksize = SDIOHAL_BLK_SIZE;
+		sdio_release_host(p_data->sdio_func[FUNC_1]);
+		if (ret < 0) {
+			sdiohal_err("enable func1 err!!! ret is %d\n", ret);
+			return ret;
+		}
+		sdiohal_info("enable func1 ok\n");
+
+		atomic_set(&p_data->flag_resume, 1);
+		sdiohal_enable_slave_irq();
+	} else
+		pm_runtime_put_noidle(&func->dev);
+#endif
+
+	atomic_set(&p_data->flag_resume, 1);
+	if (!WCN_CARD_EXIST(&p_data->xmit_cnt))
+		atomic_sub(SDIOHAL_REMOVE_CARD_VAL, &p_data->xmit_cnt);
+
+#ifdef CONFIG_WCN_RESUME_KEEPPWR_RESETSDIO
+	/* After resume will reset sdio reg, re-enable sdio int. */
+	ret = sprdwcn_bus_reg_write(SDIO_CP_INT_EN, &p_data->sdio_int_reg, 4);
+	sdiohal_info("%s SDIO_CP_INT_EN(0x58):0x%x ret:%d\n", __func__,
+		     p_data->sdio_int_reg, ret);
+#endif
+
+	if (marlin_get_bt_wl_wake_host_en()) {
+		/* Inform CP side that AP reset sdio done during resume. */
+		sprdwcn_bus_aon_writeb(REG_AP_INT_CP0, (1 << AP_RESUME));
+	}
+
+#ifdef CONFIG_WCN_RESUME_POWER_DOWN
+	marlin_schedule_download_wq();
+#endif
+
+#if (defined(CONFIG_WCN_RESUME_KEEPPWR_RESETSDIO) ||\
+	defined(CONFIG_WCN_RESUME_POWER_DOWN))
+	sdiohal_set_cp_pin_status();
+#endif
+
+	if (WCN_CARD_EXIST(&p_data->xmit_cnt)) {
+		func = container_of(dev, struct sdio_func, dev);
+		func->card->host->pm_flags &= ~MMC_PM_KEEP_POWER;
+		sdiohal_info("%s pm_flags=0x%x, caps=0x%x\n", __func__,
+			     func->card->host->pm_flags,
+			     func->card->host->caps);
+	}
+
+#ifdef CONFIG_WCN_RESUME_KEEPPWR_RESETSDIO
+	/*
+	 * polling sync_addr,
+	 * If equal to SYNC_SDIO_REINIT_DONE, cp receive sdio int (ap resume);
+	 * Then write sync_addr to SYNC_SDIO_IS_READY,
+	 * and enable sdio rx int.
+	 */
+	do {
+		ret = sprdwcn_bus_reg_read(SYNC_ADDR, &init_state, 4);
+		sdiohal_info("%s init_state:0x%x ret:%d\n", __func__,
+			     init_state, ret);
+		if (init_state == SYNC_SDIO_REINIT_DONE) {
+			init_state = SYNC_SDIO_IS_READY;
+			ret = sprdwcn_bus_reg_write(SYNC_ADDR, &init_state, 4);
+			if (ret < 0)
+				sdiohal_err("write SDIO_READY err:%d\n", ret);
+			else
+				break;
+		}
+		msleep(20);
+	} while (1);
+#endif
+
+#ifndef CONFIG_WCN_RESUME_POWER_DOWN
+	/* If CONFIG_WCN_RESUME_POWER_DOWN,
+	 * will enable irq at sdiohal_runtime_get function.
+	 */
+	if (p_data->irq_type == SDIOHAL_RX_INBAND_IRQ) {
+		sdio_claim_host(p_data->sdio_func[FUNC_1]);
+		if (sdio_claim_irq(p_data->sdio_func[FUNC_1],
+			sdiohal_irq_handler_data)) {
+			sdiohal_err("%s: Failed to request IRQ\n",
+				    __func__);
+			sdio_release_host(p_data->sdio_func[FUNC_1]);
+			return -1;
+		}
+		sdio_release_host(p_data->sdio_func[FUNC_1]);
+	} else if ((p_data->irq_type == SDIOHAL_RX_EXTERNAL_IRQ) &&
+		(p_data->irq_num > 0))
+		enable_irq(p_data->irq_num);
+#endif
+
+	for (chn = 0; chn < SDIO_CHANNEL_NUM; chn++) {
+		sdiohal_ops = chn_ops(chn);
+		if (sdiohal_ops && sdiohal_ops->power_notify) {
+			ret = sdiohal_ops->power_notify(chn, true);
+			if (ret != 0)
+				sdiohal_info("[%s] chn:%d resume fail\n",
+					     __func__, chn);
+		}
+	}
+
+	return 0;
+}
+
+int sdiohal_runtime_get(void)
+{
+	struct sdiohal_data_t *p_data = sdiohal_get_data();
+
+	int ret;
+
+	sdiohal_info("%s entry\n", __func__);
+	if (!p_data)
+		return -ENODEV;
+
+	if (!WCN_CARD_EXIST(&p_data->xmit_cnt)) {
+		sdiohal_err("%s line %d not have card\n", __func__, __LINE__);
+		return -ENODEV;
+	}
+
+	if (!p_data->pwrseq) {
+		if (p_data->irq_type == SDIOHAL_RX_INBAND_IRQ) {
+			sdio_claim_host(p_data->sdio_func[FUNC_1]);
+			if (sdio_claim_irq(p_data->sdio_func[FUNC_1],
+				sdiohal_irq_handler_data)) {
+				sdiohal_err("%s: Failed to request IRQ\n",
+					    __func__);
+				sdio_release_host(p_data->sdio_func[FUNC_1]);
+				return -1;
+			}
+			sdio_release_host(p_data->sdio_func[FUNC_1]);
+		} else if ((p_data->irq_type == SDIOHAL_RX_EXTERNAL_IRQ) &&
+			(p_data->irq_num > 0))
+			enable_irq(p_data->irq_num);
+
+		return 0;
+	}
+
+	ret = pm_runtime_get_sync(&p_data->sdio_func[FUNC_1]->dev);
+	if (ret < 0) {
+		sdiohal_err("sdiohal_rumtime_get err: %d", ret);
+		return ret;
+	}
+
+	/* Enable Function 1 */
+	sdio_claim_host(p_data->sdio_func[FUNC_1]);
+	ret = sdio_enable_func(p_data->sdio_func[FUNC_1]);
+	sdio_set_block_size(p_data->sdio_func[FUNC_1], SDIOHAL_BLK_SIZE);
+	p_data->sdio_func[FUNC_1]->max_blksize = SDIOHAL_BLK_SIZE;
+	sdio_release_host(p_data->sdio_func[FUNC_1]);
+	if (ret < 0) {
+		sdiohal_err("%s enable func1 err!!! ret is %d", __func__, ret);
+		return ret;
+	}
+	sdiohal_info("enable func1 ok!!!");
+	sdiohal_set_cp_pin_status();
+	sdiohal_enable_slave_irq();
+	if (p_data->irq_type == SDIOHAL_RX_EXTERNAL_IRQ)
+		enable_irq(p_data->irq_num);
+	sdiohal_info("sdihal: %s ret:%d\n", __func__, ret);
+
+	return ret;
+}
+
+int sdiohal_runtime_put(void)
+{
+	struct sdiohal_data_t *p_data = sdiohal_get_data();
+	int xmit_cnt;
+
+	sdiohal_info("%s entry\n", __func__);
+
+	if (!p_data)
+		return -ENODEV;
+
+	if (p_data->irq_type == SDIOHAL_RX_INBAND_IRQ) {
+		sdio_claim_host(p_data->sdio_func[FUNC_1]);
+		sdio_release_irq(p_data->sdio_func[FUNC_1]);
+		sdio_release_host(p_data->sdio_func[FUNC_1]);
+	} else if ((p_data->irq_type == SDIOHAL_RX_EXTERNAL_IRQ) &&
+		(p_data->irq_num > 0))
+		disable_irq(p_data->irq_num);
+
+	if (WCN_CARD_EXIST(&p_data->xmit_cnt)) {
+		atomic_set(&p_data->xmit_start, 0);
+		xmit_cnt = atomic_read(&p_data->xmit_cnt);
+		while ((xmit_cnt > 0) &&
+			(xmit_cnt < SDIOHAL_REMOVE_CARD_VAL)) {
+			usleep_range(1000, 2000);
+			xmit_cnt = atomic_read(&p_data->xmit_cnt);
+			sdiohal_info("%s wait xmit_cnt:%d\n",
+				     __func__, xmit_cnt);
+		}
+
+		sdiohal_info("%s wait xmit_cnt end\n", __func__);
+	} else {
+		sdiohal_err("%s line %d not have card\n", __func__, __LINE__);
+		return -ENODEV;
+	}
+
+	if (!p_data->pwrseq)
+		return 0;
+
+	return pm_runtime_put_sync(&p_data->sdio_func[FUNC_1]->dev);
+}
+
+#ifdef SDIO_RESET_DEBUG
+int sdiohal_disable_apb_reset(void)
+{
+#ifndef CONFIG_CHECK_DRIVER_BY_CHIPID
+#ifdef SDIO_RESET_ENABLE
+	int reg_value;
+
+	sdiohal_readl(SDIO_RESET_ENABLE, &reg_value);
+	sdiohal_info("0x40930040: 0x%x\n", reg_value);
+	reg_value &= ~BIT(4);
+	sdiohal_writel(SDIO_RESET_ENABLE, &reg_value);
+#endif
+#else /*CONFIG_CHECK_DRIVER_BY_CHIPID*/
+	int ret_value;
+	unsigned int sdio_reset_enable = 0x40930040;
+
+	sdiohal_readl(sdio_reset_enable, &reg_value);
+	sdiohal_info("0x40930040: 0x%x\n", reg_value);
+	reg_value &= ~BIT(4);
+	sdiohal_writel(sdio_reset_enable, &reg_value);
+#endif
+
+	return 0;
+}
+
+/*
+ * full_reset: 1, reset sdio and apb;
+ * full_reset: 0, only reset sdio.
+ */
+void sdiohal_reset(bool full_reset)
+{
+	struct sdiohal_data_t *p_data = sdiohal_get_data();
+	int ret;
+	u8 val;
+
+	sdio_claim_host(p_data->sdio_func[FUNC_0]);
+	val = sdio_readb(p_data->sdio_func[FUNC_0], SDIOHAL_CCCR_ABORT, &ret);
+	if (ret)
+		val = 0x08;
+	else
+		val |= 0x08;
+	sdio_writeb(p_data->sdio_func[FUNC_0], val, SDIOHAL_CCCR_ABORT, &ret);
+	sdio_release_host(p_data->sdio_func[FUNC_0]);
+
+	sdio_reset_comm((p_data->sdio_dev_host->card));
+
+	/* rst apb */
+	if (full_reset) {
+		sdiohal_aon_writeb(0x02, 0xf);
+		sdiohal_aon_writeb(0x02, 0x0);
+	}
+
+	/* Enable Function 1 */
+	sdio_claim_host(p_data->sdio_func[FUNC_1]);
+	ret = sdio_enable_func(p_data->sdio_func[FUNC_1]);
+	sdio_set_block_size(p_data->sdio_func[FUNC_1],
+			    SDIOHAL_BLK_SIZE);
+	p_data->sdio_func[FUNC_1]->max_blksize = SDIOHAL_BLK_SIZE;
+	sdio_release_host(p_data->sdio_func[FUNC_1]);
+	if (ret < 0) {
+		sdiohal_err("enable func1 err!!! ret is %d\n", ret);
+		return;
+	}
+	sdiohal_info("enable func1 ok\n");
+
+	sdiohal_enable_slave_irq();
+}
+#endif
+
+static int sdiohal_probe(struct sdio_func *func,
+	const struct sdio_device_id *id)
+{
+	struct sdiohal_data_t *p_data = sdiohal_get_data();
+	int ret;
+	struct mmc_host *host = func->card->host;
+
+	sdiohal_info("%s: func->class=%x, vendor=0x%04x, device=0x%04x, "
+		     "func_num=0x%04x, clock=%d\n",
+		     __func__, func->class, func->vendor, func->device,
+		     func->num, host->ios.clock);
+
+	ret = sdiohal_get_dev_func(func);
+	if (ret < 0) {
+		sdiohal_err("get func err\n");
+		return ret;
+	}
+
+	sdiohal_debug("get func ok:0x%p card:0x%p host_mmc:0x%p\n",
+		      p_data->sdio_func[FUNC_1],
+		      p_data->sdio_func[FUNC_1]->card,
+		      p_data->sdio_func[FUNC_1]->card->host);
+	p_data->sdio_dev_host = p_data->sdio_func[FUNC_1]->card->host;
+	if (p_data->sdio_dev_host == NULL) {
+		sdiohal_err("get host failed!!!");
+		return -1;
+	}
+	sdiohal_debug("get host ok!!!");
+
+	atomic_set(&p_data->xmit_start, 1);
+
+	if (!p_data->pwrseq) {
+		/* Enable Function 1 */
+		sdio_claim_host(p_data->sdio_func[FUNC_1]);
+		ret = sdio_enable_func(p_data->sdio_func[FUNC_1]);
+		sdio_set_block_size(p_data->sdio_func[FUNC_1],
+				    SDIOHAL_BLK_SIZE);
+		p_data->sdio_func[FUNC_1]->max_blksize = SDIOHAL_BLK_SIZE;
+		sdio_release_host(p_data->sdio_func[FUNC_1]);
+		if (ret < 0) {
+			sdiohal_err("enable func1 err!!! ret is %d\n", ret);
+			return ret;
+		}
+		sdiohal_debug("enable func1 ok\n");
+
+		sdiohal_enable_slave_irq();
+	} else
+		pm_runtime_put_noidle(&func->dev);
+
+	if (!WCN_CARD_EXIST(&p_data->xmit_cnt))
+		atomic_sub(SDIOHAL_REMOVE_CARD_VAL, &p_data->xmit_cnt);
+
+	p_data->card_dump_flag = false;
+
+	sdiohal_set_cp_pin_status();
+
+	if (p_data->irq_type == SDIOHAL_RX_EXTERNAL_IRQ) {
+		ret = request_irq(p_data->irq_num, sdiohal_irq_handler,
+				  p_data->irq_trigger_type | IRQF_NO_SUSPEND,
+				  "sdiohal_irq", &func->dev);
+		if (ret != 0) {
+			sdiohal_err("request irq err gpio is %d\n",
+				    p_data->irq_num);
+			return ret;
+		}
+
+		disable_irq(p_data->irq_num);
+	}
+	complete(&p_data->scan_done);
+
+	/* the card is nonremovable */
+	p_data->sdio_dev_host->caps |= MMC_CAP_NONREMOVABLE;
+
+	sdiohal_info("probe ok\n");
+
+	return 0;
+}
+
+static void sdiohal_remove(struct sdio_func *func)
+{
+	struct sdiohal_data_t *p_data = sdiohal_get_data();
+
+	sdiohal_info("[%s]enter\n", __func__);
+
+	if (WCN_CARD_EXIST(&p_data->xmit_cnt))
+		atomic_add(SDIOHAL_REMOVE_CARD_VAL, &p_data->xmit_cnt);
+
+	complete(&p_data->remove_done);
+
+	if (p_data->irq_type == SDIOHAL_RX_INBAND_IRQ) {
+		sdio_claim_host(p_data->sdio_func[FUNC_1]);
+		sdio_release_irq(p_data->sdio_func[FUNC_1]);
+		sdio_release_host(p_data->sdio_func[FUNC_1]);
+	} else if ((p_data->irq_type == SDIOHAL_RX_EXTERNAL_IRQ) &&
+		(p_data->irq_num > 0))
+		free_irq(p_data->irq_num, &func->dev);
+}
+
+static void sdiohal_launch_thread(void)
+{
+	struct sdiohal_data_t *p_data = sdiohal_get_data();
+
+	p_data->tx_thread =
+		kthread_create(sdiohal_tx_thread, NULL, "sdiohal_tx_thread");
+	if (p_data->tx_thread)
+		wake_up_process(p_data->tx_thread);
+	else {
+		sdiohal_err("create sdiohal_tx_thread fail\n");
+		return;
+	}
+
+	p_data->rx_thread =
+	    kthread_create(sdiohal_rx_thread, NULL, "sdiohal_rx_thread");
+	if (p_data->rx_thread)
+		wake_up_process(p_data->rx_thread);
+	else
+		sdiohal_err("creat sdiohal_rx_thread fail\n");
+}
+
+static void sdiohal_stop_thread(void)
+{
+	struct sdiohal_data_t *p_data = sdiohal_get_data();
+
+	sdiohal_info("[%s]enter\n", __func__);
+	atomic_set(&p_data->flag_resume, 1);
+	p_data->exit_flag = 1;
+	if (p_data->tx_thread) {
+		sdiohal_tx_up();
+		kthread_stop(p_data->tx_thread);
+		p_data->tx_thread = NULL;
+	}
+	if (p_data->rx_thread) {
+		sdiohal_rx_up();
+		kthread_stop(p_data->rx_thread);
+		p_data->rx_thread = NULL;
+	}
+}
+
+static const struct dev_pm_ops sdiohal_pm_ops = {
+	SET_SYSTEM_SLEEP_PM_OPS(sdiohal_suspend, sdiohal_resume)
+};
+
+static const struct sdio_device_id sdiohal_ids[] = {
+	{SDIO_DEVICE(0, 0)},
+	{},
+};
+MODULE_DEVICE_TABLE(sdio, sdiohal_ids);
+
+#define WCN_SDIO_CARD_REMOVED	BIT(4)
+void sdiohal_remove_card(void)
+{
+	struct sdiohal_data_t *p_data = sdiohal_get_data();
+
+	if (!WCN_CARD_EXIST(&p_data->xmit_cnt))
+		return;
+
+	atomic_add(SDIOHAL_REMOVE_CARD_VAL, &p_data->xmit_cnt);
+	sdiohal_lock_scan_ws();
+	sdiohal_resume_check();
+	while (atomic_read(&p_data->xmit_cnt) > SDIOHAL_REMOVE_CARD_VAL)
+		usleep_range(4000, 6000);
+
+	init_completion(&p_data->remove_done);
+
+	p_data->sdio_dev_host->card->state |= WCN_SDIO_CARD_REMOVED;
+
+	/* enable remove the card */
+	p_data->sdio_dev_host->caps &= ~MMC_CAP_NONREMOVABLE;
+
+	if (wait_for_completion_timeout(&p_data->remove_done,
+					msecs_to_jiffies(5000)) == 0)
+		sdiohal_err("remove card time out\n");
+	else
+		sdiohal_info("remove card end\n");
+
+	sdio_unregister_driver(&sdiohal_driver);
+	sdiohal_unlock_scan_ws();
+}
+
+int sdiohal_init(void)
+{
+	struct sdiohal_data_t *p_data;
+	int ret = 0;
+
+	sdiohal_debug("sdiohal_init entry\n");
+
+	p_data = kzalloc(sizeof(struct sdiohal_data_t), GFP_KERNEL);
+	if (!p_data) {
+		WARN_ON(1);
+		return -ENOMEM;
+	}
+	p_data->printlog_txchn = SDIO_CHANNEL_NUM;
+	p_data->printlog_rxchn = SDIO_CHANNEL_NUM;
+	/* card not ready */
+	atomic_set(&p_data->xmit_cnt, SDIOHAL_REMOVE_CARD_VAL);
+	sdiohal_data = p_data;
+
+	if (sdiohal_parse_dt() < 0)
+		return -1;
+
+	ret = sdiohal_misc_init();
+	if (ret != 0) {
+		sdiohal_err("sdiohal_misc_init error :%d\n", ret);
+		return -1;
+	}
+
+	sdiohal_launch_thread();
+	if (p_data->irq_type == SDIOHAL_RX_EXTERNAL_IRQ)
+		sdiohal_host_irq_init(p_data->gpio_num);
+	p_data->flag_init = true;
+
+#ifdef CONFIG_DEBUG_FS
+#ifndef USB_SDIO_DT
+	sdiohal_debug_init();
+#endif
+#endif
+	sdiohal_info("sdiohal_init ok\n");
+
+	return 0;
+}
+
+void sdiohal_exit(void)
+{
+	struct sdiohal_data_t *p_data = sdiohal_get_data();
+
+	sdiohal_info("sdiohal_exit entry\n");
+
+	p_data->flag_init = false;
+#ifdef CONFIG_DEBUG_FS
+	sdiohal_debug_deinit();
+#endif
+	if (WCN_CARD_EXIST(&p_data->xmit_cnt)) {
+		sdiohal_info("Already exist card!\n");
+		sdiohal_remove_card();
+	}
+	if ((p_data->irq_type == SDIOHAL_RX_EXTERNAL_IRQ) &&
+		(p_data->irq_num > 0))
+		gpio_free(p_data->gpio_num);
+	sdiohal_stop_thread();
+	sdiohal_misc_deinit();
+	if (sdiohal_data) {
+		sdiohal_data->sdio_dev_host = NULL;
+		kfree(sdiohal_data);
+		sdiohal_data = NULL;
+	}
+
+	sdiohal_info("sdiohal_exit ok\n");
+}
+
+int marlin_probe(struct device *dev);
+int marlin_remove(struct device *dev);
+void marlin_shutdown(void);
+int sprdwl_probe(struct device *dev);
+int sprdwl_remove(struct device *dev);
+
+static int marlin_sdio_probe(struct sdio_func *sdio_func,
+		   const struct sdio_device_id *id)
+{
+	struct device *dev = &sdio_func->dev;
+	int ret;
+
+	host = sdio_func->card->host;
+	ret = marlin_probe(dev);
+	if (ret)
+		return ret;
+	ret = sdiohal_probe(sdio_func, id);
+	if (ret)
+		return ret;
+	return sprdwl_probe(dev);
+}
+
+static void marlin_sdio_remove(struct sdio_func *sdio_func)
+{
+	struct device *dev = &sdio_func->dev;
+
+	sprdwl_remove(dev);
+	sdiohal_remove(sdio_func);
+	marlin_remove(dev);
+}
+
+static void marlin_sdio_shutdown(struct device *dev)
+{
+	marlin_shutdown();
+}
+
+static struct sdio_driver uwe5622_driver = {
+	.name = "uwe5622",
+	.probe = marlin_sdio_probe,
+	.remove = marlin_sdio_remove,
+	.id_table = sdiohal_ids,
+	.drv = {
+		.pm = &sdiohal_pm_ops,
+		.shutdown = marlin_sdio_shutdown,
+	}
+};
+module_sdio_driver(uwe5622_driver);
diff --git a/drivers/net/wireless/uwe5622/unisocwcn/sdio/sdiohal_rx.c b/drivers/net/wireless/uwe5622/unisocwcn/sdio/sdiohal_rx.c
new file mode 100644
index 000000000000..d308dc28a451
--- /dev/null
+++ b/drivers/net/wireless/uwe5622/unisocwcn/sdio/sdiohal_rx.c
@@ -0,0 +1,333 @@
+#include "sdiohal.h"
+
+static unsigned int sdiohal_rx_adapt_get(void)
+{
+	struct sdiohal_data_t *p_data = sdiohal_get_data();
+
+	return p_data->dtbs;
+}
+
+static void sdiohal_rx_adapt_set_dtbs(unsigned int len)
+{
+	struct sdiohal_data_t *p_data = sdiohal_get_data();
+	unsigned int off;
+
+	if (len == 0) {
+		p_data->dtbs = MAX_PAC_SIZE;
+		return;
+	}
+
+	off = (len >> 10) + 1;
+	len = SDIOHAL_ALIGN_BLK(len + 8 * off + 64);
+#if (BITS_PER_LONG > 32) || (PAGE_SIZE >= 65536)
+	p_data->dtbs = (len >= SDIOHAL_RX_RECVBUF_LEN) ?
+			SDIOHAL_RX_RECVBUF_LEN : len;
+#else
+	p_data->dtbs = (len >= SDIOHAL_32_BIT_RX_RECVBUF_LEN) ?
+			SDIOHAL_32_BIT_RX_RECVBUF_LEN : len;
+#endif
+}
+
+static unsigned int sdiohal_rx_adapt_get_pac_num(void)
+{
+	struct sdiohal_data_t *p_data = sdiohal_get_data();
+
+	return p_data->remain_pac_num;
+}
+
+static void sdiohal_rx_adapt_set_pac_num(unsigned int num)
+{
+	struct sdiohal_data_t *p_data = sdiohal_get_data();
+
+	if (num == 0) {
+		p_data->remain_pac_num = 1;
+		return;
+	}
+
+	p_data->remain_pac_num =
+		(num >= MAX_CHAIN_NODE_NUM) ? MAX_CHAIN_NODE_NUM : num;
+}
+
+static int sdiohal_data_list_assignment(struct mbuf_t *mbuf_node,
+	struct sdio_puh_t *puh, int channel)
+{
+	struct sdiohal_list_t *rx_channel_list;
+
+	rx_channel_list = sdiohal_get_rx_channel_list(channel);
+	if (rx_channel_list->node_num == 0)
+		rx_channel_list->mbuf_head = mbuf_node;
+	else
+		rx_channel_list->mbuf_tail->next = mbuf_node;
+
+	mbuf_node->next = NULL;
+	rx_channel_list->mbuf_tail = mbuf_node;
+	rx_channel_list->type = puh->type;
+	rx_channel_list->subtype = puh->subtype;
+	rx_channel_list->node_num++;
+
+	return 0;
+}
+
+/* for adma */
+static int sdiohal_rx_list_parser(struct sdiohal_list_t *data_list,
+				int valid_len)
+{
+	struct sdiohal_data_t *p_data = sdiohal_get_data();
+	struct sdio_puh_t *puh = NULL;
+	struct mbuf_t *mbuf_node, *mbuf_next;
+	unsigned int node_num, i;
+	int inout = 0, channel = 0;
+	unsigned int parse_len;
+
+	sdiohal_list_check(data_list, __func__, SDIOHAL_READ);
+
+	node_num = data_list->node_num;
+	mbuf_next = data_list->mbuf_head;
+	parse_len = 0;
+	for (i = 0; i < node_num; i++) {
+		mbuf_node = mbuf_next;
+		mbuf_next = mbuf_next->next;
+		puh = (struct sdio_puh_t *)mbuf_node->buf;
+		if ((puh->eof == 0) && (puh->type != 0xF)) {
+			channel = sdiohal_hwtype_to_channel(inout,
+				puh->type, puh->subtype);
+			parse_len += puh->len;
+			if (puh->check_sum)
+				puh->len += 2;
+			if ((channel >= SDIO_CHANNEL_NUM) || (puh->len >
+				(MAX_PAC_SIZE - SDIO_PUB_HEADER_SIZE)) ||
+				(puh->len == 0)) {
+				sdiohal_rx_list_free(mbuf_node, mbuf_node, 1);
+				sdiohal_err("%s skip type[%d]sub[%d]len[%d]\n",
+					    __func__, puh->type, puh->subtype,
+					    puh->len);
+				continue;
+			}
+			p_data->rx_packer_cnt++;
+			mbuf_node->len = MAX_MBUF_SIZE;
+			sdiohal_data_list_assignment(mbuf_node, puh, channel);
+		} else {
+			sdiohal_debug("%s eof pac:%d,parse[%d]%s valid[%d]\n",
+				      __func__, puh->eof, parse_len,
+				      (parse_len < valid_len ? "<":">="),
+				      valid_len);
+			sdiohal_debug("%s type[%d]sub[%d]len[%d]\n", __func__,
+				      puh->type, puh->subtype, puh->len);
+
+			sdiohal_rx_list_free(mbuf_node, mbuf_node, 1);
+		}
+	}
+
+	return 0;
+}
+
+/* for normal dma */
+static int sdiohal_rx_buf_parser(char *data_buf, int valid_len)
+{
+	struct sdiohal_data_t *p_data = sdiohal_get_data();
+	struct sdio_puh_t *puh = NULL;
+	struct sdiohal_list_t *data_list = NULL;
+	int inout = 0, channel;
+	unsigned char *p = NULL;
+	unsigned int parse_len;
+
+	puh = (struct sdio_puh_t *)data_buf;
+	for (parse_len = 0; parse_len < valid_len;) {
+		if (puh->eof != 0)
+			break;
+
+		p = (unsigned char *)puh;
+		if (puh->type != 0xF) {
+			channel = sdiohal_hwtype_to_channel(inout,
+				puh->type, puh->subtype);
+			parse_len += puh->len;
+			if (puh->check_sum)
+				puh->len += 2;
+			if ((channel >= SDIO_CHANNEL_NUM) || (puh->len >
+				(MAX_PAC_SIZE - SDIO_PUB_HEADER_SIZE)) ||
+				(puh->len == 0)) {
+				sdiohal_err("%s skip type[%d]sub[%d]len[%d]\n",
+					    __func__, puh->type, puh->subtype,
+					    puh->len);
+				continue;
+			}
+			p_data->rx_packer_cnt++;
+
+			data_list = sdiohal_get_rx_mbuf_node(1);
+			if (!data_list)
+				return -ENOMEM;
+			data_list->mbuf_head = data_list->mbuf_tail;
+			data_list->mbuf_head->buf = (unsigned char *)puh;
+			data_list->mbuf_head->len = puh->len;
+			data_list->node_num = 1;
+			p_data->frag_ctl.pagecnt_bias--;
+
+			sdiohal_list_check(data_list, __func__, SDIOHAL_READ);
+			sdiohal_print_list_data(channel, data_list, __func__,
+						SDIOHAL_DATA_LEVEL);
+
+			sdiohal_data_list_assignment(data_list->mbuf_head,
+						     puh, channel);
+			kfree(data_list);
+		}
+		/* pointer to next packet */
+		p += sizeof(struct sdio_puh_t)
+			+ SDIOHAL_ALIGN_4BYTE(puh->len);
+		puh = (struct sdio_puh_t *)p;
+	}
+
+	return 0;
+}
+
+static void sdiohal_rx_wait(void)
+{
+	struct sdiohal_data_t *p_data = sdiohal_get_data();
+
+	while (1) {
+		msleep(300);
+		if (WCN_CARD_EXIST(&p_data->xmit_cnt))
+			break;
+	}
+}
+
+int sdiohal_rx_thread(void *data)
+{
+	struct sdiohal_data_t *p_data = sdiohal_get_data();
+	struct sched_param param;
+	int read_len, mbuf_num;
+	int ret = 0;
+	unsigned int rx_dtbs = 0;
+	unsigned int valid_len = 0;
+	static char *rx_buf;
+	struct sdiohal_list_t *data_list = NULL;
+	struct timespec64 tm_begin, tm_end;
+	static long time_total_ns;
+	static int times_count;
+
+	param.sched_priority = SDIO_RX_TASK_PRIO;
+	sched_setscheduler(current, SCHED_FIFO, &param);
+	sdiohal_rx_adapt_set_dtbs(0);
+	sdiohal_rx_adapt_set_pac_num(1);
+
+	while (1) {
+		/* Wait the semaphore */
+		if (p_data->irq_type == SDIOHAL_RX_POLLING)
+			sdiohal_rx_wait();
+		else
+			sdiohal_rx_down();
+		if (p_data->exit_flag)
+			break;
+		if (!WCN_CARD_EXIST(&p_data->xmit_cnt)) {
+			sdiohal_err("%s line %d not have card\n",
+				    __func__, __LINE__);
+			continue;
+		}
+
+		ktime_get_real_ts64(&p_data->tm_end_irq);
+		sdiohal_pr_perf("rx sch time:%ld\n",
+				(long)(timespec64_to_ns(&p_data->tm_end_irq)
+				- timespec64_to_ns(&p_data->tm_begin_irq)));
+
+		sdiohal_resume_wait();
+		sdiohal_cp_rx_wakeup(PACKER_RX);
+
+read_again:
+		ktime_get_real_ts64(&tm_begin);
+
+		if (p_data->adma_rx_enable) {
+			/* read len is packet num */
+			mbuf_num = sdiohal_rx_adapt_get_pac_num();
+			sdiohal_debug("%s mbuf_num:%d adma_rx_enable:%d\n",
+				      __func__, mbuf_num,
+				      p_data->adma_rx_enable);
+
+			data_list = sdiohal_get_rx_mbuf_list(mbuf_num);
+			if (!data_list) {
+				sdiohal_err("sdiohal_get_rx_mbuf_list fail\n");
+				msleep(100);
+				goto submit_list;
+			}
+			if (p_data->irq_type == SDIOHAL_RX_POLLING)
+				memset(p_data->dtbs_buf, 0x0,
+				       SDIOHAL_DTBS_BUF_SIZE);
+			ret = sdiohal_adma_pt_read(data_list);
+			if (ret != 0) {
+				sdiohal_err("adma read fail ret:%d\n", ret);
+				rx_dtbs = 0;
+				if (p_data->irq_type != SDIOHAL_RX_POLLING)
+					goto submit_list;
+			}
+			rx_dtbs =  *((unsigned int *)(p_data->dtbs_buf
+				   + (SDIOHAL_DTBS_BUF_SIZE - 4)));
+			valid_len = *((unsigned int *)(p_data->dtbs_buf
+				    + (SDIOHAL_DTBS_BUF_SIZE - 8)));
+			sdiohal_debug("%s rx_pac_num:%d, valid len:%d\n",
+				      __func__, rx_dtbs, valid_len);
+			sdiohal_rx_list_parser(data_list, valid_len);
+			kfree(data_list);
+			data_list = NULL;
+		} else {
+			unsigned int alloc_size;
+
+			/* read len is packet data len */
+			read_len = sdiohal_rx_adapt_get();
+			sdiohal_debug("%s read_len:%d adma_rx_enable:%d\n",
+				      __func__, read_len,
+				      p_data->adma_rx_enable);
+
+			rx_buf = sdiohal_get_rx_free_buf(&alloc_size);
+			if (!rx_buf) {
+				sdiohal_err("get_rx_free_buf fail, rlen=%d\n",
+					    read_len);
+				msleep(100);
+				goto submit_list;
+			}
+			if (alloc_size < read_len) {
+				read_len = alloc_size;
+				sdiohal_debug("alloc_size=%d < read_len=%d\n",
+					      alloc_size, read_len);
+			}
+
+			ret = sdiohal_sdio_pt_read(rx_buf, read_len);
+			if (ret != 0) {
+				sdiohal_err("sdio pt read fail ret:%d\n", ret);
+				rx_dtbs = 0;
+				if (p_data->irq_type != SDIOHAL_RX_POLLING)
+					goto submit_list;
+			}
+			rx_dtbs = *((unsigned int *)(rx_buf + (read_len - 4)));
+			valid_len =
+				*((unsigned int *)(rx_buf + (read_len - 8)));
+			sdiohal_debug("%s rx_dtbs:%d,valid len:%d\n",
+				      __func__, rx_dtbs, valid_len);
+			sdiohal_rx_buf_parser(rx_buf, valid_len);
+		}
+
+submit_list:
+		ktime_get_real_ts64(&tm_end);
+		time_total_ns += timespec64_to_ns(&tm_end)
+			- timespec64_to_ns(&tm_begin);
+		times_count++;
+		if (!(times_count % PERFORMANCE_COUNT)) {
+			sdiohal_pr_perf("rx list avg time:%ld\n",
+					(time_total_ns / PERFORMANCE_COUNT));
+			time_total_ns = 0;
+			times_count = 0;
+		}
+
+		sdiohal_rx_list_dispatch();
+		if (p_data->adma_rx_enable)
+			sdiohal_rx_adapt_set_pac_num(rx_dtbs);
+		else
+			sdiohal_rx_adapt_set_dtbs(rx_dtbs);
+		if (rx_dtbs > 0)
+			goto read_again;
+
+		sdiohal_cp_rx_sleep(PACKER_RX);
+		sdiohal_unlock_rx_ws();
+		if (p_data->irq_type != SDIOHAL_RX_POLLING)
+			sdiohal_enable_rx_irq();
+	}
+
+	return 0;
+}
diff --git a/drivers/net/wireless/uwe5622/unisocwcn/sdio/sdiohal_tx.c b/drivers/net/wireless/uwe5622/unisocwcn/sdio/sdiohal_tx.c
new file mode 100644
index 000000000000..6ccf92dabe95
--- /dev/null
+++ b/drivers/net/wireless/uwe5622/unisocwcn/sdio/sdiohal_tx.c
@@ -0,0 +1,195 @@
+#include "sdiohal.h"
+
+#define SDIOHAL_TX_RETRY_MAX 3
+#define SDIOHAL_TX_NO_RETRY
+
+static void sdiohal_tx_retrybuf_left(unsigned int suc_pac_cnt)
+{
+	struct sdiohal_data_t *p_data = sdiohal_get_data();
+	unsigned int cnt = 0;
+	struct sdio_puh_t *puh = NULL;
+	unsigned char *p = NULL;
+
+	if (suc_pac_cnt == 0)
+		return;
+
+	puh = (struct sdio_puh_t *)p_data->send_buf.retry_buf;
+	for (cnt = 0; cnt < suc_pac_cnt;) {
+		if (puh->eof == 0) {
+			p = (unsigned char *)puh;
+			cnt++;
+			p_data->send_buf.retry_len =
+				p_data->send_buf.retry_len -
+				sizeof(struct sdio_puh_t) -
+				SDIOHAL_ALIGN_4BYTE(puh->len);
+
+			/* pointer to next packet */
+			p += sizeof(struct sdio_puh_t)
+				+ SDIOHAL_ALIGN_4BYTE(puh->len);
+			puh = (struct sdio_puh_t *)p;
+			p_data->send_buf.retry_buf = (unsigned char *)p;
+		} else
+			break;
+	}
+
+	sdiohal_debug("sdiohal_tx_retrybuf_left [%p] retry_len[%d]\n",
+		      p_data->send_buf.retry_buf,
+		      p_data->send_buf.retry_len);
+}
+
+static int sdiohal_send_try(struct sdiohal_sendbuf_t *send_buf)
+{
+	unsigned int tx_pac_cnt = 0;
+	unsigned int try_cnt = 0;
+	int ret = 0;
+
+#ifdef SDIOHAL_TX_NO_RETRY
+	return 0;
+#endif
+
+	sdiohal_tx_init_retrybuf();
+try_send:
+	try_cnt++;
+	if (try_cnt < SDIOHAL_TX_RETRY_MAX) {
+		tx_pac_cnt = sdiohal_get_trans_pac_num();
+
+		/* get the buf ptr and length right now */
+		sdiohal_tx_retrybuf_left(tx_pac_cnt);
+		usleep_range(4000, 6000);
+
+		ret = sdiohal_sdio_pt_write(send_buf->retry_buf,
+			SDIOHAL_ALIGN_BLK(send_buf->retry_len));
+		if (ret != 0)
+			goto try_send;
+	}
+
+	return 0;
+}
+
+static int sdiohal_send(struct sdiohal_sendbuf_t *send_buf,
+	struct sdiohal_list_t *data_list)
+{
+	int ret = 0;
+
+	if ((!send_buf) || (!data_list))
+		return -EINVAL;
+
+	ret = sdiohal_sdio_pt_write(send_buf->buf,
+		SDIOHAL_ALIGN_BLK(send_buf->used_len));
+	if (ret != 0) {
+		sdiohal_err("tyr send,type:%d subtype:%d node_num:%d\n",
+				data_list->type, data_list->subtype,
+				data_list->node_num);
+		ret = sdiohal_send_try(send_buf);
+	}
+
+	return ret;
+}
+
+int sdiohal_tx_data_list_send(struct sdiohal_list_t *data_list,
+			      bool pop_flag)
+{
+	struct sdiohal_data_t *p_data = sdiohal_get_data();
+	struct mbuf_t *mbuf_node;
+	unsigned int i;
+	int ret = 0;
+
+	sdiohal_sdma_enter();
+	sdiohal_list_check(data_list, __func__, SDIOHAL_WRITE);
+	mbuf_node = data_list->mbuf_head;
+	for (i = 0; i < data_list->node_num;
+		i++, mbuf_node = mbuf_node->next) {
+		if (p_data->send_buf.used_len +
+			sizeof(struct sdio_puh_t) +
+			SDIOHAL_ALIGN_4BYTE(mbuf_node->len)
+				> SDIOHAL_TX_SENDBUF_LEN) {
+			sdiohal_tx_set_eof(&p_data->send_buf,
+					   p_data->eof_buf);
+			ret = sdiohal_send(&p_data->send_buf, data_list);
+			if (ret)
+				sdiohal_err("err1,type:%d subtype:%d num:%d\n",
+					data_list->type, data_list->subtype,
+					data_list->node_num);
+			p_data->send_buf.used_len = 0;
+		}
+		sdiohal_tx_packer(&p_data->send_buf,
+				  data_list, mbuf_node);
+	}
+	sdiohal_tx_set_eof(&p_data->send_buf, p_data->eof_buf);
+
+	if (pop_flag == true)
+		sdiohal_tx_list_denq(data_list);
+	ret = sdiohal_send(&p_data->send_buf, data_list);
+	if (ret)
+		sdiohal_err("err2,type:%d subtype:%d num:%d\n",
+			data_list->type, data_list->subtype,
+			data_list->node_num);
+
+	p_data->send_buf.used_len = 0;
+	sdiohal_sdma_leave();
+
+	return ret;
+}
+
+int sdiohal_tx_thread(void *data)
+{
+	struct sdiohal_data_t *p_data = sdiohal_get_data();
+	struct sdiohal_list_t data_list;
+	struct sched_param param;
+	struct timespec64 tm_begin, tm_end;
+	static long time_total_ns;
+	static int times_count;
+
+	param.sched_priority = SDIO_TX_TASK_PRIO;
+	sched_setscheduler(current, SCHED_FIFO, &param);
+
+	while (1) {
+		/* Wait the semaphore */
+		sdiohal_tx_down();
+		if (p_data->exit_flag)
+			break;
+		if (!WCN_CARD_EXIST(&p_data->xmit_cnt)) {
+			sdiohal_err("%s line %d not have card\n",
+				    __func__, __LINE__);
+			continue;
+		}
+
+		ktime_get_real_ts64(&p_data->tm_end_sch);
+		sdiohal_pr_perf("tx sch time:%ld\n",
+			(long)(timespec64_to_ns(&p_data->tm_end_sch)
+			- timespec64_to_ns(&p_data->tm_begin_sch)));
+		sdiohal_lock_tx_ws();
+		sdiohal_resume_wait();
+
+		/* wakeup cp */
+		sdiohal_cp_tx_wakeup(PACKER_TX);
+
+		while (!sdiohal_is_tx_list_empty()) {
+			ktime_get_real_ts64(&tm_begin);
+
+			sdiohal_tx_find_data_list(&data_list);
+			if (p_data->adma_tx_enable) {
+				sdiohal_adma_pt_write(&data_list);
+				sdiohal_tx_list_denq(&data_list);
+			} else
+				sdiohal_tx_data_list_send(&data_list, true);
+
+			ktime_get_real_ts64(&tm_end);
+			time_total_ns += timespec64_to_ns(&tm_end)
+				- timespec64_to_ns(&tm_begin);
+			times_count++;
+			if (!(times_count % PERFORMANCE_COUNT)) {
+				sdiohal_pr_perf("tx list avg time:%ld\n",
+					(time_total_ns / PERFORMANCE_COUNT));
+				time_total_ns = 0;
+				times_count = 0;
+			}
+		}
+
+		sdiohal_cp_tx_sleep(PACKER_TX);
+		sdiohal_unlock_tx_ws();
+	}
+
+	return 0;
+}
+
diff --git a/drivers/net/wireless/uwe5622/unisocwcn/sleep/sdio_int.c b/drivers/net/wireless/uwe5622/unisocwcn/sleep/sdio_int.c
new file mode 100644
index 000000000000..b054c0ff4a6e
--- /dev/null
+++ b/drivers/net/wireless/uwe5622/unisocwcn/sleep/sdio_int.c
@@ -0,0 +1,353 @@
+#include <linux/device.h>
+#include <linux/err.h>
+#include <linux/export.h>
+#include <linux/gpio.h>
+#include <linux/irq.h>
+#include <linux/interrupt.h>
+#include <linux/kthread.h>
+#include <linux/module.h>
+#include <linux/spinlock.h>
+#include <marlin_platform.h>
+#include <wcn_bus.h>
+#include "sdio_int.h"
+#include "slp_mgr.h"
+#include "slp_sdio.h"
+#include "wcn_glb.h"
+#include "../sdio/sdiohal.h"
+
+struct sdio_int_t sdio_int = {0};
+
+atomic_t flag_pub_int_done;
+bool sdio_power_notify = FALSE;
+
+static inline int sdio_pub_int_clr0(unsigned char int_sts0)
+{
+	return sprdwcn_bus_aon_writeb(sdio_int.pub_int_clr0,
+			int_sts0);
+}
+
+bool sdio_get_power_notify(void)
+{
+	return sdio_power_notify;
+}
+
+void sdio_record_power_notify(bool notify_cb_sts)
+{
+	sdio_power_notify = notify_cb_sts;
+}
+
+void sdio_wait_pub_int_done(void)
+{
+	struct slp_mgr_t *slp_mgr;
+	int wait_cnt = 0;
+
+	if (sdio_int.pub_int_num <= 0)
+		return;
+
+	slp_mgr = slp_get_info();
+
+	if (sdio_power_notify) {
+		/* enter suspend, means no tx data to cp2, so set sleep*/
+		mutex_lock(&(slp_mgr->drv_slp_lock));
+		if (atomic_read(&(slp_mgr->cp2_state)) == STAY_AWAKING) {
+			SLP_MGR_INFO("allow sleep1\n");
+			slp_allow_sleep();
+			atomic_set(&(slp_mgr->cp2_state), STAY_SLPING);
+		}
+		mutex_unlock(&(slp_mgr->drv_slp_lock));
+
+		/* wait pub_int handle finish*/
+		while ((atomic_read(&flag_pub_int_done) == 0) &&
+		       (wait_cnt < 10)) {
+			wait_cnt++;
+			SLP_MGR_INFO("wait pub_int_done:%d", wait_cnt);
+			usleep_range(1500, 3000);
+		}
+		SLP_MGR_INFO("flag_pub_int_done-%d",
+			atomic_read(&flag_pub_int_done));
+	} else
+		SLP_MGR_INFO("sdio power_notify is NULL");
+}
+EXPORT_SYMBOL(sdio_wait_pub_int_done);
+
+int pub_int_handle_thread(void *data)
+{
+	union PUB_INT_STS0_REG pub_int_sts0 = {0};
+	int bit_num, ret;
+
+	while (!kthread_should_stop()) {
+		/* wait_for_completion may cause hung_task_timeout_secs
+		 * with message of task blocked for more than 120 seconds.
+		 */
+		wait_for_completion_interruptible(
+			&(sdio_int.pub_int_completion));
+
+		ret = sprdwcn_bus_aon_readb(sdio_int.pub_int_sts0,
+			&(pub_int_sts0.reg));
+		/* sdio cmd52 fail, it should be chip power off */
+		if (ret < 0)
+			SLP_MGR_INFO("sdio cmd52 fail, ret-%d", ret);
+		else {
+			SLP_MGR_INFO("PUB_INT_STS0-0x%x\n", pub_int_sts0.reg);
+			sdio_pub_int_clr0(pub_int_sts0.reg);
+
+			bit_num = 0;
+			do {
+				if ((pub_int_sts0.reg & BIT(bit_num)) &&
+					sdio_int.pub_int_cb[bit_num]) {
+					sdio_int.pub_int_cb[bit_num]();
+				}
+				bit_num++;
+			} while (bit_num < PUB_INT_MAX);
+		}
+
+		if (sdio_power_notify)
+			atomic_set(&flag_pub_int_done, 1);
+		else {
+			__pm_relax(sdio_int.pub_int_ws);
+		}
+
+		/* enable interrupt, balance with disable in pub_int_isr */
+		if (atomic_read(&(sdio_int.chip_power_on)))
+			enable_irq(sdio_int.pub_int_num);
+	}
+
+	return 0;
+}
+
+static int irq_cnt;
+static irqreturn_t pub_int_isr(int irq, void *para)
+{
+	disable_irq_nosync(irq);
+	/*
+	 * for wifi powersave special handle, when wifi driver send
+	 * power save cmd to cp2, then pub int can't take wakelock,
+	 * or ap can't enter deep sleep.
+	 */
+	if (sdio_power_notify)
+		atomic_set(&flag_pub_int_done, 0);
+	else {
+		__pm_stay_awake(sdio_int.pub_int_ws);
+	}
+
+	irq_cnt++;
+	SLP_MGR_INFO("irq_cnt%d!!", irq_cnt);
+
+	complete(&(sdio_int.pub_int_completion));
+
+	return IRQ_HANDLED;
+}
+
+static struct task_struct *pub_int_handle_task;
+static int sdio_isr_handle_init(void)
+{
+	if (!pub_int_handle_task)
+		pub_int_handle_task = kthread_create(pub_int_handle_thread,
+			NULL, "pub_int_handle_thread");
+	if (pub_int_handle_task != 0) {
+		wake_up_process(pub_int_handle_task);
+		return 0;
+	}
+
+	SLP_MGR_INFO("%s ok!\n", __func__);
+
+	return -1;
+}
+
+static int sdio_pub_int_register(int irq)
+{
+	int ret = 0;
+
+	SLP_MGR_INFO("public_int, gpio-%d\n", irq);
+
+	if (irq <= 0)
+		return ret;
+
+	ret = gpio_direction_input(irq);
+	if (ret < 0) {
+		SLP_MGR_ERR("public_int, gpio-%d input set fail!!!", irq);
+		return ret;
+	}
+
+	sdio_int.pub_int_num = gpio_to_irq(irq);
+	SLP_MGR_INFO("public_int, intnum-%d\n", sdio_int.pub_int_num);
+
+	ret = request_irq(sdio_int.pub_int_num,
+			pub_int_isr,
+			IRQF_TRIGGER_HIGH | IRQF_NO_SUSPEND,
+			"pub_int_isr",
+			NULL);
+	if (ret != 0) {
+		SLP_MGR_ERR("req irq-%d err!!!", sdio_int.pub_int_num);
+		return ret;
+	}
+
+	/* enable interrupt when chip power on */
+	disable_irq(sdio_int.pub_int_num);
+
+	return ret;
+}
+
+int sdio_ap_int_cp0(enum AP_INT_CP_BIT bit)
+{
+	union AP_INT_CP0_REG reg_int_cp0 = {0};
+
+	switch (bit) {
+
+	case ALLOW_CP_SLP:
+		reg_int_cp0.bit.allow_cp_slp = 1;
+		break;
+
+	case WIFI_BIN_DOWNLOAD:
+		reg_int_cp0.bit.wifi_bin_download = 1;
+		break;
+
+	case BT_BIN_DOWNLOAD:
+		reg_int_cp0.bit.bt_bin_download = 1;
+		break;
+	case SAVE_CP_MEM:
+		reg_int_cp0.bit.save_cp_mem = 1;
+		break;
+	case TEST_DEL_THREAD:
+		reg_int_cp0.bit.test_delet_thread = 1;
+		break;
+
+	default:
+		SLP_MGR_INFO("ap_int_cp bit error");
+		break;
+	}
+
+	return sprdwcn_bus_aon_writeb(sdio_int.ap_int_cp0,
+			reg_int_cp0.reg);
+}
+EXPORT_SYMBOL(sdio_ap_int_cp0);
+
+int sdio_pub_int_RegCb(enum PUB_INT_BIT bit,
+		PUB_INT_ISR isr_handler)
+{
+	if (sdio_int.pub_int_num <= 0)
+		return 0;
+
+	if (isr_handler == NULL) {
+		SLP_MGR_ERR("pub_int_RegCb error !!");
+		return -1;
+	}
+
+	sdio_int.pub_int_cb[bit] = isr_handler;
+
+	SLP_MGR_INFO("0X%x pub_int_RegCb", bit);
+
+	return 0;
+}
+EXPORT_SYMBOL(sdio_pub_int_RegCb);
+
+int sdio_pub_int_btwf_en0(void)
+{
+	union PUB_INT_EN0_REG reg_int_en = {0};
+
+	if (sdio_int.pub_int_num <= 0)
+		return 0;
+
+	sprdwcn_bus_aon_readb(sdio_int.pub_int_en0, &(reg_int_en.reg));
+
+	reg_int_en.bit.req_slp = 1;
+	reg_int_en.bit.mem_save_bin = 1;
+	reg_int_en.bit.wifi_open = 1;
+	reg_int_en.bit.bt_open = 1;
+	reg_int_en.bit.wifi_close = 1;
+	reg_int_en.bit.bt_close = 1;
+	sprdwcn_bus_aon_writeb(sdio_int.pub_int_en0, reg_int_en.reg);
+
+	SLP_MGR_INFO("%s ok!\n", __func__);
+
+	return 0;
+}
+EXPORT_SYMBOL(sdio_pub_int_btwf_en0);
+
+int sdio_pub_int_gnss_en0(void)
+{
+	union PUB_INT_EN0_REG reg_int_en = {0};
+
+	if (sdio_int.pub_int_num <= 0)
+		return 0;
+
+	sprdwcn_bus_aon_readb(sdio_int.pub_int_en0, &(reg_int_en.reg));
+
+	reg_int_en.bit.gnss_cali_done = 1;
+
+	sprdwcn_bus_aon_writeb(sdio_int.pub_int_en0, reg_int_en.reg);
+
+	SLP_MGR_INFO("%s ok!\n", __func__);
+
+	return 0;
+}
+EXPORT_SYMBOL(sdio_pub_int_gnss_en0);
+
+
+void sdio_pub_int_poweron(bool state)
+{
+	if (sdio_int.pub_int_num <= 0)
+		return;
+
+	atomic_set(&(sdio_int.chip_power_on), state);
+
+	if (state)
+		enable_irq(sdio_int.pub_int_num);
+	else {
+		disable_irq(sdio_int.pub_int_num);
+		reinit_completion(&(sdio_int.pub_int_completion));
+	}
+}
+EXPORT_SYMBOL(sdio_pub_int_poweron);
+
+int sdio_pub_int_init(int irq)
+{
+	if (irq <= 0) {
+		sdio_int.pub_int_num = 0;
+		return 0;
+	}
+
+	sdio_int.cp_slp_ctl = REG_CP_SLP_CTL;
+	sdio_int.ap_int_cp0 = REG_AP_INT_CP0;
+	sdio_int.pub_int_en0 = REG_PUB_INT_EN0;
+	sdio_int.pub_int_clr0 = REG_PUB_INT_CLR0;
+	sdio_int.pub_int_sts0 = REG_PUB_INT_STS0;
+
+	atomic_set(&flag_pub_int_done, 1);
+	sdio_int.pub_int_ws = wakeup_source_register(NULL, "pub_int_ws");
+	init_completion(&(sdio_int.pub_int_completion));
+
+	sdio_pub_int_register(irq);
+
+	sdio_isr_handle_init();
+
+	SLP_MGR_INFO("%s ok!\n", __func__);
+
+	return 0;
+}
+EXPORT_SYMBOL(sdio_pub_int_init);
+
+int sdio_pub_int_deinit(void)
+{
+	if (sdio_int.pub_int_num <= 0)
+		return 0;
+
+	atomic_set(&flag_pub_int_done, 1);
+	if (pub_int_handle_task) {
+		disable_irq(sdio_int.pub_int_num);
+		complete(&(sdio_int.pub_int_completion));
+		kthread_stop(pub_int_handle_task);
+		pub_int_handle_task = NULL;
+	}
+
+	sdio_power_notify = FALSE;
+	disable_irq(sdio_int.pub_int_num);
+	free_irq(sdio_int.pub_int_num, NULL);
+	wakeup_source_unregister(sdio_int.pub_int_ws);
+
+	SLP_MGR_INFO("%s ok!\n", __func__);
+
+	return 0;
+}
+EXPORT_SYMBOL(sdio_pub_int_deinit);
+
diff --git a/drivers/net/wireless/uwe5622/unisocwcn/sleep/sdio_int.h b/drivers/net/wireless/uwe5622/unisocwcn/sleep/sdio_int.h
new file mode 100644
index 000000000000..2e92aaae28f4
--- /dev/null
+++ b/drivers/net/wireless/uwe5622/unisocwcn/sleep/sdio_int.h
@@ -0,0 +1,127 @@
+#ifndef __SDIO_INT_H__
+#define __SDIO_INT_H__
+#include <linux/device.h>
+#include <linux/version.h>
+
+#define SLP_MGR_HEADER "[slp_mgr]"
+
+#define SLP_MGR_ERR(fmt, args...)	\
+	pr_err(SLP_MGR_HEADER fmt "\n", ## args)
+#define SLP_MGR_INFO(fmt, args...)	\
+	pr_info(SLP_MGR_HEADER fmt "\n", ## args)
+#define SLP_MGR_DBG(fmt, args...)	\
+	pr_debug(SLP_MGR_HEADER fmt "\n", ## args)
+
+
+extern struct sdio_int_t sdio_int;
+
+typedef void (*PUB_INT_ISR)(void);
+enum AP_INT_CP_BIT {
+	ALLOW_CP_SLP,
+	WIFI_BIN_DOWNLOAD,
+	BT_BIN_DOWNLOAD,
+	SAVE_CP_MEM,
+	TEST_DEL_THREAD,
+	AP_SUSPEND,
+	AP_RESUME,
+
+	INT_CP_MAX = 8,
+};
+
+enum PUB_INT_BIT {
+	MEM_SAVE_BIN,
+	WAKEUP_ACK,
+	REQ_SLP,
+	WIFI_OPEN,
+	BT_OPEN,
+	WIFI_CLOSE,
+	BT_CLOSE,
+	GNSS_CALI_DONE,
+
+	PUB_INT_MAX = 8,
+};
+
+union AP_INT_CP0_REG {
+	unsigned char reg;
+	struct {
+		unsigned char allow_cp_slp:1;
+		unsigned char wifi_bin_download:1;
+		unsigned char bt_bin_download:1;
+		unsigned char save_cp_mem:1;
+		unsigned char test_delet_thread:1;
+		unsigned char rsvd:3;
+	} bit;
+};
+
+union PUB_INT_EN0_REG {
+	unsigned char reg;
+	struct {
+		unsigned char mem_save_bin:1;
+		unsigned char wakeup_ack:1;
+		unsigned char req_slp:1;
+		unsigned char wifi_open:1;
+		unsigned char bt_open:1;
+		unsigned char wifi_close:1;
+		unsigned char bt_close:1;
+		unsigned char gnss_cali_done:1;
+	} bit;
+};
+
+union PUB_INT_CLR0_REG {
+	unsigned char reg;
+	struct {
+		unsigned char mem_save_bin:1;
+		unsigned char wakeup_ack:1;
+		unsigned char req_slp:1;
+		unsigned char wifi_open:1;
+		unsigned char bt_open:1;
+		unsigned char wifi_close:1;
+		unsigned char bt_close:1;
+		unsigned char gnss_cali_done:1;
+	} bit;
+};
+
+union PUB_INT_STS0_REG {
+	unsigned char reg;
+	struct {
+		unsigned char mem_save_bin:1;
+		unsigned char wakeup_ack:1;
+		unsigned char req_slp:1;
+		unsigned char wifi_open:1;
+		unsigned char bt_open:1;
+		unsigned char wifi_close:1;
+		unsigned char bt_close:1;
+		unsigned char gnss_cali_done:1;
+	} bit;
+};
+
+struct sdio_int_t {
+	unsigned int cp_slp_ctl;
+	unsigned int ap_int_cp0;
+	unsigned int pub_int_en0;
+	unsigned int pub_int_clr0;
+	unsigned int pub_int_sts0;
+	PUB_INT_ISR pub_int_cb[PUB_INT_MAX];
+	struct wakeup_source *pub_int_ws;
+	struct completion pub_int_completion;
+	unsigned int pub_int_num;
+	/* 1: power on, 0: power off */
+	atomic_t chip_power_on;
+};
+
+/* add start, for power save handle */
+bool sdio_get_power_notify(void);
+void sdio_record_power_notify(bool notify_cb_sts);
+void sdio_wait_pub_int_done(void);
+/* add end */
+
+int sdio_ap_int_cp0(enum AP_INT_CP_BIT bit);
+/* pub int api */
+int sdio_pub_int_btwf_en0(void);
+int sdio_pub_int_gnss_en0(void);
+int sdio_pub_int_RegCb(enum PUB_INT_BIT bit,
+		PUB_INT_ISR isr_handler);
+void sdio_pub_int_poweron(bool state);
+int sdio_pub_int_init(int irq);
+int sdio_pub_int_deinit(void);
+#endif
diff --git a/drivers/net/wireless/uwe5622/unisocwcn/sleep/slp_mgr.c b/drivers/net/wireless/uwe5622/unisocwcn/sleep/slp_mgr.c
new file mode 100644
index 000000000000..d95967c51b22
--- /dev/null
+++ b/drivers/net/wireless/uwe5622/unisocwcn/sleep/slp_mgr.c
@@ -0,0 +1,202 @@
+/*
+ * Copyright (C) 2013 Spreadtrum Communications Inc.
+ *
+ * Filename : slp_mgr.c
+ * Abstract : This file is a implementation for  sleep manager
+ *
+ * Authors	: sam.sun
+ *
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+#include <linux/delay.h>
+#include <linux/init.h>
+#include <linux/interrupt.h>
+#include <linux/irq.h>
+#include <linux/kernel.h>
+#include <linux/kthread.h>
+#include <linux/module.h>
+#include <linux/of.h>
+#include <linux/of_gpio.h>
+#include <linux/of_device.h>
+#include <linux/platform_device.h>
+#include <linux/spinlock.h>
+#include <linux/version.h>
+#include <wcn_bus.h>
+#include "../sdio/sdiohal.h"
+#include "slp_mgr.h"
+#include "slp_sdio.h"
+#include "wcn_glb.h"
+
+struct slp_mgr_t slp_mgr;
+
+struct slp_mgr_t *slp_get_info(void)
+{
+	return &slp_mgr;
+}
+
+void slp_mgr_drv_sleep(enum slp_subsys subsys, bool enable)
+{
+	mutex_lock(&(slp_mgr.drv_slp_lock));
+	if (enable)
+		slp_mgr.active_module &= ~(BIT(subsys));
+	else
+		slp_mgr.active_module |= (BIT(subsys));
+	if (slp_mgr.active_module == 0) {
+		/* If pubint pin is valid (not used as bt_wake_host pin),
+		 * packet mode will enter sleep when pub int irq coming.
+		 */
+		if (marlin_get_bt_wl_wake_host_en()) {
+			slp_allow_sleep();
+			atomic_set(&(slp_mgr.cp2_state), STAY_SLPING);
+		} else if (subsys > PACKER_DT_RX) {
+			slp_allow_sleep();
+			atomic_set(&(slp_mgr.cp2_state), STAY_SLPING);
+		}
+	}
+	mutex_unlock(&(slp_mgr.drv_slp_lock));
+}
+
+int slp_mgr_wakeup(enum slp_subsys subsys)
+{
+	unsigned char slp_sts;
+	int ret;
+	int do_dump = 0;
+	ktime_t time_end;
+#if KERNEL_VERSION(3, 16, 75) > LINUX_VERSION_CODE
+	ktime_t time_cmp;
+#endif
+
+	mutex_lock(&(slp_mgr.wakeup_lock));
+	if (STAY_SLPING == (atomic_read(&(slp_mgr.cp2_state)))) {
+		ap_wakeup_cp();
+		time_end = ktime_add_ms(ktime_get(), 10);
+#ifndef CONFIG_CHECK_DRIVER_BY_CHIPID
+#ifdef CONFIG_UWE5623
+		/*select btwf_slp_status*/
+		sprdwcn_bus_aon_writeb(REG_CP_PMU_SEL_CTL, 6);
+#endif
+#else /*CONFIG_CHECK_DRIVER_BY_CHIPID*/
+		if (wcn_get_chip_model() == WCN_CHIP_MARLIN3E)
+			sprdwcn_bus_aon_writeb(REG_CP_PMU_SEL_CTL, 6);
+#endif
+		while (1) {
+			ret = sprdwcn_bus_aon_readb(REG_BTWF_SLP_STS, &slp_sts);
+			if (ret < 0) {
+				SLP_MGR_ERR("read slp sts err:%d", ret);
+				usleep_range(40, 80);
+				goto try_timeout;
+			}
+
+			slp_sts &= SLEEP_STATUS_FLAG;
+#ifndef CONFIG_CHECK_DRIVER_BY_CHIPID
+			if ((slp_sts != BTWF_IN_DEEPSLEEP) &&
+			   (slp_sts != BTWF_IN_DEEPSLEEP_XLT_ON) &&
+#if defined(CONFIG_UWE5622) || defined(CONFIG_UWE5623)
+			   (slp_sts != BTWF_PLL_PWR_WAIT) &&
+			   (slp_sts != BTWF_XLT_WAIT) &&
+			   (slp_sts != BTWF_XLTBUF_WAIT))
+#else
+			   (slp_sts != BTWF_IN_DEEPSLEEP_XLT_ON))
+#endif
+			{
+#if defined(CONFIG_UWE5623)
+				unsigned int reg_val = 0;
+
+				sprdwcn_bus_reg_read(CP_WAKE_STATUS,
+						     &reg_val, 4);
+				if ((reg_val & BIT(31)) == 0)
+#endif
+					break;
+			}
+#else
+			if ((slp_sts != BTWF_IN_DEEPSLEEP) &&
+			   (slp_sts != BTWF_IN_DEEPSLEEP_XLT_ON) &&
+			   ((((wcn_get_chip_model() == WCN_CHIP_MARLIN3E) ||
+			   (wcn_get_chip_model() == WCN_CHIP_MARLIN3L)) &&
+			   (slp_sts != BTWF_PLL_PWR_WAIT) &&
+			   (slp_sts != BTWF_XLT_WAIT) &&
+			   (slp_sts != BTWF_XLTBUF_WAIT)) ||
+			   (wcn_get_chip_model() == WCN_CHIP_MARLIN3))) {
+				if (wcn_get_chip_model() ==
+					WCN_CHIP_MARLIN3E) {
+					unsigned int reg_val = 0;
+
+					sprdwcn_bus_reg_read(CP_WAKE_STATUS,
+							     &reg_val, 4);
+					if ((reg_val & BIT(31)) == 0)
+						break;
+				} else
+					break;
+			}
+#endif
+try_timeout:
+			//SLP_MGR_INFO("slp_sts-0x%x", slp_sts);
+			if (do_dump) {
+				atomic_set(&(slp_mgr.cp2_state), STAY_AWAKING);
+				SLP_MGR_INFO("wakeup fail, slp_sts-0x%x",
+					     slp_sts);
+				sdiohal_dump_aon_reg();
+				mutex_unlock(&(slp_mgr.wakeup_lock));
+				return -1;
+			}
+#if KERNEL_VERSION(3, 16, 75) <= LINUX_VERSION_CODE
+			/* kernelv3.16.75 add ktime_after function. */
+			if (ktime_after(ktime_get(), time_end))
+				do_dump = 1;
+#else
+			time_cmp = ktime_get();
+			if (time_cmp.tv64 > time_end.tv64)
+				do_dump = 1;
+#endif
+		}
+
+		atomic_set(&(slp_mgr.cp2_state), STAY_AWAKING);
+	}
+	mutex_unlock(&(slp_mgr.wakeup_lock));
+
+	return 0;
+}
+
+/* called after chip power on, and reset sleep status */
+void slp_mgr_reset(void)
+{
+	atomic_set(&(slp_mgr.cp2_state), STAY_AWAKING);
+	reinit_completion(&(slp_mgr.wakeup_ack_completion));
+}
+
+int slp_mgr_init(void)
+{
+	SLP_MGR_DBG("%s enter\n", __func__);
+
+	atomic_set(&(slp_mgr.cp2_state), STAY_AWAKING);
+	mutex_init(&(slp_mgr.drv_slp_lock));
+	mutex_init(&(slp_mgr.wakeup_lock));
+	init_completion(&(slp_mgr.wakeup_ack_completion));
+	slp_pub_int_RegCb();
+
+	SLP_MGR_DBG("%s ok!\n", __func__);
+
+	return 0;
+}
+EXPORT_SYMBOL(slp_mgr_init);
+
+int slp_mgr_deinit(void)
+{
+	SLP_MGR_DBG("%s enter\n", __func__);
+	atomic_set(&(slp_mgr.cp2_state), STAY_SLPING);
+	slp_mgr.active_module = 0;
+	mutex_destroy(&(slp_mgr.drv_slp_lock));
+	mutex_destroy(&(slp_mgr.wakeup_lock));
+	SLP_MGR_DBG("%s ok!\n", __func__);
+
+	return 0;
+}
+EXPORT_SYMBOL(slp_mgr_deinit);
diff --git a/drivers/net/wireless/uwe5622/unisocwcn/sleep/slp_mgr.h b/drivers/net/wireless/uwe5622/unisocwcn/sleep/slp_mgr.h
new file mode 100644
index 000000000000..8447b031c63d
--- /dev/null
+++ b/drivers/net/wireless/uwe5622/unisocwcn/sleep/slp_mgr.h
@@ -0,0 +1,52 @@
+/*
+ * Copyright (C) 2013 Spreadtrum Communications Inc.
+ *
+ * Filename : slp_mgr.h
+ * Abstract : This file is a implementation for itm sipc command/event function
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+#ifndef __SLP_MGR_H__
+#define __SLP_MGR_H__
+
+#include <linux/completion.h>
+#include <marlin_platform.h>
+#include <wcn_bus.h>
+
+#define SLP_MGR_HEADER "[slp_mgr]"
+#define SLP_MGR_ERR(fmt, args...)	\
+	pr_err(SLP_MGR_HEADER fmt "\n", ## args)
+#define SLP_MGR_INFO(fmt, args...)	\
+	pr_info(SLP_MGR_HEADER fmt "\n", ## args)
+#define SLP_MGR_DBG(fmt, args...)	\
+	pr_debug(SLP_MGR_HEADER fmt "\n", ## args)
+
+/* cp2 sleep status */
+#define	STAY_SLPING		0
+#define	STAY_AWAKING	1
+
+#define	WAKEUP_RTY_CNT	50
+
+struct slp_mgr_t {
+	struct mutex    drv_slp_lock;
+	struct mutex    wakeup_lock;
+	struct completion wakeup_ack_completion;
+	unsigned int active_module;
+	atomic_t  cp2_state;
+};
+
+struct slp_mgr_t *slp_get_info(void);
+int slp_mgr_init(void);
+int slp_mgr_deinit(void);
+void slp_mgr_drv_sleep(enum slp_subsys subsys, bool enable);
+int slp_mgr_wakeup(enum slp_subsys subsys);
+void slp_mgr_reset(void);
+
+#endif
diff --git a/drivers/net/wireless/uwe5622/unisocwcn/sleep/slp_sdio.c b/drivers/net/wireless/uwe5622/unisocwcn/sleep/slp_sdio.c
new file mode 100644
index 000000000000..abab04b96a40
--- /dev/null
+++ b/drivers/net/wireless/uwe5622/unisocwcn/sleep/slp_sdio.c
@@ -0,0 +1,67 @@
+#include <linux/delay.h>
+#include <linux/err.h>
+#include <linux/export.h>
+#include <linux/gpio.h>
+#include <linux/interrupt.h>
+#include <linux/irq.h>
+#include <linux/kthread.h>
+#include <linux/module.h>
+#include <linux/spinlock.h>
+#include <wcn_bus.h>
+#include "sdio_int.h"
+#include "slp_mgr.h"
+#include "slp_sdio.h"
+#include "wcn_glb.h"
+
+int slp_allow_sleep(void)
+{
+	union CP_SLP_CTL_REG reg_slp_ctl = {0};
+
+	reg_slp_ctl.bit.cp_slp_ctl = 1;
+	sprdwcn_bus_aon_writeb(REG_CP_SLP_CTL, reg_slp_ctl.reg);
+
+	sdio_ap_int_cp0(ALLOW_CP_SLP);
+	/* make SLP_CTL high_level keep 2 cycle of 32khz */
+	udelay(65);
+	return 0;
+}
+
+static void req_slp_isr(void)
+{
+	struct slp_mgr_t *slp_mgr;
+
+	slp_mgr = slp_get_info();
+	mutex_lock(&(slp_mgr->drv_slp_lock));
+	/* allow sleep */
+	if (slp_mgr->active_module == 0) {
+		SLP_MGR_INFO("allow sleep\n");
+		slp_allow_sleep();
+
+		atomic_set(&(slp_mgr->cp2_state), STAY_SLPING);
+	} else {
+		SLP_MGR_INFO("forbid slp module-0x%x\n",
+			slp_mgr->active_module);
+	}
+	mutex_unlock(&(slp_mgr->drv_slp_lock));
+}
+
+static void wakeup_ack_isr(void)
+{
+	struct slp_mgr_t *slp_mgr;
+
+	slp_mgr = slp_get_info();
+	if (STAY_SLPING == (atomic_read(&(slp_mgr->cp2_state)))) {
+		SLP_MGR_INFO("wakeup ack");
+		complete(&(slp_mgr->wakeup_ack_completion));
+	} else
+		SLP_MGR_INFO("discard wakeup ack");
+}
+
+int slp_pub_int_RegCb(void)
+{
+	sdio_pub_int_RegCb(WAKEUP_ACK, (PUB_INT_ISR)wakeup_ack_isr);
+	sdio_pub_int_RegCb(REQ_SLP, (PUB_INT_ISR)req_slp_isr);
+
+	return 0;
+}
+
diff --git a/drivers/net/wireless/uwe5622/unisocwcn/sleep/slp_sdio.h b/drivers/net/wireless/uwe5622/unisocwcn/sleep/slp_sdio.h
new file mode 100644
index 000000000000..b0e2cca011b9
--- /dev/null
+++ b/drivers/net/wireless/uwe5622/unisocwcn/sleep/slp_sdio.h
@@ -0,0 +1,22 @@
+#ifndef __SLP_SDIO_H__
+#define __SLP_SDIO_H__
+#include "sdio_int.h"
+#include "wcn_glb.h"
+
+union CP_SLP_CTL_REG {
+	unsigned char reg;
+	struct {
+		unsigned char cp_slp_ctl:1;  /* 0:wakeup, 1:sleep */
+		unsigned char rsvd:7;
+	} bit;
+};
+
+static inline
+int ap_wakeup_cp(void)
+{
+	return sprdwcn_bus_aon_writeb(REG_CP_SLP_CTL, 0);
+}
+int slp_allow_sleep(void);
+int slp_pub_int_RegCb(void);
+
+#endif
diff --git a/drivers/net/wireless/uwe5622/unisocwcn/wcn_bus.c b/drivers/net/wireless/uwe5622/unisocwcn/wcn_bus.c
new file mode 100644
index 000000000000..3306d9c609ed
--- /dev/null
+++ b/drivers/net/wireless/uwe5622/unisocwcn/wcn_bus.c
@@ -0,0 +1,311 @@
+/*
+ * Copyright (C) 2017 Spreadtrum Communications Inc.
+ *
+ * Authors	: jinglong.chen
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include <linux/kernel.h>
+#include <linux/mutex.h>
+#include <linux/slab.h>
+#include <linux/spinlock.h>
+#include <wcn_bus.h>
+
+struct buffer_pool_t {
+	int size;
+	int free;
+	int payload;
+	void *head;
+	char *mem;
+	spinlock_t lock;
+};
+
+struct chn_info_t {
+	struct mchn_ops_t *ops[CHN_MAX_NUM];
+	struct mutex callback_lock[CHN_MAX_NUM];
+	struct buffer_pool_t pool[CHN_MAX_NUM];
+};
+
+static struct sprdwcn_bus_ops *wcn_bus_ops;
+
+static struct chn_info_t g_chn_info;
+static struct chn_info_t *chn_info(void)
+{
+	return &g_chn_info;
+}
+
+static int buf_list_check(struct buffer_pool_t *pool,
+			  struct mbuf_t *head, struct mbuf_t *tail, int num)
+{
+	int i;
+	struct mbuf_t *mbuf;
+
+	if (num == 0)
+		return 0;
+	for (i = 0, mbuf = head; i < num; i++) {
+		if ((i == (num - 1)) && (mbuf != tail)) {
+			pr_err("%s(0x%lx, 0x%lx, %d), err 1\n", __func__,
+				(unsigned long)virt_to_phys(head),
+				(unsigned long)virt_to_phys(tail), num);
+			WARN_ON(1);
+		}
+		WARN_ON(!mbuf);
+		WARN_ON((char *)mbuf < pool->mem ||
+			(char *)mbuf > pool->mem + ((sizeof(struct mbuf_t)
+			+ pool->payload) * pool->size));
+		mbuf = mbuf->next;
+	}
+
+	if (tail->next != NULL) {
+		pr_err("%s(0x%lx, 0x%lx, %d), err 2\n", __func__,
+			(unsigned long)virt_to_phys(head),
+			(unsigned long)virt_to_phys(tail), num);
+		WARN_ON(1);
+	}
+
+	return 0;
+}
+
+static int buf_pool_check(struct buffer_pool_t *pool)
+{
+	int i;
+	struct mbuf_t *mbuf;
+
+	for (i = 0, mbuf = pool->head;
+	     i < pool->free; i++, mbuf = mbuf->next) {
+		WARN_ON(!mbuf);
+		WARN_ON((char *)mbuf < pool->mem ||
+			(char *)mbuf > pool->mem + ((sizeof(struct mbuf_t)
+			+ pool->payload) * pool->size));
+	}
+
+	if (mbuf != NULL) {
+		pr_err("%s(0x%p) err\n", __func__, pool);
+		WARN_ON(1);
+	}
+
+	return 0;
+}
+
+static int buf_pool_init(struct buffer_pool_t *pool, int size, int payload)
+{
+	int i;
+	struct mbuf_t *mbuf, *next;
+
+	pool->size = size;
+	pool->payload = payload;
+	spin_lock_init(&(pool->lock));
+	pool->mem = kzalloc((sizeof(struct mbuf_t) + payload) * size,
+			    GFP_KERNEL);
+	if (!pool->mem)
+		return -ENOMEM;
+
+	pool->head = (struct mbuf_t *) (pool->mem);
+	for (i = 0, mbuf = (struct mbuf_t *)(pool->head);
+	     i < (size - 1); i++) {
+		mbuf->seq = i;
+		next = (struct mbuf_t *)((char *)mbuf +
+			sizeof(struct mbuf_t) + payload);
+		mbuf->buf = (char *)mbuf + sizeof(struct mbuf_t);
+		mbuf->len = payload;
+		mbuf->next = next;
+		mbuf = next;
+	}
+	mbuf->seq = i;
+	mbuf->buf = (char *)mbuf + sizeof(struct mbuf_t);
+	mbuf->len = payload;
+	mbuf->next = NULL;
+	pool->free = size;
+
+	return 0;
+}
+
+static int buf_pool_deinit(struct buffer_pool_t *pool)
+{
+	memset(pool->mem, 0x00,
+	       (sizeof(struct mbuf_t) + pool->payload) * pool->size);
+	kfree(pool->mem);
+	pool->mem = NULL;
+
+	return 0;
+}
+
+int buf_list_alloc(int chn, struct mbuf_t **head,
+		   struct mbuf_t **tail, int *num)
+{
+	int i;
+	struct buffer_pool_t *pool;
+	struct mbuf_t *cur, *temp_head, *temp_tail = NULL;
+	struct chn_info_t *chn_inf = chn_info();
+
+	pool = &(chn_inf->pool[chn]);
+
+	if ((*num <= 0) || (pool->free <= 0)) {
+		pr_err("[+]%s err, chn:%d num %d, free %d)\n",
+			__func__, chn, *num, pool->free);
+		*num = 0;
+		*head = *tail = NULL;
+		return -1;
+	}
+
+	spin_lock_bh(&(pool->lock));
+	buf_pool_check(pool);
+	if (*num > pool->free)
+		*num = pool->free;
+
+	for (i = 0, cur = temp_head = pool->head; i < *num; i++) {
+		if (i == (*num - 1))
+			temp_tail = cur;
+		cur = cur->next;
+	}
+	*head = temp_head;
+	if (temp_tail)
+		temp_tail->next = NULL;
+	*tail = temp_tail;
+	pool->free -= *num;
+	pool->head = cur;
+	buf_list_check(pool, *head, *tail, *num);
+	spin_unlock_bh(&(pool->lock));
+
+	return 0;
+}
+EXPORT_SYMBOL(buf_list_alloc);
+
+int buf_list_is_empty(int chn)
+{
+	struct buffer_pool_t *pool;
+	struct chn_info_t *chn_inf = chn_info();
+
+	pool = &(chn_inf->pool[chn]);
+	return pool->free <= 0;
+}
+EXPORT_SYMBOL(buf_list_is_empty);
+
+int buf_list_is_full(int chn)
+{
+	struct buffer_pool_t *pool;
+	struct chn_info_t *chn_inf = chn_info();
+
+	pool = &(chn_inf->pool[chn]);
+	return pool->free == pool->size;
+}
+EXPORT_SYMBOL(buf_list_is_full);
+
+int buf_list_free(int chn, struct mbuf_t *head, struct mbuf_t *tail, int num)
+{
+	struct buffer_pool_t *pool;
+	struct chn_info_t *chn_inf = chn_info();
+
+	if ((head == NULL) || (tail == NULL) || (num == 0)) {
+		pr_err("%s(%d, 0x%lx, 0x%lx, %d)\n", __func__, chn,
+			(unsigned long)virt_to_phys(head),
+			(unsigned long)virt_to_phys(tail), num);
+		return -1;
+	}
+
+	pool = &(chn_inf->pool[chn]);
+	spin_lock_bh(&(pool->lock));
+	buf_list_check(pool, head, tail, num);
+	tail->next = pool->head;
+	pool->head = head;
+	pool->free += num;
+	buf_pool_check(pool);
+	spin_unlock_bh(&(pool->lock));
+
+	return 0;
+}
+EXPORT_SYMBOL(buf_list_free);
+
+int bus_chn_init(struct mchn_ops_t *ops, int hif_type)
+{
+	int ret = 0;
+	struct chn_info_t *chn_inf = chn_info();
+
+	/*pr_info("[+]%s(%d, %d)\n", __func__, ops->channel, ops->hif_type);*/
+	if (chn_inf->ops[ops->channel] != NULL) {
+		pr_err("%s err, hif_type %d\n", __func__, ops->hif_type);
+		WARN_ON(1);
+		return -1;
+	}
+
+	mutex_init(&chn_inf->callback_lock[ops->channel]);
+	mutex_lock(&chn_inf->callback_lock[ops->channel]);
+	ops->hif_type = hif_type;
+	chn_inf->ops[ops->channel] = ops;
+	if (ops->pool_size > 0)
+		ret = buf_pool_init(&(chn_inf->pool[ops->channel]),
+				    ops->pool_size, 0);
+	mutex_unlock(&chn_inf->callback_lock[ops->channel]);
+
+	/* pr_info("[-]%s(%d)\n", __func__, ops->channel); */
+
+	return ret;
+}
+EXPORT_SYMBOL(bus_chn_init);
+
+int bus_chn_deinit(struct mchn_ops_t *ops)
+{
+	int ret = 0;
+	struct chn_info_t *chn_inf = chn_info();
+
+	/*pr_info("[+]%s(%d, %d)\n", __func__, ops->channel, ops->hif_type);*/
+	if (chn_inf->ops[ops->channel] == NULL) {
+		pr_err("%s err\n", __func__);
+		return -1;
+	}
+
+	mutex_lock(&chn_inf->callback_lock[ops->channel]);
+	if (ops->pool_size > 0)
+		ret = buf_pool_deinit(&(chn_inf->pool[ops->channel]));
+	chn_inf->ops[ops->channel] = NULL;
+	mutex_unlock(&chn_inf->callback_lock[ops->channel]);
+	mutex_destroy(&chn_inf->callback_lock[ops->channel]);
+
+	/* pr_info("[-]%s(%d)\n", __func__, ops->channel); */
+
+	return ret;
+}
+EXPORT_SYMBOL(bus_chn_deinit);
+
+struct mchn_ops_t *chn_ops(int channel)
+{
+	if (channel >= CHN_MAX_NUM || channel < 0)
+		return NULL;
+
+	return g_chn_info.ops[channel];
+}
+EXPORT_SYMBOL(chn_ops);
+
+int module_ops_register(struct sprdwcn_bus_ops *ops)
+{
+	if (wcn_bus_ops) {
+		WARN_ON(1);
+		return -EBUSY;
+	}
+
+	wcn_bus_ops = ops;
+
+	return 0;
+}
+EXPORT_SYMBOL(module_ops_register);
+
+void module_ops_unregister(void)
+{
+	wcn_bus_ops = NULL;
+}
+EXPORT_SYMBOL(module_ops_unregister);
+
+struct sprdwcn_bus_ops *get_wcn_bus_ops(void)
+{
+	return wcn_bus_ops;
+}
+EXPORT_SYMBOL(get_wcn_bus_ops);
+
diff --git a/drivers/net/wireless/uwe5622/unisocwifi/Kconfig b/drivers/net/wireless/uwe5622/unisocwifi/Kconfig
new file mode 100644
index 000000000000..3b8b0adaa032
--- /dev/null
+++ b/drivers/net/wireless/uwe5622/unisocwifi/Kconfig
@@ -0,0 +1,12 @@
+config WLAN_UWE5622
+	tristate "UWE5622 Wi-Fi Driver"
+	help
+	  Spard UWE5622 Wi-Fi Driver.
+
+config SPRDWL_NG
+	tristate "SPRD Next Generation Wireless LAN Support"
+	depends on CFG80211
+	help
+	  This is a driver for the Spreadtrum IEEE802.11 WLAN devices.
+
+	  When compiled as a module, this driver will be called sprdwl_ng.
diff --git a/drivers/net/wireless/uwe5622/unisocwifi/Makefile b/drivers/net/wireless/uwe5622/unisocwifi/Makefile
new file mode 100644
index 000000000000..15694507a9a3
--- /dev/null
+++ b/drivers/net/wireless/uwe5622/unisocwifi/Makefile
@@ -0,0 +1,60 @@
+PWD := $(shell pwd)
+all_dependencies := driver
+
+ccflags-y += -I$(srctree)/drivers/net/wireless/uwe5622/sprdwcn/include
+ccflags-$(ORIGIN_BSP) += -I$(srctree)/../hardware/wifi/unisoc/drivers/unisocwcn/include
+
+ifneq ($(UNISOC_BSP_INCLUDE),)
+ccflags-y += -I$(UNISOC_BSP_INCLUDE)
+endif
+
+ifneq ($(UNISOC_WIFI_CUS_CONFIG),)
+ccflags-y += -DCUSTOMIZE_WIFI_CFG_PATH=\"$(UNISOC_WIFI_CUS_CONFIG)\"
+endif
+
+ifneq ($(UNISOC_WIFI_MAC_FILE),)
+ccflags-y += -DCUSTOMIZE_WIFI_MAC_FILE=\"$(UNISOC_WIFI_MAC_FILE)\"
+endif
+
+####add cflag######
+ccflags-y += -DIBSS_SUPPORT -DIBSS_RSN_SUPPORT
+ccflags-y += -DNAN_SUPPORT
+ccflags-y += -DRTT_SUPPORT
+ccflags-y += -DACS_SUPPORT -DRX_HW_CSUM
+ccflags-y += -DWMMAC_WFA_CERTIFICATION
+ccflags-y += -DCOMPAT_SAMPILE_CODE
+ccflags-y += -DRND_MAC_SUPPORT
+ccflags-y += -DSOFTAP_HOOK
+ccflags-y += -DATCMD_ASSERT
+ccflags-y += -DTCPACK_DELAY_SUPPORT
+ccflags-$(DEBUGMODE) += -DWL_CONFIG_DEBUG
+ccflags-y += -DSPLIT_STACK
+#ccflags-y += -DOTT_UWE
+
+#######add .o file#####
+sprdwl_ng-objs += main.o cfg80211.o txrx.o cmdevt.o npi.o msg.o work.o vendor.o \
+				  tcp_ack.o mm.o reorder.o wl_core.o tx_msg.o rx_msg.o \
+				  wl_intf.o qos.o reg_domain.o
+sprdwl_ng-objs += defrag.o
+sprdwl_ng-objs += ibss.o
+sprdwl_ng-objs += nan.o
+sprdwl_ng-objs += tracer.o
+sprdwl_ng-objs += rf_marlin3.o
+sprdwl_ng-objs += rtt.o
+sprdwl_ng-objs += api_version.o
+sprdwl_ng-objs += rnd_mac_addr.o
+sprdwl_ng-objs += softap_hook.o
+sprdwl_ng-objs += debug.o
+#sprdwl_ng-objs += 11h.o
+
+obj-$(CONFIG_WLAN_UWE5622) += sprdwl_ng.o
+
+all: $(all_dependencies)
+driver: $(driver_dependencies)
+	@echo build driver
+	$(MAKE) ARCH=$(ARCH) CROSS_COMPILE=$(CROSS_COMPILE) -C $(KDIR) M=$(PWD) modules
+
+clean:
+	$(MAKE) -C $(KDIR) M=$(PWD) clean
+	$(RM) Module.markers
+	$(RM) modules.order
diff --git a/drivers/net/wireless/uwe5622/unisocwifi/api_version.c b/drivers/net/wireless/uwe5622/unisocwifi/api_version.c
new file mode 100644
index 000000000000..79f0b5706d13
--- /dev/null
+++ b/drivers/net/wireless/uwe5622/unisocwifi/api_version.c
@@ -0,0 +1,498 @@
+/*
+ * Copyright (C) 2017 Spreadtrum Communications Inc.
+ *
+ * Filename : api_version.c
+ * Abstract : This file is a general definition for drv version
+ *
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+#include "version.h"
+#include <net/cfg80211.h>
+#include "sprdwl.h"
+
+struct api_version_t g_api_array[] = {
+	[0]{	/*ID:0*/
+		.cmd_id = WIFI_CMD_ERR,
+		.drv_version = 1,
+	},
+	{	/*ID:1*/
+		.cmd_id = WIFI_CMD_GET_INFO,
+		.drv_version = 1,
+	},
+	{	/*ID:2*/
+		.cmd_id = WIFI_CMD_SET_REGDOM,
+		.drv_version = 1,
+	},
+	{	/*ID:3*/
+		.cmd_id = WIFI_CMD_OPEN,
+		.drv_version = 1,
+	},
+	{	/*ID:4*/
+		.cmd_id = WIFI_CMD_CLOSE,
+		.drv_version = 1,
+	},
+	{	/*ID:5*/
+		.cmd_id = WIFI_CMD_POWER_SAVE,
+		.drv_version = 1,
+	},
+	{	/*ID:6*/
+		.cmd_id = WIFI_CMD_SET_PARAM,
+		.drv_version = 1,
+	},
+	{	/*ID:7*/
+		.cmd_id = WIFI_CMD_SET_CHANNEL,
+		.drv_version = 1,
+	},
+	{	/*ID:8*/
+		.cmd_id = WIFI_CMD_REQ_LTE_CONCUR,
+		.drv_version = 1,
+	},
+	{	/*ID:9*/
+		.cmd_id = WIFI_CMD_SYNC_VERSION,
+		.drv_version = 1,
+	},
+	{	/*ID:10*/
+		.cmd_id = WIFI_CMD_CONNECT,
+		.drv_version = 1,
+	},
+	{	/*ID:11*/
+		.cmd_id = WIFI_CMD_SCAN,
+		.drv_version = 1,
+	},
+	{	/*ID:12*/
+		.cmd_id = WIFI_CMD_SCHED_SCAN,
+		.drv_version = 1,
+	},
+	{	/*ID:13*/
+		.cmd_id = WIFI_CMD_DISCONNECT,
+		.drv_version = 1,
+	},
+	{	/*ID:14*/
+		.cmd_id = WIFI_CMD_KEY,
+		.drv_version = 1,
+	},
+	{	/*ID:15*/
+		.cmd_id = WIFI_CMD_SET_PMKSA,
+		.drv_version = 1,
+	},
+	{	/*ID:16*/
+		.cmd_id = WIFI_CMD_GET_STATION,
+		.drv_version = 1,
+	},
+	{	/*ID:17*/
+		.cmd_id = WIFI_CMD_START_AP,
+		.drv_version = 1,
+	},
+	{	/*ID:18*/
+		.cmd_id = WIFI_CMD_DEL_STATION,
+		.drv_version = 1,
+	},
+	{	/*ID:19*/
+		.cmd_id = WIFI_CMD_SET_BLACKLIST,
+		.drv_version = 1,
+	},
+	{	/*ID:20*/
+		.cmd_id = WIFI_CMD_SET_WHITELIST,
+		.drv_version = 1,
+	},
+	{	/*ID:21*/
+		.cmd_id = WIFI_CMD_TX_MGMT,
+		.drv_version = 1,
+	},
+	{	/*ID:22*/
+		.cmd_id = WIFI_CMD_REGISTER_FRAME,
+		.drv_version = 1,
+	},
+	{	/*ID:23*/
+		.cmd_id = WIFI_CMD_REMAIN_CHAN,
+		.drv_version = 1,
+	},
+	{	/*ID:24*/
+		.cmd_id = WIFI_CMD_CANCEL_REMAIN_CHAN,
+		.drv_version = 1,
+	},
+	{	/*ID:25*/
+		.cmd_id = WIFI_CMD_SET_IE,
+		.drv_version = 1,
+	},
+	{	/*ID:26*/
+		.cmd_id = WIFI_CMD_NOTIFY_IP_ACQUIRED,
+		.drv_version = 1,
+	},
+	{	/*ID:27*/
+		.cmd_id = WIFI_CMD_SET_CQM,
+		.drv_version = 1,
+	},
+	{	/*ID:28*/
+		.cmd_id = WIFI_CMD_SET_ROAM_OFFLOAD,
+		.drv_version = 1,
+	},
+	{	/*ID:29*/
+		.cmd_id = WIFI_CMD_SET_MEASUREMENT,
+		.drv_version = 1,
+	},
+	{	/*ID:30*/
+		.cmd_id = WIFI_CMD_SET_QOS_MAP,
+		.drv_version = 1,
+	},
+	{	/*ID:31*/
+		.cmd_id = WIFI_CMD_TDLS,
+		.drv_version = 1,
+	},
+	{	/*ID:32*/
+		.cmd_id = WIFI_CMD_11V,
+		.drv_version = 1,
+	},
+	{	/*ID:33*/
+		.cmd_id = WIFI_CMD_NPI_MSG,
+		.drv_version = 1,
+	},
+	{	/*ID:34*/
+		.cmd_id = WIFI_CMD_NPI_GET,
+		.drv_version = 1,
+	},
+	{	/*ID:35*/
+		.cmd_id = WIFI_CMD_ASSERT,
+		.drv_version = 1,
+	},
+	{	/*ID:36*/
+		.cmd_id = WIFI_CMD_FLUSH_SDIO,
+		.drv_version = 1,
+	},
+	{	/*ID:37*/
+		.cmd_id = WIFI_CMD_ADD_TX_TS,
+		.drv_version = 1,
+	},
+	{	/*ID:38*/
+		.cmd_id = WIFI_CMD_DEL_TX_TS,
+		.drv_version = 1,
+	},
+	{	/*ID:39*/
+		.cmd_id = WIFI_CMD_MULTICAST_FILTER,
+		.drv_version = 1,
+	},
+	{	/*ID:40*/
+		.cmd_id = WIFI_CMD_ADDBA_REQ,
+		.drv_version = 1,
+	},
+	{	/*ID:41*/
+		.cmd_id = WIFI_CMD_DELBA_REQ,
+		.drv_version = 1,
+	},
+	[56]{	/*ID:56*/
+		.cmd_id = WIFI_CMD_LLSTAT,
+		.drv_version = 1,
+	},
+	{	/*ID:57*/
+		.cmd_id = WIFI_CMD_CHANGE_BSS_IBSS_MODE,
+		.drv_version = 1,
+	},
+	{	/*ID:58*/
+		.cmd_id = WIFI_CMD_IBSS_JOIN,
+		.drv_version = 1,
+	},
+	{	/*ID:59*/
+		.cmd_id = WIFI_CMD_SET_IBSS_ATTR,
+		.drv_version = 1,
+	},
+	{	/*ID:60*/
+		.cmd_id = WIFI_CMD_IBSS_LEAVE,
+		.drv_version = 1,
+	},
+	{	/*ID:61*/
+		.cmd_id = WIFI_CMD_IBSS_VSIE_SET,
+		.drv_version = 1,
+	},
+	{	/*ID:62*/
+		.cmd_id = WIFI_CMD_IBSS_VSIE_DELETE,
+		.drv_version = 1,
+	},
+	{	/*ID:63*/
+		.cmd_id = WIFI_CMD_IBSS_SET_PS,
+		.drv_version = 1,
+	},
+	{	/*ID:64*/
+		.cmd_id = WIFI_CMD_RND_MAC,
+		.drv_version = 1,
+	},
+	{	/*ID:65*/
+		.cmd_id = WIFI_CMD_GSCAN,
+		.drv_version = 1,
+	},
+	{	/*ID:66*/
+		.cmd_id = WIFI_CMD_RTT,
+		.drv_version = 1,
+	},
+	{	/*ID:67*/
+		.cmd_id = WIFI_CMD_NAN,
+		.drv_version = 1,
+	},
+	{	/*ID:68*/
+		.cmd_id = WIFI_CMD_BA,
+		.drv_version = 1,
+	},
+	{	/*ID:69*/
+		.cmd_id = WIFI_CMD_SET_PROTECT_MODE,
+		.drv_version = 1,
+	},
+	{	/*ID:70*/
+		.cmd_id = WIFI_CMD_GET_PROTECT_MODE,
+		.drv_version = 1,
+	},
+	{	/*ID:71*/
+		.cmd_id = WIFI_CMD_SET_MAX_CLIENTS_ALLOWED,
+		.drv_version = 1,
+	},
+	{	/*ID:72*/
+		.cmd_id = WIFI_CMD_TX_DATA,
+		.drv_version = 1,
+	},
+	{	/*ID:73*/
+		.cmd_id = WIFI_CMD_NAN_DATA_PATH,
+		.drv_version = 1,
+	},
+	[74]{	/*ID:74*/
+		.cmd_id = WIFI_CMD_SET_TLV,
+		.drv_version = 1,
+	},
+	{	/*ID:75*/
+		.cmd_id = WIFI_CMD_RSSI_MONITOR,
+		.drv_version = 1,
+	},
+	{	/*ID:76*/
+		.cmd_id = WIFI_CMD_DOWNLOAD_INI,
+		.drv_version = 1,
+	},
+	{	/*ID:77*/
+		.cmd_id = WIFI_CMD_RADAR_DETECT,
+		.drv_version = 1,
+	},
+	{	/*ID:78*/
+		.cmd_id = WIFI_CMD_HANG_RECEIVED,
+		.drv_version = 1,
+	},
+	{	/*ID:79*/
+		.cmd_id = WIFI_CMD_RESET_BEACON,
+		.drv_version = 1,
+	},
+	{	/*ID:80*/
+		.cmd_id = WIFI_CMD_VOWIFI_DATA_PROTECT,
+		.drv_version = 1,
+	},
+#ifdef WOW_SUPPORT
+	[83] = {    /*ID:83*/
+		.cmd_id = WIFI_CMD_SET_WOWLAN,
+		.drv_version = 1,
+	},
+#endif
+	[84]{
+		/*ID:84*/
+		.cmd_id = WIFI_CMD_PACKET_OFFLOAD,
+		.drv_version = 1,
+	},
+	[128]{	/*ID:0x80*/
+		.cmd_id = WIFI_EVENT_CONNECT,
+		.drv_version = 1,
+	},
+	[129]{	/*ID:0x81*/
+		.cmd_id = WIFI_EVENT_DISCONNECT,
+		.drv_version = 1,
+	},
+	[130]{	/*ID:0x82*/
+		.cmd_id = WIFI_EVENT_SCAN_DONE,
+		.drv_version = 1,
+	},
+	[131]{	/*ID:0x83*/
+		.cmd_id = WIFI_EVENT_MGMT_FRAME,
+		.drv_version = 1,
+	},
+	[132]{	/*ID:0x84*/
+		.cmd_id = WIFI_EVENT_MGMT_TX_STATUS,
+		.drv_version = 1,
+	},
+	[133]{	/*ID:0x85*/
+		.cmd_id = WIFI_EVENT_REMAIN_CHAN_EXPIRED,
+		.drv_version = 1,
+	},
+	[134]{	/*ID:0x86*/
+		.cmd_id = WIFI_EVENT_MIC_FAIL,
+		.drv_version = 1,
+	},
+	[136]{	/*ID:0x88*/
+		.cmd_id = WIFI_EVENT_GSCAN_FRAME,
+		.drv_version = 1,
+	},
+	[137]{	/*ID:0x89*/
+		.cmd_id = WIFI_EVENT_RSSI_MONITOR,
+		.drv_version = 1,
+	},
+	[160]{	/*ID:0xa0*/
+		.cmd_id = WIFI_EVENT_NEW_STATION,
+		.drv_version = 1,
+	},
+	[161]{	/*ID:0xa1*/
+		.cmd_id = WIFI_EVENT_RADAR_DETECTED,
+		.drv_version = 1,
+	},
+	[176]{	/*ID:0xb0*/
+		.cmd_id = WIFI_EVENT_CQM,
+		.drv_version = 1,
+	},
+	[177]{	/*ID:0xb1*/
+		.cmd_id = WIFI_EVENT_MEASUREMENT,
+		.drv_version = 1,
+	},
+	[178]{	/*ID:0xb2*/
+		.cmd_id = WIFI_EVENT_TDLS,
+		.drv_version = 1,
+	},
+	[179]{	/*ID:0xb3*/
+		.cmd_id = WIFI_EVENT_SDIO_FLOWCON,
+		.drv_version = 1,
+	},
+	[224]{	/*ID:0xe0*/
+		.cmd_id = WIFI_EVENT_SDIO_SEQ_NUM,
+		.drv_version = 1,
+	},
+	[242]{	/*ID:0xf2*/
+		.cmd_id = WIFI_EVENT_RTT,
+		.drv_version = 1,
+	},
+	[243]{	/*ID:0xf3*/
+		.cmd_id = WIFI_EVENT_BA,
+		.drv_version = 1,
+	},
+	[244]{	/*ID:0xf4*/
+		.cmd_id = WIFI_EVENT_NAN,
+		.drv_version = 1,
+	},
+	[245]{	/*ID:0xf5*/
+		.cmd_id = WIFI_EVENT_STA_LUT_INDEX,
+		.drv_version = 1,
+	},
+	[246]{	/*ID:0xf6*/
+		.cmd_id = WIFI_EVENT_HANG_RECOVERY,
+		.drv_version = 1,
+	},
+	[247]{	/*ID:0xf7*/
+		.cmd_id = WIFI_EVENT_THERMAL_WARN,
+		.drv_version = 1,
+	},
+	[248]{	/*ID:0xf8*/
+		.cmd_id = WIFI_EVENT_SUSPEND_RESUME,
+		.drv_version = 1,
+	},
+	[255]{
+		.drv_version = 0,
+	}
+};
+
+void sprdwl_fill_drv_api_version(struct sprdwl_priv *priv,
+				 struct sprdwl_cmd_api_t *drv_api)
+{
+	int count;
+	struct api_version_t *p;
+	/*init priv sync_api struct*/
+	priv->sync_api.main_drv = MAIN_DRV_VERSION;
+	priv->sync_api.compat = DEFAULT_COMPAT;
+	(&priv->sync_api)->api_array = g_api_array;
+	/*fill CMD struct drv_api*/
+	drv_api->main_ver = priv->sync_api.main_drv;
+	for (count = 0; count < MAX_API &&
+	     count < sizeof(g_api_array) / sizeof(g_api_array[0]); count++) {
+		p = &g_api_array[count];
+		if (p->drv_version)
+			drv_api->api_map[count] =
+				p->drv_version;
+		else
+			drv_api->api_map[count] = 0;
+	}
+}
+
+void sprdwl_fill_fw_api_version(struct sprdwl_priv *priv,
+				struct sprdwl_cmd_api_t *fw_api)
+{
+	int count;
+	/*define tmp struct *p */
+	struct api_version_t *p;
+	/*got main fw_version*/
+	priv->sync_api.main_fw = fw_api->main_ver;
+	/*if main version not match, trigger it assert*/
+/*	if(priv->sync_api->main_fw != priv->sync_api->drv_fw) */
+
+	for (count = 0; count < MAX_API; count++) {
+		p = &g_api_array[count];
+		p->fw_version = fw_api->api_map[count];
+		if (p->fw_version != p->drv_version) {
+			wl_info("API version not match!! CMD ID:%d,drv:%d,fw:%d\n",
+				count, p->drv_version, p->fw_version);
+		}
+	}
+}
+
+int sprdwl_api_available_check(struct sprdwl_priv *priv,
+			       struct sprdwl_msg_buf *msg)
+{
+	/*define tmp struct *p */
+	struct api_version_t *p = NULL;
+	/*cmd head struct point*/
+	struct sprdwl_cmd_hdr *hdr = NULL;
+	u8 cmd_id;
+	u8 drv_ver = 0, fw_ver = 0;
+	u32 min_ver = 255;
+
+	hdr = (struct sprdwl_cmd_hdr *)(msg->tran_data + priv->hw_offset);
+	cmd_id = hdr->cmd_id;
+	if (cmd_id == WIFI_CMD_SYNC_VERSION)
+		return 0;
+
+	p = &g_api_array[cmd_id];
+	drv_ver = p->drv_version;
+	fw_ver = p->fw_version;
+	min_ver = min(drv_ver, fw_ver);
+	if (min_ver) {
+		if ((min_ver == drv_ver) ||
+		    min_ver == priv->sync_api.compat) {
+			priv->sync_api.compat = DEFAULT_COMPAT;
+			return 0;
+		} else {
+			wl_err("CMD ID:%d,drv ver:%d, fw ver:%d,compat:%d\n",
+			       cmd_id, drv_ver, fw_ver, priv->sync_api.compat);
+			return -1;
+		}
+	} else {
+		wl_err("CMD ID:%d,drv ver:%d, fw ver:%d drop it!!\n",
+		       cmd_id, drv_ver, fw_ver);
+		return -1;
+	}
+}
+
+int need_compat_operation(struct sprdwl_priv *priv, u8 cmd_id)
+{
+	u8 drv_ver = 0;
+	u8 fw_ver = 0;
+	struct api_version_t *api = (&priv->sync_api)->api_array;
+
+	drv_ver = (api + cmd_id)->drv_version;
+	fw_ver = (api + cmd_id)->fw_version;
+
+	if ((drv_ver != fw_ver) && (fw_ver == min(fw_ver, drv_ver))) {
+		wl_info("drv ver:%d higher than fw ver:%d\n", drv_ver, fw_ver);
+		wl_info("need compat operation!!\n");
+		return fw_ver;
+
+	} else {
+		if (drv_ver != fw_ver)
+			wl_info("drv ver:%d, fw_ver:%d\n no need compat!!",
+					drv_ver, fw_ver);
+		return 0;
+	}
+}
diff --git a/drivers/net/wireless/uwe5622/unisocwifi/cfg80211.c b/drivers/net/wireless/uwe5622/unisocwifi/cfg80211.c
new file mode 100644
index 000000000000..aa64a056eecf
--- /dev/null
+++ b/drivers/net/wireless/uwe5622/unisocwifi/cfg80211.c
@@ -0,0 +1,3815 @@
+/*
+ * Copyright (C) 2015 Spreadtrum Communications Inc.
+ *
+ * Abstract : This file is an implementation for cfg80211 subsystem
+ *
+ * Authors:
+ * Keguang Zhang <keguang.zhang@spreadtrum.com>
+ * Jingxiang Li <Jingxiang.li@spreadtrum.com>
+ * Dong Xiang <dong.xiang@spreadtrum.com>
+ * Huiquan Zhou <huiquan.zhou@spreadtrum.com>
+ * Baolei Yuan <baolei.yuan@spreadtrum.com>
+ * Xianwei Zhao <xianwei.zhao@spreadtrum.com>
+ * Gui Zhu <gui.zhu@spreadtrum.com>
+ * Andy He <andy.he@spreadtrum.com>
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include "sprdwl.h"
+#include "cfg80211.h"
+#include "cmdevt.h"
+#include "work.h"
+#include "ibss.h"
+#include "intf_ops.h"
+#include "softap_hook.h"
+#include "tx_msg.h"
+#ifdef RND_MAC_SUPPORT
+#include "rnd_mac_addr.h"
+#endif
+#include "rx_msg.h"
+
+#ifdef DFS_MASTER
+#include "11h.h"
+#endif
+
+#ifdef WMMAC_WFA_CERTIFICATION
+#include "qos.h"
+#endif
+
+#if !defined(CONFIG_CFG80211_INTERNAL_REGDB) || defined(CUSTOM_REGDOMAIN)
+#include "reg_domain.h"
+#endif
+
+#define RATETAB_ENT(_rate, _rateid, _flags)				\
+{									\
+	.bitrate	= (_rate),					\
+	.hw_value	= (_rateid),					\
+	.flags		= (_flags),					\
+}
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 7, 0)
+#define CHAN2G(_channel, _freq, _flags)                                 \
+{									\
+	.band                   = NL80211_BAND_2GHZ,    		\
+	.center_freq            = (_freq),              		\
+	.hw_value               = (_channel),           		\
+	.flags                  = (_flags),             		\
+	.max_antenna_gain       = 0,                    		\
+	.max_power              = 30,                   		\
+}
+#else
+#define CHAN2G(_channel, _freq, _flags)  				\
+{									\
+	.band                   = IEEE80211_BAND_2GHZ,  		\
+	.center_freq		= (_freq),				\
+	.hw_value		= (_channel),				\
+	.flags			= (_flags),				\
+	.max_antenna_gain	= 0,					\
+	.max_power		= 30,					\
+}
+#endif
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 7, 0)
+#define CHAN5G(_channel, _flags) 					\
+{									\
+	.band                   = NL80211_BAND_5GHZ,            	\
+	.center_freq		= 5000 + (5 * (_channel)),		\
+	.hw_value		= (_channel),				\
+	.flags			= (_flags),				\
+	.max_antenna_gain	= 0,					\
+	.max_power		= 30,					\
+}
+#else
+#define CHAN5G(_channel, _flags)                                        \
+{									\
+	.band                   = IEEE80211_BAND_5GHZ,          	\
+	.center_freq            = 5000 + (5 * (_channel)),      	\
+	.hw_value               = (_channel),                   	\
+	.flags                  = (_flags),                     	\
+	.max_antenna_gain       = 0,                            	\
+	.max_power              = 30,                           	\
+}
+#endif
+
+static struct ieee80211_rate sprdwl_rates[] = {
+	RATETAB_ENT(10, 0x1, 0),
+	RATETAB_ENT(20, 0x2, 0),
+	RATETAB_ENT(55, 0x5, 0),
+	RATETAB_ENT(110, 0xb, 0),
+	RATETAB_ENT(60, 0x6, 0),
+	RATETAB_ENT(90, 0x9, 0),
+	RATETAB_ENT(120, 0xc, 0),
+	RATETAB_ENT(180, 0x12, 0),
+	RATETAB_ENT(240, 0x18, 0),
+	RATETAB_ENT(360, 0x24, 0),
+	RATETAB_ENT(480, 0x30, 0),
+	RATETAB_ENT(540, 0x36, 0),
+
+	RATETAB_ENT(65, 0x80, 0),
+	RATETAB_ENT(130, 0x81, 0),
+	RATETAB_ENT(195, 0x82, 0),
+	RATETAB_ENT(260, 0x83, 0),
+	RATETAB_ENT(390, 0x84, 0),
+	RATETAB_ENT(520, 0x85, 0),
+	RATETAB_ENT(585, 0x86, 0),
+	RATETAB_ENT(650, 0x87, 0),
+	RATETAB_ENT(130, 0x88, 0),
+	RATETAB_ENT(260, 0x89, 0),
+	RATETAB_ENT(390, 0x8a, 0),
+	RATETAB_ENT(520, 0x8b, 0),
+	RATETAB_ENT(780, 0x8c, 0),
+	RATETAB_ENT(1040, 0x8d, 0),
+	RATETAB_ENT(1170, 0x8e, 0),
+	RATETAB_ENT(1300, 0x8f, 0)
+};
+
+#define SPRDWL_G_RATE_NUM	28
+#define sprdwl_g_rates		(sprdwl_rates)
+#define SPRDWL_A_RATE_NUM	24
+#define sprdwl_a_rates		(sprdwl_rates + 4)
+
+#define sprdwl_g_htcap (IEEE80211_HT_CAP_SUP_WIDTH_20_40 | \
+			IEEE80211_HT_CAP_SGI_20		 | \
+			IEEE80211_HT_CAP_SGI_40)
+
+#define sprdwl_a_htcap (IEEE80211_HT_CAP_SUP_WIDTH_20_40 | \
+			IEEE80211_HT_CAP_SGI_20	| \
+			IEEE80211_HT_CAP_SM_PS | IEEE80211_HT_CAP_SGI_40)
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 14, 0)
+#define sprdwl_vhtcap (IEEE80211_VHT_CAP_MAX_MPDU_LENGTH_7991 | \
+		IEEE80211_VHT_CAP_SU_BEAMFORMEE_CAPABLE | \
+		IEEE80211_VHT_CAP_BEAMFORMEE_STS_SHIFT | \
+		IEEE80211_VHT_CAP_MU_BEAMFORMEE_CAPABLE | \
+		IEEE80211_VHT_CAP_MAX_A_MPDU_LENGTH_EXPONENT_SHIFT | \
+		IEEE80211_VHT_CAP_VHT_TXOP_PS)
+#else
+#define sprdwl_vhtcap (IEEE80211_VHT_CAP_MAX_MPDU_LENGTH_7991 | \
+		IEEE80211_VHT_CAP_SU_BEAMFORMEE_CAPABLE | \
+		IEEE80211_VHT_CAP_MU_BEAMFORMEE_CAPABLE | \
+		IEEE80211_VHT_CAP_MAX_A_MPDU_LENGTH_EXPONENT_SHIFT | \
+		IEEE80211_VHT_CAP_VHT_TXOP_PS)
+#endif
+
+static struct ieee80211_channel sprdwl_2ghz_channels[] = {
+	CHAN2G(1, 2412, 0),
+	CHAN2G(2, 2417, 0),
+	CHAN2G(3, 2422, 0),
+	CHAN2G(4, 2427, 0),
+	CHAN2G(5, 2432, 0),
+	CHAN2G(6, 2437, 0),
+	CHAN2G(7, 2442, 0),
+	CHAN2G(8, 2447, 0),
+	CHAN2G(9, 2452, 0),
+	CHAN2G(10, 2457, 0),
+	CHAN2G(11, 2462, 0),
+	CHAN2G(12, 2467, 0),
+	CHAN2G(13, 2472, 0),
+	CHAN2G(14, 2484, 0)
+};
+
+static struct ieee80211_supported_band sprdwl_band_2ghz = {
+	.n_channels = ARRAY_SIZE(sprdwl_2ghz_channels),
+	.channels = sprdwl_2ghz_channels,
+	.n_bitrates = SPRDWL_G_RATE_NUM,
+	.bitrates = sprdwl_g_rates,
+	.ht_cap.cap = sprdwl_g_htcap,
+	.ht_cap.ht_supported = true
+};
+
+static struct ieee80211_channel sprdwl_5ghz_channels[] = {
+	CHAN5G(34, 0), CHAN5G(36, 0),
+	CHAN5G(40, 0), CHAN5G(44, 0),
+	CHAN5G(48, 0), CHAN5G(52, 0),
+	CHAN5G(56, 0), CHAN5G(60, 0),
+	CHAN5G(64, 0), CHAN5G(100, 0),
+	CHAN5G(104, 0), CHAN5G(108, 0),
+	CHAN5G(112, 0), CHAN5G(116, 0),
+	CHAN5G(120, 0), CHAN5G(124, 0),
+	CHAN5G(128, 0), CHAN5G(132, 0),
+	CHAN5G(136, 0), CHAN5G(140, 0),
+	CHAN5G(144, 0), CHAN5G(149, 0),
+	CHAN5G(153, 0), CHAN5G(157, 0),
+	CHAN5G(161, 0), CHAN5G(165, 0),
+	CHAN5G(184, 0), CHAN5G(188, 0),
+	CHAN5G(192, 0), CHAN5G(196, 0),
+	CHAN5G(200, 0), CHAN5G(204, 0),
+	CHAN5G(208, 0), CHAN5G(212, 0),
+	CHAN5G(216, 0)
+};
+
+static struct ieee80211_supported_band sprdwl_band_5ghz = {
+	.n_channels = ARRAY_SIZE(sprdwl_5ghz_channels),
+	.channels = sprdwl_5ghz_channels,
+	.n_bitrates = SPRDWL_A_RATE_NUM,
+	.bitrates = sprdwl_a_rates,
+	.ht_cap.cap = sprdwl_a_htcap,
+	.ht_cap.ht_supported = true,
+	.vht_cap.vht_supported = true,
+	.vht_cap.cap = sprdwl_vhtcap,
+	.vht_cap.vht_mcs.rx_mcs_map = 0xfff0,
+	.vht_cap.vht_mcs.tx_mcs_map = 0xfff0,
+	.vht_cap.vht_mcs.rx_highest = 0,
+	.vht_cap.vht_mcs.tx_highest = 0,
+};
+
+static const u32 sprdwl_cipher_suites[] = {
+	WLAN_CIPHER_SUITE_WEP40,
+	WLAN_CIPHER_SUITE_WEP104,
+	WLAN_CIPHER_SUITE_TKIP,
+	WLAN_CIPHER_SUITE_CCMP,
+	WLAN_CIPHER_SUITE_SMS4,
+	/* required by ieee802.11w */
+	WLAN_CIPHER_SUITE_AES_CMAC,
+	WLAN_CIPHER_SUITE_PMK
+};
+
+/* Supported mgmt frame types to be advertised to cfg80211 */
+static const struct ieee80211_txrx_stypes
+sprdwl_mgmt_stypes[NUM_NL80211_IFTYPES] = {
+	[NL80211_IFTYPE_STATION] = {
+		.tx = 0xffff,
+		.rx = BIT(IEEE80211_STYPE_ACTION >> 4) |
+		      BIT(IEEE80211_STYPE_PROBE_REQ >> 4)
+	},
+	[NL80211_IFTYPE_AP] = {
+		.tx = 0xffff,
+		.rx = BIT(IEEE80211_STYPE_ASSOC_REQ >> 4) |
+		      BIT(IEEE80211_STYPE_REASSOC_REQ >> 4) |
+		      BIT(IEEE80211_STYPE_PROBE_REQ >> 4) |
+		      BIT(IEEE80211_STYPE_DISASSOC >> 4) |
+		      BIT(IEEE80211_STYPE_AUTH >> 4) |
+		      BIT(IEEE80211_STYPE_DEAUTH >> 4) |
+		      BIT(IEEE80211_STYPE_ACTION >> 4)
+	},
+	[NL80211_IFTYPE_P2P_CLIENT] = {
+		.tx = 0xffff,
+		.rx = BIT(IEEE80211_STYPE_ACTION >> 4) |
+		      BIT(IEEE80211_STYPE_PROBE_REQ >> 4)
+	},
+	[NL80211_IFTYPE_P2P_GO] = {
+		.tx = 0xffff,
+		.rx = BIT(IEEE80211_STYPE_ASSOC_REQ >> 4) |
+		      BIT(IEEE80211_STYPE_REASSOC_REQ >> 4) |
+		      BIT(IEEE80211_STYPE_PROBE_REQ >> 4) |
+		      BIT(IEEE80211_STYPE_DISASSOC >> 4) |
+		      BIT(IEEE80211_STYPE_AUTH >> 4) |
+		      BIT(IEEE80211_STYPE_DEAUTH >> 4) |
+		      BIT(IEEE80211_STYPE_ACTION >> 4)
+	},
+#ifndef CONFIG_P2P_INTF
+	[NL80211_IFTYPE_P2P_DEVICE] = {
+		.tx = 0xffff,
+		.rx = BIT(IEEE80211_STYPE_ACTION >> 4) |
+		      BIT(IEEE80211_STYPE_PROBE_REQ >> 4)
+	}
+#endif
+};
+
+static const struct ieee80211_iface_limit sprdwl_iface_limits[] = {
+	{
+		.max = 1,
+		.types = BIT(NL80211_IFTYPE_STATION) |
+			 BIT(NL80211_IFTYPE_AP)
+	},
+	{
+		.max = 1,
+		.types = BIT(NL80211_IFTYPE_P2P_CLIENT) |
+			 BIT(NL80211_IFTYPE_P2P_GO)
+	},
+#ifndef CONFIG_P2P_INTF
+	{
+		.max = 1,
+		.types = BIT(NL80211_IFTYPE_P2P_DEVICE)
+	}
+#endif
+};
+
+static const struct ieee80211_iface_combination sprdwl_iface_combos[] = {
+	{
+#ifndef CONFIG_P2P_INTF
+		 .max_interfaces = 3,
+#else
+		 .max_interfaces = 2,
+#endif
+		 .num_different_channels = 2,
+		 .n_limits = ARRAY_SIZE(sprdwl_iface_limits),
+		 .limits = sprdwl_iface_limits
+	}
+};
+
+#ifdef CONFIG_PM
+static const struct wiphy_wowlan_support sprdwl_wowlan_support = {
+	.flags = WIPHY_WOWLAN_ANY | WIPHY_WOWLAN_DISCONNECT | WIPHY_WOWLAN_MAGIC_PKT,
+};
+#endif
+
+/* Interface related stuff*/
+inline void sprdwl_put_vif(struct sprdwl_vif *vif)
+{
+	if (vif) {
+		spin_lock_bh(&vif->priv->list_lock);
+		vif->ref--;
+		spin_unlock_bh(&vif->priv->list_lock);
+	}
+}
+
+inline struct sprdwl_vif *ctx_id_to_vif(struct sprdwl_priv *priv, u8 vif_ctx_id)
+{
+	struct sprdwl_vif *vif, *found = NULL;
+
+	spin_lock_bh(&priv->list_lock);
+	list_for_each_entry(vif, &priv->vif_list, vif_node) {
+		if (vif->ctx_id == vif_ctx_id) {
+			vif->ref++;
+			found = vif;
+			break;
+		}
+	}
+	spin_unlock_bh(&priv->list_lock);
+
+	return found;
+}
+
+inline struct sprdwl_vif *mode_to_vif(struct sprdwl_priv *priv, u8 vif_mode)
+{
+	struct sprdwl_vif *vif, *found = NULL;
+
+	spin_lock_bh(&priv->list_lock);
+	list_for_each_entry(vif, &priv->vif_list, vif_node) {
+		if (vif->mode == vif_mode) {
+			vif->ref++;
+			found = vif;
+			break;
+		}
+	}
+	spin_unlock_bh(&priv->list_lock);
+
+	return found;
+}
+
+static inline enum sprdwl_mode type_to_mode(enum nl80211_iftype type)
+{
+	enum sprdwl_mode mode;
+
+	switch (type) {
+	case NL80211_IFTYPE_STATION:
+		mode = SPRDWL_MODE_STATION;
+		break;
+	case NL80211_IFTYPE_AP:
+		mode = SPRDWL_MODE_AP;
+		break;
+	case NL80211_IFTYPE_P2P_GO:
+		mode = SPRDWL_MODE_P2P_GO;
+		break;
+	case NL80211_IFTYPE_P2P_CLIENT:
+		mode = SPRDWL_MODE_P2P_CLIENT;
+		break;
+	case NL80211_IFTYPE_P2P_DEVICE:
+		mode = SPRDWL_MODE_P2P_DEVICE;
+		break;
+#ifdef IBSS_SUPPORT
+	case NL80211_IFTYPE_ADHOC:
+		mode = SPRDWL_MODE_IBSS;
+		break;
+#endif /* IBSS_SUPPORT */
+	default:
+		mode = SPRDWL_MODE_NONE;
+		break;
+	}
+
+	return mode;
+}
+
+int sprdwl_init_fw(struct sprdwl_vif *vif)
+{
+	struct sprdwl_priv *priv = vif->priv;
+	enum nl80211_iftype type = vif->wdev.iftype;
+	enum sprdwl_mode mode;
+	u8 *mac;
+	u8 vif_ctx_id = 0;
+
+	wl_ndev_log(L_DBG, vif->ndev, "%s type %d, mode %d\n", __func__, type,
+		    vif->mode);
+
+	if (vif->mode != SPRDWL_MODE_NONE) {
+		wl_ndev_log(L_ERR, vif->ndev, "%s already in use: mode %d\n",
+			   __func__, vif->mode);
+		return -EBUSY;
+	}
+
+	mode = type_to_mode(type);
+	if ((mode <= SPRDWL_MODE_NONE) || (mode >= SPRDWL_MODE_MAX)) {
+		wl_ndev_log(L_ERR, vif->ndev, "%s unsupported interface type: %d\n",
+			   __func__, type);
+		return -EINVAL;
+	}
+
+#ifdef CONFIG_P2P_INTF
+	if (type == NL80211_IFTYPE_STATION) {
+		if (!strncmp(vif->ndev->name, "p2p0", 4))
+			mode = SPRDWL_MODE_P2P_CLIENT;
+	}
+#endif
+	if (priv->fw_stat[mode] == SPRDWL_INTF_OPEN) {
+		wl_ndev_log(L_ERR, vif->ndev, "%s mode %d already opened\n",
+			   __func__, mode);
+		return 0;
+	}
+
+	vif->mode = mode;
+	if (!vif->ndev)
+		mac = vif->wdev.address;
+	else
+		mac = vif->ndev->dev_addr;
+
+	if (sprdwl_open_fw(priv, &vif_ctx_id, vif->mode, mac)) {
+		wl_ndev_log(L_ERR, vif->ndev, "%s failed!\n", __func__);
+		vif->mode = SPRDWL_MODE_NONE;
+		return -EIO;
+	}
+	vif->ctx_id  = vif_ctx_id;
+	wl_ndev_log(L_DBG, vif->ndev, "%s,open success type %d, mode:%d, ctx_id:%d\n",
+		    __func__, type,
+		    vif->mode, vif->ctx_id);
+	priv->fw_stat[vif->mode] = SPRDWL_INTF_OPEN;
+
+	return 0;
+}
+
+int sprdwl_uninit_fw(struct sprdwl_vif *vif)
+{
+	struct sprdwl_priv *priv = vif->priv;
+	struct sprdwl_intf *intf = (struct sprdwl_intf *)(priv->hw_priv);
+	struct sprdwl_tx_msg *tx_msg = (struct sprdwl_tx_msg *)intf->sprdwl_tx;
+	u8 count = 0;
+
+	if ((vif->mode <= SPRDWL_MODE_NONE) || (vif->mode >= SPRDWL_MODE_MAX)) {
+		wl_ndev_log(L_ERR, vif->ndev, "%s invalid operation mode: %d\n",
+			   __func__, vif->mode);
+		return -EINVAL;
+	}
+
+	if (priv->fw_stat[vif->mode] == SPRDWL_INTF_CLOSE) {
+		wl_ndev_log(L_ERR, vif->ndev, "%s mode %d already closed\n",
+			   __func__, vif->mode);
+		return -EBUSY;
+	}
+
+	priv->fw_stat[vif->mode] = SPRDWL_INTF_CLOSING;
+
+	/*flush data belong to this mode*/
+	if (atomic_read(&tx_msg->tx_list[vif->mode]->mode_list_num) > 0)
+		sprdwl_flush_mode_txlist(tx_msg, vif->mode);
+
+	/*here we need to wait for 3s to avoid there
+	 *is still data of this modeattached to sdio not poped
+	 */
+	while ((!list_empty(&tx_msg->xmit_msg_list.to_send_list) ||
+			!list_empty(&tx_msg->xmit_msg_list.to_free_list)) &&
+			count < 100) {
+		wl_err_ratelimited("error! %s data q not empty, wait\n", __func__);
+		usleep_range(2500, 3000);
+		count++;
+	}
+
+	if (sprdwl_close_fw(priv, vif->ctx_id, vif->mode)) {
+		wl_ndev_log(L_ERR, vif->ndev, "%s failed!\n", __func__);
+		return -EIO;
+	}
+
+	priv->fw_stat[vif->mode] = SPRDWL_INTF_CLOSE;
+
+	handle_tx_status_after_close(vif);
+
+	wl_ndev_log(L_DBG, vif->ndev, "%s type %d, mode %d\n", __func__,
+		    vif->wdev.iftype, vif->mode);
+	vif->mode = SPRDWL_MODE_NONE;
+
+	return 0;
+}
+
+static inline int sprdwl_is_valid_iftype(struct wiphy *wiphy,
+					 enum nl80211_iftype type)
+{
+	return wiphy->interface_modes & BIT(type);
+}
+
+int sprdwl_check_p2p_coex(struct sprdwl_priv *priv)
+{
+	if (mode_to_vif(priv, SPRDWL_MODE_P2P_CLIENT) ||
+		mode_to_vif(priv, SPRDWL_MODE_P2P_GO))
+		return -1;
+
+	return 0;
+}
+
+#ifndef CONFIG_P2P_INTF
+static struct wireless_dev *sprdwl_cfg80211_add_iface(struct wiphy *wiphy,
+						      const char *name,
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 4, 83)
+							  unsigned char name_assign_type,
+#endif
+						      enum nl80211_iftype type,
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4, 14, 0)
+						      u32 *flags,
+#endif
+						      struct vif_params *params)
+{
+	enum sprdwl_mode mode;
+	enum nl80211_iftype iftype = type;
+	struct sprdwl_priv *priv = wiphy_priv(wiphy);
+
+	if (!sprdwl_is_valid_iftype(wiphy, type)) {
+		wl_err("%s unsupported interface type: %u\n", __func__, type);
+		return ERR_PTR(-EINVAL);
+	}
+
+	if (sprdwl_check_p2p_coex(priv)) {
+		wl_err("%s P2P mode already exist type: %u not allowed\n",
+		       __func__, type);
+		return ERR_PTR(-EINVAL);
+	}
+
+	mode = type_to_mode(type);
+	if (priv->fw_stat[mode] == SPRDWL_INTF_OPEN) {
+		if (type == NL80211_IFTYPE_STATION) {
+			iftype = NL80211_IFTYPE_AP;
+			wl_warn("%s: type %d --> %d\n", __func__, type, iftype);
+		}
+	}
+
+	return sprdwl_add_iface(priv, name, iftype, params->macaddr);
+}
+#endif
+
+static int sprdwl_cfg80211_del_iface(struct wiphy *wiphy,
+				     struct wireless_dev *wdev)
+{
+	struct sprdwl_priv *priv = wiphy_priv(wiphy);
+	struct sprdwl_vif *vif = NULL, *tmp_vif = NULL;
+
+	if (sprdwl_intf_is_exit(priv)) {
+		wiphy_err(wiphy, "%s driver removing!\n", __func__);
+		return 0;
+	}
+	spin_lock_bh(&priv->list_lock);
+	list_for_each_entry_safe(vif, tmp_vif, &priv->vif_list, vif_node) {
+		if (&vif->wdev == wdev)
+			break;
+	}
+	spin_unlock_bh(&priv->list_lock);
+
+	if (vif != NULL) {
+		sprdwl_del_iface(priv, vif);
+
+		spin_lock_bh(&priv->list_lock);
+		list_del(&vif->vif_node);
+		spin_unlock_bh(&priv->list_lock);
+	}
+
+	return 0;
+}
+
+static int sprdwl_cfg80211_change_iface(struct wiphy *wiphy,
+					struct net_device *ndev,
+					enum nl80211_iftype type,
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4, 14, 0)
+					u32 *flags,
+#endif
+					struct vif_params *params)
+{
+	struct sprdwl_vif *vif = netdev_priv(ndev);
+	enum nl80211_iftype old_type = vif->wdev.iftype;
+	int ret;
+
+	wl_ndev_log(L_DBG, ndev, "%s type %d -> %d\n", __func__, old_type, type);
+
+	if (!sprdwl_is_valid_iftype(wiphy, type)) {
+		wl_err("%s unsupported interface type: %u\n", __func__, type);
+		return -EOPNOTSUPP;
+	}
+
+	ret = sprdwl_uninit_fw(vif);
+	if (!ret) {
+		vif->wdev.iftype = type;
+		ret = sprdwl_init_fw(vif);
+		if (ret)
+			vif->wdev.iftype = old_type;
+	}
+
+	return ret;
+}
+
+static inline u8 sprdwl_parse_akm(u32 akm)
+{
+	u8 ret;
+
+	switch (akm) {
+	case WLAN_AKM_SUITE_PSK:
+		ret = SPRDWL_AKM_SUITE_PSK;
+		break;
+	case WLAN_AKM_SUITE_8021X:
+		ret = SPRDWL_AKM_SUITE_8021X;
+		break;
+	case WLAN_AKM_SUITE_FT_PSK:
+		ret = SPRDWL_AKM_SUITE_FT_PSK;
+		break;
+	case WLAN_AKM_SUITE_FT_8021X:
+		ret = SPRDWL_AKM_SUITE_FT_8021X;
+		break;
+	case WLAN_AKM_SUITE_WAPI_PSK:
+		ret = SPRDWL_AKM_SUITE_WAPI_PSK;
+		break;
+	case WLAN_AKM_SUITE_WAPI_CERT:
+		ret = SPRDWL_AKM_SUITE_WAPI_CERT;
+		break;
+	case WLAN_AKM_SUITE_PSK_SHA256:
+		ret = SPRDWL_AKM_SUITE_PSK_SHA256;
+		break;
+	case WLAN_AKM_SUITE_8021X_SHA256:
+		ret = SPRDWL_AKM_SUITE_8021X_SHA256;
+		break;
+	default:
+		ret = SPRDWL_AKM_SUITE_NONE;
+		break;
+	}
+
+	return ret;
+}
+
+/* Encryption related stuff */
+static inline u8 sprdwl_parse_cipher(u32 cipher)
+{
+	u8 ret;
+
+	switch (cipher) {
+	case WLAN_CIPHER_SUITE_WEP40:
+		ret = SPRDWL_CIPHER_WEP40;
+		break;
+	case WLAN_CIPHER_SUITE_WEP104:
+		ret = SPRDWL_CIPHER_WEP104;
+		break;
+	case WLAN_CIPHER_SUITE_TKIP:
+		ret = SPRDWL_CIPHER_TKIP;
+		break;
+	case WLAN_CIPHER_SUITE_CCMP:
+		ret = SPRDWL_CIPHER_CCMP;
+		break;
+	case WLAN_CIPHER_SUITE_SMS4:
+		ret = SPRDWL_CIPHER_WAPI;
+		break;
+	case WLAN_CIPHER_SUITE_AES_CMAC:
+		ret = SPRDWL_CIPHER_AES_CMAC;
+		break;
+	default:
+		ret = SPRDWL_CIPHER_NONE;
+		break;
+	}
+
+	return ret;
+}
+
+static int sprdwl_add_cipher_key(struct sprdwl_vif *vif, bool pairwise,
+				 u8 key_index, u32 cipher, const u8 *key_seq,
+				 const u8 *mac_addr)
+{
+	u8 *cipher_ptr = pairwise ? &vif->prwise_crypto : &vif->grp_crypto;
+	int ret = 0;
+
+	wl_ndev_log(L_DBG, vif->ndev, "%s %s key_index %d\n", __func__,
+		    pairwise ? "pairwise" : "group", key_index);
+
+	if (vif->key_len[pairwise][0] || vif->key_len[pairwise][1] ||
+	    vif->key_len[pairwise][2] || vif->key_len[pairwise][3]) {
+		*cipher_ptr = vif->prwise_crypto = sprdwl_parse_cipher(cipher);
+
+		ret = sprdwl_add_key(vif->priv, vif->ctx_id,
+				     vif->key[pairwise][key_index],
+				     vif->key_len[pairwise][key_index],
+				     pairwise, key_index, key_seq,
+				     *cipher_ptr, mac_addr);
+	}
+
+	return ret;
+}
+
+static int sprdwl_cfg80211_add_key(struct wiphy *wiphy, struct net_device *ndev,
+				   u8 key_index, bool pairwise,
+				   const u8 *mac_addr,
+				   struct key_params *params)
+{
+	struct sprdwl_vif *vif = netdev_priv(ndev);
+
+	vif->key_index[pairwise] = key_index;
+	vif->key_len[pairwise][key_index] = params->key_len;
+	memcpy(vif->key[pairwise][key_index], params->key, params->key_len);
+
+	/* PMK is for Roaming offload */
+	if (params->cipher == WLAN_CIPHER_SUITE_PMK)
+		return sprdwl_set_roam_offload(vif->priv, vif->ctx_id,
+					       SPRDWL_ROAM_OFFLOAD_SET_PMK,
+					       params->key, params->key_len);
+	else
+		return sprdwl_add_cipher_key(vif, pairwise, key_index,
+					     params->cipher, params->seq,
+					     mac_addr);
+}
+
+static int sprdwl_cfg80211_del_key(struct wiphy *wiphy, struct net_device *ndev,
+				   u8 key_index, bool pairwise,
+				   const u8 *mac_addr)
+{
+	struct sprdwl_vif *vif = netdev_priv(ndev);
+
+	wl_ndev_log(L_DBG, ndev, "%s key_index=%d, pairwise=%d\n",
+		    __func__, key_index, pairwise);
+
+	if (key_index > SPRDWL_MAX_KEY_INDEX) {
+		wl_ndev_log(L_ERR, ndev, "%s key index %d out of bounds!\n", __func__,
+			   key_index);
+		return -ENOENT;
+	}
+
+	if (!vif->key_len[pairwise][key_index]) {
+		wl_ndev_log(L_ERR, ndev, "%s key index %d is empty!\n", __func__,
+			   key_index);
+		return 0;
+	}
+
+	vif->key_len[pairwise][key_index] = 0;
+	vif->prwise_crypto = SPRDWL_CIPHER_NONE;
+	vif->grp_crypto = SPRDWL_CIPHER_NONE;
+
+	return sprdwl_del_key(vif->priv, vif->ctx_id, key_index,
+			      pairwise, mac_addr);
+}
+
+static int sprdwl_cfg80211_set_default_key(struct wiphy *wiphy,
+					   struct net_device *ndev,
+					   u8 key_index, bool unicast,
+					   bool multicast)
+{
+	struct sprdwl_vif *vif = netdev_priv(ndev);
+
+	wl_debug("%s:enter\n", __func__);
+	if (key_index > 3) {
+		wl_ndev_log(L_ERR, ndev, "%s invalid key index: %d\n", __func__,
+			   key_index);
+		return -EINVAL;
+	}
+
+	return sprdwl_set_def_key(vif->priv, vif->ctx_id, key_index);
+}
+
+static int sprdwl_cfg80211_set_rekey(struct wiphy *wiphy,
+					struct net_device *ndev,
+					struct cfg80211_gtk_rekey_data *data)
+{
+	struct sprdwl_vif *vif = netdev_priv(ndev);
+
+	wl_info("%s:enter:\n", __func__);
+	return sprdwl_set_rekey_data(vif->priv, vif->ctx_id, data);
+}
+
+/* SoftAP related stuff */
+int sprdwl_change_beacon(struct sprdwl_vif *vif,
+		struct cfg80211_beacon_data *beacon)
+{
+	int ret = 0;
+
+	if (!beacon)
+		return -EINVAL;
+
+	if (beacon->beacon_ies_len) {
+		wl_ndev_log(L_DBG, vif->ndev, "set beacon extra IE\n");
+		ret = sprdwl_set_ie(vif->priv, vif->ctx_id, SPRDWL_IE_BEACON,
+				    beacon->beacon_ies, beacon->beacon_ies_len);
+	}
+
+	if (beacon->proberesp_ies_len) {
+		wl_ndev_log(L_DBG, vif->ndev, "set probe response extra IE\n");
+		ret = sprdwl_set_ie(vif->priv, vif->ctx_id,
+				    SPRDWL_IE_PROBE_RESP,
+				    beacon->proberesp_ies,
+				    beacon->proberesp_ies_len);
+	}
+
+	if (beacon->assocresp_ies_len) {
+		wl_ndev_log(L_DBG, vif->ndev, "set associate response extra IE\n");
+		ret = sprdwl_set_ie(vif->priv, vif->ctx_id,
+				    SPRDWL_IE_ASSOC_RESP,
+				    beacon->assocresp_ies,
+				    beacon->assocresp_ies_len);
+	}
+
+	if (ret)
+		wl_ndev_log(L_ERR, vif->ndev, "%s failed\n", __func__);
+
+	return ret;
+}
+
+static int sprdwl_cfg80211_start_ap(struct wiphy *wiphy,
+				    struct net_device *ndev,
+				    struct cfg80211_ap_settings *settings)
+{
+	struct sprdwl_vif *vif = netdev_priv(ndev);
+	struct cfg80211_beacon_data *beacon = &settings->beacon;
+	struct ieee80211_mgmt *mgmt;
+	u16 mgmt_len, index = 0, hidden_index;
+	u8 *data = NULL;
+	int ret;
+
+	wl_ndev_log(L_DBG, ndev, "%s\n", __func__);
+
+#ifdef ACS_SUPPORT
+	if ((vif->mode == SPRDWL_MODE_AP) &&
+	    !list_empty(&vif->survey_info_list)) {
+		clean_survey_info_list(vif);
+	}
+#endif
+
+#ifdef DFS_MASTER
+	if (settings->beacon_interval)
+		vif->priv->beacon_period = settings->beacon_interval;
+#endif
+
+	if (!settings->ssid) {
+		wl_ndev_log(L_ERR, ndev, "%s invalid SSID!\n", __func__);
+		return -EINVAL;
+	}
+	strncpy(vif->ssid, settings->ssid, settings->ssid_len);
+	vif->ssid_len = settings->ssid_len;
+
+	sprdwl_hook_reset_channel(wiphy, settings);
+
+	sprdwl_change_beacon(vif, beacon);
+
+	if (!beacon->head)
+		return -EINVAL;
+
+	mgmt_len = beacon->head_len;
+	/* add 1 byte for hidden ssid flag */
+	mgmt_len += 1;
+	if (settings->hidden_ssid != 0)
+		mgmt_len += settings->ssid_len;
+
+	if (beacon->tail)
+		mgmt_len += beacon->tail_len;
+
+	mgmt = kmalloc(mgmt_len, GFP_KERNEL);
+	if (!mgmt)
+		return -ENOMEM;
+	data = (u8 *)mgmt;
+
+#define SSID_LEN_OFFSET		(37)
+	memcpy(data, beacon->head, SSID_LEN_OFFSET);
+	index += SSID_LEN_OFFSET;
+	/* modify ssid_len */
+	*(data + index) = (u8)(settings->ssid_len + 1);
+	index += 1;
+	/* copy ssid */
+	strncpy(data + index, settings->ssid, settings->ssid_len);
+	index += settings->ssid_len;
+	/* set hidden ssid flag */
+	*(data + index) = (u8)settings->hidden_ssid;
+	index += 1;
+	/* cope left settings */
+	if (settings->hidden_ssid != 0)
+		hidden_index = (index - settings->ssid_len);
+	else
+		hidden_index = index;
+
+	memcpy(data + index, beacon->head + hidden_index - 1,
+	       beacon->head_len + 1 - hidden_index);
+
+	if (beacon->tail)
+		memcpy(data + beacon->head_len + 1 +
+			(settings->hidden_ssid != 0 ? settings->ssid_len : 0),
+		       beacon->tail, beacon->tail_len);
+
+	ret = sprdwl_start_ap(vif->priv, vif->ctx_id, (unsigned char *)mgmt,
+			      mgmt_len);
+	kfree(mgmt);
+#ifdef DFS_MASTER
+	if (!netif_carrier_ok(vif->ndev))
+		netif_carrier_on(vif->ndev);
+	if (netif_queue_stopped(vif->ndev))
+		netif_wake_queue(vif->ndev);
+#endif
+	if (ret)
+		wl_ndev_log(L_ERR, ndev, "%s failed to start AP!\n", __func__);
+	else
+		netif_carrier_on(vif->ndev);
+
+	return ret;
+}
+
+static int sprdwl_cfg80211_change_beacon(struct wiphy *wiphy,
+					 struct net_device *ndev,
+					 struct cfg80211_beacon_data *beacon)
+{
+	struct sprdwl_vif *vif = netdev_priv(ndev);
+
+	wl_ndev_log(L_DBG, ndev, "%s\n", __func__);
+#ifdef DFS_MASTER
+	/*send beacon tail ie if needed*/
+	if (beacon->tail_len)
+		sprdwl_reset_beacon(vif->priv, vif->ctx_id,
+				beacon->tail, beacon->tail_len);
+	/*enable wifi traffic*/
+	if (!netif_carrier_ok(vif->ndev))
+		netif_carrier_on(vif->ndev);
+	if (netif_queue_stopped(vif->ndev))
+		netif_wake_queue(vif->ndev);
+#endif
+
+	return sprdwl_change_beacon(vif, beacon);
+}
+
+static int sprdwl_cfg80211_stop_ap(struct wiphy *wiphy, struct net_device *ndev)
+{
+#ifdef DFS_MASTER
+	struct sprdwl_vif *vif = netdev_priv(ndev);
+#endif
+	wl_ndev_log(L_DBG, ndev, "%s\n", __func__);
+#ifdef DFS_MASTER
+	sprdwl_abort_cac(vif);
+#endif
+
+	netif_carrier_off(ndev);
+	return 0;
+}
+
+static int sprdwl_cfg80211_add_station(struct wiphy *wiphy,
+				       struct net_device *ndev, const u8 *mac,
+				       struct station_parameters *params)
+{
+	return 0;
+}
+
+static int sprdwl_cfg80211_del_station(struct wiphy *wiphy,
+				       struct net_device *ndev,
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 4, 83)
+					   struct station_del_parameters *params
+#else
+					   const u8 *mac
+#endif
+					)
+
+{
+	struct sprdwl_vif *vif = netdev_priv(ndev);
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 4, 83)
+	if (!params->mac) {
+#else
+	if (!mac) {
+#endif
+		wl_ndev_log(L_DBG, ndev, "ignore NULL MAC address!\n");
+		goto out;
+	}
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 4, 83)
+	wl_ndev_log(L_DBG, ndev, "%s %pM reason:%d\n", __func__, params->mac,
+			params->reason_code);
+	sprdwl_del_station(vif->priv, vif->ctx_id, params->mac,
+			params->reason_code);
+#else
+	wl_ndev_log(L_DBG, ndev, "%s %pM\n", __func__, mac);
+	sprdwl_del_station(vif->priv, vif->ctx_id, mac,
+			   WLAN_REASON_DEAUTH_LEAVING);
+#endif
+
+	trace_deauth_reason(vif->mode, WLAN_REASON_DEAUTH_LEAVING, LOCAL_EVENT);
+out:
+	return 0;
+}
+
+static int
+sprdwl_cfg80211_change_station(struct wiphy *wiphy,
+			       struct net_device *ndev, const u8 *mac,
+			       struct station_parameters *params)
+{
+	return 0;
+}
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 4, 83)
+static int sprdwl_cfg80211_get_station(struct wiphy *wiphy,
+				       struct net_device *ndev, const u8 *mac,
+				       struct station_info *sinfo)
+{
+	struct sprdwl_vif *vif = netdev_priv(ndev);
+	struct sprdwl_cmd_get_station sta;
+	struct sprdwl_rate_info *rate;
+	int ret;
+
+	sinfo->filled |= BIT(NL80211_STA_INFO_TX_BYTES) |
+			 BIT(NL80211_STA_INFO_TX_PACKETS) |
+			 BIT(NL80211_STA_INFO_RX_BYTES) |
+			 BIT(NL80211_STA_INFO_RX_PACKETS);
+	sinfo->tx_bytes = ndev->stats.tx_bytes;
+	sinfo->tx_packets = ndev->stats.tx_packets;
+	sinfo->rx_bytes = ndev->stats.rx_bytes;
+	sinfo->rx_packets = ndev->stats.rx_packets;
+
+	/* Get current station info */
+	ret = sprdwl_get_station(vif->priv, vif->ctx_id,
+				 &sta);
+	if (ret)
+		goto out;
+	rate = (struct sprdwl_rate_info *)&sta;
+
+	sinfo->signal = sta.signal;
+	sinfo->filled |= BIT(NL80211_STA_INFO_SIGNAL);
+
+	sinfo->tx_failed = sta.txfailed;
+	sinfo->filled |= BIT(NL80211_STA_INFO_TX_BITRATE) |
+		BIT(NL80211_STA_INFO_TX_FAILED);
+
+	/*fill rate info */
+	/*if bit 2,3,4 not set*/
+	if (!(rate->flags & 0x1c))
+		sinfo->txrate.bw = RATE_INFO_BW_20;
+
+	if ((rate->flags) & BIT(2))
+		sinfo->txrate.bw = RATE_INFO_BW_40;
+
+	if ((rate->flags) & BIT(3))
+		sinfo->txrate.bw = RATE_INFO_BW_80;
+
+	if ((rate->flags) & BIT(4) ||
+		(rate->flags) & BIT(5))
+		sinfo->txrate.bw = RATE_INFO_BW_160;
+
+	if ((rate->flags) & BIT(6))
+		sinfo->txrate.flags |= RATE_INFO_FLAGS_SHORT_GI;
+
+	if ((rate->flags & RATE_INFO_FLAGS_MCS) ||
+		(rate->flags & RATE_INFO_FLAGS_VHT_MCS)) {
+
+		sinfo->txrate.flags = (rate->flags & 0x3);
+		sinfo->txrate.mcs = rate->mcs;
+
+		if ((rate->flags & RATE_INFO_FLAGS_VHT_MCS) &&
+			(0 != rate->nss)) {
+			sinfo->txrate.nss = rate->nss;
+		}
+	} else {
+		sinfo->txrate.legacy = rate->legacy;
+	}
+
+	wl_ndev_log(L_DBG, ndev, "%s signal %d legacy %d mcs:%d flags:0x:%x\n",
+			__func__, sinfo->signal, sinfo->txrate.legacy,
+			rate->mcs, rate->flags);
+out:
+	return ret;
+}
+
+#else
+static int sprdwl_cfg80211_get_station(struct wiphy *wiphy,
+				       struct net_device *ndev, const u8 *mac,
+				       struct station_info *sinfo)
+{
+	struct sprdwl_vif *vif = netdev_priv(ndev);
+	struct sprdwl_cmd_get_station sta;
+	struct sprdwl_rate_info *rate;
+	int ret;
+
+	sinfo->filled |= STATION_INFO_TX_BYTES |
+			 STATION_INFO_TX_PACKETS |
+			 STATION_INFO_RX_BYTES |
+			 STATION_INFO_RX_PACKETS;
+	sinfo->tx_bytes = ndev->stats.tx_bytes;
+	sinfo->tx_packets = ndev->stats.tx_packets;
+	sinfo->rx_bytes = ndev->stats.rx_bytes;
+	sinfo->rx_packets = ndev->stats.rx_packets;
+
+	/* Get current station info */
+	ret = sprdwl_get_station(vif->priv, vif->ctx_id,
+				 &sta);
+	if (ret)
+		goto out;
+	rate = (struct sprdwl_rate_info *)&sta;
+
+	sinfo->signal = sta.signal;
+	sinfo->filled |= STATION_INFO_SIGNAL;
+
+	sinfo->tx_failed = sta.txfailed;
+	sinfo->filled |= STATION_INFO_TX_BITRATE | STATION_INFO_TX_FAILED;
+
+	/*fill rate info */
+	if ((rate->flags & RATE_INFO_FLAGS_MCS) ||
+		(rate->flags & RATE_INFO_FLAGS_VHT_MCS)) {
+
+		sinfo->txrate.flags = rate->flags;
+		sinfo->txrate.mcs = rate->mcs;
+
+		if ((rate->flags & RATE_INFO_FLAGS_VHT_MCS) &&
+			(0 != rate->nss)) {
+			sinfo->txrate.nss = rate->nss;
+		}
+	} else {
+		sinfo->txrate.legacy = rate->legacy;
+	}
+
+	wl_ndev_log(L_DBG, ndev, "%s signal %d legacy %d mcs:%d flags:0x:%x\n",
+			__func__, sinfo->signal, sinfo->txrate.legacy,
+			rate->mcs, rate->flags);
+out:
+	return ret;
+}
+#endif
+
+static int sprdwl_cfg80211_set_channel(struct wiphy *wiphy,
+				       struct net_device *ndev,
+				       struct ieee80211_channel *chan)
+{
+	struct sprdwl_vif *vif = netdev_priv(ndev);
+
+	return sprdwl_set_channel(vif->priv, vif->ctx_id,
+				  ieee80211_frequency_to_channel
+				  (chan->center_freq));
+}
+
+void sprdwl_report_softap(struct sprdwl_vif *vif, u8 is_connect, u8 *addr,
+			  u8 *req_ie, u16 req_ie_len)
+{
+	struct station_info sinfo;
+
+	/*P2P device is NULL net device,and should return if
+	 * vif->ndev is NULL.
+	 * */
+
+	if (!addr || !vif->ndev)
+		return;
+
+	memset(&sinfo, 0, sizeof(sinfo));
+	if (req_ie_len > 0) {
+		sinfo.assoc_req_ies = req_ie;
+		sinfo.assoc_req_ies_len = req_ie_len;
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4, 4, 83)
+		sinfo.filled |= STATION_INFO_ASSOC_REQ_IES;
+#endif
+	}
+
+	if (is_connect) {
+		if (!netif_carrier_ok(vif->ndev)) {
+			netif_carrier_on(vif->ndev);
+			netif_wake_queue(vif->ndev);
+		}
+		cfg80211_new_sta(vif->ndev, addr, &sinfo, GFP_KERNEL);
+		wl_ndev_log(L_DBG, vif->ndev, "New station (%pM) connected\n", addr);
+	} else {
+		cfg80211_del_sta(vif->ndev, addr, GFP_KERNEL);
+		wl_ndev_log(L_DBG, vif->ndev, "The station (%pM) disconnected\n",
+			    addr);
+		trace_deauth_reason(vif->mode, 0, REMOTE_EVENT);
+	}
+}
+
+/* Station related stuff */
+static void sprdwl_cancel_scan(struct sprdwl_vif *vif)
+{
+	struct sprdwl_priv *priv = vif->priv;
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 7, 0)
+	struct cfg80211_scan_info info = {
+		.aborted = true,
+	};
+#endif
+
+	wl_info("%s enter==\n", __func__);
+
+	if (priv->scan_vif && priv->scan_vif == vif) {
+		if (timer_pending(&priv->scan_timer))
+			del_timer_sync(&priv->scan_timer);
+
+		spin_lock_bh(&priv->scan_lock);
+
+		if (priv->scan_request) {
+#ifdef ACS_SUPPORT
+			if (vif->mode == SPRDWL_MODE_AP)
+				transfer_survey_info(vif);
+#endif
+			/*delete scan node*/
+			if (!list_empty(&vif->scan_head_ptr))
+				clean_scan_list(vif);
+
+			wl_debug("%s:scan request addr:%p",
+					__func__, priv->scan_request);
+			if (priv->scan_request->n_channels != 0)
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 7, 0)
+				cfg80211_scan_done(priv->scan_request, &info);
+#else
+				cfg80211_scan_done(priv->scan_request, true);
+#endif
+			else
+				wl_err("%s, %d, error, scan_request freed",
+				       __func__, __LINE__);
+			priv->scan_request = NULL;
+			priv->scan_vif = NULL;
+		}
+		spin_unlock_bh(&priv->scan_lock);
+	}
+
+#if 0 /* Avoid set assert during hang recovery */
+	wlan_set_assert(vif->priv, vif->ctx_id, WIFI_CMD_SCAN, SCAN_ERROR);
+#endif
+}
+
+static void sprdwl_cancel_sched_scan(struct sprdwl_vif *vif)
+{
+	struct sprdwl_priv *priv = vif->priv;
+
+	if (priv->sched_scan_vif && priv->sched_scan_vif == vif) {
+		spin_lock_bh(&priv->sched_scan_lock);
+		if (priv->sched_scan_request) {
+			priv->sched_scan_request = NULL;
+			priv->sched_scan_vif = NULL;
+		}
+		spin_unlock_bh(&priv->sched_scan_lock);
+	}
+}
+
+void sprdwl_scan_done(struct sprdwl_vif *vif, bool abort)
+{
+	struct sprdwl_priv *priv = vif->priv;
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 7, 0)
+	struct cfg80211_scan_info info = {
+		.aborted = abort,
+	};
+#endif
+
+	if (priv->scan_vif && priv->scan_vif == vif) {
+		if (timer_pending(&priv->scan_timer))
+			del_timer_sync(&priv->scan_timer);
+
+		spin_lock_bh(&priv->scan_lock);
+		if (priv->scan_request) {
+#ifdef ACS_SUPPORT
+			if (vif->mode == SPRDWL_MODE_AP)
+				transfer_survey_info(vif);
+#endif
+			/*delete scan node*/
+			if (!list_empty(&vif->scan_head_ptr))
+				clean_scan_list(vif);
+
+			wl_debug("%s:scan request addr:%p",
+					__func__, priv->scan_request);
+			if (priv->scan_request->n_channels != 0) {
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 7, 0)
+				wl_ndev_log(L_DBG, vif->ndev, "%s scan is %s\n", __func__, abort ? "Aborted" : "Done");
+				cfg80211_scan_done(priv->scan_request, &info);
+#else
+				cfg80211_scan_done(priv->scan_request, abort);
+#endif
+			} else {
+				wl_err("%s, %d, error, scan_request freed",
+				       __func__, __LINE__);
+			}
+			priv->scan_request = NULL;
+			priv->scan_vif = NULL;
+		}
+		spin_unlock_bh(&priv->scan_lock);
+	}
+}
+
+void sprdwl_sched_scan_done(struct sprdwl_vif *vif, bool abort)
+{
+	struct sprdwl_priv *priv = vif->priv;
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 14, 0)
+	u64 reqid = 0;
+#endif
+
+	if (priv->sched_scan_vif && priv->sched_scan_vif == vif) {
+		spin_lock_bh(&priv->sched_scan_lock);
+		if (priv->sched_scan_request) {
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 14, 0)
+			cfg80211_sched_scan_results(vif->wdev.wiphy, reqid);
+#else
+			cfg80211_sched_scan_results(vif->wdev.wiphy);
+#endif
+			wl_ndev_log(L_DBG, priv->sched_scan_vif->ndev,
+				    "%s report result\n", __func__);
+			priv->sched_scan_request = NULL;
+			priv->sched_scan_vif = NULL;
+		}
+		spin_unlock_bh(&priv->sched_scan_lock);
+	}
+}
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 14, 0)
+void sprdwl_scan_timeout(struct timer_list *t)
+{
+	struct sprdwl_priv *priv = from_timer(priv, t, scan_timer);
+#else
+void sprdwl_scan_timeout(unsigned long data)
+{
+	struct sprdwl_priv *priv = (struct sprdwl_priv *)data;
+#endif
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 7, 0)
+	struct cfg80211_scan_info info = {
+		.aborted = true,
+	};
+#endif
+	wl_ndev_log(L_DBG, priv->scan_vif->ndev, "%s\n", __func__);
+
+	spin_lock_bh(&priv->scan_lock);
+	if (priv->scan_request) {
+#ifdef ACS_SUPPORT
+		clean_survey_info_list(priv->scan_vif);
+#endif /* ACS_SUPPORT */
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 7, 0)
+		cfg80211_scan_done(priv->scan_request, &info);
+#else
+		cfg80211_scan_done(priv->scan_request, true);
+#endif
+		priv->scan_vif = NULL;
+		priv->scan_request = NULL;
+	}
+	spin_unlock_bh(&priv->scan_lock);
+}
+
+static int sprdwl_cfg80211_scan(struct wiphy *wiphy,
+				struct cfg80211_scan_request *request)
+{
+	struct sprdwl_priv *priv = wiphy_priv(wiphy);
+	struct sprdwl_vif *vif =
+	    container_of(request->wdev, struct sprdwl_vif, wdev);
+	struct cfg80211_ssid *ssids = request->ssids;
+	struct sprdwl_scan_ssid *scan_ssids;
+	u8 *ssids_ptr = NULL;
+	int scan_ssids_len = 0;
+	u32 channels = 0;
+	unsigned int i, n;
+	int ret;
+	u16 n_5g_chn = 0, chns_5g[64];
+
+#ifdef RND_MAC_SUPPORT
+	u32 flags = request->flags;
+	static int random_mac_set;
+	int random_mac_flag;
+	static int old_mac_flag;
+#endif
+	struct sprdwl_intf *intf;
+	intf = (struct sprdwl_intf *)(priv->hw_priv);
+	if (intf->cp_asserted)
+		return -EIO;
+
+	wl_ndev_log(L_DBG, vif->ndev, "%s n_channels %u\n", __func__,
+		    request->n_channels);
+
+	if (!sprdwl_is_valid_iftype(wiphy, request->wdev->iftype)) {
+		wl_err("%s unsupported interface type: %u\n",
+		       __func__, request->wdev->iftype);
+		ret = -EOPNOTSUPP;
+		goto err;
+	}
+
+	if (priv->scan_request)
+		wl_ndev_log(L_ERR, vif->ndev, "%s error scan %p running [%p, %p]\n",
+			   __func__, priv->scan_request, priv->scan_vif, vif);
+
+#ifdef RND_MAC_SUPPORT
+	if (vif->mode == SPRDWL_MODE_STATION) {
+		if (!random_mac_set) {
+			random_mac_addr(rand_addr);
+			random_mac_set = 1;
+		}
+		if (flags & (1<<3)) {
+			random_mac_flag = 1;
+			wl_info("Random MAC support==set value:%d\n",
+			       random_mac_set);
+			wl_info("random mac addr: %pM\n", rand_addr);
+		} else {
+			wl_info("random mac feature disabled\n");
+			random_mac_flag = 0;
+		}
+		if (random_mac_flag != old_mac_flag) {
+			old_mac_flag = random_mac_flag;
+			wlan_cmd_set_rand_mac(vif->priv, vif->ctx_id,
+					      old_mac_flag, rand_addr);
+		}
+	}
+#endif
+
+	/* set WPS ie */
+	if (request->ie_len > 0) {
+		if (request->ie_len > 255) {
+			wl_ndev_log(L_ERR, vif->ndev, "%s invalid len: %zu\n", __func__,
+				   request->ie_len);
+			ret = -EOPNOTSUPP;
+			goto err;
+		}
+
+		ret = sprdwl_set_ie(priv, vif->ctx_id, SPRDWL_IE_PROBE_REQ,
+				    request->ie, request->ie_len);
+		if (ret)
+			goto err;
+	}
+
+	for (i = 0; i < request->n_channels; i++) {
+		switch (request->channels[i]->hw_value) {
+		case 0:
+			break;
+
+		case 1 ... 14:
+			channels |= (1 << (request->channels[i]->hw_value - 1));
+			break;
+
+		default:
+			if (n_5g_chn > ARRAY_SIZE(chns_5g))
+				break;
+			chns_5g[n_5g_chn] = request->channels[i]->hw_value;
+			n_5g_chn++;
+			break;
+		}
+#ifdef ACS_SUPPORT
+		if (vif->mode == SPRDWL_MODE_AP) {
+			struct sprdwl_survey_info *info = NULL;
+
+			if ((0 == i) && (!list_empty(&vif->survey_info_list))) {
+				wl_ndev_log(L_ERR, vif->ndev,
+					   "%s survey info list is not empty!\n",
+					   __func__);
+				clean_survey_info_list(vif);
+			}
+
+			info = kmalloc(sizeof(*info), GFP_KERNEL);
+			if (!info) {
+				ret = -ENOMEM;
+				goto err;
+			}
+
+			INIT_LIST_HEAD(&info->bssid_list);
+			info->chan = request->channels[i]->hw_value;
+			info->beacon_num = 0;
+			info->channel = NULL;
+			list_add_tail(&info->survey_list,
+				      &vif->survey_info_list);
+		}
+#endif /* ACS_SUPPORT */
+	}
+
+	n = min(request->n_ssids, 9);
+	if (n) {
+		ssids_ptr = kzalloc(512, GFP_KERNEL);
+		if (!ssids_ptr) {
+			wl_ndev_log(L_ERR, vif->ndev,
+				   "%s failed to alloc scan ssids!\n",
+				   __func__);
+			ret = -ENOMEM;
+			goto err;
+		}
+
+		scan_ssids = (struct sprdwl_scan_ssid *)ssids_ptr;
+		for (i = 0; i < n; i++) {
+			if (!ssids[i].ssid_len)
+				continue;
+			scan_ssids->len = ssids[i].ssid_len;
+			strncpy(scan_ssids->ssid, ssids[i].ssid,
+				ssids[i].ssid_len);
+			scan_ssids_len += (ssids[i].ssid_len
+					   + sizeof(scan_ssids->len));
+			scan_ssids = (struct sprdwl_scan_ssid *)
+			    (ssids_ptr + scan_ssids_len);
+		}
+	} else {
+#ifndef ACS_SUPPORT
+		wl_ndev_log(L_ERR, vif->ndev, "%s n_ssids is 0\n", __func__);
+		ret = -EINVAL;
+		goto err;
+#endif /* ACS_SUPPORT */
+	}
+
+	/*init scan list*/
+	init_scan_list(vif);
+
+	spin_lock_bh(&priv->scan_lock);
+	priv->scan_request = request;
+	priv->scan_vif = vif;
+	spin_unlock_bh(&priv->scan_lock);
+	wl_debug("%s:scan request addr:%p", __func__, request);
+	mod_timer(&priv->scan_timer,
+		  jiffies + SPRDWL_SCAN_TIMEOUT_MS * HZ / 1000);
+
+	ret = sprdwl_scan(vif->priv, vif->ctx_id, channels,
+			  scan_ssids_len, ssids_ptr, n_5g_chn, chns_5g);
+	kfree(ssids_ptr);
+	if (ret) {
+		sprdwl_cancel_scan(vif);
+		goto err;
+	}
+
+	return 0;
+err:
+	wl_ndev_log(L_ERR, vif->ndev, "%s failed (%d)\n", __func__, ret);
+	return ret;
+}
+
+static int sprdwl_cfg80211_sched_scan_start(struct wiphy *wiphy,
+					    struct net_device *ndev,
+					    struct cfg80211_sched_scan_request
+					    *request)
+{
+	struct sprdwl_priv *priv = wiphy_priv(wiphy);
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 4, 83)
+	struct cfg80211_sched_scan_plan *scan_plans = NULL;
+#endif
+	struct sprdwl_sched_scan_buf *sscan_buf = NULL;
+	struct sprdwl_vif *vif = NULL;
+	struct cfg80211_ssid *ssid_tmp = NULL;
+	struct cfg80211_match_set *match_ssid_tmp = NULL;
+	int ret = 0;
+	int i = 0, j = 0;
+	s32 min_rssi_thold;
+
+	if (!ndev) {
+		wl_ndev_log(L_ERR, ndev, "%s NULL ndev\n", __func__);
+		return ret;
+	}
+	vif = netdev_priv(ndev);
+	/*scan not allowed if closed*/
+	if (vif->priv->fw_stat[vif->mode] == SPRDWL_INTF_CLOSE) {
+		wl_err("%s, %d, error!mode%d scan after closed not allowed\n",
+		       __func__, __LINE__, vif->mode);
+		return -ENOMEM;
+	}
+
+	if (vif->priv->sched_scan_request) {
+		wl_ndev_log(L_ERR, ndev, "%s  schedule scan is running\n", __func__);
+		return 0;
+	}
+	/*to protect the size of struct sprdwl_sched_scan_buf*/
+	if (request->n_channels > TOTAL_2G_5G_CHANNEL_NUM) {
+		wl_err("%s, %d, error! request->n_channels=%d\n",
+		       __func__, __LINE__, request->n_channels);
+		request->n_channels = TOTAL_2G_5G_CHANNEL_NUM;
+	}
+	if (request->n_ssids > TOTAL_2G_5G_SSID_NUM) {
+		wl_err("%s, %d, error! request->n_ssids=%d\n",
+		       __func__, __LINE__, request->n_ssids);
+		request->n_ssids = TOTAL_2G_5G_SSID_NUM;
+	}
+	if (request->n_match_sets > TOTAL_2G_5G_SSID_NUM) {
+		wl_err("%s, %d, error! request->n_match_sets=%d\n",
+		       __func__, __LINE__, request->n_match_sets);
+		request->n_match_sets = TOTAL_2G_5G_SSID_NUM;
+	}
+	sscan_buf = kzalloc(sizeof(*sscan_buf), GFP_KERNEL);
+	if (!sscan_buf)
+		return -ENOMEM;
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 4, 83)
+	scan_plans = request->scan_plans;
+	sscan_buf->interval = scan_plans->interval;
+#else
+	sscan_buf->interval = DIV_ROUND_UP(request->interval, MSEC_PER_SEC);
+#endif
+	sscan_buf->flags = request->flags;
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 15, 0)
+	min_rssi_thold = request->min_rssi_thold;
+#else
+	min_rssi_thold = request->rssi_thold;
+#endif
+	if (min_rssi_thold <= NL80211_SCAN_RSSI_THOLD_OFF)
+		sscan_buf->rssi_thold = 0;
+	else if (min_rssi_thold < -127)
+		sscan_buf->rssi_thold = -127;
+	else
+		sscan_buf->rssi_thold = min_rssi_thold;
+
+	for (i = 0, j = 0; i < request->n_channels; i++) {
+		int ch = request->channels[i]->hw_value;
+
+		if (ch == 0) {
+			wl_ndev_log(L_DBG, ndev, "%s  unknown frequency %dMhz\n",
+				    __func__,
+				    request->channels[i]->center_freq);
+			continue;
+		}
+
+		wl_ndev_log(L_DBG, ndev, "%s: channel is %d\n", __func__, ch);
+		sscan_buf->channel[j + 1] = ch;
+		j++;
+	}
+	sscan_buf->channel[0] = j;
+
+	if (request->ssids && request->n_ssids > 0) {
+		sscan_buf->n_ssids = request->n_ssids;
+
+		for (i = 0; i < request->n_ssids; i++) {
+			ssid_tmp = request->ssids + i;
+			sscan_buf->ssid[i] = ssid_tmp->ssid;
+		}
+	}
+
+	if (request->match_sets && request->n_match_sets > 0) {
+		sscan_buf->n_match_ssids = request->n_match_sets;
+
+		for (i = 0; i < request->n_match_sets; i++) {
+			match_ssid_tmp = request->match_sets + i;
+			sscan_buf->mssid[i] = match_ssid_tmp->ssid.ssid;
+		}
+	}
+	sscan_buf->ie_len = request->ie_len;
+	sscan_buf->ie = request->ie;
+
+	spin_lock_bh(&priv->sched_scan_lock);
+	vif->priv->sched_scan_request = request;
+	vif->priv->sched_scan_vif = vif;
+	spin_unlock_bh(&priv->sched_scan_lock);
+
+	ret = sprdwl_sched_scan_start(priv, vif->ctx_id, sscan_buf);
+	if (ret)
+		sprdwl_cancel_sched_scan(vif);
+
+	kfree(sscan_buf);
+	return ret;
+}
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 14, 0)
+static int sprdwl_cfg80211_sched_scan_stop(struct wiphy *wiphy,
+					   struct net_device *ndev, u64 reqid)
+{
+#else
+static int sprdwl_cfg80211_sched_scan_stop(struct wiphy *wiphy,
+					   struct net_device *ndev)
+{
+#endif
+	struct sprdwl_priv *priv = wiphy_priv(wiphy);
+	struct sprdwl_vif *vif = NULL;
+	int ret = 0;
+
+	if (!ndev) {
+		wl_ndev_log(L_ERR, ndev, "%s NULL ndev\n", __func__);
+		return ret;
+	}
+	vif = netdev_priv(ndev);
+	ret = sprdwl_sched_scan_stop(priv, vif->ctx_id);
+	if (!ret) {
+		spin_lock_bh(&priv->sched_scan_lock);
+		vif->priv->sched_scan_request = NULL;
+		vif->priv->sched_scan_vif = NULL;
+		spin_unlock_bh(&priv->sched_scan_lock);
+	} else {
+		wl_ndev_log(L_ERR, ndev, "%s  scan stop failed\n", __func__);
+	}
+	return ret;
+}
+
+#ifdef SYNC_DISCONNECT
+void sprdwl_disconnect_handle(struct sprdwl_vif *vif)
+{
+	vif->sm_state = SPRDWL_DISCONNECTED;
+
+	/* Clear bssid & ssid */
+	memset(vif->bssid, 0, sizeof(vif->bssid));
+	memset(vif->ssid, 0, sizeof(vif->ssid));
+#ifdef WMMAC_WFA_CERTIFICATION
+	reset_wmmac_parameters(vif->priv);
+	reset_wmmac_ts_info();
+	init_default_qos_map();
+#endif
+	/* Stop netif */
+	if (netif_carrier_ok(vif->ndev)) {
+		netif_carrier_off(vif->ndev);
+		netif_stop_queue(vif->ndev);
+	}
+
+	/*clear link layer status data*/
+	memset(&vif->priv->pre_radio, 0, sizeof(vif->priv->pre_radio));
+}
+#endif
+static int sprdwl_cfg80211_disconnect(struct wiphy *wiphy,
+				      struct net_device *ndev, u16 reason_code)
+{
+	struct sprdwl_vif *vif = netdev_priv(ndev);
+	enum sm_state old_state = vif->sm_state;
+	int ret;
+#ifdef SYNC_DISCONNECT
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4, 9, 60)
+	u32 msec;
+	ktime_t kt;
+#endif
+#endif
+
+	wl_ndev_log(L_DBG, ndev, "%s %s reason: %d\n", __func__, vif->ssid,
+		    reason_code);
+
+	vif->sm_state = SPRDWL_DISCONNECTING;
+
+#ifdef SYNC_DISCONNECT
+	atomic_set(&vif->sync_disconnect_event, 1);
+#endif
+	ret = sprdwl_disconnect(vif->priv, vif->ctx_id, reason_code);
+	if (ret) {
+		vif->sm_state = old_state;
+		goto out;
+	}
+#ifdef SYNC_DISCONNECT
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4, 9, 60)
+	if (!sprdwl_sync_disconnect_event(vif, msecs_to_jiffies(1000))) {
+		kt = ktime_get();
+		msec = (u32)(div_u64(kt.tv64, NSEC_PER_MSEC));
+		wl_err("Wait disconnect event timeout. [mstime = %d]\n",
+		       cpu_to_le32(msec));
+	} else {
+		sprdwl_disconnect_handle(vif);
+	}
+	atomic_set(&vif->sync_disconnect_event, 0);
+#endif
+#endif
+	trace_deauth_reason(vif->mode, reason_code, LOCAL_EVENT);
+out:
+	return ret;
+}
+
+static int sprdwl_cfg80211_connect(struct wiphy *wiphy, struct net_device *ndev,
+				   struct cfg80211_connect_params *sme)
+{
+	struct sprdwl_vif *vif = netdev_priv(ndev);
+	struct sprdwl_cmd_connect con;
+	enum sm_state old_state = vif->sm_state;
+	int is_wep = (sme->crypto.cipher_group == WLAN_CIPHER_SUITE_WEP40) ||
+	    (sme->crypto.cipher_group == WLAN_CIPHER_SUITE_WEP104);
+	int ret = -EPERM;
+
+	/*workround for bug 795430*/
+	if (vif->priv->fw_stat[vif->mode] == SPRDWL_INTF_CLOSE) {
+		wl_err("%s, %d, error!mode%d connect after closed not allowed",
+		       __func__, __LINE__, vif->mode);
+		goto err;
+	}
+
+	memset(&con, 0, sizeof(con));
+
+	/*workround for bug 771600*/
+	if (vif->sm_state == SPRDWL_CONNECTING) {
+		wl_ndev_log(L_DBG, ndev, "sm_state is SPRDWL_CONNECTING, disconnect first\n");
+		sprdwl_cfg80211_disconnect(wiphy, ndev, 3);
+	}
+
+	/* Set wps ie */
+	if (sme->ie_len > 0) {
+		wl_ndev_log(L_DBG, ndev, "set assoc req ie, len %zx\n", sme->ie_len);
+		ret = sprdwl_set_ie(vif->priv, vif->ctx_id, SPRDWL_IE_ASSOC_REQ,
+				    sme->ie, sme->ie_len);
+		if (ret)
+			goto err;
+	}
+
+	wl_ndev_log(L_DBG, ndev, "wpa versions %#x\n", sme->crypto.wpa_versions);
+	con.wpa_versions = sme->crypto.wpa_versions;
+	wl_ndev_log(L_DBG, ndev, "management frame protection %#x\n", sme->mfp);
+	con.mfp_enable = sme->mfp;
+
+	wl_ndev_log(L_DBG, ndev, "auth type %#x\n", sme->auth_type);
+	if ((sme->auth_type == NL80211_AUTHTYPE_OPEN_SYSTEM) ||
+	    ((sme->auth_type == NL80211_AUTHTYPE_AUTOMATIC) && !is_wep))
+		con.auth_type = SPRDWL_AUTH_OPEN;
+	else if ((sme->auth_type == NL80211_AUTHTYPE_SHARED_KEY) ||
+		 ((sme->auth_type == NL80211_AUTHTYPE_AUTOMATIC) && is_wep))
+		con.auth_type = SPRDWL_AUTH_SHARED;
+
+	/* Set pairewise cipher */
+	if (sme->crypto.n_ciphers_pairwise) {
+		vif->prwise_crypto =
+		    sprdwl_parse_cipher(sme->crypto.ciphers_pairwise[0]);
+
+		if (vif->prwise_crypto != SPRDWL_CIPHER_NONE) {
+			wl_ndev_log(L_DBG, ndev, "pairwise cipher %#x\n",
+				    sme->crypto.ciphers_pairwise[0]);
+			con.pairwise_cipher = vif->prwise_crypto;
+			con.pairwise_cipher |= SPRDWL_VALID_CONFIG;
+		}
+	} else {
+		wl_ndev_log(L_DBG, ndev, "No pairewise cipher specified!\n");
+		vif->prwise_crypto = SPRDWL_CIPHER_NONE;
+	}
+
+	/* Set group cipher */
+	vif->grp_crypto = sprdwl_parse_cipher(sme->crypto.cipher_group);
+	if (vif->grp_crypto != SPRDWL_CIPHER_NONE) {
+		wl_ndev_log(L_DBG, ndev, "group cipher %#x\n",
+			    sme->crypto.cipher_group);
+		con.group_cipher = vif->grp_crypto;
+		con.group_cipher |= SPRDWL_VALID_CONFIG;
+	}
+
+	/* Set auth key management (akm) */
+	if (sme->crypto.n_akm_suites) {
+		wl_ndev_log(L_DBG, ndev, "akm suites %#x\n",
+			    sme->crypto.akm_suites[0]);
+		con.key_mgmt = sprdwl_parse_akm(sme->crypto.akm_suites[0]);
+		con.key_mgmt |= SPRDWL_VALID_CONFIG;
+	} else {
+		wl_ndev_log(L_DBG, ndev, "No akm suites specified!\n");
+	}
+
+	/* Set PSK */
+	if (sme->key_len) {
+		if (sme->crypto.cipher_group == WLAN_CIPHER_SUITE_WEP40 ||
+		    sme->crypto.cipher_group == WLAN_CIPHER_SUITE_WEP104 ||
+		    sme->crypto.ciphers_pairwise[0] ==
+		    WLAN_CIPHER_SUITE_WEP40 ||
+		    sme->crypto.ciphers_pairwise[0] ==
+		    WLAN_CIPHER_SUITE_WEP104) {
+			vif->key_index[SPRDWL_GROUP] = sme->key_idx;
+			vif->key_len[SPRDWL_GROUP][sme->key_idx] = sme->key_len;
+			memcpy(vif->key[SPRDWL_GROUP][sme->key_idx], sme->key,
+			       sme->key_len);
+			ret =
+			    sprdwl_add_cipher_key(vif, 0, sme->key_idx,
+						  sme->crypto.
+						  ciphers_pairwise[0],
+						  NULL, NULL);
+			if (ret)
+				goto err;
+		} else if (sme->key_len > WLAN_MAX_KEY_LEN) {
+			wl_ndev_log(L_ERR, ndev, "%s invalid key len: %d\n", __func__,
+				   sme->key_len);
+			ret = -EINVAL;
+			goto err;
+		} else {
+			wl_ndev_log(L_DBG, ndev, "PSK %s\n", sme->key);
+			con.psk_len = sme->key_len;
+			memcpy(con.psk, sme->key, sme->key_len);
+		}
+	}
+
+	/* Auth RX unencrypted EAPOL is not implemented, do nothing */
+	/* Set channel */
+	if (!sme->channel) {
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 15, 0)
+		if (sme->channel_hint) {
+			u16 center_freq = sme->channel_hint->center_freq;
+
+			con.channel =
+			    ieee80211_frequency_to_channel(center_freq);
+			wl_ndev_log(L_DBG, ndev, "channel_hint %d\n", con.channel);
+		} else
+#endif
+		{
+			wl_ndev_log(L_DBG, ndev, "No channel specified!\n");
+		}
+	} else {
+		con.channel =
+		    ieee80211_frequency_to_channel(sme->channel->center_freq);
+		wl_ndev_log(L_DBG, ndev, "channel %d\n", con.channel);
+	}
+
+	/* Set BSSID */
+	if (sme->bssid != NULL) {
+		memcpy(con.bssid, sme->bssid, sizeof(con.bssid));
+		memcpy(vif->bssid, sme->bssid, sizeof(vif->bssid));
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 15, 0)
+	} else if (sme->bssid_hint != NULL) {
+		memcpy(con.bssid, sme->bssid_hint, sizeof(con.bssid));
+		memcpy(vif->bssid, sme->bssid_hint, sizeof(vif->bssid));
+#endif
+	} else {
+		wl_ndev_log(L_DBG, ndev, "No BSSID specified!\n");
+	}
+
+	/* Special process for WEP(WEP key must be set before essid) */
+	if (sme->crypto.cipher_group == WLAN_CIPHER_SUITE_WEP40 ||
+	    sme->crypto.cipher_group == WLAN_CIPHER_SUITE_WEP104) {
+		wl_ndev_log(L_DBG, ndev, "%s WEP cipher_group\n", __func__);
+
+		if (sme->key_len <= 0) {
+			wl_ndev_log(L_DBG, ndev, "No key specified!\n");
+		} else {
+			if (sme->key_len != WLAN_KEY_LEN_WEP104 &&
+			    sme->key_len != WLAN_KEY_LEN_WEP40) {
+				wl_ndev_log(L_ERR, ndev, "%s invalid WEP key length!\n",
+					   __func__);
+				ret = -EINVAL;
+				goto err;
+			}
+
+			sprdwl_set_def_key(vif->priv, vif->ctx_id,
+					   sme->key_idx);
+			if (ret)
+				goto err;
+		}
+	}
+
+	/* Set ESSID */
+	if (!sme->ssid) {
+		wl_ndev_log(L_DBG, ndev, "No SSID specified!\n");
+	} else {
+		strncpy(con.ssid, sme->ssid, sme->ssid_len);
+		con.ssid_len = sme->ssid_len;
+		vif->sm_state = SPRDWL_CONNECTING;
+
+		if (vif->wps_flag) {
+			if (strstr(con.ssid, "Marvell") || strstr(con.ssid, "Ralink")) {
+				wl_info("%s, WPS connection\n", __func__);
+				msleep(3000);
+			}
+			vif->wps_flag = 0;
+		}
+
+		ret = sprdwl_connect(vif->priv, vif->ctx_id, &con);
+		if (ret)
+			goto err;
+		strncpy(vif->ssid, sme->ssid, sme->ssid_len);
+		vif->ssid_len = sme->ssid_len;
+		wl_ndev_log(L_DBG, ndev, "%s %s\n", __func__, vif->ssid);
+	}
+
+	return 0;
+err:
+	wl_ndev_log(L_ERR, ndev, "%s failed\n", __func__);
+	vif->sm_state = old_state;
+	return ret;
+}
+
+static int sprdwl_cfg80211_set_wiphy_params(struct wiphy *wiphy, u32 changed)
+{
+	struct sprdwl_priv *priv = wiphy_priv(wiphy);
+	u32 rts = 0, frag = 0;
+
+	if (changed & WIPHY_PARAM_RTS_THRESHOLD)
+		rts = wiphy->rts_threshold;
+
+	if (changed & WIPHY_PARAM_FRAG_THRESHOLD)
+		frag = wiphy->frag_threshold;
+
+	return sprdwl_set_param(priv, rts, frag);
+}
+
+static int sprdwl_cfg80211_set_pmksa(struct wiphy *wiphy,
+				     struct net_device *ndev,
+				     struct cfg80211_pmksa *pmksa)
+{
+	struct sprdwl_vif *vif = netdev_priv(ndev);
+
+	wl_ndev_log(L_DBG, ndev, "%s\n", __func__);
+
+	return sprdwl_pmksa(vif->priv, vif->ctx_id, pmksa->bssid,
+			    pmksa->pmkid, SPRDWL_SUBCMD_SET);
+}
+
+static int sprdwl_cfg80211_del_pmksa(struct wiphy *wiphy,
+				     struct net_device *ndev,
+				     struct cfg80211_pmksa *pmksa)
+{
+	struct sprdwl_vif *vif = netdev_priv(ndev);
+
+	wl_ndev_log(L_DBG, ndev, "%s\n", __func__);
+
+	return sprdwl_pmksa(vif->priv, vif->ctx_id, pmksa->bssid,
+			    pmksa->pmkid, SPRDWL_SUBCMD_DEL);
+}
+
+static int sprdwl_cfg80211_flush_pmksa(struct wiphy *wiphy,
+				       struct net_device *ndev)
+{
+	struct sprdwl_vif *vif = netdev_priv(ndev);
+
+	wl_ndev_log(L_DBG, ndev, "%s\n", __func__);
+
+	return sprdwl_pmksa(vif->priv, vif->ctx_id, vif->bssid, NULL,
+			    SPRDWL_SUBCMD_FLUSH);
+}
+
+void sprdwl_report_fake_probe(struct wiphy *wiphy, u8 *ie, size_t ielen)
+{
+	static int local_mac_ind, flush_count;
+	struct ieee80211_channel *channel;
+	struct cfg80211_bss *bss;
+	char fake_ssid[IEEE80211_MAX_SSID_LEN] = "&%^#!%&&?@#$&@3iU@Code1";
+	static char fake_ie[SPRDWL_MAX_IE_LEN];
+	char fake_bssid[6] = {0x02, 0x02, 0x02, 0x02, 0x02, 0x02};
+	static u16 fake_ielen;
+	u16 capability, beacon_interval;
+	u32 freq;
+	s32 signal;
+
+	if (0 == local_mac_ind) {
+		if ((ielen+IEEE80211_MAX_SSID_LEN) < SPRDWL_MAX_IE_LEN) {
+			/*add SSID IE*/
+			ie = ie + *(ie+1) + 2;
+			/*total IE length sub SSID IE;*/
+			ielen = ielen - *(ie+1) - 2;
+			/*fill in new SSID element*/
+			*fake_ie = 0;
+			/*set SSID IE length*/
+			*(fake_ie+1) = strlen(fake_ssid);
+			/*fill resp IE with fake ssid*/
+			memcpy((fake_ie+2), fake_ssid, strlen(fake_ssid));
+			/*fill resp IE with other IE */
+			memcpy((fake_ie+2+strlen(fake_ssid)), ie, ielen);
+			fake_ielen = ielen + 2 + strlen(fake_ssid);
+			local_mac_ind = 1;
+		} else {
+			return;
+		}
+	}
+	if (0 == ((flush_count++)%5)) {
+		freq = 2412;
+		capability = 0x2D31;
+		beacon_interval = 100;
+		signal = -20;
+		channel = ieee80211_get_channel(wiphy, freq);
+		bss = cfg80211_inform_bss(wiphy, channel,
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 18, 0))
+					  CFG80211_BSS_FTYPE_UNKNOWN,
+#endif
+					  fake_bssid, 0, capability,
+					  beacon_interval, fake_ie,
+					  fake_ielen, signal,
+					  GFP_KERNEL);
+		cfg80211_put_bss(wiphy, bss);
+	}
+}
+
+void signal_level_enhance(struct sprdwl_vif *vif,
+			  struct ieee80211_mgmt *mgmt, s32 *signal)
+{
+	struct scan_result *scan_node;
+	struct sprdwl_priv *priv = vif->priv;
+
+	if (!priv->scan_vif || priv->scan_vif != vif)
+		return;
+	spin_lock_bh(&priv->scan_lock);
+	/*check whether there is a same bssid & ssid*/
+	if (priv->scan_request && !list_empty(&vif->scan_head_ptr)) {
+		list_for_each_entry(scan_node, &vif->scan_head_ptr, list) {
+			if (!memcmp(scan_node->bssid, mgmt->bssid, ETH_ALEN)) {
+				/*if found,compare signal and decide
+				* whether to replae it with a better one
+				*/
+				if (scan_node->signal > *signal)
+					*signal = scan_node->signal;
+				else
+					scan_node->signal = *signal;
+				goto unlock;
+			}
+		}
+	}
+	/*if didn't found,create a node*/
+	scan_node = kmalloc(sizeof(*scan_node), GFP_ATOMIC);
+	if (!scan_node)
+		goto unlock;
+	scan_node->signal = *signal;
+	memcpy(scan_node->bssid, mgmt->bssid, 6);
+	list_add_tail(&scan_node->list, &vif->scan_head_ptr);
+
+unlock:
+	spin_unlock_bh(&priv->scan_lock);
+}
+
+void sprdwl_report_scan_result(struct sprdwl_vif *vif, u16 chan, s16 rssi,
+			       u8 *frame, u16 len)
+{
+	struct sprdwl_priv *priv = vif->priv;
+	struct wiphy *wiphy = priv->wiphy;
+	struct ieee80211_mgmt *mgmt = (struct ieee80211_mgmt *)frame;
+	struct ieee80211_channel *channel;
+	struct cfg80211_bss *bss;
+	u16 capability, beacon_interval;
+	u32 freq;
+	s32 signal;
+	u64 tsf;
+	u8 *ie;
+	size_t ielen;
+
+	if (!priv->scan_request && !priv->sched_scan_request) {
+		wl_ndev_log(L_DBG, vif->ndev, "%s Unexpected event\n", __func__);
+		return;
+	}
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 7, 0)
+	freq = ieee80211_channel_to_frequency(chan, chan <= CH_MAX_2G_CHANNEL ?
+			NL80211_BAND_2GHZ : NL80211_BAND_5GHZ);
+#else
+	freq = ieee80211_channel_to_frequency(chan, chan <= CH_MAX_2G_CHANNEL ?
+			IEEE80211_BAND_2GHZ : IEEE80211_BAND_5GHZ);
+#endif
+	channel = ieee80211_get_channel(wiphy, freq);
+	if (!channel) {
+		wl_ndev_log(L_ERR, vif->ndev, "%s invalid freq!\n", __func__);
+		return;
+	}
+
+	if (!mgmt) {
+		wl_ndev_log(L_ERR, vif->ndev, "%s NULL frame!\n", __func__);
+		return;
+	}
+
+	signal = rssi * 100;
+	/*signal level enhance*/
+	signal_level_enhance(vif, mgmt, &signal);
+	/*if signal has been update & enhanced*/
+
+	if ((rssi * 100) != signal)
+		wl_debug("old signal level:%d,new signal level:%d\n",
+		       (rssi*100), signal);
+
+#ifdef ACS_SUPPORT
+	if (vif->mode == SPRDWL_MODE_AP)
+		acs_scan_result(vif, chan, mgmt);
+#endif
+
+	ie = mgmt->u.probe_resp.variable;
+	ielen = len - offsetof(struct ieee80211_mgmt, u.probe_resp.variable);
+	/* framework use system bootup time */
+	tsf = ktime_to_ns(ktime_get_boottime());
+	beacon_interval = le16_to_cpu(mgmt->u.probe_resp.beacon_int);
+	capability = le16_to_cpu(mgmt->u.probe_resp.capab_info);
+
+	wl_ndev_log(L_DBG, vif->ndev, "   %s, %pM, channel %2u, signal %d\n",
+		    ieee80211_is_probe_resp(mgmt->frame_control)
+		    ? "proberesp" : "beacon   ", mgmt->bssid, chan, signal);
+
+	bss = cfg80211_inform_bss(wiphy, channel,
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 18, 0))
+				  CFG80211_BSS_FTYPE_UNKNOWN,
+#endif
+				  mgmt->bssid, tsf, capability, beacon_interval,
+				  ie, ielen, signal, GFP_KERNEL);
+
+	if (unlikely(!bss))
+		wl_ndev_log(L_ERR, vif->ndev,
+			   "%s failed to inform bss frame!\n", __func__);
+	cfg80211_put_bss(wiphy, bss);
+
+	/*check log mac flag and call report fake probe*/
+	if (vif->local_mac_flag)
+		sprdwl_report_fake_probe(wiphy, ie, ielen);
+
+	if (vif->beacon_loss) {
+		bss = cfg80211_get_bss(wiphy, NULL, vif->bssid,
+				       vif->ssid, vif->ssid_len,
+				       WLAN_CAPABILITY_ESS,
+				       WLAN_CAPABILITY_ESS);
+		if (bss) {
+			cfg80211_unlink_bss(wiphy, bss);
+			wl_ndev_log(L_DBG, vif->ndev,
+				    "unlink %pM due to beacon loss\n",
+				    bss->bssid);
+			vif->beacon_loss = 0;
+		}
+	}
+}
+
+void sprdwl_report_connection(struct sprdwl_vif *vif,
+					struct sprdwl_connect_info *conn_info,
+					u8 status_code)
+{
+	struct sprdwl_priv *priv = vif->priv;
+	struct wiphy *wiphy = priv->wiphy;
+	struct ieee80211_channel *channel;
+	struct ieee80211_mgmt *mgmt;
+	struct cfg80211_bss *bss = NULL;
+#ifdef WMMAC_WFA_CERTIFICATION
+	struct wmm_params_element *wmm_params;
+	int i;
+#endif
+	u16 capability, beacon_interval;
+	u32 freq;
+	u64 tsf;
+	u8 *ie;
+	size_t ielen;
+
+	if (vif->sm_state != SPRDWL_CONNECTING &&
+	    vif->sm_state != SPRDWL_CONNECTED) {
+		wl_ndev_log(L_ERR, vif->ndev, "%s Unexpected event!\n", __func__);
+		return;
+	}
+#ifndef IBSS_SUPPORT
+	if (conn_info->status != SPRDWL_CONNECT_SUCCESS &&
+	    conn_info->status != SPRDWL_ROAM_SUCCESS)
+		goto err;
+#else
+	if (conn_info->status != SPRDWL_CONNECT_SUCCESS &&
+	    conn_info->status != SPRDWL_ROAM_SUCCESS &&
+	    conn_info->status != SPRDWL_IBSS_JOIN &&
+	    conn_info->status != SPRDWL_IBSS_START)
+		goto err;
+#endif /* IBSS_SUPPORT */
+	if (!conn_info->bssid) {
+		wl_ndev_log(L_ERR, vif->ndev, "%s NULL BSSID!\n", __func__);
+		goto err;
+	}
+	if (!conn_info->req_ie_len) {
+		wl_ndev_log(L_ERR, vif->ndev, "%s No associate REQ IE!\n", __func__);
+		goto err;
+	}
+	if (!conn_info->resp_ie_len) {
+		wl_ndev_log(L_ERR, vif->ndev, "%s No associate RESP IE!\n", __func__);
+		goto err;
+	}
+
+	if (conn_info->bea_ie_len) {
+		wl_debug("%s channel num:%d\n", __func__, conn_info->channel);
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 7, 0)
+		freq = ieee80211_channel_to_frequency(conn_info->channel,
+									conn_info->channel <= CH_MAX_2G_CHANNEL ?
+									NL80211_BAND_2GHZ : NL80211_BAND_5GHZ);
+#else
+		freq = ieee80211_channel_to_frequency(conn_info->channel,
+									conn_info->channel <= CH_MAX_2G_CHANNEL ?
+									IEEE80211_BAND_2GHZ : IEEE80211_BAND_5GHZ);
+#endif
+		channel = ieee80211_get_channel(wiphy, freq);
+		if (!channel) {
+			wl_err("%s invalid freq!channel num:%d\n", __func__,
+				conn_info->channel);
+			goto err;
+		}
+
+		mgmt = (struct ieee80211_mgmt *)conn_info->bea_ie;
+		wl_ndev_log(L_DBG, vif->ndev, "%s update BSS %s\n", __func__,
+			    vif->ssid);
+		if (!mgmt) {
+			wl_ndev_log(L_ERR, vif->ndev, "%s NULL frame!\n", __func__);
+			goto err;
+		}
+		if (!ether_addr_equal(conn_info->bssid, mgmt->bssid))
+			wl_ndev_log(L_ERR, vif->ndev,
+				    "%s Invalid Beacon!,vif->bssid = %pM, con->bssid = %pM, mgmt->bssid = %pM\n",
+				    __func__, vif->bssid, conn_info->bssid, mgmt->bssid);
+		ie = mgmt->u.probe_resp.variable;
+		ielen = conn_info->bea_ie_len - offsetof(struct ieee80211_mgmt,
+						 u.probe_resp.variable);
+		/* framework use system bootup time */
+		tsf = ktime_to_ns(ktime_get_boottime());
+		beacon_interval = le16_to_cpu(mgmt->u.probe_resp.beacon_int);
+		capability = le16_to_cpu(mgmt->u.probe_resp.capab_info);
+		wl_ndev_log(L_DBG, vif->ndev, "%s, %pM, signal: %d\n",
+			   ieee80211_is_probe_resp(mgmt->frame_control)
+			   ? "proberesp" : "beacon", mgmt->bssid,
+			   conn_info->signal);
+
+		bss = cfg80211_inform_bss(wiphy, channel,
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 18, 0))
+					  CFG80211_BSS_FTYPE_UNKNOWN,
+#endif
+					  mgmt->bssid, tsf,
+					  capability, beacon_interval,
+					  ie, ielen, conn_info->signal, GFP_KERNEL);
+		if (unlikely(!bss))
+			wl_ndev_log(L_ERR, vif->ndev,
+				   "%s failed to inform bss frame!\n",
+				   __func__);
+	} else {
+		wl_ndev_log(L_ERR, vif->ndev, "%s No Beason IE!\n", __func__);
+	}
+
+	if (vif->sm_state == SPRDWL_CONNECTING &&
+	    conn_info->status == SPRDWL_CONNECT_SUCCESS)
+		cfg80211_connect_result(vif->ndev,
+					conn_info->bssid, conn_info->req_ie, conn_info->req_ie_len,
+					conn_info->resp_ie, conn_info->resp_ie_len,
+					WLAN_STATUS_SUCCESS, GFP_KERNEL);
+	else if (vif->sm_state == SPRDWL_CONNECTED &&
+		 conn_info->status == SPRDWL_ROAM_SUCCESS){
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 14, 0)
+		struct cfg80211_roam_info roam_info = {
+			.bss = bss,
+			.req_ie = conn_info->req_ie,
+			.req_ie_len = conn_info->req_ie_len,
+			.resp_ie = conn_info->resp_ie,
+			.resp_ie_len = conn_info->resp_ie_len,
+		};
+		cfg80211_roamed(vif->ndev, &roam_info, GFP_KERNEL);
+#else
+		cfg80211_roamed_bss(vif->ndev, bss, conn_info->req_ie, conn_info->req_ie_len,
+				    conn_info->resp_ie, conn_info->resp_ie_len, GFP_KERNEL);
+#endif
+	}
+#ifdef IBSS_SUPPORT
+	else if (vif->sm_state == SPRDWL_CONNECTED &&
+		 (conn_info->status == SPRDWL_IBSS_JOIN ||
+		 conn_info->status == SPRDWL_IBSS_START)) {
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 7, 0)
+		freq = ieee80211_channel_to_frequency(conn_info->channel,
+				conn_info->channel <= CH_MAX_2G_CHANNEL ?
+				NL80211_BAND_2GHZ : NL80211_BAND_5GHZ);
+#else
+		freq = ieee80211_channel_to_frequency(conn_info->channel,
+				conn_info->channel <= CH_MAX_2G_CHANNEL ?
+				IEEE80211_BAND_2GHZ : IEEE80211_BAND_5GHZ);
+#endif
+		channel = ieee80211_get_channel(wiphy, freq);
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 15, 0))
+		cfg80211_ibss_joined(vif->ndev, conn_info->bssid, channel, GFP_KERNEL);
+#else
+		cfg80211_ibss_joined(vif->ndev, conn_info->bssid, GFP_KERNEL);
+#endif
+		}
+#endif /* IBSS_SUPPORT */
+	else {
+		wl_ndev_log(L_ERR, vif->ndev, "%s sm_state (%d), status: (%d)!\n",
+			   __func__, vif->sm_state, conn_info->status);
+		goto err;
+	}
+
+	if (!netif_carrier_ok(vif->ndev)) {
+		netif_carrier_on(vif->ndev);
+		netif_wake_queue(vif->ndev);
+	}
+
+#ifdef WMMAC_WFA_CERTIFICATION
+	wmm_params = (struct wmm_params_element *)get_wmm_ie(conn_info->resp_ie,
+						conn_info->resp_ie_len,
+						WLAN_EID_VENDOR_SPECIFIC,
+						OUI_MICROSOFT,
+						WMM_OUI_TYPE);
+
+	if (wmm_params != NULL) {
+		for (i = 0; i < NUM_AC; i++) {
+			wl_ndev_log(L_DBG, vif->ndev, "wmm_params->ac[%d].aci_aifsn: %x\n",
+					i, wmm_params->ac[i].aci_aifsn);
+			priv->wmmac.ac[i].aci_aifsn = wmm_params->ac[i].aci_aifsn;
+		}
+	} else {
+		wl_ndev_log(L_DBG, vif->ndev, "%s wmm_params is NULL!!!!\n", __func__);
+	}
+#endif
+
+	vif->sm_state = SPRDWL_CONNECTED;
+	memcpy(vif->bssid, conn_info->bssid, sizeof(vif->bssid));
+	wl_ndev_log(L_DBG, vif->ndev, "%s %s to %s (%pM)\n", __func__,
+		    conn_info->status == SPRDWL_CONNECT_SUCCESS ?
+			"connect" : "roam", vif->ssid, vif->bssid);
+	return;
+err:
+	if (status_code == WLAN_STATUS_SUCCESS)
+		status_code = WLAN_STATUS_UNSPECIFIED_FAILURE;
+	if (vif->sm_state == SPRDWL_CONNECTING)
+		cfg80211_connect_result(vif->ndev, vif->bssid, NULL, 0, NULL, 0,
+					status_code, GFP_KERNEL);
+
+	wl_ndev_log(L_ERR, vif->ndev, "%s %s failed status code:%d!\n",
+				__func__, vif->ssid, status_code);
+	memset(vif->bssid, 0, sizeof(vif->bssid));
+	memset(vif->ssid, 0, sizeof(vif->ssid));
+}
+
+void sprdwl_report_disconnection(struct sprdwl_vif *vif, u16 reason_code)
+{
+	if (vif->sm_state == SPRDWL_CONNECTING) {
+		cfg80211_connect_result(vif->ndev, vif->bssid, NULL, 0, NULL, 0,
+					WLAN_STATUS_UNSPECIFIED_FAILURE,
+					GFP_KERNEL);
+	} else if ((vif->sm_state == SPRDWL_CONNECTED) ||
+			(vif->sm_state == SPRDWL_DISCONNECTING)) {
+		cfg80211_disconnected(vif->ndev, reason_code,
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 4, 83)
+				NULL, 0, false, GFP_KERNEL);
+#else
+				      NULL, 0, GFP_KERNEL);
+#endif
+		wl_ndev_log(L_DBG, vif->ndev,
+			    "%s %s, reason_code %d\n", __func__,
+			    vif->ssid, reason_code);
+	} else {
+		wl_ndev_log(L_ERR, vif->ndev, "%s Unexpected event!\n", __func__);
+		return;
+	}
+
+	vif->sm_state = SPRDWL_DISCONNECTED;
+
+	sprdwl_fc_add_share_credit(vif);
+
+	/* Clear bssid & ssid */
+	memset(vif->bssid, 0, sizeof(vif->bssid));
+	memset(vif->ssid, 0, sizeof(vif->ssid));
+#ifdef WMMAC_WFA_CERTIFICATION
+	reset_wmmac_parameters(vif->priv);
+	reset_wmmac_ts_info();
+	init_default_qos_map();
+#endif
+	/* Stop netif */
+	if (netif_carrier_ok(vif->ndev)) {
+		netif_carrier_off(vif->ndev);
+		netif_stop_queue(vif->ndev);
+	}
+	/*clear link layer status data*/
+	memset(&vif->priv->pre_radio, 0, sizeof(vif->priv->pre_radio));
+
+	trace_deauth_reason(vif->mode, reason_code, REMOTE_EVENT);
+}
+
+void sprdwl_report_mic_failure(struct sprdwl_vif *vif, u8 is_mcast, u8 key_id)
+{
+	wl_ndev_log(L_DBG, vif->ndev,
+		    "%s is_mcast:0x%x key_id: 0x%x bssid: %pM\n",
+		    __func__, is_mcast, key_id, vif->bssid);
+
+	cfg80211_michael_mic_failure(vif->ndev, vif->bssid,
+				     (is_mcast ? NL80211_KEYTYPE_GROUP :
+				      NL80211_KEYTYPE_PAIRWISE),
+				     key_id, NULL, GFP_KERNEL);
+}
+
+static char type_name[16][32] = {
+	"ASSO REQ",
+	"ASSO RESP",
+	"REASSO REQ",
+	"REASSO RESP",
+	"PROBE REQ",
+	"PROBE RESP",
+	"TIMING ADV",
+	"RESERVED",
+	"BEACON",
+	"ATIM",
+	"DISASSO",
+	"AUTH",
+	"DEAUTH",
+	"ACTION",
+	"ACTION NO ACK",
+	"RESERVED"
+};
+
+static char pub_action_name[][32] = {
+	"GO Negotiation Req",
+	"GO Negotiation Resp",
+	"GO Negotiation Conf",
+	"P2P Invitation Req",
+	"P2P Invitation Resp",
+	"Device Discovery Req",
+	"Device Discovery Resp",
+	"Provision Discovery Req",
+	"Provision Discovery Resp",
+	"Reserved"
+};
+
+static char p2p_action_name[][32] = {
+	"Notice of Absence",
+	"P2P Precence Req",
+	"P2P Precence Resp",
+	"GO Discoverability Req",
+	"Reserved"
+};
+
+#define MAC_LEN			(24)
+#define ADDR1_OFFSET		(4)
+#define ADDR2_OFFSET		(10)
+#define ACTION_TYPE		(13)
+#define ACTION_SUBTYPE_OFFSET	(30)
+#define PUB_ACTION		(0x4)
+#define P2P_ACTION		(0x7f)
+
+#define	PRINT_BUF_LEN		(1 << 10)
+static char print_buf[PRINT_BUF_LEN];
+void sprdwl_cfg80211_dump_frame_prot_info(int send, int freq,
+					  const unsigned char *buf, int len)
+{
+	int idx = 0;
+	int type = ((*buf) & IEEE80211_FCTL_FTYPE) >> 2;
+	int subtype = ((*buf) & IEEE80211_FCTL_STYPE) >> 4;
+	int action, action_subtype;
+	char *p = print_buf;
+
+	idx += sprintf(p + idx, "[cfg80211] ");
+
+	if (send)
+		idx += sprintf(p + idx, "SEND: ");
+	else
+		idx += sprintf(p + idx, "RECV: ");
+
+	if (type == IEEE80211_FTYPE_MGMT) {
+		idx += sprintf(p + idx, "%dMHz, %s, ",
+			       freq, type_name[subtype]);
+	} else {
+		idx += sprintf(p + idx,
+			       "%dMHz, not mgmt frame, type=%d, ", freq, type);
+	}
+
+	if (subtype == ACTION_TYPE) {
+		action = *(buf + MAC_LEN);
+		action_subtype = *(buf + ACTION_SUBTYPE_OFFSET);
+		if (action == PUB_ACTION)
+			idx += sprintf(p + idx, "PUB:%s ",
+				       pub_action_name[action_subtype]);
+		else if (action == P2P_ACTION)
+			idx += sprintf(p + idx, "P2P:%s ",
+				       p2p_action_name[action_subtype]);
+		else
+			idx += sprintf(p + idx, "Unknown ACTION(0x%x)", action);
+	}
+	p[idx] = '\0';
+
+	wl_debug("%s %pM %pM\n", p, &buf[4], &buf[10]);
+}
+
+/* P2P related stuff */
+static int sprdwl_cfg80211_remain_on_channel(struct wiphy *wiphy,
+					     struct wireless_dev *wdev,
+					     struct ieee80211_channel *chan,
+					     unsigned int duration, u64 *cookie)
+{
+	struct sprdwl_vif *vif = container_of(wdev, struct sprdwl_vif, wdev);
+	enum nl80211_channel_type channel_type = 0;
+	static u64 remain_index;
+	int ret;
+
+	*cookie = vif->listen_cookie = ++remain_index;
+	wl_ndev_log(L_DBG, wdev->netdev, "%s %d for %dms, cookie %lld\n",
+		    __func__, chan->center_freq, duration, *cookie);
+	memcpy(&vif->listen_channel, chan, sizeof(struct ieee80211_channel));
+
+	ret = sprdwl_remain_chan(vif->priv, vif->ctx_id, chan,
+				 channel_type, duration, cookie);
+	if (ret)
+		return ret;
+
+	cfg80211_ready_on_channel(wdev, *cookie, chan, duration, GFP_KERNEL);
+
+	return 0;
+}
+
+static int sprdwl_cfg80211_cancel_remain_on_channel(struct wiphy *wiphy,
+						    struct wireless_dev *wdev,
+						    u64 cookie)
+{
+	struct sprdwl_vif *vif = container_of(wdev, struct sprdwl_vif, wdev);
+
+	wl_ndev_log(L_DBG, wdev->netdev, "%s cookie %lld\n", __func__, cookie);
+
+	return sprdwl_cancel_remain_chan(vif->priv, vif->ctx_id, cookie);
+}
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 14, 0)
+static int sprdwl_cfg80211_mgmt_tx(struct wiphy *wiphy,
+				   struct wireless_dev *wdev,
+				   struct cfg80211_mgmt_tx_params *params,
+				   u64 *cookie)
+#else
+static int sprdwl_cfg80211_mgmt_tx(struct wiphy *wiphy,
+				   struct wireless_dev *wdev,
+				   struct ieee80211_channel *chan, bool offchan,
+				   unsigned int wait, const u8 *buf, size_t len,
+				   bool no_cck, bool dont_wait_for_ack, u64 *cookie)
+#endif
+{
+	struct sprdwl_vif *vif = container_of(wdev, struct sprdwl_vif, wdev);
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 14, 0)
+	struct ieee80211_channel *chan = params->chan;
+	const u8 *buf = params->buf;
+	size_t len = params->len;
+	unsigned int wait = params->wait;
+	bool dont_wait_for_ack = params->dont_wait_for_ack;
+#endif
+	static u64 mgmt_index;
+	int ret = 0;
+
+	*cookie = ++mgmt_index;
+	wl_ndev_log(L_DBG, wdev->netdev, "%s cookie %lld\n", __func__, *cookie);
+
+	sprdwl_cfg80211_dump_frame_prot_info(1, chan->center_freq, buf, len);
+	/* send tx mgmt */
+	if (len > 0) {
+		ret = sprdwl_tx_mgmt(vif->priv, vif->ctx_id,
+				     ieee80211_frequency_to_channel
+				     (chan->center_freq), dont_wait_for_ack,
+				     wait, cookie, buf, len);
+		if (ret)
+			if (!dont_wait_for_ack)
+				cfg80211_mgmt_tx_status(wdev, *cookie, buf, len,
+							0, GFP_KERNEL);
+	}
+
+	return ret;
+}
+
+static void
+sprdwl_cfg80211_update_mgmt_frame_registrations(struct wiphy *wiphy,
+						struct wireless_dev *wdev,
+						struct mgmt_frame_regs *upd)
+{
+	struct sprdwl_vif *vif = container_of(wdev, struct sprdwl_vif, wdev);
+	struct sprdwl_work *misc_work;
+	struct sprdwl_reg_mgmt *reg_mgmt;
+
+	if (vif->mode == SPRDWL_MODE_NONE)
+		return;
+
+	vif->mgmt_reg = upd->interface_stypes;
+
+	misc_work = sprdwl_alloc_work(sizeof(*reg_mgmt));
+	if (!misc_work) {
+		wl_ndev_log(L_ERR, wdev->netdev, "%s out of memory\n", __func__);
+		return;
+	}
+
+	misc_work->vif = vif;
+	misc_work->id = SPRDWL_WORK_REG_MGMT;
+
+	reg_mgmt = (struct sprdwl_reg_mgmt *)misc_work->data;
+	reg_mgmt->type = upd->interface_stypes << 4;
+	reg_mgmt->reg = upd->interface_stypes & BIT(IEEE80211_STYPE_PROBE_REQ >> 4);
+
+	sprdwl_queue_work(vif->priv, misc_work);
+}
+
+void sprdwl_report_remain_on_channel_expired(struct sprdwl_vif *vif)
+{
+	wl_ndev_log(L_DBG, vif->ndev, "%s\n", __func__);
+
+	cfg80211_remain_on_channel_expired(&vif->wdev, vif->listen_cookie,
+					   &vif->listen_channel, GFP_KERNEL);
+}
+
+void sprdwl_report_mgmt_tx_status(struct sprdwl_vif *vif, u64 cookie,
+				  const u8 *buf, u32 len, u8 ack)
+{
+	wl_ndev_log(L_DBG, vif->ndev, "%s cookie %lld\n", __func__, cookie);
+
+	cfg80211_mgmt_tx_status(&vif->wdev, cookie, buf, len, ack, GFP_KERNEL);
+}
+
+void sprdwl_report_rx_mgmt(struct sprdwl_vif *vif, u8 chan, const u8 *buf,
+			   size_t len)
+{
+	bool ret;
+	int freq;
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 7, 0)
+	freq = ieee80211_channel_to_frequency(chan,
+					      chan <= CH_MAX_2G_CHANNEL ?
+					      NL80211_BAND_2GHZ :
+					      NL80211_BAND_5GHZ);
+#else
+	freq = ieee80211_channel_to_frequency(chan,
+						chan <= CH_MAX_2G_CHANNEL ?
+						IEEE80211_BAND_2GHZ :
+						IEEE80211_BAND_5GHZ);
+#endif
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3, 12, 0)
+	ret = cfg80211_rx_mgmt(&vif->wdev, freq, 0, buf, len, GFP_ATOMIC);
+#elif LINUX_VERSION_CODE >= KERNEL_VERSION(3, 18, 0)
+	ret = cfg80211_rx_mgmt(&vif->wdev, freq, 0, buf, len, 0);
+#else
+	ret = cfg80211_rx_mgmt(&vif->wdev, freq, 0, buf, len, 0, GFP_ATOMIC);
+#endif
+	if (!ret)
+		wl_ndev_log(L_ERR, vif->ndev, "%s unregistered frame!", __func__);
+}
+
+void sprdwl_report_mgmt_deauth(struct sprdwl_vif *vif, const u8 *buf,
+			       size_t len)
+{
+	struct sprdwl_work *misc_work;
+
+	misc_work = sprdwl_alloc_work(len);
+	if (!misc_work) {
+		wl_ndev_log(L_ERR, vif->ndev, "%s out of memory", __func__);
+		return;
+	}
+
+	misc_work->vif = vif;
+	misc_work->id = SPRDWL_WORK_DEAUTH;
+	memcpy(misc_work->data, buf, len);
+
+	sprdwl_queue_work(vif->priv, misc_work);
+}
+
+void sprdwl_report_mgmt_disassoc(struct sprdwl_vif *vif, const u8 *buf,
+				 size_t len)
+{
+	struct sprdwl_work *misc_work;
+
+	misc_work = sprdwl_alloc_work(len);
+	if (!misc_work) {
+		wl_ndev_log(L_ERR, vif->ndev, "%s out of memory", __func__);
+		return;
+	}
+
+	misc_work->vif = vif;
+	misc_work->id = SPRDWL_WORK_DISASSOC;
+	memcpy(misc_work->data, buf, len);
+
+	sprdwl_queue_work(vif->priv, misc_work);
+}
+
+static int sprdwl_cfg80211_start_p2p_device(struct wiphy *wiphy,
+					    struct wireless_dev *wdev)
+{
+	struct sprdwl_vif *vif = container_of(wdev, struct sprdwl_vif, wdev);
+
+	wl_ndev_log(L_DBG, vif->ndev, "%s\n", __func__);
+
+	return sprdwl_init_fw(vif);
+}
+
+static void sprdwl_cfg80211_stop_p2p_device(struct wiphy *wiphy,
+					    struct wireless_dev *wdev)
+{
+	struct sprdwl_vif *vif = container_of(wdev, struct sprdwl_vif, wdev);
+
+	wl_ndev_log(L_DBG, vif->ndev, "%s\n", __func__);
+
+	sprdwl_uninit_fw(vif);
+
+	if (vif->priv->scan_request)
+		sprdwl_scan_done(vif, true);
+}
+
+static int sprdwl_cfg80211_tdls_mgmt(struct wiphy *wiphy,
+				     struct net_device *ndev, const u8 *peer,
+				     u8 action_code, u8 dialog_token,
+				     u16 status_code,  u32 peer_capability,
+				     bool initiator, const u8 *buf, size_t len)
+{
+	struct sprdwl_vif *vif = netdev_priv(ndev);
+	struct sk_buff *tdls_skb;
+	struct sprdwl_cmd_tdls_mgmt *p;
+	u16 datalen, ielen;
+	u32 end = 0x1a2b3c4d;
+	int ret = 0;
+
+	wl_ndev_log(L_DBG, ndev, "%s action_code=%d(%pM)\n", __func__,
+		    action_code, peer);
+
+	datalen = sizeof(*p) + len + sizeof(end);
+	ielen = len + sizeof(end);
+	tdls_skb = dev_alloc_skb(datalen + NET_IP_ALIGN);
+	if (!tdls_skb) {
+		wl_err("dev_alloc_skb failed\n");
+		return -ENOMEM;
+	}
+	skb_reserve(tdls_skb, NET_IP_ALIGN);
+	p = (struct sprdwl_cmd_tdls_mgmt *)skb_put(tdls_skb,
+			offsetof(struct sprdwl_cmd_tdls_mgmt, u));
+
+	ether_addr_copy(p->da, peer);
+	ether_addr_copy(p->sa, vif->ndev->dev_addr);
+	p->ether_type = cpu_to_be16(ETH_P_TDLS);
+	p->payloadtype = WLAN_TDLS_SNAP_RFTYPE;
+	switch (action_code) {
+	case WLAN_TDLS_SETUP_REQUEST:
+		p->category = WLAN_CATEGORY_TDLS;
+		p->action_code = WLAN_TDLS_SETUP_REQUEST;
+		p = (struct sprdwl_cmd_tdls_mgmt *)skb_put(tdls_skb,
+			(sizeof(p->u.setup_req) + ielen));
+		memcpy(p, &dialog_token, 1);
+		memcpy((u8 *)p + 1, buf, len);
+		memcpy((u8 *)p + 1 + len, &end, sizeof(end));
+		break;
+	case WLAN_TDLS_SETUP_RESPONSE:
+		p->category = WLAN_CATEGORY_TDLS;
+		p->action_code = WLAN_TDLS_SETUP_RESPONSE;
+		p = (struct sprdwl_cmd_tdls_mgmt *)skb_put(tdls_skb,
+			(sizeof(p->u.setup_resp) + ielen));
+		memcpy(p, &status_code, 2);
+		memcpy((u8 *)p + 2, &dialog_token, 1);
+		memcpy((u8 *)p + 3, buf, len);
+		memcpy((u8 *)p + 3 + len, &end, sizeof(end));
+		break;
+	case WLAN_TDLS_SETUP_CONFIRM:
+		p->category = WLAN_CATEGORY_TDLS;
+		p->action_code = WLAN_TDLS_SETUP_CONFIRM;
+		p = (struct sprdwl_cmd_tdls_mgmt *)skb_put(tdls_skb,
+			(sizeof(p->u.setup_cfm) + ielen));
+		memcpy(p, &status_code, 2);
+		memcpy((u8 *)p + 2, &dialog_token, 1);
+		memcpy((u8 *)p + 3, buf, len);
+		memcpy((u8 *)p + 3 + len, &end, sizeof(end));
+		break;
+	case WLAN_TDLS_TEARDOWN:
+		p->category = WLAN_CATEGORY_TDLS;
+		p->action_code = WLAN_TDLS_TEARDOWN;
+		p = (struct sprdwl_cmd_tdls_mgmt *)skb_put(tdls_skb,
+			(sizeof(p->u.teardown) + ielen));
+		memcpy(p, &status_code, 2);
+		memcpy((u8 *)p + 2, buf, len);
+		memcpy((u8 *)p + 2 + len, &end, sizeof(end));
+		break;
+	case SPRDWL_TDLS_DISCOVERY_RESPONSE:
+		p->category = WLAN_CATEGORY_TDLS;
+		p->action_code = SPRDWL_TDLS_DISCOVERY_RESPONSE;
+		p = (struct sprdwl_cmd_tdls_mgmt *)skb_put(tdls_skb,
+			(sizeof(p->u.discover_resp) + ielen));
+		memcpy(p, &dialog_token, 1);
+		memcpy((u8 *)p + 1, buf, len);
+		memcpy((u8 *)p + 1 + len, &end, sizeof(end));
+		break;
+	default:
+		wl_err("%s, %d, error action_code%d\n", __func__, __LINE__, action_code);
+		dev_kfree_skb(tdls_skb);
+		return -ENOMEM;
+		break;
+	}
+
+	ret = sprdwl_tdls_mgmt(vif, tdls_skb);
+	dev_kfree_skb(tdls_skb);
+	return ret;
+}
+
+static int sprdwl_cfg80211_tdls_oper(struct wiphy *wiphy,
+				     struct net_device *ndev, const u8 *peer,
+				     enum nl80211_tdls_operation oper)
+{
+	struct sprdwl_vif *vif = netdev_priv(ndev);
+	int ret;
+
+	wl_ndev_log(L_DBG, ndev, "%s oper=%d\n", __func__, oper);
+
+	if (oper == NL80211_TDLS_ENABLE_LINK) {
+		sprdwl_tdls_flow_flush(vif, peer, oper);
+		oper = SPRDWL_TDLS_ENABLE_LINK;
+	} else if (oper == NL80211_TDLS_DISABLE_LINK)
+		oper = SPRDWL_TDLS_DISABLE_LINK;
+	else
+		wl_ndev_log(L_ERR, ndev, "unsupported this TDLS oper\n");
+
+	ret = sprdwl_tdls_oper(vif->priv, vif->ctx_id, peer, oper);
+	/*to enable tx_addba_req*/
+	if (!ret && oper == SPRDWL_TDLS_ENABLE_LINK) {
+		u8 i;
+		struct sprdwl_intf *intf;
+
+		intf = (struct sprdwl_intf *)(vif->priv->hw_priv);
+		for (i = 0; i < MAX_LUT_NUM; i++) {
+			if ((0 == memcmp(intf->peer_entry[i].tx.da,
+					 peer, ETH_ALEN)) &&
+			    (intf->peer_entry[i].ctx_id == vif->ctx_id)) {
+				wl_info("%s, %d, lut_index=%d\n",
+					__func__, __LINE__,
+					intf->peer_entry[i].lut_index);
+				intf->peer_entry[i].ip_acquired  = 1;
+				break;
+			}
+		}
+	}
+	return ret;
+}
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 19, 0)
+static int sprdwl_cfg80211_tdls_chan_switch(struct wiphy *wiphy,
+					    struct net_device *ndev,
+					    const u8 *addr, u8 oper_class,
+					    struct cfg80211_chan_def *chandef)
+{
+	struct sprdwl_vif *vif = netdev_priv(ndev);
+	u8 chan, band;
+
+	chan = chandef->chan->hw_value;
+	band = chandef->chan->band;
+
+	wl_ndev_log(L_DBG, ndev, "%s: chan=%u, band=%u\n", __func__, chan, band);
+	return sprdwl_start_tdls_channel_switch(vif->priv, vif->ctx_id, addr,
+						chan, 0, band);
+}
+
+static void sprdwl_cfg80211_tdls_cancel_chan_switch(struct wiphy *wiphy,
+						    struct net_device *ndev,
+						    const u8 *addr)
+{
+	struct sprdwl_vif *vif = netdev_priv(ndev);
+
+	wl_ndev_log(L_DBG, ndev, "%s\n", __func__);
+	sprdwl_cancel_tdls_channel_switch(vif->priv, vif->ctx_id, addr);
+}
+#endif
+
+void sprdwl_report_tdls(struct sprdwl_vif *vif, const u8 *peer,
+			u8 oper, u16 reason_code)
+{
+	wl_ndev_log(L_DBG, vif->ndev, "%s A station (%pM)found\n", __func__, peer);
+
+	cfg80211_tdls_oper_request(vif->ndev, peer, oper,
+				   reason_code, GFP_KERNEL);
+}
+
+/* Roaming related stuff */
+int sprdwl_cfg80211_set_cqm_rssi_config(struct wiphy *wiphy,
+					struct net_device *ndev,
+					s32 rssi_thold, u32 rssi_hyst)
+{
+	struct sprdwl_vif *vif = netdev_priv(ndev);
+
+	wl_ndev_log(L_DBG, ndev, "%s rssi_thold %d rssi_hyst %d",
+		    __func__, rssi_thold, rssi_hyst);
+
+	return sprdwl_set_cqm_rssi(vif->priv, vif->ctx_id,
+				   rssi_thold, rssi_hyst);
+}
+
+void sprdwl_report_cqm(struct sprdwl_vif *vif, u8 rssi_event)
+{
+	wl_ndev_log(L_DBG, vif->ndev, "%s rssi_event: %d\n", __func__, rssi_event);
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 14, 0)
+	cfg80211_cqm_rssi_notify(vif->ndev, rssi_event, 0, GFP_KERNEL);
+#else
+	cfg80211_cqm_rssi_notify(vif->ndev, rssi_event, GFP_KERNEL);
+#endif
+}
+
+int sprdwl_cfg80211_update_ft_ies(struct wiphy *wiphy, struct net_device *ndev,
+				  struct cfg80211_update_ft_ies_params *ftie)
+{
+	struct sprdwl_vif *vif = netdev_priv(ndev);
+
+	wl_ndev_log(L_DBG, ndev, "%s\n", __func__);
+
+	return sprdwl_set_roam_offload(vif->priv, vif->ctx_id,
+				       SPRDWL_ROAM_OFFLOAD_SET_FTIE,
+				       ftie->ie, ftie->ie_len);
+}
+
+static int sprdwl_cfg80211_set_qos_map(struct wiphy *wiphy,
+				       struct net_device *ndev,
+				       struct cfg80211_qos_map *qos_map)
+{
+	struct sprdwl_vif *vif = netdev_priv(ndev);
+
+	wl_ndev_log(L_DBG, ndev, "%s\n", __func__);
+
+	return sprdwl_set_qos_map(vif->priv, vif->ctx_id, (void *)qos_map);
+}
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 18, 0)
+static int sprdwl_cfg80211_add_tx_ts(struct wiphy *wiphy,
+				     struct net_device *ndev,
+				     u8 tsid, const u8 *peer,
+				     u8 user_prio, u16 admitted_time)
+{
+	struct sprdwl_vif *vif = netdev_priv(ndev);
+
+	wl_ndev_log(L_DBG, ndev, "%s\n", __func__);
+
+	return sprdwl_add_tx_ts(vif->priv, vif->ctx_id, tsid, peer,
+				user_prio, admitted_time);
+}
+
+static int sprdwl_cfg80211_del_tx_ts(struct wiphy *wiphy,
+				     struct net_device *ndev,
+				     u8 tsid, const u8 *peer)
+{
+	struct sprdwl_vif *vif = netdev_priv(ndev);
+
+	wl_ndev_log(L_DBG, ndev, "%s\n", __func__);
+
+	return sprdwl_del_tx_ts(vif->priv, vif->ctx_id, tsid, peer);
+}
+#endif
+
+static int sprdwl_cfg80211_set_mac_acl(struct wiphy *wiphy,
+				       struct net_device *ndev,
+				       const struct cfg80211_acl_data *acl)
+{
+	struct sprdwl_vif *vif = netdev_priv(ndev);
+	int index, num;
+	int mode = SPRDWL_ACL_MODE_DISABLE;
+	unsigned char *mac_addr = NULL;
+
+	if (!acl || !acl->n_acl_entries) {
+		wl_ndev_log(L_ERR, ndev, "%s no ACL data\n", __func__);
+		return 0;
+	}
+
+	if (acl->acl_policy == NL80211_ACL_POLICY_DENY_UNLESS_LISTED) {
+		mode = SPRDWL_ACL_MODE_WHITELIST;
+	} else if (acl->acl_policy == NL80211_ACL_POLICY_ACCEPT_UNLESS_LISTED) {
+		mode = SPRDWL_ACL_MODE_BLACKLIST;
+	} else {
+		wl_ndev_log(L_ERR, ndev, "%s invalid ACL mode\n", __func__);
+		return -EINVAL;
+	}
+
+	num = acl->n_acl_entries;
+	wl_ndev_log(L_DBG, ndev, "%s ACL MAC num:%d\n", __func__, num);
+	if (num < 0 || num > vif->priv->max_acl_mac_addrs)
+		return -EINVAL;
+
+	mac_addr = kzalloc(num * ETH_ALEN, GFP_KERNEL);
+	if (IS_ERR(mac_addr))
+		return -ENOMEM;
+
+	for (index = 0; index < num; index++) {
+		wl_ndev_log(L_DBG, ndev, "%s  MAC: %pM\n", __func__,
+			    &acl->mac_addrs[index]);
+		memcpy(mac_addr + index * ETH_ALEN,
+		       &acl->mac_addrs[index], ETH_ALEN);
+	}
+
+	if (mode == SPRDWL_ACL_MODE_WHITELIST)
+		return sprdwl_set_whitelist(vif->priv, vif->ctx_id,
+					    SPRDWL_SUBCMD_ENABLE,
+					    num, mac_addr);
+	else
+		return sprdwl_set_blacklist(vif->priv, vif->ctx_id,
+					    SPRDWL_SUBCMD_ADD, num, mac_addr);
+}
+
+int sprdwl_cfg80211_set_power_mgmt(struct wiphy *wiphy, struct net_device *ndev,
+				   bool enabled, int timeout)
+{
+	struct sprdwl_vif *vif = netdev_priv(ndev);
+
+	wl_ndev_log(L_DBG, ndev, "%s power save status:%d\n", __func__, enabled);
+	return sprdwl_power_save(vif->priv, vif->ctx_id,
+				 SPRDWL_SET_PS_STATE, enabled);
+}
+
+#ifdef ACS_SUPPORT
+static int
+sprdwl_cfg80211_dump_survey(struct wiphy *wiphy, struct net_device *ndev,
+			    int idx, struct survey_info *s_info)
+{
+	struct sprdwl_vif *vif = netdev_priv(ndev);
+	struct sprdwl_survey_info *info = NULL;
+	struct sprdwl_bssid *bssid = NULL, *pos = NULL;
+	static int survey_count;
+	int err = 0;
+
+	if (vif->mode != SPRDWL_MODE_AP) {
+		wl_ndev_log(L_DBG, vif->ndev, "Not AP mode, exit %s!\n", __func__);
+		err = -ENOENT;
+		goto out;
+	}
+
+	if (!list_empty(&vif->survey_info_list)) {
+		info = list_first_entry(&vif->survey_info_list,
+					struct sprdwl_survey_info, survey_list);
+		list_del(&info->survey_list);
+
+		if (info->channel) {
+			s_info->channel = info->channel;
+			s_info->noise = info->noise;
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 4, 83)
+			s_info->time = SPRDWL_ACS_SCAN_TIME;
+			s_info->time_busy = info->cca_busy_time;
+			s_info->filled = (SURVEY_INFO_NOISE_DBM |
+					SURVEY_INFO_TIME |
+					SURVEY_INFO_TIME_BUSY);
+#else
+			s_info->channel_time = SPRDWL_ACS_SCAN_TIME;
+			s_info->channel_time_busy = info->cca_busy_time;
+			s_info->filled = (SURVEY_INFO_NOISE_DBM |
+					  SURVEY_INFO_CHANNEL_TIME |
+					  SURVEY_INFO_CHANNEL_TIME_BUSY);
+#endif
+
+			survey_count++;
+		}
+
+		list_for_each_entry_safe(bssid, pos, &info->bssid_list, list) {
+			list_del(&bssid->list);
+			kfree(bssid);
+			bssid = NULL;
+		}
+
+		kfree(info);
+	} else {
+		/* There are no more survey info in list */
+		err = -ENOENT;
+		wl_ndev_log(L_DBG, vif->ndev, "%s report %d surveys\n",
+			    __func__, survey_count);
+		survey_count = 0;
+	}
+
+out:
+	return err;
+}
+#endif /* ACS_SUPPORT */
+
+#ifdef WOW_SUPPORT
+static void sprdwl_set_wakeup(struct wiphy *wiphy, bool enabled)
+{
+	struct cfg80211_wowlan *cfg = wiphy->wowlan_config;
+	struct sprdwl_priv *priv = wiphy_priv(wiphy);
+
+	if (!enabled) {
+		wl_debug("%s: disabled\n", __func__);
+		sprdwl_set_wowlan(priv, SPRDWL_WOWLAN_ANY, NULL, 0);
+		return;
+	}
+
+	if (cfg->any) {
+		wl_debug("%s: any\n", __func__);
+		sprdwl_set_wowlan(priv, SPRDWL_WOWLAN_ANY, NULL, 0);
+		return;
+	}
+
+	if (cfg->magic_pkt) {
+		wl_debug("%s: magic packet\n", __func__);
+		sprdwl_set_wowlan(priv, SPRDWL_WOWLAN_MAGIC_PKT, NULL, 0);
+	}
+
+	if (cfg->disconnect) {
+		wl_debug("%s: disconnect\n", __func__);
+		sprdwl_set_wowlan(priv, SPRDWL_WOWLAN_DISCONNECT, NULL, 0);
+	}
+}
+#endif
+
+static struct cfg80211_ops sprdwl_cfg80211_ops = {
+#ifndef CONFIG_P2P_INTF
+	.add_virtual_intf = sprdwl_cfg80211_add_iface,
+	.del_virtual_intf = sprdwl_cfg80211_del_iface,
+#endif
+	.change_virtual_intf = sprdwl_cfg80211_change_iface,
+	.add_key = sprdwl_cfg80211_add_key,
+	.del_key = sprdwl_cfg80211_del_key,
+	.set_default_key = sprdwl_cfg80211_set_default_key,
+	.set_rekey_data = sprdwl_cfg80211_set_rekey,
+	.start_ap = sprdwl_cfg80211_start_ap,
+	.change_beacon = sprdwl_cfg80211_change_beacon,
+	.stop_ap = sprdwl_cfg80211_stop_ap,
+	.add_station = sprdwl_cfg80211_add_station,
+	.del_station = sprdwl_cfg80211_del_station,
+	.change_station = sprdwl_cfg80211_change_station,
+	.get_station = sprdwl_cfg80211_get_station,
+	.libertas_set_mesh_channel = sprdwl_cfg80211_set_channel,
+	.scan = sprdwl_cfg80211_scan,
+	.connect = sprdwl_cfg80211_connect,
+	.disconnect = sprdwl_cfg80211_disconnect,
+#ifdef IBSS_SUPPORT
+	.join_ibss = sprdwl_cfg80211_join_ibss,
+	.leave_ibss = sprdwl_cfg80211_leave_ibss,
+#endif /* IBSS_SUPPORT */
+	.set_wiphy_params = sprdwl_cfg80211_set_wiphy_params,
+	.set_pmksa = sprdwl_cfg80211_set_pmksa,
+	.del_pmksa = sprdwl_cfg80211_del_pmksa,
+	.flush_pmksa = sprdwl_cfg80211_flush_pmksa,
+	.remain_on_channel = sprdwl_cfg80211_remain_on_channel,
+	.cancel_remain_on_channel = sprdwl_cfg80211_cancel_remain_on_channel,
+	.mgmt_tx = sprdwl_cfg80211_mgmt_tx,
+	.update_mgmt_frame_registrations =
+		sprdwl_cfg80211_update_mgmt_frame_registrations,
+	.set_power_mgmt = sprdwl_cfg80211_set_power_mgmt,
+	.set_cqm_rssi_config = sprdwl_cfg80211_set_cqm_rssi_config,
+	.sched_scan_start = sprdwl_cfg80211_sched_scan_start,
+	.sched_scan_stop = sprdwl_cfg80211_sched_scan_stop,
+	.tdls_mgmt = sprdwl_cfg80211_tdls_mgmt,
+	.tdls_oper = sprdwl_cfg80211_tdls_oper,
+	.start_p2p_device = sprdwl_cfg80211_start_p2p_device,
+	.stop_p2p_device = sprdwl_cfg80211_stop_p2p_device,
+	.set_mac_acl = sprdwl_cfg80211_set_mac_acl,
+	.update_ft_ies = sprdwl_cfg80211_update_ft_ies,
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 14, 0)
+	.set_qos_map = sprdwl_cfg80211_set_qos_map,
+#endif
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 18, 0)
+	.add_tx_ts = sprdwl_cfg80211_add_tx_ts,
+	.del_tx_ts = sprdwl_cfg80211_del_tx_ts,
+#endif
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 19, 0)
+	.tdls_channel_switch = sprdwl_cfg80211_tdls_chan_switch,
+	.tdls_cancel_channel_switch = sprdwl_cfg80211_tdls_cancel_chan_switch,
+#endif
+
+#ifdef ACS_SUPPORT
+	.dump_survey = sprdwl_cfg80211_dump_survey,
+#endif /*ACS_SUPPORT*/
+#ifdef DFS_MASTER
+	.start_radar_detection = sprdwl_cfg80211_start_radar_detection,
+	.channel_switch = sprdwl_cfg80211_channel_switch,
+#endif
+#ifdef WOW_SUPPORT
+	.set_wakeup = sprdwl_set_wakeup,
+#endif
+};
+
+void sprdwl_save_ch_info(struct sprdwl_priv *priv, u32 band, u32 flags, int center_freq)
+{
+	int index = 0;
+	/* Workaround for bug873327, report freq list instead of channel list */
+	// int tmp_ch = ieee80211_frequency_to_channel(center_freq);
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 7, 0)
+	if (band == NL80211_BAND_2GHZ) {
+#else
+	if (band == IEEE80211_BAND_2GHZ) {
+#endif
+		index = priv->ch_2g4_info.num_channels;
+		// priv->ch_2g4_info.channels[index] = tmp_ch;
+		priv->ch_2g4_info.channels[index] = center_freq;
+		priv->ch_2g4_info.num_channels++;
+	}
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 7, 0)
+	else if (band == NL80211_BAND_5GHZ) {
+#else
+	else if (band == IEEE80211_BAND_5GHZ) {
+#endif
+		if (flags & IEEE80211_CHAN_RADAR) {
+			index = priv->ch_5g_dfs_info.num_channels;
+			// priv->ch_5g_dfs_info.channels[index] = tmp_ch;
+			priv->ch_5g_dfs_info.channels[index] = center_freq;
+			priv->ch_5g_dfs_info.num_channels++;
+		} else {
+			index = priv->ch_5g_without_dfs_info.num_channels;
+			// priv->ch_5g_without_dfs_info.channels[index] = tmp_ch;
+			priv->ch_5g_without_dfs_info.channels[index] = center_freq;
+			priv->ch_5g_without_dfs_info.num_channels++;
+		}
+	} else
+		wl_err("invalid band param!\n");
+
+}
+
+#if defined(CONFIG_CFG80211_INTERNAL_REGDB) && !defined(CUSTOM_REGDOMAIN)
+static void sprdwl_reg_notify(struct wiphy *wiphy,
+			      struct regulatory_request *request)
+{
+	struct sprdwl_priv *priv = wiphy_priv(wiphy);
+	struct ieee80211_supported_band *sband;
+	struct ieee80211_channel *chan;
+	const struct ieee80211_freq_range *freq_range;
+	const struct ieee80211_reg_rule *reg_rule;
+	struct sprdwl_ieee80211_regdomain *rd = NULL;
+	u32 band, channel, i;
+	u32 last_start_freq;
+	u32 n_rules = 0, rd_size;
+
+	wl_info("%s %c%c initiator %d hint_type %d\n", __func__,
+		request->alpha2[0], request->alpha2[1],
+		request->initiator, request->user_reg_hint_type);
+
+	memset(&priv->ch_2g4_info, 0, sizeof(struct sprdwl_channel_list));
+	memset(&priv->ch_5g_without_dfs_info, 0,
+		sizeof(struct sprdwl_channel_list));
+	memset(&priv->ch_5g_dfs_info, 0, sizeof(struct sprdwl_channel_list));
+
+	/* Figure out the actual rule number */
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 7, 0)
+	for (band = 0; band < NUM_NL80211_BANDS; band++) {
+#else
+	for (band = 0; band < IEEE80211_NUM_BANDS; band++) {
+#endif
+		sband = wiphy->bands[band];
+		if (!sband)
+			continue;
+
+		last_start_freq = 0;
+		for (channel = 0; channel < sband->n_channels; channel++) {
+			chan = &sband->channels[channel];
+
+			reg_rule =
+			    freq_reg_info(wiphy, MHZ_TO_KHZ(chan->center_freq));
+			if (IS_ERR(reg_rule))
+				continue;
+
+			freq_range = &reg_rule->freq_range;
+			if (last_start_freq != freq_range->start_freq_khz) {
+				last_start_freq = freq_range->start_freq_khz;
+				n_rules++;
+			}
+
+			sprdwl_save_ch_info(priv, band, chan->flags,
+						(int)(chan->center_freq));
+		}
+	}
+
+	rd_size = sizeof(struct sprdwl_ieee80211_regdomain) +
+	    n_rules * sizeof(struct ieee80211_reg_rule);
+
+	rd = kzalloc(rd_size, GFP_KERNEL);
+	if (!rd) {
+		wl_err("%s failed to alloc sprdwl_ieee80211_regdomain!\n",
+		       __func__);
+		return;
+	}
+
+	/* Fill regulatory domain */
+	rd->n_reg_rules = n_rules;
+	memcpy(rd->alpha2, request->alpha2, ARRAY_SIZE(rd->alpha2));
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 7, 0)
+	for (band = 0, i = 0; band < NUM_NL80211_BANDS; band++) {
+#else
+	for (band = 0, i = 0; band < IEEE80211_NUM_BANDS; band++) {
+#endif
+		sband = wiphy->bands[band];
+		if (!sband)
+			continue;
+
+		last_start_freq = 0;
+		for (channel = 0; channel < sband->n_channels; channel++) {
+			chan = &sband->channels[channel];
+
+			if (chan->flags & IEEE80211_CHAN_DISABLED)
+				continue;
+
+			reg_rule =
+			    freq_reg_info(wiphy, MHZ_TO_KHZ(chan->center_freq));
+			if (IS_ERR(reg_rule))
+				continue;
+
+			freq_range = &reg_rule->freq_range;
+			if (last_start_freq != freq_range->start_freq_khz &&
+			    i < n_rules) {
+				last_start_freq = freq_range->start_freq_khz;
+
+				memcpy(&rd->reg_rules[i], reg_rule,
+				       sizeof(struct ieee80211_reg_rule));
+				i++;
+
+				wl_info(
+					  "%d KHz - %d KHz @ %d KHz flags %#x, chan->flags:%x\n",
+					  freq_range->start_freq_khz,
+					  freq_range->end_freq_khz,
+					  freq_range->max_bandwidth_khz,
+					  reg_rule->flags, chan->flags);
+			}
+		}
+	}
+
+	print_hex_dump_debug("regdom:", DUMP_PREFIX_OFFSET, 16, 1,
+			     rd, rd_size, true);
+	if (sprdwl_set_regdom(priv, (u8 *)rd, rd_size))
+		wl_err("%s failed to set regdomain!\n", __func__);
+	if (rd != NULL) {
+		kfree(rd);
+		rd = NULL;
+	}
+}
+#else
+static void sprdwl_reg_notify(struct wiphy *wiphy,
+			      struct regulatory_request *request)
+{
+	struct sprdwl_priv *priv = wiphy_priv(wiphy);
+	struct ieee80211_supported_band *sband;
+	struct ieee80211_channel *chan;
+	const struct ieee80211_freq_range *freq_range;
+	const struct ieee80211_reg_rule *reg_rule;
+	struct sprdwl_ieee80211_regdomain *rd = NULL;
+	u32 band, channel, i;
+	u32 last_start_freq;
+	u32 n_rules = 0, rd_size;
+	const struct ieee80211_regdomain *pRegdom;
+
+	wl_info("%s %c%c initiator %d hint_type %d\n", __func__,
+		request->alpha2[0], request->alpha2[1],
+		request->initiator, request->user_reg_hint_type);
+
+	if (!wiphy) {
+		wl_err("%s(): Wiphy = NULL\n", __func__);
+		return;
+	}
+
+	pRegdom = getRegdomainFromSprdDB(request->alpha2);
+	if (!pRegdom) {
+		wl_err("%s: Error, no correct RegDomain, country:%c%c\n",
+			__func__, request->alpha2[0], request->alpha2[1]);
+
+		return;
+	}
+
+	memset(&priv->ch_2g4_info, 0, sizeof(struct sprdwl_channel_list));
+	memset(&priv->ch_5g_without_dfs_info, 0,
+		sizeof(struct sprdwl_channel_list));
+	memset(&priv->ch_5g_dfs_info, 0, sizeof(struct sprdwl_channel_list));
+
+	/* Figure out the actual rule number */
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 7, 0)
+	for (band = 0; band < NUM_NL80211_BANDS; band++) {
+#else
+	for (band = 0; band < IEEE80211_NUM_BANDS; band++) {
+#endif
+		sband = wiphy->bands[band];
+		if (!sband)
+			continue;
+
+		last_start_freq = 0;
+		for (channel = 0; channel < sband->n_channels; channel++) {
+			chan = &sband->channels[channel];
+
+			reg_rule =
+			    sprd_freq_reg_info_regd(MHZ_TO_KHZ(chan->center_freq), pRegdom);
+			if (IS_ERR(reg_rule)) {
+				wl_debug("%s, %d, chan=%d\n", __func__, __LINE__, (int)(chan->center_freq));
+				continue;
+			}
+
+			freq_range = &reg_rule->freq_range;
+			if (last_start_freq != freq_range->start_freq_khz) {
+				last_start_freq = freq_range->start_freq_khz;
+				n_rules++;
+			}
+
+			sprdwl_save_ch_info(priv, band, chan->flags,
+						(int)(chan->center_freq));
+		}
+	}
+
+	rd_size = sizeof(struct sprdwl_ieee80211_regdomain) +
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 15, 0))
+	    n_rules * sizeof(struct ieee80211_reg_rule);
+#else
+	    n_rules * sizeof(struct unisoc_reg_rule);
+#endif
+
+	rd = kzalloc(rd_size, GFP_KERNEL);
+	if (!rd) {
+		wl_err("%s failed to alloc sprdwl_ieee80211_regdomain!\n",
+		       __func__);
+		return;
+	}
+
+	/* Fill regulatory domain */
+	rd->n_reg_rules = n_rules;
+	memcpy(rd->alpha2, request->alpha2, ARRAY_SIZE(rd->alpha2));
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 7, 0)
+	for (band = 0, i = 0; band < NUM_NL80211_BANDS; band++) {
+#else
+	for (band = 0, i = 0; band < IEEE80211_NUM_BANDS; band++) {
+#endif
+		sband = wiphy->bands[band];
+		if (!sband)
+			continue;
+
+		last_start_freq = 0;
+		for (channel = 0; channel < sband->n_channels; channel++) {
+			chan = &sband->channels[channel];
+
+			if (chan->flags & IEEE80211_CHAN_DISABLED)
+				continue;
+
+			reg_rule =
+			     sprd_freq_reg_info_regd(MHZ_TO_KHZ(chan->center_freq), pRegdom);
+			if (IS_ERR(reg_rule))
+				continue;
+
+			freq_range = &reg_rule->freq_range;
+			if (last_start_freq != freq_range->start_freq_khz &&
+			    i < n_rules) {
+				last_start_freq = freq_range->start_freq_khz;
+
+				memcpy(&rd->reg_rules[i], reg_rule,
+				       sizeof(struct ieee80211_reg_rule));
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(3, 15, 0))
+				rd->reg_rules[i].dfs_cac_ms = 0;
+#endif
+				i++;
+
+				wiphy_dbg(wiphy,
+					  "   %d KHz - %d KHz @ %d KHz flags %#x\n",
+					  freq_range->start_freq_khz,
+					  freq_range->end_freq_khz,
+					  freq_range->max_bandwidth_khz,
+					  reg_rule->flags);
+			}
+		}
+	}
+
+	wl_hex_dump(L_DBG, "regdom:", DUMP_PREFIX_OFFSET, 16, 1,
+			     rd, rd_size, true);
+	if (sprdwl_set_regdom(priv, (u8 *)rd, rd_size))
+		wl_err("%s failed to set regdomain!\n", __func__);
+
+	kfree(rd);
+}
+#endif
+
+static void sprdwl_ht_cap_update(struct ieee80211_sta_ht_cap *ht_info,
+		struct sprdwl_priv *priv)
+{
+	struct wiphy_sec2_t *sec2 = &priv->wiphy_sec2;
+
+	wl_info("%s enter:\n", __func__);
+	ht_info->ht_supported = true;
+	/*set Max A-MPDU length factor*/
+	if (sec2->ampdu_para) {
+		/*bit 0,1*/
+		ht_info->ampdu_factor = (sec2->ampdu_para & 0x3);
+		/*bit 2,3,4*/
+		ht_info->ampdu_density = ((sec2->ampdu_para >> 2) & 0x7);
+	}
+	/*set HT capabilities map as described in 802.11n spec */
+	if (sec2->ht_cap_info)
+		ht_info->cap = sec2->ht_cap_info;
+	/*set Supported MCS rates*/
+	memcpy(&ht_info->mcs, &sec2->ht_mcs_set,
+			sizeof(struct ieee80211_mcs_info));
+}
+
+static void sprdwl_vht_cap_update(struct ieee80211_sta_vht_cap *vht_cap,
+		struct sprdwl_priv *priv)
+{
+	struct wiphy_sec2_t *sec2 = &priv->wiphy_sec2;
+
+	wl_debug("%s enter:\n", __func__);
+	vht_cap->vht_supported = true;
+	if (sec2->vht_cap_info)
+		vht_cap->cap = sec2->vht_cap_info;
+	memcpy(&vht_cap->vht_mcs, &sec2->vht_mcs_set,
+			sizeof(struct ieee80211_vht_mcs_info));
+}
+
+void sprdwl_setup_wiphy(struct wiphy *wiphy, struct sprdwl_priv *priv)
+{
+	struct wiphy_sec2_t *sec2 = NULL;
+	struct ieee80211_sta_vht_cap *vht_info = NULL;
+	struct ieee80211_sta_ht_cap *ht_info = NULL;
+#if !defined (CONFIG_CFG80211_INTERNAL_REGDB) || defined(CUSTOM_REGDOMAIN)
+	const struct ieee80211_regdomain *pRegdom;
+	char alpha2[2];
+#endif
+
+	wiphy->mgmt_stypes = sprdwl_mgmt_stypes;
+	wiphy->interface_modes =
+	    BIT(NL80211_IFTYPE_STATION) | BIT(NL80211_IFTYPE_AP) |
+	    BIT(NL80211_IFTYPE_P2P_GO) | BIT(NL80211_IFTYPE_P2P_CLIENT);
+#ifndef CONFIG_P2P_INTF
+	wiphy->interface_modes |= BIT(NL80211_IFTYPE_P2P_DEVICE);
+#endif
+
+#if defined(IBSS_SUPPORT)
+	wiphy->interface_modes |= BIT(NL80211_IFTYPE_ADHOC);
+#endif /* IBSS_SUPPORT */
+
+	wiphy->flags &= ~WIPHY_FLAG_PS_ON_BY_DEFAULT;
+	wiphy->flags |= WIPHY_FLAG_HAS_REMAIN_ON_CHANNEL;
+	wiphy->signal_type = CFG80211_SIGNAL_TYPE_MBM;
+	wiphy->max_scan_ssids = SPRDWL_MAX_SCAN_SSIDS;
+	wiphy->max_scan_ie_len = SPRDWL_MAX_SCAN_IE_LEN;
+	wiphy->cipher_suites = sprdwl_cipher_suites;
+	wiphy->n_cipher_suites = ARRAY_SIZE(sprdwl_cipher_suites);
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 18, 0)
+	wiphy->max_ap_assoc_sta = priv->max_ap_assoc_sta;
+#endif
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 7, 0)
+	wiphy->bands[NL80211_BAND_2GHZ] = &sprdwl_band_2ghz;
+#else
+	wiphy->bands[IEEE80211_BAND_2GHZ] = &sprdwl_band_2ghz;
+#endif
+	if (priv->wiphy_sec2_flag) {
+		/*update HT capa got from fw*/
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 7, 0)
+		ht_info = &wiphy->bands[NL80211_BAND_2GHZ]->ht_cap;
+#else
+		ht_info = &wiphy->bands[IEEE80211_BAND_2GHZ]->ht_cap;
+#endif
+		sprdwl_ht_cap_update(ht_info, priv);
+
+		sec2 = &priv->wiphy_sec2;
+		/*set antenna mask*/
+		if (sec2->antenna_tx) {
+			wl_info("tx antenna:%d\n", sec2->antenna_tx);
+			wiphy->available_antennas_tx = sec2->antenna_tx;
+		}
+		if (sec2->antenna_rx) {
+			wl_info("rx antenna:%d\n", sec2->antenna_rx);
+			wiphy->available_antennas_rx = sec2->antenna_rx;
+		}
+		/*set retry limit for short or long frame*/
+		if (sec2->retry_short) {
+			wl_info("retry short num:%d\n", sec2->retry_short);
+			wiphy->retry_short = sec2->retry_short;
+		}
+		if (sec2->retry_long) {
+			wl_info("retry long num:%d\n", sec2->retry_long);
+			wiphy->retry_long = sec2->retry_long;
+		}
+		/*Fragmentation threshold (dot11FragmentationThreshold)*/
+		if ((sec2->frag_threshold) &&
+			(sec2->frag_threshold <=
+			 IEEE80211_MAX_FRAG_THRESHOLD)) {
+				wl_info("frag threshold:%d\n", sec2->frag_threshold);
+				wiphy->frag_threshold = sec2->frag_threshold;
+		} else {
+				wl_info("flag threshold invalid:%d,set to default:%d\n",
+					sec2->frag_threshold,
+					IEEE80211_MAX_FRAG_THRESHOLD);
+				sec2->frag_threshold = IEEE80211_MAX_FRAG_THRESHOLD;
+		}
+		/*RTS threshold (dot11RTSThreshold); -1 = RTS/CTS disabled*/
+		if ((sec2->rts_threshold) &&
+			(sec2->rts_threshold <= IEEE80211_MAX_RTS_THRESHOLD)) {
+				wl_info("rts threshold:%d\n", sec2->rts_threshold);
+				wiphy->rts_threshold = sec2->rts_threshold;
+		} else {
+				wl_info("rts threshold invalid:%d,set to default:%d\n",
+					sec2->rts_threshold, IEEE80211_MAX_RTS_THRESHOLD);
+				wiphy->rts_threshold = IEEE80211_MAX_RTS_THRESHOLD;
+		}
+	}
+
+#ifdef CONFIG_PM
+	/* Set WoWLAN flags */
+#if LINUX_VERSION_CODE > KERNEL_VERSION(3, 10, 0)
+	wiphy->wowlan = &sprdwl_wowlan_support;
+#else
+	memcpy(&wiphy->wowlan, &sprdwl_wowlan_support, sizeof(struct wiphy_wowlan_support));
+#endif
+#endif
+	wiphy->max_remain_on_channel_duration = 5000;
+	wiphy->max_num_pmkids = SPRDWL_MAX_NUM_PMKIDS;
+#ifdef RND_MAC_SUPPORT
+	wiphy->features |= (SCAN_RANDOM_MAC_ADDR);
+#endif
+	wiphy->features |= NL80211_FEATURE_CELL_BASE_REG_HINTS;
+
+	if (priv->fw_std & SPRDWL_STD_11D) {
+		wl_info("\tIEEE802.11d supported\n");
+		wiphy->reg_notifier = sprdwl_reg_notify;
+
+#if !defined (CONFIG_CFG80211_INTERNAL_REGDB) || defined(CUSTOM_REGDOMAIN)
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 14, 0))
+	wiphy->regulatory_flags |= REGULATORY_CUSTOM_REG;
+#else
+	wiphy->flags |= WIPHY_FLAG_CUSTOM_REGULATORY;
+#endif
+		alpha2[0] = '0';
+		alpha2[1] = '0';
+		pRegdom = getRegdomainFromSprdDB((char *)alpha2);
+		if (pRegdom) {
+			apply_custom_regulatory(wiphy, pRegdom);
+			ShowChannel(wiphy);
+		}
+#endif
+	}
+#if 0
+	if (priv->fw_std & SPRDWL_STD_11E) {
+		wl_info("\tIEEE802.11e supported\n");
+		wiphy->features |= NL80211_FEATURE_SUPPORTS_WMM_ADMISSION;
+		wiphy->flags |= WIPHY_FLAG_AP_UAPSD;
+	}
+#endif
+
+	if (priv->fw_std & SPRDWL_STD_11K)
+		wl_info("\tIEEE802.11k supported\n");
+
+	if (priv->fw_std & SPRDWL_STD_11R)
+		wl_info("\tIEEE802.11r supported\n");
+
+	if (priv->fw_std & SPRDWL_STD_11U)
+		wl_info("\tIEEE802.11u supported\n");
+
+	if (priv->fw_std & SPRDWL_STD_11V)
+		wl_info("\tIEEE802.11v supported\n");
+
+	if (priv->fw_std & SPRDWL_STD_11W)
+		wl_info("\tIEEE802.11w supported\n");
+
+	if (priv->fw_capa & SPRDWL_CAPA_5G) {
+		wl_info("\tDual band supported\n");
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 7, 0)
+		wiphy->bands[NL80211_BAND_5GHZ] = &sprdwl_band_5ghz;
+#else
+		wiphy->bands[IEEE80211_BAND_5GHZ] = &sprdwl_band_5ghz;
+#endif
+		if (priv->wiphy_sec2_flag) {
+			/*update HT capa got from fw*/
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 7, 0)
+			ht_info = &wiphy->bands[NL80211_BAND_5GHZ]->ht_cap;
+#else
+			ht_info = &wiphy->bands[IEEE80211_BAND_5GHZ]->ht_cap;
+#endif
+			sprdwl_ht_cap_update(ht_info, priv);
+			/*update VHT capa got from fw*/
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 7, 0)
+			vht_info = &wiphy->bands[NL80211_BAND_5GHZ]->vht_cap;
+#else
+			vht_info = &wiphy->bands[IEEE80211_BAND_5GHZ]->vht_cap;
+#endif
+			sprdwl_vht_cap_update(vht_info, priv);
+		}
+	}
+
+	if (priv->fw_capa & SPRDWL_CAPA_MCC) {
+		wl_info("\tMCC supported\n");
+		wiphy->n_iface_combinations = ARRAY_SIZE(sprdwl_iface_combos);
+		wiphy->iface_combinations = sprdwl_iface_combos;
+	} else {
+		wl_info("\tSCC supported\n");
+		wiphy->software_iftypes =
+		    BIT(NL80211_IFTYPE_STATION) | BIT(NL80211_IFTYPE_AP) |
+		    BIT(NL80211_IFTYPE_P2P_CLIENT) |
+		    BIT(NL80211_IFTYPE_P2P_GO);
+#ifndef CONFIG_P2P_INTF
+		wiphy->software_iftypes |= BIT(NL80211_IFTYPE_P2P_DEVICE);
+#endif
+	}
+
+	if (priv->fw_capa & SPRDWL_CAPA_ACL) {
+		wl_info("\tACL supported (%d)\n", priv->max_acl_mac_addrs);
+		wiphy->max_acl_mac_addrs = priv->max_acl_mac_addrs;
+	}
+
+	if (priv->fw_capa & SPRDWL_CAPA_AP_SME) {
+		wl_info("\tAP SME enabled\n");
+		wiphy->flags |= WIPHY_FLAG_HAVE_AP_SME;
+		wiphy->ap_sme_capa = 1;
+	}
+#if 0
+	if (priv->fw_capa & SPRDWL_CAPA_PMK_OKC_OFFLOAD &&
+	    priv->fw_capa & SPRDWL_CAPA_11R_ROAM_OFFLOAD) {
+		wl_info("\tRoaming offload supported\n");
+		wiphy->flags |= WIPHY_FLAG_SUPPORTS_FW_ROAM;
+	}
+#endif
+	if (priv->fw_capa & SPRDWL_CAPA_SCHED_SCAN) {
+		wl_info("\tScheduled scan supported\n");
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4, 12, 0)
+		wiphy->flags |= WIPHY_FLAG_SUPPORTS_SCHED_SCAN;
+#endif
+		wiphy->max_sched_scan_ssids = SPRDWL_MAX_PFN_LIST_COUNT;
+		wiphy->max_match_sets = SPRDWL_MAX_PFN_LIST_COUNT;
+		wiphy->max_sched_scan_ie_len = SPRDWL_MAX_SCAN_IE_LEN;
+	}
+#if 0
+	if (priv->fw_capa & SPRDWL_CAPA_TDLS) {
+		wl_info("\tTDLS supported\n");
+		wiphy->flags |= WIPHY_FLAG_SUPPORTS_TDLS;
+		wiphy->flags |= WIPHY_FLAG_TDLS_EXTERNAL_SETUP;
+		wiphy->features |= NL80211_FEATURE_TDLS_CHANNEL_SWITCH;
+	}
+#endif
+	if (priv->fw_capa & SPRDWL_CAPA_LL_STATS)
+		wl_info("\tLink layer stats supported\n");
+
+#if defined(IBSS_SUPPORT) && defined(IBSS_RSN_SUPPORT)
+	wiphy->flags |= WIPHY_FLAG_IBSS_RSN;
+#endif /* IBSS_SUPPORT && IBSS_RSN_SUPPORT */
+
+#ifdef DFS_MASTER
+	wiphy->flags |= WIPHY_FLAG_HAS_CHANNEL_SWITCH;
+#endif
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 12, 0)
+	wiphy->max_sched_scan_reqs = 1;
+#endif
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 11, 0)
+	wiphy_ext_feature_set(wiphy,
+		NL80211_EXT_FEATURE_SCHED_SCAN_RELATIVE_RSSI);
+#endif
+}
+
+static void sprdwl_check_intf_ops(struct sprdwl_if_ops *ops)
+{
+	WARN_ON(!ops->get_msg_buf);
+	WARN_ON(!ops->free_msg_buf);
+	WARN_ON(!ops->tx);
+	WARN_ON(!ops->force_exit);
+	WARN_ON(!ops->is_exit);
+}
+
+struct sprdwl_priv *sprdwl_core_create(enum sprdwl_hw_type type,
+				       struct sprdwl_if_ops *ops)
+{
+	struct wiphy *wiphy;
+	struct sprdwl_priv *priv;
+	int ret = 0;
+
+	sprdwl_check_intf_ops(ops);
+	sprdwl_cmd_init();
+
+	wiphy = wiphy_new(&sprdwl_cfg80211_ops, sizeof(*priv));
+	if (!wiphy) {
+		wl_err("failed to allocate wiphy!\n");
+		return NULL;
+	}
+	priv = wiphy_priv(wiphy);
+	priv->wiphy = wiphy;
+	g_sprdwl_priv = priv;
+	priv->hw_type = type;
+	wl_info("hw_type:%d\n", priv->hw_type);
+
+	priv->skb_head_len = sizeof(struct sprdwl_data_hdr) + NET_IP_ALIGN +
+	    SPRDWL_SKB_HEAD_RESERV_LEN + 3;
+
+	priv->if_ops = ops;
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 14, 0)
+	timer_setup(&priv->scan_timer, sprdwl_scan_timeout, 0);
+#else
+	setup_timer(&priv->scan_timer, sprdwl_scan_timeout,
+		    (unsigned long)priv);
+#endif
+
+#ifdef WMMAC_WFA_CERTIFICATION
+	wmm_ac_init(priv);
+	init_default_qos_map();
+#endif
+	spin_lock_init(&priv->scan_lock);
+	spin_lock_init(&priv->sched_scan_lock);
+	spin_lock_init(&priv->list_lock);
+	INIT_LIST_HEAD(&priv->vif_list);
+	ret = sprdwl_init_work(priv);
+	if (ret != 0) {
+		wl_err("sprdwl_init_work failed!\n");
+		return NULL;
+	}
+
+	return priv;
+}
+
+void sprdwl_core_free(struct sprdwl_priv *priv)
+{
+	if (priv)
+		sprdwl_deinit_work(priv);
+	sprdwl_cmd_deinit();
+	if (priv) {
+		struct wiphy *wiphy = priv->wiphy;
+
+		if (wiphy)
+			wiphy_free(wiphy);
+		g_sprdwl_priv = NULL;
+	}
+}
diff --git a/drivers/net/wireless/uwe5622/unisocwifi/cfg80211.h b/drivers/net/wireless/uwe5622/unisocwifi/cfg80211.h
new file mode 100644
index 000000000000..380e7da5f442
--- /dev/null
+++ b/drivers/net/wireless/uwe5622/unisocwifi/cfg80211.h
@@ -0,0 +1,211 @@
+/*
+ * Copyright (C) 2015 Spreadtrum Communications Inc.
+ *
+ * Authors	:
+ * Keguang Zhang <keguang.zhang@spreadtrum.com>
+ * Jingxiang Li <Jingxiang.li@spreadtrum.com>
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#ifndef __SPRDWL_CFG80211_H__
+#define __SPRDWL_CFG80211_H__
+
+#include <net/cfg80211.h>
+#include <linux/version.h>
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3, 19, 0)
+#define NL80211_SCAN_FLAG_RANDOM_ADDR          (1<<3)
+
+#define NL80211_FEATURE_SUPPORTS_WMM_ADMISSION (1 << 26)
+#define NL80211_FEATURE_TDLS_CHANNEL_SWITCH    (1 << 28)
+#define NL80211_FEATURE_SCAN_RANDOM_MAC_ADDR   (1 << 29)
+#endif
+
+/* auth type */
+#define SPRDWL_AUTH_OPEN		0
+#define SPRDWL_AUTH_SHARED		1
+/* parise or group key type */
+#define SPRDWL_GROUP			0
+#define SPRDWL_PAIRWISE			1
+/* cipher suite */
+#define WLAN_CIPHER_SUITE_PMK           0x000FACFF
+/* AKM suite */
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4, 14, 0)
+#define WLAN_AKM_SUITE_FT_8021X		0x000FAC03
+#define WLAN_AKM_SUITE_FT_PSK		0x000FAC04
+#endif
+#define WLAN_AKM_SUITE_WAPI_CERT	0x00147201
+#define WLAN_AKM_SUITE_WAPI_PSK		0x00147202
+
+#define SPRDWL_AKM_SUITE_NONE		(0)
+#define SPRDWL_AKM_SUITE_8021X		(1)
+#define SPRDWL_AKM_SUITE_PSK		(2)
+#define SPRDWL_AKM_SUITE_FT_8021X	(3)
+#define SPRDWL_AKM_SUITE_FT_PSK		(4)
+#define SPRDWL_AKM_SUITE_WAPI_PSK	(4)
+#define SPRDWL_AKM_SUITE_8021X_SHA256	(5)
+#define SPRDWL_AKM_SUITE_PSK_SHA256	(6)
+#define SPRDWL_AKM_SUITE_WAPI_CERT	(12)
+
+/* determine the actual values for the macros below*/
+#define SPRDWL_MAX_SCAN_SSIDS		12
+#define SPRDWL_MAX_SCAN_IE_LEN		2304
+#define SPRDWL_MAX_NUM_PMKIDS		4
+#define SPRDWL_MAX_KEY_INDEX		3
+#define SPRDWL_SCAN_TIMEOUT_MS		10000
+#define SPRDWL_MAX_PFN_LIST_COUNT	9
+#define SPRDWL_MAX_IE_LEN           500
+
+#define SPRDWL_MAC_INDEX_MAX		4
+
+#define SPRDWL_ACS_SCAN_TIME		20
+
+#define CH_MAX_2G_CHANNEL			(14)
+#define CH_MAX_5G_CHANNEL			(25)
+#define TOTAL_2G_5G_CHANNEL_NUM			(39)/*14+25=39*/
+#define TOTAL_2G_5G_SSID_NUM         9
+
+enum sprdwl_mode {
+	SPRDWL_MODE_NONE,
+	SPRDWL_MODE_STATION,
+	SPRDWL_MODE_AP,
+
+	SPRDWL_MODE_P2P_DEVICE = 4,
+	SPRDWL_MODE_P2P_CLIENT,
+	SPRDWL_MODE_P2P_GO,
+
+	SPRDWL_MODE_IBSS,
+
+	SPRDWL_MODE_MAX,
+};
+
+enum sm_state {
+	SPRDWL_UNKNOWN = 0,
+	SPRDWL_SCANNING,
+	SPRDWL_SCAN_ABORTING,
+	SPRDWL_DISCONNECTING,
+	SPRDWL_DISCONNECTED,
+	SPRDWL_CONNECTING,
+	SPRDWL_CONNECTED
+};
+
+enum connect_result {
+	SPRDWL_CONNECT_SUCCESS,
+	SPRDWL_CONNECT_FAILED,
+	SPRDWL_ROAM_SUCCESS,
+	SPRDWL_IBSS_JOIN,
+	SPRDWL_IBSS_START
+};
+
+enum acl_mode {
+	SPRDWL_ACL_MODE_DISABLE,
+	SPRDWL_ACL_MODE_WHITELIST,
+	SPRDWL_ACL_MODE_BLACKLIST,
+};
+
+struct sprdwl_scan_ssid {
+	u8 len;
+	u8 ssid[0];
+} __packed;
+
+struct sprdwl_sched_scan_buf {
+	u32 interval;
+	u32 flags;
+	s32 rssi_thold;
+	u8 channel[TOTAL_2G_5G_CHANNEL_NUM + 1];
+
+	u32 n_ssids;
+	u8 *ssid[TOTAL_2G_5G_CHANNEL_NUM];
+	u32 n_match_ssids;
+	u8 *mssid[TOTAL_2G_5G_CHANNEL_NUM];
+
+	const u8 *ie;
+	size_t ie_len;
+};
+
+struct unisoc_reg_rule {
+	struct ieee80211_freq_range freq_range;
+	struct ieee80211_power_rule power_rule;
+	u32 flags;
+	u32 dfs_cac_ms;
+};
+
+struct sprdwl_ieee80211_regdomain {
+	u32 n_reg_rules;
+	char alpha2[2];
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 15, 0) && \
+	LINUX_VERSION_CODE < KERNEL_VERSION(4, 18, 0))
+	struct ieee80211_reg_rule reg_rules[];
+#else
+	struct unisoc_reg_rule reg_rules[];
+#endif
+};
+
+/* WIFI_EVENT_CONNECT */
+struct sprdwl_connect_info {
+	u8 status;
+	u8 *bssid;
+	u8 channel;
+	s8 signal;
+	u8 *bea_ie;
+	u16 bea_ie_len;
+	u8 *req_ie;
+	u16 req_ie_len;
+	u8 *resp_ie;
+	u16 resp_ie_len;
+} __packed;
+
+struct sprdwl_vif;
+struct sprdwl_priv;
+
+void sprdwl_setup_wiphy(struct wiphy *wiphy, struct sprdwl_priv *priv);
+
+int sprdwl_init_fw(struct sprdwl_vif *vif);
+int sprdwl_uninit_fw(struct sprdwl_vif *vif);
+
+struct sprdwl_vif *ctx_id_to_vif(struct sprdwl_priv *priv, u8 vif_ctx_id);
+struct sprdwl_vif *mode_to_vif(struct sprdwl_priv *priv, u8 vif_mode);
+void sprdwl_put_vif(struct sprdwl_vif *vif);
+
+void sprdwl_report_softap(struct sprdwl_vif *vif, u8 is_connect, u8 *addr,
+			  u8 *req_ie, u16 req_ie_len);
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 14, 0)
+void sprdwl_scan_timeout(struct timer_list *t);
+#else
+void sprdwl_scan_timeout(unsigned long data);
+#endif
+void sprdwl_scan_done(struct sprdwl_vif *vif, bool abort);
+void sprdwl_sched_scan_done(struct sprdwl_vif *vif, bool abort);
+void sprdwl_report_scan_result(struct sprdwl_vif *vif, u16 chan, s16 rssi,
+			       u8 *frame, u16 len);
+void sprdwl_report_connection(struct sprdwl_vif *vif,
+							struct sprdwl_connect_info *conn_info,
+							u8 status_code);
+void sprdwl_report_disconnection(struct sprdwl_vif *vif, u16 reason_code);
+void sprdwl_report_mic_failure(struct sprdwl_vif *vif, u8 is_mcast, u8 key_id);
+void sprdwl_cfg80211_dump_frame_prot_info(int send, int freq,
+					  const unsigned char *buf, int len);
+void sprdwl_report_remain_on_channel_expired(struct sprdwl_vif *vif);
+void sprdwl_report_mgmt_tx_status(struct sprdwl_vif *vif, u64 cookie,
+				  const u8 *buf, u32 len, u8 ack);
+void sprdwl_report_rx_mgmt(struct sprdwl_vif *vif, u8 chan, const u8 *buf,
+			   size_t len);
+void sprdwl_report_mgmt_deauth(struct sprdwl_vif *vif, const u8 *buf,
+			       size_t len);
+void sprdwl_report_mgmt_disassoc(struct sprdwl_vif *vif, const u8 *buf,
+				 size_t len);
+void sprdwl_report_cqm(struct sprdwl_vif *vif, u8 rssi_event);
+void sprdwl_report_tdls(struct sprdwl_vif *vif, const u8 *peer,
+			u8 oper, u16 reason_code);
+void sprdwl_report_fake_probe(struct wiphy *wiphy, u8 *ie, size_t ielen);
+int sprdwl_change_beacon(struct sprdwl_vif *vif,
+		struct cfg80211_beacon_data *beacon);
+#endif
diff --git a/drivers/net/wireless/uwe5622/unisocwifi/cmdevt.c b/drivers/net/wireless/uwe5622/unisocwifi/cmdevt.c
new file mode 100644
index 000000000000..7692bc847df2
--- /dev/null
+++ b/drivers/net/wireless/uwe5622/unisocwifi/cmdevt.c
@@ -0,0 +1,3561 @@
+/*
+ * Copyright (C) 2015 Spreadtrum Communications Inc.
+ *
+ * Authors	:
+ * Keguang Zhang <keguang.zhang@spreadtrum.com>
+ * Jingxiang Li <Jingxiang.li@spreadtrum.com>
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include "sprdwl.h"
+#include "cmdevt.h"
+#include "cfg80211.h"
+#include "msg.h"
+#include "txrx.h"
+#include "intf_ops.h"
+#include "vendor.h"
+#include "work.h"
+#ifdef NAN_SUPPORT
+#include "nan.h"
+#endif /* NAN_SUPPORT */
+#include "tx_msg.h"
+#include "rx_msg.h"
+#include "wl_intf.h"
+#ifdef DFS_MASTER
+#include "11h.h"
+#endif
+#include "rf_marlin3.h"
+#include <linux/kthread.h>
+#ifdef WMMAC_WFA_CERTIFICATION
+#include "qos.h"
+#endif
+#include <linux/completion.h>
+
+struct sprdwl_cmd {
+	u8 cmd_id;
+	int init_ok;
+	u32 mstime;
+	void *data;
+	atomic_t refcnt;
+	/* spin lock for command */
+	spinlock_t lock;
+	/* mutex for command */
+	struct mutex cmd_lock;
+	/* wake_lock for command */
+	struct wakeup_source *wake_lock;
+	/*complettion for command*/
+	struct completion completed;
+};
+
+static struct sprdwl_cmd g_sprdwl_cmd;
+
+const uint16_t CRC_table[] = {
+	0x0000, 0xCC01, 0xD801, 0x1400, 0xF001, 0x3C00,
+	0x2800, 0xE401, 0xA001, 0x6C00, 0x7800, 0xB401,
+	0x5000, 0x9C01, 0x8801, 0x4400,
+};
+
+#define C2S(x) \
+{ \
+	case x: \
+		str = #x;\
+		break; \
+}
+
+static int bss_count;
+static const char *cmd2str(u8 cmd)
+{
+	const char *str = NULL;
+
+	switch (cmd) {
+	C2S(WIFI_CMD_ERR)
+	C2S(WIFI_CMD_GET_INFO)
+	C2S(WIFI_CMD_SET_REGDOM)
+	C2S(WIFI_CMD_OPEN)
+	C2S(WIFI_CMD_CLOSE)
+	C2S(WIFI_CMD_POWER_SAVE)
+	C2S(WIFI_CMD_SET_PARAM)
+	C2S(WIFI_CMD_REQ_LTE_CONCUR)
+	C2S(WIFI_CMD_SYNC_VERSION)
+	C2S(WIFI_CMD_CONNECT)
+
+	C2S(WIFI_CMD_SCAN)
+	C2S(WIFI_CMD_SCHED_SCAN)
+	C2S(WIFI_CMD_DISCONNECT)
+	C2S(WIFI_CMD_KEY)
+	C2S(WIFI_CMD_SET_PMKSA)
+	C2S(WIFI_CMD_GET_STATION)
+	C2S(WIFI_CMD_SET_CHANNEL)
+
+	C2S(WIFI_CMD_START_AP)
+	C2S(WIFI_CMD_DEL_STATION)
+	C2S(WIFI_CMD_SET_BLACKLIST)
+	C2S(WIFI_CMD_SET_WHITELIST)
+	C2S(WIFI_CMD_MULTICAST_FILTER)
+
+	C2S(WIFI_CMD_TX_MGMT)
+	C2S(WIFI_CMD_REGISTER_FRAME)
+	C2S(WIFI_CMD_REMAIN_CHAN)
+	C2S(WIFI_CMD_CANCEL_REMAIN_CHAN)
+
+	C2S(WIFI_CMD_SET_IE)
+	C2S(WIFI_CMD_NOTIFY_IP_ACQUIRED)
+
+	C2S(WIFI_CMD_SET_CQM)
+	C2S(WIFI_CMD_SET_ROAM_OFFLOAD)
+	C2S(WIFI_CMD_SET_MEASUREMENT)
+	C2S(WIFI_CMD_SET_QOS_MAP)
+	C2S(WIFI_CMD_TDLS)
+	C2S(WIFI_CMD_11V)
+	C2S(WIFI_CMD_NPI_MSG)
+	C2S(WIFI_CMD_NPI_GET)
+
+	C2S(WIFI_CMD_ASSERT)
+	C2S(WIFI_CMD_FLUSH_SDIO)
+	C2S(WIFI_CMD_ADD_TX_TS)
+	C2S(WIFI_CMD_DEL_TX_TS)
+	C2S(WIFI_CMD_LLSTAT)
+
+	C2S(WIFI_CMD_GSCAN)
+	C2S(WIFI_CMD_RSSI_MONITOR)
+
+	C2S(WIFI_CMD_IBSS_JOIN)
+	C2S(WIFI_CMD_SET_IBSS_ATTR)
+	C2S(WIFI_CMD_NAN)
+	C2S(WIFI_CMD_RND_MAC)
+	C2S(WIFI_CMD_BA)
+	C2S(WIFI_CMD_SET_MAX_CLIENTS_ALLOWED)
+	C2S(WIFI_CMD_TX_DATA)
+	C2S(WIFI_CMD_ADDBA_REQ)
+	C2S(WIFI_CMD_DELBA_REQ)
+	C2S(WIFI_CMD_SET_PROTECT_MODE)
+	C2S(WIFI_CMD_GET_PROTECT_MODE)
+	C2S(WIFI_CMD_DOWNLOAD_INI)
+	C2S(WIFI_CMD_PACKET_OFFLOAD)
+#ifdef DFS_MASTER
+	C2S(WIFI_CMD_RADAR_DETECT)
+	C2S(WIFI_CMD_RESET_BEACON)
+#endif
+	C2S(WIFI_CMD_VOWIFI_DATA_PROTECT)
+	C2S(WIFI_CMD_SET_TLV)
+	C2S(WIFI_CMD_SET_WOWLAN)
+	default :
+		return "WIFI_CMD_UNKNOWN";
+	}
+
+	return str;
+}
+
+#undef C2S
+
+#define AR2S(x) \
+{ \
+	case x: \
+		str = #x; \
+		break; \
+}
+
+static const char *assert_reason_to_str(u8 reason)
+{
+	const char *str = NULL;
+
+	switch (reason) {
+	AR2S(SCAN_ERROR)
+	AR2S(RSP_CNT_ERROR)
+	AR2S(HANDLE_FLAG_ERROR)
+	AR2S(CMD_RSP_TIMEOUT_ERROR)
+	AR2S(LOAD_INI_DATA_FAILED)
+	AR2S(DOWNLOAD_INI_DATA_FAILED)
+	default :
+		return "UNKNOWN ASSERT REASON";
+	}
+	return str;
+}
+
+#undef AR2S
+
+uint16_t CRC16(uint8_t *buf, uint16_t len)
+{
+	uint16_t CRC = 0xFFFF;
+	uint16_t i;
+	uint8_t ch_char;
+
+	for (i = 0; i < len; i++) {
+		ch_char = *buf++;
+		CRC = CRC_table[(ch_char ^ CRC) & 15] ^ (CRC >> 4);
+		CRC = CRC_table[((ch_char >> 4) ^ CRC) & 15] ^ (CRC >> 4);
+	}
+	return CRC;
+}
+
+static const char *err2str(s8 error)
+{
+	char *str = NULL;
+
+	switch (error) {
+	case SPRDWL_CMD_STATUS_ARG_ERROR:
+		str = "SPRDWL_CMD_STATUS_ARG_ERROR";
+		break;
+	case SPRDWL_CMD_STATUS_GET_RESULT_ERROR:
+		str = "SPRDWL_CMD_STATUS_GET_RESULT_ERROR";
+		break;
+	case SPRDWL_CMD_STATUS_EXEC_ERROR:
+		str = "SPRDWL_CMD_STATUS_EXEC_ERROR";
+		break;
+	case SPRDWL_CMD_STATUS_MALLOC_ERROR:
+		str = "SPRDWL_CMD_STATUS_MALLOC_ERROR";
+		break;
+	case SPRDWL_CMD_STATUS_WIFIMODE_ERROR:
+		str = "SPRDWL_CMD_STATUS_WIFIMODE_ERROR";
+		break;
+	case SPRDWL_CMD_STATUS_ERROR:
+		str = "SPRDWL_CMD_STATUS_ERROR";
+		break;
+	case SPRDWL_CMD_STATUS_CONNOT_EXEC_ERROR:
+		str = "SPRDWL_CMD_STATUS_CONNOT_EXEC_ERROR";
+		break;
+	case SPRDWL_CMD_STATUS_NOT_SUPPORT_ERROR:
+		str = "SPRDWL_CMD_STATUS_NOT_SUPPORT_ERROR";
+		break;
+	case SPRDWL_CMD_STATUS_CRC_ERROR:
+		str = "SPRDWL_CMD_STATUS_CRC_ERROR";
+		break;
+	case SPRDWL_CMD_STATUS_INI_INDEX_ERROR:
+		str = "SPRDWL_CMD_STATUS_INI_INDEX_ERROR";
+		break;
+	case SPRDWL_CMD_STATUS_LENGTH_ERROR:
+		str = "SPRDWL_CMD_STATUS_LENGTH_ERROR";
+		break;
+	case SPRDWL_CMD_STATUS_OTHER_ERROR:
+		str = "SPRDWL_CMD_STATUS_OTHER_ERROR";
+		break;
+	case SPRDWL_CMD_STATUS_OK:
+		str = "CMD STATUS OK";
+		break;
+	default:
+		str = "SPRDWL_CMD_STATUS_UNKNOWN_ERROR";
+		break;
+	}
+	return str;
+}
+
+int sprdwl_cmd_init(void)
+{
+	struct sprdwl_cmd *cmd = &g_sprdwl_cmd;
+	/* memset(cmd, 0, sizeof(*cmd)); */
+	cmd->data = NULL;
+	cmd->wake_lock = wakeup_source_register(sprdwl_dev,
+						"Wi-Fi_cmd_wakelock");
+
+	if (!cmd->wake_lock) {
+		wl_err("%s wakeup source register error.\n", __func__);
+		return -EINVAL;
+	}
+	spin_lock_init(&cmd->lock);
+	mutex_init(&cmd->cmd_lock);
+	init_completion(&cmd->completed);
+	cmd->init_ok = 1;
+	return 0;
+}
+
+void sprdwl_cmd_wake_upall(void)
+{
+	complete(&g_sprdwl_cmd.completed);
+}
+
+static void sprdwl_cmd_set(struct sprdwl_cmd_hdr *hdr)
+{
+	struct sprdwl_cmd *cmd = &g_sprdwl_cmd;
+	u32 msec;
+	ktime_t kt;
+
+	kt = ktime_get();
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 14, 0)
+	msec = (u32)(div_u64(kt, NSEC_PER_MSEC));
+#else
+	msec = (u32)(div_u64(kt.tv64, NSEC_PER_MSEC));
+#endif
+	hdr->mstime = cpu_to_le32(msec);
+	spin_lock_bh(&cmd->lock);
+	kfree(cmd->data);
+	cmd->data = NULL;
+	cmd->mstime = msec;
+	cmd->cmd_id = hdr->cmd_id;
+	spin_unlock_bh(&cmd->lock);
+}
+
+static void sprdwl_cmd_clean(struct sprdwl_cmd *cmd)
+{
+	spin_lock_bh(&cmd->lock);
+	kfree(cmd->data);
+	cmd->data = NULL;
+	cmd->mstime = 0;
+	cmd->cmd_id = 0;
+	spin_unlock_bh(&cmd->lock);
+}
+
+#define SPRDWL_CMD_EXIT_VAL 0x8000
+void sprdwl_cmd_deinit(void)
+{
+	unsigned long timeout;
+	struct sprdwl_cmd *cmd = &g_sprdwl_cmd;
+
+	atomic_add(SPRDWL_CMD_EXIT_VAL, &cmd->refcnt);
+	complete(&cmd->completed);
+	timeout = jiffies + msecs_to_jiffies(1000);
+	while (atomic_read(&cmd->refcnt) > SPRDWL_CMD_EXIT_VAL) {
+		if (time_after(jiffies, timeout)) {
+			wl_err("%s cmd lock timeout\n", __func__);
+			break;
+		}
+		usleep_range(2000, 2500);
+	}
+	sprdwl_cmd_clean(cmd);
+	mutex_destroy(&cmd->cmd_lock);
+	if (cmd->wake_lock)
+		wakeup_source_unregister(cmd->wake_lock);
+}
+
+extern struct sprdwl_intf_ops g_intf_ops;
+static int sprdwl_cmd_lock(struct sprdwl_cmd *cmd)
+{
+	struct sprdwl_intf *intf = (struct sprdwl_intf *)g_intf_ops.intf;
+
+	if (atomic_inc_return(&cmd->refcnt) >= SPRDWL_CMD_EXIT_VAL) {
+		atomic_dec(&cmd->refcnt);
+		wl_err("%s failed, cmd->refcnt=%d\n",
+		       __func__,
+		       atomic_read(&cmd->refcnt));
+		return -1;
+	}
+	mutex_lock(&cmd->cmd_lock);
+	if (intf->priv->is_suspending == 0)
+		__pm_stay_awake(cmd->wake_lock);
+	wl_debug("cmd->refcnt=%x\n", atomic_read(&cmd->refcnt));
+
+	return 0;
+}
+
+static void sprdwl_cmd_unlock(struct sprdwl_cmd *cmd)
+{
+	struct sprdwl_intf *intf = (struct sprdwl_intf *)g_intf_ops.intf;
+
+	mutex_unlock(&cmd->cmd_lock);
+	atomic_dec(&cmd->refcnt);
+	if (intf->priv->is_suspending == 0)
+		__pm_relax(cmd->wake_lock);
+	if (intf->priv->is_suspending == 1)
+		intf->priv->is_suspending = 0;
+}
+
+struct sprdwl_msg_buf *__sprdwl_cmd_getbuf(struct sprdwl_priv *priv,
+					   u16 len, u8 ctx_id,
+					   enum sprdwl_head_rsp rsp,
+					   u8 cmd_id, gfp_t flags)
+{
+	struct sprdwl_msg_buf *msg;
+	struct sprdwl_cmd_hdr *hdr;
+	u16 plen = sizeof(*hdr) + len;
+	enum sprdwl_mode mode = SPRDWL_MODE_NONE;/*default to open new device*/
+	void *data = NULL;
+	struct sprdwl_vif *vif;
+	struct sprdwl_intf *intf = (struct sprdwl_intf *)(priv->hw_priv);
+
+	if (intf->cp_asserted == 1)
+		return NULL;
+
+	if (cmd_id >= WIFI_CMD_OPEN) {
+		vif = ctx_id_to_vif(priv, ctx_id);
+		if (!vif)
+			wl_err("%s cant't get vif, ctx_id: %d\n",
+			       __func__, ctx_id);
+		else
+			mode =  vif->mode;
+		sprdwl_put_vif(vif);
+	}
+
+	msg = sprdwl_intf_get_msg_buf(priv, SPRDWL_TYPE_CMD, mode, ctx_id);
+	if (!msg) {
+		wl_err("%s, %d, getmsgbuf fail, mode=%d\n",
+		       __func__, __LINE__, mode);
+		return NULL;
+	}
+
+	data = kzalloc((plen + priv->hw_offset), flags);
+	if (data) {
+		hdr = (struct sprdwl_cmd_hdr *)(data + priv->hw_offset);
+		hdr->common.type = SPRDWL_TYPE_CMD;
+		hdr->common.reserv = 0;
+		hdr->common.rsp = rsp;
+		hdr->common.ctx_id = ctx_id;
+		hdr->plen = cpu_to_le16(plen);
+		hdr->cmd_id = cmd_id;
+		sprdwl_fill_msg(msg, NULL, data, plen);
+		msg->data = hdr + 1;
+	} else {
+		wl_err("%s failed to allocate skb\n", __func__);
+		sprdwl_intf_free_msg_buf(priv, msg);
+		return NULL;
+	}
+
+	return msg;
+}
+
+/* if erro, data is released in this function
+ * if OK, data is released in hif interface
+ */
+static int sprdwl_cmd_send_to_ic(struct sprdwl_priv *priv,
+				 struct sprdwl_msg_buf *msg)
+{
+	struct sprdwl_cmd_hdr *hdr;
+	struct sprdwl_intf *intf = (struct sprdwl_intf *)(priv->hw_priv);
+	struct sprdwl_tx_msg *tx_msg = (struct sprdwl_tx_msg *)intf->sprdwl_tx;
+
+	hdr = (struct sprdwl_cmd_hdr *)(msg->tran_data + priv->hw_offset);
+	/*TODO:consider common this if condition since
+	 * SPRDWL_HEAD_NORSP not used any more
+	 */
+	if (hdr->common.rsp)
+		sprdwl_cmd_set(hdr);
+
+	wl_warn("[%u]ctx_id %d send[%s], num: %d\n",
+		le32_to_cpu(hdr->mstime),
+		hdr->common.ctx_id,
+		cmd2str(hdr->cmd_id),
+		tx_msg->cmd_send + 1);
+
+	return sprdwl_send_cmd(priv, msg);
+}
+
+static int sprdwl_timeout_recv_rsp(struct sprdwl_priv *priv,
+				   unsigned int timeout)
+{
+	int ret;
+	struct sprdwl_cmd *cmd = &g_sprdwl_cmd;
+	struct sprdwl_intf *intf = (struct sprdwl_intf *)(priv->hw_priv);
+	struct sprdwl_tx_msg *tx_msg = (struct sprdwl_tx_msg *)intf->sprdwl_tx;
+
+	ret = wait_for_completion_timeout(&cmd->completed, msecs_to_jiffies(timeout));
+	if (!ret) {
+		wl_err("[%s]timeout\n", cmd2str(cmd->cmd_id));
+		return -1;
+	} else if (sprdwl_intf_is_exit(priv) ||
+		   atomic_read(&cmd->refcnt) >= SPRDWL_CMD_EXIT_VAL) {
+		wl_err("cmd->refcnt=%x\n", atomic_read(&cmd->refcnt));
+		return -1;
+	} else if (tx_msg->hang_recovery_status == HANG_RECOVERY_ACKED
+		&& cmd->cmd_id != WIFI_CMD_HANG_RECEIVED) {
+		wl_warn("hang recovery happen\n");
+		return -1;
+	}
+
+	spin_lock_bh(&cmd->lock);
+	ret = cmd->data ? 0 : -1;
+	spin_unlock_bh(&cmd->lock);
+
+	return ret;
+}
+
+static int sprdwl_atcmd_assert(struct sprdwl_priv *priv, u8 vif_ctx_id, u8 cmd_id, u8 reason)
+{
+#define ASSERT_INFO_BUF_SIZE	100
+
+	struct sprdwl_intf *intf = (struct sprdwl_intf *)(priv->hw_priv);
+	char	buf[ASSERT_INFO_BUF_SIZE] = {0};
+	u8 idx = 0;
+
+	wl_err("%s ctx_id:%d, cmd_id:%d, reason:%d, cp_asserted:%d\n",
+	       __func__, vif_ctx_id, cmd_id, reason, intf->cp_asserted);
+
+	if (intf->cp_asserted == 0) {
+		intf->cp_asserted = 1;
+
+		if ((strlen(cmd2str(cmd_id)) + strlen(assert_reason_to_str(reason)) +
+		   strlen("[CMD] ") + strlen(", [REASON] ")) < ASSERT_INFO_BUF_SIZE)
+			idx += sprintf(buf+idx, "[CMD] %s, [REASON] %s", cmd2str(cmd_id), assert_reason_to_str(reason));
+		else
+			idx += sprintf(buf+idx, "[CMD ID] %d, [REASON ID] %d", cmd_id, reason);
+
+		buf[idx] = '\0';
+
+		mdbg_assert_interface(buf);
+		sprdwl_net_flowcontrl(priv, SPRDWL_MODE_NONE, false);
+		intf->exit = 1;
+
+		return 1;
+	} else {
+		return -1;
+	}
+
+#undef ASSERT_INFO_BUF_SIZE
+}
+
+/* msg is released in this function or the realy driver
+ * rbuf: the msg after sprdwl_cmd_hdr
+ * rlen: input the length of rbuf
+ *       output the length of the msg,if *rlen == 0, rbuf get nothing
+ */
+int sprdwl_cmd_send_recv(struct sprdwl_priv *priv,
+			 struct sprdwl_msg_buf *msg,
+			 unsigned int timeout, u8 *rbuf, u16 *rlen)
+{
+	u8 cmd_id;
+	u16 plen;
+	int ret = 0;
+	struct sprdwl_cmd *cmd = &g_sprdwl_cmd;
+	struct sprdwl_cmd_hdr *hdr;
+	u8 ctx_id;
+	struct sprdwl_vif *vif;
+	struct sprdwl_intf *intf;
+	struct sprdwl_tx_msg *tx_msg;
+	intf = (struct sprdwl_intf *)(priv->hw_priv);
+	tx_msg = (struct sprdwl_tx_msg *)intf->sprdwl_tx;
+
+	ret = sprdwl_api_available_check(priv, msg);
+	if (ret || sprdwl_cmd_lock(cmd)) {
+		sprdwl_intf_free_msg_buf(priv, msg);
+		kfree(msg->tran_data);
+		if (rlen)
+			*rlen = 0;
+		if (ret)
+			wl_err("API check fail, return!!\n");
+		goto out;
+	}
+
+	hdr = (struct sprdwl_cmd_hdr *)(msg->tran_data + priv->hw_offset);
+	cmd_id = hdr->cmd_id;
+	ctx_id = hdr->common.ctx_id;
+
+	reinit_completion(&cmd->completed);
+	ret = sprdwl_cmd_send_to_ic(priv, msg);
+	if (ret) {
+		sprdwl_cmd_unlock(cmd);
+		wl_err("%s ctx_id = %d, cmd: %s[%d] send failed, ret = %d\n",
+				__func__, ctx_id, cmd2str(cmd_id), cmd_id, ret);
+		return -1;
+	}
+
+	ret = sprdwl_timeout_recv_rsp(priv, timeout);
+	if (ret != -1) {
+		if (rbuf && rlen && *rlen) {
+			hdr = (struct sprdwl_cmd_hdr *)cmd->data;
+			plen = le16_to_cpu(hdr->plen) - sizeof(*hdr);
+			*rlen = min(*rlen, plen);
+			memcpy(rbuf, hdr->paydata, *rlen);
+			wl_warn("ctx_id:%d cmd_id:%d [%s]rsp received, num=%d\n",
+				hdr->common.ctx_id, cmd_id, cmd2str(cmd_id),
+				tx_msg->cmd_send);
+			if (cmd_id == WIFI_CMD_OPEN)
+				rbuf[0] = hdr->common.ctx_id;
+		} else {
+			hdr = (struct sprdwl_cmd_hdr *)cmd->data;
+			wl_info("ctx_id:%d cmd_id:%d [%s]rsp received, num=%d\n",
+				hdr->common.ctx_id, cmd_id, cmd2str(cmd_id),
+				tx_msg->cmd_send);
+		}
+	} else {
+		wl_err("ctx_id:%d cmd: %s[%d] rsp timeout (mstime = %d), num=%d\n",
+		       ctx_id, cmd2str(cmd_id), cmd_id, le32_to_cpu(hdr->mstime),
+		       tx_msg->cmd_send);
+		if (cmd_id == WIFI_CMD_CLOSE) {
+			sprdwl_atcmd_assert(priv, ctx_id, cmd_id, CMD_RSP_TIMEOUT_ERROR);
+			sprdwl_cmd_unlock(cmd);
+			return ret;
+		}
+		vif = ctx_id_to_vif(priv, ctx_id);
+		if (vif != NULL) {
+			intf = (struct sprdwl_intf *)(vif->priv->hw_priv);
+			tx_msg = (struct sprdwl_tx_msg *)intf->sprdwl_tx;
+			if (intf->cp_asserted == 0 &&
+				tx_msg->hang_recovery_status == HANG_RECOVERY_END)
+				sprdwl_send_assert_cmd(vif, cmd_id, CMD_RSP_TIMEOUT_ERROR);
+			sprdwl_put_vif(vif);
+		}
+	}
+	sprdwl_cmd_unlock(cmd);
+out:
+	return ret;
+}
+
+/* msg is released in this function or the realy driver
+ * rbuf: the msg after sprdwl_cmd_hdr
+ * rlen: input the length of rbuf
+ *       output the length of the msg,if *rlen == 0, rbuf get nothing
+ */
+int sprdwl_cmd_send_recv_no_wait(struct sprdwl_priv *priv,
+			 struct sprdwl_msg_buf *msg)
+{
+	u8 cmd_id;
+	int ret = 0;
+	struct sprdwl_cmd *cmd = &g_sprdwl_cmd;
+	struct sprdwl_cmd_hdr *hdr;
+	u8 ctx_id;
+
+	if (sprdwl_cmd_lock(cmd)) {
+		wl_err("%s, %d, error!\n", __func__, __LINE__);
+		sprdwl_intf_free_msg_buf(priv, msg);
+		kfree(msg->tran_data);
+		goto out;
+	}
+
+	hdr = (struct sprdwl_cmd_hdr *)(msg->tran_data + priv->hw_offset);
+	cmd_id = hdr->cmd_id;
+	ctx_id = hdr->common.ctx_id;
+
+	ret = sprdwl_cmd_send_to_ic(priv, msg);
+	if (ret) {
+		sprdwl_cmd_unlock(cmd);
+		return -1;
+	}
+	sprdwl_cmd_unlock(cmd);
+out:
+	return ret;
+}
+
+/*Commands to sync API version with firmware*/
+int sprdwl_sync_version(struct sprdwl_priv *priv)
+{
+	struct sprdwl_msg_buf *msg;
+	struct sprdwl_cmd_api_t *drv_api = NULL;
+	struct sprdwl_cmd_api_t *fw_api = NULL;
+	u16 r_len = sizeof(*fw_api);
+	u8 r_buf[r_len];
+	int ret = 0;
+
+	msg = sprdwl_cmd_getbuf(priv, sizeof(struct sprdwl_cmd_api_t),
+			SPRDWL_MODE_NONE, SPRDWL_HEAD_RSP,
+			WIFI_CMD_SYNC_VERSION);
+	if (!msg)
+		return -ENOMEM;
+	drv_api = (struct sprdwl_cmd_api_t *)msg->data;
+	/*fill drv api version got from local*/
+	sprdwl_fill_drv_api_version(priv, drv_api);
+
+	ret = sprdwl_cmd_send_recv(priv, msg, CMD_WAIT_TIMEOUT, r_buf, &r_len);
+	if (!ret && r_len) {
+		fw_api = (struct sprdwl_cmd_api_t *)r_buf;
+		/*fill fw api version to priv got from firmware*/
+		sprdwl_fill_fw_api_version(priv, fw_api);
+	}
+	return ret;
+}
+
+/* Commands */
+static int sprdwl_down_ini_cmd(struct sprdwl_priv *priv,
+						uint8_t *data, uint32_t len,
+						uint8_t sec_num)
+{
+	int ret = 0;
+	struct sprdwl_msg_buf *msg;
+	uint8_t *p = NULL;
+	uint16_t CRC = 0;
+
+	/*reserved 4 byte of section num for align */
+	msg = sprdwl_cmd_getbuf(priv, len + 4 + sizeof(CRC),
+			SPRDWL_MODE_NONE, SPRDWL_HEAD_RSP,
+			WIFI_CMD_DOWNLOAD_INI);
+	if (!msg)
+		return -ENOMEM;
+
+	/*calc CRC value*/
+	CRC = CRC16(data, len);
+	wl_info("CRC value:%d\n", CRC);
+
+	p = msg->data;
+	*p = sec_num;
+
+	/*copy data after section num*/
+	memcpy((p + 4), data, len);
+	/*put CRC value at the tail of INI data*/
+	memcpy((p + 4 + len), &CRC, sizeof(CRC));
+
+	ret = sprdwl_cmd_send_recv(priv, msg, CMD_WAIT_TIMEOUT, NULL, NULL);
+	return ret;
+}
+
+void sprdwl_download_ini(struct sprdwl_priv *priv)
+{
+#define SEC1	1
+#define SEC2	2
+#define SEC3	3
+
+	int ret;
+	struct wifi_conf_t *wifi_data;
+	struct wifi_conf_sec1_t *sec1;
+	struct wifi_conf_sec2_t *sec2;
+
+	wl_debug("%s enter:", __func__);
+	/*if ini file has been download already, return*/
+	if (sprdwl_get_ini_status(priv)) {
+		wl_err("RF ini download already, skip!\n");
+		return;
+	}
+
+	wifi_data = kzalloc(sizeof(struct wifi_conf_t), GFP_KERNEL);
+	/*init INI data struct */
+	/*got ini data from file*/
+	ret = get_wifi_config_param(wifi_data);
+	if (ret) {
+		wl_err("load ini data failed, return\n");
+		kfree(wifi_data);
+		wlan_set_assert(priv, SPRDWL_MODE_NONE,
+				WIFI_CMD_DOWNLOAD_INI,
+				LOAD_INI_DATA_FAILED);
+		return;
+	}
+
+	wl_info("total config len:%ld,sec1 len:%ld, sec2 len:%ld\n",
+		(long unsigned int)sizeof(wifi_data), (long unsigned int)sizeof(*sec1),
+		(long unsigned int)sizeof(*sec2));
+	/*devide wifi_conf into sec1 and sec2 since it's too large*/
+	sec1 = (struct wifi_conf_sec1_t *)wifi_data;
+	sec2 = (struct wifi_conf_sec2_t *)(&wifi_data->tx_scale);
+
+	wl_info("download the first section of config file\n");
+	ret = sprdwl_down_ini_cmd(priv, (uint8_t *)sec1, sizeof(*sec1), SEC1);
+	if (ret) {
+		wl_err("download the first section of ini fail,return\n");
+		kfree(wifi_data);
+		wlan_set_assert(priv, SPRDWL_MODE_NONE,
+				WIFI_CMD_DOWNLOAD_INI,
+				DOWNLOAD_INI_DATA_FAILED);
+		return;
+	}
+
+	wl_info("download the second section of config file\n");
+	ret = sprdwl_down_ini_cmd(priv, (uint8_t *)sec2, sizeof(*sec2), SEC2);
+	if (ret) {
+		wl_err("download the second section of ini fail,return\n");
+		kfree(wifi_data);
+		wlan_set_assert(priv, SPRDWL_MODE_NONE,
+				WIFI_CMD_DOWNLOAD_INI,
+				DOWNLOAD_INI_DATA_FAILED);
+		return;
+	}
+
+	if (wifi_data->rf_config.rf_data_len) {
+		wl_info("download the third section of config file\n");
+		wl_info("rf_data_len = %d\n", wifi_data->rf_config.rf_data_len);
+		ret = sprdwl_down_ini_cmd(priv, wifi_data->rf_config.rf_data,
+				wifi_data->rf_config.rf_data_len, SEC3);
+		if (ret) {
+			wl_err("download the third section of ini fail,return\n");
+			kfree(wifi_data);
+			wlan_set_assert(priv, SPRDWL_MODE_NONE,
+					WIFI_CMD_DOWNLOAD_INI,
+					DOWNLOAD_INI_DATA_FAILED);
+			return;
+		}
+	}
+
+	kfree(wifi_data);
+}
+
+int sprdwl_get_fw_info(struct sprdwl_priv *priv)
+{
+	int ret;
+	struct sprdwl_msg_buf *msg;
+	struct sprdwl_cmd_fw_info *p;
+	struct sprdwl_tlv_data *tlv;
+	u16 r_len = sizeof(*p) + GET_INFO_TLV_RBUF_SIZE;
+	u16 r_len_ori = r_len;
+	u8 r_buf[r_len];
+	u8 compat_ver = 0;
+	unsigned int len_count = 0;
+	bool b_tlv_data_chk = true;
+	u16 tlv_len = sizeof(struct ap_version_tlv_elmt);
+#ifdef WL_CONFIG_DEBUG
+	u8 ap_version = NOTIFY_AP_VERSION_USER_DEBUG;
+#else
+	u8 ap_version = NOTIFY_AP_VERSION_USER;
+#endif
+
+#ifdef OTT_UWE
+#define OTT_UWE_OFFSET_ENABLE 1
+	tlv_len += 1;
+#endif
+
+	memset(r_buf, 0, r_len);
+	msg = sprdwl_cmd_getbuf(priv, tlv_len, SPRDWL_MODE_NONE,
+				SPRDWL_HEAD_RSP, WIFI_CMD_GET_INFO);
+	if (!msg)
+		return -ENOMEM;
+
+	compat_ver = need_compat_operation(priv, WIFI_CMD_GET_INFO);
+	if (compat_ver) {
+		switch (compat_ver) {
+		case VERSION_1:
+			/*add data struct modification in here!*/
+			priv->sync_api.compat = VERSION_1;
+			break;
+		case VERSION_2:
+			/*add data struct modification in here!*/
+			priv->sync_api.compat = VERSION_2;
+			break;
+		case VERSION_3:
+			/*add data struct modification in here!*/
+			priv->sync_api.compat = VERSION_3;
+			break;
+		default:
+			break;
+		}
+	}
+
+	sprdwl_set_tlv_elmt((u8 *)msg->data, NOTIFY_AP_VERSION,
+				sizeof(ap_version), &ap_version);
+
+#ifdef OTT_UWE
+	tlv = (struct sprdwl_tlv_data *)msg->data;
+	tlv->type = OTT_UWE_OFFSET_ENABLE;
+	tlv->len = 1;
+	*((char *)tlv->data) = 1;
+#endif
+	ret = sprdwl_cmd_send_recv(priv, msg, CMD_WAIT_TIMEOUT, r_buf, &r_len);
+	if (!ret && r_len) {
+#if defined COMPAT_SAMPILE_CODE
+		switch (compat_ver) {
+		case VERSION_1:
+			/*add data struct modification in here!*/
+			break;
+		case VERSION_2:
+			/*add data struct modification in here!*/
+			break;
+		case VERSION_3:
+			/*add data struct modification in here!*/
+			break;
+		default:
+			break;
+		}
+#endif
+		/* Version 1 Section */
+		p = (struct sprdwl_cmd_fw_info *)r_buf;
+		priv->chip_model = p->chip_model;
+		priv->chip_ver = p->chip_version;
+		priv->fw_ver = p->fw_version;
+		priv->fw_capa = p->fw_capa;
+		priv->fw_std = p->fw_std;
+		priv->max_ap_assoc_sta = p->max_ap_assoc_sta;
+		priv->max_acl_mac_addrs = p->max_acl_mac_addrs;
+		priv->max_mc_mac_addrs = p->max_mc_mac_addrs;
+		priv->wnm_ft_support = p->wnm_ft_support;
+		len_count += SEC1_LEN;
+		/*check sec2 data length got from fw*/
+		if ((r_len - len_count) >= sizeof(struct wiphy_sec2_t)) {
+			priv->wiphy_sec2_flag = 1;
+			wl_info("save wiphy section2 info to sprdwl_priv\n");
+			memcpy(&priv->wiphy_sec2, &p->wiphy_sec2,
+					sizeof(struct wiphy_sec2_t));
+		} else {
+			goto out;
+		}
+		len_count += sizeof(struct wiphy_sec2_t);
+
+		if ((r_len - len_count) >= ETH_ALEN) {
+			ether_addr_copy(priv->mac_addr, p->mac_addr);
+		} else {
+			memset(priv->mac_addr, 0x00, ETH_ALEN);
+			goto out;
+		}
+		len_count += ETH_ALEN;
+
+		if ((r_len - len_count) >= 1)
+			priv->credit_capa = p->credit_capa;
+		else
+			priv->credit_capa = TX_WITH_CREDIT;
+
+		/* Version 2 Section */
+		if (compat_ver == VERSION_1) {
+			/* Set default value for non-version-1 variable */
+			priv->ott_supt = OTT_NO_SUPT;
+		} else {
+			len_count = sizeof(struct sprdwl_cmd_fw_info);
+			tlv = (struct sprdwl_tlv_data *)((u8 *)r_buf + len_count);
+			while ((len_count + sizeof(struct sprdwl_tlv_data) + tlv->len) <= r_len) {
+				b_tlv_data_chk = false;
+				switch (tlv->type) {
+				case GET_INFO_TLV_TP_OTT:
+					if (tlv->len == 1) {
+						priv->ott_supt = *((unsigned char *)(tlv->data));
+						b_tlv_data_chk = true;
+					}
+					break;
+				default:
+					break;
+				}
+
+				wl_info("%s, TLV type=%d, len=%d, data_chk=%d\n",
+					__func__, tlv->type, tlv->len, b_tlv_data_chk);
+
+				if (b_tlv_data_chk == false) {
+					wl_err("%s TLV check failed: type=%d, len=%d\n",
+					       __func__, tlv->type, tlv->len);
+					goto out;
+				}
+
+				len_count += (sizeof(struct sprdwl_tlv_data) + tlv->len);
+				tlv = (struct sprdwl_tlv_data *)((u8 *)r_buf + len_count);
+			}
+
+			if (r_len_ori <= r_len) {
+				wl_warn("%s check tlv rbuf size: r_len_ori=%d, r_len=%d\n",
+					__func__, r_len_ori, r_len);
+			}
+
+			if (len_count != r_len) {
+				wl_err("%s length mismatch: len_count=%d, r_len=%d\n",
+				       __func__, len_count, r_len);
+				goto out;
+			}
+		}
+
+out:
+		wl_err("%s, drv_version=%d, fw_version=%d, compat_ver=%d\n", __func__,
+			(&priv->sync_api)->api_array[WIFI_CMD_GET_INFO].drv_version,
+			(&priv->sync_api)->api_array[WIFI_CMD_GET_INFO].fw_version,
+			compat_ver);
+		wl_err("chip_model:0x%x, chip_ver:0x%x\n",
+			priv->chip_model, priv->chip_ver);
+		wl_err("fw_ver:%d, fw_std:0x%x, fw_capa:0x%x\n",
+			priv->fw_ver, priv->fw_std, priv->fw_capa);
+		if (is_valid_ether_addr(priv->mac_addr))
+			wl_err("mac_addr:%02x:%02x:%02x:%02x:%02x:%02x\n",
+				priv->mac_addr[0], priv->mac_addr[1], priv->mac_addr[2],
+				priv->mac_addr[3], priv->mac_addr[4], priv->mac_addr[5]);
+		wl_err("credit_capa:%s\n",
+			(priv->credit_capa == TX_WITH_CREDIT) ?
+			"TX_WITH_CREDIT" : "TX_NO_CREDIT");
+		wl_err("ott support:%d\n", priv->ott_supt);
+	}
+
+	return ret;
+}
+
+int sprdwl_set_regdom(struct sprdwl_priv *priv, u8 *regdom, u32 len)
+{
+	struct sprdwl_msg_buf *msg;
+	struct sprdwl_ieee80211_regdomain *p;
+#ifdef COMPAT_SAMPILE_CODE
+	u8 compat_ver = 0;
+#endif
+
+	msg = sprdwl_cmd_getbuf(priv, len, SPRDWL_MODE_NONE, SPRDWL_HEAD_RSP,
+				WIFI_CMD_SET_REGDOM);
+	if (!msg)
+		return -ENOMEM;
+#ifdef COMPAT_SAMPILE_CODE
+	compat_ver = need_compat_operation(priv, WIFI_CMD_SET_REGDOM);
+	if (compat_ver) {
+		switch (compat_ver) {
+		case VERSION_1:
+		/*add data struct modification in here!*/
+			priv->sync_api.compat = VERSION_1;
+			break;
+		case VERSION_2:
+		/*add data struct modification in here!*/
+			priv->sync_api.compat = VERSION_2;
+			break;
+		case VERSION_3:
+			/*add data struct modification in here!*/
+			priv->sync_api.compat = VERSION_3;
+			break;
+		default:
+			break;
+		}
+	}
+#endif
+	p = (struct sprdwl_ieee80211_regdomain *)msg->data;
+	memcpy(p, regdom, len);
+
+	return sprdwl_cmd_send_recv(priv, msg, CMD_WAIT_TIMEOUT, NULL, NULL);
+}
+
+int sprdwl_open_fw(struct sprdwl_priv *priv, u8 *vif_ctx_id,
+		   u8 mode, u8 *mac_addr)
+{
+	struct sprdwl_msg_buf *msg;
+	struct sprdwl_cmd_open *p;
+	u16 rlen = 1;
+
+	msg = sprdwl_cmd_getbuf(priv, sizeof(*p), *vif_ctx_id,
+				SPRDWL_HEAD_RSP, WIFI_CMD_OPEN);
+	if (!msg)
+		return -ENOMEM;
+	p = (struct sprdwl_cmd_open *)msg->data;
+	p->mode = mode;
+	if (mac_addr)
+		memcpy(&p->mac[0], mac_addr, sizeof(p->mac));
+	else
+		wl_err("%s, %d, mac_addr error!\n", __func__, __LINE__);
+
+	p->reserved = 0;
+	if (0 != wfa_cap) {
+		p->reserved = wfa_cap;
+		wfa_cap = 0;
+	}
+
+	return sprdwl_cmd_send_recv(priv, msg, CMD_WAIT_TIMEOUT,
+				    vif_ctx_id, &rlen);
+}
+
+int sprdwl_close_fw(struct sprdwl_priv *priv, u8 vif_ctx_id, u8 mode)
+{
+	struct sprdwl_msg_buf *msg;
+	struct sprdwl_cmd_close *p;
+
+	msg = sprdwl_cmd_getbuf(priv, sizeof(*p), vif_ctx_id,
+				SPRDWL_HEAD_RSP, WIFI_CMD_CLOSE);
+	if (!msg)
+		return -ENOMEM;
+	p = (struct sprdwl_cmd_close *)msg->data;
+	p->mode = mode;
+
+	sprdwl_cmd_send_recv(priv, msg, CMD_WAIT_TIMEOUT, NULL, NULL);
+	/* FIXME - in case of close failure */
+	return 0;
+}
+
+int sprdwl_power_save(struct sprdwl_priv *priv, u8 vif_ctx_id,
+		       u8 sub_type, u8 status)
+{
+	int ret;
+	s32 ret_code;
+	u16 len = 0;
+	struct sprdwl_msg_buf *msg;
+	struct sprdwl_cmd_power_save *p;
+
+	msg = sprdwl_cmd_getbuf(priv, sizeof(*p), vif_ctx_id,
+				SPRDWL_HEAD_RSP, WIFI_CMD_POWER_SAVE);
+	if (!msg)
+		return -ENOMEM;
+
+	p = (struct sprdwl_cmd_power_save *)msg->data;
+	p->sub_type = sub_type;
+	p->value = status;
+	ret = sprdwl_cmd_send_recv(priv, msg, CMD_WAIT_TIMEOUT, (u8 *)&ret_code, &len);
+
+	return len == 4 ? ret_code : ret;
+}
+
+int sprdwl_add_key(struct sprdwl_priv *priv, u8 vif_ctx_id, const u8 *key_data,
+		   u8 key_len, u8 pairwise, u8 key_index, const u8 *key_seq,
+		   u8 cypher_type, const u8 *mac_addr)
+{
+	struct sprdwl_msg_buf *msg;
+	struct sprdwl_cmd_add_key *p;
+	u8 *sub_cmd;
+	int datalen = sizeof(*p) + sizeof(*sub_cmd) + key_len;
+
+	msg = sprdwl_cmd_getbuf(priv, datalen, vif_ctx_id,
+				SPRDWL_HEAD_RSP, WIFI_CMD_KEY);
+	if (!msg)
+		return -ENOMEM;
+
+	sub_cmd = (u8 *)msg->data;
+	*sub_cmd = SPRDWL_SUBCMD_ADD;
+	p = (struct sprdwl_cmd_add_key *)(++sub_cmd);
+
+	p->key_index = key_index;
+	p->pairwise = pairwise;
+	p->cypher_type = cypher_type;
+	p->key_len = key_len;
+	if (key_seq) {
+		if (SPRDWL_CIPHER_WAPI == cypher_type)
+			memcpy(p->keyseq, key_seq, WAPI_PN_SIZE);
+		else
+			memcpy(p->keyseq, key_seq, 8);
+	}
+	if (mac_addr)
+		ether_addr_copy(p->mac, mac_addr);
+	if (key_data)
+		memcpy(p->value, key_data, key_len);
+
+	if (mac_addr)
+		reset_pn(priv, mac_addr);
+
+	return sprdwl_cmd_send_recv(priv, msg, CMD_WAIT_TIMEOUT, NULL, NULL);
+}
+
+int sprdwl_del_key(struct sprdwl_priv *priv, u8 vif_ctx_id, u16 key_index,
+		    bool pairwise, const u8 *mac_addr)
+{
+	struct sprdwl_msg_buf *msg;
+	struct sprdwl_cmd_del_key *p;
+	u8 *sub_cmd;
+
+	msg = sprdwl_cmd_getbuf(priv, sizeof(*p) + sizeof(*sub_cmd), vif_ctx_id,
+				SPRDWL_HEAD_RSP, WIFI_CMD_KEY);
+	if (!msg)
+		return -ENOMEM;
+
+	sub_cmd = (u8 *)msg->data;
+	*sub_cmd = SPRDWL_SUBCMD_DEL;
+	p = (struct sprdwl_cmd_del_key *)(++sub_cmd);
+
+	p->key_index = key_index;
+	p->pairwise = pairwise;
+	if (mac_addr)
+		ether_addr_copy(p->mac, mac_addr);
+
+	return sprdwl_cmd_send_recv(priv, msg, CMD_WAIT_TIMEOUT, NULL, NULL);
+}
+
+int sprdwl_set_def_key(struct sprdwl_priv *priv, u8 vif_ctx_id, u8 key_index)
+{
+	struct sprdwl_msg_buf *msg;
+	struct sprdwl_cmd_set_def_key *p;
+	u8 *sub_cmd;
+
+	msg = sprdwl_cmd_getbuf(priv, sizeof(*p) + sizeof(*sub_cmd), vif_ctx_id,
+				SPRDWL_HEAD_RSP, WIFI_CMD_KEY);
+	if (!msg)
+		return -ENOMEM;
+
+	sub_cmd = (u8 *)msg->data;
+	*sub_cmd = SPRDWL_SUBCMD_SET;
+	p = (struct sprdwl_cmd_set_def_key *)(++sub_cmd);
+
+	p->key_index = key_index;
+
+	return sprdwl_cmd_send_recv(priv, msg, CMD_WAIT_TIMEOUT, NULL, NULL);
+}
+
+int sprdwl_set_rekey_data(struct sprdwl_priv *priv, u8 vif_ctx_id,
+		struct cfg80211_gtk_rekey_data *data)
+{
+	struct sprdwl_msg_buf *msg;
+	struct sprdwl_cmd_set_rekey *p;
+	u8 *sub_cmd;
+
+	msg = sprdwl_cmd_getbuf(priv, sizeof(*p) + sizeof(*sub_cmd), vif_ctx_id,
+				SPRDWL_HEAD_RSP, WIFI_CMD_KEY);
+	if (!msg)
+		return -ENOMEM;
+	sub_cmd = (u8 *)msg->data;
+	*sub_cmd = SPRDWL_SUBCMD_REKEY;
+	 p = (struct sprdwl_cmd_set_rekey *)(++sub_cmd);
+	 memcpy(p->kek, data->kek, NL80211_KEK_LEN);
+	 memcpy(p->kck, data->kck, NL80211_KCK_LEN);
+	 memcpy(p->replay_ctr, data->replay_ctr, NL80211_REPLAY_CTR_LEN);
+	 return sprdwl_cmd_send_recv(priv, msg, CMD_WAIT_TIMEOUT, NULL, NULL);
+}
+
+int sprdwl_set_ie(struct sprdwl_priv *priv, u8 vif_ctx_id, u8 type,
+		  const u8 *ie, u16 len)
+{
+	struct sprdwl_msg_buf *msg;
+	struct sprdwl_cmd_set_ie *p;
+
+	msg = sprdwl_cmd_getbuf(priv, sizeof(*p) + len, vif_ctx_id,
+				SPRDWL_HEAD_RSP, WIFI_CMD_SET_IE);
+	if (!msg)
+		return -ENOMEM;
+
+	p = (struct sprdwl_cmd_set_ie *)msg->data;
+	p->type = type;
+	p->len = len;
+	memcpy(p->data, ie, len);
+
+	return sprdwl_cmd_send_recv(priv, msg, CMD_WAIT_TIMEOUT, NULL, NULL);
+}
+
+#ifdef DFS_MASTER
+int sprdwl_reset_beacon(struct sprdwl_priv *priv,
+		     u8 vif_ctx_id, const u8 *beacon, u16 len)
+{
+	struct sprdwl_msg_buf *msg;
+
+	msg = sprdwl_cmd_getbuf(priv, len, vif_ctx_id, SPRDWL_HEAD_RSP,
+				WIFI_CMD_RESET_BEACON);
+	if (!msg)
+		return -ENOMEM;
+
+	memcpy(msg->data, beacon, len);
+
+	return sprdwl_cmd_send_recv(priv, msg, CMD_WAIT_TIMEOUT, NULL, NULL);
+}
+#endif
+
+int sprdwl_start_ap(struct sprdwl_priv *priv,
+		     u8 vif_ctx_id, u8 *beacon, u16 len)
+{
+	struct sprdwl_msg_buf *msg;
+	struct sprdwl_cmd_start_ap *p;
+	u16 datalen = sizeof(*p) + len;
+
+	msg = sprdwl_cmd_getbuf(priv, datalen, vif_ctx_id, SPRDWL_HEAD_RSP,
+				WIFI_CMD_START_AP);
+	if (!msg)
+		return -ENOMEM;
+
+	p = (struct sprdwl_cmd_start_ap *)msg->data;
+	p->len = cpu_to_le16(len);
+	memcpy(p->value, beacon, len);
+
+	return sprdwl_cmd_send_recv(priv, msg, CMD_WAIT_TIMEOUT, NULL, NULL);
+}
+
+int sprdwl_del_station(struct sprdwl_priv *priv, u8 vif_ctx_id,
+		       const u8 *mac_addr, u16 reason_code)
+{
+	struct sprdwl_msg_buf *msg;
+	struct sprdwl_cmd_del_station *p;
+
+	msg = sprdwl_cmd_getbuf(priv, sizeof(*p), vif_ctx_id, SPRDWL_HEAD_RSP,
+				WIFI_CMD_DEL_STATION);
+	if (!msg)
+		return -ENOMEM;
+
+	p = (struct sprdwl_cmd_del_station *)msg->data;
+	if (mac_addr)
+		memcpy(&p->mac[0], mac_addr, sizeof(p->mac));
+	p->reason_code = cpu_to_le16(reason_code);
+
+	return sprdwl_cmd_send_recv(priv, msg, CMD_WAIT_TIMEOUT, NULL, NULL);
+}
+
+int sprdwl_get_station(struct sprdwl_priv *priv, u8 vif_ctx_id,
+			struct sprdwl_cmd_get_station *sta)
+{
+	struct sprdwl_msg_buf *msg;
+	u8 *r_buf = (u8 *)sta;
+	u16 r_len = sizeof(struct sprdwl_cmd_get_station);
+	int ret;
+
+	msg = sprdwl_cmd_getbuf(priv, 0, vif_ctx_id, SPRDWL_HEAD_RSP,
+				WIFI_CMD_GET_STATION);
+	if (!msg)
+		return -ENOMEM;
+	ret = sprdwl_cmd_send_recv(priv, msg, CMD_WAIT_TIMEOUT, r_buf, &r_len);
+
+	return ret;
+}
+
+int sprdwl_set_channel(struct sprdwl_priv *priv, u8 vif_ctx_id, u8 channel)
+{
+	struct sprdwl_msg_buf *msg;
+	struct sprdwl_cmd_set_channel *p;
+
+	msg = sprdwl_cmd_getbuf(priv, sizeof(*p), vif_ctx_id,
+				SPRDWL_HEAD_RSP, WIFI_CMD_SET_CHANNEL);
+	if (!msg)
+		return -ENOMEM;
+	p = (struct sprdwl_cmd_set_channel *)msg->data;
+	p->channel = channel;
+
+	return sprdwl_cmd_send_recv(priv, msg, CMD_WAIT_TIMEOUT, NULL, NULL);
+}
+
+int sprdwl_scan(struct sprdwl_priv *priv, u8 vif_ctx_id,
+		u32 channels, int ssid_len, const u8 *ssid_list,
+		u16 chn_count_5g, const u16 *chns_5g)
+{
+	struct sprdwl_msg_buf *msg;
+	struct sprdwl_cmd_scan *p;
+	struct sprdwl_cmd_rsp_state_code state;
+	u16 rlen;
+	u32 data_len, chns_len_5g;
+
+	struct sprdwl_5g_chn {
+		u16 n_5g_chn;
+		u16 chns[0];
+	} *ext_5g;
+
+	chns_len_5g = chn_count_5g * sizeof(*chns_5g);
+	data_len = sizeof(*p) + ssid_len + chns_len_5g +
+		sizeof(ext_5g->n_5g_chn);
+	msg = sprdwl_cmd_getbuf(priv, data_len, vif_ctx_id,
+				SPRDWL_HEAD_RSP, WIFI_CMD_SCAN);
+	if (!msg)
+		return -ENOMEM;
+
+	p = (struct sprdwl_cmd_scan *)msg->data;
+	p->channels = channels;
+	if (ssid_len > 0) {
+		memcpy(p->ssid, ssid_list, ssid_len);
+		p->ssid_len = cpu_to_le16(ssid_len);
+	}
+
+	ext_5g = (struct sprdwl_5g_chn *)(p->ssid + ssid_len);
+	if (chn_count_5g > 0) {
+		ext_5g->n_5g_chn = chn_count_5g;
+		memcpy(ext_5g->chns, chns_5g, chns_len_5g);
+	} else {
+		ext_5g->n_5g_chn = 0;
+	}
+
+	wl_hex_dump(L_DBG, "scan hex:", DUMP_PREFIX_OFFSET,
+			     16, 1, p, data_len, true);
+
+	rlen = sizeof(state);
+
+	return	sprdwl_cmd_send_recv(priv, msg, CMD_SCAN_WAIT_TIMEOUT,
+			     (u8 *)&state, &rlen);
+}
+
+int sprdwl_sched_scan_start(struct sprdwl_priv *priv, u8 vif_ctx_id,
+			     struct sprdwl_sched_scan_buf *buf)
+{
+	struct sprdwl_msg_buf *msg;
+	struct sprdwl_cmd_sched_scan_hd *sscan_head = NULL;
+	struct sprdwl_cmd_sched_scan_ie_hd *ie_head = NULL;
+	struct sprdwl_cmd_sched_scan_ifrc *sscan_ifrc = NULL;
+	u16 datalen;
+	u8 *p = NULL;
+	int len = 0, i, hd_len;
+
+	datalen = sizeof(*sscan_head) + sizeof(*ie_head) + sizeof(*sscan_ifrc)
+	    + buf->n_ssids * IEEE80211_MAX_SSID_LEN
+	    + buf->n_match_ssids * IEEE80211_MAX_SSID_LEN + buf->ie_len;
+	hd_len = sizeof(*ie_head);
+	datalen = datalen + (buf->n_ssids ? hd_len : 0)
+	    + (buf->n_match_ssids ? hd_len : 0)
+	    + (buf->ie_len ? hd_len : 0);
+
+	msg = sprdwl_cmd_getbuf(priv, datalen, vif_ctx_id,
+				SPRDWL_HEAD_RSP, WIFI_CMD_SCHED_SCAN);
+	if (!msg)
+		return -ENOMEM;
+
+	p = msg->data;
+
+	sscan_head = (struct sprdwl_cmd_sched_scan_hd *)(p + len);
+	sscan_head->started = 1;
+	sscan_head->buf_flags = SPRDWL_SCHED_SCAN_BUF_END;
+	len += sizeof(*sscan_head);
+
+	ie_head = (struct sprdwl_cmd_sched_scan_ie_hd *)(p + len);
+	ie_head->ie_flag = SPRDWL_SEND_FLAG_IFRC;
+	ie_head->ie_len = sizeof(*sscan_ifrc);
+	len += sizeof(*ie_head);
+
+	sscan_ifrc = (struct sprdwl_cmd_sched_scan_ifrc *)(p + len);
+
+	sscan_ifrc->interval = buf->interval;
+	sscan_ifrc->flags = buf->flags;
+	sscan_ifrc->rssi_thold = buf->rssi_thold;
+	memcpy(sscan_ifrc->chan, buf->channel, TOTAL_2G_5G_CHANNEL_NUM + 1);
+
+	len += ie_head->ie_len;
+
+	if (buf->n_ssids > 0) {
+		ie_head = (struct sprdwl_cmd_sched_scan_ie_hd *)(p + len);
+		ie_head->ie_flag = SPRDWL_SEND_FLAG_SSID;
+		ie_head->ie_len = buf->n_ssids * IEEE80211_MAX_SSID_LEN;
+		len += sizeof(*ie_head);
+		for (i = 0; i < buf->n_ssids; i++) {
+			memcpy((p + len + i * IEEE80211_MAX_SSID_LEN),
+			       buf->ssid[i], IEEE80211_MAX_SSID_LEN);
+		}
+		len += ie_head->ie_len;
+	}
+
+	if (buf->n_match_ssids > 0) {
+		ie_head = (struct sprdwl_cmd_sched_scan_ie_hd *)(p + len);
+		ie_head->ie_flag = SPRDWL_SEND_FLAG_MSSID;
+		ie_head->ie_len = buf->n_match_ssids * IEEE80211_MAX_SSID_LEN;
+		len += sizeof(*ie_head);
+		for (i = 0; i < buf->n_match_ssids; i++) {
+			memcpy((p + len + i * IEEE80211_MAX_SSID_LEN),
+			       buf->mssid[i], IEEE80211_MAX_SSID_LEN);
+		}
+		len += ie_head->ie_len;
+	}
+
+	if (buf->ie_len > 0) {
+		ie_head = (struct sprdwl_cmd_sched_scan_ie_hd *)(p + len);
+		ie_head->ie_flag = SPRDWL_SEND_FLAG_IE;
+		ie_head->ie_len = buf->ie_len;
+		len += sizeof(*ie_head);
+
+		wl_info("%s: ie len is %zu, ie:%s\n",
+			__func__, buf->ie_len, buf->ie);
+		memcpy((p + len), buf->ie, buf->ie_len);
+		len += ie_head->ie_len;
+	}
+
+	return sprdwl_cmd_send_recv(priv, msg, CMD_WAIT_TIMEOUT, NULL, NULL);
+}
+
+int sprdwl_sched_scan_stop(struct sprdwl_priv *priv, u8 vif_ctx_id)
+{
+	struct sprdwl_msg_buf *msg;
+	struct sprdwl_cmd_sched_scan_hd *p;
+
+	msg = sprdwl_cmd_getbuf(priv, sizeof(*p), vif_ctx_id,
+				SPRDWL_HEAD_RSP, WIFI_CMD_SCHED_SCAN);
+	if (!msg)
+		return -ENOMEM;
+	p = (struct sprdwl_cmd_sched_scan_hd *)msg->data;
+	p->started = 0;
+	p->buf_flags = SPRDWL_SCHED_SCAN_BUF_END;
+
+	return sprdwl_cmd_send_recv(priv, msg, CMD_WAIT_TIMEOUT, NULL, NULL);
+}
+
+int sprdwl_connect(struct sprdwl_priv *priv, u8 vif_ctx_id,
+		    struct sprdwl_cmd_connect *p)
+{
+	struct sprdwl_msg_buf *msg;
+
+	msg = sprdwl_cmd_getbuf(priv, sizeof(*p), vif_ctx_id,
+				SPRDWL_HEAD_RSP, WIFI_CMD_CONNECT);
+	if (!msg)
+		return -ENOMEM;
+
+	memcpy(msg->data, p, sizeof(*p));
+
+	return sprdwl_cmd_send_recv(priv, msg, CMD_WAIT_TIMEOUT, NULL, NULL);
+}
+
+int sprdwl_disconnect(struct sprdwl_priv *priv, u8 vif_ctx_id, u16 reason_code)
+{
+	struct sprdwl_msg_buf *msg;
+	struct sprdwl_cmd_disconnect *p;
+
+	msg = sprdwl_cmd_getbuf(priv, sizeof(*p), vif_ctx_id, SPRDWL_HEAD_RSP,
+				WIFI_CMD_DISCONNECT);
+	if (!msg)
+		return -ENOMEM;
+	p = (struct sprdwl_cmd_disconnect *)msg->data;
+	p->reason_code = cpu_to_le16(reason_code);
+
+	return sprdwl_cmd_send_recv(priv, msg, CMD_DISCONNECT_TIMEOUT, NULL, NULL);
+}
+
+int sprdwl_set_param(struct sprdwl_priv *priv, u32 rts, u32 frag)
+{
+	struct sprdwl_msg_buf *msg;
+	struct sprdwl_cmd_set_param *p;
+
+	msg = sprdwl_cmd_getbuf(priv, sizeof(*p), SPRDWL_MODE_NONE,
+				SPRDWL_HEAD_RSP, WIFI_CMD_SET_PARAM);
+	if (!msg)
+		return -ENOMEM;
+
+	p = (struct sprdwl_cmd_set_param *)msg->data;
+	p->rts = cpu_to_le32(rts);
+	p->frag = cpu_to_le32(frag);
+
+	return sprdwl_cmd_send_recv(priv, msg, CMD_WAIT_TIMEOUT, NULL, NULL);
+}
+
+int sprdwl_pmksa(struct sprdwl_priv *priv, u8 vif_ctx_id,
+		  const u8 *bssid, const u8 *pmkid, u8 type)
+{
+	struct sprdwl_msg_buf *msg;
+	struct sprdwl_cmd_pmkid *p;
+	u8 *sub_cmd;
+
+	msg = sprdwl_cmd_getbuf(priv, sizeof(*p) + sizeof(*sub_cmd), vif_ctx_id,
+				SPRDWL_HEAD_RSP, WIFI_CMD_SET_PMKSA);
+	if (!msg)
+		return -ENOMEM;
+
+	sub_cmd = (u8 *)msg->data;
+	*sub_cmd = type;
+	p = (struct sprdwl_cmd_pmkid *)(++sub_cmd);
+
+	if (bssid)
+		memcpy(p->bssid, bssid, sizeof(p->bssid));
+	if (pmkid)
+		memcpy(p->pmkid, pmkid, sizeof(p->pmkid));
+
+	return sprdwl_cmd_send_recv(priv, msg, CMD_WAIT_TIMEOUT, NULL, NULL);
+}
+
+int sprdwl_set_qos_map(struct sprdwl_priv *priv, u8 vif_ctx_id, void *qos_map)
+{
+	struct sprdwl_msg_buf *msg;
+	struct sprdwl_cmd_qos_map *p;
+	int index;
+
+	if (!qos_map)
+		return 0;
+	msg =
+	    sprdwl_cmd_getbuf(priv, sizeof(*p), vif_ctx_id, 1,
+			      WIFI_CMD_SET_QOS_MAP);
+	if (!msg)
+		return -ENOMEM;
+
+	p = (struct sprdwl_cmd_qos_map *)msg->data;
+	memset((u8 *)p, 0, sizeof(*p));
+	memcpy((u8 *)p, qos_map, sizeof(*p));
+	memcpy(&g_11u_qos_map.qos_exceptions[0], &p->dscp_exception[0],
+		sizeof(struct sprdwl_cmd_dscp_exception) * QOS_MAP_MAX_DSCP_EXCEPTION);
+
+	for (index = 0; index < 8; index++) {
+		g_11u_qos_map.qos_ranges[index].low = p->up[index].low;
+		g_11u_qos_map.qos_ranges[index].high = p->up[index].high;
+		g_11u_qos_map.qos_ranges[index].up = index;
+	}
+
+	return sprdwl_cmd_send_recv(priv, msg, CMD_WAIT_TIMEOUT, NULL, NULL);
+}
+
+int sprdwl_gscan_subcmd(struct sprdwl_priv *priv, u8 vif_ctx_id,
+			void *data, u16 subcmd, u16 len, u8 *r_buf, u16 *r_len)
+{
+	struct sprdwl_msg_buf *msg;
+	struct sprd_cmd_gscan_header *p;
+
+	msg = sprdwl_cmd_getbuf(priv, sizeof(*p) + len,
+				vif_ctx_id, SPRDWL_HEAD_RSP, WIFI_CMD_GSCAN);
+
+	if (!msg)
+		return -ENOMEM;
+
+	p = (struct sprd_cmd_gscan_header *)msg->data;
+	p->subcmd = subcmd;
+
+	if (data != NULL) {
+		p->data_len = len;
+		memcpy(p->data, data, len);
+	} else{
+		p->data_len = 0;
+	}
+	return sprdwl_cmd_send_recv(priv, msg, CMD_WAIT_TIMEOUT, r_buf, r_len);
+
+}
+
+int sprdwl_set_gscan_config(struct sprdwl_priv *priv, u8 vif_ctx_id,
+			    void *data, u16 len, u8 *r_buf, u16 *r_len)
+{
+	struct sprdwl_msg_buf *msg;
+	struct sprd_cmd_gscan_header *p;
+
+	msg = sprdwl_cmd_getbuf(priv, sizeof(*p) + len,
+				vif_ctx_id, 1, WIFI_CMD_GSCAN);
+	if (!msg)
+		return -ENOMEM;
+
+	p = (struct sprd_cmd_gscan_header *)msg->data;
+	p->subcmd = SPRDWL_GSCAN_SUBCMD_SET_CONFIG;
+	p->data_len = len;
+	memcpy(p->data, data, len);
+	return sprdwl_cmd_send_recv(priv, msg, CMD_WAIT_TIMEOUT, r_buf, r_len);
+}
+
+int sprdwl_set_gscan_scan_config(struct sprdwl_priv *priv, u8 vif_ctx_id,
+				 void *data, u16 len, u8 *r_buf, u16 *r_len)
+{
+	struct sprdwl_msg_buf *msg;
+	struct sprd_cmd_gscan_header *p;
+
+	msg = sprdwl_cmd_getbuf(priv, sizeof(*p) + len,
+				vif_ctx_id, 1, WIFI_CMD_GSCAN);
+	if (!msg)
+		return -ENOMEM;
+
+	p = (struct sprd_cmd_gscan_header *)msg->data;
+	p->subcmd = SPRDWL_GSCAN_SUBCMD_SET_SCAN_CONFIG;
+	p->data_len = len;
+	memcpy(p->data, data, len);
+	return sprdwl_cmd_send_recv(priv, msg, CMD_WAIT_TIMEOUT, r_buf, r_len);
+}
+
+int sprdwl_enable_gscan(struct sprdwl_priv *priv, u8 vif_ctx_id, void *data,
+			u8 *r_buf, u16 *r_len)
+{
+	struct sprdwl_msg_buf *msg;
+	struct sprd_cmd_gscan_header *p;
+
+	msg = sprdwl_cmd_getbuf(priv, sizeof(*p) + sizeof(int),
+				vif_ctx_id, 1, WIFI_CMD_GSCAN);
+	if (!msg)
+		return -ENOMEM;
+
+	p = (struct sprd_cmd_gscan_header *)msg->data;
+	p->subcmd = SPRDWL_GSCAN_SUBCMD_ENABLE_GSCAN;
+	p->data_len = sizeof(int);
+	memcpy(p->data, data, p->data_len);
+	return sprdwl_cmd_send_recv(priv, msg, CMD_WAIT_TIMEOUT, r_buf, r_len);
+}
+
+int sprdwl_get_gscan_capabilities(struct sprdwl_priv *priv, u8 vif_ctx_id,
+				  u8 *r_buf, u16 *r_len)
+{
+	struct sprdwl_msg_buf *msg;
+	struct sprd_cmd_gscan_header *p;
+
+	msg = sprdwl_cmd_getbuf(priv, sizeof(*p), vif_ctx_id,
+				SPRDWL_HEAD_RSP, WIFI_CMD_GSCAN);
+	if (!msg)
+		return -ENOMEM;
+
+	p = (struct sprd_cmd_gscan_header *)msg->data;
+	p->subcmd = SPRDWL_GSCAN_SUBCMD_GET_CAPABILITIES;
+	p->data_len = 0;
+
+	return sprdwl_cmd_send_recv(priv, msg, CMD_WAIT_TIMEOUT, r_buf, r_len);
+}
+
+int sprdwl_get_gscan_channel_list(struct sprdwl_priv *priv, u8 vif_ctx_id,
+				  void *data, u8 *r_buf, u16 *r_len)
+{
+	struct sprdwl_msg_buf *msg;
+	int *band;
+	struct sprd_cmd_gscan_header *p;
+
+	msg = sprdwl_cmd_getbuf(priv, sizeof(*p)+sizeof(*band), vif_ctx_id,
+				SPRDWL_HEAD_RSP, WIFI_CMD_GSCAN);
+	if (!msg)
+		return -ENOMEM;
+
+
+	p = (struct sprd_cmd_gscan_header *)msg->data;
+	p->subcmd = SPRDWL_GSCAN_SUBCMD_GET_CHANNEL_LIST;
+	p->data_len = sizeof(*band);
+
+	band = (int *)(msg->data + sizeof(struct sprd_cmd_gscan_header));
+	*band = *((int *)data);
+
+	return sprdwl_cmd_send_recv(priv, msg, CMD_WAIT_TIMEOUT, r_buf, r_len);
+}
+
+int sprdwl_set_gscan_bssid_hotlist(struct sprdwl_priv *priv, u8 vif_ctx_id,
+			    void *data, u16 len, u8 *r_buf, u16 *r_len)
+{
+	struct sprdwl_msg_buf *msg;
+	struct sprd_cmd_gscan_header *p;
+
+	msg = sprdwl_cmd_getbuf(priv, sizeof(*p) + len,
+				vif_ctx_id, 1, WIFI_CMD_GSCAN);
+	if (!msg)
+		return -ENOMEM;
+
+	p = (struct sprd_cmd_gscan_header *)msg->data;
+	p->subcmd = SPRDWL_GSCAN_SUBCMD_SET_HOTLIST;
+	p->data_len = len;
+	memcpy(p->data, data, len);
+	return sprdwl_cmd_send_recv(priv, msg, CMD_WAIT_TIMEOUT, r_buf, r_len);
+}
+
+int sprdwl_set_gscan_bssid_blacklist(struct sprdwl_priv *priv, u8 vif_ctx_id,
+			    void *data, u16 len, u8 *r_buf, u16 *r_len)
+{
+	struct sprdwl_msg_buf *msg;
+	struct sprd_cmd_gscan_header *p;
+
+	msg = sprdwl_cmd_getbuf(priv, sizeof(*p) + len,
+				vif_ctx_id, 1, WIFI_CMD_GSCAN);
+	if (!msg)
+		return -ENOMEM;
+
+	p = (struct sprd_cmd_gscan_header *)msg->data;
+	p->subcmd = SPRDWL_WIFI_SUBCMD_SET_BSSID_BLACKLIST;
+	p->data_len = len;
+	memcpy(p->data, data, len);
+	return sprdwl_cmd_send_recv(priv, msg, CMD_WAIT_TIMEOUT, r_buf, r_len);
+}
+int sprdwl_add_tx_ts(struct sprdwl_priv *priv, u8 vif_ctx_id, u8 tsid,
+		     const u8 *peer, u8 user_prio, u16 admitted_time)
+{
+	struct sprdwl_msg_buf *msg;
+	struct sprdwl_cmd_tx_ts *p;
+#ifdef WMMAC_WFA_CERTIFICATION
+	edca_ac_t ac;
+#endif
+
+	msg = sprdwl_cmd_getbuf(priv, sizeof(*p), vif_ctx_id, 1,
+				WIFI_CMD_ADD_TX_TS);
+	if (!msg)
+		return -ENOMEM;
+
+	p = (struct sprdwl_cmd_tx_ts *)msg->data;
+	memset((u8 *)p, 0, sizeof(*p));
+
+	p->tsid = tsid;
+	ether_addr_copy(p->peer, peer);
+	p->user_prio = user_prio;
+	p->admitted_time = cpu_to_le16(admitted_time);
+
+#ifdef WMMAC_WFA_CERTIFICATION
+	ac = map_priority_to_edca_ac(p->user_prio);
+	update_wmmac_ts_info(p->tsid, p->user_prio, ac, true, p->admitted_time);
+	update_admitted_time(priv, p->tsid, p->admitted_time, true);
+#endif
+	return sprdwl_cmd_send_recv(priv, msg, CMD_WAIT_TIMEOUT, NULL, NULL);
+}
+
+int sprdwl_del_tx_ts(struct sprdwl_priv *priv, u8 vif_ctx_id, u8 tsid,
+		     const u8 *peer)
+{
+	struct sprdwl_msg_buf *msg;
+	struct sprdwl_cmd_tx_ts *p;
+
+	msg = sprdwl_cmd_getbuf(priv, sizeof(*p), vif_ctx_id, 1,
+				WIFI_CMD_DEL_TX_TS);
+	if (!msg)
+		return -ENOMEM;
+
+	p = (struct sprdwl_cmd_tx_ts *)msg->data;
+	memset((u8 *)p, 0, sizeof(*p));
+
+	p->tsid = tsid;
+	ether_addr_copy(p->peer, peer);
+
+#ifdef WMMAC_WFA_CERTIFICATION
+	update_admitted_time(priv, p->tsid, p->admitted_time, false);
+	remove_wmmac_ts_info(p->tsid);
+#endif
+	return sprdwl_cmd_send_recv(priv, msg, CMD_WAIT_TIMEOUT, NULL, NULL);
+}
+
+int sprdwl_remain_chan(struct sprdwl_priv *priv, u8 vif_ctx_id,
+		       struct ieee80211_channel *channel,
+		       enum nl80211_channel_type channel_type,
+		       u32 duration, u64 *cookie)
+{
+	struct sprdwl_msg_buf *msg;
+	struct sprdwl_cmd_remain_chan *p;
+
+	msg = sprdwl_cmd_getbuf(priv, sizeof(*p), vif_ctx_id, SPRDWL_HEAD_RSP,
+				WIFI_CMD_REMAIN_CHAN);
+	if (!msg)
+		return -ENOMEM;
+	p = (struct sprdwl_cmd_remain_chan *)msg->data;
+	p->chan = ieee80211_frequency_to_channel(channel->center_freq);
+	p->chan_type = channel_type;
+	p->duraion = cpu_to_le32(duration);
+	p->cookie = cpu_to_le64(*cookie);
+
+	return sprdwl_cmd_send_recv(priv, msg, CMD_WAIT_TIMEOUT, NULL, NULL);
+}
+
+int sprdwl_cancel_remain_chan(struct sprdwl_priv *priv,
+			       u8 vif_ctx_id, u64 cookie)
+{
+	struct sprdwl_msg_buf *msg;
+	struct sprdwl_cmd_cancel_remain_chan *p;
+
+	msg = sprdwl_cmd_getbuf(priv, sizeof(*p), vif_ctx_id, SPRDWL_HEAD_RSP,
+				WIFI_CMD_CANCEL_REMAIN_CHAN);
+	if (!msg)
+		return -ENOMEM;
+	p = (struct sprdwl_cmd_cancel_remain_chan *)msg->data;
+	p->cookie = cpu_to_le64(cookie);
+
+	return sprdwl_cmd_send_recv(priv, msg, CMD_WAIT_TIMEOUT, NULL, NULL);
+}
+#if 0
+static int sprdwl_tx_data(struct sprdwl_priv *priv, u8 vif_ctx_id, u8 channel,
+			  u8 dont_wait_for_ack, u32 wait, u64 *cookie,
+			  const u8 *buf, size_t len)
+{
+	struct sprdwl_msg_buf *msg;
+	struct sprdwl_cmd_mgmt_tx *p;
+	u16 datalen = sizeof(*p) + len;
+
+	msg = sprdwl_cmd_getbuf(priv, datalen, vif_ctx_id,
+				SPRDWL_HEAD_RSP, WIFI_CMD_TX_MGMT);
+	if (!msg)
+		return -ENOMEM;
+	p = (struct sprdwl_cmd_mgmt_tx *)msg->data;
+
+	p->chan = channel;
+	p->dont_wait_for_ack = dont_wait_for_ack;
+	p->wait = cpu_to_le32(wait);
+	if (cookie)
+		p->cookie = cpu_to_le64(*cookie);
+	p->len = cpu_to_le16(len);
+	memcpy(p->value, buf, len);
+
+	return sprdwl_cmd_send_to_ic(priv, msg);
+}
+#endif
+
+int sprdwl_tx_mgmt(struct sprdwl_priv *priv, u8 vif_ctx_id, u8 channel,
+		   u8 dont_wait_for_ack, u32 wait, u64 *cookie,
+		   const u8 *buf, size_t len)
+{
+	struct sprdwl_msg_buf *msg;
+	struct sprdwl_cmd_mgmt_tx *p;
+	u16 datalen = sizeof(*p) + len;
+
+	msg = sprdwl_cmd_getbuf(priv, datalen, vif_ctx_id,
+				SPRDWL_HEAD_RSP, WIFI_CMD_TX_MGMT);
+	if (!msg)
+		return -ENOMEM;
+	p = (struct sprdwl_cmd_mgmt_tx *)msg->data;
+
+	p->chan = channel;
+	p->dont_wait_for_ack = dont_wait_for_ack;
+	p->wait = cpu_to_le32(wait);
+	if (cookie)
+		p->cookie = cpu_to_le64(*cookie);
+	p->len = cpu_to_le16(len);
+	memcpy(p->value, buf, len);
+
+	return sprdwl_cmd_send_recv(priv, msg, CMD_WAIT_TIMEOUT, NULL, NULL);
+}
+
+int sprdwl_register_frame(struct sprdwl_priv *priv, u8 vif_ctx_id,
+			  u16 type, u8 reg)
+{
+	struct sprdwl_msg_buf *msg;
+	struct sprdwl_cmd_register_frame *p;
+
+	msg = sprdwl_cmd_getbuf(priv, sizeof(*p), vif_ctx_id, SPRDWL_HEAD_RSP,
+				WIFI_CMD_REGISTER_FRAME);
+	if (!msg)
+		return -ENOMEM;
+	p = (struct sprdwl_cmd_register_frame *)msg->data;
+	p->type = type;
+	p->reg = reg;
+
+	return sprdwl_cmd_send_recv(priv, msg, CMD_WAIT_TIMEOUT, NULL, NULL);
+}
+
+int sprdwl_set_cqm_rssi(struct sprdwl_priv *priv, u8 vif_ctx_id,
+			s32 rssi_thold, u32 rssi_hyst)
+{
+	struct sprdwl_msg_buf *msg;
+	struct sprdwl_cmd_cqm_rssi *p;
+
+	msg = sprdwl_cmd_getbuf(priv, sizeof(*p), vif_ctx_id,
+				SPRDWL_HEAD_RSP, WIFI_CMD_SET_CQM);
+	if (!msg)
+		return -ENOMEM;
+	p = (struct sprdwl_cmd_cqm_rssi *)msg->data;
+	p->rssih = cpu_to_le32(rssi_thold);
+	p->rssil = cpu_to_le32(rssi_hyst);
+
+	return sprdwl_cmd_send_recv(priv, msg, CMD_WAIT_TIMEOUT, NULL, NULL);
+}
+
+int sprdwl_set_roam_offload(struct sprdwl_priv *priv, u8 vif_ctx_id,
+			    u8 sub_type, const u8 *data, u8 len)
+{
+	struct sprdwl_msg_buf *msg;
+	struct sprdwl_cmd_roam_offload_data *p;
+
+	if (!(priv->fw_capa & SPRDWL_CAPA_11R_ROAM_OFFLOAD))	{
+		wl_err("%s, not supported\n", __func__);
+		return -ENOTSUPP;
+	}
+	msg = sprdwl_cmd_getbuf(priv, sizeof(*p) + len, vif_ctx_id,
+				SPRDWL_HEAD_RSP, WIFI_CMD_SET_ROAM_OFFLOAD);
+	if (!msg)
+		return -ENOMEM;
+	p = (struct sprdwl_cmd_roam_offload_data *)msg->data;
+	p->type = sub_type;
+	p->len = len;
+	memcpy(p->value, data, len);
+
+	return sprdwl_cmd_send_recv(priv, msg, CMD_WAIT_TIMEOUT, NULL, NULL);
+}
+
+int sprdwl_tdls_mgmt(struct sprdwl_vif *vif, struct sk_buff *skb)
+{
+	int ret;
+
+	/* temp debug use */
+	if (skb_headroom(skb) < vif->ndev->needed_headroom)
+		wl_err("%s skb head len err:%d %d\n",
+		       __func__, skb_headroom(skb),
+		       vif->ndev->needed_headroom);
+
+	/*send TDLS mgmt through cmd port instead of data port,needed by CP2*/
+	ret = sprdwl_send_tdlsdata_use_cmd(skb, vif, 1);
+	if (ret) {
+		wl_err("%s drop msg due to TX Err\n",
+		       __func__);
+		goto out;
+	}
+
+	vif->ndev->stats.tx_bytes += skb->len;
+	vif->ndev->stats.tx_packets++;
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4, 7, 0)
+	vif->ndev->trans_start = jiffies;
+#else
+	netif_trans_update(vif->ndev);
+#endif
+	wl_hex_dump(L_DBG, "TX packet: ", DUMP_PREFIX_OFFSET,
+			     16, 1, skb->data, skb->len, 0);
+
+out:
+	return ret;
+}
+
+int sprdwl_send_tdls_cmd(struct sprdwl_vif *vif, u8 vif_ctx_id, const u8 *peer,
+		     int oper)
+{
+	struct sprdwl_work *misc_work;
+	struct sprdwl_tdls_work tdls;
+
+	tdls.vif_ctx_id = vif_ctx_id;
+	if (peer)
+		ether_addr_copy(tdls.peer, peer);
+	tdls.oper = oper;
+
+	misc_work = sprdwl_alloc_work(sizeof(struct sprdwl_tdls_work));
+	if (!misc_work) {
+		wl_err("%s out of memory\n", __func__);
+		return -1;
+	}
+	misc_work->vif = vif;
+	misc_work->id = SPRDWL_TDLS_CMD;
+	memcpy(misc_work->data, &tdls, sizeof(struct sprdwl_tdls_work));
+
+	sprdwl_queue_work(vif->priv, misc_work);
+	return 0;
+}
+
+int sprdwl_tdls_oper(struct sprdwl_priv *priv, u8 vif_ctx_id, const u8 *peer,
+		     int oper)
+{
+	struct sprdwl_msg_buf *msg;
+	struct sprdwl_cmd_tdls *p;
+
+	msg = sprdwl_cmd_getbuf(priv, sizeof(*p), vif_ctx_id,
+				SPRDWL_HEAD_RSP, WIFI_CMD_TDLS);
+	if (!msg)
+		return -ENOMEM;
+	p = (struct sprdwl_cmd_tdls *)msg->data;
+	if (peer)
+		ether_addr_copy(p->da, peer);
+	p->tdls_sub_cmd_mgmt = oper;
+
+	return sprdwl_cmd_send_recv(priv, msg, CMD_WAIT_TIMEOUT, NULL, NULL);
+}
+
+int sprdwl_start_tdls_channel_switch(struct sprdwl_priv *priv, u8 vif_ctx_id,
+				     const u8 *peer_mac, u8 primary_chan,
+				     u8 second_chan_offset, u8 band)
+{
+	struct sprdwl_msg_buf *msg;
+	struct sprdwl_cmd_tdls *p;
+	struct sprdwl_cmd_tdls_channel_switch chan_switch;
+
+	msg = sprdwl_cmd_getbuf(priv, sizeof(*p) + sizeof(chan_switch),
+				vif_ctx_id, SPRDWL_HEAD_RSP, WIFI_CMD_TDLS);
+	if (!msg)
+		return -ENOMEM;
+	p = (struct sprdwl_cmd_tdls *)msg->data;
+	p->tdls_sub_cmd_mgmt = SPRDWL_TDLS_START_CHANNEL_SWITCH;
+	if (peer_mac)
+		ether_addr_copy(p->da, peer_mac);
+	p->initiator = 1;
+	chan_switch.primary_chan = primary_chan;
+	chan_switch.second_chan_offset = second_chan_offset;
+	chan_switch.band = band;
+	p->paylen = sizeof(chan_switch);
+	memcpy(p->payload, &chan_switch, p->paylen);
+
+	return sprdwl_cmd_send_recv(priv, msg, CMD_WAIT_TIMEOUT, NULL, NULL);
+}
+
+int sprdwl_cancel_tdls_channel_switch(struct sprdwl_priv *priv, u8 vif_ctx_id,
+				      const u8 *peer_mac)
+{
+	struct sprdwl_msg_buf *msg;
+	struct sprdwl_cmd_tdls *p;
+
+	msg = sprdwl_cmd_getbuf(priv, sizeof(*p), vif_ctx_id,
+				SPRDWL_HEAD_RSP, WIFI_CMD_TDLS);
+	if (!msg)
+		return -ENOMEM;
+	p = (struct sprdwl_cmd_tdls *)msg->data;
+	p->tdls_sub_cmd_mgmt = SPRDWL_TDLS_CANCEL_CHANNEL_SWITCH;
+	if (peer_mac)
+		ether_addr_copy(p->da, peer_mac);
+	p->initiator = 1;
+
+	return sprdwl_cmd_send_recv(priv, msg, CMD_WAIT_TIMEOUT, NULL, NULL);
+}
+
+int sprdwl_notify_ip(struct sprdwl_priv *priv, u8 vif_ctx_id, u8 ip_type,
+		     u8 *ip_addr)
+{
+	struct sprdwl_msg_buf *msg;
+	u8 *ip_value;
+	u8 ip_len;
+
+	if (ip_type != SPRDWL_IPV4 && ip_type != SPRDWL_IPV6)
+		return -EINVAL;
+	ip_len = (ip_type == SPRDWL_IPV4) ?
+	    SPRDWL_IPV4_ADDR_LEN : SPRDWL_IPV6_ADDR_LEN;
+	msg = sprdwl_cmd_getbuf(priv, ip_len, vif_ctx_id,
+				SPRDWL_HEAD_RSP, WIFI_CMD_NOTIFY_IP_ACQUIRED);
+	if (!msg)
+		return -ENOMEM;
+	ip_value = (unsigned char *)msg->data;
+	memcpy(ip_value, ip_addr, ip_len);
+
+	return sprdwl_cmd_send_recv(priv, msg, CMD_WAIT_TIMEOUT, NULL, NULL);
+}
+
+int sprdwl_set_blacklist(struct sprdwl_priv *priv,
+			 u8 vif_ctx_id, u8 sub_type, u8 num, u8 *mac_addr)
+{
+	struct sprdwl_msg_buf *msg;
+	struct sprdwl_cmd_blacklist *p;
+
+	msg = sprdwl_cmd_getbuf(priv, sizeof(*p) + num * ETH_ALEN,
+				vif_ctx_id, SPRDWL_HEAD_RSP,
+				WIFI_CMD_SET_BLACKLIST);
+	if (!msg)
+		return -ENOMEM;
+
+	p = (struct sprdwl_cmd_blacklist *)msg->data;
+	p->sub_type = sub_type;
+	p->num = num;
+	if (mac_addr)
+		memcpy(p->mac, mac_addr, num * ETH_ALEN);
+
+	return sprdwl_cmd_send_recv(priv, msg, CMD_WAIT_TIMEOUT, NULL, NULL);
+}
+
+int sprdwl_set_whitelist(struct sprdwl_priv *priv, u8 vif_ctx_id,
+			 u8 sub_type, u8 num, u8 *mac_addr)
+{
+	struct sprdwl_msg_buf *msg;
+	struct sprdwl_cmd_set_mac_addr *p;
+
+	msg = sprdwl_cmd_getbuf(priv, sizeof(*p) + num * ETH_ALEN,
+				vif_ctx_id, SPRDWL_HEAD_RSP,
+				WIFI_CMD_SET_WHITELIST);
+	if (!msg)
+		return -ENOMEM;
+	p = (struct sprdwl_cmd_set_mac_addr *)msg->data;
+	p->sub_type = sub_type;
+	p->num = num;
+	if (mac_addr)
+		memcpy(p->mac, mac_addr, num * ETH_ALEN);
+
+	return sprdwl_cmd_send_recv(priv, msg, CMD_WAIT_TIMEOUT, NULL, NULL);
+}
+
+int sprdwl_set_mc_filter(struct sprdwl_priv *priv,  u8 vif_ctx_id,
+			 u8 sub_type, u8 num, u8 *mac_addr)
+{
+	struct sprdwl_msg_buf *msg;
+	struct sprdwl_cmd_set_mac_addr *p;
+
+	msg = sprdwl_cmd_getbuf(priv, sizeof(*p) + num * ETH_ALEN,
+				vif_ctx_id, SPRDWL_HEAD_RSP,
+				WIFI_CMD_MULTICAST_FILTER);
+	if (!msg)
+		return -ENOMEM;
+	p = (struct sprdwl_cmd_set_mac_addr *)msg->data;
+	p->sub_type = sub_type;
+	p->num = num;
+	if (num && mac_addr)
+		memcpy(p->mac, mac_addr, num * ETH_ALEN);
+
+	return sprdwl_cmd_send_recv(priv, msg, CMD_WAIT_TIMEOUT, NULL, NULL);
+}
+
+int sprdwl_npi_send_recv(struct sprdwl_priv *priv, u8 vif_ctx_id, u8 *s_buf,
+			 u16 s_len, u8 *r_buf, u16 *r_len)
+{
+	struct sprdwl_msg_buf *msg;
+
+	msg = sprdwl_cmd_getbuf(priv, s_len, vif_ctx_id,
+				SPRDWL_HEAD_RSP, WIFI_CMD_NPI_MSG);
+	if (!msg)
+		return -ENOMEM;
+	memcpy(msg->data, s_buf, s_len);
+
+	return sprdwl_cmd_send_recv(priv, msg, CMD_WAIT_TIMEOUT, r_buf, r_len);
+}
+
+int sprdwl_set_11v_feature_support(struct sprdwl_priv *priv,
+				   u8 vif_ctx_id, u16 val)
+{
+	struct sprdwl_msg_buf *msg = NULL;
+	struct sprdwl_cmd_rsp_state_code state;
+	struct sprdwl_cmd_11v *p = NULL;
+	u16 rlen = sizeof(state);
+
+	msg = sprdwl_cmd_getbuf(priv, sizeof(*p), vif_ctx_id, 1, WIFI_CMD_11V);
+	if (!msg)
+		return -ENOMEM;
+	p = (struct sprdwl_cmd_11v *)msg->data;
+
+	p->cmd = SPRDWL_SUBCMD_SET;
+	p->value = (val << 16) | val;
+	/* len  only 8 =  cmd(2) + len(2) +value(4)*/
+	p->len = 8;
+
+	return sprdwl_cmd_send_recv(priv, msg, CMD_WAIT_TIMEOUT,
+				    (u8 *)&state, &rlen);
+}
+
+int sprdwl_set_11v_sleep_mode(struct sprdwl_priv *priv, u8 vif_ctx_id,
+			      u8 status, u16 interval)
+{
+	struct sprdwl_msg_buf *msg = NULL;
+	struct sprdwl_cmd_rsp_state_code state;
+	struct sprdwl_cmd_11v *p = NULL;
+	u16 rlen = sizeof(state);
+	u32 value = 0;
+
+	msg = sprdwl_cmd_getbuf(priv, sizeof(*p), vif_ctx_id, 1, WIFI_CMD_11V);
+	if (!msg)
+		return -ENOMEM;
+	p = (struct sprdwl_cmd_11v *)msg->data;
+
+	p->cmd = SPRDWL_SUBCMD_ENABLE;
+	/* 24-31 feature 16-23 status 0-15 interval */
+	value = SPRDWL_11V_SLEEP << 8;
+	value = (value | status) << 16;
+	value = value | interval;
+	p->value = value;
+	/* len  only 8 =  cmd(2) + len(2) +value(4)*/
+	p->len = 8;
+
+	return sprdwl_cmd_send_recv(priv, msg, CMD_WAIT_TIMEOUT,
+				    (u8 *)&state, &rlen);
+}
+
+int sprdwl_send_ba_mgmt(struct sprdwl_priv *priv, u8 vif_ctx_id,
+			void *data, u16 len)
+{
+	struct sprdwl_msg_buf *msg = NULL;
+
+	msg = sprdwl_cmd_getbuf(priv, sizeof(struct sprdwl_cmd_ba),
+				vif_ctx_id, 1, WIFI_CMD_BA);
+	if (!msg)
+		return -ENOMEM;
+
+	memcpy(msg->data, data, len);
+	return sprdwl_cmd_send_recv(priv, msg, CMD_WAIT_TIMEOUT, NULL, NULL);
+}
+
+int sprdwl_set_max_clients_allowed(struct sprdwl_priv *priv,
+				   u8 vif_ctx_id, int n_clients)
+{
+	int *max;
+	struct sprdwl_msg_buf *msg;
+
+	msg = sprdwl_cmd_getbuf(priv, sizeof(*max), vif_ctx_id, SPRDWL_HEAD_RSP,
+				WIFI_CMD_SET_MAX_CLIENTS_ALLOWED);
+	if (!msg)
+		return -ENOMEM;
+	*(int *)msg->data = n_clients;
+
+	return sprdwl_cmd_send_recv(priv, msg, CMD_WAIT_TIMEOUT, NULL, NULL);
+}
+
+void sprdwl_add_hang_cmd(struct sprdwl_vif *vif)
+{
+	struct sprdwl_work *misc_work;
+	struct sprdwl_cmd *cmd = &g_sprdwl_cmd;
+	struct sprdwl_intf *intf = (struct sprdwl_intf *)(vif->priv->hw_priv);
+	struct sprdwl_tx_msg *tx_msg = (struct sprdwl_tx_msg *)intf->sprdwl_tx;
+
+	if (sprdwl_intf_is_exit(vif->priv)
+		|| (tx_msg->hang_recovery_status == HANG_RECOVERY_ACKED
+		&& cmd->cmd_id != WIFI_CMD_HANG_RECEIVED)) {
+		complete(&cmd->completed);
+	}
+	misc_work = sprdwl_alloc_work(0);
+	if (!misc_work) {
+		wl_err("%s out of memory\n", __func__);
+		return;
+	}
+	misc_work->vif = vif;
+	misc_work->id = SPRDWL_HANG_RECEIVED;
+
+	sprdwl_queue_work(vif->priv, misc_work);
+}
+
+void sprdwl_add_close_cmd(struct sprdwl_vif *vif, enum sprdwl_mode mode)
+{
+	struct sprdwl_work *misc_work;
+
+	misc_work = sprdwl_alloc_work(1);
+	if (!misc_work) {
+		wl_err("%s out of memory\n", __func__);
+		return;
+	}
+	misc_work->vif = vif;
+	misc_work->id = SPRDWL_SEND_CLOSE;
+	memcpy(misc_work->data, &mode, 1);
+
+	sprdwl_queue_work(vif->priv, misc_work);
+}
+
+/* CP2 send WIFI_EVENT_HANG_RECOVERY to Driver,
+* then Driver need to send a WIFI_CMD_HANG_RECEIVED cmd to CP2
+* to notify that CP2 can reset credit now.
+*/
+int sprdwl_send_hang_received_cmd(struct sprdwl_priv *priv, u8 vif_ctx_id)
+{
+	struct sprdwl_msg_buf *msg;
+	struct sprdwl_intf *intf = (struct sprdwl_intf *)(priv->hw_priv);
+	struct sprdwl_tx_msg *tx_msg = (struct sprdwl_tx_msg *)intf->sprdwl_tx;
+
+	msg = sprdwl_cmd_getbuf(priv, 0, vif_ctx_id, SPRDWL_HEAD_RSP,
+				WIFI_CMD_HANG_RECEIVED);
+	if (!msg)
+		return -ENOMEM;
+	tx_msg->hang_recovery_status = HANG_RECOVERY_ACKED;
+	return sprdwl_cmd_send_recv(priv, msg,
+			CMD_WAIT_TIMEOUT, NULL, NULL);
+}
+
+void sprdwl_send_assert_cmd(struct sprdwl_vif *vif, u8 cmd_id, u8 reason)
+{
+	struct sprdwl_work *misc_work;
+	struct sprdwl_assert_info *assert_info;
+
+	misc_work = sprdwl_alloc_work(sizeof(struct sprdwl_assert_info));
+	if (!misc_work) {
+		wl_err("%s out of memory\n", __func__);
+		return;
+	}
+	misc_work->vif = vif;
+	misc_work->id = SPRDWL_ASSERT;
+	assert_info = (struct sprdwl_assert_info *)(misc_work->data);
+	assert_info->cmd_id = cmd_id;
+	assert_info->reason = reason;
+
+	sprdwl_queue_work(vif->priv, misc_work);
+}
+
+/* add a reason to CMD assert
+* 0:scan time out
+* 1:rsp cnt lost
+*/
+int wlan_set_assert(struct sprdwl_priv *priv, u8 vif_ctx_id, u8 cmd_id, u8 reason)
+{
+#ifndef ATCMD_ASSERT
+	struct sprdwl_msg_buf *msg;
+	struct sprdwl_cmd_set_assert *p;
+
+	return 0;
+	msg = sprdwl_cmd_getbuf(priv, sizeof(*p), vif_ctx_id,
+			SPRDWL_HEAD_RSP, WIFI_CMD_ERR);
+	if (!msg)
+		return -ENOMEM;
+	p = (struct sprdwl_cmd_set_assert *)msg->data;
+	p->reason = reason;
+
+	return sprdwl_cmd_send_recv(priv, msg,
+			CMD_WAIT_TIMEOUT, NULL, NULL);
+#else
+	return sprdwl_atcmd_assert(priv, vif_ctx_id, cmd_id, reason);
+#endif
+}
+
+int sprdwl_send_data2cmd(struct sprdwl_priv *priv, u8 vif_ctx_id,
+				void *data, u16 len)
+{
+	struct sprdwl_msg_buf *msg = NULL;
+
+	msg = sprdwl_cmd_getbuf(priv, len, vif_ctx_id,
+			SPRDWL_HEAD_RSP, WIFI_CMD_TX_DATA);
+	if (!msg)
+		return -ENOMEM;
+	memcpy(msg->data, data, len);
+	return sprdwl_cmd_send_recv(priv, msg, CMD_WAIT_TIMEOUT, NULL, NULL);
+}
+
+
+int sprdwl_xmit_data2cmd(struct sk_buff *skb, struct net_device *ndev)
+{
+#define FLAG_SIZE  5
+	struct sprdwl_vif *vif = netdev_priv(ndev);
+	struct sprdwl_msg_buf *msg;
+	u8 *temp_flag = "01234";
+	struct tx_msdu_dscr *dscr;
+	struct sprdwl_cmd *cmd = &g_sprdwl_cmd;
+
+	if (unlikely(atomic_read(&cmd->refcnt) > 0)) {
+		wl_err("%s, cmd->refcnt = %d, Try later again\n",
+		       __func__, atomic_read(&cmd->refcnt));
+		return -EAGAIN;
+	}
+
+	if (skb->protocol == cpu_to_be16(ETH_P_PAE)) {
+		u8 *data = (u8 *)(skb->data) + sizeof(struct ethhdr);
+		struct sprdwl_eap_hdr *eap = (struct sprdwl_eap_hdr *)data;
+
+		if (eap->type == EAP_PACKET_TYPE && eap->opcode == EAP_WSC_DONE) {
+			wl_info("%s, EAP_WSC_DONE!\n", __func__);
+			vif->wps_flag = 1;
+		}
+	}
+	/*fill dscr header first*/
+	if (sprdwl_intf_fill_msdu_dscr(vif, skb, SPRDWL_TYPE_CMD, 0)) {
+		dev_kfree_skb(skb);
+		return -EPERM;
+	}
+	/*alloc five byte for fw 16 byte need
+	 *dscr:11+flag:5 =16
+	 */
+	skb_push(skb, FLAG_SIZE);
+	memcpy(skb->data, temp_flag, FLAG_SIZE);
+	/*malloc msg buffer*/
+	msg = sprdwl_cmd_getbuf_atomic(vif->priv, skb->len, vif->ctx_id,
+				       SPRDWL_HEAD_RSP, WIFI_CMD_TX_DATA);
+	if (!msg) {
+		wl_err("%s, %d, getmsgbuf fail, free skb\n",
+		       __func__, __LINE__);
+		dev_kfree_skb(skb);
+		return -ENOMEM;
+	}
+	/*send group in BK to avoid FW hang*/
+	dscr = (struct tx_msdu_dscr *)skb->data;
+	if ((vif->mode == SPRDWL_MODE_AP ||
+	     vif->mode == SPRDWL_MODE_P2P_GO) &&
+	     (dscr->sta_lut_index < 6)) {
+		dscr->buffer_info.msdu_tid = prio_1;
+		wl_info("%s, %d, SOFTAP/GO group go as BK\n", __func__, __LINE__);
+	}
+
+	memcpy(msg->data, skb->data, skb->len);
+	dev_kfree_skb(skb);
+
+	return sprdwl_cmd_send_to_ic(vif->priv, msg);
+}
+
+int sprdwl_xmit_data2cmd_wq(struct sk_buff *skb, struct net_device *ndev)
+{
+#define FLAG_SIZE  5
+	struct sprdwl_vif *vif = netdev_priv(ndev);
+	u8 *temp_flag = "01234";
+	struct tx_msdu_dscr *dscr;
+	struct sprdwl_work *misc_work = NULL;
+
+	/*fill dscr header first*/
+	if (sprdwl_intf_fill_msdu_dscr(vif, skb, SPRDWL_TYPE_CMD, 0)) {
+		dev_kfree_skb(skb);
+		return -EPERM;
+	}
+	/*alloc five byte for fw 16 byte need
+	 *dscr:11+flag:5 =16
+	 */
+	skb_push(skb, FLAG_SIZE);
+	memcpy(skb->data, temp_flag, FLAG_SIZE),
+	/*send group in BK to avoid FW hang*/
+	dscr = (struct tx_msdu_dscr *)skb->data;
+	if ((vif->mode == SPRDWL_MODE_AP ||
+		vif->mode == SPRDWL_MODE_P2P_GO) &&
+		(dscr->sta_lut_index < 6)) {
+		dscr->buffer_info.msdu_tid = prio_1;
+		wl_info("%s, %d, SOFTAP/GO group go as BK\n", __func__, __LINE__);
+	}
+
+	/*create work queue*/
+	misc_work = sprdwl_alloc_work(skb->len);
+	if (!misc_work) {
+		wl_err("%s:work queue alloc failure\n", __func__);
+		dev_kfree_skb(skb);
+		return -1;
+	}
+	memcpy(misc_work->data, skb->data, skb->len);
+	dev_kfree_skb(skb);
+	misc_work->vif = vif;
+	misc_work->id = SPRDWL_CMD_TX_DATA;
+	sprdwl_queue_work(vif->priv, misc_work);
+
+	return 0;
+}
+
+int sprdwl_send_vowifi_data_prot(struct sprdwl_priv *priv, u8 ctx_id,
+				 void *data, int len)
+{
+	struct sprdwl_msg_buf *msg;
+
+	wl_info("enter--at %s\n", __func__);
+
+	if (priv == NULL)
+		return -EINVAL;
+
+	msg = sprdwl_cmd_getbuf(priv, 0, ctx_id,
+				SPRDWL_HEAD_RSP, WIFI_CMD_VOWIFI_DATA_PROTECT);
+	if (!msg)
+		return -ENOMEM;
+
+	return sprdwl_cmd_send_recv(priv, msg, CMD_WAIT_TIMEOUT, NULL, NULL);
+}
+
+void sprdwl_vowifi_data_protection(struct sprdwl_vif *vif)
+{
+	struct sprdwl_work *misc_work;
+
+	wl_info("enter--at %s\n", __func__);
+
+	misc_work = sprdwl_alloc_work(0);
+	if (!misc_work) {
+		wl_err("%s out of memory\n", __func__);
+		return;
+	}
+	misc_work->vif = vif;
+	misc_work->id = SPRDWL_WORK_VOWIFI_DATA_PROTECTION;
+
+	sprdwl_queue_work(vif->priv, misc_work);
+}
+
+void sprdwl_work_host_wakeup_fw(struct sprdwl_vif *vif)
+{
+	struct sprdwl_work *misc_work;
+
+	misc_work = sprdwl_alloc_work(0);
+	if (!misc_work) {
+		wl_err("%s out of memory\n", __func__);
+		return;
+	}
+	if (!vif) {
+		wl_err("%s vif is null!\n", __func__);
+		return;
+	}
+	if (!vif->priv) {
+		wl_err("%s priv is null!\n", __func__);
+		return;
+	}
+	misc_work->vif = vif;
+	misc_work->id = SPRDWL_WORK_HOST_WAKEUP_FW;
+
+	sprdwl_queue_work(vif->priv, misc_work);
+}
+
+int sprdwl_cmd_host_wakeup_fw(struct sprdwl_priv *priv, u8 ctx_id)
+{
+	struct sprdwl_msg_buf *msg;
+	struct sprdwl_cmd_power_save *p;
+	u8 r_buf = -1;
+	u16 r_len = 1;
+	int ret = 0;
+	struct sprdwl_intf *intf = (struct sprdwl_intf *)(priv->hw_priv);
+	struct sprdwl_tx_msg *tx_msg = (struct sprdwl_tx_msg *)intf->sprdwl_tx;
+
+	msg = sprdwl_cmd_getbuf(priv, sizeof(*p), ctx_id,
+				SPRDWL_HEAD_RSP, WIFI_CMD_POWER_SAVE);
+	if (!msg)
+		return -ENOMEM;
+
+	p = (struct sprdwl_cmd_power_save *)msg->data;
+	p->sub_type = SPRDWL_HOST_WAKEUP_FW;
+	p->value = 0;
+
+	ret =  sprdwl_cmd_send_recv(priv, msg, CMD_WAIT_TIMEOUT,
+				    &r_buf, &r_len);
+
+	if (!ret && (1 == r_buf)) {
+		intf->fw_awake = 1;
+		tx_up(tx_msg);
+	} else {
+		intf->fw_awake = 0;
+		intf->fw_power_down = 1;
+		tx_up(tx_msg);
+		wl_err("host wakeup fw cmd failed, ret=%d\n", ret);
+	}
+
+	return ret;
+}
+
+int sprdwl_cmd_req_lte_concur(struct sprdwl_priv *priv, u8 ctx_id, u8 user_channel)
+{
+	struct sprdwl_msg_buf *msg;
+
+	msg = sprdwl_cmd_getbuf(priv, sizeof(user_channel), ctx_id,
+				SPRDWL_HEAD_RSP, WIFI_CMD_REQ_LTE_CONCUR);
+	if (!msg)
+		return -ENOMEM;
+
+	*(u8 *)msg->data = user_channel;
+	return sprdwl_cmd_send_recv(priv, msg, CMD_WAIT_TIMEOUT, NULL, NULL);
+}
+
+static int handle_rsp_status_err(u8 cmd_id, s8 status)
+{
+	int flag = 0;
+
+	switch (cmd_id) {
+	case WIFI_CMD_DOWNLOAD_INI:
+		 if ((SPRDWL_CMD_STATUS_CRC_ERROR == status) ||
+			(SPRDWL_CMD_STATUS_INI_INDEX_ERROR == status) ||
+			(SPRDWL_CMD_STATUS_LENGTH_ERROR == status))
+			flag = -1;
+		 break;
+	default:
+		 flag = 0;
+		 break;
+	}
+
+	return flag;
+}
+
+/* retrun the msg length or 0 */
+unsigned short sprdwl_rx_rsp_process(struct sprdwl_priv *priv, u8 *msg)
+{
+	u16 plen;
+	void *data;
+	int handle_flag = 0;
+	struct sprdwl_cmd *cmd = &g_sprdwl_cmd;
+	struct sprdwl_cmd_hdr *hdr;
+
+	if (unlikely(!cmd->init_ok)) {
+		wl_info("%s cmd coming too early, drop it\n", __func__);
+		return 0;
+	}
+
+	hdr = (struct sprdwl_cmd_hdr *)msg;
+	plen = SPRDWL_GET_LE16(hdr->plen);
+
+	/* 2048 use mac */
+	/*TODO here ctx_id range*/
+#ifndef CONFIG_P2P_INTF
+	if (hdr->common.ctx_id > STAP_MODE_P2P_DEVICE ||
+#else
+	if (hdr->common.ctx_id >= STAP_MODE_COEXI_NUM ||
+#endif
+		hdr->cmd_id > WIFI_CMD_MAX ||
+	    plen > 2048) {
+		wl_err("%s wrong CMD_RSP: ctx_id:%d;cmd_id:%d\n",
+		       __func__, hdr->common.ctx_id,
+		       hdr->cmd_id);
+		return 0;
+	}
+	if (atomic_inc_return(&cmd->refcnt) >= SPRDWL_CMD_EXIT_VAL) {
+		atomic_dec(&cmd->refcnt);
+		wl_err("cmd->refcnt=%x\n", atomic_read(&cmd->refcnt));
+		return 0;
+	}
+	data = kmalloc(plen, GFP_KERNEL);
+	if (!data) {
+		atomic_dec(&cmd->refcnt);
+		wl_err("cmd->refcnt=%x\n", atomic_read(&cmd->refcnt));
+		return plen;
+	}
+	memcpy(data, (void *)hdr, plen);
+
+	spin_lock_bh(&cmd->lock);
+	if (!cmd->data && SPRDWL_GET_LE32(hdr->mstime) == cmd->mstime &&
+	    hdr->cmd_id == cmd->cmd_id) {
+		wl_debug("ctx_id %d recv rsp[%s]\n",
+			hdr->common.ctx_id, cmd2str(hdr->cmd_id));
+		if (unlikely(hdr->status != 0)) {
+			wl_debug("%s ctx_id %d recv rsp[%s] status[%s]\n",
+			       __func__, hdr->common.ctx_id,
+			       cmd2str(hdr->cmd_id),
+			       err2str(hdr->status));
+			handle_flag = handle_rsp_status_err(hdr->cmd_id,
+						hdr->status);
+		}
+		cmd->data = data;
+		complete(&cmd->completed);
+	} else {
+		kfree(data);
+		wl_err("%s ctx_id %d recv mismatched rsp[%s] status[%s]\n",
+		       __func__, hdr->common.ctx_id,
+		       cmd2str(hdr->cmd_id),
+		       err2str(hdr->status));
+		wl_err("%s mstime:[%u %u]\n", __func__,
+		       SPRDWL_GET_LE32(hdr->mstime), cmd->mstime);
+	}
+	spin_unlock_bh(&cmd->lock);
+	atomic_dec(&cmd->refcnt);
+	wl_debug("cmd->refcnt=%x\n", atomic_read(&cmd->refcnt));
+
+	if (0 != handle_flag)
+		wlan_set_assert(priv, SPRDWL_MODE_NONE, hdr->cmd_id, HANDLE_FLAG_ERROR);
+
+	return plen;
+}
+
+/* Events */
+void sprdwl_event_station(struct sprdwl_vif *vif, u8 *data, u16 len)
+{
+	struct sprdwl_event_new_station *sta =
+	    (struct sprdwl_event_new_station *)data;
+
+	sprdwl_report_softap(vif, sta->is_connect,
+			     sta->mac, sta->ie, sta->ie_len);
+}
+
+void sprdwl_event_scan_done(struct sprdwl_vif *vif, u8 *data, u16 len)
+{
+	struct sprdwl_event_scan_done *p =
+	    (struct sprdwl_event_scan_done *)data;
+	u8 bucket_id = 0;
+
+	switch (p->type) {
+	case SPRDWL_SCAN_DONE:
+		sprdwl_scan_done(vif, false);
+		wl_ndev_log(L_DBG, vif->ndev, "%s got %d BSSes\n", __func__,
+			    bss_count);
+		break;
+	case SPRDWL_SCHED_SCAN_DONE:
+		sprdwl_sched_scan_done(vif, false);
+		wl_ndev_log(L_DBG, vif->ndev, "%s schedule scan got %d BSSes\n",
+			    __func__, bss_count);
+		break;
+	case SPRDWL_GSCAN_DONE:
+		bucket_id = ((struct sprdwl_event_gscan_done *)data)->bucket_id;
+		sprdwl_gscan_done(vif, bucket_id);
+		wl_ndev_log(L_DBG, vif->ndev, "%s gscan got %d bucketid done\n",
+			    __func__, bucket_id);
+		break;
+	case SPRDWL_SCAN_ERROR:
+	default:
+		sprdwl_scan_done(vif, true);
+		sprdwl_sched_scan_done(vif, false);
+		if (p->type == SPRDWL_SCAN_ERROR)
+			wl_ndev_log(L_ERR, vif->ndev, "%s error!\n", __func__);
+		else
+			wl_ndev_log(L_ERR, vif->ndev, "%s invalid scan done type: %d\n",
+				   __func__, p->type);
+		break;
+	}
+	bss_count = 0;
+}
+
+void sprdwl_event_connect(struct sprdwl_vif *vif, u8 *data, u16 len)
+{
+	u8 *pos = data;
+	u8 status_code = 0;
+	int left = len;
+	struct sprdwl_connect_info conn_info;
+#ifdef COMPAT_SAMPILE_CODE
+	u8 compat_ver = 0;
+	struct sprdwl_priv *priv = vif->priv;
+
+	compat_ver = need_compat_operation(priv, WIFI_EVENT_CONNECT);
+	if (compat_ver) {
+		switch (compat_ver) {
+		case VERSION_1:
+			/*add data struct modification in here!*/
+			break;
+		case VERSION_2:
+			/*add data struct modification in here!*/
+			break;
+		case VERSION_3:
+			/*add data struct modification in here!*/
+			break;
+		default:
+			break;
+		}
+	}
+#endif
+
+	/*init data struct*/
+	memset(&conn_info, 0, sizeof(conn_info));
+	/* the first byte is status code */
+	memcpy(&conn_info.status, pos, sizeof(conn_info.status));
+	if (conn_info.status != SPRDWL_CONNECT_SUCCESS &&
+	    conn_info.status != SPRDWL_ROAM_SUCCESS){
+		/*Assoc response status code by set in the 3 byte if failure*/
+		memcpy(&status_code, pos+2, sizeof(status_code));
+		goto out;
+	}
+	pos += sizeof(conn_info.status);
+	left -= sizeof(conn_info.status);
+
+	/* parse BSSID */
+	if (left < ETH_ALEN)
+		goto out;
+	conn_info.bssid = pos;
+	pos += ETH_ALEN;
+	left -= ETH_ALEN;
+
+	/* get channel */
+	if (left < sizeof(conn_info.channel))
+		goto out;
+	memcpy(&conn_info.channel, pos, sizeof(conn_info.channel));
+	pos += sizeof(conn_info.channel);
+	left -= sizeof(conn_info.channel);
+
+	/* get signal */
+	if (left < sizeof(conn_info.signal))
+		goto out;
+	memcpy(&conn_info.signal, pos, sizeof(conn_info.signal));
+	pos += sizeof(conn_info.signal);
+	left -= sizeof(conn_info.signal);
+
+	/* parse REQ IE */
+	if (left < 0)
+		goto out;
+	memcpy(&conn_info.req_ie_len, pos, sizeof(conn_info.req_ie_len));
+	pos += sizeof(conn_info.req_ie_len);
+	left -= sizeof(conn_info.req_ie_len);
+	conn_info.req_ie = pos;
+	pos += conn_info.req_ie_len;
+	left -= conn_info.req_ie_len;
+
+	/* parse RESP IE */
+	if (left < 0)
+		goto out;
+	memcpy(&conn_info.resp_ie_len, pos, sizeof(conn_info.resp_ie_len));
+	pos += sizeof(conn_info.resp_ie_len);
+	left -= sizeof(conn_info.resp_ie_len);
+	conn_info.resp_ie = pos;
+	pos += conn_info.resp_ie_len;
+	left -= conn_info.resp_ie_len;
+
+	/* parse BEA IE */
+	if (left < 0)
+		goto out;
+	memcpy(&conn_info.bea_ie_len, pos, sizeof(conn_info.bea_ie_len));
+	pos += sizeof(conn_info.bea_ie_len);
+	left -= sizeof(conn_info.bea_ie_len);
+	conn_info.bea_ie = pos;
+out:
+	sprdwl_report_connection(vif, &conn_info, status_code);
+}
+
+void sprdwl_event_disconnect(struct sprdwl_vif *vif, u8 *data, u16 len)
+{
+	u16 reason_code;
+
+	memcpy(&reason_code, data, sizeof(reason_code));
+#ifdef SYNC_DISCONNECT
+	/*Report disconnection on version > 4.9.60, even though disconnect
+	 is from wpas, otherwise it returns -EALREADY on next connect.*/
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4, 9, 60)
+	if (atomic_read(&vif->sync_disconnect_event)) {
+		vif->disconnect_event_code = reason_code;
+		atomic_set(&vif->sync_disconnect_event, 0);
+		wake_up(&vif->disconnect_wq);
+		wl_err("%s reason code = %d\n", __func__, reason_code);
+	} else
+#endif
+#endif
+	sprdwl_report_disconnection(vif, reason_code);
+}
+
+void sprdwl_event_mic_failure(struct sprdwl_vif *vif, u8 *data, u16 len)
+{
+	struct sprdwl_event_mic_failure *mic_failure =
+	    (struct sprdwl_event_mic_failure *)data;
+
+	sprdwl_report_mic_failure(vif, mic_failure->is_mcast,
+				  mic_failure->key_id);
+}
+
+void sprdwl_event_remain_on_channel_expired(struct sprdwl_vif *vif,
+					    u8 *data, u16 len)
+{
+	sprdwl_report_remain_on_channel_expired(vif);
+}
+
+void sprdwl_event_mlme_tx_status(struct sprdwl_vif *vif, u8 *data, u16 len)
+{
+	struct sprdwl_event_mgmt_tx_status *tx_status =
+	    (struct sprdwl_event_mgmt_tx_status *)data;
+
+	sprdwl_report_mgmt_tx_status(vif, SPRDWL_GET_LE64(tx_status->cookie),
+				     tx_status->buf,
+				     SPRDWL_GET_LE16(tx_status->len),
+				     tx_status->ack);
+}
+
+/* @flag: 1 for data, 0 for event */
+void sprdwl_event_frame(struct sprdwl_vif *vif, u8 *data, u16 len, int flag)
+{
+	struct sprdwl_event_mgmt_frame *frame;
+	u16 buf_len;
+	u8 *buf = NULL;
+	u8 channel, type;
+
+	if (flag) {
+		/* here frame maybe not 4 bytes align */
+		frame = (struct sprdwl_event_mgmt_frame *)
+			(data - sizeof(*frame) + len);
+		buf = data - sizeof(*frame);
+	} else {
+		frame = (struct sprdwl_event_mgmt_frame *)data;
+		buf = frame->data;
+	}
+	channel = frame->channel;
+	type = frame->type;
+	buf_len = SPRDWL_GET_LE16(frame->len);
+
+	sprdwl_cfg80211_dump_frame_prot_info(0, 0, buf, buf_len);
+
+	switch (type) {
+	case SPRDWL_FRAME_NORMAL:
+		sprdwl_report_rx_mgmt(vif, channel, buf, buf_len);
+		break;
+	case SPRDWL_FRAME_DEAUTH:
+		sprdwl_report_mgmt_deauth(vif, buf, buf_len);
+		break;
+	case SPRDWL_FRAME_DISASSOC:
+		sprdwl_report_mgmt_disassoc(vif, buf, buf_len);
+		break;
+	case SPRDWL_FRAME_SCAN:
+		sprdwl_report_scan_result(vif, channel, frame->signal,
+					  buf, buf_len);
+		++bss_count;
+		break;
+	default:
+		wl_ndev_log(L_ERR, vif->ndev, "%s invalid frame type: %d!\n",
+			   __func__, type);
+		break;
+	}
+}
+
+void sprdwl_event_epno_results(struct sprdwl_vif *vif, u8 *data, u16 data_len)
+{
+	int i;
+	u64 msecs, now;
+	struct sk_buff *skb;
+	struct nlattr *attr, *sub_attr;
+	struct sprdwl_epno_results *epno_results;
+	struct sprdwl_priv *priv = vif->priv;
+	struct wiphy *wiphy = priv->wiphy;
+
+	wl_hex_dump(L_DBG, "epno result:", DUMP_PREFIX_OFFSET,
+			     16, 1, data, data_len, true);
+
+	epno_results = (struct sprdwl_epno_results *)data;
+	if (epno_results->nr_scan_results <= 0) {
+		wl_err("%s invalid data\n", __func__);
+		return;
+	}
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 4, 83)
+	skb = cfg80211_vendor_event_alloc(wiphy, &vif->wdev, data_len,
+#else
+	skb = cfg80211_vendor_event_alloc(wiphy, data_len,
+#endif
+					  SPRDWL_VENDOR_EVENT_EPNO_FOUND,
+					  GFP_KERNEL);
+	if (skb == NULL) {
+		wl_ndev_log(L_ERR, vif->ndev, "skb alloc failed");
+		return;
+	}
+
+	nla_put_u32(skb, GSCAN_RESULTS_REQUEST_ID, epno_results->request_id);
+	nla_put_u32(skb, GSCAN_RESULTS_NUM_RESULTS_AVAILABLE,
+		    epno_results->nr_scan_results);
+	nla_put_u8(skb, GSCAN_RESULTS_SCAN_RESULT_MORE_DATA, 0);
+
+	attr = nla_nest_start(skb, GSCAN_RESULTS_LIST);
+	if (attr == NULL)
+		goto failed;
+
+	now = jiffies;
+
+	if (now > epno_results->boot_time)
+		msecs = jiffies_to_msecs(now - epno_results->boot_time);
+	else {
+		now += (MAX_JIFFY_OFFSET - epno_results->boot_time) + 1;
+		msecs = jiffies_to_msecs(now);
+	}
+
+	for (i = 0; i < epno_results->nr_scan_results; i++) {
+		sub_attr = nla_nest_start(skb, i);
+		if (sub_attr == NULL)
+			goto failed;
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 7, 0)
+		nla_put_u64_64bit(skb, GSCAN_RESULTS_SCAN_RESULT_TIME_STAMP, msecs, 0);
+#else
+		nla_put_u64(skb, GSCAN_RESULTS_SCAN_RESULT_TIME_STAMP, msecs);
+#endif
+		nla_put(skb, GSCAN_RESULTS_SCAN_RESULT_BSSID, ETH_ALEN,
+			epno_results->results[i].bssid);
+		nla_put_u32(skb, GSCAN_RESULTS_SCAN_RESULT_CHANNEL,
+			    epno_results->results[i].channel);
+		nla_put_s32(skb, GSCAN_RESULTS_SCAN_RESULT_RSSI,
+			    epno_results->results[i].rssi);
+		nla_put_u32(skb, GSCAN_RESULTS_SCAN_RESULT_RTT,
+			    epno_results->results[i].rtt);
+		nla_put_u32(skb, GSCAN_RESULTS_SCAN_RESULT_RTT_SD,
+			    epno_results->results[i].rtt_sd);
+		nla_put_u16(skb, GSCAN_RESULTS_SCAN_RESULT_BEACON_PERIOD,
+			    epno_results->results[i].beacon_period);
+		nla_put_u16(skb, GSCAN_RESULTS_SCAN_RESULT_CAPABILITY,
+			    epno_results->results[i].capability);
+		nla_put_string(skb, GSCAN_RESULTS_SCAN_RESULT_SSID,
+			       epno_results->results[i].ssid);
+
+		nla_nest_end(skb, sub_attr);
+	}
+
+	nla_nest_end(skb, attr);
+
+	cfg80211_vendor_event(skb, GFP_KERNEL);
+	wl_debug("report epno event success, count = %d\n",
+		 epno_results->nr_scan_results);
+	return;
+
+failed:
+	kfree(skb);
+	wl_err("%s report epno event failed\n", __func__);
+}
+
+void sprdwl_event_gscan_frame(struct sprdwl_vif *vif, u8 *data, u16 len)
+{
+	u32 report_event;
+	u8 *pos = data;
+	s32 avail_len = len;
+	struct sprdwl_gscan_result *frame;
+	u16 buf_len;
+	u8 bucket_id = 0;
+
+	report_event = *(u32 *)pos;
+	avail_len -= sizeof(u32);
+	pos += sizeof(u32);
+
+	if (report_event & REPORT_EVENTS_EPNO)
+		return sprdwl_event_epno_results(vif, pos, avail_len);
+
+/*significant change result is different with gsan with, deal it specially*/
+	if (report_event & REPORT_EVENTS_SIGNIFICANT_CHANGE) {
+		sprdwl_vendor_cache_significant_change_result(vif,
+				pos, avail_len);
+		sprdwl_significant_change_event(vif);
+		return;
+	}
+
+	while (avail_len > 0) {
+		if (avail_len < sizeof(struct sprdwl_gscan_result)) {
+			wl_ndev_log(L_ERR, vif->ndev,
+				   "%s invalid available length: %d!\n",
+				   __func__, avail_len);
+			break;
+		}
+
+		bucket_id = *(u8 *)pos;
+		pos += sizeof(u8);
+		frame = (struct sprdwl_gscan_result *)pos;
+		frame->ts = jiffies;
+		buf_len = frame->ie_length;
+
+		if ((report_event == REPORT_EVENTS_BUFFER_FULL) ||
+			(report_event & REPORT_EVENTS_EACH_SCAN))
+			sprdwl_vendor_cache_scan_result(vif, bucket_id, frame);
+		else if (report_event & REPORT_EVENTS_FULL_RESULTS)
+			sprdwl_vendor_report_full_scan(vif, frame);
+		else if (report_event & REPORT_EVENTS_HOTLIST_RESULTS_FOUND ||
+			report_event & REPORT_EVENTS_HOTLIST_RESULTS_LOST) {
+			sprdwl_vendor_cache_hotlist_result(vif, frame);
+		}
+
+		avail_len -= sizeof(struct sprdwl_gscan_result) + buf_len + 1;
+		pos += sizeof(struct sprdwl_gscan_result) + buf_len;
+
+		wl_ndev_log(L_DBG, vif->ndev, "%s ch:%d id:%d len:%d aval:%d, report_event:%d\n",
+			    __func__, frame->channel, bucket_id,
+			    buf_len, avail_len, report_event);
+	}
+
+	if (report_event == REPORT_EVENTS_BUFFER_FULL)
+		sprdwl_buffer_full_event(vif);
+	else if (report_event & REPORT_EVENTS_EACH_SCAN)
+		sprdwl_gscan_done(vif, bucket_id);
+	else if (report_event & REPORT_EVENTS_HOTLIST_RESULTS_FOUND ||
+		report_event & REPORT_EVENTS_HOTLIST_RESULTS_LOST) {
+		sprdwl_hotlist_change_event(vif, report_event);
+	}
+
+}
+
+void sprdwl_event_cqm(struct sprdwl_vif *vif, u8 *data, u16 len)
+{
+	struct sprdwl_event_cqm *p;
+	u8 rssi_event;
+
+	p = (struct sprdwl_event_cqm *)data;
+	switch (p->status) {
+	case SPRDWL_CQM_RSSI_LOW:
+		rssi_event = NL80211_CQM_RSSI_THRESHOLD_EVENT_LOW;
+		break;
+	case SPRDWL_CQM_RSSI_HIGH:
+		rssi_event = NL80211_CQM_RSSI_THRESHOLD_EVENT_HIGH;
+		break;
+	case SPRDWL_CQM_BEACON_LOSS:
+		/* TODO wpa_supplicant not support the event ,
+		 * so we workaround this issue
+		 */
+		rssi_event = NL80211_CQM_RSSI_THRESHOLD_EVENT_LOW;
+		vif->beacon_loss = 1;
+		break;
+	default:
+		wl_ndev_log(L_ERR, vif->ndev, "%s invalid event!\n", __func__);
+		return;
+	}
+
+	sprdwl_report_cqm(vif, rssi_event);
+}
+
+void sprdwl_event_tdls(struct sprdwl_vif *vif, u8 *data, u16 len)
+{
+	unsigned char peer[ETH_ALEN];
+	u8 oper;
+	u16 reason_code;
+	struct sprdwl_event_tdls *report_tdls = NULL;
+
+	report_tdls = (struct sprdwl_event_tdls *)data;
+	ether_addr_copy(&peer[0], &report_tdls->mac[0]);
+	oper = report_tdls->tdls_sub_cmd_mgmt;
+
+	if (SPRDWL_TDLS_TEARDOWN == oper)
+		oper = NL80211_TDLS_TEARDOWN;
+	else if (SPRDWL_TDLS_UPDATE_PEER_INFOR == oper)
+		sprdwl_event_tdls_flow_count(vif, data, len);
+	else {
+		oper = NL80211_TDLS_SETUP;
+		sprdwl_tdls_flow_flush(vif, peer, oper);
+	}
+
+	reason_code = 0;
+	sprdwl_report_tdls(vif, peer, oper, reason_code);
+}
+
+int sprdwl_send_tdlsdata_use_cmd(struct sk_buff *skb,
+				  struct sprdwl_vif *vif, u8 need_cp2_rsp)
+{
+	struct sprdwl_msg_buf *msg;
+	struct sprdwl_cmd_tdls *p;
+	struct sprdwl_intf *intf;
+
+	intf = (struct sprdwl_intf *)(vif->priv->hw_priv);
+	msg = sprdwl_cmd_getbuf(vif->priv, sizeof(*p) + skb->len, vif->ctx_id,
+		SPRDWL_HEAD_RSP, WIFI_CMD_TDLS);
+	if (!msg)
+		return -ENOMEM;
+	p = (struct sprdwl_cmd_tdls *)msg->data;
+	p->tdls_sub_cmd_mgmt = WLAN_TDLS_CMD_TX_DATA;
+	ether_addr_copy(p->da, skb->data);
+	p->paylen = skb->len;/*TBD*/
+	memcpy(p->payload, skb->data, skb->len);
+
+	if (need_cp2_rsp)
+		return sprdwl_cmd_send_recv(vif->priv, msg,
+			CMD_WAIT_TIMEOUT, NULL, NULL);
+	else
+		return sprdwl_cmd_send_recv_no_wait(vif->priv, msg);
+}
+
+inline void sprdwl_event_ba_mgmt(struct sprdwl_vif *vif, u8 *data, u16 len)
+{
+	wlan_ba_session_event(vif->priv->hw_priv, data, len);
+}
+
+void sprdwl_event_suspend_resume(struct sprdwl_vif *vif, u8 *data, u16 len)
+{
+	struct sprdwl_event_suspend_resume *suspend_resume = NULL;
+	struct sprdwl_intf *intf = (struct sprdwl_intf *)(vif->priv->hw_priv);
+	struct sprdwl_tx_msg *tx_msg = (struct sprdwl_tx_msg *)intf->sprdwl_tx;
+
+	suspend_resume = (struct sprdwl_event_suspend_resume *)data;
+	if ((1 == suspend_resume->status) &&
+		(intf->suspend_mode == SPRDWL_PS_RESUMING)) {
+		intf->suspend_mode = SPRDWL_PS_RESUMED;
+		tx_up(tx_msg);
+		wl_info("%s, %d,resumed,wakeuptx\n", __func__, __LINE__);
+	}
+}
+
+void sprdwl_event_hang_recovery(struct sprdwl_vif *vif, u8 *data, u16 len)
+{
+	struct event_hang_recovery *hang =
+		(struct event_hang_recovery *)data;
+	struct sprdwl_intf *intf = (struct sprdwl_intf *)(vif->priv->hw_priv);
+	struct sprdwl_tx_msg *tx_msg = (struct sprdwl_tx_msg *)intf->sprdwl_tx;
+
+	tx_msg->hang_recovery_status = hang->action;
+	wl_info("%s, %d, action=%d, status=%d\n",
+		__func__, __LINE__,
+		hang->action,
+		tx_msg->hang_recovery_status);
+	if (hang->action == HANG_RECOVERY_BEGIN)
+		sprdwl_add_hang_cmd(vif);
+	if (hang->action == HANG_RECOVERY_END)
+		tx_up(tx_msg);
+}
+
+void sprdwl_event_thermal_warn(struct sprdwl_vif *vif, u8 *data, u16 len)
+{
+	struct event_thermal_warn *thermal =
+		(struct event_thermal_warn *)data;
+	struct sprdwl_intf *intf = (struct sprdwl_intf *)(vif->priv->hw_priv);
+	struct sprdwl_tx_msg *tx_msg = (struct sprdwl_tx_msg *)intf->sprdwl_tx;
+	enum sprdwl_mode mode;
+
+	wl_info("%s, %d, action=%d, status=%d\n",
+		__func__, __LINE__,
+		thermal->action,
+		tx_msg->thermal_status);
+	if (tx_msg->thermal_status == THERMAL_WIFI_DOWN)
+		return;
+	tx_msg->thermal_status = thermal->action;
+	switch (thermal->action) {
+	case THERMAL_TX_RESUME:
+		sprdwl_net_flowcontrl(intf->priv, SPRDWL_MODE_NONE, true);
+		tx_up(tx_msg);
+		break;
+	case THERMAL_TX_STOP:
+		wl_err("%s, %d, netif_stop_queue because of thermal warn\n",
+		       __func__, __LINE__);
+		sprdwl_net_flowcontrl(intf->priv, SPRDWL_MODE_NONE, false);
+		break;
+	case THERMAL_WIFI_DOWN:
+		wl_err("%s, %d, close wifi because of thermal warn\n",
+		       __func__, __LINE__);
+		sprdwl_net_flowcontrl(intf->priv, SPRDWL_MODE_NONE, false);
+		for (mode = SPRDWL_MODE_STATION; mode < SPRDWL_MODE_MAX; mode++) {
+			if (intf->priv->fw_stat[mode] == SPRDWL_INTF_OPEN)
+				sprdwl_add_close_cmd(vif, mode);
+		}
+		break;
+	default:
+		break;
+	}
+}
+
+#define WIFI_EVENT_WFD_RATE 0x30
+extern int wfd_notifier_call_chain(unsigned long val, void *v);
+
+void sprdwl_wfd_mib_cnt(struct sprdwl_vif *vif, u8 *data, u16 len)
+{
+	struct event_wfd_mib_cnt *wfd =
+		(struct event_wfd_mib_cnt *)data;
+	u32 tx_cnt, busy_cnt, wfd_rate = 0;
+
+	wl_info("%s, %d, tp=%d, sum_tp=%d, drop=%d,%d,%d,%d, frame=%d, clear=%d, mib=%d\n",
+		__func__, __LINE__,
+		wfd->wfd_throughput, wfd->sum_tx_throughput,
+		wfd->tx_mpdu_lost_cnt[0], wfd->tx_mpdu_lost_cnt[1], wfd->tx_mpdu_lost_cnt[2], wfd->tx_mpdu_lost_cnt[3],
+		wfd->tx_frame_cnt, wfd->rx_clear_cnt, wfd->mib_cycle_cnt);
+
+	if (!wfd->mib_cycle_cnt)
+		return;
+
+	tx_cnt = wfd->tx_frame_cnt / wfd->mib_cycle_cnt;
+	busy_cnt = (10 * wfd->rx_clear_cnt) / wfd->mib_cycle_cnt;
+
+	if (busy_cnt > 8)
+		wfd_rate = wfd->sum_tx_throughput;
+	else{
+		if (tx_cnt)
+			wfd_rate = wfd->sum_tx_throughput + wfd->sum_tx_throughput * (1 / tx_cnt) * ((10 - busy_cnt) / 10) / 2;
+	}
+	wl_info("%s, %d, wfd_rate=%d\n", __func__, __LINE__, wfd_rate);
+	wfd_rate = 2;
+	/* wfd_notifier_call_chain(WIFI_EVENT_WFD_RATE, (void *)(unsigned long)wfd_rate); */
+}
+
+int sprdwl_fw_power_down_ack(struct sprdwl_priv *priv, u8 ctx_id)
+{
+	struct sprdwl_msg_buf *msg;
+	struct sprdwl_cmd_power_save *p;
+	int ret = 0;
+	struct sprdwl_intf *intf = (struct sprdwl_intf *)(priv->hw_priv);
+	struct sprdwl_tx_msg *tx_msg = (struct sprdwl_tx_msg *)intf->sprdwl_tx;
+	enum sprdwl_mode mode = SPRDWL_MODE_NONE;
+	int tx_num = 0;
+
+	msg = sprdwl_cmd_getbuf(priv, sizeof(*p), ctx_id,
+				SPRDWL_HEAD_RSP, WIFI_CMD_POWER_SAVE);
+	if (!msg)
+		return -ENOMEM;
+
+	p = (struct sprdwl_cmd_power_save *)msg->data;
+	p->sub_type = SPRDWL_FW_PWR_DOWN_ACK;
+
+	for (mode = SPRDWL_MODE_NONE; mode < SPRDWL_MODE_MAX; mode++) {
+		int num = atomic_read(&tx_msg->tx_list[mode]->mode_list_num);
+
+		tx_num += num;
+	}
+
+	if (tx_num > 0 ||
+	    !list_empty(&tx_msg->xmit_msg_list.to_send_list) ||
+	    !list_empty(&tx_msg->xmit_msg_list.to_free_list)) {
+		if (intf->fw_power_down == 1)
+			goto err;
+		p->value = 0;
+		intf->fw_power_down = 0;
+		intf->fw_awake = 1;
+	} else {
+		p->value = 1;
+		intf->fw_power_down = 1;
+		intf->fw_awake = 0;
+	}
+	wl_info("%s, value=%d, fw_pwr_down=%d, fw_awake=%d, %d, %d, %d, %d\n",
+		__func__,
+		p->value,
+		intf->fw_power_down,
+		intf->fw_awake,
+		atomic_read(&tx_msg->tx_list_qos_pool.ref),
+		tx_num,
+		list_empty(&tx_msg->xmit_msg_list.to_send_list),
+		list_empty(&tx_msg->xmit_msg_list.to_free_list));
+
+	ret =  sprdwl_cmd_send_recv(priv, msg, CMD_WAIT_TIMEOUT, NULL, NULL);
+
+	if (intf->fw_power_down == 1) {
+		sprdwl_unboost();
+	}
+
+	if (ret)
+		wl_err("host send data cmd failed, ret=%d\n", ret);
+
+	return ret;
+err:
+	wl_err("%s donot ack FW_PWR_DOWN twice\n", __func__);
+	sprdwl_intf_free_msg_buf(priv, msg);
+	return -1;
+}
+
+void sprdwl_event_fw_power_down(struct sprdwl_vif *vif, u8 *data, u16 len)
+{
+	struct sprdwl_work *misc_work;
+
+	misc_work = sprdwl_alloc_work(0);
+	if (!misc_work) {
+		wl_err("%s out of memory\n", __func__);
+		return;
+	}
+	misc_work->vif = vif;
+	misc_work->id = SPRDWL_WORK_FW_PWR_DOWN;
+
+	sprdwl_queue_work(vif->priv, misc_work);
+}
+
+void sprdwl_event_chan_changed(struct sprdwl_vif *vif, u8 *data, u16 len)
+{
+	struct sprdwl_chan_changed_info *p = (struct sprdwl_chan_changed_info *)data;
+	u8 channel;
+	u16 freq;
+	struct wiphy *wiphy = vif->wdev.wiphy;
+	struct ieee80211_channel *ch = NULL;
+	struct cfg80211_chan_def chandef;
+
+	if (p->initiator == 0) {
+		wl_err("%s, unknowed event!\n", __func__);
+	} else if (p->initiator == 1) {
+		channel = p->target_channel;
+		freq = 2412 + (channel-1) * 5;
+		if (wiphy)
+			ch = ieee80211_get_channel(wiphy, freq);
+		else
+			wl_err("%s, wiphy is null!\n", __func__);
+		if (ch)
+			/* we will be active on the channel */
+			cfg80211_chandef_create(&chandef, ch,
+						NL80211_CHAN_HT20);
+		else
+			wl_err("%s, ch is null!\n", __func__);
+		cfg80211_ch_switch_notify(vif->ndev, &chandef);
+	}
+}
+
+void sprdwl_event_coex_bt_on_off(u8 *data, u16 len)
+{
+	struct event_coex_mode_changed *coex_bt_on_off =
+		(struct event_coex_mode_changed *)data;
+
+	wl_info("%s, %d, action=%d\n",
+		__func__, __LINE__,
+		coex_bt_on_off->action);
+	set_coex_bt_on_off(coex_bt_on_off->action);
+}
+
+#define E2S(x) \
+{ \
+	case x: \
+		str = #x; \
+		break; \
+}
+
+static const char *evt2str(u8 evt)
+{
+	const char *str = NULL;
+
+	switch (evt) {
+	E2S(WIFI_EVENT_CONNECT)
+	E2S(WIFI_EVENT_DISCONNECT)
+	E2S(WIFI_EVENT_SCAN_DONE)
+	E2S(WIFI_EVENT_MGMT_FRAME)
+	E2S(WIFI_EVENT_MGMT_TX_STATUS)
+	E2S(WIFI_EVENT_REMAIN_CHAN_EXPIRED)
+	E2S(WIFI_EVENT_MIC_FAIL)
+	E2S(WIFI_EVENT_NEW_STATION)
+	E2S(WIFI_EVENT_CQM)
+	E2S(WIFI_EVENT_MEASUREMENT)
+	E2S(WIFI_EVENT_TDLS)
+	E2S(WIFI_EVENT_SDIO_SEQ_NUM)
+	E2S(WIFI_EVENT_SDIO_FLOWCON)
+	E2S(WIFI_EVENT_BA)
+	E2S(WIFI_EVENT_RSSI_MONITOR)
+	E2S(WIFI_EVENT_GSCAN_FRAME)
+#ifdef DFS_MASTER
+	E2S(WIFI_EVENT_RADAR_DETECTED)
+#endif
+	E2S(WIFI_EVENT_STA_LUT_INDEX)
+	E2S(WIFI_EVENT_SUSPEND_RESUME)
+	E2S(WIFI_EVENT_NAN)
+	E2S(WIFI_EVENT_RTT)
+	E2S(WIFI_EVENT_HANG_RECOVERY)
+	E2S(WIFI_EVENT_THERMAL_WARN)
+	E2S(WIFI_EVENT_WFD_MIB_CNT)
+	E2S(WIFI_EVENT_FW_PWR_DOWN)
+	default :
+		return "WIFI_EVENT_UNKNOWN";
+	}
+
+	return str;
+}
+
+#undef E2S
+
+/* retrun the msg length or 0 */
+unsigned short sprdwl_rx_event_process(struct sprdwl_priv *priv, u8 *msg)
+{
+	struct sprdwl_cmd_hdr *hdr = (struct sprdwl_cmd_hdr *)msg;
+	struct sprdwl_vif *vif;
+	u8 ctx_id;
+	u16 len, plen;
+	u8 *data;
+
+	ctx_id = hdr->common.ctx_id;
+	/*TODO ctx_id range*/
+#ifndef CONFIG_P2P_INTF
+	if (ctx_id > STAP_MODE_P2P_DEVICE) {
+#else
+	if (ctx_id >= STAP_MODE_COEXI_NUM) {
+#endif
+		wl_info("%s invalid ctx_id: %d\n", __func__, ctx_id);
+		return 0;
+	}
+
+	plen = SPRDWL_GET_LE16(hdr->plen);
+	if (!priv) {
+		wl_err("%s priv is NULL [%u]ctx_id %d recv[%s]len: %d\n",
+		       __func__, le32_to_cpu(hdr->mstime), ctx_id,
+		       evt2str(hdr->cmd_id), hdr->plen);
+		return plen;
+	}
+
+	wl_debug("[%u]ctx_id %d recv[%s]len: %d\n",
+		le32_to_cpu(hdr->mstime), ctx_id,
+		evt2str(hdr->cmd_id), plen);
+
+	wl_hex_dump(L_DBG, "EVENT: ", DUMP_PREFIX_OFFSET, 16, 1,
+			     (u8 *)hdr, hdr->plen, 0);
+
+	len = plen - sizeof(*hdr);
+	vif = ctx_id_to_vif(priv, ctx_id);
+	if (!vif) {
+		wl_info("%s NULL vif for ctx_id: %d, len:%d\n",
+			__func__, ctx_id, plen);
+		return plen;
+	}
+
+	if (!((long)msg & 0x3)) {
+		data = (u8 *)msg;
+		data += sizeof(*hdr);
+	} else {
+		/* never into here when the dev is BA or MARLIN2,
+		 * temply used as debug and safe
+		 */
+		WARN_ON(1);
+		data = kmalloc(len, GFP_KERNEL);
+		if (!data) {
+			sprdwl_put_vif(vif);
+			return plen;
+		}
+		memcpy(data, msg + sizeof(*hdr), len);
+	}
+
+	switch (hdr->cmd_id) {
+	case WIFI_EVENT_CONNECT:
+		sprdwl_event_connect(vif, data, len);
+		break;
+	case WIFI_EVENT_DISCONNECT:
+		sprdwl_event_disconnect(vif, data, len);
+		break;
+	case WIFI_EVENT_REMAIN_CHAN_EXPIRED:
+		sprdwl_event_remain_on_channel_expired(vif, data, len);
+		break;
+	case WIFI_EVENT_NEW_STATION:
+		sprdwl_event_station(vif, data, len);
+		break;
+	case WIFI_EVENT_MGMT_FRAME:
+		/* for old Marlin2 CP code or BA*/
+		sprdwl_event_frame(vif, data, len, 0);
+		break;
+	case WIFI_EVENT_GSCAN_FRAME:
+		sprdwl_event_gscan_frame(vif, data, len);
+		break;
+	case WIFI_EVENT_RSSI_MONITOR:
+		sprdwl_event_rssi_monitor(vif, data, len);
+		break;
+	case WIFI_EVENT_SCAN_DONE:
+		sprdwl_event_scan_done(vif, data, len);
+		break;
+	case WIFI_EVENT_SDIO_SEQ_NUM:
+		break;
+	case WIFI_EVENT_MIC_FAIL:
+		sprdwl_event_mic_failure(vif, data, len);
+		break;
+	case WIFI_EVENT_CQM:
+		sprdwl_event_cqm(vif, data, len);
+		break;
+	case WIFI_EVENT_MGMT_TX_STATUS:
+		sprdwl_event_mlme_tx_status(vif, data, len);
+		break;
+	case WIFI_EVENT_TDLS:
+		sprdwl_event_tdls(vif, data, len);
+		break;
+	case WIFI_EVENT_SUSPEND_RESUME:
+		sprdwl_event_suspend_resume(vif, data, len);
+		break;
+#ifdef NAN_SUPPORT
+	case WIFI_EVENT_NAN:
+		sprdwl_event_nan(vif, data, len);
+		break;
+#endif /* NAN_SUPPORT */
+	case WIFI_EVENT_STA_LUT_INDEX:
+		sprdwl_event_sta_lut(vif, data, len);
+		break;
+	case WIFI_EVENT_BA:
+		sprdwl_event_ba_mgmt(vif, data, len);
+		break;
+#ifdef DFS_MASTER
+	case WIFI_EVENT_RADAR_DETECTED:
+		sprdwl_11h_handle_radar_detected(vif, data, len);
+		break;
+#endif
+#ifdef RTT_SUPPORT
+	case WIFI_EVENT_RTT:
+		sprdwl_event_ftm(vif, data, len);
+		break;
+#endif /* RTT_SUPPORT */
+	case WIFI_EVENT_HANG_RECOVERY:
+		sprdwl_event_hang_recovery(vif, data, len);
+		break;
+	case WIFI_EVENT_THERMAL_WARN:
+		sprdwl_event_thermal_warn(vif, data, len);
+		break;
+	case WIFI_EVENT_WFD_MIB_CNT:
+		sprdwl_wfd_mib_cnt(vif, data, len);
+		break;
+	case WIFI_EVENT_FW_PWR_DOWN:
+		sprdwl_event_fw_power_down(vif, data, len);
+		break;
+	case WIFI_EVENT_SDIO_FLOWCON:
+		break;
+	case WIFI_EVENT_CHAN_CHANGED:
+		sprdwl_event_chan_changed(vif, data, len);
+		break;
+	case WIFI_EVENT_COEX_BT_ON_OFF:
+		sprdwl_event_coex_bt_on_off(data, len);
+		break;
+	default:
+		wl_info("unsupported event: %d\n", hdr->cmd_id);
+		break;
+	}
+
+	sprdwl_put_vif(vif);
+
+	if ((long)msg & 0x3)
+		kfree(data);
+
+	return plen;
+}
+
+int sprdwl_set_tlv_data(struct sprdwl_priv *priv, u8 ctx_id,
+			struct sprdwl_tlv_data *tlv, int length)
+{
+	struct sprdwl_msg_buf *msg;
+
+	if (priv == NULL || tlv == NULL)
+		return -EINVAL;
+
+	msg = sprdwl_cmd_getbuf(priv, length, ctx_id,
+				SPRDWL_HEAD_RSP, WIFI_CMD_SET_TLV);
+	if (!msg)
+		return -ENOMEM;
+
+	memcpy(msg->data, tlv, length);
+
+	wl_info("%s tlv type = %d\n", __func__, tlv->type);
+
+	return sprdwl_cmd_send_recv(priv, msg, CMD_WAIT_TIMEOUT, NULL, NULL);
+}
+
+void sprdwl_set_tlv_elmt(u8 *addr, u16 type, u16 len, u8 *data)
+{
+	struct sprdwl_tlv_data *p = (struct sprdwl_tlv_data *)addr;
+
+	p->type = type;
+	p->len = len;
+	memcpy(p->data, data, len);
+}
+
+int sprdwl_set_wowlan(struct sprdwl_priv *priv, int subcmd, void *pad, int pad_len)
+{
+	struct sprdwl_msg_buf *msg;
+	struct wowlan_cmd {
+		u8 sub_cmd_id;
+		u8 pad_len;
+		char pad[0];
+	} *cmd;
+
+	if (priv == NULL)
+		return -EINVAL;
+
+	msg = sprdwl_cmd_getbuf(priv, pad_len + sizeof(struct wowlan_cmd), SPRDWL_MODE_NONE,
+			SPRDWL_HEAD_RSP, WIFI_CMD_SET_WOWLAN);
+	if (!msg)
+		return -ENOMEM;
+
+	cmd = (struct wowlan_cmd *)msg->data;
+	cmd->sub_cmd_id = subcmd;
+	cmd->pad_len = pad_len;
+
+	wl_debug("%s subcmd = %d, len = %d\n", __func__, cmd->sub_cmd_id, cmd->pad_len);
+	if (pad_len)
+		memcpy(cmd->pad, pad, pad_len);
+
+	return sprdwl_cmd_send_recv(priv, msg, CMD_WAIT_TIMEOUT, NULL, NULL);
+}
+
+#ifdef SYNC_DISCONNECT
+int sprdwl_sync_disconnect_event(struct sprdwl_vif *vif, unsigned int timeout)
+{
+	int ret;
+
+	sprdwl_cmd_lock(&g_sprdwl_cmd);
+	vif->disconnect_event_code = 0;
+	ret = wait_event_timeout(vif->disconnect_wq,
+				 atomic_read(&vif->sync_disconnect_event) == 0, timeout);
+	sprdwl_cmd_unlock(&g_sprdwl_cmd);
+
+	return ret;
+}
+#endif
+
+int sprdwl_set_packet_offload(struct sprdwl_priv *priv, u8 vif_ctx_id,
+			      u32 req, u8 enable, u32 interval,
+			      u32 len, u8 *data)
+{
+	struct sprdwl_msg_buf *msg;
+	struct sprdwl_cmd_packet_offload *p;
+	struct sprdwl_cmd_packet_offload *packet = NULL;
+	u16 r_len = sizeof(*packet);
+	u8 r_buf[r_len];
+
+	msg = sprdwl_cmd_getbuf(priv, sizeof(*p) + len, vif_ctx_id,
+				SPRDWL_HEAD_RSP, WIFI_CMD_PACKET_OFFLOAD);
+	if (!msg)
+		return -ENOMEM;
+	p = (struct sprdwl_cmd_packet_offload *)msg->data;
+
+	p->enable = enable;
+	p->req_id = req;
+	if (enable) {
+		p->period = interval;
+		p->len = len;
+		memcpy(p->data, data, len);
+	}
+
+	return sprdwl_cmd_send_recv(priv, msg, CMD_WAIT_TIMEOUT, r_buf, &r_len);
+}
diff --git a/drivers/net/wireless/uwe5622/unisocwifi/cmdevt.h b/drivers/net/wireless/uwe5622/unisocwifi/cmdevt.h
new file mode 100644
index 000000000000..2152d2559344
--- /dev/null
+++ b/drivers/net/wireless/uwe5622/unisocwifi/cmdevt.h
@@ -0,0 +1,1125 @@
+/*
+ * Copyright (C) 2015 Spreadtrum Communications Inc.
+ *
+ * Authors	:
+ * Keguang Zhang <keguang.zhang@spreadtrum.com>
+ * Jingxiang Li <Jingxiang.li@spreadtrum.com>
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#ifndef __SPRDWL_CMD_H__
+#define __SPRDWL_CMD_H__
+
+#include "msg.h"
+#include <linux/math64.h>
+#include <linux/pm_wakeup.h>
+
+#define SPRDWL_VALID_CONFIG		(0x80)
+#define  CMD_WAIT_TIMEOUT		(3000)
+#define CMD_DISCONNECT_TIMEOUT		(5500)
+/* Set scan timeout to 9s due to split scan
+ * to several period in CP2
+ * Framework && wpa_supplicant timeout is 10s
+ * so it should be smaller than 10s
+ * Please don't change it!!!
+ */
+#define  CMD_SCAN_WAIT_TIMEOUT	(9000)
+/* cipher type */
+#define SPRDWL_CIPHER_NONE		0
+#define SPRDWL_CIPHER_WEP40		1
+#define SPRDWL_CIPHER_WEP104		2
+#define SPRDWL_CIPHER_TKIP		3
+#define SPRDWL_CIPHER_CCMP		4
+#define SPRDWL_CIPHER_AP_TKIP		5
+#define SPRDWL_CIPHER_AP_CCMP		6
+#define SPRDWL_CIPHER_WAPI		7
+#define SPRDWL_CIPHER_AES_CMAC		8
+#define SPRDWL_MAX_SDIO_SEND_COUT	1024
+#define SPRDWL_SCHED_SCAN_BUF_END	(1<<0)
+
+#define SPRDWL_SEND_FLAG_IFRC		(1<<0)
+#define SPRDWL_SEND_FLAG_SSID		(1<<1)
+#define SPRDWL_SEND_FLAG_MSSID		(1<<2)
+#define SPRDWL_SEND_FLAG_IE		(1<<4)
+
+#define SPRDWL_TDLS_ENABLE_LINK		11
+#define SPRDWL_TDLS_DISABLE_LINK	12
+#define SPRDWL_TDLS_TEARDOWN		3
+#define SPRDWL_TDLS_DISCOVERY_RESPONSE		14
+#define SPRDWL_TDLS_START_CHANNEL_SWITCH	13
+#define SPRDWL_TDLS_CANCEL_CHANNEL_SWITCH	14
+#define WLAN_TDLS_CMD_TX_DATA   0x11
+#define SPRDWL_TDLS_UPDATE_PEER_INFOR	15
+#define SPRDWL_TDLS_CMD_CONNECT	16
+
+#define SPRDWL_IPV4			1
+#define SPRDWL_IPV6			2
+#define SPRDWL_IPV4_ADDR_LEN		4
+#define SPRDWL_IPV6_ADDR_LEN		16
+
+/* wnm feature */
+#define SPRDWL_11V_BTM                  BIT(0)
+#define SPRDWL_11V_PARP                 BIT(1)
+#define SPRDWL_11V_MIPM                 BIT(2)
+#define SPRDWL_11V_DMS                  BIT(3)
+#define SPRDWL_11V_SLEEP                BIT(4)
+#define SPRDWL_11V_TFS                  BIT(5)
+#define SPRDWL_11V_ALL_FEATURE          0xFFFF
+
+extern unsigned int wfa_cap;
+enum SPRDWL_CMD_LIST {
+	WIFI_CMD_MIN = 0,
+	WIFI_CMD_ERR = WIFI_CMD_MIN,
+	/* All Interface */
+	WIFI_CMD_GET_INFO = 1,
+	WIFI_CMD_SET_REGDOM,
+	WIFI_CMD_OPEN,
+	WIFI_CMD_CLOSE,
+	WIFI_CMD_POWER_SAVE,
+	WIFI_CMD_SET_PARAM,
+	WIFI_CMD_SET_CHANNEL,
+	WIFI_CMD_REQ_LTE_CONCUR,
+	WIFI_CMD_SYNC_VERSION = 9,
+	/* Connect */
+	WIFI_CMD_CONNECT = 10,
+
+	/* Station */
+	WIFI_CMD_SCAN = 11,
+	WIFI_CMD_SCHED_SCAN,
+	WIFI_CMD_DISCONNECT,
+	WIFI_CMD_KEY,
+	WIFI_CMD_SET_PMKSA,
+	WIFI_CMD_GET_STATION,
+
+	/* SoftAP */
+	WIFI_CMD_START_AP = 17,
+	WIFI_CMD_DEL_STATION,
+	WIFI_CMD_SET_BLACKLIST,
+	WIFI_CMD_SET_WHITELIST,
+
+	/* P2P */
+	WIFI_CMD_TX_MGMT = 21,
+	WIFI_CMD_REGISTER_FRAME,
+	WIFI_CMD_REMAIN_CHAN,
+	WIFI_CMD_CANCEL_REMAIN_CHAN,
+
+	/* Public/New Feature */
+	WIFI_CMD_SET_IE = 25,
+	WIFI_CMD_NOTIFY_IP_ACQUIRED,
+	/* Roaming */
+	WIFI_CMD_SET_CQM,	/* Uplayer Roaming */
+	WIFI_CMD_SET_ROAM_OFFLOAD,	/* fw Roaming */
+	WIFI_CMD_SET_MEASUREMENT,
+	WIFI_CMD_SET_QOS_MAP,
+	WIFI_CMD_TDLS,
+	WIFI_CMD_11V,
+
+	/* NPI/DEBUG/OTHER */
+	WIFI_CMD_NPI_MSG = 33,
+	WIFI_CMD_NPI_GET,
+
+	WIFI_CMD_ASSERT,
+	WIFI_CMD_FLUSH_SDIO,
+
+	/* WMM Admisson Control */
+	WIFI_CMD_ADD_TX_TS = 37,
+	WIFI_CMD_DEL_TX_TS = 38,
+
+	/* Multicast filter */
+	WIFI_CMD_MULTICAST_FILTER,
+
+	WIFI_CMD_ADDBA_REQ = 40,
+	WIFI_CMD_DELBA_REQ,
+
+	WIFI_CMD_LLSTAT = 56,
+
+	WIFI_CMD_CHANGE_BSS_IBSS_MODE = 57,
+
+	/* IBSS */
+	WIFI_CMD_IBSS_JOIN = 58,
+	WIFI_CMD_SET_IBSS_ATTR,
+	WIFI_CMD_IBSS_LEAVE,
+	WIFI_CMD_IBSS_VSIE_SET,
+	WIFI_CMD_IBSS_VSIE_DELETE,
+	WIFI_CMD_IBSS_SET_PS,
+	WIFI_CMD_RND_MAC = 64,
+	/* gscan */
+	WIFI_CMD_GSCAN = 65,
+
+	WIFI_CMD_RTT = 66,
+	/* NAN */
+	WIFI_CMD_NAN = 67,
+
+	/* BA */
+	WIFI_CMD_BA = 68,
+
+	WIFI_CMD_SET_PROTECT_MODE = 69,
+	WIFI_CMD_GET_PROTECT_MODE,
+
+	WIFI_CMD_SET_MAX_CLIENTS_ALLOWED,
+	WIFI_CMD_TX_DATA = 72,
+	WIFI_CMD_NAN_DATA_PATH = 73,
+	WIFI_CMD_SET_TLV = 74,
+	WIFI_CMD_RSSI_MONITOR = 75,
+	WIFI_CMD_DOWNLOAD_INI = 76,
+	WIFI_CMD_RADAR_DETECT = 77,
+	WIFI_CMD_HANG_RECEIVED = 78,
+	WIFI_CMD_RESET_BEACON = 79,
+	WIFI_CMD_VOWIFI_DATA_PROTECT = 80,
+	WIFI_CMD_SET_WOWLAN = 83,
+	WIFI_CMD_PACKET_OFFLOAD = 84,
+	/*Please add new command above line,
+	* conditional compile flag is not recommended
+	*/
+	WIFI_CMD_MAX
+};
+
+enum SPRDWL_WOWLAN_SUBCMD {
+	SPRDWL_WOWLAN_ANY,
+	SPRDWL_WOWLAN_MAGIC_PKT,
+	SPRDWL_WOWLAN_DISCONNECT,
+};
+
+enum SPRDWL_SUBCMD {
+	SPRDWL_SUBCMD_GET = 1,
+	SPRDWL_SUBCMD_SET,
+	SPRDWL_SUBCMD_ADD,
+	SPRDWL_SUBCMD_DEL,
+	SPRDWL_SUBCMD_FLUSH,
+	SPRDWL_SUBCMD_UPDATE,
+	SPRDWL_SUBCMD_ENABLE,
+	SPRDWL_SUBCMD_DISABLE,
+	SPRDWL_SUBCMD_REKEY,
+	SPRDWL_SUBCMD_MAX
+};
+
+enum GSCAN_SUB_COMMAND {
+	SPRDWL_GSCAN_SUBCMD_GET_CAPABILITIES,
+	SPRDWL_GSCAN_SUBCMD_SET_CONFIG,
+	SPRDWL_GSCAN_SUBCMD_SET_SCAN_CONFIG,
+	SPRDWL_GSCAN_SUBCMD_ENABLE_GSCAN,
+	SPRDWL_GSCAN_SUBCMD_GET_SCAN_RESULTS,
+	SPRDWL_GSCAN_SUBCMD_SCAN_RESULTS,
+	SPRDWL_GSCAN_SUBCMD_SET_HOTLIST,
+	SPRDWL_GSCAN_SUBCMD_SET_SIGNIFICANT_CHANGE_CONFIG,
+	SPRDWL_GSCAN_SUBCMD_ENABLE_FULL_SCAN_RESULTS,
+	SPRDWL_GSCAN_SUBCMD_GET_CHANNEL_LIST,
+	SPRDWL_WIFI_SUBCMD_GET_FEATURE_SET,
+	SPRDWL_WIFI_SUBCMD_GET_FEATURE_SET_MATRIX,
+	SPRDWL_WIFI_SUBCMD_SET_PNO_RANDOM_MAC_OUI,
+	SPRDWL_WIFI_SUBCMD_NODFS_SET,
+	SPRDWL_WIFI_SUBCMD_SET_COUNTRY_CODE,
+	/* Add more sub commands here */
+	SPRDWL_GSCAN_SUBCMD_SET_EPNO_SSID,
+	SPRDWL_WIFI_SUBCMD_SET_SSID_WHITE_LIST,
+	SPRDWL_WIFI_SUBCMD_SET_ROAM_PARAMS,
+	SPRDWL_WIFI_SUBCMD_ENABLE_LAZY_ROAM,
+	SPRDWL_WIFI_SUBCMD_SET_BSSID_PREF,
+	SPRDWL_WIFI_SUBCMD_SET_BSSID_BLACKLIST,
+	SPRDWL_GSCAN_SUBCMD_ANQPO_CONFIG,
+	SPRDWL_WIFI_SUBCMD_SET_RSSI_MONITOR,
+	SPRDWL_GSCAN_SUBCMD_SET_SSID_HOTLIST,
+	SPRDWL_GSCAN_SUBCMD_RESET_HOTLIST,
+	SPRDWL_GSCAN_SUBCMD_RESET_SIGNIFICANT_CHANGE_CONFIG,
+	SPRDWL_GSCAN_SUBCMD_RESET_SSID_HOTLIST,
+	SPRDWL_WIFI_SUBCMD_RESET_BSSID_BLACKLIST,
+	SPRDWL_GSCAN_SUBCMD_RESET_ANQPO_CONFIG,
+	SPRDWL_GSCAN_SUBCMD_SET_EPNO_FLUSH,
+	/* Add more sub commands here */
+	SPRDWL_GSCAN_SUBCMD_MAX
+};
+
+/*CMD SYNC_VERSION struct*/
+struct sprdwl_cmd_api_t {
+	u32 main_ver;
+	u8 api_map[256];
+};
+
+/*wiphy section2 info struct use for get info CMD*/
+struct wiphy_sec2_t {
+	u16 ht_cap_info;
+	u16 ampdu_para;
+	struct ieee80211_mcs_info ht_mcs_set;
+	u32 vht_cap_info;
+	struct ieee80211_vht_mcs_info  vht_mcs_set;
+	u32 antenna_tx;
+	u32 antenna_rx;
+	u8 retry_short;
+	u8 retry_long;
+	u16 reserved;
+	u32 frag_threshold;
+	u32 rts_threshold;
+};
+
+/* WIFI_CMD_GET_INFO
+ * @SPRDWL_STD_11D:  The fw supports regulatory domain.
+ * @SPRDWL_STD_11E:  The fw supports WMM/WMM-AC/WMM-PS.
+ * @SPRDWL_STD_11K:  The fw supports Radio Resource Measurement.
+ * @SPRDWL_STD_11R:  The fw supports FT roaming.
+ * @SPRDWL_STD_11U:  The fw supports Interworking Network.
+ * @SPRDWL_STD_11V:  The fw supports Wireless Network Management.
+ * @SPRDWL_STD_11W:  The fw supports Protected Management Frame.
+ *
+ * @SPRDWL_CAPA_5G:  The fw supports dual band (2.4G/5G).
+ * @SPRDWL_CAPA_MCC:  The fw supports Multi Channel Concurrency.
+ * @SPRDWL_CAPA_ACL:  The fw supports ACL.
+ * @SPRDWL_CAPA_AP_SME:  The fw integrates AP SME.
+ * @SPRDWL_CAPA_PMK_OKC_OFFLOAD:  The fw supports PMK/OKC roaming offload.
+ * @SPRDWL_CAPA_11R_ROAM_OFFLOAD:  The fw supports FT roaming offload.
+ * @SPRDWL_CAPA_SCHED_SCAN:  The fw supports scheduled scans.
+ * @SPRDWL_CAPA_TDLS:  The fw supports TDLS (802.11z) operation.
+ * @SPRDWL_CAPA_MC_FILTER:  The fw supports multicast filter operation.
+ * @SPRDWL_CAPA_NS_OFFLOAD:  The fw supports ipv6 NS operation.
+ * @SPRDWL_CAPA_RA_OFFLOAD:  The fw supports ipv6 RA offload.
+ * @SPRDWL_CAPA_LL_STATS:  The fw supports link layer stats.
+ */
+#define SEC1_LEN 24
+struct sprdwl_cmd_fw_info {
+	__le32 chip_model;
+	__le32 chip_version;
+	__le32 fw_version;
+#define SPRDWL_STD_11D			BIT(0)
+#define SPRDWL_STD_11E			BIT(1)
+#define SPRDWL_STD_11K			BIT(2)
+#define SPRDWL_STD_11R			BIT(3)
+#define SPRDWL_STD_11U			BIT(4)
+#define SPRDWL_STD_11V			BIT(5)
+#define SPRDWL_STD_11W			BIT(6)
+	__le32 fw_std;
+#define SPRDWL_CAPA_5G			BIT(0)
+#define SPRDWL_CAPA_MCC			BIT(1)
+#define SPRDWL_CAPA_ACL			BIT(2)
+#define SPRDWL_CAPA_AP_SME		BIT(3)
+#define SPRDWL_CAPA_PMK_OKC_OFFLOAD		BIT(4)
+#define SPRDWL_CAPA_11R_ROAM_OFFLOAD	BIT(5)
+#define SPRDWL_CAPA_SCHED_SCAN		BIT(6)
+#define SPRDWL_CAPA_TDLS			BIT(7)
+#define SPRDWL_CAPA_MC_FILTER		BIT(8)
+#define SPRDWL_CAPA_NS_OFFLOAD		BIT(9)
+#define SPRDWL_CAPA_RA_OFFLOAD		BIT(10)
+#define SPRDWL_CAPA_LL_STATS		BIT(11)
+#define SPRDWL_CAPA_NAN             BIT(12)
+#define SPRDWL_CAPA_CONFIG_NDO      BIT(13)
+#define SPRDWL_CAPA_D2D_RTT         BIT(14)
+#define SPRDWL_CAPA_D2AP_RTT        BIT(15)
+#define SPRDWL_CAPA_TDLS_OFFCHANNEL BIT(16)
+#define SPRDWL_CAPA_GSCAN			BIT(17)
+#define SPRDWL_CAPA_BATCH_SCAN		BIT(18)
+#define SPRDWL_CAPA_PNO				BIT(19)
+#define SPRDWL_CAPA_EPNO			BIT(20)
+#define SPRDWL_CAPA_RSSI_MONITOR	BIT(21)
+#define SPRDWL_CAPA_SCAN_RAND		BIT(22)
+#define SPRDWL_CAPA_ADDITIONAL_STA	BIT(23)
+#define SPRDWL_CAPA_EPR				BIT(24)
+#define SPRDWL_CAPA_AP_STA			BIT(25)
+#define SPRDWL_CAPA_WIFI_LOGGER		BIT(26)
+#define SPRDWL_CAPA_MKEEP_ALIVE		BIT(27)
+#define SPRDWL_CAPA_TX_POWER		BIT(28)
+#define SPRDWL_CAPA_IE_WHITELIST	BIT(29)
+	__le32 fw_capa;
+	u8 max_ap_assoc_sta;
+	u8 max_acl_mac_addrs;
+	u8 max_mc_mac_addrs;
+	u8 wnm_ft_support;
+	struct wiphy_sec2_t wiphy_sec2;
+	u8 mac_addr[ETH_ALEN];
+	/* with credit or without credit */
+#define TX_WITH_CREDIT	(0)
+#define TX_NO_CREDIT	(1)
+	unsigned char credit_capa;
+} __packed;
+
+/* WIFI_CMD_OPEN */
+struct sprdwl_cmd_open {
+	u8 mode;
+	u8 reserved;
+	u8 mac[ETH_ALEN];
+} __packed;
+
+/* WIFI_CMD_CLOSE */
+struct sprdwl_cmd_close {
+	u8 mode;
+} __packed;
+
+struct sprdwl_cmd_power_save {
+#define SPRDWL_SCREEN_ON_OFF	1
+#define SPRDWL_SET_FCC_CHANNEL	2
+#define SPRDWL_SET_TX_POWER	3
+#define SPRDWL_SET_PS_STATE	4
+#define SPRDWL_SUSPEND_RESUME  5
+#define SPRDWL_FW_PWR_DOWN_ACK 6
+#define SPRDWL_HOST_WAKEUP_FW 7
+	u8 sub_type;
+	u8 value;
+} __packed;
+
+struct sprdwl_cmd_vowifi {
+	u8 value;
+} __packed;
+
+struct sprdwl_cmd_add_key {
+	u8 key_index;
+	u8 pairwise;
+	u8 mac[ETH_ALEN];
+	u8 keyseq[16];
+	u8 cypher_type;
+	u8 key_len;
+	u8 value[0];
+} __packed;
+
+struct sprdwl_cmd_del_key {
+	u8 key_index;
+	u8 pairwise;		/* pairwise or group */
+	u8 mac[ETH_ALEN];
+} __packed;
+
+struct sprdwl_cmd_set_def_key {
+	u8 key_index;
+} __packed;
+
+struct sprdwl_cmd_set_rekey {
+	u8 kek[NL80211_KEK_LEN];
+	u8 kck[NL80211_KCK_LEN];
+	u8 replay_ctr[NL80211_REPLAY_CTR_LEN];
+} __packed;
+
+/* WIFI_CMD_SET_IE */
+struct sprdwl_cmd_set_ie {
+#define	SPRDWL_IE_BEACON		0
+#define	SPRDWL_IE_PROBE_REQ		1
+#define	SPRDWL_IE_PROBE_RESP		2
+#define	SPRDWL_IE_ASSOC_REQ		3
+#define	SPRDWL_IE_ASSOC_RESP		4
+#define	SPRDWL_IE_BEACON_HEAD		5
+#define	SPRDWL_IE_BEACON_TAIL		6
+	u8 type;
+	__le16 len;
+	u8 data[0];
+} __packed;
+
+/* WIFI_CMD_START_AP */
+struct sprdwl_cmd_start_ap {
+	__le16 len;
+	u8 value[0];
+} __packed;
+
+/* WIFI_CMD_DEL_STATION */
+struct sprdwl_cmd_del_station {
+	u8 mac[ETH_ALEN];
+	__le16 reason_code;
+} __packed;
+
+/*
+ * * struct rate_info - bitrate information
+ * *
+ * * Information about a receiving or transmitting bitrate
+ * *
+ * * @flags: bitflag of flags from &enum rate_info_flags
+ * * @mcs: mcs index if struct describes a 802.11n bitrate
+ * * @legacy: bitrate in 100kbit/s for 802.11abg
+ * * @nss: number of streams (VHT only)
+ */
+
+struct sprdwl_rate_info {
+	u8 flags;
+	u8 mcs;
+	u16 legacy;
+	u8 nss;
+} __packed;
+
+/* WIFI_CMD_GET_STATION */
+struct sprdwl_cmd_get_station {
+	struct sprdwl_rate_info rate;
+	s8 signal;
+	u8 noise;
+	u8 reserved;
+	__le32 txfailed;
+} __packed;
+
+/* WIFI_CMD_SET_CHANNEL */
+struct sprdwl_cmd_set_channel {
+	u8 channel;
+} __packed;
+
+/* WIFI_CMD_SCAN */
+struct sprdwl_cmd_scan {
+	__le32 channels;	/* One bit for one channel */
+	__le32 reserved;
+	u16 ssid_len;
+	u8 ssid[0];
+} __packed;
+
+/* WIFI_CMD_SCHED_SCAN */
+struct sprdwl_cmd_sched_scan_hd {
+	u16 started;
+	u16 buf_flags;
+} __packed;
+
+struct sprdwl_cmd_sched_scan_ie_hd {
+	u16 ie_flag;
+	u16 ie_len;
+} __packed;
+
+struct sprdwl_cmd_sched_scan_ifrc {
+	u32 interval;
+	u32 flags;
+	s32 rssi_thold;
+	u8 chan[TOTAL_2G_5G_CHANNEL_NUM + 1];
+} __packed;
+
+struct sprdwl_cmd_connect {
+	__le32 wpa_versions;
+	u8 bssid[ETH_ALEN];
+	u8 channel;
+	u8 auth_type;
+	u8 pairwise_cipher;
+	u8 group_cipher;
+	u8 key_mgmt;
+	u8 mfp_enable;
+	u8 psk_len;
+	u8 ssid_len;
+	u8 psk[WLAN_MAX_KEY_LEN];
+	u8 ssid[IEEE80211_MAX_SSID_LEN];
+} __packed;
+
+/* WIFI_CMD_DISCONNECT */
+struct sprdwl_cmd_disconnect {
+	__le16 reason_code;
+} __packed;
+
+/* WIFI_CMD_SET_PARAM */
+struct sprdwl_cmd_set_param {
+	__le32 rts;
+	__le32 frag;
+} __packed;
+
+struct sprdwl_cmd_pmkid {
+	u8 bssid[ETH_ALEN];
+	u8 pmkid[WLAN_PMKID_LEN];
+} __packed;
+
+struct sprdwl_cmd_dscp_exception {
+	u8 dscp;
+	u8 up;
+} __packed;
+
+struct sprdwl_cmd_dscp_range {
+	u8 low;
+	u8 high;
+} __packed;
+
+struct sprdwl_cmd_qos_map {
+	u8 num_des;
+	struct sprdwl_cmd_dscp_exception dscp_exception[21];
+	struct sprdwl_cmd_dscp_range up[8];
+} __packed;
+
+struct sprdwl_cmd_tx_ts {
+	u8 tsid;
+	u8 peer[ETH_ALEN];
+	u8 user_prio;
+	__le16 admitted_time;
+} __packed;
+
+/* WIFI_CMD_REMAIN_CHAN */
+struct sprdwl_cmd_remain_chan {
+	u8 chan;
+	u8 chan_type;
+	__le32 duraion;
+	__le64 cookie;
+} __packed;
+
+/* WIFI_CMD_CANCEL_REMAIN_CHAN */
+struct sprdwl_cmd_cancel_remain_chan {
+	__le64 cookie;		/* cookie */
+} __packed;
+
+/* WIFI_CMD_TX_MGMT */
+struct sprdwl_cmd_mgmt_tx {
+	u8 chan;		/* send channel */
+	u8 dont_wait_for_ack;	/*don't wait for ack */
+	__le32 wait;		/* wait time */
+	__le64 cookie;		/* cookie */
+	__le16 len;		/* mac length */
+	u8 value[0];		/* mac */
+} __packed;
+
+/* WIFI_CMD_REGISTER_FRAME */
+struct sprdwl_cmd_register_frame {
+	__le16 type;
+	u8 reg;
+} __packed;
+
+/* WIFI_CMD_SET_CQM */
+struct sprdwl_cmd_cqm_rssi {
+	__le32 rssih;
+	__le32 rssil;
+} __packed;
+
+/*define roam subtype value*/
+#define SPRDWL_ROAM_OFFLOAD_SET_FLAG 1
+#define	SPRDWL_ROAM_OFFLOAD_SET_FTIE  2
+#define	SPRDWL_ROAM_OFFLOAD_SET_PMK  3
+#define	SPRDWL_ROAM_SET_BLACK_LIST  4
+#define	SPRDWL_ROAM_SET_WHITE_LIST  5
+
+struct sprdwl_cmd_roam_offload_data {
+	u8 type;
+	u8 len;
+	u8 value[0];
+} __packed;
+
+struct sprdwl_cmd_tdls_mgmt {
+	u8 da[ETH_ALEN];
+	u8 sa[ETH_ALEN];
+	__le16 ether_type;
+	u8 payloadtype;
+	u8 category;
+	u8 action_code;
+	union {
+		struct {
+			u8 dialog_token;
+		} __packed setup_req;
+		struct {
+			__le16 status_code;
+			u8 dialog_token;
+		} __packed setup_resp;
+		struct {
+			__le16 status_code;
+			u8 dialog_token;
+		} __packed setup_cfm;
+		struct {
+			__le16 reason_code;
+		} __packed teardown;
+		struct {
+			u8 dialog_token;
+		} __packed discover_resp;
+	} u;
+	__le32 len;
+	u8 frame[0];
+} __packed;
+
+struct sprdwl_cmd_tdls {
+	u8 tdls_sub_cmd_mgmt;
+	u8 da[ETH_ALEN];
+	u8 initiator;
+	u8 rsvd;
+	u8 paylen;
+	u8 payload[0];
+} __packed;
+
+struct sprdwl_cmd_blacklist {
+	u8 sub_type;
+	u8 num;
+	u8 mac[0];
+} __packed;
+
+struct sprdwl_cmd_tdls_channel_switch {
+	u8 primary_chan;
+	u8 second_chan_offset;
+	u8 band;
+} __packed;
+
+struct sprdwl_cmd_set_mac_addr {
+	u8 sub_type;
+	u8 num;
+	u8 mac[0];
+} __packed;
+
+struct sprdwl_cmd_rsp_state_code {
+	__le32 code;
+} __packed;
+
+/* 11v cmd struct */
+struct sprdwl_cmd_11v {
+	u16 cmd;
+	u16 len;
+	union {
+		u32 value;
+		u8 buf[0];
+	};
+} __packed;
+
+struct sprdwl_event_suspend_resume {
+	u32 status;
+} __packed;
+
+enum SPRDWL_EVENT_LIST {
+	WIFI_EVENT_MIN = 0x80,
+	/* Station/P2P */
+	WIFI_EVENT_CONNECT = WIFI_EVENT_MIN,
+	WIFI_EVENT_DISCONNECT,
+	WIFI_EVENT_SCAN_DONE,
+	WIFI_EVENT_MGMT_FRAME,
+	WIFI_EVENT_MGMT_TX_STATUS,
+	WIFI_EVENT_REMAIN_CHAN_EXPIRED,
+	WIFI_EVENT_MIC_FAIL,
+	WIFI_EVENT_GSCAN_FRAME = 0X88,
+	WIFI_EVENT_RSSI_MONITOR = 0x89,
+	WIFI_EVENT_COEX_BT_ON_OFF = 0x90,
+
+	/* SoftAP */
+	WIFI_EVENT_NEW_STATION = 0xA0,
+	WIFI_EVENT_RADAR_DETECTED = 0xA1,
+
+	/* New Feature */
+	/* Uplayer Roaming */
+	WIFI_EVENT_CQM = 0xB0,
+	WIFI_EVENT_MEASUREMENT,
+	WIFI_EVENT_TDLS,
+	WIFI_EVENT_SDIO_FLOWCON = 0xB3,
+
+	/* DEBUG/OTHER */
+	WIFI_EVENT_SDIO_SEQ_NUM = 0xE0,
+
+	WIFI_EVENT_BA = 0xf3,
+	/* RTT */
+	WIFI_EVENT_RTT = 0xf2,
+
+	/* NAN */
+	WIFI_EVENT_NAN = 0xf4,
+	WIFI_EVENT_STA_LUT_INDEX = 0xf5,
+	WIFI_EVENT_HANG_RECOVERY = 0xf6,
+	WIFI_EVENT_THERMAL_WARN = 0xf7,
+	WIFI_EVENT_SUSPEND_RESUME = 0xf8,
+	WIFI_EVENT_WFD_MIB_CNT = 0xf9,
+	WIFI_EVENT_FW_PWR_DOWN = 0xfa,
+	WIFI_EVENT_CHAN_CHANGED = 0xfb,
+	WIFI_EVENT_MAX
+};
+
+/* WIFI_EVENT_DISCONNECT */
+struct sprdwl_event_disconnect {
+	u16 reason_code;
+} __packed;
+
+/* WIFI_EVENT_MGMT_FRAME */
+struct sprdwl_event_mgmt_frame {
+#define SPRDWL_FRAME_NORMAL		1
+#define	SPRDWL_FRAME_DEAUTH		2
+#define	SPRDWL_FRAME_DISASSOC		3
+#define	SPRDWL_FRAME_SCAN		4
+#define SPRDWL_FRAME_ROAMING		5
+	u8 type;
+	u8 channel;
+	s8 signal;		/* signal should be signed */
+	u8 reserved;
+	u8 bssid[ETH_ALEN];	/* roaming frame */
+	__le16 len;
+	u8 data[0];
+} __packed;
+
+/* WIFI_EVENT_SCAN_COMP */
+struct sprdwl_event_scan_done {
+#define	SPRDWL_SCAN_DONE		1
+#define	SPRDWL_SCHED_SCAN_DONE		2
+#define SPRDWL_SCAN_ERROR		3
+#define SPRDWL_GSCAN_DONE		4
+	u8 type;
+} __packed;
+
+/* WIFI_EVENT_GSCAN_COMP */
+struct sprdwl_event_gscan_done {
+	struct sprdwl_event_scan_done evt;
+	u8 bucket_id;
+} __packed;
+
+/* WIFI_EVENT_MLME_TX_STATUS */
+struct sprdwl_event_mgmt_tx_status {
+	__le64 cookie;		/* cookie */
+	u8 ack;			/* status */
+	__le16 len;		/* frame len */
+	u8 buf[0];		/* mgmt frame */
+} __packed;
+
+/* WIFI_EVENT_NEW_STATION  */
+struct sprdwl_event_new_station {
+	u8 is_connect;
+	u8 mac[ETH_ALEN];
+	__le16 ie_len;
+	u8 ie[0];
+} __packed;
+
+/* WIFI_EVENT_MIC_FAIL */
+struct sprdwl_event_mic_failure {
+	u8 key_id;
+	u8 is_mcast;
+} __packed;
+
+/* WIFI_EVENT_CQM  */
+struct sprdwl_event_cqm {
+#define	SPRDWL_CQM_RSSI_LOW	1
+#define	SPRDWL_CQM_RSSI_HIGH	2
+#define	SPRDWL_CQM_BEACON_LOSS	3
+	u8 status;
+} __packed;
+
+struct sprdwl_event_tdls {
+	u8 tdls_sub_cmd_mgmt;
+	u8 mac[ETH_ALEN];
+	u8 payload_len;
+	u8 rcpi;
+} __packed;
+
+struct sprd_cmd_gscan_header {
+	u16 subcmd;
+	u16 data_len;
+	u8 data[0];
+} __packed;
+
+struct sprdwl_llc_hdr {
+	u8 dsap;
+	u8 ssap;
+	u8 cntl;
+	u8 org_code[3];
+	__be16 eth_type;
+} __packed;
+
+struct sprdwl_cmd_ba {
+#define SPRDWL_ADDBA_REQ_CMD 0
+#define SPRDWL_ADDBA_RSP_CMD 1
+#define SPRDWL_DELBA_CMD 2
+#define SPRDWL_DELBA_ALL_CMD 5
+	unsigned char type;
+	unsigned char tid;
+	unsigned char da[6];
+	unsigned char success;
+} __packed;
+
+struct win_param {
+	unsigned short win_start;
+	unsigned short win_size;
+} __packed;
+
+struct msdu_param {
+	unsigned short seq_num;
+} __packed;
+
+struct sprdwl_event_ba {
+#define SPRDWL_ADDBA_REQ_EVENT 0
+#define SPRDWL_ADDBA_RSP_EVENT 1
+#define SPRDWL_DELBA_EVENT 2
+#define SPRDWL_BAR_EVENT 3
+#define SPRDWL_FILTER_EVENT 4
+#define SPRDWL_DELBA_ALL_EVENT 5
+#define SPRDWL_DELTXBA_EVENT 6
+	unsigned char type;
+	unsigned char tid;
+	unsigned char sta_lut_index;
+	unsigned char reserved;
+	union {
+		struct win_param win_param;
+		struct msdu_param msdu_param;
+	} __packed;
+} __packed;
+
+struct sprdwl_sta_lut_ind {
+	u8 ctx_id;
+	u8 action;
+	u8 sta_lut_index;
+	u8 ra[ETH_ALEN];
+	u8 is_ht_enable;
+	u8 is_vht_enable;
+} __packed;
+
+struct sprdwl_chan_changed_info {
+	u8 initiator;
+	u8 target_channel;
+} __packed;
+
+struct tdls_update_peer_infor {
+	u8 tdls_cmd_type;
+	u8 da[ETH_ALEN];
+	u8 valid;
+	u8 timer;
+	u8 rsvd;
+	u16 txrx_len;
+} __packed;
+
+struct sprdwl_cmd_set_assert {
+#define SCAN_ERROR 0
+#define RSP_CNT_ERROR 1
+#define HANDLE_FLAG_ERROR 2
+#define CMD_RSP_TIMEOUT_ERROR 3
+#define LOAD_INI_DATA_FAILED 4
+#define DOWNLOAD_INI_DATA_FAILED 5
+	u8 reason;
+} __packed;
+
+struct event_hang_recovery {
+#define HANG_RECOVERY_BEGIN 0
+#define HANG_RECOVERY_END 1
+	u32 action;
+} __packed;
+
+struct event_thermal_warn {
+#define THERMAL_TX_RESUME 0
+#define THERMAL_TX_STOP 1
+#define THERMAL_WIFI_DOWN 2
+	u32 action;
+} __packed;
+
+struct event_wfd_mib_cnt {
+	u32 wfd_throughput;
+	u32 sum_tx_throughput;
+	u32 tx_mpdu_lost_cnt[4];
+	u32 tx_frame_cnt;
+	u32 rx_clear_cnt;
+	u32 mib_cycle_cnt;
+} __packed;
+
+struct event_coex_mode_changed {
+#define BT_ON 1
+#define BT_OFF 0
+	u8 action;
+} __packed;
+
+int sprdwl_cmd_init(void);
+void sprdwl_cmd_wake_upall(void);
+void sprdwl_cmd_deinit(void);
+
+struct sprdwl_priv;
+
+/* TLV info */
+struct sprdwl_tlv_data {
+	u16 type;
+	u16 len;
+	u8 data[0];
+} __packed;
+
+/* TLV rbuf size */
+#define GET_INFO_TLV_RBUF_SIZE	300
+
+/* TLV type list */
+#define GET_INFO_TLV_TP_OTT	1
+#define NOTIFY_AP_VERSION	2
+
+struct ap_version_tlv_elmt {
+#define NOTIFY_AP_VERSION_USER 0
+#define NOTIFY_AP_VERSION_USER_DEBUG 1
+	struct sprdwl_tlv_data hdr;
+	u8 ap_version;
+} __packed;
+
+/* IOCTL command=SPRDWLSETTLV */
+/* type list */
+enum IOCTL_TLV_TYPE_LIST {
+	IOCTL_TLV_TP_VOWIFI_INFO = 6,
+	IOCTL_TLV_TP_ADD_VOWIFI_PAIR = 7,
+	IOCTL_TLV_TP_DEL_VOWIFI_PAIR = 8,
+	IOCTL_TLV_TP_FLUSH_VOWIFI_PAIR = 9
+};
+
+/* structure */
+/* tlv type = 6 */
+struct vowifi_info {
+	u8 data;	/* vowifi status: 0:disable,1:enable */
+	u8 call_type;	/* vowifi type: 0:video,1:voice */
+};
+
+/* packet offload struct */
+struct sprdwl_cmd_packet_offload {
+	u32 req_id;
+	u8 enable;
+	u32 period;
+	u16 len;
+	u8 data[0];
+} __packed;
+
+int sprdwl_cmd_rsp(struct sprdwl_priv *priv, u8 *msg);
+/*driver & fw API sync function start*/
+int sprdwl_sync_version(struct sprdwl_priv *priv);
+void sprdwl_fill_drv_api_version(struct sprdwl_priv *priv,
+		struct sprdwl_cmd_api_t *drv_api);
+void sprdwl_fill_fw_api_version(struct sprdwl_priv *priv,
+		struct sprdwl_cmd_api_t *fw_api);
+int sprdwl_api_available_check(struct sprdwl_priv *priv,
+		struct sprdwl_msg_buf *msg);
+int need_compat_operation(struct sprdwl_priv *priv, u8 cmd_id);
+/*driver & fw API sync function end*/
+void sprdwl_download_ini(struct sprdwl_priv *priv);
+int sprdwl_get_fw_info(struct sprdwl_priv *priv);
+int sprdwl_set_regdom(struct sprdwl_priv *priv, u8 *regdom, u32 len);
+int sprdwl_set_rts(struct sprdwl_priv *priv, u16 rts_threshold);
+int sprdwl_set_frag(struct sprdwl_priv *priv, u16 frag_threshold);
+int sprdwl_screen_off(struct sprdwl_priv *priv, bool is_off);
+int sprdwl_power_save(struct sprdwl_priv *priv, u8 vif_ctx_id,
+		      u8 sub_type, u8 status);
+int sprdwl_notify_ip(struct sprdwl_priv *priv, u8 vif_ctx_id,
+		     u8 ip_type, u8 *ip_addr);
+int sprdwl_add_blacklist(struct sprdwl_priv *priv, u8 vif_ctx_id, u8 *mac_addr);
+int sprdwl_del_blacklist(struct sprdwl_priv *priv, u8 vif_ctx_id, u8 *mac_addr);
+int sprdwl_set_whitelist(struct sprdwl_priv *priv, u8 vif_ctx_id,
+			 u8 sub_type, u8 num, u8 *mac_addr);
+
+int sprdwl_open_fw(struct sprdwl_priv *priv, u8 *vif_ctx_id, u8 mode,
+		   u8 *mac_addr);
+int sprdwl_close_fw(struct sprdwl_priv *priv, u8 vif_ctx_id, u8 mode);
+int sprdwl_add_key(struct sprdwl_priv *priv, u8 vif_ctx_id, const u8 *key_data,
+		   u8 key_len, u8 pairwise, u8 key_index, const u8 *key_seq,
+		   u8 cypher_type, const u8 *mac_addr);
+int sprdwl_del_key(struct sprdwl_priv *priv, u8 vif_ctx_id, u16 key_index,
+		   bool pairwise, const u8 *mac_addr);
+int sprdwl_set_key(struct sprdwl_priv *priv, u8 vif_ctx_id, u8 key_index);
+int sprdwl_set_rekey_data(struct sprdwl_priv *priv, u8 vif_ctx_id,
+			struct cfg80211_gtk_rekey_data *data);
+int sprdwl_set_p2p_ie(struct sprdwl_priv *priv, u8 vif_ctx_id, u8 type,
+		      const u8 *ie, u16 len);
+int sprdwl_set_wps_ie(struct sprdwl_priv *priv, u8 vif_ctx_id, u8 type,
+		      const u8 *ie, u8 len);
+int sprdwl_set_ft_ie(struct sprdwl_priv *priv, u8 vif_ctx_id,
+		     const u8 *ie, u16 len);
+#ifdef DFS_MASTER
+int sprdwl_reset_beacon(struct sprdwl_priv *priv, u8 vif_ctx_id,
+		   const u8 *beacon, u16 len);
+#endif
+int sprdwl_start_ap(struct sprdwl_priv *priv, u8 vif_ctx_id,
+		    u8 *beacon, u16 len);
+int sprdwl_get_rssi(struct sprdwl_priv *priv, u8 vif_ctx_id, u8 *signal,
+		    u8 *noise);
+int sprdwl_get_txrate_txfailed(struct sprdwl_priv *priv, u8 vif_ctx_id,
+			       u32 *rate, u32 *failed);
+int sprdwl_set_channel(struct sprdwl_priv *priv, u8 vif_ctx_id, u8 channel);
+int sprdwl_scan(struct sprdwl_priv *priv, u8 vif_ctx_id, u32 channels,
+		int ssid_len, const u8 *ssid_list,
+		u16 chn_count_5g, const u16 *chns_5g);
+int sprdwl_sched_scan_start(struct sprdwl_priv *priv, u8 vif_ctx_id,
+			    struct sprdwl_sched_scan_buf *buf);
+int sprdwl_sched_scan_stop(struct sprdwl_priv *priv, u8 vif_ctx_id);
+int sprdwl_disconnect(struct sprdwl_priv *priv, u8 vif_ctx_id, u16 reason_code);
+int sprdwl_connect(struct sprdwl_priv *priv, u8 vif_ctx_id,
+		   struct sprdwl_cmd_connect *p);
+int sprdwl_pmksa(struct sprdwl_priv *priv, u8 vif_ctx_id, const u8 *bssid,
+		 const u8 *pmkid, u8 type);
+int sprdwl_remain_chan(struct sprdwl_priv *priv, u8 vif_ctx_id,
+		       struct ieee80211_channel *channel,
+		       enum nl80211_channel_type channel_type,
+		       u32 duration, u64 *cookie);
+int sprdwl_cancel_remain_chan(struct sprdwl_priv *priv, u8 vif_ctx_id,
+			      u64 cookie);
+int sprdwl_tx_mgmt(struct sprdwl_priv *priv, u8 vif_ctx_id, u8 channel,
+		   u8 dont_wait_for_ack, u32 wait, u64 *cookie,
+		   const u8 *mac, size_t mac_len);
+int sprdwl_register_frame(struct sprdwl_priv *priv, u8 vif_ctx_id, u16 type,
+			  u8 reg);
+int sprdwl_tdls_mgmt(struct sprdwl_vif *vif, struct sk_buff *skb);
+int sprdwl_tdls_oper(struct sprdwl_priv *priv, u8 vif_ctx_id, const u8 *peer,
+		     int oper);
+int sprdwl_start_tdls_channel_switch(struct sprdwl_priv *priv, u8 vif_ctx_id,
+				     const u8 *peer_mac, u8 primary_chan,
+				     u8 second_chan_offset, u8 band);
+int sprdwl_cancel_tdls_channel_switch(struct sprdwl_priv *priv, u8 vif_ctx_id,
+				      const u8 *peer_mac);
+int sprdwl_set_cqm_rssi(struct sprdwl_priv *priv, u8 vif_ctx_id, s32 rssi_thold,
+			u32 rssi_hyst);
+int sprdwl_set_roam_offload(struct sprdwl_priv *priv, u8 vif_ctx_id,
+			    u8 sub_type, const u8 *data, u8 len);
+int sprdwl_del_station(struct sprdwl_priv *priv, u8 vif_ctx_id,
+		       const u8 *mac_addr, u16 reason_code);
+int sprdwl_set_blacklist(struct sprdwl_priv *priv,
+			 u8 vif_ctx_id, u8 sub_type, u8 num, u8 *mac_addr);
+int sprdwl_set_ie(struct sprdwl_priv *priv, u8 vif_ctx_id, u8 type,
+		  const u8 *ie, u16 len);
+int sprdwl_set_param(struct sprdwl_priv *priv, u32 rts, u32 frag);
+int sprdwl_get_station(struct sprdwl_priv *priv, u8 vif_ctx_id,
+		       struct sprdwl_cmd_get_station *sta);
+int sprdwl_set_def_key(struct sprdwl_priv *priv, u8 vif_ctx_id, u8 key_index);
+
+int sprdwl_npi_send_recv(struct sprdwl_priv *priv, u8 vif_ctx_id, u8 *s_buf,
+			 u16 s_len, u8 *r_buf, u16 *r_len);
+int sprdwl_set_qos_map(struct sprdwl_priv *priv, u8 vif_ctx_id, void *qos_map);
+int sprdwl_add_tx_ts(struct sprdwl_priv *priv, u8 vif_ctx_id, u8 tsid,
+		     const u8 *peer, u8 user_prio, u16 admitted_time);
+int sprdwl_del_tx_ts(struct sprdwl_priv *priv, u8 vif_ctx_id, u8 tsid,
+		     const u8 *peer);
+int sprdwl_set_mc_filter(struct sprdwl_priv *priv,  u8 vif_ctx_id,
+			 u8 sub_type, u8 num, u8 *mac_addr);
+int sprdwl_set_gscan_config(struct sprdwl_priv *priv, u8 vif_ctx_id, void *data,
+			    u16 len, u8 *r_buf, u16 *r_len);
+int sprdwl_set_gscan_scan_config(struct sprdwl_priv *priv, u8 vif_ctx_id,
+				 void *data, u16 len, u8 *r_buf, u16 *r_len);
+int sprdwl_enable_gscan(struct sprdwl_priv *priv, u8 vif_ctx_id, void *data,
+			u8 *r_buf, u16 *r_len);
+int sprdwl_set_11v_feature_support(struct sprdwl_priv *priv,
+				   u8 vif_ctx_id, u16 val);
+int sprdwl_set_11v_sleep_mode(struct sprdwl_priv *priv, u8 vif_ctx_id,
+			      u8 status, u16 interval);
+int sprdwl_xmit_data2cmd(struct sk_buff *skb, struct net_device *ndev);
+int sprdwl_xmit_data2cmd_wq(struct sk_buff *skb, struct net_device *ndev);
+int sprdwl_send_vowifi_data_prot(struct sprdwl_priv *priv, u8 ctx_id,
+				  void *data, int len);
+void sprdwl_vowifi_data_protection(struct sprdwl_vif *vif);
+int sprdwl_get_gscan_capabilities(struct sprdwl_priv *priv, u8 vif_ctx_id,
+				  u8 *r_buf, u16 *r_len);
+int sprdwl_get_gscan_channel_list(struct sprdwl_priv *priv, u8 vif_ctx_id,
+				  void *data, u8 *r_buf, u16 *r_len);
+int sprdwl_cmd_send_recv(struct sprdwl_priv *priv,
+			 struct sprdwl_msg_buf *msg,
+			 unsigned int timeout, u8 *rbuf, u16 *rlen);
+void sprdwl_event_frame(struct sprdwl_vif *vif, u8 *data, u16 len, int flag);
+int sprdwl_send_ba_mgmt(struct sprdwl_priv *priv, u8 vif_ctx_id,
+			void *data, u16 len);
+int sprdwl_set_gscan_bssid_hotlist(struct sprdwl_priv *priv, u8 vif_ctx_id,
+			    void *data, u16 len, u8 *r_buf, u16 *r_len);
+
+int sprdwl_set_gscan_bssid_blacklist(struct sprdwl_priv *priv, u8 vif_ctx_id,
+			    void *data, u16 len, u8 *r_buf, u16 *r_len);
+int sprdwl_send_tdlsdata_use_cmd(struct sk_buff *skb,
+				  struct sprdwl_vif *vif, u8 need_cp2_rsp);
+int sprdwl_gscan_subcmd(struct sprdwl_priv *priv, u8 vif_ctx_id,
+			void *data, u16 subcmd, u16 len, u8 *r_buf, u16 *r_len);
+int sprdwl_get_protect_mode(struct sprdwl_priv *priv, u32 ctxt_id, u8 *mode);
+int sprdwl_set_protect_mode(struct sprdwl_priv *priv, u32 ctxt_id, u8 mode);
+int wlan_set_assert(struct sprdwl_priv *priv, u8 vif_ctx_id, u8 cmd_id, u8 reason);
+void sprdwl_send_assert_cmd(struct sprdwl_vif *vif, u8 cmd_id, u8 reason);
+int sprdwl_send_hang_received_cmd(struct sprdwl_priv *priv, u8 vif_ctx_id);
+int sprdwl_set_max_clients_allowed(struct sprdwl_priv *priv,
+				   u8 ctxt_id, int n_clients);
+int sprdwl_set_tlv_data(struct sprdwl_priv *priv, u8 ctx_id,
+			struct sprdwl_tlv_data *tlv, int length);
+int sprdwl_send_tdls_cmd(struct sprdwl_vif *vif, u8 vif_ctx_id, const u8 *peer,
+		     int oper);
+int sprdwl_fw_power_down_ack(struct sprdwl_priv *priv, u8 ctx_id);
+int sprdwl_cmd_host_wakeup_fw(struct sprdwl_priv *priv, u8 ctx_id);
+void sprdwl_work_host_wakeup_fw(struct sprdwl_vif *vif);
+struct sprdwl_msg_buf *__sprdwl_cmd_getbuf(struct sprdwl_priv *priv,
+					   u16 len, u8 ctx_id,
+					   enum sprdwl_head_rsp rsp,
+					   u8 cmd_id, gfp_t flags);
+
+static inline struct sprdwl_msg_buf *sprdwl_cmd_getbuf(struct sprdwl_priv *priv,
+						       u16 len, u8 ctx_id,
+						       enum sprdwl_head_rsp rsp,
+						       u8 cmd_id)
+{
+	return __sprdwl_cmd_getbuf(priv, len, ctx_id, rsp, cmd_id, GFP_KERNEL);
+}
+
+static inline struct
+sprdwl_msg_buf *sprdwl_cmd_getbuf_atomic(struct sprdwl_priv *priv,
+					 u16 len, u8 ctx_id,
+					 enum sprdwl_head_rsp rsp,
+					 u8 cmd_id)
+{
+	return __sprdwl_cmd_getbuf(priv, len, ctx_id, rsp, cmd_id, GFP_ATOMIC);
+}
+
+int sprdwl_send_data2cmd(struct sprdwl_priv *priv, u8 vif_ctx_id,
+		void *data, u16 len);
+
+void mdbg_assert_interface(char *str);
+void sprdwl_set_tlv_elmt(u8 *addr, u16 type, u16 len, u8 *data);
+int sprdwl_set_wowlan(struct sprdwl_priv *priv, int subcmd, void *pad, int pad_len);
+#ifdef SYNC_DISCONNECT
+int sprdwl_sync_disconnect_event(struct sprdwl_vif *vif, unsigned int timeout);
+#endif
+int sprdwl_set_if_down(struct net_device *ndev);
+#endif
diff --git a/drivers/net/wireless/uwe5622/unisocwifi/debug.c b/drivers/net/wireless/uwe5622/unisocwifi/debug.c
new file mode 100644
index 000000000000..9fcf347cead1
--- /dev/null
+++ b/drivers/net/wireless/uwe5622/unisocwifi/debug.c
@@ -0,0 +1,189 @@
+#include "debug.h"
+#include <linux/spinlock.h>
+#include <linux/jiffies.h>
+
+struct debug_ctrl {
+	spinlock_t debug_ctrl_lock;
+	bool start;
+};
+
+static struct debug_ctrl debug_ctrl;
+
+void debug_ctrl_init(void)
+{
+	spin_lock_init(&debug_ctrl.debug_ctrl_lock);
+	debug_ctrl.start = false;
+}
+
+static bool check_debug_ctrl(void)
+{
+	bool value = false;
+
+	spin_lock_bh(&debug_ctrl.debug_ctrl_lock);
+	if (debug_ctrl.start)
+		value = true;
+	spin_unlock_bh(&debug_ctrl.debug_ctrl_lock);
+
+	return value;
+}
+
+#define MAX_TS_NUM 20
+struct debug_time_stamp {
+	unsigned long ts_enter;
+	unsigned int pos;
+	unsigned int ts_record[MAX_TS_NUM];
+	unsigned int max_ts;
+};
+
+static struct debug_time_stamp g_debug_ts[MAX_DEBUG_TS_INDEX];
+
+void debug_ts_enter(enum debug_ts_index index)
+{
+	if (!check_debug_ctrl())
+		return;
+
+	g_debug_ts[index].ts_enter = jiffies;
+}
+
+void debug_ts_leave(enum debug_ts_index index)
+{
+	struct debug_time_stamp *ts = &g_debug_ts[index];
+
+	if (!check_debug_ctrl() || (ts->ts_enter == 0))
+		return;
+
+	ts->ts_record[ts->pos] =
+		jiffies_to_usecs(jiffies - ts->ts_enter);
+
+	if (ts->ts_record[ts->pos] > ts->max_ts)
+		ts->max_ts = ts->ts_record[ts->pos];
+
+	(ts->pos < (MAX_TS_NUM - 1)) ? ts->pos++ : (ts->pos = 0);
+}
+
+void debug_ts_show(struct seq_file *s, enum debug_ts_index index)
+{
+	unsigned int i = 0;
+	unsigned int avr_time = 0, avr_cnt = 0;
+	struct debug_time_stamp *ts = &g_debug_ts[index];
+
+	if (!check_debug_ctrl())
+		return;
+
+	seq_printf(s, "%s(us):", ts_index2str(index));
+	for (i = 0; i < MAX_TS_NUM; i++) {
+		seq_printf(s, " %d", ts->ts_record[i]);
+		if (ts->ts_record[i] != 0) {
+			avr_time += ts->ts_record[i];
+			avr_cnt++;
+		}
+	}
+	seq_printf(s, "\n%s average time(us): %d\n",
+			ts_index2str(index), avr_time/avr_cnt);
+	seq_printf(s, "%s max time(us): %d\n",
+			ts_index2str(index), ts->max_ts);
+}
+
+struct debug_cnt {
+	int cnt;
+};
+
+static struct debug_cnt g_debug_cnt[MAX_DEBUG_CNT_INDEX];
+
+void debug_cnt_inc(enum debug_cnt_index index)
+{
+	if (!check_debug_ctrl())
+		return;
+
+	g_debug_cnt[index].cnt++;
+}
+
+void debug_cnt_dec(enum debug_cnt_index index)
+{
+	if (!check_debug_ctrl())
+		return;
+
+	g_debug_cnt[index].cnt--;
+}
+
+void debug_cnt_add(enum debug_cnt_index index, int num)
+{
+	if (!check_debug_ctrl())
+		return;
+
+	g_debug_cnt[index].cnt += num;
+}
+
+void debug_cnt_sub(enum debug_cnt_index index, int num)
+{
+	if (!check_debug_ctrl())
+		return;
+
+	g_debug_cnt[index].cnt -= num;
+}
+
+void debug_cnt_show(struct seq_file *s, enum debug_cnt_index index)
+{
+	if (!check_debug_ctrl())
+		return;
+
+	seq_printf(s, "%s: %d\n",
+		cnt_index2str(index), g_debug_cnt[index].cnt);
+}
+
+#define MAX_RECORD_NUM 20
+struct debug_record {
+	unsigned int pos;
+	int record[MAX_TS_NUM];
+};
+
+static struct debug_record g_debug_record[MAX_RECORD_NUM];
+
+void debug_record_add(enum debug_record_index index, int num)
+{
+	struct debug_record *record = &g_debug_record[index];
+
+	if (!check_debug_ctrl())
+		return;
+
+	record->record[record->pos] = num;
+	(record->pos < (MAX_RECORD_NUM - 1)) ?
+		record->pos++ : (record->pos = 0);
+}
+
+void debug_record_show(struct seq_file *s, enum debug_record_index index)
+{
+	struct debug_record *record = &g_debug_record[index];
+	unsigned int i = 0;
+
+	if (!check_debug_ctrl())
+		return;
+
+	seq_printf(s, "%s:", record_index2str(index));
+	for (i = 0; i < MAX_RECORD_NUM; i++) {
+		seq_printf(s, " %d", record->record[i]);
+	}
+	seq_puts(s, "\n");
+}
+
+void adjust_ts_cnt_debug(char *buf, unsigned char offset)
+{
+	int level = buf[offset] - '0';
+
+	spin_lock_bh(&debug_ctrl.debug_ctrl_lock);
+	if (level == 0) {
+		debug_ctrl.start = false;
+		spin_unlock_bh(&debug_ctrl.debug_ctrl_lock);
+	} else {
+		memset(g_debug_ts, 0,
+		       (MAX_DEBUG_TS_INDEX *
+			sizeof(struct debug_time_stamp)));
+		memset(g_debug_cnt, 0,
+		       (MAX_DEBUG_CNT_INDEX * sizeof(struct debug_cnt)));
+		memset(g_debug_record, 0,
+		       (MAX_RECORD_NUM * sizeof(struct debug_record)));
+		debug_ctrl.start = true;
+		spin_unlock_bh(&debug_ctrl.debug_ctrl_lock);
+	}
+}
+
diff --git a/drivers/net/wireless/uwe5622/unisocwifi/debug.h b/drivers/net/wireless/uwe5622/unisocwifi/debug.h
new file mode 100644
index 000000000000..108b6c857204
--- /dev/null
+++ b/drivers/net/wireless/uwe5622/unisocwifi/debug.h
@@ -0,0 +1,88 @@
+#ifndef __DEBUG_H__
+#define __DEBUG_H__
+
+#include <linux/seq_file.h>
+
+enum debug_ts_index {
+	RX_SDIO_PORT,
+	MAX_DEBUG_TS_INDEX,
+};
+
+static inline char *ts_index2str(u8 index)
+{
+#define I2S(x) \
+{ \
+	case x: \
+		return #x; \
+}
+
+	switch (index) {
+		I2S(RX_SDIO_PORT)
+		default : return "UNKNOW_DEBUG_TS_INDEX";
+	}
+#undef I2S
+}
+
+enum debug_cnt_index {
+	REORDER_TIMEOUT_CNT,
+	MAX_DEBUG_CNT_INDEX,
+};
+
+static inline char *cnt_index2str(u8 index)
+{
+#define I2S(x) \
+{ \
+	case x: \
+		return #x; \
+}
+
+	switch (index) {
+		I2S(REORDER_TIMEOUT_CNT)
+		default : return "UNKNOW_DEBUG_CNT_INDEX";
+	}
+#undef I2S
+}
+
+enum debug_record_index {
+	TX_CREDIT_RECORD,
+	TX_CREDIT_TIME_DIFF,
+	TX_CREDIT_PER_ADD,
+	TX_CREDIT_ADD,
+	MAX_DEBUG_RECORD_INDEX,
+};
+
+static inline char *record_index2str(u8 index)
+{
+#define I2S(x) \
+{ \
+	case x: \
+		return #x; \
+}
+
+	switch (index) {
+		I2S(TX_CREDIT_RECORD)
+		I2S(TX_CREDIT_TIME_DIFF)
+		I2S(TX_CREDIT_PER_ADD)
+		I2S(TX_CREDIT_ADD)
+		default : return "UNKNOW_DEBUG_RECORD_INDEX";
+	}
+#undef I2S
+}
+
+void debug_ctrl_init(void);
+void adjust_ts_cnt_debug(char *buf, unsigned char offset);
+
+void debug_ts_enter(enum debug_ts_index index);
+void debug_ts_leave(enum debug_ts_index index);
+void debug_ts_show(struct seq_file *s, enum debug_ts_index index);
+
+void debug_cnt_inc(enum debug_cnt_index index);
+void debug_cnt_dec(enum debug_cnt_index index);
+void debug_cnt_add(enum debug_cnt_index index, int num);
+void debug_cnt_sub(enum debug_cnt_index index, int num);
+void debug_cnt_show(struct seq_file *s, enum debug_cnt_index index);
+
+void debug_record_add(enum debug_record_index index, int record);
+void debug_record_show(struct seq_file *s, enum debug_record_index index);
+
+#endif /* __DEBUG_H__ */
diff --git a/drivers/net/wireless/uwe5622/unisocwifi/defrag.c b/drivers/net/wireless/uwe5622/unisocwifi/defrag.c
new file mode 100644
index 000000000000..0b3cfb767681
--- /dev/null
+++ b/drivers/net/wireless/uwe5622/unisocwifi/defrag.c
@@ -0,0 +1,264 @@
+/*
+ * Copyright (C) 2016 Spreadtrum Communications Inc.
+ *
+ * Authors	:
+ * star.liu <star.liu@spreadtrum.com>
+ * yifei.li <yifei.li@spreadtrum.com>
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include "defrag.h"
+#include "rx_msg.h"
+
+static struct rx_defrag_node
+*find_defrag_node(struct sprdwl_rx_defrag_entry *defrag_entry,
+		  struct rx_msdu_desc *msdu_desc)
+{
+	struct rx_defrag_node *node = NULL, *pos_node = NULL;
+
+	list_for_each_entry(pos_node, &defrag_entry->list, list) {
+		if ((pos_node->desc.sta_lut_index ==
+		     msdu_desc->sta_lut_index) &&
+		    (pos_node->desc.tid == msdu_desc->tid)) {
+			if ((pos_node->desc.seq_num == msdu_desc->seq_num) &&
+			    ((pos_node->last_frag_num + 1) ==
+			     msdu_desc->frag_num)) {
+				/* Node alive & fragment avail */
+				pos_node->last_frag_num = msdu_desc->frag_num;
+				wl_debug("%s: last_frag_num: %d\n",
+					 __func__, pos_node->last_frag_num);
+				node = pos_node;
+			}
+			break;
+		}
+	}
+
+	return node;
+}
+
+static inline void __init_first_frag_node(struct rx_defrag_node *node,
+					  struct rx_msdu_desc *msdu_desc)
+{
+	node->desc.sta_lut_index = msdu_desc->sta_lut_index;
+	node->desc.tid = msdu_desc->tid;
+	node->desc.frag_num = msdu_desc->frag_num;
+	node->desc.seq_num = msdu_desc->seq_num;
+
+	if (!skb_queue_empty(&node->skb_list))
+		skb_queue_purge(&node->skb_list);
+
+	if (likely(msdu_desc->snap_hdr_present))
+		node->msdu_len = ETH_HLEN + msdu_desc->msdu_offset;
+	else
+		node->msdu_len = 2*ETH_ALEN + msdu_desc->msdu_offset;
+
+	node->last_frag_num = msdu_desc->frag_num;
+}
+
+static struct rx_defrag_node
+*init_first_defrag_node(struct sprdwl_rx_defrag_entry *defrag_entry,
+		      struct rx_msdu_desc *msdu_desc)
+{
+	struct rx_defrag_node *node = NULL, *pos_node = NULL;
+	bool ret = true;
+
+	/* Check whether this entry alive or this fragment avail */
+	list_for_each_entry(pos_node, &defrag_entry->list, list) {
+		if ((pos_node->desc.sta_lut_index ==
+		     msdu_desc->sta_lut_index) &&
+		    (pos_node->desc.tid == msdu_desc->tid)) {
+			if (!seqno_leq(msdu_desc->seq_num,
+				       pos_node->desc.seq_num)) {
+				/* Replace this entry */
+				wl_err("%s: fragment replace: %d, %d\n",
+				       __func__, msdu_desc->seq_num,
+				       pos_node->desc.seq_num);
+				node = pos_node;
+			} else {
+				/* fragment not avail */
+				wl_err("%s: fragment not avail: %d, %d\n",
+				       __func__, msdu_desc->seq_num,
+				       pos_node->desc.seq_num);
+				ret = false;
+			}
+			break;
+		}
+	}
+
+	if (ret) {
+		if (!node) {
+			/* Get the empty or oldest entry
+			 * HW just maintain three fragLUTs
+			 * just kick out oldest entry (Should it happen?)
+			 */
+			node = list_entry(defrag_entry->list.prev,
+					  struct rx_defrag_node, list);
+		}
+		__init_first_frag_node(node, msdu_desc);
+
+		/* Move this node to head */
+		if (defrag_entry->list.next != &node->list)
+			list_move(&node->list, &defrag_entry->list);
+	}
+
+	return node;
+}
+
+static struct rx_defrag_node
+*get_defrag_node(struct sprdwl_rx_defrag_entry *defrag_entry,
+		 struct rx_msdu_desc *msdu_desc)
+{
+	struct rx_defrag_node *node = NULL;
+
+	wl_debug("%s: frag_num: %d\n", __func__, msdu_desc->frag_num);
+
+	/* HW do not record entry time when HW suspend
+	 * So we need to judge whether this entry is alive
+	 */
+	if (msdu_desc->frag_num) {
+		/* Check whether this entry alive or this fragment avail */
+		node = find_defrag_node(defrag_entry, msdu_desc);
+	} else {
+		node = init_first_defrag_node(defrag_entry, msdu_desc);
+	}
+
+	return node;
+}
+
+static struct sk_buff
+*defrag_single_data_process(struct sprdwl_rx_defrag_entry *defrag_entry,
+			    struct sk_buff *pskb)
+{
+	struct rx_defrag_node *node = NULL;
+	struct rx_msdu_desc *msdu_desc = (struct rx_msdu_desc *)pskb->data;
+	unsigned short offset = 0, frag_len = 0, frag_offset = 0;
+	struct sk_buff *skb = NULL, *pos_skb = NULL;
+
+	node = get_defrag_node(defrag_entry, msdu_desc);
+	if (node) {
+		skb_queue_tail(&node->skb_list, pskb);
+		if (msdu_desc->snap_hdr_present)
+			frag_len = msdu_desc->msdu_len - ETH_HLEN;
+		else
+			frag_len = msdu_desc->msdu_len - 2*ETH_ALEN;
+		node->msdu_len += frag_len;
+
+		wl_debug("%s: more_frag_bit: %d, node msdu_len: %d\n",
+			 __func__, msdu_desc->more_frag_bit, node->msdu_len);
+		if (!msdu_desc->more_frag_bit) {
+			skb = skb_dequeue(&node->skb_list);
+			msdu_desc = (struct rx_msdu_desc *)skb->data;
+			offset = msdu_total_len(msdu_desc);
+			msdu_desc->msdu_len =
+				node->msdu_len - msdu_desc->msdu_offset;
+
+			pos_skb = dev_alloc_skb(node->msdu_len);
+			if (unlikely(!pos_skb)) {
+				/* Free all skbs */
+				wl_err("%s: expand skb fail\n", __func__);
+				skb_queue_purge(&node->skb_list);
+				dev_kfree_skb(skb);
+				skb = NULL;
+				goto exit;
+			}
+
+			memcpy(pos_skb->data, skb->data, offset);
+			dev_kfree_skb(skb);
+			skb = pos_skb;
+
+			while ((pos_skb = skb_dequeue(&node->skb_list))) {
+				msdu_desc =
+					(struct rx_msdu_desc *)pos_skb->data;
+				if (msdu_desc->snap_hdr_present) {
+					frag_len = msdu_desc->msdu_len -
+							ETH_HLEN;
+					frag_offset = msdu_desc->msdu_offset +
+							ETH_HLEN;
+				} else {
+					frag_len = msdu_desc->msdu_len -
+							2*ETH_ALEN;
+					frag_offset = msdu_desc->msdu_offset +
+							2*ETH_ALEN;
+				}
+
+				wl_debug("%s: frag_len: %d, frag_offset: %d\n",
+					 __func__, frag_len, frag_offset);
+				memcpy((skb->data + offset),
+				       (pos_skb->data + frag_offset), frag_len);
+				offset += frag_len;
+
+				dev_kfree_skb(pos_skb);
+			}
+
+			fill_skb_csum(skb, 0);
+			skb->next = NULL;
+exit:
+			/* Move this entry to tail */
+			if (!list_is_last(&node->list, &defrag_entry->list))
+				list_move_tail(&node->list,
+					       &defrag_entry->list);
+		}
+	} else {
+		dev_kfree_skb(pskb);
+	}
+
+	return skb;
+}
+
+struct sk_buff
+*defrag_data_process(struct sprdwl_rx_defrag_entry *defrag_entry,
+		     struct sk_buff *pskb)
+{
+	struct rx_msdu_desc *msdu_desc = (struct rx_msdu_desc *)pskb->data;
+	struct sk_buff *skb = NULL;
+
+	if (!msdu_desc->frag_num && !msdu_desc->more_frag_bit)
+		skb = pskb;
+	else
+		skb = defrag_single_data_process(defrag_entry, pskb);
+
+	return skb;
+}
+
+int sprdwl_defrag_init(struct sprdwl_rx_defrag_entry *defrag_entry)
+{
+	int i = 0;
+	struct rx_defrag_node *node = NULL;
+	int ret = 0;
+
+	INIT_LIST_HEAD(&defrag_entry->list);
+
+	for (i = 0; i < MAX_DEFRAG_NUM; i++) {
+		node = kzalloc(sizeof(*node), GFP_KERNEL);
+		if (likely(node)) {
+			skb_queue_head_init(&node->skb_list);
+			list_add(&node->list, &defrag_entry->list);
+		} else {
+			wl_err("%s: fail to alloc rx_defrag_node\n", __func__);
+			ret = -ENOMEM;
+			break;
+		}
+	}
+
+	return ret;
+}
+
+void sprdwl_defrag_deinit(struct sprdwl_rx_defrag_entry *defrag_entry)
+{
+	struct rx_defrag_node *node = NULL, *pos_node = NULL;
+
+	list_for_each_entry_safe(node, pos_node, &defrag_entry->list, list) {
+		list_del(&node->list);
+		if (!skb_queue_empty(&node->skb_list))
+			skb_queue_purge(&node->skb_list);
+		kfree(node);
+	}
+}
diff --git a/drivers/net/wireless/uwe5622/unisocwifi/defrag.h b/drivers/net/wireless/uwe5622/unisocwifi/defrag.h
new file mode 100644
index 000000000000..127bc6a42c4f
--- /dev/null
+++ b/drivers/net/wireless/uwe5622/unisocwifi/defrag.h
@@ -0,0 +1,35 @@
+#ifndef __DEFRAG__H__
+#define __DEFRAG__H__
+
+#include <linux/skbuff.h>
+
+#define MAX_DEFRAG_NUM 3
+
+struct rx_defrag_desc {
+	unsigned char sta_lut_index;
+	unsigned char tid;
+	unsigned char frag_num;
+	unsigned short seq_num;
+};
+
+struct rx_defrag_node {
+	struct list_head list;
+	struct rx_defrag_desc desc;
+	struct sk_buff_head skb_list;
+	unsigned int msdu_len;
+	unsigned char last_frag_num;
+};
+
+struct sprdwl_rx_defrag_entry {
+	struct list_head list;
+	struct sk_buff *skb_head;
+	struct sk_buff *skb_last;
+};
+
+int sprdwl_defrag_init(struct sprdwl_rx_defrag_entry *defrag_entry);
+void sprdwl_defrag_deinit(struct sprdwl_rx_defrag_entry *defrag_entry);
+struct sk_buff
+*defrag_data_process(struct sprdwl_rx_defrag_entry *defrag_entry,
+		     struct sk_buff *pskb);
+
+#endif /*__DEFRAG__H__*/
diff --git a/drivers/net/wireless/uwe5622/unisocwifi/ibss.c b/drivers/net/wireless/uwe5622/unisocwifi/ibss.c
new file mode 100644
index 000000000000..d335635bc262
--- /dev/null
+++ b/drivers/net/wireless/uwe5622/unisocwifi/ibss.c
@@ -0,0 +1,209 @@
+/*
+ * Copyright (C) 2015 Spreadtrum Communications Inc.
+ *
+ * Abstract : This file is an implementation for cfg80211 subsystem
+ *
+ * Authors:
+ * Chaojie Xu <chaojie.xu@spreadtrum.com>
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include "ibss.h"
+#include "sprdwl.h"
+
+#define IBSS_INITIAL_SCAN_ALLOWED	(1)
+#define IBSS_COALESCE_ALLOWED		(0)
+#define IBSS_COLESCE			(0)
+#define IBSS_SCAN_SUPPRESS		(0)
+#define IBSS_ATIM			(10)
+#define WPA_RSN			(2)
+
+/* cfg80211 */
+int sprdwl_cfg80211_join_ibss(struct wiphy *wiphy,
+				     struct net_device *ndev,
+				     struct cfg80211_ibss_params *params)
+{
+	int ret = 0;
+	struct ieee80211_channel *chan;
+	struct sprdwl_join_params join_params;
+	u32 join_params_size;
+	u8 coalesce = IBSS_COLESCE;
+	u8 scan_suppress = IBSS_SCAN_SUPPRESS;
+	u8 atim = IBSS_ATIM;
+#ifdef IBSS_RSN_SUPPORT
+	u8 wpa_version = WPA_RSN;
+#endif /* IBSS_RSN_SUPPORT */
+
+	struct sprdwl_vif *vif = netdev_priv(ndev);
+
+	wl_ndev_log(L_DBG, ndev, "%s enter\n", __func__);
+
+	if (SPRDWL_MODE_IBSS != vif->mode) {
+		wl_ndev_log(L_ERR, ndev, "%s invalid mode: %d\n", __func__,
+			   vif->mode);
+		return -EINVAL;
+	}
+
+	if (!params->ssid || params->ssid_len <= 0) {
+		wl_ndev_log(L_ERR, ndev, "%s invalid SSID\n", __func__);
+		return -EINVAL;
+	}
+
+	/* set channel */
+	chan = params->chandef.chan;
+	if (chan) {
+		ret =  sprdwl_set_channel(vif->priv, vif->mode,
+					  ieee80211_frequency_to_channel(
+					  chan->center_freq));
+		if (ret < 0) {
+			wl_ndev_log(L_ERR, ndev, "%s set channel failed(%d)\n",
+				   __func__, ret);
+			return ret;
+		}
+	}
+
+	 /* Join with specific SSID */
+
+	wl_ndev_log(L_INFO, ndev, "%s params->ssid=%s\n", __func__, params->ssid);
+	wl_ndev_log(L_INFO, ndev, "%s params->ssid_len=%d\n",
+		    __func__, params->ssid_len);
+	join_params_size = sizeof(join_params);
+	memset(&join_params, 0, join_params_size);
+	memcpy(join_params.ssid, params->ssid, params->ssid_len);
+	join_params.ssid_len = params->ssid_len;
+
+	if (params->bssid) {
+		join_params.bssid_len = ETH_ALEN;
+		ether_addr_copy(join_params.bssid, params->bssid);
+	} else {
+		join_params.bssid_len = 0;
+		memset(join_params.bssid, 0, ETH_ALEN);
+	}
+	wl_ndev_log(L_INFO, ndev, "%s join_params.ssid=%s\n",
+		    __func__, join_params.ssid);
+	wl_ndev_log(L_INFO, ndev, "%s join_params.ssid_len=%d\n",
+		    __func__, join_params.ssid_len);
+
+	/* attribute */
+	ret = sprdwl_set_ibss_attribute(vif->priv, vif->mode,
+					SPRDWL_IBSS_COALESCE, coalesce);
+	if (ret) {
+		wl_ndev_log(L_ERR, ndev, "%s set coalesce failed (%d)\n",
+			   __func__, ret);
+		return ret;
+	}
+
+	ret = sprdwl_set_ibss_attribute(vif->priv, vif->mode,
+					SPRDWL_IBSS_SCAN_SUPPRESS,
+					scan_suppress);
+	if (ret) {
+		wl_ndev_log(L_ERR, ndev, "%s set scan_suppress failed (%d)\n",
+			   __func__, ret);
+		return ret;
+	}
+
+	ret = sprdwl_set_ibss_attribute(vif->priv, vif->mode,
+					SPRDWL_IBSS_ATIM, atim);
+	if (ret) {
+		wl_ndev_log(L_ERR, ndev, "%s set ATIM failed (%d)\n",
+			   __func__, ret);
+		return ret;
+	}
+
+#ifdef IBSS_RSN_SUPPORT
+	ret = sprdwl_set_ibss_attribute(vif->priv, vif->mode,
+					SPRDWL_IBSS_WPA_VERSION, wpa_version);
+	if (ret) {
+		wl_ndev_log(L_ERR, ndev, "%s set wpa_version failed (%d)\n",
+			   __func__, ret);
+		return ret;
+	}
+#endif /* IBSS_RSN_SUPPORT */
+
+	ret = sprdwl_ibss_join(vif->priv, vif->mode,
+			       &join_params, join_params_size);
+	if (ret) {
+		wl_ndev_log(L_ERR, ndev, "%s join failed (%d)\n", __func__, ret);
+		return ret;
+	}
+
+	/* update */
+	ether_addr_copy(vif->bssid, join_params.bssid);
+	memcpy(vif->ssid, join_params.ssid, join_params.ssid_len);
+	vif->ssid_len = join_params.ssid_len;
+
+	return ret;
+}
+
+int sprdwl_cfg80211_leave_ibss(struct wiphy *wiphy,
+				      struct net_device *ndev)
+{
+	struct sprdwl_vif *vif = netdev_priv(ndev);
+	enum sm_state old_state = vif->sm_state;
+	int ret = 0;
+
+	wl_ndev_log(L_DBG, ndev, "%s enter\n", __func__);
+
+	if (SPRDWL_MODE_IBSS != vif->mode) {
+		wl_ndev_log(L_ERR, ndev, "%s invalid mode: %d\n", __func__,
+			   vif->mode);
+		return -EINVAL;
+	}
+
+	vif->sm_state = SPRDWL_DISCONNECTING;
+	/* disconect, use reason code 0 temporarily*/
+	ret = sprdwl_disconnect(vif->priv, vif->mode, 0);
+	if (ret < 0) {
+		vif->sm_state = old_state;
+		wl_ndev_log(L_ERR, ndev, "%s disconnect failed (%d)\n", __func__, ret);
+		return ret;
+	}
+
+	memset(vif->ssid, 0, sizeof(vif->ssid));
+	memset(vif->bssid, 0, ETH_ALEN);
+
+	return ret;
+}
+
+/* cmd */
+int sprdwl_set_ibss_attribute(struct sprdwl_priv *priv, u8 vif_mode,
+				u8 sub_type, u8 value)
+{
+	struct sprdwl_msg_buf *msg;
+	struct sprdwl_ibss_attr *p;
+
+	msg = sprdwl_cmd_getbuf(priv, sizeof(*p), vif_mode,
+				SPRDWL_HEAD_RSP, WIFI_CMD_SET_IBSS_ATTR);
+	if (!msg)
+		return -ENOMEM;
+	p = (struct sprdwl_ibss_attr *)msg->data;
+	p->sub_type = sub_type;
+	p->value = value;
+
+	return sprdwl_cmd_send_recv(priv, msg, CMD_WAIT_TIMEOUT, NULL, NULL);
+}
+
+int sprdwl_ibss_join(struct sprdwl_priv *priv, u8 vif_mode,
+			struct sprdwl_join_params *params, u32 params_len)
+{
+	struct sprdwl_msg_buf *msg;
+	struct sprdwl_join_params *p;
+
+	msg = sprdwl_cmd_getbuf(priv, sizeof(*p), vif_mode,
+				SPRDWL_HEAD_RSP, WIFI_CMD_IBSS_JOIN);
+	if (!msg)
+		return -ENOMEM;
+
+	p = (struct sprdwl_join_params *)msg->data;
+	memcpy(p, params, params_len);
+
+	return sprdwl_cmd_send_recv(priv, msg, CMD_WAIT_TIMEOUT, NULL, NULL);
+}
diff --git a/drivers/net/wireless/uwe5622/unisocwifi/ibss.h b/drivers/net/wireless/uwe5622/unisocwifi/ibss.h
new file mode 100644
index 000000000000..82c00cd32aee
--- /dev/null
+++ b/drivers/net/wireless/uwe5622/unisocwifi/ibss.h
@@ -0,0 +1,36 @@
+#ifndef __SPRDWL_IBSS_H__
+#define __SPRDWL_IBSS_H__
+
+#include "sprdwl.h"
+
+/* IBSS attribute */
+struct sprdwl_ibss_attr {
+#define SPRDWL_IBSS_COALESCE		1
+#define SPRDWL_IBSS_SCAN_SUPPRESS	2
+#define SPRDWL_IBSS_ATIM		3
+#define SPRDWL_IBSS_WPA_VERSION		4
+	u8 sub_type;
+	u8 value;
+} __packed;
+
+/* used for join with or without a specific bssid */
+struct sprdwl_join_params {
+	unsigned short ssid_len;
+	unsigned char ssid[32];
+	unsigned short bssid_len;
+	unsigned char bssid[6];
+} __packed;
+
+/* cfg80211 */
+int sprdwl_cfg80211_join_ibss(struct wiphy *wiphy,
+				     struct net_device *ndev,
+				     struct cfg80211_ibss_params *params);
+int sprdwl_cfg80211_leave_ibss(struct wiphy *wiphy,
+				      struct net_device *ndev);
+
+/* cmd */
+int sprdwl_set_ibss_attribute(struct sprdwl_priv *priv, u8 vif_mode,
+				u8 sub_type, u8 value);
+int sprdwl_ibss_join(struct sprdwl_priv *priv, u8 vif_mode,
+			struct sprdwl_join_params *params, u32 params_len);
+#endif
diff --git a/drivers/net/wireless/uwe5622/unisocwifi/intf.h b/drivers/net/wireless/uwe5622/unisocwifi/intf.h
new file mode 100644
index 000000000000..41b9bd5a3fe9
--- /dev/null
+++ b/drivers/net/wireless/uwe5622/unisocwifi/intf.h
@@ -0,0 +1,41 @@
+/*
+ * Copyright (C) 2013 Spreadtrum Communications Inc.
+ *
+ * Authors:
+ * Keguang Zhang <keguang.zhang@spreadtrum.com>
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#ifndef __SPRDWL_INTF_H__
+#define __SPRDWL_INTF_H__
+
+#include "msg.h"
+
+struct sprdwl_priv;
+
+struct sprdwl_if_ops {
+	struct sprdwl_msg_buf *(*get_msg_buf)(void *sdev,
+					      enum sprdwl_head_type type,
+					      enum sprdwl_mode mode,
+					      u8 ctx_id);
+
+	void (*free_msg_buf)(void *sdev, struct sprdwl_msg_buf *msg);
+	int (*tx)(void *spdev, struct sprdwl_msg_buf *msg);
+	void (*force_exit)(void *spdev);
+	int (*is_exit)(void *spdev);
+	int (*suspend)(struct sprdwl_priv *priv);
+	int (*resume)(struct sprdwl_priv *priv);
+	void (*debugfs)(void *spdev, struct dentry *dir);
+	void (*tcp_drop_msg)(void *spdev, struct sprdwl_msg_buf *msg);
+	int (*ini_download_status)(void);
+};
+
+#endif/*__INTF_H__*/
diff --git a/drivers/net/wireless/uwe5622/unisocwifi/intf_ops.h b/drivers/net/wireless/uwe5622/unisocwifi/intf_ops.h
new file mode 100644
index 000000000000..c580b3040260
--- /dev/null
+++ b/drivers/net/wireless/uwe5622/unisocwifi/intf_ops.h
@@ -0,0 +1,97 @@
+/*
+ * Copyright (C) 2015 Spreadtrum Communications Inc.
+ *
+ * Authors	:
+ * Keguang Zhang <keguang.zhang@spreadtrum.com>
+ * Jingxiang Li <Jingxiang.li@spreadtrum.com>
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#ifndef __SPRDWL_INTF_OPS_H__
+#define __SPRDWL_INTF_OPS_H__
+
+#include <linux/dcache.h>
+#include "intf.h"
+
+static
+inline struct sprdwl_msg_buf *sprdwl_intf_get_msg_buf(struct sprdwl_priv *priv,
+						      enum sprdwl_head_type
+						      type,
+						      enum sprdwl_mode mode,
+						      u8 ctx_id)
+{
+	return priv->if_ops->get_msg_buf(priv->hw_priv, type, mode, ctx_id);
+}
+
+static inline void sprdwl_intf_free_msg_buf(struct sprdwl_priv *priv,
+					    struct sprdwl_msg_buf *msg)
+{
+	return priv->if_ops->free_msg_buf(priv->hw_priv, msg);
+}
+
+/* return:
+ *      0, msg buf freed by the real driver
+ *      others, skb need free by the caller,remember not use msg->skb!
+ */
+static inline int sprdwl_intf_tx(struct sprdwl_priv *priv,
+				 struct sprdwl_msg_buf *msg)
+{
+	return priv->if_ops->tx(priv->hw_priv, msg);
+}
+
+static inline void sprdwl_intf_force_exit(struct sprdwl_priv *priv)
+{
+	priv->if_ops->force_exit(priv->hw_priv);
+}
+
+static inline int sprdwl_intf_is_exit(struct sprdwl_priv *priv)
+{
+	return priv->if_ops->is_exit(priv->hw_priv);
+}
+
+static inline int sprdwl_intf_suspend(struct sprdwl_priv *priv)
+{
+	if (priv->if_ops->suspend)
+		return priv->if_ops->suspend(priv);
+
+	return 0;
+}
+
+static inline int sprdwl_intf_resume(struct sprdwl_priv *priv)
+{
+	if (priv->if_ops->resume)
+		return priv->if_ops->resume(priv);
+
+	return 0;
+}
+
+static inline void sprdwl_intf_debugfs(struct sprdwl_priv *priv,
+				       struct dentry *dir)
+{
+	if (priv->if_ops->debugfs)
+		priv->if_ops->debugfs(priv->hw_priv, dir);
+}
+
+static inline void sprdwl_intf_tcp_drop_msg(struct sprdwl_priv *priv,
+					    struct sprdwl_msg_buf *msg)
+{
+	if (priv->if_ops->tcp_drop_msg)
+		priv->if_ops->tcp_drop_msg(priv->hw_priv, msg);
+}
+
+static inline int sprdwl_get_ini_status(struct sprdwl_priv *priv)
+{
+	if (priv->if_ops->ini_download_status)
+		return priv->if_ops->ini_download_status();
+	return 0;
+}
+
+#endif
diff --git a/drivers/net/wireless/uwe5622/unisocwifi/main.c b/drivers/net/wireless/uwe5622/unisocwifi/main.c
new file mode 100644
index 000000000000..aec824cde4ce
--- /dev/null
+++ b/drivers/net/wireless/uwe5622/unisocwifi/main.c
@@ -0,0 +1,1643 @@
+/*
+ * Copyright (C) 2015 Spreadtrum Communications Inc.
+ *
+ * Authors	:
+ * Keguang Zhang <keguang.zhang@spreadtrum.com>
+ * Jingxiang Li <Jingxiang.li@spreadtrum.com>
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include "sprdwl.h"
+#include "npi.h"
+#include "cfg80211.h"
+#include "cmdevt.h"
+#include "txrx.h"
+#include "msg.h"
+#include "intf_ops.h"
+#include "vendor.h"
+#include "work.h"
+#include "tx_msg.h"
+#include "rx_msg.h"
+#include "wl_core.h"
+#include "tcp_ack.h"
+#ifdef DFS_MASTER
+#include "11h.h"
+#endif
+
+#ifdef RTT_SUPPORT
+#include "rtt.h"
+#endif /* RTT_SUPPORT */
+
+#ifdef TCPACK_DELAY_SUPPORT
+#include "tcp_ack.h"
+#endif
+
+struct sprdwl_priv *g_sprdwl_priv;
+
+static void str2mac(const char *mac_addr, u8 *mac)
+{
+	unsigned int m[ETH_ALEN];
+
+	if (sscanf(mac_addr, "%02x:%02x:%02x:%02x:%02x:%02x",
+		   &m[0], &m[1], &m[2], &m[3], &m[4], &m[5]) != ETH_ALEN)
+		wl_err("failed to parse mac address '%s'", mac_addr);
+	mac[0] = m[0];
+	mac[1] = m[1];
+	mac[2] = m[2];
+	mac[3] = m[3];
+	mac[4] = m[4];
+	mac[5] = m[5];
+}
+
+void sprdwl_netif_rx(struct sk_buff *skb, struct net_device *ndev)
+{
+	struct sprdwl_vif *vif;
+	struct sprdwl_intf *intf;
+	struct sprdwl_rx_if *rx_if = NULL;
+
+	vif = netdev_priv(ndev);
+	intf = (struct sprdwl_intf *)(vif->priv->hw_priv);
+	rx_if = (struct sprdwl_rx_if *)intf->sprdwl_rx;
+
+	wl_hex_dump(L_DBG, "RX packet: ", DUMP_PREFIX_OFFSET,
+			     16, 1, skb->data, skb->len, 0);
+
+	skb->dev = ndev;
+	skb->protocol = eth_type_trans(skb, ndev);
+	/* CHECKSUM_UNNECESSARY not supported by our hardware */
+	/* skb->ip_summed = CHECKSUM_UNNECESSARY; */
+
+	ndev->stats.rx_packets++;
+	ndev->stats.rx_bytes += skb->len;
+#if defined(MORE_DEBUG)
+		intf->stats.rx_packets++;
+		intf->stats.rx_bytes += skb->len;
+		if (skb->pkt_type == PACKET_MULTICAST)
+			intf->stats.rx_multicast++;
+#endif
+
+#ifndef RX_NAPI
+/*to ensure data handled in netif in order*/
+	local_bh_disable();
+	netif_receive_skb(skb);
+	local_bh_enable();
+#else
+	skb_orphan(skb);
+	napi_gro_receive(&rx_if->napi_rx, skb);
+#endif
+}
+
+void sprdwl_stop_net(struct sprdwl_vif *vif)
+{
+	struct sprdwl_vif *real_vif, *tmp_vif;
+	struct sprdwl_priv *priv = vif->priv;
+
+	spin_lock_bh(&priv->list_lock);
+	list_for_each_entry_safe(real_vif, tmp_vif, &priv->vif_list, vif_node)
+		if (real_vif->ndev)
+			netif_stop_queue(real_vif->ndev);
+	spin_unlock_bh(&priv->list_lock);
+}
+
+static void sprdwl_netflowcontrl_mode(struct sprdwl_priv *priv,
+				      enum sprdwl_mode mode, bool state)
+{
+	struct sprdwl_vif *vif;
+
+	vif = mode_to_vif(priv, mode);
+	if (vif) {
+		if (state)
+			netif_wake_queue(vif->ndev);
+		else
+			netif_stop_queue(vif->ndev);
+		sprdwl_put_vif(vif);
+	}
+}
+
+static void sprdwl_netflowcontrl_all(struct sprdwl_priv *priv, bool state)
+{
+	struct sprdwl_vif *real_vif, *tmp_vif;
+
+	spin_lock_bh(&priv->list_lock);
+	list_for_each_entry_safe(real_vif, tmp_vif, &priv->vif_list, vif_node)
+		if (real_vif->ndev) {
+			if (state)
+				netif_wake_queue(real_vif->ndev);
+			else
+				netif_stop_queue(real_vif->ndev);
+		}
+	spin_unlock_bh(&priv->list_lock);
+}
+
+/* @state: true for netif_start_queue
+ *	   false for netif_stop_queue
+ */
+void sprdwl_net_flowcontrl(struct sprdwl_priv *priv,
+			   enum sprdwl_mode mode, bool state)
+{
+	if (mode != SPRDWL_MODE_NONE)
+		sprdwl_netflowcontrl_mode(priv, mode, state);
+	else
+		sprdwl_netflowcontrl_all(priv, state);
+}
+
+#ifdef PPPOE_LLC_SUPPORT
+static struct sk_buff *sprdwl_fill_pppoe_llc_header(struct sk_buff *skb)
+{
+#define LLC_HEADER_LEN 8
+	struct ethhdr *ethhdr = NULL;
+	char *llc = NULL;
+	char llc_header_disc[] = {0xAA, 0xAA, 0x03, 0x00, 0x00, 0x00, 0x88, 0x63};
+	char llc_header_sec[] = {0xAA, 0xAA, 0x03, 0x00, 0x00, 0x00, 0x88, 0x64};
+
+	ethhdr = (struct ethhdr *)skb->data;
+
+	switch (htons(ethhdr->h_proto)) {
+	case ETH_P_PPP_DISC:
+		llc = llc_header_disc;
+		break;
+	case ETH_P_PPP_SES:
+		llc = llc_header_sec;
+		break;
+	default:
+		return skb;
+	}
+
+	if (unlikely(skb_headroom(skb) < LLC_HEADER_LEN)) {
+		struct sk_buff *skb2 = NULL;
+		skb2 = skb_realloc_headroom(skb, LLC_HEADER_LEN);
+		if (!skb2) {
+			kfree_skb(skb);
+			pr_err("realloc skb headroom for llc failed\n");
+			return NULL;
+		}
+		if (skb->sk)
+			skb_set_owner_w(skb2, skb->sk);
+		consume_skb(skb);
+		skb = skb2;
+	}
+
+	skb_push(skb, LLC_HEADER_LEN);
+	memmove(skb->data, skb->data + LLC_HEADER_LEN, 14);
+	memcpy(skb->data + 14, llc, LLC_HEADER_LEN);
+
+	return skb;
+}
+#endif
+static int sprdwl_start_xmit(struct sk_buff *skb, struct net_device *ndev)
+{
+	struct sprdwl_vif *vif = netdev_priv(ndev);
+	int ret = 0;
+	struct sprdwl_msg_buf *msg = NULL;
+	u8 *data_temp;
+	struct sprdwl_eap_hdr *eap_temp;
+	struct sprdwl_intf *intf;
+
+	intf = (struct sprdwl_intf *)vif->priv->hw_priv;
+
+	if (intf->cp_asserted == 1 ||
+		intf->suspend_mode != SPRDWL_PS_RESUMED) {
+		dev_kfree_skb(skb);
+		return NETDEV_TX_OK;
+	}
+
+	/* drop nonlinearize skb */
+	if (skb_linearize(skb)) {
+		wl_err("nonlinearize skb\n");
+		dev_kfree_skb(skb);
+		ndev->stats.tx_dropped++;
+		goto out;
+	}
+
+	data_temp = (u8 *)(skb->data) + sizeof(struct ethhdr);
+	eap_temp = (struct sprdwl_eap_hdr *)data_temp;
+	if (vif->mode == SPRDWL_MODE_P2P_GO &&
+		skb->protocol == cpu_to_be16(ETH_P_PAE) &&
+		eap_temp->type == EAP_PACKET_TYPE &&
+		eap_temp->code == EAP_FAILURE_CODE) {
+		sprdwl_xmit_data2cmd(skb, ndev);
+		return NETDEV_TX_OK;
+	}
+
+	/* FIXME vif connect state, need fix cfg80211_connect_result when MCC */
+	/*if (vif->connect_status != SPRDWL_CONNECTED) */
+
+	/* Hardware tx data queue prority is lower than management queue
+	 * management frame will be send out early even that get into queue
+	 * after data frame.
+	 * Workaround way: Put eap failure frame to high queue
+	 * by use tx mgmt cmd
+	 */
+	/* send 802.1x or WAPI frame from cmd channel */
+
+	if (skb->protocol == cpu_to_be16(ETH_P_PAE) ||
+		skb->protocol == cpu_to_be16(WAPI_TYPE)) {
+		wl_info("send %s frame by WIFI_CMD_TX_DATA\n",
+		       skb->protocol == cpu_to_be16(ETH_P_PAE) ?
+		       "802.1X" : "WAI");
+		if (sprdwl_xmit_data2cmd_wq(skb, ndev) == -EAGAIN)
+			return NETDEV_TX_BUSY;
+		return NETDEV_TX_OK;
+	} else {
+		ret = sprdwl_tx_filter_packet(skb, ndev);
+		if (!ret)
+			return NETDEV_TX_OK;
+	}
+
+	/*mode not open, so we will not send data*/
+	if (vif->priv->fw_stat[vif->mode] != SPRDWL_INTF_OPEN) {
+		wl_err_ratelimited("%s, %d, should not send this data\n",
+		       __func__, __LINE__);
+		return NETDEV_TX_BUSY;
+	}
+
+	msg = sprdwl_intf_get_msg_buf(vif->priv,
+				      SPRDWL_TYPE_DATA,
+				      vif->mode,
+				      vif->ctx_id);
+	if (!msg) {
+		wl_err("%s, %d, get msg bug failed\n", __func__, __LINE__);
+		ndev->stats.tx_fifo_errors++;
+		return NETDEV_TX_BUSY;
+	}
+
+	if (skb_headroom(skb) < ndev->needed_headroom) {
+		struct sk_buff *tmp_skb = skb;
+
+		skb = skb_realloc_headroom(skb, ndev->needed_headroom);
+		dev_kfree_skb(tmp_skb);
+		if (!skb) {
+			wl_ndev_log(L_ERR, ndev,
+				   "%s skb_realloc_headroom failed\n",
+				   __func__);
+			sprdwl_intf_free_msg_buf(vif->priv, msg);
+			goto out;
+		}
+	}
+#ifdef PPPOE_LLC_SUPPORT
+	skb = sprdwl_fill_pppoe_llc_header(skb);
+	if (!skb) {
+		sprdwl_intf_free_msg_buf(vif->priv, msg);
+		return NETDEV_TX_OK;
+	}
+#endif
+	ret = sprdwl_send_data(vif, msg, skb, 0);
+	if (ret) {
+		wl_ndev_log(L_ERR, ndev, "%s drop msg due to TX Err\n", __func__);
+		/* FIXME as debug sdiom later, here just drop the msg
+		 * wapi temp drop
+		 */
+		dev_kfree_skb(skb);
+		sprdwl_intf_free_msg_buf(vif->priv, msg);
+		return NETDEV_TX_OK;
+	}
+
+	vif->ndev->stats.tx_bytes += skb->len;
+	vif->ndev->stats.tx_packets++;
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4, 7, 0)
+	ndev->trans_start = jiffies;
+#else
+	netif_trans_update(vif->ndev);
+#endif
+	wl_hex_dump(L_DBG, "TX packet: ", DUMP_PREFIX_OFFSET,
+			     16, 1, skb->data, skb->len, 0);
+
+out:
+	return NETDEV_TX_OK;
+}
+
+static int sprdwl_init(struct net_device *ndev)
+{
+	struct sprdwl_vif *vif = netdev_priv(ndev);
+
+	/* initialize firmware */
+	return sprdwl_init_fw(vif);
+}
+
+static void sprdwl_uninit(struct net_device *ndev)
+{
+	struct sprdwl_vif *vif = netdev_priv(ndev);
+
+	sprdwl_uninit_fw(vif);
+}
+
+static int sprdwl_open(struct net_device *ndev)
+{
+	wl_ndev_log(L_DBG, ndev, "%s\n", __func__);
+#ifdef DFS_MASTER
+	netif_carrier_off(ndev);
+#endif
+
+	netif_start_queue(ndev);
+
+	return 0;
+}
+
+static int sprdwl_close(struct net_device *ndev)
+{
+	struct sprdwl_vif *vif = netdev_priv(ndev);
+
+	wl_ndev_log(L_DBG, ndev, "%s\n", __func__);
+
+	sprdwl_scan_done(vif, true);
+	sprdwl_sched_scan_done(vif, true);
+	netif_stop_queue(ndev);
+	if (netif_carrier_ok(ndev))
+		netif_carrier_off(ndev);
+
+	return 0;
+}
+
+static struct net_device_stats *sprdwl_get_stats(struct net_device *ndev)
+{
+	return &ndev->stats;
+}
+
+static void sprdwl_tx_timeout(struct net_device *ndev, unsigned int val)
+{
+	wl_ndev_log(L_DBG, ndev, "%s\n", __func__);
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4, 7, 0)
+	ndev->trans_start = jiffies;
+#else
+	netif_trans_update(ndev);
+#endif
+	netif_wake_queue(ndev);
+}
+
+#define MAX_PRIV_CMD_LEN		SPRDWL_MAX_CMD_TXLEN
+#define CMD_BLACKLIST_ENABLE		"BLOCK"
+#define CMD_BLACKLIST_DISABLE		"UNBLOCK"
+#define CMD_ADD_WHITELIST		"WHITE_ADD"
+#define CMD_DEL_WHITELIST		"WHITE_DEL"
+#define CMD_ENABLE_WHITELIST		"WHITE_EN"
+#define CMD_DISABLE_WHITELIST		"WHITE_DIS"
+#define CMD_SETSUSPENDMODE		"SETSUSPENDMODE"
+#define CMD_SET_FCC_CHANNEL		"SET_FCC_CHANNEL"
+#define CMD_SET_COUNTRY			"COUNTRY"
+#define CMD_11V_GET_CFG			"11VCFG_GET"
+#define CMD_11V_SET_CFG			"11VCFG_SET"
+#define CMD_11V_WNM_SLEEP		"WNM_SLEEP"
+#define CMD_SET_MAX_CLIENTS		"MAX_STA"
+
+#define CMD_BTCOEXSCAN_START     "BTCOEXSCAN-START"
+#define CMD_BTCOEXSCAN_STOP      "BTCOEXSCAN-STOP"
+#define CMD_RXFILTER_STOP        "RXFILTER-STOP"
+#define CMD_RXFILTER_ADD         "RXFILTER-ADD"
+#define CMD_RXFILTER_START       "RXFILTER-START"
+#define CMD_RXFILTER_REMOVE      "RXFILTER-REMOVE"
+#define CMD_SETBAND              "SETBAND"
+#define CMD_BTCOEXMODE           "BTCOEXMODE"
+#define CMD_WLS_BATCHING         "WLS_BATCHING"
+#define CMD_SET_AP_WPS_P2P_IE    "SET_AP_WPS_P2P_IE"
+
+static int sprdwl_priv_cmd(struct net_device *ndev, struct ifreq *ifr)
+{
+#ifdef CONFIG_COMPAT
+	struct compat_android_wifi_priv_cmd {
+		compat_caddr_t buf;
+		int used_len;
+		int total_len;
+	};
+#endif /* CONFIG_COMPAT */
+	int n_clients;
+	struct sprdwl_vif *vif = netdev_priv(ndev);
+	struct sprdwl_priv *priv = vif->priv;
+	struct android_wifi_priv_cmd priv_cmd;
+	char *command = NULL, *country = NULL;
+	u16 interval = 0;
+	int max_len;
+	u8 feat = 0, status = 0;
+	u8 addr[ETH_ALEN] = {0}, *mac_addr = NULL, *tmp, *mac_list;
+	int ret = 0, skip, counter, index, value;
+
+	if (!ifr->ifr_data)
+		return -EINVAL;
+#ifdef CONFIG_COMPAT
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(4, 6, 0))
+	if (in_compat_syscall())
+#else
+	if (is_compat_task())
+#endif
+	{
+		struct compat_android_wifi_priv_cmd compat_priv_cmd;
+		if (copy_from_user(&compat_priv_cmd, ifr->ifr_data,
+					sizeof(struct compat_android_wifi_priv_cmd))) {
+			return -EFAULT;
+		}
+		priv_cmd.buf = compat_ptr(compat_priv_cmd.buf);
+		priv_cmd.used_len = compat_priv_cmd.used_len;
+		priv_cmd.total_len = compat_priv_cmd.total_len;
+	} else
+#endif /* CONFIG_COMPAT */
+	{
+		if (copy_from_user(&priv_cmd, ifr->ifr_data, sizeof(priv_cmd)))
+			return -EFAULT;
+	}
+
+	/*add length check to avoid invalid NULL ptr*/
+	if (!priv_cmd.total_len) {
+		wl_ndev_log(L_INFO, ndev, "%s: priv cmd total len is invalid\n", __func__);
+		return -EINVAL;
+	}
+
+	/* fix max_len for mv300(total_len = 4096) */
+	max_len = priv_cmd.total_len > MAX_PRIV_CMD_LEN ? MAX_PRIV_CMD_LEN : priv_cmd.total_len;
+	command = kmalloc(max_len, GFP_KERNEL);
+	if (!command)
+		return -ENOMEM;
+	if (copy_from_user(command, priv_cmd.buf, max_len)) {
+		ret = -EFAULT;
+		goto out;
+	}
+
+	if (!strncasecmp(command, CMD_BLACKLIST_ENABLE,
+			 strlen(CMD_BLACKLIST_ENABLE))) {
+		skip = strlen(CMD_BLACKLIST_ENABLE) + 1;
+		str2mac(command + skip, addr);
+		if (!is_valid_ether_addr(addr))
+			goto out;
+		wl_ndev_log(L_INFO, ndev, "%s: block %pM\n", __func__, addr);
+		ret = sprdwl_set_blacklist(priv, vif->ctx_id,
+					   SPRDWL_SUBCMD_ADD, 1, addr);
+	} else if (!strncasecmp(command, CMD_BLACKLIST_DISABLE,
+				strlen(CMD_BLACKLIST_DISABLE))) {
+		skip = strlen(CMD_BLACKLIST_DISABLE) + 1;
+		str2mac(command + skip, addr);
+		if (!is_valid_ether_addr(addr))
+			goto out;
+		wl_ndev_log(L_INFO, ndev, "%s: unblock %pM\n", __func__, addr);
+		ret = sprdwl_set_blacklist(priv, vif->ctx_id,
+					   SPRDWL_SUBCMD_DEL, 1, addr);
+	} else if (!strncasecmp(command, CMD_ADD_WHITELIST,
+				strlen(CMD_ADD_WHITELIST))) {
+		skip = strlen(CMD_ADD_WHITELIST) + 1;
+		str2mac(command + skip, addr);
+		if (!is_valid_ether_addr(addr))
+			goto out;
+		wl_ndev_log(L_INFO, ndev, "%s: add whitelist %pM\n", __func__, addr);
+		ret = sprdwl_set_whitelist(priv, vif->ctx_id,
+					   SPRDWL_SUBCMD_ADD, 1, addr);
+	} else if (!strncasecmp(command, CMD_DEL_WHITELIST,
+				strlen(CMD_DEL_WHITELIST))) {
+		skip = strlen(CMD_DEL_WHITELIST) + 1;
+		str2mac(command + skip, addr);
+		if (!is_valid_ether_addr(addr))
+			goto out;
+		wl_ndev_log(L_INFO, ndev, "%s: delete whitelist %pM\n", __func__, addr);
+		ret = sprdwl_set_whitelist(priv, vif->ctx_id,
+					   SPRDWL_SUBCMD_DEL, 1, addr);
+	} else if (!strncasecmp(command, CMD_ENABLE_WHITELIST,
+				strlen(CMD_ENABLE_WHITELIST))) {
+		skip = strlen(CMD_ENABLE_WHITELIST) + 1;
+		counter = command[skip];
+		wl_ndev_log(L_INFO, ndev, "%s: enable whitelist counter : %d\n",
+			    __func__, counter);
+		if (!counter) {
+			ret = sprdwl_set_whitelist(priv, vif->ctx_id,
+						   SPRDWL_SUBCMD_ENABLE,
+						   0, NULL);
+			goto out;
+		}
+		mac_addr = kmalloc(ETH_ALEN * counter, GFP_KERNEL);
+		mac_list = mac_addr;
+		if (IS_ERR(mac_addr)) {
+			ret = -ENOMEM;
+			goto out;
+		}
+
+		tmp = command + skip + 1;
+		for (index = 0; index < counter; index++) {
+			str2mac(tmp, mac_addr);
+			if (!is_valid_ether_addr(mac_addr))
+				goto out;
+			wl_ndev_log(L_INFO, ndev, "%s: enable whitelist %pM\n",
+				    __func__, mac_addr);
+			mac_addr += ETH_ALEN;
+			tmp += 18;
+		}
+		ret = sprdwl_set_whitelist(priv, vif->ctx_id,
+					   SPRDWL_SUBCMD_ENABLE,
+					   counter, mac_list);
+		kfree(mac_list);
+	} else if (!strncasecmp(command, CMD_DISABLE_WHITELIST,
+				strlen(CMD_DISABLE_WHITELIST))) {
+		skip = strlen(CMD_DISABLE_WHITELIST) + 1;
+		counter = command[skip];
+		wl_ndev_log(L_INFO, ndev, "%s: disable whitelist counter : %d\n",
+			    __func__, counter);
+		if (!counter) {
+			ret = sprdwl_set_whitelist(priv, vif->ctx_id,
+						   SPRDWL_SUBCMD_DISABLE,
+						   0, NULL);
+			goto out;
+		}
+		mac_addr = kmalloc(ETH_ALEN * counter, GFP_KERNEL);
+		mac_list = mac_addr;
+		if (IS_ERR(mac_addr)) {
+			ret = -ENOMEM;
+			goto out;
+		}
+
+		tmp = command + skip + 1;
+		for (index = 0; index < counter; index++) {
+			str2mac(tmp, mac_addr);
+			if (!is_valid_ether_addr(mac_addr))
+				goto out;
+			wl_ndev_log(L_INFO, ndev, "%s: disable whitelist %pM\n",
+				    __func__, mac_addr);
+			mac_addr += ETH_ALEN;
+			tmp += 18;
+		}
+		ret = sprdwl_set_whitelist(priv, vif->ctx_id,
+					   SPRDWL_SUBCMD_DISABLE,
+					   counter, mac_list);
+		kfree(mac_list);
+	} else if (!strncasecmp(command, CMD_11V_GET_CFG,
+				strlen(CMD_11V_GET_CFG))) {
+		/* deflaut CP support all featrue */
+		if (max_len < (strlen(CMD_11V_GET_CFG) + 4)) {
+			ret = -ENOMEM;
+			goto out;
+		}
+		memset(command, 0, max_len);
+		if (priv->fw_std & SPRDWL_STD_11V)
+			feat = priv->wnm_ft_support;
+
+		sprintf(command, "%s %d", CMD_11V_GET_CFG, feat);
+		wl_ndev_log(L_INFO, ndev, "%s: get 11v feat\n", __func__);
+		if (copy_to_user(priv_cmd.buf, command, max_len)) {
+			wl_ndev_log(L_ERR, ndev, "%s: get 11v copy failed\n", __func__);
+			ret = -EFAULT;
+			goto out;
+		}
+	} else if (!strncasecmp(command, CMD_11V_SET_CFG,
+				strlen(CMD_11V_SET_CFG))) {
+		int skip = strlen(CMD_11V_SET_CFG) + 1;
+		int cfg = command[skip];
+
+		wl_ndev_log(L_INFO, ndev, "%s: 11v cfg %d\n", __func__, cfg);
+		sprdwl_set_11v_feature_support(priv, vif->ctx_id, cfg);
+	} else if (!strncasecmp(command, CMD_11V_WNM_SLEEP,
+				strlen(CMD_11V_WNM_SLEEP))) {
+		int skip = strlen(CMD_11V_WNM_SLEEP) + 1;
+
+		status = command[skip];
+		if (status)
+			interval = command[skip + 1];
+
+		wl_ndev_log(L_INFO, ndev, "%s: 11v sleep, status %d, interval %d\n",
+			    __func__, status, interval);
+		sprdwl_set_11v_sleep_mode(priv, vif->ctx_id, status, interval);
+	} else if (!strncasecmp(command, CMD_SET_COUNTRY,
+				strlen(CMD_SET_COUNTRY))) {
+		skip = strlen(CMD_SET_COUNTRY) + 1;
+		country = command + skip;
+
+		if (!country || strlen(country) != SPRDWL_COUNTRY_CODE_LEN) {
+			wl_ndev_log(L_ERR, ndev, "%s: invalid country code\n",
+				   __func__);
+			ret = -EINVAL;
+			goto out;
+		}
+		wl_ndev_log(L_INFO, ndev, "%s country code:%c%c\n", __func__,
+			    toupper(country[0]), toupper(country[1]));
+		ret = regulatory_hint(priv->wiphy, country);
+	} else if (!strncasecmp(command, CMD_SET_MAX_CLIENTS,
+		   strlen(CMD_SET_MAX_CLIENTS))) {
+		skip = strlen(CMD_SET_MAX_CLIENTS) + 1;
+		ret = kstrtou32(command+skip, 10, &n_clients);
+		if (ret < 0) {
+			ret = -EINVAL;
+			goto out;
+		}
+		ret = sprdwl_set_max_clients_allowed(priv, vif->ctx_id,
+						     n_clients);
+	} else if (!strncasecmp(command, CMD_SETSUSPENDMODE,
+			 strlen(CMD_SETSUSPENDMODE))) {
+		skip = strlen(CMD_SETSUSPENDMODE) + 1;
+		ret = kstrtoint(command + skip, 0, &value);
+		if (ret)
+			goto out;
+		wl_ndev_log(L_INFO, ndev, "%s: set suspend mode,value : %d\n",
+			    __func__, value);
+		ret = sprdwl_power_save(priv, vif->ctx_id,
+					SPRDWL_SCREEN_ON_OFF, value);
+	} else {
+#ifdef OTT_UWE
+		if (!strncasecmp(command, CMD_BTCOEXSCAN_STOP,
+					strlen(CMD_BTCOEXSCAN_STOP)))
+			ret = 0;
+		else if (!strncasecmp(command, CMD_BTCOEXSCAN_START,
+					strlen(CMD_BTCOEXSCAN_START)))
+			ret = 0;
+		else if (!strncasecmp(command, CMD_RXFILTER_STOP,
+					strlen(CMD_RXFILTER_STOP)))
+			ret = 0;
+		else if (!strncasecmp(command, CMD_RXFILTER_ADD,
+					strlen(CMD_RXFILTER_ADD)))
+			ret = 0;
+		else if (!strncasecmp(command, CMD_RXFILTER_START,
+					strlen(CMD_RXFILTER_START)))
+			ret = 0;
+		else if (!strncasecmp(command, CMD_RXFILTER_REMOVE,
+					strlen(CMD_RXFILTER_REMOVE)))
+			ret = 0;
+		else if (!strncasecmp(command, CMD_BTCOEXMODE,
+					strlen(CMD_BTCOEXMODE)))
+			ret = 0;
+		else if (!strncasecmp(command, CMD_WLS_BATCHING,
+					strlen(CMD_WLS_BATCHING)))
+			ret = 0;
+		else if (!strncasecmp(command, CMD_SETBAND,
+					strlen(CMD_SETBAND)))
+			ret = 0;
+		else if (!strncasecmp(command, CMD_SET_AP_WPS_P2P_IE,
+					strlen(CMD_SET_AP_WPS_P2P_IE)))
+			ret = 0;
+		else {
+			wl_ndev_log(L_ERR, ndev, "sprdbg: %s command(%s) not support\n", __func__, command);
+			ret = -ENOTSUPP;
+		}
+#else
+		wl_ndev_log(L_ERR, ndev, "sprdbg: %s command(%s) not support\n", __func__, command);
+		ret = -ENOTSUPP;
+#endif
+	}
+out:
+	kfree(command);
+	return ret;
+}
+
+static int sprdwl_set_power_save(struct net_device *ndev, struct ifreq *ifr)
+{
+	struct sprdwl_vif *vif = netdev_priv(ndev);
+	struct sprdwl_priv *priv = vif->priv;
+	struct android_wifi_priv_cmd priv_cmd;
+	char *command = NULL;
+	int ret = 0, skip, value;
+
+	if (!ifr->ifr_data)
+		return -EINVAL;
+	if (copy_from_user(&priv_cmd, ifr->ifr_data, sizeof(priv_cmd)))
+		return -EFAULT;
+
+	command = kmalloc(priv_cmd.total_len, GFP_KERNEL);
+	if (!command)
+		return -ENOMEM;
+	if (copy_from_user(command, priv_cmd.buf, priv_cmd.total_len)) {
+		ret = -EFAULT;
+		goto out;
+	}
+
+	if (!strncasecmp(command, CMD_SETSUSPENDMODE,
+			 strlen(CMD_SETSUSPENDMODE))) {
+		skip = strlen(CMD_SETSUSPENDMODE) + 1;
+		ret = kstrtoint(command + skip, 0, &value);
+		if (ret)
+			goto out;
+		wl_ndev_log(L_INFO, ndev, "%s: set suspend mode,value : %d\n",
+			    __func__, value);
+		ret = sprdwl_power_save(priv, vif->ctx_id,
+					SPRDWL_SCREEN_ON_OFF, value);
+	} else if (!strncasecmp(command, CMD_SET_FCC_CHANNEL,
+				strlen(CMD_SET_FCC_CHANNEL))) {
+		skip = strlen(CMD_SET_FCC_CHANNEL) + 1;
+		ret = kstrtoint(command + skip, 0, &value);
+		if (ret)
+			goto out;
+		wl_ndev_log(L_INFO, ndev, "%s: set fcc channel,value : %d\n",
+			    __func__, value);
+		ret = sprdwl_power_save(priv, vif->ctx_id,
+					SPRDWL_SET_FCC_CHANNEL, value);
+	} else {
+		wl_ndev_log(L_ERR, ndev, "%s command not support\n", __func__);
+		ret = -ENOTSUPP;
+	}
+out:
+	kfree(command);
+	return ret;
+}
+
+static int sprdwl_set_tlv(struct net_device *ndev, struct ifreq *ifr)
+{
+	struct sprdwl_vif *vif = netdev_priv(ndev);
+	struct sprdwl_priv *priv = vif->priv;
+	struct android_wifi_priv_cmd priv_cmd;
+	struct sprdwl_tlv_data *tlv;
+	int ret;
+
+	if (!ifr->ifr_data)
+		return -EINVAL;
+
+	if (copy_from_user(&priv_cmd, ifr->ifr_data, sizeof(priv_cmd)))
+		return -EFAULT;
+
+	if (priv_cmd.total_len < sizeof(*tlv))
+		return -EINVAL;
+
+	tlv = kmalloc(priv_cmd.total_len, GFP_KERNEL);
+	if (!tlv)
+		return -ENOMEM;
+
+	if (copy_from_user(tlv, priv_cmd.buf, priv_cmd.total_len)) {
+		ret = -EFAULT;
+		goto out;
+	}
+	/*vowifi case, should send delba*/
+	if (tlv->type == IOCTL_TLV_TP_VOWIFI_INFO &&
+		vif->sm_state == SPRDWL_CONNECTED &&
+		(is_valid_ether_addr(vif->bssid))) {
+		struct sprdwl_intf *intf = NULL;
+		struct sprdwl_peer_entry *peer_entry = NULL;
+		struct vowifi_info *info = (struct vowifi_info *)(tlv->data);
+
+		peer_entry = sprdwl_find_peer_entry_using_addr(vif, vif->bssid);
+		intf = (struct sprdwl_intf *)vif->priv->hw_priv;
+		if (intf && peer_entry) {
+			wl_info("lut:%d, vowifi_enabled, txba_map:%lu\n",
+				peer_entry->lut_index,
+				peer_entry->ba_tx_done_map);
+
+			if ((tlv->len != 0) &&
+				(info->data == 0)) {
+				peer_entry->vowifi_enabled = 0;
+			} else {
+				u16 tid = qos_index_2_tid(SPRDWL_AC_VO);
+
+				peer_entry->vowifi_enabled = 1;
+				peer_entry->vowifi_pkt_cnt = 0;
+				if (test_bit(tid, &peer_entry->ba_tx_done_map))
+					sprdwl_tx_delba(intf, peer_entry,
+							SPRDWL_AC_VO);
+			}
+		}
+	}
+
+	ret = sprdwl_set_tlv_data(priv, vif->ctx_id, tlv, priv_cmd.total_len);
+	if (ret)
+		wl_ndev_log(L_ERR, ndev, "%s set tlv(type=%#x) error\n",
+			   __func__, tlv->type);
+out:
+	kfree(tlv);
+	return ret;
+}
+
+#define SPRDWLIOCTL		(SIOCDEVPRIVATE + 1)
+#define SPRDWLGETSSID		(SIOCDEVPRIVATE + 2)
+#define SPRDWLSETFCC		(SIOCDEVPRIVATE + 3)
+#define SPRDWLSETSUSPEND	(SIOCDEVPRIVATE + 4)
+#define SPRDWLSETCOUNTRY	(SIOCDEVPRIVATE + 5)
+#define SPRDWLSETTLV		(SIOCDEVPRIVATE + 7)
+
+static int sprdwl_ioctl(struct net_device *ndev, struct ifreq *req, int cmd)
+{
+	struct sprdwl_vif *vif = netdev_priv(ndev);
+	struct iwreq *wrq = (struct iwreq *)req;
+
+	switch (cmd) {
+	case SPRDWLIOCTL:
+	case SPRDWLSETCOUNTRY:
+		return sprdwl_priv_cmd(ndev, req);
+	case SPRDWLGETSSID:
+		if (vif->ssid_len > 0) {
+			if (copy_to_user(wrq->u.essid.pointer, vif->ssid,
+					 vif->ssid_len))
+				return -EFAULT;
+			wrq->u.essid.length = vif->ssid_len;
+		} else {
+			wl_ndev_log(L_ERR, ndev, "SSID len is zero\n");
+			return -EFAULT;
+		}
+		break;
+	case SPRDWLSETFCC:
+	case SPRDWLSETSUSPEND:
+		return sprdwl_set_power_save(ndev, req);
+	case SPRDWLSETTLV:
+		return sprdwl_set_tlv(ndev, req);
+	default:
+		wl_ndev_log(L_ERR, ndev, "Unsupported IOCTL %d\n", cmd);
+		return -ENOTSUPP;
+	}
+
+	return 0;
+}
+
+static bool mc_address_changed(struct net_device *ndev)
+{
+	struct sprdwl_vif *vif = netdev_priv(ndev);
+	struct netdev_hw_addr *ha;
+	u8 mc_count, index;
+	u8 *mac_addr;
+	bool found;
+
+	mc_count = netdev_mc_count(ndev);
+
+	if (mc_count != vif->mc_filter->mac_num)
+		return true;
+
+	mac_addr = vif->mc_filter->mac_addr;
+	netdev_for_each_mc_addr(ha, ndev) {
+		found = false;
+		for (index = 0; index < vif->mc_filter->mac_num; index++) {
+			if (!memcmp(ha->addr, mac_addr, ETH_ALEN)) {
+				found = true;
+				break;
+			}
+			mac_addr += ETH_ALEN;
+		}
+
+		if (!found)
+			return true;
+	}
+	return false;
+}
+
+#define SPRDWL_RX_MODE_MULTICAST	1
+static void sprdwl_set_multicast(struct net_device *ndev)
+{
+	struct sprdwl_vif *vif = netdev_priv(ndev);
+	struct sprdwl_priv *priv = vif->priv;
+	struct sprdwl_work *work;
+	struct netdev_hw_addr *ha;
+	u8 mc_count;
+	u8 *mac_addr;
+
+	mc_count = netdev_mc_count(ndev);
+	wl_ndev_log(L_DBG, ndev, "%s multicast address num: %d\n", __func__, mc_count);
+	if (mc_count > priv->max_mc_mac_addrs)
+		return;
+
+	vif->mc_filter->mc_change = false;
+	if ((ndev->flags & IFF_MULTICAST) && (mc_address_changed(ndev))) {
+		mac_addr = vif->mc_filter->mac_addr;
+		netdev_for_each_mc_addr(ha, ndev) {
+			wl_ndev_log(L_DBG, ndev, "%s set mac: %pM\n", __func__,
+				    ha->addr);
+			if ((ha->addr[0] != 0x33 || ha->addr[1] != 0x33) &&
+			    (ha->addr[0] != 0x01 || ha->addr[1] != 0x00 ||
+			     ha->addr[2] != 0x5e || ha->addr[3] > 0x7f)) {
+				wl_ndev_log(L_INFO, ndev, "%s invalid addr\n",
+					    __func__);
+				return;
+			}
+			ether_addr_copy(mac_addr, ha->addr);
+			mac_addr += ETH_ALEN;
+		}
+		vif->mc_filter->mac_num = mc_count;
+		vif->mc_filter->mc_change = true;
+	} else if (!(ndev->flags & IFF_MULTICAST) && vif->mc_filter->mac_num) {
+		vif->mc_filter->mac_num = 0;
+		vif->mc_filter->mc_change = true;
+	}
+
+	work = sprdwl_alloc_work(0);
+	if (!work) {
+		wl_ndev_log(L_ERR, ndev, "%s out of memory\n", __func__);
+		return;
+	}
+	work->vif = vif;
+	work->id = SPRDWL_WORK_MC_FILTER;
+	vif->mc_filter->subtype = SPRDWL_RX_MODE_MULTICAST;
+	sprdwl_queue_work(vif->priv, work);
+}
+
+static int sprdwl_set_mac(struct net_device *dev, void *addr)
+{
+	if (!dev) {
+		netdev_err(dev, "Invalid net device\n");
+		return -EINVAL;
+	}
+
+	/*return success to pass vts test*/
+	return 0;
+}
+
+static struct net_device_ops sprdwl_netdev_ops = {
+	.ndo_init = sprdwl_init,
+	.ndo_uninit = sprdwl_uninit,
+	.ndo_open = sprdwl_open,
+	.ndo_stop = sprdwl_close,
+	.ndo_start_xmit = sprdwl_start_xmit,
+	.ndo_get_stats = sprdwl_get_stats,
+	.ndo_tx_timeout = sprdwl_tx_timeout,
+	.ndo_do_ioctl = sprdwl_ioctl,
+	.ndo_set_mac_address = sprdwl_set_mac,
+};
+
+static int sprdwl_inetaddr_event(struct notifier_block *this,
+				 unsigned long event, void *ptr)
+{
+	struct net_device *ndev;
+	struct sprdwl_vif *vif;
+	struct sprdwl_peer_entry *entry;
+	struct in_ifaddr *ifa = (struct in_ifaddr *)ptr;
+
+	if (!ifa || !(ifa->ifa_dev->dev))
+		return NOTIFY_DONE;
+	if (ifa->ifa_dev->dev->netdev_ops != &sprdwl_netdev_ops)
+		return NOTIFY_DONE;
+
+	ndev = ifa->ifa_dev->dev;
+	vif = netdev_priv(ndev);
+
+	switch (vif->wdev.iftype) {
+	case NL80211_IFTYPE_STATION:
+	case NL80211_IFTYPE_P2P_CLIENT:
+		if (event == NETDEV_UP) {
+			entry = sprdwl_find_peer_entry_using_addr(vif,
+								  vif->bssid);
+			if (entry != NULL) {
+				if (entry->ctx_id == vif->ctx_id)
+					entry->ip_acquired = 1;
+				else
+					wl_err("ctx_id(%d) mismatch\n",
+					       entry->ctx_id);
+			} else {
+			    wl_err("failed to find entry\n");
+			}
+
+			sprdwl_notify_ip(vif->priv, vif->ctx_id, SPRDWL_IPV4,
+					 (u8 *)&ifa->ifa_address);
+		}
+
+		break;
+
+	default:
+		break;
+	}
+
+	return NOTIFY_DONE;
+}
+
+static struct notifier_block sprdwl_inetaddr_cb = {
+	.notifier_call = sprdwl_inetaddr_event
+};
+
+static int sprdwl_inetaddr6_event(struct notifier_block *this,
+				  unsigned long event, void *ptr)
+{
+	struct net_device *ndev;
+	struct sprdwl_vif *vif;
+	struct inet6_ifaddr *inet6_ifa = (struct inet6_ifaddr *)ptr;
+	struct sprdwl_work *work;
+	u8 *ipv6_addr;
+
+	if (!inet6_ifa || !(inet6_ifa->idev->dev))
+		return NOTIFY_DONE;
+
+	if (inet6_ifa->idev->dev->netdev_ops != &sprdwl_netdev_ops)
+		return NOTIFY_DONE;
+
+	ndev = inet6_ifa->idev->dev;
+	vif = netdev_priv(ndev);
+
+	switch (vif->wdev.iftype) {
+	case NL80211_IFTYPE_STATION:
+	case NL80211_IFTYPE_P2P_CLIENT:
+		if (event == NETDEV_UP) {
+			work = sprdwl_alloc_work(SPRDWL_IPV6_ADDR_LEN);
+			if (!work) {
+				wl_ndev_log(L_ERR, ndev, "%s out of memory\n",
+					   __func__);
+				return NOTIFY_DONE;
+			}
+			work->vif = vif;
+			work->id = SPRDWL_WORK_NOTIFY_IP;
+			ipv6_addr = (u8 *)work->data;
+			memcpy(ipv6_addr, (u8 *)&inet6_ifa->addr,
+			       SPRDWL_IPV6_ADDR_LEN);
+			sprdwl_queue_work(vif->priv, work);
+		}
+		break;
+	default:
+		break;
+	}
+	return NOTIFY_DONE;
+}
+
+static struct notifier_block sprdwl_inet6addr_cb = {
+	.notifier_call = sprdwl_inetaddr6_event
+};
+
+#ifdef CONFIG_SUNXI_ADDR_MGT
+extern int get_wifi_custom_mac_address(char *addr_str);
+#endif
+static void sprdwl_set_mac_addr(struct sprdwl_vif *vif, u8 *pending_addr,
+				u8 *addr)
+{
+	int default_mac_valid = 0;
+	enum nl80211_iftype type = vif->wdev.iftype;
+	struct sprdwl_priv *priv = vif->priv;
+	u8 addr_str[20];
+	u8 custom_mac[6] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
+	int ret;
+	(void)addr_str;
+	(void)ret;
+
+	if (!addr) {
+		return;
+	}
+
+#ifdef CONFIG_SUNXI_ADDR_MGT
+	ret = get_wifi_custom_mac_address(addr_str);
+	if (ret != -1) {
+		sscanf(addr_str, "%02hhx:%02hhx:%02hhx:%02hhx:%02hhx:%02hhx",
+				&custom_mac[0], &custom_mac[1], &custom_mac[2],
+				&custom_mac[3], &custom_mac[4], &custom_mac[5]);
+	}
+#endif
+
+	if (is_valid_ether_addr(custom_mac)) {
+		ether_addr_copy(addr, custom_mac);
+	} else if (priv && is_valid_ether_addr(priv->mac_addr)) {
+		ether_addr_copy(addr, priv->mac_addr);
+	} else if (pending_addr && is_valid_ether_addr(pending_addr)) {
+		ether_addr_copy(addr, pending_addr);
+	} else if (priv && is_valid_ether_addr(priv->default_mac)) {
+		ether_addr_copy(addr, priv->default_mac);
+		default_mac_valid = 1;
+	} else {
+		printk("no valid mac address!\n");
+	}
+
+	switch (type) {
+	case NL80211_IFTYPE_STATION:
+		ether_addr_copy(priv->default_mac, addr);
+		break;
+	case NL80211_IFTYPE_AP:
+		if (default_mac_valid) {
+			addr[0] ^= 0x10;
+			addr[0] |= 0x2;
+		} else
+			ether_addr_copy(priv->default_mac, addr);
+
+		break;
+	case NL80211_IFTYPE_P2P_CLIENT:
+	case NL80211_IFTYPE_P2P_GO:
+		addr[4] ^= 0x80;
+	case NL80211_IFTYPE_P2P_DEVICE:
+		addr[0] ^= 0x02;
+		break;
+	default:
+		break;
+	}
+}
+void init_scan_list(struct sprdwl_vif *vif)
+{
+	if (!list_empty(&vif->scan_head_ptr)) {
+		/*clean scan list if not empty first*/
+		clean_scan_list(vif);
+	}
+	INIT_LIST_HEAD(&vif->scan_head_ptr);
+}
+
+void clean_scan_list(struct sprdwl_vif *vif)
+{
+	struct scan_result *node, *pos;
+	int count = 0;
+
+	list_for_each_entry_safe(node, pos, &vif->scan_head_ptr, list) {
+		list_del(&node->list);
+		kfree(node);
+		count++;
+	}
+
+	wl_info("delete scan node num:%d\n", count);
+}
+
+#ifdef ACS_SUPPORT
+void clean_survey_info_list(struct sprdwl_vif *vif)
+{
+	struct sprdwl_bssid *bssid = NULL, *pos_bssid = NULL;
+	struct sprdwl_survey_info *info = NULL, *pos_info = NULL;
+
+	list_for_each_entry_safe(info, pos_info,
+				 &vif->survey_info_list, survey_list) {
+		list_del(&info->survey_list);
+
+		if (!list_empty(&info->bssid_list)) {
+			list_for_each_entry_safe(bssid, pos_bssid,
+						 &info->bssid_list, list) {
+				list_del(&bssid->list);
+				kfree(bssid);
+				bssid = NULL;
+			}
+		}
+
+		kfree(info);
+		info = NULL;
+	}
+}
+
+static unsigned short cal_total_beacon(struct sprdwl_vif *vif,
+				       struct sprdwl_survey_info *info)
+{
+	unsigned short total_beacon = 0;
+	short pos_chan, chan;
+
+	total_beacon += info->beacon_num;
+	chan = (short)info->chan;
+
+	if (chan > 0 && chan < 15) {
+		/* Calculate overlapping channels */
+		list_for_each_entry(info, &vif->survey_info_list, survey_list) {
+			pos_chan = (short)info->chan;
+			if (pos_chan > (chan - 4) && pos_chan < (chan + 4) &&
+			    pos_chan != chan) {
+				total_beacon += info->beacon_num;
+			}
+		}
+	}
+
+	wl_ndev_log(L_DBG, vif->ndev, "survey chan: %d, total beacon: %d!\n",
+		    chan, total_beacon);
+	return total_beacon;
+}
+
+/* Transfer beacons to survey info */
+void transfer_survey_info(struct sprdwl_vif *vif)
+{
+	struct ieee80211_channel *channel = NULL;
+	struct wiphy *wiphy = vif->wdev.wiphy;
+	struct sprdwl_survey_info *info = NULL;
+	unsigned int freq;
+	unsigned short total_beacon = 0;
+
+	list_for_each_entry(info, &vif->survey_info_list, survey_list) {
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 7, 0)
+		freq = ieee80211_channel_to_frequency(info->chan,
+				info->chan <= CH_MAX_2G_CHANNEL ?
+				NL80211_BAND_2GHZ : NL80211_BAND_5GHZ);
+#else
+		freq = ieee80211_channel_to_frequency(info->chan,
+				info->chan <= CH_MAX_2G_CHANNEL ?
+				IEEE80211_BAND_2GHZ : IEEE80211_BAND_5GHZ);
+#endif
+		channel = ieee80211_get_channel(wiphy, freq);
+		if (channel) {
+			total_beacon = cal_total_beacon(vif, info);
+			info->cca_busy_time =
+				(total_beacon < 20) ? total_beacon : 20;
+			info->noise =
+				-95 + ((total_beacon < 30) ? total_beacon : 30);
+			info->channel = channel;
+		}
+
+		freq = 0;
+		channel = NULL;
+		total_beacon = 0;
+	}
+}
+
+static bool find_bssid(struct sprdwl_survey_info *info, unsigned char *nbssid)
+{
+	struct sprdwl_bssid *bssid = NULL;
+	int ret = false;
+
+	if (!list_empty(&info->bssid_list)) {
+		list_for_each_entry(bssid, &info->bssid_list, list) {
+			if (!memcmp(bssid->bssid, nbssid, 6)) {
+				ret = true;
+				break;
+			}
+		}
+	}
+
+	return ret;
+}
+
+static struct sprdwl_survey_info *find_survey_info(struct sprdwl_vif *vif,
+						   unsigned short chan)
+{
+	struct sprdwl_survey_info *info = NULL, *result = NULL;
+
+	if (!list_empty(&vif->survey_info_list)) {
+		list_for_each_entry(info, &vif->survey_info_list, survey_list) {
+			if (chan == info->chan) {
+				result = info;
+				break;
+			}
+		}
+	}
+
+	return result;
+}
+
+void acs_scan_result(struct sprdwl_vif *vif, u16 chan,
+		     struct ieee80211_mgmt *mgmt)
+{
+	struct sprdwl_survey_info *info = NULL;
+	struct sprdwl_bssid *bssid = NULL;
+
+	info = find_survey_info(vif, chan);
+	if (info) {
+		if (!find_bssid(info, mgmt->bssid)) {
+			bssid = kmalloc(sizeof(*bssid), GFP_KERNEL);
+			if (bssid) {
+				ether_addr_copy(bssid->bssid, mgmt->bssid);
+				list_add_tail(&bssid->list, &info->bssid_list);
+				info->beacon_num++;
+			} else {
+				wl_ndev_log(L_ERR, vif->ndev, "%s no memory for bssid!\n",
+					   __func__);
+			}
+		}
+	}
+}
+#endif /* ACS_SUPPORT */
+
+static void sprdwl_init_vif(struct sprdwl_priv *priv, struct sprdwl_vif *vif,
+			    const char *name)
+{
+	WARN_ON(strlen(name) >= sizeof(vif->name));
+
+	strcpy(vif->name, name);
+	vif->priv = priv;
+	vif->sm_state = SPRDWL_DISCONNECTED;
+#ifdef ACS_SUPPORT
+	/* Init ACS */
+	INIT_LIST_HEAD(&vif->survey_info_list);
+#endif
+	INIT_LIST_HEAD(&vif->scan_head_ptr);
+}
+
+static void sprdwl_deinit_vif(struct sprdwl_vif *vif)
+{
+	sprdwl_scan_done(vif, true);
+	sprdwl_sched_scan_done(vif, true);
+	/* We have to clear all the work which
+	 * is belong to the vif we are going to remove.
+	 */
+#ifdef SYNC_DISCONNECT
+	if (vif->sm_state == SPRDWL_CONNECTING ||
+	    vif->sm_state == SPRDWL_CONNECTED  ||
+	    vif->sm_state == SPRDWL_DISCONNECTING)
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 2, 0)
+		cfg80211_disconnected(vif->ndev, 3,
+		NULL, 0, false, GFP_KERNEL);
+#else
+		cfg80211_disconnected(vif->ndev, 3,
+		NULL, 0, GFP_KERNEL);
+#endif
+#endif
+	sprdwl_cancle_work(vif->priv, vif);
+
+	if (vif->ref > 0) {
+		int cnt = 0;
+		unsigned long timeout = jiffies + msecs_to_jiffies(1000);
+
+		do {
+			usleep_range(2000, 2500);
+			cnt++;
+			if (time_after(jiffies, timeout)) {
+				wl_ndev_log(L_ERR, vif->ndev, "%s timeout cnt %d\n",
+					   __func__, cnt);
+				break;
+			}
+		} while (vif->ref > 0);
+		wl_ndev_log(L_DBG, vif->ndev, "cnt %d\n", cnt);
+	}
+}
+
+#ifndef CONFIG_P2P_INTF
+static struct sprdwl_vif *sprdwl_register_wdev(struct sprdwl_priv *priv,
+					       const char *name,
+					       enum nl80211_iftype type,
+					       u8 *addr)
+{
+	struct sprdwl_vif *vif;
+	struct wireless_dev *wdev;
+
+	vif = kzalloc(sizeof(*vif), GFP_KERNEL);
+	if (!vif)
+		return ERR_PTR(-ENOMEM);
+
+	/* initialize vif stuff */
+	sprdwl_init_vif(priv, vif, name);
+
+	/* initialize wdev stuff */
+	wdev = &vif->wdev;
+	wdev->wiphy = priv->wiphy;
+	wdev->iftype = type;
+
+	sprdwl_set_mac_addr(vif, addr, wdev->address);
+	wl_info("iface '%s'(%pM) type %d added\n", name, wdev->address, type);
+
+	return vif;
+}
+#endif
+
+static void sprdwl_unregister_wdev(struct sprdwl_vif *vif)
+{
+	wl_info("iface '%s' deleted\n", vif->name);
+
+	cfg80211_unregister_wdev(&vif->wdev);
+	/* cfg80211_unregister_wdev use list_del_rcu to delete wdev,
+	 * so we can not free vif immediately, must wait until an
+	 * RCU grace period has elapsed.
+	 */
+	synchronize_rcu();
+	sprdwl_deinit_vif(vif);
+	kfree(vif);
+}
+
+static struct sprdwl_vif *sprdwl_register_netdev(struct sprdwl_priv *priv,
+						 const char *name,
+						 enum nl80211_iftype type,
+						 u8 *addr)
+{
+	struct net_device *ndev;
+	struct wireless_dev *wdev;
+	struct sprdwl_vif *vif;
+	int ret;
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 17, 0))
+	ndev = alloc_netdev(sizeof(*vif), name, NET_NAME_UNKNOWN, ether_setup);
+#else
+	ndev = alloc_netdev(sizeof(*vif), name, ether_setup);
+#endif
+	if (!ndev) {
+		wl_err("%s failed to alloc net_device!\n", __func__);
+		return ERR_PTR(-ENOMEM);
+	}
+
+	/* initialize vif stuff */
+	vif = netdev_priv(ndev);
+	vif->ndev = ndev;
+	sprdwl_init_vif(priv, vif, name);
+
+	/* initialize wdev stuff */
+	wdev = &vif->wdev;
+	wdev->netdev = ndev;
+	wdev->wiphy = priv->wiphy;
+	wdev->iftype = type;
+
+	/* initialize ndev stuff */
+	ndev->ieee80211_ptr = wdev;
+	if (priv->fw_capa & SPRDWL_CAPA_MC_FILTER) {
+		wl_info("\tMulticast Filter supported\n");
+		vif->mc_filter =
+		    kzalloc(sizeof(struct sprdwl_mc_filter) +
+			    priv->max_mc_mac_addrs * ETH_ALEN, GFP_KERNEL);
+		if (!vif->mc_filter) {
+			ret = -ENOMEM;
+			goto err;
+		}
+
+		sprdwl_netdev_ops.ndo_set_rx_mode = sprdwl_set_multicast;
+	}
+	ndev->netdev_ops = &sprdwl_netdev_ops;
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 14, 0)
+	ndev->priv_destructor = free_netdev;
+#else
+	ndev->destructor = free_netdev;
+#endif
+	ndev->needed_headroom = priv->skb_head_len;
+	ndev->watchdog_timeo = 2 * HZ;
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 5, 0)
+	ndev->features |= NETIF_F_CSUM_MASK;
+#else
+	ndev->features |= NETIF_F_ALL_CSUM;
+#endif
+#ifdef RX_NAPI
+	ndev->features |= NETIF_F_GRO;
+#endif
+	ndev->features |= NETIF_F_SG;
+	SET_NETDEV_DEV(ndev, wiphy_dev(priv->wiphy));
+
+	sprdwl_set_mac_addr(vif, addr, ndev->dev_addr);
+
+#ifdef CONFIG_P2P_INTF
+	if (type == NL80211_IFTYPE_P2P_DEVICE)
+		wdev->iftype = NL80211_IFTYPE_STATION;
+#endif
+
+	/* register new Ethernet interface */
+	ret = register_netdevice(ndev);
+	if (ret) {
+		wl_ndev_log(L_ERR, ndev, "failed to regitster netdev(%d)!\n", ret);
+		goto err;
+	}
+
+	wl_info("iface '%s'(%pM) type %d added\n",
+		ndev->name, ndev->dev_addr, type);
+	return vif;
+err:
+	sprdwl_deinit_vif(vif);
+	free_netdev(ndev);
+	return ERR_PTR(ret);
+}
+
+static void sprdwl_unregister_netdev(struct sprdwl_vif *vif)
+{
+	wl_info("iface '%s' deleted\n", vif->ndev->name);
+
+	if (vif->priv->fw_capa & SPRDWL_CAPA_MC_FILTER)
+		kfree(vif->mc_filter);
+	sprdwl_deinit_vif(vif);
+	unregister_netdevice(vif->ndev);
+}
+
+struct wireless_dev *sprdwl_add_iface(struct sprdwl_priv *priv,
+				      const char *name,
+				      enum nl80211_iftype type, u8 *addr)
+{
+	struct sprdwl_vif *vif;
+
+#ifndef CONFIG_P2P_INTF
+	if (type == NL80211_IFTYPE_P2P_DEVICE)
+		vif = sprdwl_register_wdev(priv, name, type, addr);
+	else
+		vif = sprdwl_register_netdev(priv, name, type, addr);
+#else
+	vif = sprdwl_register_netdev(priv, name, type, addr);
+#endif
+
+	if (IS_ERR(vif)) {
+		wl_err("failed to add iface '%s'\n", name);
+		return (void *)vif;
+	}
+#ifdef SYNC_DISCONNECT
+	init_waitqueue_head(&vif->disconnect_wq);
+	atomic_set(&vif->sync_disconnect_event, 0);
+#endif
+#ifdef DFS_MASTER
+	sprdwl_init_dfs_master(vif);
+#endif
+
+	spin_lock_bh(&priv->list_lock);
+	list_add_tail(&vif->vif_node, &priv->vif_list);
+	spin_unlock_bh(&priv->list_lock);
+
+	return &vif->wdev;
+}
+
+int sprdwl_del_iface(struct sprdwl_priv *priv, struct sprdwl_vif *vif)
+{
+#ifdef DFS_MASTER
+	sprdwl_deinit_dfs_master(vif);
+#endif
+	if (!vif->ndev)
+		sprdwl_unregister_wdev(vif);
+	else
+		sprdwl_unregister_netdev(vif);
+
+	return 0;
+}
+
+static void sprdwl_del_all_ifaces(struct sprdwl_priv *priv)
+{
+	struct sprdwl_vif *vif;
+
+next_intf:
+	spin_lock_bh(&priv->list_lock);
+	list_for_each_entry_reverse(vif, &priv->vif_list, vif_node) {
+		list_del(&vif->vif_node);
+		spin_unlock_bh(&priv->list_lock);
+		rtnl_lock();
+		sprdwl_del_iface(priv, vif);
+		rtnl_unlock();
+		goto next_intf;
+	}
+
+	spin_unlock_bh(&priv->list_lock);
+
+}
+
+static void sprdwl_init_debugfs(struct sprdwl_priv *priv)
+{
+	if (!priv->wiphy->debugfsdir)
+		return;
+	priv->debugfs = debugfs_create_dir("sprdwl_wifi",
+					   priv->wiphy->debugfsdir);
+	if (IS_ERR_OR_NULL(priv->debugfs))
+		return;
+	sprdwl_intf_debugfs(priv, priv->debugfs);
+}
+
+int sprdwl_core_init(struct device *dev, struct sprdwl_priv *priv)
+{
+	u8 *efuse_mac_addr = NULL;
+	struct wiphy *wiphy = priv->wiphy;
+	struct wireless_dev *wdev;
+	int ret;
+	ret = sprdwl_sync_version(priv);
+	if (ret) {
+		wl_err("SYNC CMD ERROR!!\n");
+		goto out;
+	}
+	sprdwl_download_ini(priv);
+	sprdwl_tcp_ack_init(priv);
+	sprdwl_get_fw_info(priv);
+#ifdef RTT_SUPPORT
+	sprdwl_ftm_init(priv);
+#endif /* RTT_SUPPORT */
+	sprdwl_setup_wiphy(wiphy, priv);
+	sprdwl_vendor_init(wiphy);
+	set_wiphy_dev(wiphy, dev);
+	ret = wiphy_register(wiphy);
+	if (ret) {
+		wl_err("failed to regitster wiphy(%d)!\n", ret);
+		goto out;
+	}
+	sprdwl_init_debugfs(priv);
+
+	if (is_valid_ether_addr(priv->mac_addr))
+		efuse_mac_addr = priv->mac_addr;
+	rtnl_lock();
+	wdev = sprdwl_add_iface(priv, "wlan%d", NL80211_IFTYPE_STATION, NULL);
+	rtnl_unlock();
+	if (IS_ERR(wdev)) {
+		wiphy_unregister(wiphy);
+		ret = -ENXIO;
+		goto out;
+	}
+
+#ifdef CONFIG_P2P_INTF
+	rtnl_lock();
+	wdev = sprdwl_add_iface(priv, "p2p%d", NL80211_IFTYPE_P2P_DEVICE, NULL);
+	rtnl_unlock();
+	if (IS_ERR(wdev)) {
+		wiphy_unregister(wiphy);
+		ret = -ENXIO;
+		goto out;
+	}
+#endif
+
+#ifdef RX_NAPI
+	sprdwl_rx_napi_init(wdev->netdev,
+			    ((struct sprdwl_intf *)priv->hw_priv));
+#endif
+
+	qos_enable(1);
+	sprdwl_init_npi();
+	ret = register_inetaddr_notifier(&sprdwl_inetaddr_cb);
+	if (ret)
+		wl_err("%s failed to register inetaddr notifier(%d)!\n",
+		       __func__, ret);
+	if (priv->fw_capa & SPRDWL_CAPA_NS_OFFLOAD) {
+		wl_info("\tIPV6 NS Offload supported\n");
+		ret = register_inet6addr_notifier(&sprdwl_inet6addr_cb);
+		if (ret)
+			wl_err("%s failed to register inet6addr notifier(%d)!\n",
+			       __func__, ret);
+	}
+
+	trace_info_init();
+
+	ret = marlin_reset_register_notify(priv->if_ops->force_exit, priv->hw_priv);
+	if (ret) {
+		wl_err("%s failed to register wcn cp rest notify(%d)!\n",
+		       __func__, ret);
+	}
+
+out:
+	return ret;
+}
+
+int sprdwl_core_deinit(struct sprdwl_priv *priv)
+{
+	marlin_reset_unregister_notify();
+	unregister_inetaddr_notifier(&sprdwl_inetaddr_cb);
+	if (priv->fw_capa & SPRDWL_CAPA_NS_OFFLOAD)
+		unregister_inet6addr_notifier(&sprdwl_inet6addr_cb);
+	sprdwl_deinit_npi();
+	qos_enable(0);
+	sprdwl_del_all_ifaces(priv);
+	sprdwl_vendor_deinit(priv->wiphy);
+	wiphy_unregister(priv->wiphy);
+	sprdwl_cmd_wake_upall();
+	sprdwl_tcp_ack_deinit(priv);
+#ifdef RTT_SUPPORT
+	sprdwl_ftm_deinit(priv);
+#endif /* RTT_SUPPORT */
+	trace_info_deinit();
+
+	return 0;
+}
+
+unsigned int wfa_cap;
+module_param(wfa_cap, uint, 0000);
+MODULE_PARM_DESC(wfa_cap, "set capability for WFA test");
+
+unsigned int tcp_ack_drop_cnt = SPRDWL_TCP_ACK_DROP_CNT;
+/* Maybe you need S_IRUGO | S_IWUSR for debug */
+module_param(tcp_ack_drop_cnt, uint, 0000);
+MODULE_PARM_DESC(tcp_ack_drop_cnt, "valid values: [1, 13]");
+
+#ifdef TCP_ACK_DROP_SUPPORT
+unsigned int tcp_ack_drop_enable = 1;
+module_param(tcp_ack_drop_enable, uint, 0000);
+MODULE_PARM_DESC(tcp_ack_drop_enable, "valid values: [0, 1]");
+#else
+const unsigned int tcp_ack_drop_enable;
+#endif
+
diff --git a/drivers/net/wireless/uwe5622/unisocwifi/mm.c b/drivers/net/wireless/uwe5622/unisocwifi/mm.c
new file mode 100644
index 000000000000..2b65b97aebdd
--- /dev/null
+++ b/drivers/net/wireless/uwe5622/unisocwifi/mm.c
@@ -0,0 +1,620 @@
+/*
+ * Copyright (C) 2016 Spreadtrum Communications Inc.
+ *
+ * Authors	:
+ * star.liu <star.liu@spreadtrum.com>
+ * yifei.li <yifei.li@spreadtrum.com>
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include <linux/prefetch.h>
+#include <linux/version.h>
+#include <wcn_bus.h>
+#include "rx_msg.h"
+#include "tx_msg.h"
+#include "cmdevt.h"
+#include "work.h"
+
+#define GET_NEXT_ADDR_TRANS_VALUE(value, offset) \
+	(struct sprdwl_addr_trans_value *)((unsigned char *)value + offset)
+
+#define SKB_SHARED_INFO_OFFSET \
+	SKB_DATA_ALIGN(SPRDWL_MAX_DATA_RXLEN + NET_SKB_PAD)
+
+void check_mh_buffer(struct device *dev, void *buffer, dma_addr_t pa,
+		     size_t size, enum dma_data_direction direction)
+{
+#define MAX_RETRY_NUM 8
+	int retry = 0;
+
+	if (direction == DMA_FROM_DEVICE) {
+		struct rx_msdu_desc *desc = buffer + sizeof(struct rx_mh_desc);
+
+		/* Check whether this buffer is ok to use */
+		while ((desc->data_write_done != 1) ||
+		       (retry < MAX_RETRY_NUM)) {
+			wl_err("%s: hw still writing: 0x%lx, 0x%lx\n",
+			       __func__, (unsigned long)buffer,
+			       (unsigned long)pa);
+			/* FIXME: Should we delay here? */
+			dma_sync_single_for_device(dev, pa, size, direction);
+			retry++;
+		}
+	} else {
+		while (((((struct pcie_addr_buffer *)buffer)->
+			buffer_ctrl.buffer_inuse) != 0) ||
+			(retry < MAX_RETRY_NUM)) {
+			wl_err("%s: hw still writing: 0x%lx, 0x%lx\n",
+			       __func__, (unsigned long)buffer,
+			       (unsigned long)pa);
+			dma_sync_single_for_device(dev, pa, size, direction);
+			retry++;
+		}
+	}
+
+	if (retry >= MAX_RETRY_NUM) {
+		/* TODO: How to deal with this situation? */
+		dma_sync_single_for_device(dev, pa, size, direction);
+		wl_err("%s: hw still writing: 0x%lx, 0x%lx\n",
+		       __func__, (unsigned long)buffer, (unsigned long)pa);
+	}
+}
+
+unsigned long mm_virt_to_phys(struct device *dev, void *buffer, size_t size,
+			      enum dma_data_direction direction)
+{
+	dma_addr_t pa = 0;
+	unsigned long pcie_addr = 0;
+
+	pa = dma_map_single(dev, buffer, size, direction);
+	if (likely(!dma_mapping_error(dev, pa)))
+		pcie_addr = pa | SPRDWL_MH_ADDRESS_BIT;
+
+	return pcie_addr;
+}
+
+void *mm_phys_to_virt(struct device *dev, unsigned long pcie_addr, size_t size,
+		      enum dma_data_direction direction, bool is_mh)
+{
+	dma_addr_t pa = 0;
+	void *buffer = NULL;
+
+	pa = pcie_addr & (~(SPRDWL_MH_ADDRESS_BIT) & SPRDWL_PHYS_MASK);
+	buffer = phys_to_virt(pa);
+
+	dma_sync_single_for_device(dev, pa, size, direction);
+
+	if (is_mh)
+		check_mh_buffer(dev, buffer, pa, size, direction);
+
+	dma_unmap_single(dev, pa, size, direction);
+
+	return buffer;
+}
+
+static inline struct sk_buff *mm_build_skb(void *data, int len, int buffer_type)
+{
+	return build_skb(data, (buffer_type ? len : 0));
+}
+
+static struct sk_buff
+*mm_data2skb_process(struct sprdwl_mm *mm_entry, void *data, int len)
+{
+	struct sk_buff *skb = NULL;
+
+	skb = dev_alloc_skb(len);
+	if (likely(skb))
+		memcpy(skb->data, data, len);
+
+	return skb;
+}
+
+static inline void mm_flush_buffer(struct sprdwl_mm *mm_entry)
+{
+	/* TODO: Should we stop something here? */
+
+	/* Free all skbs */
+	skb_queue_purge(&mm_entry->buffer_list);
+}
+
+static inline void mm_alloc_addr_buf(struct sprdwl_mm *mm_entry)
+{
+	struct sprdwl_addr_trans_value *value = NULL;
+	struct sprdwl_addr_hdr *hdr = NULL;
+	void *p = NULL;
+
+	p = kmalloc((mm_entry->hif_offset + SPRDWL_ADDR_BUF_LEN), GFP_KERNEL);
+	if (likely(p)) {
+		hdr = (struct sprdwl_addr_hdr *)(p + mm_entry->hif_offset);
+		value = (struct sprdwl_addr_trans_value *)hdr->paydata;
+
+		/* Tell CP that this CMD is used to add MH buffer */
+		hdr->common.reserv = 1;
+		/* NOTE: CP do not care ctx_id & rsp */
+		hdr->common.ctx_id = 0;
+		hdr->common.rsp = 0;
+		hdr->common.type = SPRDWL_TYPE_DATA_PCIE_ADDR;
+
+		value->type = 0;
+		value->num = 0;
+	}
+
+	mm_entry->hdr = (void *)hdr;
+	mm_entry->addr_trans = (void *)value;
+}
+
+static inline int mm_do_addr_buf(struct sprdwl_mm *mm_entry)
+{
+	struct sprdwl_rx_if *rx_if =
+			container_of(mm_entry, struct sprdwl_rx_if, mm_entry);
+	struct sprdwl_addr_trans_value *value =
+		(struct sprdwl_addr_trans_value *)mm_entry->addr_trans;
+	int ret = 0;
+	int addr_trans_len = 0;
+
+	/* NOTE: addr_buf should be allocating after being sent,
+	 *       JUST avoid addr_buf allocating fail after being sent here
+	 */
+	if (unlikely(!value)) {
+		wl_debug("%s: addr buf is NULL, re-alloc here\n", __func__);
+		mm_alloc_addr_buf(mm_entry);
+		if (unlikely(!mm_entry->addr_trans)) {
+			wl_err("%s: alloc addr buf fail!\n", __func__);
+			ret = -ENOMEM;
+		}
+	} else if (value->num >= SPRDWL_MAX_ADD_MH_BUF_ONCE) {
+		addr_trans_len = sizeof(struct sprdwl_addr_hdr) +
+				sizeof(struct sprdwl_addr_trans_value) +
+				(value->num*SPRDWL_PHYS_LEN);
+
+		/* FIXME: temporary solution, would TX supply API for us? */
+		/* TODO: How to do with tx fail? */
+		if ((if_tx_addr_trans(rx_if->intf, mm_entry->hdr,
+				      addr_trans_len) >= 0)) {
+			mm_alloc_addr_buf(mm_entry);
+			if (unlikely(!mm_entry->addr_trans)) {
+				wl_err("%s: alloc addr buf fail!\n", __func__);
+				ret = -ENOMEM;
+			}
+		} else {
+			wl_err("%s: send addr buf fail!\n", __func__);
+			ret = -EIO;
+		}
+	}
+
+	return ret;
+}
+
+static int mm_w_addr_buf(struct sprdwl_mm *mm_entry, unsigned long pcie_addr)
+{
+	int ret = 0;
+	struct sprdwl_addr_trans_value *value = NULL;
+
+	ret = mm_do_addr_buf(mm_entry);
+	if (!ret) {
+		value = (struct sprdwl_addr_trans_value *)mm_entry->addr_trans;
+
+		/* NOTE: MH is little endian */
+		memcpy((void *)value->address[value->num],
+		       &pcie_addr, SPRDWL_PHYS_LEN);
+		value->num++;
+		/* do not care the result here */
+		mm_do_addr_buf(mm_entry);
+	}
+
+	return ret;
+}
+
+static int mm_single_buffer_alloc(struct sprdwl_mm *mm_entry)
+{
+	struct sprdwl_rx_if *rx_if =
+			container_of(mm_entry, struct sprdwl_rx_if, mm_entry);
+	struct sk_buff *skb = NULL;
+	unsigned long pcie_addr = 0;
+	int ret = -ENOMEM;
+
+	skb = dev_alloc_skb(SPRDWL_MAX_DATA_RXLEN);
+	if (skb) {
+		/* hook skb address after skb end
+		 * first 64 bits of skb_shared_info are
+		 * nr_frags, tx_flags, gso_size, gso_segs, gso_type
+		 * It could be re-used and MUST clean after using
+		 */
+		memcpy((void *)skb_end_pointer(skb), &skb, sizeof(skb));
+		/* transfer virt to phys */
+		pcie_addr = mm_virt_to_phys(rx_if->intf->dev,
+					    skb->data, SPRDWL_MAX_DATA_RXLEN,
+					    DMA_FROM_DEVICE);
+
+		if (unlikely(!pcie_addr)) {
+			ret = mm_w_addr_buf(mm_entry, pcie_addr);
+			if (ret) {
+				wl_err("%s: write addr buf fail: %d\n",
+				       __func__, ret);
+				dev_kfree_skb(skb);
+			} else {
+				/* queue skb */
+				skb_queue_tail(&mm_entry->buffer_list, skb);
+			}
+		}
+	} else {
+		wl_err("%s: alloc skb fail\n", __func__);
+	}
+
+	return ret;
+}
+
+int mm_buffer_alloc(struct sprdwl_mm *mm_entry, int need_num)
+{
+	int num = 0, ret = 0;
+
+	for (num = 0; num < need_num; num++) {
+		ret = mm_single_buffer_alloc(mm_entry);
+		if (ret) {
+			wl_err("%s: alloc num: %d, need num: %d, ret: %d\n",
+			       __func__, num, need_num, ret);
+			break;
+		}
+	}
+
+	return ret;
+}
+
+static struct sk_buff *mm_single_buffer_unlink(struct sprdwl_mm *mm_entry,
+					       unsigned long pcie_addr)
+{
+	struct sprdwl_rx_if *rx_if =
+			container_of(mm_entry, struct sprdwl_rx_if, mm_entry);
+	struct sk_buff *skb = NULL;
+	void *buffer = NULL;
+
+	buffer = mm_phys_to_virt(rx_if->intf->dev, pcie_addr,
+				 SPRDWL_MAX_DATA_RXLEN, DMA_FROM_DEVICE, true);
+
+	memcpy(&skb, (buffer + SKB_SHARED_INFO_OFFSET), sizeof(skb));
+	skb_unlink(skb, &mm_entry->buffer_list);
+	memset((void *)skb_end_pointer(skb), 0x0, sizeof(skb));
+
+	return skb;
+}
+
+static int mm_buffer_relink(struct sprdwl_mm *mm_entry,
+			    struct sprdwl_addr_trans_value *value,
+			    int total_len)
+{
+	int num = 0;
+	unsigned long pcie_addr = 0;
+	struct sk_buff *skb = NULL;
+	int len = 0, ret = 0;
+
+	for (num = 0; num < value->num; num++) {
+		len += SPRDWL_PHYS_LEN;
+		if (unlikely(len > total_len)) {
+			wl_err("%s: total_len:%d < len:%d\n",
+			       __func__, total_len, len);
+			wl_err("%s: total %d pkts, relink %d pkts\n",
+			       __func__, value->num, num);
+			len = -EINVAL;
+			break;
+		}
+
+		memcpy(&pcie_addr, value->address[num], SPRDWL_PHYS_LEN);
+		pcie_addr &= SPRDWL_PHYS_MASK;
+
+		ret = mm_w_addr_buf(mm_entry, pcie_addr);
+		if (ret) {
+			wl_err("%s: write addr buf fail: %d\n", __func__, ret);
+			skb = mm_single_buffer_unlink(mm_entry, pcie_addr);
+			if (likely(skb))
+				dev_kfree_skb(skb);
+			else
+				wl_err("%s: unlink skb fail!\n", __func__);
+		}
+
+		skb = NULL;
+		pcie_addr = 0;
+	}
+
+	return len;
+}
+
+static int mm_buffer_unlink(struct sprdwl_mm *mm_entry,
+			    struct sprdwl_addr_trans_value *value,
+			    int total_len)
+{
+	int num = 0;
+	unsigned long pcie_addr = 0;
+	struct sk_buff *skb = NULL;
+	struct rx_msdu_desc *msdu_desc = NULL;
+	int len = 0;
+	unsigned short csum = 0;
+	struct sprdwl_rx_if *rx_if =
+			container_of(mm_entry, struct sprdwl_rx_if, mm_entry);
+
+	for (num = 0; num < value->num; num++) {
+		len += SPRDWL_PHYS_LEN;
+		if (unlikely(len > total_len)) {
+			wl_err("%s: total_len:%d < len:%d\n",
+			       __func__, total_len, len);
+			wl_err("%s: total %d pkts, unlink %d pkts\n",
+			       __func__, value->num, num);
+			len = -EINVAL;
+			break;
+		}
+
+		memcpy(&pcie_addr, value->address[num], SPRDWL_PHYS_LEN);
+		pcie_addr &= SPRDWL_PHYS_MASK;
+
+		skb = mm_single_buffer_unlink(mm_entry, pcie_addr);
+		if (likely(skb)) {
+			csum = get_pcie_data_csum((void *)rx_if->intf,
+						  skb->data);
+			skb_reserve(skb, sizeof(struct rx_mh_desc));
+			/* TODO: Would CP do this? */
+			msdu_desc = (struct rx_msdu_desc *)skb->data;
+			msdu_desc->msdu_offset -=
+					sizeof(struct rx_mh_desc);
+			/* TODO: Check whether prefetch work */
+			prefetch(skb->data);
+
+			if (likely(fill_skb_csum(skb, csum) >= 0))
+				sprdwl_rx_process(rx_if, skb);
+			else /* checksum error, free skb */
+				dev_kfree_skb(skb);
+
+			mm_single_buffer_alloc(mm_entry);
+		} else {
+			wl_err("%s: unlink skb fail!\n", __func__);
+		}
+
+		skb = NULL;
+		pcie_addr = 0;
+	}
+
+	return len;
+}
+
+inline bool is_compound_data(struct sprdwl_mm *mm_entry, void *data)
+{
+	struct rx_msdu_desc *msdu_desc =
+		(struct rx_msdu_desc *)(data + mm_entry->hif_offset);
+
+	wl_debug("%s: short_pkt_num: %d\n", __func__, msdu_desc->short_pkt_num);
+
+	return (msdu_desc->short_pkt_num > 1);
+}
+
+static void
+mm_compound_data_process(struct sprdwl_mm *mm_entry, void *compound_data,
+			 int total_len, int buffer_type)
+{
+#define ALIGN_8BYTE(a) (((a) + 7) & ~7)
+	void *pos_data = NULL;
+	int num = 0, msdu_len = 0, len = 0;
+	struct sk_buff *skb = NULL;
+	struct sprdwl_rx_if *rx_if =
+			container_of(mm_entry, struct sprdwl_rx_if, mm_entry);
+
+	wl_debug("%s: num: %d, total_len: %d\n", __func__, num, total_len);
+
+	pos_data = compound_data + mm_entry->hif_offset;
+	total_len -= mm_entry->hif_offset;
+	num = ((struct rx_msdu_desc *)pos_data)->short_pkt_num;
+
+	while (num--) {
+		msdu_len = msdu_total_len((struct rx_msdu_desc *)pos_data);
+		len += ALIGN_8BYTE(msdu_len);
+		if (unlikely(len > total_len)) {
+			wl_err("%s: total_len:%d < len:%d, leave %d pkts\n",
+			       __func__, total_len, len, (num + 1));
+			break;
+		}
+
+		wl_debug("%s: msdu_len: %d, len: %d\n",
+			 __func__, msdu_len, len);
+
+		skb = mm_data2skb_process(mm_entry, pos_data, msdu_len);
+		if (unlikely(!skb)) {
+			wl_err("%s: alloc skb fail, leave %d pkts\n",
+			       __func__, (num + 1));
+			break;
+		}
+
+		sprdwl_rx_process(rx_if, skb);
+
+		pos_data = (unsigned char *)pos_data +
+			ALIGN_8BYTE(msdu_len + sizeof(struct rx_mh_desc));
+		skb = NULL;
+	}
+
+	sprdwl_free_data(compound_data, buffer_type);
+}
+
+static void mm_normal_data_process(struct sprdwl_mm *mm_entry,
+				   void *data, int len, int buffer_type)
+{
+	int skb_len = 0;
+	unsigned short csum = 0;
+	bool free_data = false;
+	struct sk_buff *skb = NULL;
+	struct rx_msdu_desc *msdu_desc =
+		(struct rx_msdu_desc *)(data + mm_entry->hif_offset);
+	struct sprdwl_rx_if *rx_if =
+			container_of(mm_entry, struct sprdwl_rx_if, mm_entry);
+
+	if (unlikely(len < sizeof(struct rx_msdu_desc))) {
+		wl_err("%s: data len is %d, too short\n",
+		       __func__, len);
+		free_data = true;
+	} else {
+		csum = get_sdio_data_csum((void *)rx_if->intf, data);
+		skb_len = SKB_DATA_ALIGN(sizeof(struct skb_shared_info)) +
+			  SKB_DATA_ALIGN(msdu_total_len(msdu_desc) +
+					 mm_entry->hif_offset);
+
+		/*0: sdma, 1: adma*/
+		if (sprdwcn_bus_get_rx_mode() == 1) {
+			if (likely(skb_len <= len)) {
+				/* Use len instead of skb_len
+				 * because we could reserve more tailroom
+				 */
+
+				skb = mm_build_skb(data, skb_len, buffer_type);
+			} else {
+				/* Should not happen */
+				wl_err("%s: data len is %d, skb need %d\n",
+						__func__, len, skb_len);
+				skb = mm_data2skb_process(mm_entry, data,
+						SKB_WITH_OVERHEAD(skb_len));
+				free_data = true;
+			}
+		} else {
+			skb = mm_data2skb_process(mm_entry, data, SKB_WITH_OVERHEAD(skb_len));
+			free_data = true;
+		}
+
+		if (unlikely(!skb)) {
+			wl_err("%s: alloc skb fail\n", __func__);
+			free_data = true;
+		} else {
+			skb_reserve(skb, mm_entry->hif_offset);
+
+			if (likely(fill_skb_csum(skb, csum) >= 0))
+				sprdwl_rx_process(rx_if, skb);
+			else /* checksum error, free skb */
+				dev_kfree_skb(skb);
+		}
+	}
+
+	if (free_data)
+		sprdwl_free_data(data, buffer_type);
+}
+
+
+/* NOTE: This function JUST work when mm_w_addr_buf() work abnormal */
+static inline void mm_refill_buffer(struct sprdwl_mm *mm_entry)
+{
+	int num = SPRDWL_MAX_MH_BUF - skb_queue_len(&mm_entry->buffer_list);
+
+	wl_debug("%s: need to refill %d buffer\n", __func__, num);
+
+	if (num > 0) {
+		mm_buffer_alloc(mm_entry, num);
+	} else if (num < 0) {
+		/* Should never happen */
+		wl_err("%s: %d > mx addr buf!\n", __func__, num);
+	}
+}
+
+static int mm_single_event_process(struct sprdwl_mm *mm_entry,
+				   struct sprdwl_addr_trans_value *value,
+				   int len)
+{
+	int ret = 0;
+
+	switch (value->type) {
+	case SPRDWL_PROCESS_BUFFER:
+		ret = mm_buffer_unlink(mm_entry, value, len);
+		break;
+	case SPRDWL_FREE_BUFFER:
+		ret = mm_buffer_relink(mm_entry, value, len);
+		break;
+	case SPRDWL_REQUEST_BUFFER:
+		/* NOTE: Not need to do anything here */
+		break;
+	case SPRDWL_FLUSH_BUFFER:
+		mm_flush_buffer(mm_entry);
+		break;
+	default:
+		wl_err("%s: err type: %d\n", __func__, value->type);
+		ret = -EINVAL;
+	}
+
+	if (value->type < SPRDWL_FLUSH_BUFFER)
+		mm_refill_buffer(mm_entry);
+
+	return (ret < 0) ? ret : (ret + sizeof(*value));
+}
+
+/* PCIE DATA EVENT */
+void mm_mh_data_event_process(struct sprdwl_mm *mm_entry, void *data,
+			      int len, int buffer_type)
+{
+	int offset = 0;
+	struct sprdwl_addr_hdr *hdr =
+		(struct sprdwl_addr_hdr *)(data + mm_entry->hif_offset);
+	struct sprdwl_addr_trans *addr_trans =
+		(struct sprdwl_addr_trans *)hdr->paydata;
+	struct sprdwl_addr_trans_value *value = addr_trans->value;
+	unsigned char tlv_num = addr_trans->tlv_num;
+	int remain_len = len - sizeof(*addr_trans);
+
+	while (tlv_num--) {
+		remain_len = remain_len - offset - sizeof(*value);
+		if (remain_len < 0) {
+			wl_err("%s: remain tlv num: %d\n", __func__, tlv_num);
+			break;
+		}
+
+		value = GET_NEXT_ADDR_TRANS_VALUE(value, offset);
+		offset = mm_single_event_process(mm_entry, value, remain_len);
+		if (offset < 0) {
+			wl_err("%s: do mh event fail: %d!\n",
+			       __func__, offset);
+			break;
+		}
+	}
+
+	sprdwl_free_data(data, buffer_type);
+}
+
+/* NORMAL DATA */
+void mm_mh_data_process(struct sprdwl_mm *mm_entry, void *data,
+			int len, int buffer_type)
+{
+	if (is_compound_data(mm_entry, data))
+		mm_compound_data_process(mm_entry, data, len, buffer_type);
+	else
+		mm_normal_data_process(mm_entry, data, len, buffer_type);
+}
+
+int sprdwl_mm_init(struct sprdwl_mm *mm_entry, void *intf)
+{
+	int ret = 0;
+
+	mm_entry->hif_offset = ((struct sprdwl_intf *)intf)->hif_offset;
+
+	if (((struct sprdwl_intf *)intf)->priv->hw_type ==
+	    SPRDWL_HW_PCIE) {
+		skb_queue_head_init(&mm_entry->buffer_list);
+
+		ret = mm_buffer_alloc(mm_entry, SPRDWL_MAX_MH_BUF);
+		if (ret)
+			wl_err("%s: alloc rx if fail\n", __func__);
+	}
+
+	return ret;
+}
+
+int sprdwl_mm_deinit(struct sprdwl_mm *mm_entry, void *intf)
+{
+	if (((struct sprdwl_intf *)intf)->priv->hw_type ==
+	    SPRDWL_HW_PCIE) {
+		/* NOTE: pclint says kfree(NULL) is safe */
+		kfree(mm_entry->hdr);
+		mm_entry->hdr = NULL;
+		mm_entry->addr_trans = NULL;
+		mm_flush_buffer(mm_entry);
+	}
+
+	mm_entry->hif_offset = 0;
+	return 0;
+}
diff --git a/drivers/net/wireless/uwe5622/unisocwifi/mm.h b/drivers/net/wireless/uwe5622/unisocwifi/mm.h
new file mode 100644
index 000000000000..ac74ba701405
--- /dev/null
+++ b/drivers/net/wireless/uwe5622/unisocwifi/mm.h
@@ -0,0 +1,40 @@
+#ifndef __SPRDWL_MM_H__
+#define __SPRDWL_MM_H__
+
+#include <linux/skbuff.h>
+#include <linux/dma-direction.h>
+
+#define SPRDWL_PHYS_LEN 5
+#define SPRDWL_PHYS_MASK (((uint64_t)1 << 40) - 1)
+#define SPRDWL_MH_ADDRESS_BIT ((uint64_t)1 << 39)
+
+#define SPRDWL_MAX_MH_BUF 500
+#define SPRDWL_ADD_MH_BUF_THRESHOLD 300
+#define SPRDWL_MAX_ADD_MH_BUF_ONCE 200
+#define SPRDWL_ADDR_BUF_LEN (sizeof(struct sprdwl_addr_hdr) +\
+			     sizeof(struct sprdwl_addr_trans_value) +\
+			     (SPRDWL_MAX_ADD_MH_BUF_ONCE * SPRDWL_PHYS_LEN))
+
+struct sprdwl_mm {
+	int hif_offset;
+	struct sk_buff_head buffer_list;
+	/* hdr point to hdr of addr buf */
+	void *hdr;
+	/* addr_trans point to addr trans of addr buf */
+	void *addr_trans;
+};
+
+int sprdwl_mm_init(struct sprdwl_mm *mm_entry, void *intf);
+int sprdwl_mm_deinit(struct sprdwl_mm *mm_entry, void *intf);
+void mm_mh_data_process(struct sprdwl_mm *mm_entry, void *data,
+			int len, int buffer_type);
+void mm_mh_data_event_process(struct sprdwl_mm *mm_entry, void *data,
+			      int len, int buffer_type);
+unsigned long mm_virt_to_phys(struct device *dev, void *buffer, size_t size,
+			      enum dma_data_direction direction);
+void *mm_phys_to_virt(struct device *dev, unsigned long pcie_addr, size_t size,
+		      enum dma_data_direction direction, bool is_mh);
+int sprdwl_tx_addr_buf_unmap(void *tx_msg,
+			     int complete, int tx_count);
+int mm_buffer_alloc(struct sprdwl_mm *mm_entry, int need_num);
+#endif /* __SPRDWL_MM_H__ */
diff --git a/drivers/net/wireless/uwe5622/unisocwifi/msg.c b/drivers/net/wireless/uwe5622/unisocwifi/msg.c
new file mode 100644
index 000000000000..90e7ce910d78
--- /dev/null
+++ b/drivers/net/wireless/uwe5622/unisocwifi/msg.c
@@ -0,0 +1,183 @@
+/*
+ * Copyright (C) 2015 Spreadtrum Communications Inc.
+ *
+ * Authors	:
+ * Keguang Zhang <keguang.zhang@spreadtrum.com>
+ * Jingxiang Li <Jingxiang.li@spreadtrum.com>
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include "sprdwl.h"
+#include "msg.h"
+
+/* static struct sprdwl_msg_list msg_list */
+
+int sprdwl_msg_init(int num, struct sprdwl_msg_list *list)
+{
+	int i;
+	struct sprdwl_msg_buf *msg_buf;
+	struct sprdwl_msg_buf *pos;
+
+	if (!list)
+		return -EPERM;
+	INIT_LIST_HEAD(&list->freelist);
+	INIT_LIST_HEAD(&list->busylist);
+	INIT_LIST_HEAD(&list->cmd_to_free);
+	list->maxnum = num;
+	spin_lock_init(&list->freelock);
+	spin_lock_init(&list->busylock);
+	spin_lock_init(&list->complock);
+	atomic_set(&list->ref, 0);
+	atomic_set(&list->flow, 0);
+	for (i = 0; i < num; i++) {
+		msg_buf = kzalloc(sizeof(*msg_buf), GFP_KERNEL);
+		if (msg_buf) {
+			INIT_LIST_HEAD(&msg_buf->list);
+			list_add_tail(&msg_buf->list, &list->freelist);
+		} else {
+			wl_err("%s failed to alloc msg_buf!\n", __func__);
+			goto err_alloc_buf;
+		}
+	}
+
+	return 0;
+
+err_alloc_buf:
+	list_for_each_entry_safe(msg_buf, pos, &list->freelist, list) {
+		list_del(&msg_buf->list);
+		kfree(msg_buf);
+	}
+	return -ENOMEM;
+}
+
+#define SPRDWL_MSG_EXIT_VAL 0x8000
+void sprdwl_msg_deinit(struct sprdwl_msg_list *list)
+{
+	struct sprdwl_msg_buf *msg_buf;
+	struct sprdwl_msg_buf *pos;
+	struct timespec64 txmsgftime1, txmsgftime2;
+
+	atomic_add(SPRDWL_MSG_EXIT_VAL, &list->ref);
+	if (atomic_read(&list->ref) > SPRDWL_MSG_EXIT_VAL)
+		wl_err("%s ref not ok! wait for pop!\n", __func__);
+
+	ktime_get_real_ts64(&txmsgftime1);
+	while (atomic_read(&list->ref) > SPRDWL_MSG_EXIT_VAL) {
+		ktime_get_real_ts64(&txmsgftime2);
+		if (((unsigned long)(timespec64_to_ns(&txmsgftime2) -
+			timespec64_to_ns(&txmsgftime1))/1000000) > 3000)
+			break;
+		usleep_range(2000, 2500);
+	}
+
+	wl_info("%s list->ref ok!\n", __func__);
+
+	if (!list_empty(&list->busylist))
+		WARN_ON(1);
+
+	list_for_each_entry_safe(msg_buf, pos, &list->freelist, list) {
+		list_del(&msg_buf->list);
+		kfree(msg_buf);
+	}
+}
+
+struct sprdwl_msg_buf *sprdwl_alloc_msg_buf(struct sprdwl_msg_list *list)
+{
+	struct sprdwl_msg_buf *msg_buf = NULL;
+
+	if (atomic_inc_return(&list->ref) >= SPRDWL_MSG_EXIT_VAL) {
+		atomic_dec(&list->ref);
+		return NULL;
+	}
+	spin_lock_bh(&list->freelock);
+	if (!list_empty(&list->freelist)) {
+		msg_buf = list_first_entry(&list->freelist,
+					   struct sprdwl_msg_buf, list);
+		list_del(&msg_buf->list);
+	}
+	spin_unlock_bh(&list->freelock);
+
+	if (!msg_buf)
+		atomic_dec(&list->ref);
+	return msg_buf;
+}
+
+void sprdwl_free_msg_buf(struct sprdwl_msg_buf *msg_buf,
+			 struct sprdwl_msg_list *list)
+{
+	spin_lock_bh(&list->freelock);
+	list_add_tail(&msg_buf->list, &list->freelist);
+	atomic_dec(&list->ref);
+	spin_unlock_bh(&list->freelock);
+}
+
+void sprdwl_queue_msg_buf(struct sprdwl_msg_buf *msg_buf,
+			  struct sprdwl_msg_list *list)
+{
+	spin_lock_bh(&list->busylock);
+	list_add_tail(&msg_buf->list, &list->busylist);
+	spin_unlock_bh(&list->busylock);
+}
+
+struct sprdwl_msg_buf *sprdwl_peek_msg_buf(struct sprdwl_msg_list *list)
+{
+	struct sprdwl_msg_buf *msg_buf = NULL;
+
+	spin_lock_bh(&list->busylock);
+	if (!list_empty(&list->busylist))
+		msg_buf = list_first_entry(&list->busylist,
+				   struct sprdwl_msg_buf, list);
+	spin_unlock_bh(&list->busylock);
+
+	return msg_buf;
+}
+
+void sprdwl_dequeue_msg_buf(struct sprdwl_msg_buf *msg_buf,
+			    struct sprdwl_msg_list *list)
+{
+	spin_lock_bh(&list->busylock);
+	list_del(&msg_buf->list);
+	spin_unlock_bh(&list->busylock);
+	sprdwl_free_msg_buf(msg_buf, list);
+}
+
+struct sprdwl_msg_buf *sprdwl_get_msgbuf_by_data(void *data,
+						 struct sprdwl_msg_list *list)
+{
+	int find = 0;
+	struct sprdwl_msg_buf *pos;
+	struct sprdwl_msg_buf *msg_buf;
+
+	spin_lock_bh(&list->busylock);
+	list_for_each_entry_safe(msg_buf, pos,  &list->busylist, list) {
+		if (data == msg_buf->tran_data) {
+			list_del(&msg_buf->list);
+			find = 1;
+			break;
+		}
+	}
+	spin_unlock_bh(&list->busylock);
+
+	return find ? msg_buf : NULL;
+}
+
+struct sprdwl_msg_buf *sprdwl_get_tail_msg_buf(struct sprdwl_msg_list *list)
+{
+	struct sprdwl_msg_buf *msg_buf = NULL;
+
+	spin_lock_bh(&list->busylock);
+	if (!list_empty(&list->busylist))
+		msg_buf = list_last_entry(&list->busylist,
+					struct sprdwl_msg_buf, list);
+	spin_unlock_bh(&list->busylock);
+	return msg_buf;
+}
+
diff --git a/drivers/net/wireless/uwe5622/unisocwifi/msg.h b/drivers/net/wireless/uwe5622/unisocwifi/msg.h
new file mode 100644
index 000000000000..dd57521ae708
--- /dev/null
+++ b/drivers/net/wireless/uwe5622/unisocwifi/msg.h
@@ -0,0 +1,219 @@
+/*
+ * Copyright (C) 2015 Spreadtrum Communications Inc.
+ *
+ * Authors	:
+ * Keguang Zhang <keguang.zhang@spreadtrum.com>
+ * Jingxiang Li <Jingxiang.li@spreadtrum.com>
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#ifndef __SPRDWL_MSG_H__
+#define __SPRDWL_MSG_H__
+
+#include <linux/types.h>
+#include <linux/list.h>
+#include <linux/spinlock.h>
+#include <asm/byteorder.h>
+#include <linux/version.h>
+
+/* 0 for cmd, 1 for event, 2 for data, 3 for mh data */
+enum sprdwl_head_type {
+	SPRDWL_TYPE_CMD,
+	SPRDWL_TYPE_EVENT,
+	SPRDWL_TYPE_DATA,
+	SPRDWL_TYPE_DATA_SPECIAL,
+	SPRDWL_TYPE_DATA_PCIE_ADDR,
+	SPRDWL_TYPE_PKT_LOG,
+};
+
+enum sprdwl_head_rsp {
+	/* cmd no rsp */
+	SPRDWL_HEAD_NORSP,
+	/* cmd need rsp */
+	SPRDWL_HEAD_RSP,
+};
+
+/* bit[7][6][5] ctx_id: context id
+ * bit[4] rsp: sprdwl_head_rsp
+ * bit[3] reserv
+ * bit[2][1][0] type: sprdwl_head_type
+ */
+struct sprdwl_common_hdr {
+#if defined(__LITTLE_ENDIAN_BITFIELD)
+	__u8 type:3;
+	__u8 reserv:1;
+	__u8 rsp:1;
+	__u8 ctx_id:3;
+#elif defined(__BIG_ENDIAN_BITFIELD)
+	__u8 ctx_id:3;
+	__u8 rsp:1;
+	__u8 reserv:1;
+	__u8 type:3;
+#else
+#error  "check <asm/byteorder.h> defines"
+#endif
+};
+
+#define SPRDWL_CMD_STATUS_OK			0
+#define SPRDWL_CMD_STATUS_ARG_ERROR		-1
+#define SPRDWL_CMD_STATUS_GET_RESULT_ERROR	-2
+#define SPRDWL_CMD_STATUS_EXEC_ERROR		-3
+#define SPRDWL_CMD_STATUS_MALLOC_ERROR		-4
+#define SPRDWL_CMD_STATUS_WIFIMODE_ERROR	-5
+#define SPRDWL_CMD_STATUS_ERROR			-6
+#define SPRDWL_CMD_STATUS_CONNOT_EXEC_ERROR	-7
+#define SPRDWL_CMD_STATUS_NOT_SUPPORT_ERROR	-8
+#define SPRDWL_CMD_STATUS_CRC_ERROR			-9
+#define SPRDWL_CMD_STATUS_INI_INDEX_ERROR   -10
+#define SPRDWL_CMD_STATUS_LENGTH_ERROR     -11
+#define SPRDWL_CMD_STATUS_OTHER_ERROR		-127
+
+#define SPRDWL_HEAD_GET_TYPE(common) \
+	(((struct sprdwl_common_hdr *)(common))->type)
+
+#define SPRDWL_HEAD_GET_CTX_ID(common) \
+	(((struct sprdwl_common_hdr *)(common))->ctx_id)
+
+#define SPRD_HEAD_GET_RESUME_BIT(common) \
+	(((struct sprdwl_common_hdr *)(common))->reserv)
+
+struct sprdwl_cmd_hdr {
+	struct sprdwl_common_hdr common;
+	u8 cmd_id;
+	/* the payload len include the size of this struct */
+	__le16 plen;
+	__le32 mstime;
+	s8 status;
+	u8 rsp_cnt;
+	u8 reserv[2];
+	u8 paydata[0];
+} __packed;
+
+struct sprdwl_addr_hdr {
+	struct sprdwl_common_hdr common;
+	u8 paydata[0];
+} __packed;
+
+#define SPRDWL_GET_CMD_PAYDATA(msg) \
+	    (((struct sprdwl_cmd_hdr *)((msg)->skb->data))->paydata)
+
+struct sprdwl_data_hdr {
+	struct sprdwl_common_hdr common;
+
+#define WAPI_PN_SIZE                16
+#define SPRDWL_DATA_OFFSET         2
+	u8 info1; /*no used in marlin3*/
+	/* the payload len include the size of this struct */
+	__le16 plen;
+	/* the flow contrl shared by sta and p2p */
+	u8 flow0;
+	/* the sta flow contrl */
+	u8 flow1;
+	/* the p2p flow contrl */
+	u8 flow2;
+	/* flow3 0: share, 1: self */
+	u8 flow3;
+} __packed;
+
+struct sprdwl_pktlog_hdr {
+	struct sprdwl_common_hdr common;
+	u8 rsvd;
+	/* the payload len include the size of this struct */
+	__le16 plen;
+} __packed;
+
+struct sprdwl_msg_list {
+	struct list_head freelist;
+	struct list_head busylist;
+	/*cmd to be free list*/
+	struct list_head cmd_to_free;
+	int maxnum;
+	/* freelist lock */
+	spinlock_t freelock;
+	/* busylist lock */
+	spinlock_t busylock;
+	/*cmd_to_free lock*/
+	spinlock_t complock;
+	atomic_t ref;
+	/* data flow contrl */
+	atomic_t flow;
+};
+
+struct sprdwl_xmit_msg_list {
+	/*merge qos queues to this list*/
+	struct list_head to_send_list;
+	/*data list sending by HIF, will be freed later*/
+	struct list_head to_free_list;
+	spinlock_t send_lock;
+	spinlock_t free_lock;
+	u8 mode;
+	unsigned long failcount;
+};
+
+struct sprdwl_msg_buf {
+	struct list_head list;
+	struct sk_buff *skb;
+	/* data just tx cmd use,not include the head */
+	void *data;
+	void *tran_data;
+	u8 type;
+	u8 mode;
+	u16 len;
+	unsigned long timeout;
+	/* marlin 2 */
+	unsigned int fifo_id;
+	struct sprdwl_msg_list *msglist;
+	/* marlin 3 */
+	unsigned char buffer_type;
+	struct peer_list *data_list;
+	struct sprdwl_xmit_msg_list *xmit_msg_list;
+	unsigned char msg_type;
+#if defined(MORE_DEBUG)
+	unsigned long tx_start_time;
+#endif
+};
+
+static inline void sprdwl_fill_msg(struct sprdwl_msg_buf *msg,
+				   struct sk_buff *skb, void *data, u16 len)
+{
+	msg->skb = skb;
+	msg->tran_data = data;
+	msg->len = len;
+}
+
+static inline int sprdwl_msg_ref(struct sprdwl_msg_list *msglist)
+{
+	return atomic_read(&msglist->ref);
+}
+
+static inline int sprdwl_msg_tx_pended(struct sprdwl_msg_list *msglist)
+{
+	return !list_empty(&msglist->busylist);
+}
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3, 13, 0)
+#define list_last_entry(ptr, type, member) \
+	list_entry((ptr)->prev, type, member)
+#endif
+
+int sprdwl_msg_init(int num, struct sprdwl_msg_list *list);
+void sprdwl_msg_deinit(struct sprdwl_msg_list *list);
+struct sprdwl_msg_buf *sprdwl_alloc_msg_buf(struct sprdwl_msg_list *list);
+void sprdwl_free_msg_buf(struct sprdwl_msg_buf *msg_buf,
+			 struct sprdwl_msg_list *list);
+void sprdwl_queue_msg_buf(struct sprdwl_msg_buf *msg_buf,
+			  struct sprdwl_msg_list *list);
+struct sprdwl_msg_buf *sprdwl_peek_msg_buf(struct sprdwl_msg_list *list);
+void sprdwl_dequeue_msg_buf(struct sprdwl_msg_buf *msg_buf,
+			    struct sprdwl_msg_list *list);
+struct sprdwl_msg_buf *sprdwl_get_msgbuf_by_data(void *data,
+						 struct sprdwl_msg_list *list);
+struct sprdwl_msg_buf *sprdwl_get_tail_msg_buf(struct sprdwl_msg_list *list);
+#endif
diff --git a/drivers/net/wireless/uwe5622/unisocwifi/nan.c b/drivers/net/wireless/uwe5622/unisocwifi/nan.c
new file mode 100644
index 000000000000..0eca06336c52
--- /dev/null
+++ b/drivers/net/wireless/uwe5622/unisocwifi/nan.c
@@ -0,0 +1,87 @@
+/*
+ * Copyright (C) 2016 Spreadtrum Communications Inc.
+ *
+ * Abstract : This file is an implementation for NAN
+ *
+ * Authors:
+ * Chaojie Xu <chaojie.xu@spreadtrum.com>
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include "sprdwl.h"
+#include "nan.h"
+
+/* macro */
+#define NAN_RSP_LEN 128
+
+/* structure */
+
+/* cmd handler*/
+
+int sprdwl_vendor_nan_cmds(struct wiphy *wiphy,
+			   struct wireless_dev *wdev,
+			   const void  *data, int len)
+{
+	struct sprdwl_msg_buf *msg;
+	struct sprdwl_vif *vif = netdev_priv(wdev->netdev);
+	u8 rsp[NAN_RSP_LEN] = {0x0};
+	u16 rsp_len = NAN_RSP_LEN;
+	int ret = 0;
+
+	msg = sprdwl_cmd_getbuf(vif->priv, len,
+				vif->ctx_id, 1, WIFI_CMD_NAN);
+	if (!msg)
+		return -ENOMEM;
+
+	memcpy(msg->data, data, len);
+	ret = sprdwl_cmd_send_recv(vif->priv, msg,
+				    CMD_WAIT_TIMEOUT, rsp, &rsp_len);
+
+	if (!ret && rsp_len) {
+		sprdwl_event_nan(vif, rsp, rsp_len);
+	} else {
+		wl_err("%s: ret=%d, rsp_len=%d\n", __func__, ret, rsp_len);
+	}
+
+	return ret;
+}
+
+/* event handler*/
+int sprdwl_event_nan(struct sprdwl_vif *vif, u8 *data, u16 len)
+{
+	struct sprdwl_priv *priv = vif->priv;
+	struct wiphy *wiphy = priv->wiphy;
+	struct sk_buff *skb;
+
+	/* Alloc the skb for vendor event */
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 4, 83)
+	skb = cfg80211_vendor_event_alloc(wiphy, &vif->wdev, NLMSG_HDRLEN + len,
+#else
+	skb = cfg80211_vendor_event_alloc(wiphy, NLMSG_HDRLEN + len,
+#endif
+					  SPRDWL_VENDOR_EVENT_NAN_INDEX,
+					  GFP_KERNEL);
+	if (!skb) {
+		wl_ndev_log(L_INFO, vif->ndev, "skb alloc failed");
+		return -ENOMEM;
+	}
+
+	/* Push the data to the skb */
+	if (nla_put(skb, SRPDWL_VENDOR_ATTR_NAN, len, data)) {
+		wl_ndev_log(L_INFO, vif->ndev, "nla put failed");
+		kfree_skb(skb);
+		return -1;
+	}
+
+	cfg80211_vendor_event(skb, GFP_KERNEL);
+
+	return 0;
+}
diff --git a/drivers/net/wireless/uwe5622/unisocwifi/nan.h b/drivers/net/wireless/uwe5622/unisocwifi/nan.h
new file mode 100644
index 000000000000..fd6d980b4d78
--- /dev/null
+++ b/drivers/net/wireless/uwe5622/unisocwifi/nan.h
@@ -0,0 +1,304 @@
+#ifndef __SPRDWL_NAN_H__
+#define __SPRDWL_NAN_H__
+
+/* macro */
+enum nan_msg_id {
+	NAN_MSG_ID_ERROR_RSP                    = 0,
+	NAN_MSG_ID_CONFIGURATION_REQ            = 1,
+	NAN_MSG_ID_CONFIGURATION_RSP            = 2,
+	NAN_MSG_ID_PUBLISH_SERVICE_REQ          = 3,
+	NAN_MSG_ID_PUBLISH_SERVICE_RSP          = 4,
+	NAN_MSG_ID_PUBLISH_SERVICE_CANCEL_REQ   = 5,
+	NAN_MSG_ID_PUBLISH_SERVICE_CANCEL_RSP   = 6,
+	NAN_MSG_ID_PUBLISH_REPLIED_IND          = 7,
+	NAN_MSG_ID_PUBLISH_TERMINATED_IND       = 8,
+	NAN_MSG_ID_SUBSCRIBE_SERVICE_REQ        = 9,
+	NAN_MSG_ID_SUBSCRIBE_SERVICE_RSP        = 10,
+	NAN_MSG_ID_SUBSCRIBE_SERVICE_CANCEL_REQ = 11,
+	NAN_MSG_ID_SUBSCRIBE_SERVICE_CANCEL_RSP = 12,
+	NAN_MSG_ID_MATCH_IND                    = 13,
+	NAN_MSG_ID_MATCH_EXPIRED_IND            = 14,
+	NAN_MSG_ID_SUBSCRIBE_TERMINATED_IND     = 15,
+	NAN_MSG_ID_DE_EVENT_IND                 = 16,
+	NAN_MSG_ID_TRANSMIT_FOLLOWUP_REQ        = 17,
+	NAN_MSG_ID_TRANSMIT_FOLLOWUP_RSP        = 18,
+	NAN_MSG_ID_FOLLOWUP_IND                 = 19,
+	NAN_MSG_ID_STATS_REQ                    = 20,
+	NAN_MSG_ID_STATS_RSP                    = 21,
+	NAN_MSG_ID_ENABLE_REQ                   = 22,
+	NAN_MSG_ID_ENABLE_RSP                   = 23,
+	NAN_MSG_ID_DISABLE_REQ                  = 24,
+	NAN_MSG_ID_DISABLE_RSP                  = 25,
+	NAN_MSG_ID_DISABLE_IND                  = 26,
+	NAN_MSG_ID_TCA_REQ                      = 27,
+	NAN_MSG_ID_TCA_RSP                      = 28,
+	NAN_MSG_ID_TCA_IND                      = 29,
+	NAN_MSG_ID_BEACON_SDF_REQ               = 30,
+	NAN_MSG_ID_BEACON_SDF_RSP               = 31,
+	NAN_MSG_ID_BEACON_SDF_IND               = 32,
+	NAN_MSG_ID_CAPABILITIES_REQ             = 33,
+	NAN_MSG_ID_CAPABILITIES_RSP             = 34
+};
+
+enum nan_tlv_type {
+	NAN_TLV_TYPE_FIRST = 0,
+
+	/* Service Discovery Frame types */
+	NAN_TLV_TYPE_SDF_FIRST = NAN_TLV_TYPE_FIRST,
+	NAN_TLV_TYPE_SERVICE_NAME = NAN_TLV_TYPE_SDF_FIRST,
+	NAN_TLV_TYPE_SDF_MATCH_FILTER,
+	NAN_TLV_TYPE_TX_MATCH_FILTER,
+	NAN_TLV_TYPE_RX_MATCH_FILTER,
+	NAN_TLV_TYPE_SERVICE_SPECIFIC_INFO,
+	NAN_TLV_TYPE_EXT_SERVICE_SPECIFIC_INFO = 5,
+	NAN_TLV_TYPE_VENDOR_SPECIFIC_ATTRIBUTE_TRANSMIT = 6,
+	NAN_TLV_TYPE_VENDOR_SPECIFIC_ATTRIBUTE_RECEIVE = 7,
+	NAN_TLV_TYPE_POST_NAN_CONNECTIVITY_CAPABILITIES_RECEIVE = 8,
+	NAN_TLV_TYPE_POST_NAN_DISCOVERY_ATTRIBUTE_RECEIVE = 9,
+	NAN_TLV_TYPE_BEACON_SDF_PAYLOAD_RECEIVE = 10,
+	NAN_TLV_TYPE_SDF_LAST = 4095,
+
+	/* Configuration types */
+	NAN_TLV_TYPE_CONFIG_FIRST = 4096,
+	NAN_TLV_TYPE_24G_SUPPORT = NAN_TLV_TYPE_CONFIG_FIRST,
+	NAN_TLV_TYPE_24G_BEACON,
+	NAN_TLV_TYPE_24G_SDF,
+	NAN_TLV_TYPE_24G_RSSI_CLOSE,
+	NAN_TLV_TYPE_24G_RSSI_MIDDLE = 4100,
+	NAN_TLV_TYPE_24G_RSSI_CLOSE_PROXIMITY,
+	NAN_TLV_TYPE_5G_SUPPORT,
+	NAN_TLV_TYPE_5G_BEACON,
+	NAN_TLV_TYPE_5G_SDF,
+	NAN_TLV_TYPE_5G_RSSI_CLOSE,
+	NAN_TLV_TYPE_5G_RSSI_MIDDLE,
+	NAN_TLV_TYPE_5G_RSSI_CLOSE_PROXIMITY,
+	NAN_TLV_TYPE_SID_BEACON,
+	NAN_TLV_TYPE_HOP_COUNT_LIMIT,
+	NAN_TLV_TYPE_MASTER_PREFERENCE = 4110,
+	NAN_TLV_TYPE_CLUSTER_ID_LOW,
+	NAN_TLV_TYPE_CLUSTER_ID_HIGH,
+	NAN_TLV_TYPE_RSSI_AVERAGING_WINDOW_SIZE,
+	NAN_TLV_TYPE_CLUSTER_OUI_NETWORK_ID,
+	NAN_TLV_TYPE_SOURCE_MAC_ADDRESS,
+	NAN_TLV_TYPE_CLUSTER_ATTRIBUTE_IN_SDF,
+	NAN_TLV_TYPE_SOCIAL_CHANNEL_SCAN_PARAMS,
+	NAN_TLV_TYPE_DEBUGGING_FLAGS,
+	NAN_TLV_TYPE_POST_NAN_CONNECTIVITY_CAPABILITIES_TRANSMIT,
+	NAN_TLV_TYPE_POST_NAN_DISCOVERY_ATTRIBUTE_TRANSMIT = 4120,
+	NAN_TLV_TYPE_FURTHER_AVAILABILITY_MAP,
+	NAN_TLV_TYPE_HOP_COUNT_FORCE,
+	NAN_TLV_TYPE_RANDOM_FACTOR_FORCE,
+	NAN_TLV_TYPE_RANDOM_UPDATE_TIME = 4124,
+	NAN_TLV_TYPE_EARLY_WAKEUP,
+	NAN_TLV_TYPE_PERIODIC_SCAN_INTERVAL,
+	NAN_TLV_TYPE_DW_INTERVAL = 4128,
+	NAN_TLV_TYPE_DB_INTERVAL,
+	NAN_TLV_TYPE_FURTHER_AVAILABILITY,
+	NAN_TLV_TYPE_24G_CHANNEL,
+	NAN_TLV_TYPE_5G_CHANNEL,
+	NAN_TLV_TYPE_CONFIG_LAST = 8191,
+
+	/* Attributes types */
+	NAN_TLV_TYPE_ATTRS_FIRST = 8192,
+	NAN_TLV_TYPE_AVAILABILITY_INTERVALS_MAP = NAN_TLV_TYPE_ATTRS_FIRST,
+	NAN_TLV_TYPE_WLAN_MESH_ID,
+	NAN_TLV_TYPE_MAC_ADDRESS,
+	NAN_TLV_TYPE_RECEIVED_RSSI_VALUE,
+	NAN_TLV_TYPE_CLUSTER_ATTRIBUTE,
+	NAN_TLV_TYPE_WLAN_INFRA_SSID,
+	NAN_TLV_TYPE_ATTRS_LAST = 12287,
+
+	/* Events Type */
+	NAN_TLV_TYPE_EVENTS_FIRST = 12288,
+	NAN_TLV_TYPE_EVENT_SELF_STATION_MAC_ADDRESS = NAN_TLV_TYPE_EVENTS_FIRST,
+	NAN_TLV_TYPE_EVENT_STARTED_CLUSTER,
+	NAN_TLV_TYPE_EVENT_JOINED_CLUSTER,
+	NAN_TLV_TYPE_EVENT_CLUSTER_SCAN_RESULTS,
+	NAN_TLV_TYPE_FAW_MEM_AVAIL,
+	NAN_TLV_TYPE_EVENTS_LAST = 16383,
+
+	/* TCA types */
+	NAN_TLV_TYPE_TCA_FIRST = 16384,
+	NAN_TLV_TYPE_CLUSTER_SIZE_REQ = NAN_TLV_TYPE_TCA_FIRST,
+	NAN_TLV_TYPE_CLUSTER_SIZE_RSP,
+	NAN_TLV_TYPE_TCA_LAST = 32767,
+
+	/* Statistics types */
+	NAN_TLV_TYPE_STATS_FIRST = 32768,
+	NAN_TLV_TYPE_DE_PUBLISH_STATS = NAN_TLV_TYPE_STATS_FIRST,
+	NAN_TLV_TYPE_DE_SUBSCRIBE_STATS,
+	NAN_TLV_TYPE_DE_MAC_STATS,
+	NAN_TLV_TYPE_DE_TIMING_SYNC_STATS,
+	NAN_TLV_TYPE_DE_DW_STATS,
+	NAN_TLV_TYPE_DE_STATS,
+	NAN_TLV_TYPE_STATS_LAST = 36863,
+
+	NAN_TLV_TYPE_LAST = 65535
+};
+
+/* structure */
+struct nan_msg_header {
+	u16 msg_ver:4; /* NAN_MSG_VERSION 1 */
+	u16 msg_id:12;
+	u16 msg_len;
+	u16 handle; /* publish_id or subscribe_id */
+	u16 transaction_id;
+} __packed;
+
+struct nan_tlv {
+	u16 type;
+	u16 length;
+	u8 *value;
+} __packed;
+
+struct nan_enable_req {
+	struct nan_msg_header header;
+	/* TLVs:
+	 *
+	 * Required: Cluster Low, Cluster High, Master Preference,
+	 * Optional: 5G Support, SID, 5G Sync Disc, RSSI Close, RSSI Medium,
+	 *           Hop Count Limit, Random Time, Master Preference,
+	 *           WLAN Intra Attr, P2P Operation Attr, WLAN IBSS Attr,
+	 *           WLAN Mesh Attr
+	*/
+	u8 nan_tlv[];
+} __packed;
+
+struct nan_disable_req {
+	struct nan_msg_header header;
+} __packed;
+
+struct nan_disable_rsp {
+	struct nan_msg_header header;
+	/* status of the request */
+	u16 status;
+	u16 value;
+} __packed;
+
+struct publish_config_params {
+	u16 ttl;
+	u16 period;
+	u32 reserved:1;
+	u32 publish_type:2;
+	u32 tx_type:1;
+	u32 rssi_threshold_flag:1;
+	u32 ota_flag:1;
+	u32 publish_match_indicator:2;
+	u32 publish_count:8;
+	u32 connmap:8;
+	u32 disable_pub_terminated_ind:1;
+	u32 disable_pub_match_expired_ind:1;
+	u32 disable_followup_rx_ind:1;
+	u32 reserved2:5;
+} __packed;
+
+struct nan_publish_req {
+	struct nan_msg_header header;
+	struct publish_config_params pub_params;
+	/* TLVs:
+	 *
+	 * Required: Service Name,
+	 * Optional: Tx Match Filter, Rx Match Filter, Service Specific Info,
+	 */
+	u8 nan_tlv[];
+} __packed;
+
+struct nan_cancel_pub_req {
+	struct nan_msg_header header;
+} __packed;
+
+struct subscribe_config_parames {
+	u16 ttl;
+	u16 period;
+	u32 subscribe_type:1;
+	u32 srf_type:1;
+	u32 srf_include_type:1;
+	u32 srf_state:1;
+	u32 ssi_required:1;
+	u32 subscribe_match_indicator:2;
+	u32 xbit:1;
+	u32 subscribe_count:8;
+	u32 rssi_threshold_flag:1;
+	u32 ota_flag:1;
+	u32 disable_sub_terminated_ind:1;
+	u32 disable_sub_match_expired_ind:1;
+	u32 disable_followup_rx_ind:1;
+	u32 reserved:3;
+	u32 connmap:8;
+} __packed;
+
+struct nan_subscribe_req {
+	struct nan_msg_header header;
+	struct subscribe_config_parames sub_params;
+	/* TLVs:
+	 *
+	 * Required: Service Name
+	 * Optional: Rx Match Filter, Tx Match Filter, Service Specific Info,
+	 */
+	u8 nan_tlv[];
+} __packed;
+
+struct nan_cancel_sub_req {
+	struct nan_msg_header header;
+} __packed;
+
+struct followup_config_params {
+	u32 requestor_instance_id;
+	u32 priority:4;
+	u32 dw_or_faw:1;
+	u32 recv_indication_cfg:1;
+	u32 reserved:26;
+} __packed;
+
+struct nan_followup_req {
+	struct nan_msg_header header;
+	struct followup_config_params followup_params;
+	/* TLVs:
+	 *
+	 * Required: Service Specific Info or Extended Service Specific Info
+	 */
+	u8 nan_tlv[];
+} __packed;
+
+struct nan_capabilities_req {
+	struct nan_msg_header header;
+} __packed;
+
+struct sprdwl_event_nan {
+	struct nan_msg_header header;
+	/* status of the request */
+	u16 status;
+	u16 value;
+} __packed;
+
+struct nan_capa {
+	struct nan_msg_header header;
+	u32 status;
+	u32 value;
+	u32 max_concurrent_nan_clusters;
+	u32 max_publishes;
+	u32 max_subscribes;
+	u32 max_service_name_len;
+	u32 max_match_filter_len;
+	u32 max_total_match_filter_len;
+	u32 max_service_specific_info_len;
+	u32 max_vsa_data_len;
+	u32 max_mesh_data_len;
+	u32 max_ndi_interfaces;
+	u32 max_ndp_sessions;
+	u32 max_app_info_len;
+} __packed;
+
+struct nan_cmd_header {
+	u16 data_len;
+	u8 data[0];
+} __packed;
+
+/* cmd handler*/
+int sprdwl_vendor_nan_cmds(struct wiphy *wiphy,
+			   struct wireless_dev *wdev,
+			   const void  *data, int len);
+/* event handler*/
+int sprdwl_event_nan(struct sprdwl_vif *vif, u8 *data, u16 len);
+
+#endif /* __SPRDWL_NAN_H__ */
diff --git a/drivers/net/wireless/uwe5622/unisocwifi/npi.c b/drivers/net/wireless/uwe5622/unisocwifi/npi.c
new file mode 100644
index 000000000000..14ff06f72e17
--- /dev/null
+++ b/drivers/net/wireless/uwe5622/unisocwifi/npi.c
@@ -0,0 +1,313 @@
+/*
+ * Copyright (C) 2015 Spreadtrum Communications Inc.
+ *
+ * Authors	:
+ * Xianwei.Zhao <xianwei.zhao@spreadtrum.com>
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include <linux/kernel.h>
+#include <linux/platform_device.h>
+#include <linux/module.h>
+#include <linux/uaccess.h>
+#include <net/genetlink.h>
+#include <linux/types.h>
+#include <linux/version.h>
+#include <marlin_platform.h>
+
+#include "sprdwl.h"
+#include "npi.h"
+
+static int sprdwl_nl_send_generic(struct genl_info *info, u8 attr, u8 cmd,
+				  u32 len, u8 *data);
+static struct genl_family sprdwl_nl_genl_family;
+
+static int sprdwl_cmd_set_psm_cap(struct sprdwl_vif *vif)
+{
+	struct sprdwl_priv *priv = NULL;
+	struct sprdwl_npi_cmd_hdr *msg;
+	unsigned char r_buf[512] = {0}, s_buf[8];
+	unsigned short r_len = 512;
+	int s_len, flag, ret;
+
+	if (!vif) {
+		wl_err("%s: parameters invalid\n", __func__);
+		return -EINVAL;
+	}
+	priv = vif->priv;
+	flag = SPRDWL_STA_GC_NO_SLEEP; //FIXME: or SPRDWL_STA_GC_EN_SLEEP ?
+
+	msg = (struct sprdwl_npi_cmd_hdr *)s_buf;
+	msg->type = SPRDWL_HT2CP_CMD;
+	msg->subtype = SPRDWL_NPI_CMD_SET_WLAN_CAP;
+	msg->len = sizeof(flag);
+	s_len = msg->len + sizeof(*msg);
+	memcpy(s_buf + sizeof(*msg), &flag, sizeof(flag));
+	ret = sprdwl_npi_send_recv(priv, vif->ctx_id, s_buf,
+				   s_len, r_buf, &r_len);
+
+	wl_info("[%s psm is:%s]\n", __func__, flag ? "normal mode" : "rf mode");
+
+	return ret;
+}
+
+static int sprdwl_npi_pre_doit(const struct genl_ops *ops,
+			       struct sk_buff *skb, struct genl_info *info)
+{
+	struct net_device *ndev;
+	struct sprdwl_vif *vif;
+	struct sprdwl_priv *priv;
+	int ifindex;
+
+	if (!info) {
+		wl_err("%s NULL info!\n", __func__);
+		return -EINVAL;
+	}
+
+	if (info->attrs[SPRDWL_NL_ATTR_IFINDEX]) {
+		ifindex = nla_get_u32(info->attrs[SPRDWL_NL_ATTR_IFINDEX]);
+		ndev = dev_get_by_index(genl_info_net(info), ifindex);
+		if (!ndev) {
+			wl_err("NPI: Could not find ndev\n");
+			return -EFAULT;
+		}
+		vif = netdev_priv(ndev);
+		priv = vif->priv;
+		info->user_ptr[0] = ndev;
+		info->user_ptr[1] = priv;
+	} else {
+		wl_err("nl80211_pre_doit: Not have attr_ifindex\n");
+		return -EFAULT;
+	}
+	return 0;
+}
+
+static void sprdwl_npi_post_doit(const struct genl_ops *ops,
+				 struct sk_buff *skb, struct genl_info *info)
+{
+	if (info->user_ptr[0])
+		dev_put(info->user_ptr[0]);
+}
+
+static bool sprdwl_npi_cmd_is_start(void *buf)
+{
+	struct sprdwl_npi_cmd_hdr *msg;
+
+	msg = (struct sprdwl_npi_cmd_hdr *)buf;
+	if ((msg->type == SPRDWL_HT2CP_CMD) &&
+	    (msg->subtype == SPRDWL_NPI_CMD_START))
+		return true;
+	else
+		return false;
+}
+
+static bool sta_or_p2p_is_opened(void)
+{
+	return false;
+}
+
+static int sprdwl_nl_npi_handler(struct sk_buff *skb_2, struct genl_info *info)
+{
+	struct net_device *ndev = NULL;
+	struct sprdwl_vif *vif = NULL;
+	struct sprdwl_priv *priv = NULL;
+	struct sprdwl_npi_cmd_hdr *hdr = NULL;
+	unsigned short r_len = 1024, s_len;
+	unsigned char *s_buf = NULL, *r_buf = NULL;
+	unsigned char dbgstr[64] = { 0 };
+	int err = -100, ret = 0;
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 14, 0)
+	const char *id_name = NULL;
+	unsigned char status = 0;
+#endif
+
+	ndev = info->user_ptr[0];
+	vif = netdev_priv(ndev);
+	priv = info->user_ptr[1];
+	if (!info->attrs[SPRDWL_NL_ATTR_AP2CP]) {
+		wl_err("%s: invalid content\n", __func__);
+		return -EPERM;
+	}
+	r_buf = kmalloc(1024, GFP_KERNEL);
+	if (!r_buf)
+		return -ENOMEM;
+
+	s_buf = nla_data(info->attrs[SPRDWL_NL_ATTR_AP2CP]);
+	s_len = nla_len(info->attrs[SPRDWL_NL_ATTR_AP2CP]);
+	if (sprdwl_npi_cmd_is_start(s_buf) && sta_or_p2p_is_opened()) {
+		hdr = kzalloc(sizeof(*hdr), GFP_KERNEL);
+		if (!hdr) {
+			wl_err("%s: failed to alloc hdr!\n", __func__);
+			kfree(r_buf);
+			return -ENOMEM;
+		}
+		hdr->type = SPRDWL_CP2HT_REPLY;
+		hdr->subtype = SPRDWL_NPI_CMD_START;
+		hdr->len = sizeof(err);
+		r_len = sizeof(*hdr) + hdr->len;
+		memcpy(r_buf, hdr, sizeof(*hdr));
+		memcpy(r_buf + sizeof(*hdr), &err, hdr->len);
+		ret = sprdwl_nl_send_generic(info, SPRDWL_NL_ATTR_CP2AP,
+					     SPRDWL_NL_CMD_NPI, r_len, r_buf);
+		kfree(hdr);
+		kfree(r_buf);
+		return ret;
+	}
+
+	sprintf(dbgstr, "[iwnpi][SEND][%d]:", s_len);
+	hdr = (struct sprdwl_npi_cmd_hdr *)s_buf;
+	wl_err("%s type is %d, subtype %d\n", dbgstr, hdr->type, hdr->subtype);
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 14, 0)
+	if (hdr->subtype == SPRDWL_NPI_CMD_GET_CHIPID) {
+		id_name = wcn_get_chip_name();
+		sprintf(r_buf, "%d", status);
+		strcat(r_buf, id_name);
+		r_len = strlen(r_buf);
+		wl_err("r_len = %d, %s\n", r_len, __func__);
+	} else {
+		sprdwl_npi_send_recv(priv, vif->ctx_id, s_buf, s_len, r_buf, &r_len);
+
+		sprintf(dbgstr, "[iwnpi][RECV][%d]:", r_len);
+		hdr = (struct sprdwl_npi_cmd_hdr *)r_buf;
+		wl_err("%s type is %d, subtype %d\n", dbgstr, hdr->type, hdr->subtype);
+	}
+#else
+	sprdwl_npi_send_recv(priv, vif->ctx_id, s_buf, s_len, r_buf, &r_len);
+
+	sprintf(dbgstr, "[iwnpi][RECV][%d]:", r_len);
+	hdr = (struct sprdwl_npi_cmd_hdr *)r_buf;
+	wl_err("%s type is %d, subtype %d\n", dbgstr, hdr->type, hdr->subtype);
+#endif
+
+	ret = sprdwl_nl_send_generic(info, SPRDWL_NL_ATTR_CP2AP,
+				     SPRDWL_NL_CMD_NPI, r_len, r_buf);
+
+	if (sprdwl_npi_cmd_is_start(s_buf)) {
+		msleep(100);
+		ret = sprdwl_cmd_set_psm_cap(vif);
+	}
+	kfree(r_buf);
+	return ret;
+}
+
+static int sprdwl_nl_get_info_handler(struct sk_buff *skb_2,
+				      struct genl_info *info)
+{
+	struct net_device *ndev = info->user_ptr[0];
+	struct sprdwl_vif *vif = netdev_priv(ndev);
+	unsigned char r_buf[64] = { 0 };
+	unsigned short r_len = 0;
+	int ret = 0;
+
+	if (vif) {
+		ether_addr_copy(r_buf, vif->ndev->dev_addr);
+		sprdwl_put_vif(vif);
+		r_len = 6;
+		ret = sprdwl_nl_send_generic(info, SPRDWL_NL_ATTR_CP2AP,
+					     SPRDWL_NL_CMD_GET_INFO, r_len,
+					     r_buf);
+	} else {
+		wl_err("%s NULL vif!\n", __func__);
+		ret = -1;
+	}
+	return ret;
+}
+
+static struct nla_policy sprdwl_genl_policy[SPRDWL_NL_ATTR_MAX + 1] = {
+	[SPRDWL_NL_ATTR_AP2CP] = {.type = NLA_BINARY, .len = 1024},
+	[SPRDWL_NL_ATTR_CP2AP] = {.type = NLA_BINARY, .len = 1024}
+};
+
+static struct genl_ops sprdwl_nl_ops[] = {
+	{
+		.cmd = SPRDWL_NL_CMD_NPI,
+		.policy = sprdwl_genl_policy,
+		.doit = sprdwl_nl_npi_handler,
+	},
+	{
+		.cmd = SPRDWL_NL_CMD_GET_INFO,
+		.policy = sprdwl_genl_policy,
+		.doit = sprdwl_nl_get_info_handler,
+	}
+};
+
+static struct genl_family sprdwl_nl_genl_family = {
+	.id = SPRDWL_NL_GENERAL_SOCK_ID,
+	.hdrsize = 0,
+	.name = "SPRDWL_NL",
+	.version = 1,
+	.maxattr = SPRDWL_NL_ATTR_MAX,
+	.pre_doit = sprdwl_npi_pre_doit,
+	.post_doit = sprdwl_npi_post_doit,
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 14, 0)
+	.module = THIS_MODULE,
+	.n_ops = ARRAY_SIZE(sprdwl_nl_ops),
+	.ops = sprdwl_nl_ops,
+#endif
+};
+
+static int sprdwl_nl_send_generic(struct genl_info *info, u8 attr,
+				  u8 cmd, u32 len, u8 *data)
+{
+	struct sk_buff *skb;
+	void *hdr;
+	int ret;
+
+	skb = nlmsg_new(NLMSG_GOODSIZE, GFP_KERNEL);
+	if (!skb)
+		return -ENOMEM;
+	hdr = genlmsg_put(skb, info->snd_portid, info->snd_seq,
+			  &sprdwl_nl_genl_family, 0, cmd);
+	if (IS_ERR(hdr)) {
+		ret = PTR_ERR(hdr);
+		goto err_put;
+	}
+	if (nla_put(skb, attr, len, data)) {
+		ret = -1;
+		goto err_put;
+	}
+
+	genlmsg_end(skb, hdr);
+	return genlmsg_reply(skb, info);
+
+err_put:
+	nlmsg_free(skb);
+	return ret;
+}
+
+void sprdwl_init_npi(void)
+{
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 14, 0)
+	int ret = genl_register_family(&sprdwl_nl_genl_family);
+	if (ret)
+		wl_err("genl_register_family error: %d\n", ret);
+#else
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 13, 0)
+	int ret = genl_register_family_with_ops(&sprdwl_nl_genl_family,
+						sprdwl_nl_ops);
+#else
+	int ret = genl_register_family_with_ops(&sprdwl_nl_genl_family,
+						sprdwl_nl_ops,
+						ARRAY_SIZE(sprdwl_nl_ops));
+#endif
+	if (ret)
+		wl_err("genl_register_family_with_ops error: %d\n", ret);
+#endif
+}
+
+void sprdwl_deinit_npi(void)
+{
+	int ret = genl_unregister_family(&sprdwl_nl_genl_family);
+
+	if (ret)
+		wl_err("genl_unregister_family error:%d\n", ret);
+}
diff --git a/drivers/net/wireless/uwe5622/unisocwifi/npi.h b/drivers/net/wireless/uwe5622/unisocwifi/npi.h
new file mode 100644
index 000000000000..0c81ef0d7d92
--- /dev/null
+++ b/drivers/net/wireless/uwe5622/unisocwifi/npi.h
@@ -0,0 +1,75 @@
+/*
+ * Copyright (C) 2013 Spreadtrum Communications Inc.
+ *
+ * Filename : npi.h
+ * Abstract : This file is a general definition for NPI cmd
+ *
+ * Authors	:
+ * Xianwei.Zhao <xianwei.zhao@spreadtrum.com>
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#ifndef __SPRDWL_NPI_H__
+#define __SPRDWL_NPI_H__
+
+#define SPRDWL_NL_GENERAL_SOCK_ID	(1022)
+#define SPRDWL_NPI_CMD_START		(0)
+#define SPRDWL_NPI_CMD_SET_WLAN_CAP	(40)
+#define SPRDWL_STA_GC_EN_SLEEP		(0x3)
+#define SPRDWL_STA_GC_NO_SLEEP		(0x0)
+#define SPRDWL_PSM_PATH			"/opt/etc/.psm.info"
+#define SPRDWL_NPI_CMD_GET_CHIPID	(136)
+
+#define SPRDWL_NPI_CMD_SET_PROTECTION_MODE 50
+#define SPRDWL_NPI_CMD_GET_PROTECTION_MODE 51
+#define SPRDWL_NPI_CMD_SET_RTS_THRESHOLD   52
+
+/* enable: 0x0
+ * disable: 0x1
+ * STA: bit 0
+ * GC: bit 1
+ */
+enum sprdwl_nl_commands {
+	SPRDWL_NL_CMD_UNSPEC,
+	SPRDWL_NL_CMD_NPI,
+	SPRDWL_NL_CMD_GET_INFO,
+	SPRDWL_NL_CMD_MAX,
+};
+
+enum sprdwl_nl_attrs {
+	SPRDWL_NL_ATTR_UNSPEC,
+	SPRDWL_NL_ATTR_IFINDEX,
+	SPRDWL_NL_ATTR_AP2CP,
+	SPRDWL_NL_ATTR_CP2AP,
+	SPRDWL_NL_ATTR_MAX,
+};
+
+struct sprdwl_npi_cmd_hdr {
+	unsigned char type;
+	unsigned char subtype;
+	unsigned short len;
+} __packed;
+
+struct sprdwl_npi_cmd_resp_hdr {
+	unsigned char type;
+	unsigned char subtype;
+	unsigned short len;
+	int status;
+} __packed;
+
+enum sprdwl_npi_cmd_type {
+	SPRDWL_HT2CP_CMD = 1,
+	SPRDWL_CP2HT_REPLY,
+};
+
+void sprdwl_init_npi(void);
+void sprdwl_deinit_npi(void);
+#endif /*__NPI_H__*/
diff --git a/drivers/net/wireless/uwe5622/unisocwifi/qos.c b/drivers/net/wireless/uwe5622/unisocwifi/qos.c
new file mode 100644
index 000000000000..c01d88fba346
--- /dev/null
+++ b/drivers/net/wireless/uwe5622/unisocwifi/qos.c
@@ -0,0 +1,815 @@
+/*
+ * Copyright (C) 2016 Spreadtrum Communications Inc.
+ *
+ * Authors	:
+ * star.liu <star.liu@spreadtrum.com>
+ * yifei.li <yifei.li@spreadtrum.com>
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include "qos.h"
+#include "msg.h"
+#include "sprdwl.h"
+
+unsigned int g_qos_enable;
+#if 0
+/*initial array of dscp map to priority
+ *map array will be changed by qos remap
+ */
+#define DSCP_MAX_VALUE 64
+const unsigned char default_dscp2priomap[DSCP_MAX_VALUE] = {
+	0, 0, 0, 0, 0, 0, 0, 0,
+	1, 0, 0, 0, 0, 0, 0, 0,
+	1, 0, 0, 0, 0, 0, 0, 0,
+	0, 0, 4, 0, 4, 0, 4, 0,
+	4, 0, 4, 0, 4, 0, 4, 0,
+	4, 0, 0, 0, 0, 0, 6, 0,
+	6, 0, 0, 0, 0, 0, 0, 0,
+	6, 0, 0, 0, 0, 0, 0, 0
+};
+#endif
+#ifdef WMMAC_WFA_CERTIFICATION
+bool g_wmmac_available[NUM_AC] = {false, false, false, false};
+u32 g_wmmac_admittedtime[NUM_AC] = {0};
+u32 g_wmmac_usedtime[NUM_AC] = {0};
+struct wmm_ac_ts_t g_sta_ts_info[NUM_TID];
+unsigned int wmmac_ratio = 10;
+#endif
+
+struct qos_map_set g_11u_qos_map;
+
+void init_default_qos_map(void)
+{
+	u8 index;
+
+	for (index = 0; index < QOS_MAP_MAX_DSCP_EXCEPTION; index++) {
+		g_11u_qos_map.qos_exceptions[index].dscp = 0xFF;
+		g_11u_qos_map.qos_exceptions[index].up = prio_0;
+	}
+
+	index = 0;
+	g_11u_qos_map.qos_ranges[index].low = 0x0;	/*IP-PL0*/
+	g_11u_qos_map.qos_ranges[index].high = 0x0;
+	g_11u_qos_map.qos_ranges[index].up = prio_0;
+
+	index++;
+	g_11u_qos_map.qos_ranges[index].low = 0x3;	/*IP-PL3*/
+	g_11u_qos_map.qos_ranges[index].high = 0x3;
+	g_11u_qos_map.qos_ranges[index].up = prio_0;
+
+	index++;
+	g_11u_qos_map.qos_ranges[index].low = 0x1;	/*IP-PL1*/
+	g_11u_qos_map.qos_ranges[index].high = 0x2;	/*IP-PL2*/
+	g_11u_qos_map.qos_ranges[index].up = prio_1;
+
+	index++;
+	g_11u_qos_map.qos_ranges[index].low = 0x4;	/*IP-PL4*/
+	g_11u_qos_map.qos_ranges[index].high = 0x5;	/*IP-PL5*/
+	g_11u_qos_map.qos_ranges[index].up = prio_4;
+
+	index++;
+	g_11u_qos_map.qos_ranges[index].low = 0x6;	/*IP-PL6*/
+	g_11u_qos_map.qos_ranges[index].high = 0x7;	/*IP-PL7*/
+	g_11u_qos_map.qos_ranges[index].up = prio_6;
+
+}
+
+unsigned int pkt_get_prio(void *skb, int data_offset, unsigned char *tos)
+{
+	struct ether_header *eh;
+	struct ethervlan_header *evh;
+	unsigned char *pktdata;
+	unsigned int priority = prio_6;
+
+	pktdata = ((struct sk_buff *)(skb))->data + data_offset;
+	eh = (struct ether_header *)pktdata;
+
+	if (eh->ether_type == cpu_to_be16(ETHER_TYPE_8021Q)) {
+		unsigned short vlan_tag;
+		int vlan_prio;
+
+		evh = (struct ethervlan_header *)eh;
+
+		vlan_tag = be16_to_cpu(evh->vlan_tag);
+		vlan_prio = (int)(vlan_tag >> VLAN_PRI_SHIFT) & VLAN_PRI_MASK;
+		priority = vlan_prio;
+	} else {
+		unsigned char *ip_body = pktdata + sizeof(struct ether_header);
+		unsigned char tos_tc = IP_TOS46(ip_body) & 0xE0;
+
+		*tos = IP_TOS46(ip_body);
+		switch (tos_tc) {
+		case 0x00:
+		case 0x60:
+			priority = prio_0;/*BE*/
+			break;
+		case 0x20:
+		case 0x40:
+			priority = prio_1;/*BK*/
+			break;
+		case 0x80:
+		case 0xA0:
+			priority = prio_4;/*VI*/
+			break;
+		default:
+			priority = prio_6;/*VO*/
+			break;
+		}
+	}
+
+	PKT_SET_PRIO(skb, priority);
+	return priority;
+}
+
+static const u8 up_to_ac[] = {
+	0,	/*SPRDWL_AC_BE*/
+	1,	/*SPRDWL_AC_BK*/
+	1,	/*SPRDWL_AC_BK*/
+	0,	/*SPRDWL_AC_BE*/
+	4,	/*SPRDWL_AC_VI*/
+	4,	/*SPRDWL_AC_VI*/
+	6,	/*SPRDWL_AC_VO*/
+	6	/*SPRDWL_AC_VO*/
+};
+
+#if 0
+/* up range from low to high with up value */
+static bool
+qos_up_table_set(u8 *dscp2up_table, u8 up, struct dscp_range *dscp_range)
+{
+	int i;
+
+	if (up > 7 || dscp_range->low > dscp_range->high ||
+		dscp_range->low >= DSCP_MAX_VALUE ||
+		dscp_range->high >= DSCP_MAX_VALUE) {
+		return false;
+	}
+
+	for (i = dscp_range->low; i <= dscp_range->high; i++)
+		dscp2up_table[i] = up_to_ac[up];
+
+	return true;
+}
+
+/* set user priority table */
+void qos_set_dscp2up_table(unsigned char *dscp2up_table,
+			   struct qos_capab_info *qos_map_ie)
+{
+	unsigned char len;
+	struct dscp_range dscp_range;
+	int i;
+	struct dscp_range *range;
+	unsigned char except_len;
+	u8 *except_ptr;
+	u8 *range_ptr;
+
+	if (dscp2up_table == NULL || qos_map_ie == NULL)
+		return;
+
+	/* length of QoS Map IE must be 16+n*2, n is number of exceptions */
+	if (qos_map_ie != NULL && qos_map_ie->id == DOT11_MNG_QOS_MAP_ID &&
+			qos_map_ie->len >= QOS_MAP_FIXED_LENGTH &&
+			(qos_map_ie->len % 2) == 0) {
+		except_ptr = (u8 *)qos_map_ie->qos_info;
+		len = qos_map_ie->len;
+		except_len = len - QOS_MAP_FIXED_LENGTH;
+		range_ptr = except_ptr + except_len;
+
+		/* fill in ranges */
+		for (i = 0; i < QOS_MAP_FIXED_LENGTH; i += 2) {
+			range = (struct dscp_range *)(&range_ptr[i]);
+
+			if (range->low == 255 && range->high == 255)
+				continue;
+			if (!qos_up_table_set(dscp2up_table, i / 2, range)) {
+				/* reset the table on failure */
+				memcpy(dscp2up_table, default_dscp2priomap,
+				       DSCP_MAX_VALUE);
+				return;
+			}
+		}
+
+		/* update exceptions */
+		for (i = 0; i < except_len; i += 2) {
+			struct dscp_exception *exception =
+				(struct dscp_exception *)(&except_ptr[i]);
+			unsigned char dscp = exception->dscp;
+			unsigned char up = exception->up;
+
+			dscp_range.high = dscp;
+			dscp_range.low = dscp;
+			/* exceptions with invalid dscp/up are ignored */
+			qos_up_table_set(dscp2up_table, up, &dscp_range);
+		}
+	}
+	wl_hex_dump(L_DBG, "qos up table: ", DUMP_PREFIX_OFFSET,
+			     16, 1, dscp2up_table, DSCP_MAX_VALUE, 0);
+}
+
+/*Todo*/
+int fq_table[5][4] = {
+	{0,  0,  0,  0},
+	{30,  0,  0,  0},
+	{30,  20,  0,  0},
+	{40,  25,  20,  0},
+	{40,  30,  20,  10}
+};
+
+/*Todo*/
+int wfq_table[5][4] = {
+	{0,  0,  0,  0},
+	{10, 0,  0,  0},
+	{20, 10, 0,  0},
+	{30, 20, 10, 0},
+	{40, 30, 20, 10}
+};
+
+/*Todo*/
+int fd_special_table[2][2] = {
+	{30, 10},
+	{30, 10}
+};
+
+/*time slot ratio based on WFA spec*/
+int fd_ratio_table[3] = {7, /*vo: 87%, vi:13%*/
+			      9, /*vi:90%, be:10%*/
+			      5};/*be:81%, bk:19%*/
+#endif
+void qos_enable(int flag)
+{
+	g_qos_enable = flag;
+}
+
+void qos_init(struct tx_t *tx_t_list)
+{
+	int i, j;
+
+	/*tx_t_list->index = SPRDWL_AC_VO;*/
+	for (i = 0; i < SPRDWL_AC_MAX; i++) {
+		for (j = 0; j < MAX_LUT_NUM; j++) {
+			INIT_LIST_HEAD(&tx_t_list->q_list[i].p_list[j].head_list);
+			spin_lock_init(&tx_t_list->q_list[i].p_list[j].p_lock);
+			atomic_set(&tx_t_list->q_list[i].p_list[j].l_num, 0);
+		}
+	}
+#if 0
+	if (tx_t_list->dscp2up_table == NULL) {
+		tx_t_list->dscp2up_table = kzalloc(DSCP_MAX_VALUE, GFP_KERNEL);
+		if (tx_t_list->dscp2up_table == NULL)
+			wl_err("%s malloc dscp2up_table fail\n", __func__);
+		else
+			memcpy(tx_t_list->dscp2up_table, default_dscp2priomap,
+			       DSCP_MAX_VALUE);
+	}
+#endif
+}
+#if 0
+void qos_deinit(struct tx_t *qos)
+{
+	if (qos->dscp2up_table != NULL) {
+		kfree(qos->dscp2up_table);
+		qos->dscp2up_table = NULL;
+	}
+}
+
+struct qos_capab_info *qos_parse_capab_info(void *buf, int buflen, uint key)
+{
+	struct qos_capab_info *capab_info;
+	int totlen;
+
+	capab_info = (struct qos_capab_info *)buf;
+	if (capab_info == NULL)
+		return NULL;
+
+	totlen = buflen;
+
+	/* find tagged parameter */
+	while (totlen >= TLV_HDR_LEN) {
+		int len = capab_info->len;
+
+		/* validate remaining totlen */
+		if ((capab_info->id == key) &&
+		   (totlen >= (int)(len + TLV_HDR_LEN)))
+			return capab_info;
+
+		capab_info = (struct qos_capab_info *)
+			((u8 *)capab_info + (len + TLV_HDR_LEN));
+		totlen -= (len + TLV_HDR_LEN);
+	}
+
+	return NULL;
+}
+#endif
+unsigned int qos_match_q(void *skb, int data_offset)
+{
+	int priority;
+	struct ether_header *eh;
+	qos_head_type_t data_type = SPRDWL_AC_BE;
+	unsigned char tos = 0;
+
+	if (0 == g_qos_enable)
+		return SPRDWL_AC_BE;
+	/* vo vi bk be*/
+	eh =
+	(struct ether_header *)(((struct sk_buff *)(skb))->data + data_offset);
+
+	if (cpu_to_be16(ETHER_TYPE_IP) != eh->ether_type &&
+	   cpu_to_be16(ETHER_TYPE_IPV6) != eh->ether_type) {
+		goto OUT;
+	}
+	priority = pkt_get_prio(skb, data_offset, &tos);
+	switch (priority) {
+	case prio_1:
+		data_type = SPRDWL_AC_BK;
+		break;
+	case prio_4:
+		data_type = SPRDWL_AC_VI;
+		break;
+	case prio_6:
+		data_type = SPRDWL_AC_VO;
+		break;
+	default:
+		data_type = SPRDWL_AC_BE;
+		break;
+	}
+OUT:
+	/*return data_type as qos queue index*/
+	return data_type;
+}
+
+unsigned int tid_map_to_qosindex(unsigned char tid)
+{
+	qos_head_type_t qos_index = SPRDWL_AC_BE;
+
+	switch (tid) {
+	case prio_1:
+		qos_index = SPRDWL_AC_BK;
+		break;
+	case prio_4:
+		qos_index = SPRDWL_AC_VI;
+		break;
+	case prio_6:
+		qos_index = SPRDWL_AC_VO;
+		break;
+	default:
+		qos_index = SPRDWL_AC_BE;
+		break;
+	}
+	/*return data_type as qos queue index*/
+	return qos_index;
+}
+
+unsigned int get_tid_qosindex(void *skb, int data_offset, unsigned char *tid, unsigned char *tos)
+{
+	int priority;
+	struct ether_header *eh;
+
+	if (0 == g_qos_enable)
+		return SPRDWL_AC_BE;
+	/* vo vi bk be*/
+	eh =
+	(struct ether_header *)(((struct sk_buff *)(skb))->data + data_offset);
+
+	/*if (cpu_to_be16(ETHER_TYPE_IP) != eh->ether_type &&
+	   cpu_to_be16(ETHER_TYPE_IPV6) != eh->ether_type) {
+		goto OUT;
+	}*/
+	priority = pkt_get_prio(skb, data_offset, tos);
+	*tid = priority;
+
+	/*return data_type as qos queue index*/
+	return tid_map_to_qosindex(*tid);
+}
+#if 0
+void qos_wfq(struct tx_t *qos)
+{
+	int t, i, j, weight, q[4] = {0}, list_num[4] = {0, 0, 0, 0};
+
+	for (i = 0, t = 0, weight = 0; i < 4; i++) {
+		for (j = 0; j < MAX_LUT_NUM; j++)
+			list_num[i] += get_list_num(&qos->q_list[i].p_list[j].head_list);
+		if (list_num[i] > 0) {
+			q[t] = i;
+			t++;
+		}
+	}
+	if (0 == t)
+		return;
+	for (i = 0; i < t; i++)
+		weight += wfq_table[t][i];
+	for (i = 0; i < t; i++)
+		qos->going[q[i]] = wfq_table[t][i] *
+				   list_num[i] / weight;
+}
+
+void qos_fq(struct tx_t *qos)
+{
+	int i, j, t, k, q[4] = {0}, list_num[4] = {0, 0, 0, 0};
+
+	for (i = 0, t = 0; i < 4; i++) {
+		for (j = 0; j < MAX_LUT_NUM; j++)
+			list_num[i] += get_list_num(&qos->q_list[i].p_list[j].head_list);
+		if (list_num[i] > 0) {
+			q[t] = i;
+			t++;
+		}
+	}
+	if (0 == t)
+		return;
+	/* vi & bk*/
+	if ((2 == t) && (1 == q[0]) && (2 == q[1])) {
+		qos->going[SPRDWL_AC_VI] = fd_special_table[0][0];
+		qos->going[SPRDWL_AC_BE] = fd_special_table[0][1];
+
+		if (list_num[SPRDWL_AC_VI] < qos->going[1])
+			qos->going[SPRDWL_AC_VI] =
+				list_num[SPRDWL_AC_VI];
+		if (list_num[SPRDWL_AC_BE] < qos->going[2])
+			qos->going[SPRDWL_AC_BE] =
+				list_num[SPRDWL_AC_BE];
+		return;
+	}
+	/*bk & be*/
+	if ((2 == t) && (2 == q[0]) && (3 == q[1])) {
+		qos->going[2] = fd_special_table[1][0];
+		qos->going[3] = fd_special_table[1][1];
+
+		if (list_num[SPRDWL_AC_BE] < qos->going[2])
+			qos->going[SPRDWL_AC_BE] =
+				list_num[SPRDWL_AC_BE];
+		if (list_num[SPRDWL_AC_BK] < qos->going[3])
+			qos->going[SPRDWL_AC_BK] =
+				list_num[SPRDWL_AC_BK];
+		return;
+	}
+
+	for (i = 0; i < t; i++) {
+		k = 0;
+		qos->going[q[i]] = fq_table[t][i];
+		if (list_num[q[i]]  < qos->going[q[i]]) {
+			k = list_num[q[i]];
+			qos->going[q[i]] = k;
+		}
+	}
+}
+
+/*get time slot ratio between higher priority stream and lower*/
+int qos_fq_ratio(struct tx_t *qos)
+{
+	int i, j, t, q[4] = {0};
+
+	for (i = 0, t = 0; i < 4; i++) {
+		for (j = 0; j < MAX_LUT_NUM; j++) {
+			if (!list_empty(&qos->q_list[i].p_list[j].head_list)) {
+				q[t] = i;
+				t++;
+				break;
+			}
+		}
+	}
+	if (0 == t)
+		return t;
+	/*vi & vo, two streams coexist based on WFA spec*/
+	if ((2 == t) && (0 == q[0]) && (1 == q[1])) {
+		qos->ratio = fd_ratio_table[0];
+		qos->ac_index = SPRDWL_AC_VO;
+		return t;
+	}
+	/* vi & be*/
+	if ((2 == t) && (1 == q[0]) && (2 == q[1])) {
+		qos->ratio = fd_ratio_table[1];
+		qos->ac_index = SPRDWL_AC_VI;
+		return t;
+	}
+	/*be & bk*/
+	if ((2 == t) && (2 == q[0]) && (3 == q[1])) {
+		qos->ratio = fd_ratio_table[2];
+		qos->ac_index = SPRDWL_AC_BE;
+		return t;
+	}
+	/*ac_index indicate which two qos streams coexist*/
+	qos->ac_index = SPRDWL_AC_MAX;
+	qos->ratio = 0;
+	return t;
+}
+
+void qos_sched(struct tx_t *qos, struct qos_list **q, int *num)
+{
+	int round, j;
+
+	if (0 == g_qos_enable) {
+		*q = &qos->q_list[SPRDWL_AC_BE];
+		for (j = 0; j < MAX_LUT_NUM; j++)
+			*num += get_list_num(&qos->q_list[SPRDWL_AC_BE].p_list[j].head_list);
+		return;
+	}
+
+	for (round = 0;  round < 4; round++) {
+		if ((SPRDWL_AC_VO == qos->index) &&
+			(0 == qos->going[SPRDWL_AC_VO]))
+			/*qos_fq(qos);*/
+			qos_wfq(qos);
+		if (qos->going[qos->index] > 0)
+			break;
+		qos->index = INCR_RING_BUFF_INDX(qos->index, 4);
+	}
+	*q = &qos->q_list[qos->index];
+	*num = qos->going[qos->index];
+}
+#endif
+int get_list_num(struct list_head *list)
+{
+	int num = 0;
+	struct list_head *pos;
+	struct list_head *n_list;
+
+	if (list_empty(list))
+		return 0;
+	list_for_each_safe(pos, n_list, list)
+		num++;
+	return num;
+}
+
+#ifdef WMMAC_WFA_CERTIFICATION
+/*init wmmac params, include timer and ac params*/
+void wmm_ac_init(struct sprdwl_priv *priv)
+{
+	u8 ac;
+
+	for (ac = 0; ac < NUM_AC; ac++) {
+		g_wmmac_usedtime[ac] = 0;
+		g_wmmac_available[ac] = false;
+		g_wmmac_admittedtime[ac] = 0;
+	}
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 14, 0)
+	timer_setup(&priv->wmmac.wmmac_edcaf_timer, update_wmmac_edcaftime_timeout, 0);
+#else
+	setup_timer(&priv->wmmac.wmmac_edcaf_timer, update_wmmac_edcaftime_timeout,
+		    (unsigned long)priv);
+#endif
+	memset(&priv->wmmac.ac[0], 0, 4*sizeof(struct wmm_ac_params));
+}
+void reset_wmmac_parameters(struct sprdwl_priv *priv)
+{
+	u8 ac;
+
+	for (ac = 0; ac < NUM_AC; ac++) {
+		g_wmmac_usedtime[ac] = 0;
+		g_wmmac_available[ac] = false;
+		g_wmmac_admittedtime[ac] = 0;
+	}
+	if (timer_pending(&priv->wmmac.wmmac_edcaf_timer))
+		del_timer_sync(&priv->wmmac.wmmac_edcaf_timer);
+
+	memset(&priv->wmmac.ac[0], 0, 4*sizeof(struct wmm_ac_params));
+}
+
+void reset_wmmac_ts_info(void)
+{
+	u8 tsid;
+
+	for (tsid = 0; tsid < NUM_TID; tsid++)
+		remove_wmmac_ts_info(tsid);
+}
+
+unsigned int priority_map_to_qos_index(int priority)
+{
+	qos_head_type_t qos_index = SPRDWL_AC_BE;
+
+	switch (up_to_ac[priority]) {
+	case prio_1:
+		qos_index = SPRDWL_AC_BK;
+		break;
+	case prio_4:
+		qos_index = SPRDWL_AC_VI;
+		break;
+	case prio_6:
+		qos_index = SPRDWL_AC_VO;
+		break;
+	default:
+		qos_index = SPRDWL_AC_BE;
+		break;
+	}
+	/*return data_type as qos queue index*/
+	return qos_index;
+}
+
+unsigned int map_priority_to_edca_ac(int priority)
+{
+	int ac;
+
+	switch (priority) {
+	case 01:
+	case 02:
+		ac = AC_BK;
+	break;
+
+	case 04:
+	case 05:
+		ac = AC_VI;
+	break;
+
+	case 06:
+	case 07:
+		ac = AC_VO;
+	break;
+
+	case 00:
+	case 03:
+	default:
+		ac = AC_BE;
+	break;
+	}
+	/*return data_type as qos queue index*/
+	return ac;
+}
+
+unsigned int map_edca_ac_to_priority(u8 ac)
+{
+	unsigned int priority;
+
+	switch (ac) {
+	case AC_BK:
+		priority = prio_1;
+	break;
+	case AC_VI:
+		priority = prio_4;
+	break;
+	case AC_VO:
+		priority = prio_6;
+	break;
+	case AC_BE:
+	default:
+		priority = prio_0;
+	break;
+	}
+	return priority;
+}
+void update_wmmac_ts_info(u8 tsid, u8 up, u8 ac, bool status, u16 admitted_time)
+{
+	g_sta_ts_info[tsid].exist = status;
+	g_sta_ts_info[tsid].ac = ac;
+	g_sta_ts_info[tsid].up = up;
+	g_sta_ts_info[tsid].admitted_time = admitted_time;
+}
+
+u16 get_wmmac_admitted_time(u8 tsid)
+{
+	u16 value = 0;
+
+	if (g_sta_ts_info[tsid].exist == true)
+		value = g_sta_ts_info[tsid].admitted_time;
+
+	return value;
+}
+
+void remove_wmmac_ts_info(u8 tsid)
+{
+	memset(&(g_sta_ts_info[tsid]), 0, sizeof(struct wmm_ac_ts_t));
+}
+void update_admitted_time(struct sprdwl_priv *priv, u8 tsid, u16 medium_time, bool increase)
+{
+	u8 ac = g_sta_ts_info[tsid].ac;
+
+	if (true == increase) {
+		/*mediumtime is in unit of 32 us, admittedtime is in unit of us*/
+		g_wmmac_admittedtime[ac] += (medium_time<<5);
+		mod_timer(&priv->wmmac.wmmac_edcaf_timer,
+				jiffies + WMMAC_EDCA_TIMEOUT_MS * HZ / 1000);
+	} else {
+		if (g_wmmac_admittedtime[ac] > (medium_time<<5))
+			g_wmmac_admittedtime[ac] -= (medium_time<<5);
+		else {
+			g_wmmac_admittedtime[ac] = 0;
+			if (timer_pending(&priv->wmmac.wmmac_edcaf_timer))
+				del_timer_sync(&priv->wmmac.wmmac_edcaf_timer);
+		}
+	}
+
+	g_wmmac_available[ac] = (g_wmmac_usedtime[ac] < g_wmmac_admittedtime[ac]);
+}
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 14, 0)
+void update_wmmac_edcaftime_timeout(struct timer_list *t)
+{
+	struct sprdwl_priv *priv = from_timer(priv, t, wmmac.wmmac_edcaf_timer);
+#else
+void update_wmmac_edcaftime_timeout(unsigned long data)
+{
+	struct sprdwl_priv *priv = (struct sprdwl_priv *)data;
+#endif
+	/*restart edcaf timer per second*/
+	mod_timer(&priv->wmmac.wmmac_edcaf_timer, jiffies + WMMAC_EDCA_TIMEOUT_MS * HZ / 1000);
+
+	if (g_wmmac_admittedtime[AC_VO] > 0) {
+		g_wmmac_usedtime[AC_VO] = 0;
+		g_wmmac_available[AC_VO] = true;
+	}
+	if (g_wmmac_admittedtime[AC_VI] > 0) {
+		g_wmmac_usedtime[AC_VI] = 0;
+		g_wmmac_available[AC_VI] = true;
+	}
+}
+
+/*change priority according to the g_wmmac_available value */
+unsigned int change_priority_if(struct sprdwl_priv *priv, unsigned char *tid, unsigned char *tos, u16 len)
+{
+	unsigned int qos_index, ac;
+	int match_index = 0;
+	unsigned char priority = *tos;
+
+	if (1 == g_qos_enable) {
+		ac = map_priority_to_edca_ac(*tid);
+		while (ac != 0) {
+			if (!!(priv->wmmac.ac[ac].aci_aifsn & WMM_AC_ACM)) {
+				/*current ac is available, use it directly*/
+				if (true == g_wmmac_available[ac]) {
+					/* use wmmac_ratio to adjust ac used time */
+					/* it is rough calc method: (data_len * 8) * ratio / data_rate, here , use 54Mbps as common usage */
+					g_wmmac_usedtime[ac] += (len + 4) * 8 * wmmac_ratio / 10 / 54;
+					g_wmmac_available[ac] = (g_wmmac_usedtime[ac] < g_wmmac_admittedtime[ac]);
+					break;
+				}
+				if ((g_wmmac_available[ac] == false) && (g_wmmac_usedtime[ac] != 0))
+					return SPRDWL_AC_MAX;
+				/*current ac is not available, maybe usedtime > admitted time*/
+				/*downgrade to lower ac, then try again*/
+				ac--;
+			} else {
+				break;
+			}
+		}
+
+		*tid = map_edca_ac_to_priority(ac);
+	}
+
+	priority >>= 2;
+
+	for (match_index = 0; match_index < QOS_MAP_MAX_DSCP_EXCEPTION; match_index++) {
+		if (priority == g_11u_qos_map.qos_exceptions[match_index].dscp) {
+			*tid = g_11u_qos_map.qos_exceptions[match_index].up;
+			break;
+		}
+	}
+
+	if (match_index >= QOS_MAP_MAX_DSCP_EXCEPTION) {
+		for (match_index = 0; match_index < 8; match_index++) {
+			if ((priority >= g_11u_qos_map.qos_ranges[match_index].low) &&
+			   (priority <= g_11u_qos_map.qos_ranges[match_index].high)) {
+				*tid = g_11u_qos_map.qos_ranges[match_index].up;
+				break;
+			}
+		}
+	}
+	switch (*tid) {
+	case prio_1:
+		qos_index = SPRDWL_AC_BK;
+		break;
+	case prio_4:
+		qos_index = SPRDWL_AC_VI;
+		break;
+	case prio_6:
+		qos_index = SPRDWL_AC_VO;
+		break;
+	default:
+		qos_index = SPRDWL_AC_BE;
+		break;
+	}
+
+	/*return data_type as qos queue index*/
+	return qos_index;
+}
+
+const u8 *get_wmm_ie(u8 *res, u16 ie_len, u8 ie, uint oui, uint oui_type)
+{
+	const u8 *end, *pos;
+
+	pos = res;
+	end = pos + ie_len;
+	while (pos + 1 < end) {
+		if (pos + 2 + pos[1] > end)
+			break;
+		/*try to find VENDOR_SPECIFIC ie, which wmm ie located*/
+		if (pos[0] == ie) {
+			/*match the OUI_MICROSOFT 0x0050f2 ie, and WMM ie*/
+			if ((((pos[2] << 16) | (pos[3] << 8) | pos[4]) == oui) &&
+				(pos[5] == WMM_OUI_TYPE)) {
+				pos += 2;
+				return pos;
+			}
+			break;
+		}
+		pos += 2 + pos[1];
+	}
+	return NULL;
+}
+#endif
+
diff --git a/drivers/net/wireless/uwe5622/unisocwifi/qos.h b/drivers/net/wireless/uwe5622/unisocwifi/qos.h
new file mode 100644
index 000000000000..2a99178bcea4
--- /dev/null
+++ b/drivers/net/wireless/uwe5622/unisocwifi/qos.h
@@ -0,0 +1,247 @@
+#ifndef __WLAN_QOS_H__
+#define __WLAN_QOS_H__
+#include "msg.h"
+#include "cfg80211.h"
+#include "wl_core.h"
+#include <linux/skbuff.h>
+#include "sprdwl.h"
+
+typedef enum {
+	SPRDWL_AC_VO,
+	SPRDWL_AC_VI,
+	SPRDWL_AC_BE,
+	SPRDWL_AC_BK,
+	SPRDWL_AC_MAX,
+} qos_head_type_t;
+
+struct peer_list {
+	struct list_head head_list;
+	spinlock_t p_lock;/*peer list lock*/
+	atomic_t l_num;
+	/*u8 delay_flag;
+	u8 l_prio;*/
+};
+
+struct qos_list {
+	struct peer_list p_list[MAX_LUT_NUM];
+};
+
+struct tx_t {
+	int ac_index;
+	unsigned char lut_id;
+	atomic_t mode_list_num;
+	struct qos_list q_list[SPRDWL_AC_MAX];
+	/*int index;*/
+	/*int going[SPRDWL_AC_MAX];*/
+	/*high priority tx_index of two streams*/
+	/*tx ratio of two streams*/
+	/*int ratio;
+	unsigned char *dscp2up_table;*/
+};
+
+typedef enum {
+	prio_0 = 0,/* Mapped to AC_BE_Q */
+	prio_1 = 1,/* Mapped to AC_BK_Q */
+	prio_4 = 4,/* Mapped to AC_VI_Q */
+	prio_6 = 6,/* Mapped to AC_VO_Q */
+} ip_pkt_prio_t;
+
+struct qos_capab_info {
+	unsigned char id;
+	unsigned char len;
+	unsigned char qos_info[1];
+};
+
+struct dscp_range {
+	u8 low;
+	u8 high;
+};
+
+struct dscp_exception {
+	u8 dscp;
+	u8 up;
+};
+
+struct qos_map_range {
+	u8 low;
+	u8 high;
+	u8 up;
+};
+
+#define QOS_MAP_MAX_DSCP_EXCEPTION 21
+
+struct qos_map_set {
+	struct dscp_exception qos_exceptions[QOS_MAP_MAX_DSCP_EXCEPTION];
+	struct qos_map_range qos_ranges[8];
+};
+
+#ifdef WMMAC_WFA_CERTIFICATION
+#define NUM_AC 4
+#define NUM_TID 16
+#define WMMAC_EDCA_TIMEOUT_MS		1000
+
+#define WLAN_EID_VENDOR_SPECIFIC 221
+#define OUI_MICROSOFT 0x0050f2 /* Microsoft (also used in Wi-Fi specs)
+				* 00:50:F2 */
+#define WMM_OUI_TYPE 2
+#define WMM_AC_ACM 0x10
+
+
+typedef enum {
+	AC_BK = 0,
+	AC_BE = 1,
+	AC_VI = 2,
+	AC_VO = 3,
+} edca_ac_t;
+
+struct wmm_ac_ts_t {
+	bool exist;
+	u8 ac;
+	u8 up;
+	u8 direction;
+	u16 admitted_time;
+};
+#endif
+
+#define INCR_RING_BUFF_INDX(indx, max_num) \
+	((((indx) + 1) < (max_num)) ? ((indx) + 1) : (0))
+
+#define ETHER_ADDR_LEN 6
+
+struct ether_header {
+	unsigned char     ether_dhost[ETHER_ADDR_LEN];
+	unsigned char     ether_shost[ETHER_ADDR_LEN];
+	unsigned short     ether_type;
+
+} __packed;
+
+struct ethervlan_header {
+	unsigned char ether_dhost[ETHER_ADDR_LEN];
+	unsigned char     ether_shost[ETHER_ADDR_LEN];
+	/* 0x8100 */
+	unsigned short vlan_type;
+	/* priority, cfi and vid */
+	unsigned short vlan_tag;
+	unsigned short ether_type;
+};
+/* 11u QoS map set */
+#define DOT11_MNG_QOS_MAP_ID 110
+/* DSCP ranges fixed with 8 entries */
+#define QOS_MAP_FIXED_LENGTH	(8 * 2)
+/* header length */
+#define TLV_HDR_LEN 2
+
+/* user priority */
+#define VLAN_PRI_SHIFT	13
+/* 3 bits of priority */
+#define VLAN_PRI_MASK	7
+/* VLAN ethertype/Tag Protocol ID */
+#define VLAN_TPID	0x8100
+
+/* IPV4 and IPV6 common */
+#define ETHER_TYPE_IP	0x0800
+/* IPv6 */
+#define ETHER_TYPE_IPV6 0x86dd
+/* offset to version field */
+#define IP_VER_OFFSET	0x0
+/* version mask */
+#define IP_VER_MASK	0xf0
+/* version shift */
+#define IP_VER_SHIFT	4
+/* version number for IPV4 */
+#define IP_VER_4	4
+/* version number for IPV6 */
+#define IP_VER_6	6
+ /* type of service offset */
+#define IPV4_TOS_OFFSET            1
+/* DiffServ codepoint shift */
+#define IPV4_TOS_DSCP_SHIFT	2
+#define IPV4_TOS(ipv4_body)\
+	(((unsigned char *)(ipv4_body))[IPV4_TOS_OFFSET])
+/* Historical precedence shift */
+#define IPV4_TOS_PREC_SHIFT 5
+/* 802.1Q */
+#define ETHER_TYPE_8021Q 0x8100
+
+/* IPV6 field decodes */
+#define IPV6_TRAFFIC_CLASS(ipv6_body) \
+	(((((unsigned char *)(ipv6_body))[0] & 0x0f) << 4) | \
+	((((unsigned char *)(ipv6_body))[1] & 0xf0) >> 4))
+
+#define IP_VER(ip_body) \
+	((((unsigned char *)(ip_body))[IP_VER_OFFSET] & IP_VER_MASK) >> \
+	IP_VER_SHIFT)
+
+/* IPV4 TOS or IPV6 Traffic Classifier or 0 */
+#define IP_TOS46(ip_body) \
+	(IP_VER(ip_body) == IP_VER_4 ? IPV4_TOS(ip_body) : \
+	IP_VER(ip_body) == IP_VER_6 ? IPV6_TRAFFIC_CLASS(ip_body) : 0)
+
+#define PKT_SET_PRIO(skb, x) (((struct sk_buff *)(skb))->priority = (x))
+
+#define VI_TOTAL_QUOTA 1500
+#define BE_TOTAL_QUOTA 200
+#define BK_TOTAL_QUOTA 200
+
+
+static inline u8 qos_index_2_tid(unsigned int qos_index)
+{
+	unsigned char tid = 0;
+
+	switch (qos_index) {
+	case SPRDWL_AC_VO:
+		tid = 6;
+		break;
+	case SPRDWL_AC_VI:
+		tid = 4;
+		break;
+	case SPRDWL_AC_BK:
+		tid = 1;
+		break;
+	default:
+		tid = 0;
+		break;
+	}
+	return tid;
+}
+
+extern struct qos_map_set g_11u_qos_map;
+void qos_init(struct tx_t *qos);
+unsigned int qos_match_q(void *skb, int data_offset);
+void qos_enable(int flag);
+unsigned int pkt_get_prio(void *skb, int data_offset, unsigned char *tos);
+#if 0
+void qos_deinit(struct tx_t *qos);
+void qos_sched_tx_most(struct tx_t *qos, struct qos_list **data_list);
+void qos_set_dscp2up_table(unsigned char *dscp2up_table,
+			   struct qos_capab_info *qos_map_ie);
+struct qos_capab_info *qos_parse_capab_info(void *buf, int buflen, uint key);
+void qos_sched(struct tx_t *qos, struct qos_list **q, int *num);
+int qos_fq_ratio(struct tx_t *qos);
+#endif
+int get_list_num(struct list_head *list);
+unsigned int tid_map_to_qosindex(unsigned char tid);
+unsigned int get_tid_qosindex(void *skb, int data_offset, unsigned char *tid, unsigned char *tos);
+#ifdef WMMAC_WFA_CERTIFICATION
+void init_default_qos_map(void);
+void wmm_ac_init(struct sprdwl_priv *priv);
+void reset_wmmac_parameters(struct sprdwl_priv *priv);
+void reset_wmmac_ts_info(void);
+unsigned int map_edca_ac_to_priority(u8 ac);
+unsigned int map_priority_to_edca_ac(int priority);
+void update_wmmac_ts_info(u8 tsid, u8 up, u8 ac, bool status, u16 admitted_time);
+void remove_wmmac_ts_info(u8 tsid);
+void update_admitted_time(struct sprdwl_priv *priv, u8 tsid, u16 medium_time, bool increase);
+u16 get_wmmac_admitted_time(u8 tsid);
+void reset_wmmac_parameters(struct sprdwl_priv *priv);
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 14, 0)
+void update_wmmac_edcaftime_timeout(struct timer_list *t);
+#else
+void update_wmmac_edcaftime_timeout(unsigned long data);
+#endif
+void update_wmmac_vo_timeout(unsigned long data);
+void update_wmmac_vi_timeout(unsigned long data);
+unsigned int change_priority_if(struct sprdwl_priv *priv, unsigned char *tid, unsigned char *tos, u16 len);
+const u8 *get_wmm_ie(u8 *res, u16 ie_len, u8 ie, uint oui, uint oui_type);
+#endif
+#endif
diff --git a/drivers/net/wireless/uwe5622/unisocwifi/reg_domain.c b/drivers/net/wireless/uwe5622/unisocwifi/reg_domain.c
new file mode 100644
index 000000000000..5a9857757f53
--- /dev/null
+++ b/drivers/net/wireless/uwe5622/unisocwifi/reg_domain.c
@@ -0,0 +1,342 @@
+#include "reg_domain.h"
+#include "sprdwl.h"
+#include "wl_intf.h"
+
+static const struct ieee80211_regdomain world_regdom = {
+	.n_reg_rules = 7,
+	.alpha2 =  "00",
+	.reg_rules = {
+		/* IEEE 802.11b/g, channels 1..11 */
+		REG_RULE(2412-10, 2462+10, 40, 6, 20, 0),
+		/* IEEE 802.11b/g, channels 12..13. */
+		REG_RULE(2467-10, 2472+10, 40, 6, 20, NL80211_RRF_AUTO_BW),
+		/* IEEE 802.11 channel 14 - Only JP enables
+		 * this and for 802.11b only */
+		REG_RULE(2484-10, 2484+10, 20, 6, 20,
+			NL80211_RRF_NO_OFDM),
+		/* IEEE 802.11a, channel 36..48 */
+		REG_RULE(5180-10, 5240+10, 160, 6, 20,
+			NL80211_RRF_AUTO_BW),
+
+		/* IEEE 802.11a, channel 52..64 - DFS required */
+		REG_RULE(5260-10, 5320+10, 160, 6, 20,
+			NL80211_RRF_DFS |
+			NL80211_RRF_AUTO_BW),
+
+		/* IEEE 802.11a, channel 100..144 - DFS required */
+		REG_RULE(5500-10, 5720+10, 160, 6, 20,
+			NL80211_RRF_DFS),
+
+		/* IEEE 802.11a, channel 149..165 */
+		REG_RULE(5745-10, 5825+10, 80, 6, 20, 0),
+	}
+};
+
+const struct ieee80211_regdomain regdom_cn = {
+	.n_reg_rules = 4,
+	.alpha2 = "CN",
+	.reg_rules = {
+	/* IEEE 802.11b/g, channels 1..13 */
+	REG_RULE(2412-10, 2472+10, 40, 6, 20, 0),
+	/* IEEE 802.11a, channel 36..48 */
+	REG_RULE(5180-10, 5240+10, 160, 6, 20,
+			NL80211_RRF_AUTO_BW),
+	/* IEEE 802.11a, channel 52..64 - DFS required */
+	REG_RULE(5260-10, 5320+10, 160, 6, 20,
+			NL80211_RRF_DFS |
+			NL80211_RRF_AUTO_BW),
+	/* channels 149..165 */
+	REG_RULE(5745-10, 5825+10, 80, 6, 20, 0),
+	}
+};
+
+const struct ieee80211_regdomain regdom_us01 = {
+	.n_reg_rules = 6,
+	.reg_rules = {
+	/* channels 1..11 */
+	SPRD_REG_RULE(2412-10, 2462+10, 40, 0),
+	/* channels 36..48 */
+	SPRD_REG_RULE(5180-10, 5240+10, 40, 0),
+	/* channels 56..64 */
+	SPRD_REG_RULE(5260-10, 5320+10, 40, NL80211_RRF_DFS),
+	/* channels 100..118 */
+	SPRD_REG_RULE(5500-10, 5590+10, 40, NL80211_RRF_DFS),
+	/* channels 132..140 */
+	SPRD_REG_RULE(5660-10, 5700+10, 40, NL80211_RRF_DFS),
+	/* channels 149..165 */
+	SPRD_REG_RULE(5745-10, 5825+10, 40, 0) }
+};
+
+const struct ieee80211_regdomain regdom_us = {
+	.n_reg_rules = 5,
+	.dfs_region = NL80211_DFS_FCC,
+	.reg_rules = {
+	/* channels 1..11 */
+	SPRD_REG_RULE(2412-10, 2462+10, 40, 0),
+	/* channels 36..48 */
+	SPRD_REG_RULE(5180-10, 5240+10, 80, NL80211_RRF_AUTO_BW),
+	/* channels 52..64 */
+	SPRD_REG_RULE(5260-10, 5320+10, 80, NL80211_RRF_DFS | NL80211_RRF_AUTO_BW),
+	/* channels 100..140 */
+	SPRD_REG_RULE(5500-10, 5720+10, 160, NL80211_RRF_DFS),
+	/* channels 149..165 */
+	SPRD_REG_RULE(5745-10, 5825+10, 80, 0) }
+};
+
+
+
+const struct ieee80211_regdomain regdom_cz_nl = {
+	.n_reg_rules = 5,
+	.reg_rules = {
+	/* channels 1..11 */
+	SPRD_REG_RULE(2412-10, 2462+10, 40, 0),
+	/* channels 12,13 */
+	SPRD_REG_RULE(2467-10, 2472+10, 40, 0),
+	/* channels 36..48 */
+	SPRD_REG_RULE(5180-10, 5240+10, 80, 0),
+	/* channels 52..64 */
+	SPRD_REG_RULE(5260-10, 5320+10, 80, NL80211_RRF_DFS),
+	/* channels 100..140 */
+	SPRD_REG_RULE(5500-10, 5700+10, 160, NL80211_RRF_DFS) }
+};
+
+const struct ieee80211_regdomain regdom_jp = {
+	.n_reg_rules = 7,
+	.dfs_region = NL80211_DFS_JP,
+	.reg_rules = {
+	/* channels 1..13 */
+	SPRD_REG_RULE(2412-10, 2472+10, 40, 0),
+	/* channels 14 */
+	SPRD_REG_RULE(2484-10, 2484+10, 20, NL80211_RRF_NO_OFDM),
+	/* channels 184..196 */
+	SPRD_REG_RULE(4920-10, 4980+10, 40, 0),
+	/* channels 8..16 */
+	SPRD_REG_RULE(5040-10, 5080+10, 40, 0),
+	/* channels 36..48 */
+	SPRD_REG_RULE(5180-10, 5240+10, 80, NL80211_RRF_AUTO_BW),
+	/* channels 52..64 */
+	SPRD_REG_RULE(5260-10, 5320+10, 80, NL80211_RRF_DFS | NL80211_RRF_AUTO_BW),
+	/* channels 100..140 */
+	SPRD_REG_RULE(5500-10, 5700+10, 160, NL80211_RRF_DFS) }
+};
+
+const struct ieee80211_regdomain regdom_tr = {
+	.n_reg_rules = 4,
+	.dfs_region = NL80211_DFS_ETSI,
+	.reg_rules = {
+	/* channels 1..13 */
+	SPRD_REG_RULE(2412-10, 2472+10, 40, 0),
+	/* channels 36..48 */
+	SPRD_REG_RULE(5180-10, 5240+10, 80, NL80211_RRF_AUTO_BW),
+	/* channels 52..64 */
+	SPRD_REG_RULE(5260-10, 5320+10, 80, NL80211_RRF_DFS | NL80211_RRF_AUTO_BW),
+	/* channels 100..140 */
+	SPRD_REG_RULE(5500-10, 5700+10, 160, NL80211_RRF_DFS) }
+};
+
+const struct sprd_regdomain sprd_regdom_00 = {
+	.country_code = "00",
+	.prRegdRules = &world_regdom
+};
+
+const struct sprd_regdomain sprd_regdom_us01 = {
+	.country_code = "US01",
+	.prRegdRules = &regdom_us01
+};
+
+const struct sprd_regdomain sprd_regdom_us = {
+	.country_code = "US",
+	.prRegdRules = &regdom_us
+};
+
+const struct sprd_regdomain sprd_regdom_cn = {
+	.country_code = "CN",
+	.prRegdRules = &regdom_cn
+};
+
+const struct sprd_regdomain sprd_regdom_nl = {
+	.country_code = "NL",
+	.prRegdRules = &regdom_cz_nl
+};
+
+const struct sprd_regdomain sprd_regdom_cz = {
+	.country_code = "CZ",
+	.prRegdRules = &regdom_cz_nl
+};
+
+const struct sprd_regdomain sprd_regdom_jp = {
+	.country_code = "JP",
+	.prRegdRules = &regdom_jp
+};
+
+const struct sprd_regdomain sprd_regdom_tr = {
+	.country_code = "TR",
+	.prRegdRules = &regdom_tr
+};
+
+const struct sprd_regdomain *g_prRegRuleTable[] = {
+	&sprd_regdom_00,
+	/*&sprd_regdom_us01,*/
+	&sprd_regdom_us,
+	&sprd_regdom_cn,
+	&sprd_regdom_nl,
+	&sprd_regdom_cz,
+	&sprd_regdom_jp,
+	&sprd_regdom_tr,
+	NULL /* this NULL SHOULD be at the end of the array */
+};
+
+const struct ieee80211_regdomain *getRegdomainFromSprdDB(char *alpha2)
+{
+	u8 idx;
+	const struct sprd_regdomain *prRegd;
+
+	idx = 0;
+	while (g_prRegRuleTable[idx]) {
+		prRegd = g_prRegRuleTable[idx];
+
+		if ((prRegd->country_code[0] == alpha2[0]) &&
+			(prRegd->country_code[1] == alpha2[1])/* &&
+			(prRegd->country_code[2] == alpha2[2]) &&
+			(prRegd->country_code[3] == alpha2[3])*/)
+			return prRegd->prRegdRules;
+
+		idx++;
+	}
+
+	wl_info("%s(): Error, wrong country = %s\n",
+			__func__, alpha2);
+	wl_info("Set as default 00\n");
+
+	return &world_regdom; /*default world wide*/
+}
+
+void
+apply_custom_regulatory(struct wiphy *pWiphy,
+							const struct ieee80211_regdomain *pRegdom)
+{
+	u32 band_idx, ch_idx;
+	struct ieee80211_supported_band *sband;
+	struct ieee80211_channel *chan;
+
+	for (band_idx = 0; band_idx < 2; band_idx++) {
+		sband = pWiphy->bands[band_idx];
+		if (!sband)
+			continue;
+
+		for (ch_idx = 0; ch_idx < sband->n_channels; ch_idx++) {
+			chan = &sband->channels[ch_idx];
+
+			chan->flags = 0;
+		}
+	}
+
+	/* update to kernel */
+	wiphy_apply_custom_regulatory(pWiphy, pRegdom);
+}
+
+void ShowChannel(struct wiphy *pWiphy)
+{
+	u32 band_idx, ch_idx;
+	u32 ch_count;
+	struct ieee80211_supported_band *sband;
+	struct ieee80211_channel *chan;
+
+	ch_count = 0;
+	for (band_idx = 0; band_idx < 2; band_idx++) {
+		sband = pWiphy->bands[band_idx];
+		if (!sband)
+			continue;
+
+		for (ch_idx = 0; ch_idx < sband->n_channels; ch_idx++) {
+			chan = &sband->channels[ch_idx];
+
+			if (chan->flags & IEEE80211_CHAN_DISABLED) {
+				wl_info("disable channels[%d][%d]: ch%d (freq = %d) flags=0x%x\n",
+				    band_idx, ch_idx, chan->hw_value, chan->center_freq, chan->flags);
+				continue;
+			}
+
+			/* Allowable channel */
+			if (ch_count == TOTAL_2G_5G_CHANNEL_NUM) {
+				wl_info("%s(): no buffer to store channel information.\n", __func__);
+				break;
+			}
+
+			wl_info("channels[%d][%d]: ch%d (freq = %d) flgs=0x%x\n",
+				band_idx, ch_idx, chan->hw_value, chan->center_freq, chan->flags);
+
+			ch_count++;
+		}
+	}
+}
+
+static bool freq_in_rule_band(const struct ieee80211_freq_range *freq_range,
+			      u32 freq_khz)
+{
+#define ONE_GHZ_IN_KHZ	1000000
+	/*
+	 * From 802.11ad: directional multi-gigabit (DMG):
+	 * Pertaining to operation in a frequency band containing a channel
+	 * with the Channel starting frequency above 45 GHz.
+	 */
+	u32 limit = freq_khz > 45 * ONE_GHZ_IN_KHZ ?
+			10 * ONE_GHZ_IN_KHZ : 2 * ONE_GHZ_IN_KHZ;
+	if (abs(freq_khz - freq_range->start_freq_khz) <= limit)
+		return true;
+	if (abs(freq_khz - freq_range->end_freq_khz) <= limit)
+		return true;
+	return false;
+#undef ONE_GHZ_IN_KHZ
+}
+static bool reg_does_bw_fit(const struct ieee80211_freq_range *freq_range,
+			    u32 center_freq_khz, u32 bw_khz)
+{
+	u32 start_freq_khz, end_freq_khz;
+
+	start_freq_khz = center_freq_khz - (bw_khz/2);
+	end_freq_khz = center_freq_khz + (bw_khz/2);
+
+	if (start_freq_khz >= freq_range->start_freq_khz &&
+	    end_freq_khz <= freq_range->end_freq_khz)
+		return true;
+
+	return false;
+}
+const struct ieee80211_reg_rule *
+sprd_freq_reg_info_regd(u32 center_freq,
+		   const struct ieee80211_regdomain *regd)
+{
+	int i;
+	bool band_rule_found = false;
+	bool bw_fits = false;
+
+	if (!regd)
+		return ERR_PTR(-EINVAL);
+
+	for (i = 0; i < regd->n_reg_rules; i++) {
+		const struct ieee80211_reg_rule *rr;
+		const struct ieee80211_freq_range *fr = NULL;
+
+		rr = &regd->reg_rules[i];
+		fr = &rr->freq_range;
+
+		/*
+		 * We only need to know if one frequency rule was
+		 * was in center_freq's band, that's enough, so lets
+		 * not overwrite it once found
+		 */
+		if (!band_rule_found)
+			band_rule_found = freq_in_rule_band(fr, center_freq);
+
+		bw_fits = reg_does_bw_fit(fr, center_freq, MHZ_TO_KHZ(20));
+
+		if (band_rule_found && bw_fits)
+			return rr;
+	}
+
+	if (!band_rule_found)
+		return ERR_PTR(-ERANGE);
+
+	return ERR_PTR(-EINVAL);
+}
diff --git a/drivers/net/wireless/uwe5622/unisocwifi/reg_domain.h b/drivers/net/wireless/uwe5622/unisocwifi/reg_domain.h
new file mode 100644
index 000000000000..fdabd9d74de4
--- /dev/null
+++ b/drivers/net/wireless/uwe5622/unisocwifi/reg_domain.h
@@ -0,0 +1,27 @@
+#ifndef __REG_DOMAIN_H__
+#define __REG_DOMAIN_H__
+#include <linux/types.h>
+#include "wl_core.h"
+#include "msg.h"
+#include "cfg80211.h"
+#include "wl_intf.h"
+#include <linux/version.h>
+
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(3, 18, 0))
+#define NL80211_RRF_AUTO_BW 0
+#endif
+
+#define SPRD_REG_RULE(start, end, bw, reg_flags) REG_RULE(start, end, bw, 0, 0, reg_flags)
+struct sprd_regdomain {
+	char country_code[4];
+	const struct ieee80211_regdomain *prRegdRules;
+};
+
+const struct ieee80211_regdomain *getRegdomainFromSprdDB(char *alpha2);
+void apply_custom_regulatory(struct wiphy *pWiphy,
+							const struct ieee80211_regdomain *pRegdom);
+void ShowChannel(struct wiphy *pWiphy);
+const struct ieee80211_reg_rule *
+sprd_freq_reg_info_regd(u32 center_freq,
+		   const struct ieee80211_regdomain *regd);
+#endif
diff --git a/drivers/net/wireless/uwe5622/unisocwifi/reorder.c b/drivers/net/wireless/uwe5622/unisocwifi/reorder.c
new file mode 100644
index 000000000000..7887476e6aad
--- /dev/null
+++ b/drivers/net/wireless/uwe5622/unisocwifi/reorder.c
@@ -0,0 +1,996 @@
+/*
+ * Copyright (C) 2016 Spreadtrum Communications Inc.
+ *
+ * Authors	:
+ * star.liu <star.liu@spreadtrum.com>
+ * yifei.li <yifei.li@spreadtrum.com>
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include "reorder.h"
+#include "rx_msg.h"
+#include "work.h"
+#include "cmdevt.h"
+#include "wl_intf.h"
+#include "qos.h"
+#include "debug.h"
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 14, 0)
+static void ba_reorder_timeout(struct timer_list *t);
+#else
+static void ba_reorder_timeout(unsigned long data);
+#endif
+
+static inline unsigned int get_index_size(unsigned int size)
+{
+	unsigned int index_size = MIN_INDEX_SIZE;
+
+	while (size > index_size)
+		index_size = (index_size << 1);
+
+	wl_info("%s: rx ba index size: %d\n", __func__, index_size);
+
+	return index_size;
+}
+
+static inline void
+set_ba_node_desc(struct rx_ba_node_desc *ba_node_desc,
+		 unsigned short win_start, unsigned short win_size,
+		 unsigned int index_mask)
+{
+	ba_node_desc->win_size = win_size;
+	ba_node_desc->win_start = win_start;
+	ba_node_desc->win_limit = SEQNO_ADD(ba_node_desc->win_start,
+					    (ba_node_desc->win_size - 1));
+	ba_node_desc->win_tail = SEQNO_SUB(ba_node_desc->win_start, 1);
+	ba_node_desc->index_mask = index_mask;
+	ba_node_desc->buff_cnt = 0;
+
+	wl_info("%s:(win_start:%d, win_size:%d, win_tail:%d, index_mask:%d)\n",
+		__func__, ba_node_desc->win_start, ba_node_desc->win_size,
+		ba_node_desc->win_tail, ba_node_desc->index_mask);
+}
+
+static inline void set_ba_pkt_desc(struct rx_ba_pkt_desc *ba_pkt_desc,
+				   struct rx_msdu_desc *msdu_desc)
+{
+	ba_pkt_desc->seq = msdu_desc->seq_num;
+	ba_pkt_desc->pn_l = msdu_desc->pn_l;
+	ba_pkt_desc->pn_h = msdu_desc->pn_h;
+	ba_pkt_desc->cipher_type = msdu_desc->cipher_type;
+}
+
+static inline void
+reorder_set_skb_list(struct sprdwl_rx_ba_entry *ba_entry,
+		     struct sk_buff *skb_head, struct sk_buff *skb_last)
+{
+	spin_lock_bh(&ba_entry->skb_list_lock);
+	if (!ba_entry->skb_head) {
+		ba_entry->skb_head = skb_head;
+		ba_entry->skb_last = skb_last;
+	} else {
+		ba_entry->skb_last->next = skb_head;
+		ba_entry->skb_last = skb_last;
+	}
+	ba_entry->skb_last->next = NULL;
+	spin_unlock_bh(&ba_entry->skb_list_lock);
+}
+
+#ifdef SPLIT_STACK
+struct sk_buff *reorder_get_skb_list(struct sprdwl_rx_ba_entry *ba_entry)
+#else
+static inline struct sk_buff
+*reorder_get_skb_list(struct sprdwl_rx_ba_entry *ba_entry)
+#endif
+{
+	struct sk_buff *skb = NULL;
+
+	spin_lock_bh(&ba_entry->skb_list_lock);
+	skb = ba_entry->skb_head;
+	ba_entry->skb_head = NULL;
+	ba_entry->skb_last = NULL;
+	spin_unlock_bh(&ba_entry->skb_list_lock);
+
+	return skb;
+}
+
+static inline void mod_reorder_timer(struct rx_ba_node *ba_node)
+{
+	if (ba_node->rx_ba->buff_cnt) {
+		mod_timer(&ba_node->reorder_timer,
+			  jiffies + RX_BA_LOSS_RECOVERY_TIMEOUT);
+	} else {
+		del_timer(&ba_node->reorder_timer);
+		ba_node->timeout_cnt = 0;
+	}
+}
+
+static inline bool is_same_pn(struct rx_ba_pkt_desc *ba_pkt_desc,
+			      struct rx_msdu_desc *msdu_desc)
+{
+	bool ret = true;
+	unsigned char cipher_type = 0;
+
+	cipher_type = ba_pkt_desc->cipher_type;
+	if ((cipher_type == SPRDWL_HW_TKIP) ||
+	    (cipher_type == SPRDWL_HW_CCMP)) {
+		if ((ba_pkt_desc->pn_l != msdu_desc->pn_l) ||
+		    (ba_pkt_desc->pn_h != msdu_desc->pn_h))
+			ret = false;
+	}
+
+	return ret;
+}
+
+static inline bool replay_detection(struct rx_ba_pkt_desc *ba_pkt_desc,
+				    struct rx_ba_node_desc *ba_node_desc)
+{
+	bool ret = true;
+	unsigned int old_val_low = 0;
+	unsigned int old_val_high = 0;
+	unsigned int rx_val_low = 0;
+	unsigned int rx_val_high = 0;
+	unsigned char cipher_type = 0;
+
+	/* FIXME: Need to check sta entry instead of check cipher_type param */
+	cipher_type = ba_pkt_desc->cipher_type;
+
+	/* FIXME: Maybe other cipher type need to do replay detection
+	 *	  HW do not support other cipher type now
+	 */
+	if ((cipher_type == SPRDWL_HW_TKIP) ||
+	    (cipher_type == SPRDWL_HW_CCMP)) {
+		old_val_low = ba_node_desc->pn_l;
+		old_val_high = ba_node_desc->pn_h;
+		rx_val_low = ba_pkt_desc->pn_l;
+		rx_val_high = ba_pkt_desc->pn_h;
+
+		if ((1 == ba_node_desc->reset_pn) &&
+			(old_val_low >= rx_val_low) && (old_val_high >= rx_val_high)) {
+			wl_err("%s: clear reset_pn,old_val_low: %d, old_val_high: %d, rx_val_low: %d, rx_val_high: %d\n",
+			       __func__, old_val_low, old_val_high, rx_val_low, rx_val_high);
+			ba_node_desc->reset_pn = 0;
+			ba_node_desc->pn_l = rx_val_low;
+			ba_node_desc->pn_h = rx_val_high;
+		} else if (((old_val_high == rx_val_high) &&
+		     (old_val_low < rx_val_low)) ||
+		    (old_val_high < rx_val_high)) {
+			ba_node_desc->pn_l = rx_val_low;
+			ba_node_desc->pn_h = rx_val_high;
+		} else {
+			ret = false;
+			wl_err("%s: old_val_low: %d, old_val_high: %d\n",
+				__func__, old_val_low, old_val_high);
+			wl_err("%s: rx_val_low: %d, rx_val_high: %d\n",
+				__func__, rx_val_low, rx_val_high);
+		}
+	}
+
+	return ret;
+}
+
+static inline void send_order_msdu(struct sprdwl_rx_ba_entry *ba_entry,
+				   struct rx_msdu_desc *msdu_desc,
+				   struct sk_buff *skb,
+				   struct rx_ba_node_desc *ba_node_desc)
+{
+	struct rx_ba_pkt_desc ba_pkt_desc;
+
+	set_ba_pkt_desc(&ba_pkt_desc, msdu_desc);
+	ba_node_desc->win_start = SEQNO_ADD(ba_node_desc->win_start, 1);
+	ba_node_desc->win_limit = SEQNO_ADD(ba_node_desc->win_limit, 1);
+	ba_node_desc->win_tail = SEQNO_SUB(ba_node_desc->win_start, 1);
+
+	wl_debug("%s: seq: %d\n", __func__, ba_pkt_desc.seq);
+	wl_debug("%s: win_start: %d, win_tail: %d, buff_cnt: %d\n",
+		 __func__, ba_node_desc->win_start,
+		 ba_node_desc->win_tail, ba_node_desc->buff_cnt);
+
+	if (skb) {
+		if (replay_detection(&ba_pkt_desc, ba_node_desc))
+			reorder_set_skb_list(ba_entry, skb, skb);
+		else
+			dev_kfree_skb(skb);
+	}
+}
+
+static inline void
+send_reorder_skb(struct sprdwl_rx_ba_entry *ba_entry,
+		 struct rx_ba_node_desc *ba_node_desc, struct rx_ba_pkt *pkt)
+{
+	wl_debug("%s: seq: %d, msdu num: %d\n", __func__,
+		 pkt->desc.seq, pkt->desc.msdu_num);
+
+	if (pkt->skb && pkt->skb_last) {
+		if (replay_detection(&pkt->desc, ba_node_desc))
+			reorder_set_skb_list(ba_entry, pkt->skb, pkt->skb_last);
+		else
+			kfree_skb_list(pkt->skb);
+	}
+
+	memset(pkt, 0, sizeof(struct rx_ba_pkt));
+}
+
+static inline void flush_reorder_buffer(struct rx_ba_node_desc *ba_node_desc)
+{
+	int i = 0;
+	struct rx_ba_pkt *pkt = NULL;
+
+	for (i = 0; i < (ba_node_desc->index_mask + 1); i++) {
+		pkt = &ba_node_desc->reorder_buffer[i];
+		kfree_skb_list(pkt->skb);
+		memset(pkt, 0, sizeof(struct rx_ba_pkt));
+	}
+
+	ba_node_desc->buff_cnt = 0;
+}
+
+static inline void joint_msdu(struct rx_ba_pkt *pkt, struct sk_buff *newsk)
+{
+	if (newsk) {
+		if (pkt->skb_last) {
+			pkt->skb_last->next = newsk;
+			pkt->skb_last = pkt->skb_last->next;
+		} else {
+			pkt->skb = newsk;
+			pkt->skb_last = pkt->skb;
+		}
+		pkt->skb_last->next = NULL;
+	}
+}
+
+static unsigned short send_msdu_in_order(struct sprdwl_rx_ba_entry *ba_entry,
+					 struct rx_ba_node_desc *ba_node_desc)
+{
+	unsigned short seq_num = ba_node_desc->win_start;
+	struct rx_ba_pkt *pkt = NULL;
+	unsigned int index = 0;
+
+	while (1) {
+		index = seq_num & ba_node_desc->index_mask;
+		pkt = &ba_node_desc->reorder_buffer[index];
+		if (!ba_node_desc->buff_cnt || !pkt->desc.last)
+			break;
+
+		send_reorder_skb(ba_entry, ba_node_desc, pkt);
+		ba_node_desc->buff_cnt--;
+		seq_num++;
+	}
+
+	seq_num &= SEQNO_MASK;
+	return seq_num;
+}
+
+static unsigned short
+send_msdu_with_gap(struct sprdwl_rx_ba_entry *ba_entry,
+		   struct rx_ba_node_desc *ba_node_desc,
+		   unsigned short last_seqno)
+{
+	unsigned short seq_num = ba_node_desc->win_start;
+	struct rx_ba_pkt *pkt = NULL;
+	unsigned short num_frms = 0;
+	unsigned short num = SEQNO_SUB(last_seqno, seq_num);
+	unsigned int index = 0;
+
+	while (num--) {
+		index = seq_num & ba_node_desc->index_mask;
+		pkt = &ba_node_desc->reorder_buffer[index];
+		if (ba_node_desc->buff_cnt && pkt->desc.msdu_num) {
+			send_reorder_skb(ba_entry, ba_node_desc, pkt);
+			num_frms++;
+			ba_node_desc->buff_cnt--;
+		}
+		seq_num++;
+	}
+
+	return num_frms;
+}
+
+static inline void between_seqlo_seqhi(struct sprdwl_rx_ba_entry *ba_entry,
+				       struct rx_ba_node_desc *ba_node_desc)
+{
+	ba_node_desc->win_start = send_msdu_in_order(ba_entry, ba_node_desc);
+	ba_node_desc->win_limit = SEQNO_ADD(ba_node_desc->win_start,
+					    (ba_node_desc->win_size - 1));
+}
+
+static inline void
+greater_than_seqhi(struct sprdwl_rx_ba_entry *ba_entry,
+		   struct rx_ba_node_desc *ba_node_desc, unsigned short seq_num)
+{
+	unsigned short pos_win_end;
+	unsigned short pos_win_start;
+
+	pos_win_end = seq_num;
+	pos_win_start = SEQNO_SUB(pos_win_end, (ba_node_desc->win_size - 1));
+	send_msdu_with_gap(ba_entry, ba_node_desc, pos_win_start);
+	ba_node_desc->win_start = pos_win_start;
+	ba_node_desc->win_start = send_msdu_in_order(ba_entry, ba_node_desc);
+	ba_node_desc->win_limit = SEQNO_ADD(ba_node_desc->win_start,
+					    (ba_node_desc->win_size - 1));
+}
+
+static inline void bar_send_ba_buffer(struct sprdwl_rx_ba_entry *ba_entry,
+				      struct rx_ba_node_desc *ba_node_desc,
+				      unsigned short seq_num)
+{
+	if (!seqno_leq(seq_num, ba_node_desc->win_start)) {
+		send_msdu_with_gap(ba_entry, ba_node_desc, seq_num);
+		ba_node_desc->win_start = seq_num;
+		ba_node_desc->win_start =
+				send_msdu_in_order(ba_entry, ba_node_desc);
+		ba_node_desc->win_limit =
+				SEQNO_ADD(ba_node_desc->win_start,
+					  (ba_node_desc->win_size - 1));
+	}
+}
+
+static inline int
+insert_msdu(struct rx_msdu_desc *msdu_desc, struct sk_buff *skb,
+	    struct rx_ba_node_desc *ba_node_desc)
+{
+	int ret = 0;
+	unsigned short seq_num = msdu_desc->seq_num;
+	unsigned short index = seq_num & ba_node_desc->index_mask;
+	struct rx_ba_pkt *insert = &ba_node_desc->reorder_buffer[index];
+	bool last_msdu_flag = msdu_desc->last_msdu_of_mpdu;
+
+	wl_debug("%s: index: %d, seq: %d\n", __func__, index, insert->desc.seq);
+
+	if (insert->desc.msdu_num != 0) {
+		if ((insert->desc.seq == seq_num) && (insert->desc.last != 1) &&
+		    is_same_pn(&insert->desc, msdu_desc)) {
+			joint_msdu(insert, skb);
+			insert->desc.msdu_num++;
+			insert->desc.last = last_msdu_flag;
+		} else {
+			wl_err("%s: in_use: %d\n", __func__, insert->desc.seq);
+			ret = -EINVAL;
+		}
+	} else {
+		joint_msdu(insert, skb);
+		set_ba_pkt_desc(&insert->desc, msdu_desc);
+		insert->desc.last = last_msdu_flag;
+		insert->desc.msdu_num = 1;
+		ba_node_desc->buff_cnt++;
+	}
+
+	return ret;
+}
+
+static int reorder_msdu(struct sprdwl_rx_ba_entry *ba_entry,
+			struct rx_msdu_desc *msdu_desc, struct sk_buff *skb,
+			struct rx_ba_node *ba_node)
+{
+	int ret = -EINVAL;
+	unsigned short seq_num = msdu_desc->seq_num;
+	struct rx_ba_node_desc *ba_node_desc = ba_node->rx_ba;
+
+	if (seqno_geq(seq_num, ba_node_desc->win_start)) {
+		if (!seqno_leq(seq_num, ba_node_desc->win_limit)) {
+			/* Buffer is full, send data now */
+			greater_than_seqhi(ba_entry, ba_node_desc, seq_num);
+		}
+
+		ret = insert_msdu(msdu_desc, skb, ba_node_desc);
+		if (!ret && seqno_geq(seq_num, ba_node_desc->win_tail))
+			ba_node_desc->win_tail = seq_num;
+	} else {
+		wl_debug("%s: seq_num: %d is less than win_start: %d\n",
+		       __func__, seq_num, ba_node_desc->win_start);
+	}
+
+	if (ret && skb) {
+		wl_debug("%s: kfree skb %d", __func__, ret);
+		dev_kfree_skb(skb);
+	}
+
+	return ret;
+}
+
+static void reorder_msdu_process(struct sprdwl_rx_ba_entry *ba_entry,
+				 struct rx_msdu_desc *msdu_desc,
+				 struct sk_buff *skb,
+				 struct rx_ba_node *ba_node)
+{
+	struct rx_ba_node_desc *ba_node_desc = ba_node->rx_ba;
+	int ret = 0;
+	int seq_num = msdu_desc->seq_num;
+	bool last_msdu_flag = msdu_desc->last_msdu_of_mpdu;
+	unsigned short old_win_start = 0;
+
+	spin_lock_bh(&ba_node->ba_node_lock);
+	if (likely(ba_node->active)) {
+		wl_debug("%s: seq: %d, last_msdu_of_mpdu: %d\n",
+			 __func__, seq_num, last_msdu_flag);
+		wl_debug("%s: win_start: %d, win_tail: %d, buff_cnt: %d\n",
+			 __func__, ba_node_desc->win_start,
+			ba_node_desc->win_tail, ba_node_desc->buff_cnt);
+
+		/* FIXME: Data come in sequence in default */
+		if ((seq_num == ba_node_desc->win_start) &&
+		    !ba_node_desc->buff_cnt && last_msdu_flag) {
+			send_order_msdu(ba_entry, msdu_desc, skb, ba_node_desc);
+			goto out;
+		}
+
+		old_win_start = ba_node_desc->win_start;
+		ret = reorder_msdu(ba_entry, msdu_desc, skb, ba_node);
+		if (!ret) {
+			if (last_msdu_flag &&
+			    (seq_num == ba_node_desc->win_start)) {
+				between_seqlo_seqhi(ba_entry, ba_node_desc);
+				mod_reorder_timer(ba_node);
+			} else if (!timer_pending(&ba_node->reorder_timer) ||
+				   (old_win_start != ba_node_desc->win_start)) {
+				wl_debug("%s: start timer\n", __func__);
+				mod_reorder_timer(ba_node);
+			}
+		} else if (unlikely(!ba_node_desc->buff_cnt)) {
+			/* Should never happen */
+			del_timer(&ba_node->reorder_timer);
+			ba_node->timeout_cnt = 0;
+		}
+	} else {
+		wl_err("%s: BA SESSION IS NO ACTIVE sta_lut_index: %d, tid: %d\n",
+		       __func__, msdu_desc->sta_lut_index, msdu_desc->tid);
+		reorder_set_skb_list(ba_entry, skb, skb);
+	}
+
+out:
+	spin_unlock_bh(&ba_node->ba_node_lock);
+}
+
+static inline void init_ba_node(struct sprdwl_rx_ba_entry *ba_entry,
+				struct rx_ba_node *ba_node,
+				unsigned char sta_lut_index, unsigned char tid)
+{
+	/* Init reorder spinlock */
+	spin_lock_init(&ba_node->ba_node_lock);
+
+	ba_node->active = 0;
+	ba_node->sta_lut_index = sta_lut_index;
+	ba_node->tid = tid;
+	ba_node->ba_entry = ba_entry;
+
+	/* Init reorder timer */
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 14, 0)
+	timer_setup(&ba_node->reorder_timer, ba_reorder_timeout, 0);
+#else
+	init_timer(&ba_node->reorder_timer);
+	ba_node->reorder_timer.data = (unsigned long)ba_node;
+	ba_node->reorder_timer.function = ba_reorder_timeout;
+#endif
+}
+
+static inline bool is_same_ba(struct rx_ba_node *ba_node,
+			      unsigned char sta_lut_index, unsigned char tid)
+{
+	bool ret = false;
+
+	if (ba_node) {
+		if ((ba_node->sta_lut_index == sta_lut_index) &&
+		    (ba_node->tid == tid))
+			ret = true;
+	}
+
+	return ret;
+}
+
+static struct rx_ba_node
+*find_ba_node(struct sprdwl_rx_ba_entry *ba_entry,
+	      unsigned char sta_lut_index, unsigned char tid)
+{
+	struct rx_ba_node *ba_node = NULL;
+
+	if (tid < NUM_TIDS) {
+		if (is_same_ba(ba_entry->current_ba_node, sta_lut_index, tid)) {
+			ba_node = ba_entry->current_ba_node;
+		} else {
+			struct hlist_head *head = &ba_entry->hlist[tid];
+
+			if (!hlist_empty(head)) {
+				hlist_for_each_entry(ba_node, head, hlist) {
+					if (sta_lut_index ==
+					    ba_node->sta_lut_index) {
+						ba_entry->current_ba_node =
+							ba_node;
+						break;
+					}
+				}
+			}
+		}
+	} else {
+		wl_err("%s: TID is too large sta_lut_index: %d, tid: %d\n",
+		       __func__, sta_lut_index, tid);
+	}
+
+	return ba_node;
+}
+
+static struct rx_ba_node
+*create_ba_node(struct sprdwl_rx_ba_entry *ba_entry,
+		unsigned char sta_lut_index, unsigned char tid,
+		unsigned int size)
+{
+	struct rx_ba_node *ba_node = NULL;
+	struct hlist_head *head = &ba_entry->hlist[tid];
+	unsigned int rx_ba_size = sizeof(struct rx_ba_node_desc) +
+				(size * sizeof(struct rx_ba_pkt));
+
+	ba_node = kzalloc(sizeof(*ba_node), GFP_ATOMIC);
+	if (ba_node) {
+		ba_node->rx_ba = kzalloc(rx_ba_size, GFP_ATOMIC);
+		if (ba_node->rx_ba) {
+			init_ba_node(ba_entry, ba_node, sta_lut_index, tid);
+			INIT_HLIST_NODE(&ba_node->hlist);
+			hlist_add_head(&ba_node->hlist, head);
+			ba_entry->current_ba_node = ba_node;
+		} else {
+			kfree(ba_node);
+			ba_node = NULL;
+		}
+	}
+
+	return ba_node;
+}
+
+void reset_pn(struct sprdwl_priv *priv, const u8 *mac_addr)
+{
+	struct sprdwl_intf *intf = (struct sprdwl_intf *)(priv->hw_priv);
+	struct sprdwl_rx_if *rx_if = (struct sprdwl_rx_if *)intf->sprdwl_rx;
+	struct sprdwl_rx_ba_entry *ba_entry = &rx_if->ba_entry;
+	unsigned char i, tid, lut_id = 0xff;
+	struct rx_ba_node *ba_node = NULL;
+
+	if (!mac_addr || !priv)
+		return;
+
+	for (i = 0; i < MAX_LUT_NUM; i++) {
+		if (ether_addr_equal(intf->peer_entry[i].tx.da, mac_addr)) {
+			lut_id = intf->peer_entry[i].lut_index;
+			break;
+		}
+	}
+	if (lut_id == 0xff)
+		return;
+
+	for (tid = 0; tid < NUM_TIDS; tid++) {
+		ba_node = find_ba_node(ba_entry, lut_id, tid);
+		if (ba_node) {
+			spin_lock_bh(&ba_node->ba_node_lock);
+			ba_node->rx_ba->reset_pn = 1;
+			wl_info("%s: set,lut=%d,tid=%d,pn_l=%d,pn_h=%d\n",
+			       __func__, lut_id, tid,
+			       ba_node->rx_ba->pn_l,
+			       ba_node->rx_ba->pn_h);
+			spin_unlock_bh(&ba_node->ba_node_lock);
+		}
+	}
+}
+
+struct sk_buff *reorder_data_process(struct sprdwl_rx_ba_entry *ba_entry,
+				     struct sk_buff *pskb)
+{
+	struct rx_ba_node *ba_node = NULL;
+	struct rx_msdu_desc *msdu_desc = NULL;
+
+	if (pskb) {
+		msdu_desc = (struct rx_msdu_desc *)pskb->data;
+
+		wl_debug("%s: qos_flag: %d, ampdu_flag: %d, bc_mc_flag: %d\n",
+			 __func__, msdu_desc->qos_flag,
+			msdu_desc->ampdu_flag, msdu_desc->bc_mc_flag);
+
+		if (!msdu_desc->bc_mc_flag && msdu_desc->qos_flag) {
+			ba_node = find_ba_node(ba_entry,
+					       msdu_desc->sta_lut_index,
+					       msdu_desc->tid);
+			if (ba_node)
+				reorder_msdu_process(ba_entry, msdu_desc,
+						     pskb, ba_node);
+			else
+				reorder_set_skb_list(ba_entry, pskb, pskb);
+		} else {
+			reorder_set_skb_list(ba_entry, pskb, pskb);
+		}
+	}
+
+#ifdef SPLIT_STACK
+	return NULL;
+#else
+	return reorder_get_skb_list(ba_entry);
+#endif
+}
+
+static void wlan_filter_event(struct sprdwl_rx_ba_entry *ba_entry,
+			      struct sprdwl_event_ba *ba_event)
+{
+	struct rx_ba_node *ba_node = NULL;
+	struct rx_msdu_desc msdu_desc;
+
+	ba_node = find_ba_node(ba_entry,
+			       ba_event->sta_lut_index, ba_event->tid);
+	if (ba_node) {
+		msdu_desc.last_msdu_of_mpdu = 1;
+		msdu_desc.seq_num = ba_event->msdu_param.seq_num;
+		msdu_desc.msdu_index_of_mpdu = 0;
+		msdu_desc.pn_l = 0;
+		msdu_desc.pn_h = 0;
+		msdu_desc.cipher_type = 0;
+		reorder_msdu_process(ba_entry, &msdu_desc, NULL, ba_node);
+	}
+}
+
+static void wlan_delba_event(struct sprdwl_rx_ba_entry *ba_entry,
+			     struct sprdwl_event_ba *ba_event)
+{
+	struct rx_ba_node *ba_node = NULL;
+	struct rx_ba_node_desc *ba_node_desc = NULL;
+
+	wl_info("enter %s\n", __func__);
+	ba_node = find_ba_node(ba_entry,
+			       ba_event->sta_lut_index, ba_event->tid);
+	if (!ba_node) {
+		wl_err("%s: NOT FOUND sta_lut_index: %d, tid: %d\n",
+		       __func__, ba_event->sta_lut_index, ba_event->tid);
+		return;
+	}
+
+	del_timer_sync(&ba_node->reorder_timer);
+	spin_lock_bh(&ba_node->ba_node_lock);
+	if (ba_node->active) {
+		ba_node_desc = ba_node->rx_ba;
+		ba_node->active = 0;
+		ba_node->timeout_cnt = 0;
+		between_seqlo_seqhi(ba_entry, ba_node_desc);
+		flush_reorder_buffer(ba_node_desc);
+	}
+	hlist_del(&ba_node->hlist);
+	spin_unlock_bh(&ba_node->ba_node_lock);
+
+	kfree(ba_node->rx_ba);
+	kfree(ba_node);
+	ba_node = NULL;
+	ba_entry->current_ba_node = NULL;
+}
+
+#if 0
+static void wlan_bar_event(struct sprdwl_rx_ba_entry *ba_entry,
+			   struct sprdwl_event_ba *ba_event)
+{
+	struct rx_ba_node *ba_node = NULL;
+	struct rx_ba_node_desc *ba_node_desc = NULL;
+
+	wl_info("enter %s\n", __func__);
+	ba_node = find_ba_node(ba_entry,
+			       ba_event->sta_lut_index, ba_event->tid);
+	if (!ba_node) {
+		wl_err("%s: NOT FOUND sta_lut_index: %d, tid: %d\n",
+		       __func__, ba_event->sta_lut_index, ba_event->tid);
+		return;
+	}
+
+	spin_lock_bh(&ba_node->ba_node_lock);
+	if (ba_node->active) {
+		ba_node_desc = ba_node->rx_ba;
+		if (!seqno_leq(ba_event->win_param.win_start,
+			       ba_node_desc->win_start)) {
+			bar_send_ba_buffer(ba_entry, ba_node_desc,
+					   ba_event->win_param.win_start);
+			mod_reorder_timer(ba_node);
+		}
+
+		wl_info("%s:(active:%d, tid:%d)\n",
+			__func__, ba_node->active, ba_node->tid);
+		wl_info("%s:(win_size:%d, win_start:%d, win_tail:%d)\n",
+			__func__, ba_node_desc->win_size,
+			ba_node_desc->win_start, ba_node_desc->win_tail);
+	} else {
+		wl_err("%s: BA SESSION IS NO ACTIVE sta_lut_index: %d, tid: %d\n",
+		       __func__, ba_event->sta_lut_index, ba_event->tid);
+	}
+	spin_unlock_bh(&ba_node->ba_node_lock);
+}
+#endif
+
+static void send_addba_rsp(struct sprdwl_rx_ba_entry *ba_entry,
+			   unsigned char tid, unsigned char sta_lut_index,
+			   int status)
+{
+	struct sprdwl_cmd_ba addba_rsp;
+	struct sprdwl_intf *intf = NULL;
+	struct sprdwl_peer_entry *peer_entry = NULL;
+	struct sprdwl_rx_if *rx_if = container_of(ba_entry,
+						  struct sprdwl_rx_if,
+						  ba_entry);
+
+	intf = rx_if->intf;
+	peer_entry =
+		sprdwl_find_peer_entry_using_lut_index(intf, sta_lut_index);
+	if (peer_entry == NULL) {
+		wl_err("%s, peer not found\n", __func__);
+		return;
+	}
+
+	addba_rsp.type = SPRDWL_ADDBA_RSP_CMD;
+	addba_rsp.tid = tid;
+	ether_addr_copy(addba_rsp.da, peer_entry->tx.da);
+	addba_rsp.success = (status) ? 0 : 1;
+
+	sprdwl_rx_send_cmd(intf, (void *)(&addba_rsp), sizeof(addba_rsp),
+			   SPRDWL_WORK_BA_MGMT, peer_entry->ctx_id);
+}
+
+static void send_delba(struct sprdwl_rx_ba_entry *ba_entry,
+		       unsigned short tid, unsigned char sta_lut_index)
+{
+	struct sprdwl_cmd_ba delba;
+	struct sprdwl_intf *intf = NULL;
+	struct sprdwl_peer_entry *peer_entry = NULL;
+	struct sprdwl_rx_if *rx_if = container_of(ba_entry,
+						  struct sprdwl_rx_if,
+						  ba_entry);
+
+	intf = rx_if->intf;
+	peer_entry =
+		sprdwl_find_peer_entry_using_lut_index(intf, sta_lut_index);
+	if (peer_entry == NULL) {
+		wl_err("%s, peer not found\n", __func__);
+		return;
+	}
+
+	delba.type = SPRDWL_DELBA_CMD;
+	delba.tid = tid;
+	ether_addr_copy(delba.da, peer_entry->tx.da);
+	delba.success = 1;
+
+	sprdwl_rx_send_cmd(intf, (void *)(&delba), sizeof(delba),
+			   SPRDWL_WORK_BA_MGMT, peer_entry->ctx_id);
+}
+
+static int wlan_addba_event(struct sprdwl_rx_ba_entry *ba_entry,
+			    struct sprdwl_event_ba *ba_event)
+{
+	struct rx_ba_node *ba_node = NULL;
+	int ret = 0;
+	unsigned char sta_lut_index = ba_event->sta_lut_index;
+	unsigned char tid = ba_event->tid;
+	unsigned short win_start = ba_event->win_param.win_start;
+	unsigned short win_size = ba_event->win_param.win_size;
+	unsigned int index_size = get_index_size(2 * win_size);
+
+	wl_info("enter %s\n", __func__);
+	ba_node = find_ba_node(ba_entry, sta_lut_index, tid);
+	if (!ba_node) {
+		ba_node = create_ba_node(ba_entry, sta_lut_index,
+					 tid, index_size);
+		if (!ba_node) {
+			wl_err("%s: Create ba_entry fail\n", __func__);
+			ret = -ENOMEM;
+			goto out;
+		}
+	}
+
+	spin_lock_bh(&ba_node->ba_node_lock);
+	if (likely(!ba_node->active)) {
+		set_ba_node_desc(ba_node->rx_ba, win_start, win_size,
+				 INDEX_SIZE_MASK(index_size));
+		ba_node->active = 1;
+		wl_debug("%s:(active:%d, tid:%d)\n",
+			 __func__, ba_node->active, ba_node->tid);
+	} else {
+		/* Should never happen */
+		wl_err("%s: BA SESSION IS ACTIVE sta_lut_index: %d, tid: %d\n",
+		       __func__, sta_lut_index, tid);
+		ret = -EINVAL;
+	}
+	spin_unlock_bh(&ba_node->ba_node_lock);
+
+out:
+	return ret;
+}
+
+void wlan_ba_session_event(void *hw_intf,
+			   unsigned char *data, unsigned short len)
+{
+	struct sprdwl_intf *intf = (struct sprdwl_intf *)hw_intf;
+	struct sprdwl_rx_if *rx_if = (struct sprdwl_rx_if *)intf->sprdwl_rx;
+	struct sprdwl_rx_ba_entry *ba_entry = &rx_if->ba_entry;
+	struct sprdwl_event_ba *ba_event =
+				  (struct sprdwl_event_ba *)data;
+	unsigned char type = ba_event->type;
+	int ret = 0;
+	struct sprdwl_peer_entry *peer_entry = NULL;
+	u8 qos_index;
+
+	switch (type) {
+	case SPRDWL_ADDBA_REQ_EVENT:
+		ret = wlan_addba_event(ba_entry, ba_event);
+		send_addba_rsp(ba_entry, ba_event->tid,
+			       ba_event->sta_lut_index, ret);
+		break;
+	case SPRDWL_DELBA_EVENT:
+		wlan_delba_event(ba_entry, ba_event);
+		break;
+	case SPRDWL_BAR_EVENT:
+		/*wlan_bar_event(ba_entry, ba_event);*/
+		break;
+	case SPRDWL_FILTER_EVENT:
+		wlan_filter_event(ba_entry, ba_event);
+		break;
+	case SPRDWL_DELTXBA_EVENT:
+		peer_entry = &intf->peer_entry[ba_event->sta_lut_index];
+		qos_index = tid_map_to_qosindex(ba_event->tid);
+		peer_entry = &intf->peer_entry[ba_event->sta_lut_index];
+		if (test_and_clear_bit(ba_event->tid, &peer_entry->ba_tx_done_map))
+			wl_info("%s, %d, deltxba, lut=%d, tid=%d, map=%lu\n",
+				__func__, __LINE__,
+				ba_event->sta_lut_index,
+				ba_event->tid,
+				peer_entry->ba_tx_done_map);
+		break;
+	default:
+		wl_err("%s: Error type: %d\n", __func__, type);
+		break;
+	}
+
+	/* TODO:Should we handle skb list here? */
+}
+
+void sprdwl_reorder_init(struct sprdwl_rx_ba_entry *ba_entry)
+{
+	int i = 0;
+
+	for (i = 0; i < NUM_TIDS; i++)
+		INIT_HLIST_HEAD(&ba_entry->hlist[i]);
+
+	spin_lock_init(&ba_entry->skb_list_lock);
+}
+
+void sprdwl_reorder_deinit(struct sprdwl_rx_ba_entry *ba_entry)
+{
+	int i = 0;
+	struct rx_ba_node *ba_node = NULL;
+
+	for (i = 0; i < NUM_TIDS; i++) {
+		struct hlist_head *head = &ba_entry->hlist[i];
+		struct hlist_node *node = NULL;
+
+		if (hlist_empty(head))
+			continue;
+
+		hlist_for_each_entry_safe(ba_node, node, head, hlist) {
+			del_timer_sync(&ba_node->reorder_timer);
+			spin_lock_bh(&ba_node->ba_node_lock);
+			ba_node->active = 0;
+			flush_reorder_buffer(ba_node->rx_ba);
+			hlist_del(&ba_node->hlist);
+			spin_unlock_bh(&ba_node->ba_node_lock);
+			kfree(ba_node->rx_ba);
+			kfree(ba_node);
+			ba_node = NULL;
+		}
+	}
+}
+
+static unsigned short
+get_first_seqno_in_buff(struct rx_ba_node_desc *ba_node_desc)
+{
+	unsigned short seqno = ba_node_desc->win_start;
+	unsigned short index = 0;
+
+	while (seqno_leq(seqno, ba_node_desc->win_tail)) {
+		index = seqno & ba_node_desc->index_mask;
+		if (ba_node_desc->reorder_buffer[index].desc.last)
+			break;
+
+		seqno = SEQNO_ADD(seqno, 1);
+	}
+
+	wl_info("%s: first seqno: %d\n", __func__, seqno);
+	return seqno;
+}
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 14, 0)
+static void ba_reorder_timeout(struct timer_list *t)
+{
+	struct rx_ba_node *ba_node = from_timer(ba_node, t, reorder_timer);
+#else
+static void ba_reorder_timeout(unsigned long data)
+{
+	struct rx_ba_node *ba_node = (struct rx_ba_node *)data;
+#endif
+	struct sprdwl_rx_ba_entry *ba_entry = ba_node->ba_entry;
+	struct rx_ba_node_desc *ba_node_desc = ba_node->rx_ba;
+	struct sprdwl_rx_if *rx_if = container_of(ba_entry,
+						  struct sprdwl_rx_if,
+						  ba_entry);
+	unsigned short pos_seqno = 0;
+
+	wl_info("enter %s\n", __func__);
+	debug_cnt_inc(REORDER_TIMEOUT_CNT);
+	spin_lock_bh(&ba_node->ba_node_lock);
+	if (ba_node->active && ba_node_desc->buff_cnt &&
+	    !timer_pending(&ba_node->reorder_timer)) {
+		pos_seqno = get_first_seqno_in_buff(ba_node_desc);
+		send_msdu_with_gap(ba_entry, ba_node_desc, pos_seqno);
+		ba_node_desc->win_start = pos_seqno;
+		ba_node_desc->win_start =
+				send_msdu_in_order(ba_entry, ba_node_desc);
+		ba_node_desc->win_limit =
+				SEQNO_ADD(ba_node_desc->win_start,
+					  (ba_node_desc->win_size - 1));
+
+		ba_node->timeout_cnt++;
+		if (ba_node->timeout_cnt > MAX_TIMEOUT_CNT) {
+			ba_node->active = 0;
+			ba_node->timeout_cnt = 0;
+			wl_info("%s, %d, send_delba\n", __func__, __LINE__);
+			send_delba(ba_entry, ba_node->tid,
+				   ba_node->sta_lut_index);
+		}
+
+		mod_reorder_timer(ba_node);
+	}
+	spin_unlock_bh(&ba_node->ba_node_lock);
+
+	spin_lock_bh(&ba_entry->skb_list_lock);
+	if (ba_entry->skb_head) {
+		spin_unlock_bh(&ba_entry->skb_list_lock);
+
+#ifndef RX_NAPI
+		if (!work_pending(&rx_if->rx_work)) {
+			wl_info("%s: queue rx workqueue\n", __func__);
+			queue_work(rx_if->rx_queue, &rx_if->rx_work);
+		}
+#else
+		napi_schedule(&rx_if->napi_rx);
+#endif
+	} else {
+		spin_unlock_bh(&ba_entry->skb_list_lock);
+	}
+	wl_info("leave %s\n", __func__);
+}
+
+void peer_entry_delba(void *hw_intf, unsigned char lut_index)
+{
+	int tid = 0;
+	struct rx_ba_node *ba_node = NULL;
+	struct rx_ba_node_desc *ba_node_desc = NULL;
+	struct sprdwl_intf *intf = (struct sprdwl_intf *)hw_intf;
+	struct sprdwl_rx_if *rx_if = (struct sprdwl_rx_if *)intf->sprdwl_rx;
+	struct sprdwl_rx_ba_entry *ba_entry = &rx_if->ba_entry;
+
+	wl_info("enter %s\n", __func__);
+	for (tid = 0; tid < NUM_TIDS; tid++) {
+		ba_node = find_ba_node(ba_entry, lut_index, tid);
+		if (ba_node) {
+			wl_info("%s: del ba lut_index: %d, tid %d\n",
+				__func__, lut_index, tid);
+			del_timer_sync(&ba_node->reorder_timer);
+			spin_lock_bh(&ba_node->ba_node_lock);
+			if (ba_node->active) {
+				ba_node_desc = ba_node->rx_ba;
+				ba_node->active = 0;
+				ba_node->timeout_cnt = 0;
+				flush_reorder_buffer(ba_node_desc);
+			}
+			hlist_del(&ba_node->hlist);
+			spin_unlock_bh(&ba_node->ba_node_lock);
+
+			kfree(ba_node->rx_ba);
+			kfree(ba_node);
+			ba_node = NULL;
+			ba_entry->current_ba_node = NULL;
+		}
+	}
+}
diff --git a/drivers/net/wireless/uwe5622/unisocwifi/reorder.h b/drivers/net/wireless/uwe5622/unisocwifi/reorder.h
new file mode 100644
index 000000000000..0c8451f91a36
--- /dev/null
+++ b/drivers/net/wireless/uwe5622/unisocwifi/reorder.h
@@ -0,0 +1,76 @@
+#ifndef __SPRDWL_REORDER_H__
+#define __SPRDWL_REORDER_H__
+
+#include "sprdwl.h"
+#include <linux/timer.h>
+#include <linux/skbuff.h>
+
+#define NUM_TIDS 8
+#define RX_BA_LOSS_RECOVERY_TIMEOUT (HZ / 10)
+#define MAX_TIMEOUT_CNT 60
+#define MIN_INDEX_SIZE (1 << 6)
+#define INDEX_SIZE_MASK(index_size) (index_size - 1)
+
+struct rx_ba_pkt_desc {
+	unsigned int pn_l;
+	unsigned short pn_h;
+	unsigned short seq;
+	unsigned char cipher_type;
+	unsigned char last;
+	unsigned short msdu_num;
+};
+
+struct rx_ba_pkt {
+	struct sk_buff *skb;
+	struct sk_buff *skb_last; /* TODO: could we just search last skb? */
+	struct rx_ba_pkt_desc desc;
+};
+
+struct rx_ba_node_desc {
+	unsigned short win_start;
+	unsigned short win_limit;
+	unsigned short win_tail;
+	unsigned short win_size;
+	unsigned short buff_cnt;
+	unsigned short pn_h;
+	unsigned int pn_l;
+	unsigned char reset_pn;
+	unsigned int index_mask;
+	struct rx_ba_pkt reorder_buffer[0];
+};
+
+struct rx_ba_node {
+	unsigned char sta_lut_index;
+	unsigned char tid;
+	unsigned char active;
+	unsigned char timeout_cnt;
+	struct hlist_node hlist;
+	struct rx_ba_node_desc *rx_ba;
+
+	/* For reorder timeout */
+	spinlock_t ba_node_lock;
+	struct timer_list reorder_timer;
+	struct sprdwl_rx_ba_entry *ba_entry;
+};
+
+struct sprdwl_rx_ba_entry {
+	struct hlist_head hlist[NUM_TIDS];
+	struct rx_ba_node *current_ba_node;
+	spinlock_t skb_list_lock;
+	struct sk_buff *skb_head;
+	struct sk_buff *skb_last;
+};
+
+void sprdwl_reorder_init(struct sprdwl_rx_ba_entry *ba_entry);
+void sprdwl_reorder_deinit(struct sprdwl_rx_ba_entry *ba_entry);
+struct sk_buff *reorder_data_process(struct sprdwl_rx_ba_entry *ba_entry,
+				     struct sk_buff *pskb);
+#ifdef SPLIT_STACK
+struct sk_buff *reorder_get_skb_list(struct sprdwl_rx_ba_entry *ba_entry);
+#endif
+void wlan_ba_session_event(void *hw_intf,
+			   unsigned char *data, unsigned short len);
+void peer_entry_delba(void *hw_intf, unsigned char sta_lut_index);
+void reset_pn(struct sprdwl_priv *priv, const u8 *mac_addr);
+
+#endif /* __SPRDWL_REORDER_H__ */
diff --git a/drivers/net/wireless/uwe5622/unisocwifi/rf_marlin3.c b/drivers/net/wireless/uwe5622/unisocwifi/rf_marlin3.c
new file mode 100644
index 000000000000..00c2330b17d9
--- /dev/null
+++ b/drivers/net/wireless/uwe5622/unisocwifi/rf_marlin3.c
@@ -0,0 +1,440 @@
+#include <linux/types.h>
+#include <linux/firmware.h>
+#include <linux/kernel.h>
+#include <linux/device.h>
+#include <linux/string.h>
+#include <linux/uaccess.h>
+#include <linux/fs.h>
+#include <linux/file.h>
+#include <linux/proc_fs.h>
+#include <linux/slab.h>
+#include <linux/printk.h>
+#include <linux/vmalloc.h>
+#include <linux/kdev_t.h>
+#include <linux/proc_fs.h>
+#include "rf_marlin3.h"
+#include <linux/version.h>
+#include <wcn_bus.h>
+#include <marlin_platform.h>
+
+#include "sprdwl.h"
+
+#define CF_TAB(NAME, MEM_OFFSET, TYPE) \
+	{ NAME, (size_t)(&(((struct wifi_conf_t *)(0))->MEM_OFFSET)), TYPE}
+
+#define OFS_MARK_STRING \
+	"#-----------------------------------------------------------------\r\n"
+
+static struct nvm_name_table g_config_table[] = {
+	/* [Section 1: Version]
+	 */
+	CF_TAB("Major", version.major, 2),
+	CF_TAB("Minor", version.minor, 2),
+
+	/* [SETCTION 2]Board Config: board_config_t
+	 */
+	CF_TAB("Calib_Bypass", board_config.calib_bypass, 2),
+	CF_TAB("TxChain_Mask", board_config.txchain_mask, 1),
+	CF_TAB("RxChain_Mask", board_config.rxchain_mask, 1),
+
+	/* [SETCTION 3]Board Config TPC: board_config_tpc_t
+	 */
+	CF_TAB("DPD_LUT_idx", board_config_tpc.dpd_lut_idx[0], 1),
+	CF_TAB("TPC_Goal_Chain0", board_config_tpc.tpc_goal_chain0[0], 2),
+	CF_TAB("TPC_Goal_Chain1", board_config_tpc.tpc_goal_chain1[0], 2),
+	/* [SETCTION 4]TPC-LUT: tpc_lut_t
+	 */
+	CF_TAB("Chain0_LUT_0", tpc_lut.chain0_lut[0], 1),
+	CF_TAB("Chain0_LUT_1", tpc_lut.chain0_lut[1], 1),
+	CF_TAB("Chain0_LUT_2", tpc_lut.chain0_lut[2], 1),
+	CF_TAB("Chain0_LUT_3", tpc_lut.chain0_lut[3], 1),
+	CF_TAB("Chain0_LUT_4", tpc_lut.chain0_lut[4], 1),
+	CF_TAB("Chain0_LUT_5", tpc_lut.chain0_lut[5], 1),
+	CF_TAB("Chain0_LUT_6", tpc_lut.chain0_lut[6], 1),
+	CF_TAB("Chain0_LUT_7", tpc_lut.chain0_lut[7], 1),
+	CF_TAB("Chain1_LUT_0", tpc_lut.chain1_lut[0], 1),
+	CF_TAB("Chain1_LUT_1", tpc_lut.chain1_lut[1], 1),
+	CF_TAB("Chain1_LUT_2", tpc_lut.chain1_lut[2], 1),
+	CF_TAB("Chain1_LUT_3", tpc_lut.chain1_lut[3], 1),
+	CF_TAB("Chain1_LUT_4", tpc_lut.chain1_lut[4], 1),
+	CF_TAB("Chain1_LUT_5", tpc_lut.chain1_lut[5], 1),
+	CF_TAB("Chain1_LUT_6", tpc_lut.chain1_lut[6], 1),
+	CF_TAB("Chain1_LUT_7", tpc_lut.chain1_lut[7], 1),
+
+	/*[SETCTION 5]Board Config Frequency Compensation:
+	 * board_conf_freq_comp_t
+	 */
+	CF_TAB("2G_Channel_Chain0",
+			board_conf_freq_comp.channel_2g_chain0[0], 1),
+	CF_TAB("2G_Channel_Chain1",
+			board_conf_freq_comp.channel_2g_chain1[0], 1),
+	CF_TAB("5G_Channel_Chain0",
+			board_conf_freq_comp.channel_5g_chain0[0], 1),
+	CF_TAB("5G_Channel_Chain1",
+			board_conf_freq_comp.channel_5g_chain1[0], 1),
+
+	/*[SETCTION 6]Rate To Power with BW 20M: power_20m_t
+	 */
+	CF_TAB("11b_Power", power_20m.power_11b[0], 1),
+	CF_TAB("11ag_Power", power_20m.power_11ag[0], 1),
+	CF_TAB("11n_Power", power_20m.power_11n[0], 1),
+	CF_TAB("11ac_Power", power_20m.power_11ac[0], 1),
+
+	/*[SETCTION 7]Power Backoff:power_backoff_t
+	 */
+	CF_TAB("Green_WIFI_offset", power_backoff.green_wifi_offset, 1),
+	CF_TAB("HT40_Power_offset", power_backoff.ht40_power_offset, 1),
+	CF_TAB("VHT40_Power_offset", power_backoff.vht40_power_offset, 1),
+	CF_TAB("VHT80_Power_offset", power_backoff.vht80_power_offset, 1),
+	CF_TAB("SAR_Power_offset", power_backoff.sar_power_offset, 1),
+	CF_TAB("Mean_Power_offset", power_backoff.mean_power_offset, 1),
+	CF_TAB("TPC_mode", power_backoff.tpc_mode, 1),
+	CF_TAB("MAGIC_word", power_backoff.magic_word, 1),
+
+	/*[SETCTION 8]Reg Domain:reg_domain_t
+	 */
+	CF_TAB("reg_domain1", reg_domain.reg_domain1, 4),
+	CF_TAB("reg_domain2", reg_domain.reg_domain2, 4),
+
+	/*[SETCTION 9]Band Edge Power offset(MKK, FCC, ETSI):
+	 * band_edge_power_offset_t
+	 */
+	CF_TAB("BW20M", band_edge_power_offset.bw20m[0], 1),
+	CF_TAB("BW40M", band_edge_power_offset.bw40m[0], 1),
+	CF_TAB("BW80M", band_edge_power_offset.bw80m[0], 1),
+
+	/*[SETCTION 10]TX Scale:tx_scale_t
+	 */
+	CF_TAB("Chain0_1", tx_scale.chain0[0][0], 1),
+	CF_TAB("Chain1_1", tx_scale.chain1[0][0], 1),
+	CF_TAB("Chain0_2", tx_scale.chain0[1][0], 1),
+	CF_TAB("Chain1_2", tx_scale.chain1[1][0], 1),
+	CF_TAB("Chain0_3", tx_scale.chain0[2][0], 1),
+	CF_TAB("Chain1_3", tx_scale.chain1[2][0], 1),
+	CF_TAB("Chain0_4", tx_scale.chain0[3][0], 1),
+	CF_TAB("Chain1_4", tx_scale.chain1[3][0], 1),
+	CF_TAB("Chain0_5", tx_scale.chain0[4][0], 1),
+	CF_TAB("Chain1_5", tx_scale.chain1[4][0], 1),
+	CF_TAB("Chain0_6", tx_scale.chain0[5][0], 1),
+	CF_TAB("Chain1_6", tx_scale.chain1[5][0], 1),
+	CF_TAB("Chain0_7", tx_scale.chain0[6][0], 1),
+	CF_TAB("Chain1_7", tx_scale.chain1[6][0], 1),
+	CF_TAB("Chain0_8", tx_scale.chain0[7][0], 1),
+	CF_TAB("Chain1_8", tx_scale.chain1[7][0], 1),
+	CF_TAB("Chain0_9", tx_scale.chain0[8][0], 1),
+	CF_TAB("Chain1_9", tx_scale.chain1[8][0], 1),
+	CF_TAB("Chain0_10", tx_scale.chain0[9][0], 1),
+	CF_TAB("Chain1_10", tx_scale.chain1[9][0], 1),
+	CF_TAB("Chain0_11", tx_scale.chain0[10][0], 1),
+	CF_TAB("Chain1_11", tx_scale.chain1[10][0], 1),
+	CF_TAB("Chain0_12", tx_scale.chain0[11][0], 1),
+	CF_TAB("Chain1_12", tx_scale.chain1[11][0], 1),
+	CF_TAB("Chain0_13", tx_scale.chain0[12][0], 1),
+	CF_TAB("Chain1_13", tx_scale.chain1[12][0], 1),
+	CF_TAB("Chain0_14", tx_scale.chain0[13][0], 1),
+	CF_TAB("Chain1_14", tx_scale.chain1[13][0], 1),
+	CF_TAB("Chain0_36", tx_scale.chain0[14][0], 1),
+	CF_TAB("Chain1_36", tx_scale.chain1[14][0], 1),
+	CF_TAB("Chain0_40", tx_scale.chain0[15][0], 1),
+	CF_TAB("Chain1_40", tx_scale.chain1[15][0], 1),
+	CF_TAB("Chain0_44", tx_scale.chain0[16][0], 1),
+	CF_TAB("Chain1_44", tx_scale.chain1[16][0], 1),
+	CF_TAB("Chain0_48", tx_scale.chain0[17][0], 1),
+	CF_TAB("Chain1_48", tx_scale.chain1[17][0], 1),
+	CF_TAB("Chain0_52", tx_scale.chain0[18][0], 1),
+	CF_TAB("Chain1_52", tx_scale.chain1[18][0], 1),
+	CF_TAB("Chain0_56", tx_scale.chain0[19][0], 1),
+	CF_TAB("Chain1_56", tx_scale.chain1[19][0], 1),
+	CF_TAB("Chain0_60", tx_scale.chain0[20][0], 1),
+	CF_TAB("Chain1_60", tx_scale.chain1[20][0], 1),
+	CF_TAB("Chain0_64", tx_scale.chain0[21][0], 1),
+	CF_TAB("Chain1_64", tx_scale.chain1[21][0], 1),
+	CF_TAB("Chain0_100", tx_scale.chain0[22][0], 1),
+	CF_TAB("Chain1_100", tx_scale.chain1[22][0], 1),
+	CF_TAB("Chain0_104", tx_scale.chain0[23][0], 1),
+	CF_TAB("Chain1_104", tx_scale.chain1[23][0], 1),
+	CF_TAB("Chain0_108", tx_scale.chain0[24][0], 1),
+	CF_TAB("Chain1_108", tx_scale.chain1[24][0], 1),
+	CF_TAB("Chain0_112", tx_scale.chain0[25][0], 1),
+	CF_TAB("Chain1_112", tx_scale.chain1[25][0], 1),
+	CF_TAB("Chain0_116", tx_scale.chain0[26][0], 1),
+	CF_TAB("Chain1_116", tx_scale.chain1[26][0], 1),
+	CF_TAB("Chain0_120", tx_scale.chain0[27][0], 1),
+	CF_TAB("Chain1_120", tx_scale.chain1[27][0], 1),
+	CF_TAB("Chain0_124", tx_scale.chain0[28][0], 1),
+	CF_TAB("Chain1_124", tx_scale.chain1[28][0], 1),
+	CF_TAB("Chain0_128", tx_scale.chain0[29][0], 1),
+	CF_TAB("Chain1_128", tx_scale.chain1[29][0], 1),
+	CF_TAB("Chain0_132", tx_scale.chain0[30][0], 1),
+	CF_TAB("Chain1_132", tx_scale.chain1[30][0], 1),
+	CF_TAB("Chain0_136", tx_scale.chain0[31][0], 1),
+	CF_TAB("Chain1_136", tx_scale.chain1[31][0], 1),
+	CF_TAB("Chain0_140", tx_scale.chain0[32][0], 1),
+	CF_TAB("Chain1_140", tx_scale.chain1[32][0], 1),
+	CF_TAB("Chain0_144", tx_scale.chain0[33][0], 1),
+	CF_TAB("Chain1_144", tx_scale.chain1[33][0], 1),
+	CF_TAB("Chain0_149", tx_scale.chain0[34][0], 1),
+	CF_TAB("Chain1_149", tx_scale.chain1[34][0], 1),
+	CF_TAB("Chain0_153", tx_scale.chain0[35][0], 1),
+	CF_TAB("Chain1_153", tx_scale.chain0[35][0], 1),
+	CF_TAB("Chain0_157", tx_scale.chain0[36][0], 1),
+	CF_TAB("Chain1_157", tx_scale.chain0[36][0], 1),
+	CF_TAB("Chain0_161", tx_scale.chain0[37][0], 1),
+	CF_TAB("Chain1_161", tx_scale.chain1[37][0], 1),
+	CF_TAB("Chain0_165", tx_scale.chain0[38][0], 1),
+	CF_TAB("Chain1_165", tx_scale.chain1[38][0], 1),
+
+	/*[SETCTION 11]misc:misc_t
+	 */
+	CF_TAB("DFS_switch", misc.dfs_switch, 1),
+	CF_TAB("power_save_switch", misc.power_save_switch, 1),
+	CF_TAB("ex-Fem_and_ex-LNA_param_setup", misc.fem_lan_param_setup, 1),
+	CF_TAB("rssi_report_diff", misc.rssi_report_diff, 1),
+
+	/*[SETCTION 12]debug reg:debug_reg_t
+	 */
+	CF_TAB("address", debug_reg.address[0], 4),
+	CF_TAB("value", debug_reg.value[0], 4),
+
+	/*[SETCTION 13]coex_config:coex_config_t
+	 */
+	CF_TAB("bt_performance_cfg0", coex_config.bt_performance_cfg0, 4),
+	CF_TAB("bt_performance_cfg1", coex_config.bt_performance_cfg1, 4),
+	CF_TAB("wifi_performance_cfg0", coex_config.wifi_performance_cfg0, 4),
+	CF_TAB("wifi_performance_cfg2", coex_config.wifi_performance_cfg2, 4),
+	CF_TAB("strategy_cfg0", coex_config.strategy_cfg0, 4),
+	CF_TAB("strategy_cfg1", coex_config.strategy_cfg1, 4),
+	CF_TAB("strategy_cfg2", coex_config.strategy_cfg2, 4),
+	CF_TAB("compatibility_cfg0", coex_config.compatibility_cfg0, 4),
+	CF_TAB("compatibility_cfg1", coex_config.compatibility_cfg1, 4),
+	CF_TAB("ant_cfg0", coex_config.ant_cfg0, 4),
+	CF_TAB("ant_cfg1", coex_config.ant_cfg1, 4),
+	CF_TAB("isolation_cfg0", coex_config.isolation_cfg0, 4),
+	CF_TAB("isolation_cfg1", coex_config.isolation_cfg1, 4),
+	CF_TAB("reserved_cfg0", coex_config.reserved_cfg0, 4),
+	CF_TAB("reserved_cfg1", coex_config.reserved_cfg1, 4),
+	CF_TAB("reserved_cfg2", coex_config.reserved_cfg2, 4),
+	CF_TAB("reserved_cfg3", coex_config.reserved_cfg3, 4),
+	CF_TAB("reserved_cfg4", coex_config.reserved_cfg4, 4),
+	CF_TAB("reserved_cfg5", coex_config.reserved_cfg5, 4),
+	CF_TAB("reserved_cfg6", coex_config.reserved_cfg6, 4),
+	CF_TAB("reserved_cfg7", coex_config.reserved_cfg7, 4),
+
+	/*
+	 * [SETCTION 14] rf_config:rf_config_t
+	 */
+	CF_TAB("rf_config", rf_config.rf_data, 1),
+};
+
+static int find_type(char key)
+{
+	if ((key >= 'a' && key <= 'w') ||
+		(key >= 'y' && key <= 'z') ||
+		(key >= 'A' && key <= 'W') ||
+		(key >= 'Y' && key <= 'Z') ||
+		('_' == key))
+		return 1;
+	if ((key >= '0' && key <= '9') ||
+		('-' == key))
+		return 2;
+	if (('x' == key) ||
+		('X' == key) ||
+		('.' == key))
+		return 3;
+	if ((key == '\0') ||
+		('\r' == key) ||
+		('\n' == key) ||
+		('#' == key))
+		return 4;
+	return 0;
+}
+
+static int wifi_nvm_set_cmd(struct nvm_name_table *pTable,
+	struct nvm_cali_cmd *cmd, void *p_data)
+{
+	int i;
+	unsigned char *p;
+
+	if ((1 != pTable->type) &&
+		(2 != pTable->type) &&
+		(4 != pTable->type))
+		return -1;
+
+	p = (unsigned char *)(p_data) + pTable->mem_offset;
+
+	wl_debug("[g_table]%s, offset:%u, num:%u, value:\
+			%d %d %d %d %d %d %d %d %d %d \n",
+			pTable->itm, pTable->mem_offset, cmd->num,
+			cmd->par[0], cmd->par[1], cmd->par[2],
+			cmd->par[3], cmd->par[4], cmd->par[5],
+			cmd->par[6], cmd->par[7], cmd->par[8],
+			cmd->par[9]);
+
+	for (i = 0; i < cmd->num; i++) {
+		if (1 == pTable->type)
+			*((unsigned char *)p + i)
+			= (unsigned char)(cmd->par[i]);
+		else if (2 == pTable->type)
+			*((unsigned short *)p + i)
+			= (unsigned short)(cmd->par[i]);
+		else if (4 == pTable->type)
+			*((unsigned int *)p + i)
+			= (unsigned int)(cmd->par[i]);
+		else
+			wl_err("%s, type err\n", __func__);
+	}
+	return 0;
+}
+
+static void get_cmd_par(const char *str, struct nvm_cali_cmd *cmd)
+{
+	int i, j, bufType, cType, flag;
+	char tmp[128];
+	char c;
+	long val;
+
+	bufType = -1;
+	cType = 0;
+	flag = 0;
+	memset(cmd, 0, sizeof(struct nvm_cali_cmd));
+
+	for (i = 0, j = 0;; i++) {
+		c = str[i];
+		cType = find_type(c);
+		if ((1 == cType) ||
+			(2 == cType) ||
+			(3 == cType)) {
+			tmp[j] = c;
+			j++;
+			if (-1 == bufType) {
+				if (2 == cType)
+					bufType = 2;
+				else
+					bufType = 1;
+			} else if (2 == bufType) {
+				if (1 == cType)
+					bufType = 1;
+			}
+			continue;
+		}
+		if (-1 != bufType) {
+			tmp[j] = '\0';
+
+			if ((1 == bufType) && (0 == flag)) {
+				strcpy(cmd->itm, tmp);
+				flag = 1;
+			} else {
+				if (kstrtol(tmp, 0, &val))
+					wl_info(" %s ", tmp);
+			/* pr_err("kstrtol %s: error\n", tmp); */
+				cmd->par[cmd->num] = val & 0xFFFFFFFF;
+				cmd->num++;
+			}
+			bufType = -1;
+			j = 0;
+		}
+		if (0 == cType)
+			continue;
+		if (4 == cType)
+			return;
+	}
+}
+
+static struct nvm_name_table *cf_table_match(struct nvm_cali_cmd *cmd)
+{
+	int i;
+	struct nvm_name_table *pTable = NULL;
+	int len = sizeof(g_config_table) / sizeof(struct nvm_name_table);
+
+	if (NULL == cmd)
+		return NULL;
+	for (i = 0; i < len; i++) {
+		if (NULL == g_config_table[i].itm)
+			continue;
+		if (0 != strcmp(g_config_table[i].itm, cmd->itm))
+			continue;
+		pTable = &g_config_table[i];
+		break;
+	}
+	return pTable;
+}
+
+static int wifi_nvm_buf_operate(const char *pBuf, int file_len, void *p_data)
+{
+	int i, p;
+	struct nvm_cali_cmd *cmd;
+	struct wifi_conf_t *conf;
+	struct nvm_name_table *pTable = NULL;
+
+	if ((NULL == pBuf) || (0 == file_len))
+		return -1;
+
+	cmd = kzalloc(sizeof(struct nvm_cali_cmd), GFP_KERNEL);
+	for (i = 0, p = 0; i < file_len; i++) {
+		if (('\n' == *(pBuf + i)) ||
+			('\r' == *(pBuf + i)) ||
+			('\0' == *(pBuf + i))) {
+			if (5 <= (i - p)) {
+				get_cmd_par((pBuf + p), cmd);
+				pTable = cf_table_match(cmd);
+
+				if (NULL != pTable) {
+					wifi_nvm_set_cmd(pTable, cmd, p_data);
+					if (strcmp(pTable->itm, "rf_config") == 0) {
+						conf = (struct wifi_conf_t *)p_data;
+						conf->rf_config.rf_data_len = cmd->num;
+					}
+				}
+			}
+			p = i + 1;
+		}
+	}
+
+	kfree(cmd);
+	return 0;
+}
+
+static int wifi_nvm_parse(const char *name, void *p_data)
+{
+	int ret;
+	const struct firmware *firmware;
+
+	ret = request_firmware(&firmware, name, NULL);
+	if (ret < 0) {
+		wl_err("can't load ini file!\n");
+		return ret;
+	}
+
+	ret = wifi_nvm_buf_operate((const char *)firmware->data, firmware->size, p_data);
+	release_firmware(firmware);
+	wl_err("%s(), ok!\n", __func__);
+	return ret;
+}
+
+int get_wifi_config_param(struct wifi_conf_t *p)
+{
+	int ant = 0;
+	int chipid = 0;
+	char conf_name[32] = {0};
+	int ret;
+
+	ant = marlin_get_ant_num();
+	if (ant < 0) {
+		wl_err("get ant config failed, ant = %d\n", ant);
+		return -1;
+	}
+
+	chipid = marlin_get_wcn_chipid();
+	if (chipid == 0) {
+		wl_err("get chip ip failed, chipid = %d\n", chipid);
+		return -1;
+	}
+
+	sprintf(conf_name, "wifi_%8x_%dant.ini", chipid, ant);
+
+	ret = wifi_nvm_parse(conf_name, (void *)p);
+
+	pr_err("wifi ini name = %s, ret=%d\n", conf_name, ret);
+
+	return ret;
+}
diff --git a/drivers/net/wireless/uwe5622/unisocwifi/rf_marlin3.h b/drivers/net/wireless/uwe5622/unisocwifi/rf_marlin3.h
new file mode 100644
index 000000000000..785665f83180
--- /dev/null
+++ b/drivers/net/wireless/uwe5622/unisocwifi/rf_marlin3.h
@@ -0,0 +1,181 @@
+#ifndef __MARLIN3_RF_H__
+#define __MARLIN3_RF_H__
+struct nvm_cali_cmd {
+	int8_t itm[64];
+	int32_t par[512];
+	int32_t num;
+};
+
+struct nvm_name_table {
+	int8_t *itm;
+	uint32_t mem_offset;
+	int32_t type;
+};
+/*[Section 1: Version] */
+struct version_t {
+	uint16_t major;
+	uint16_t minor;
+};
+
+/*[Section 2: Board Config]*/
+struct board_config_t {
+	uint16_t calib_bypass;
+	uint8_t txchain_mask;
+	uint8_t rxchain_mask;
+};
+
+/*[Section 3: Board Config TPC]*/
+struct board_config_tpc_t {
+	uint8_t dpd_lut_idx[8];
+	uint16_t tpc_goal_chain0[8];
+	uint16_t tpc_goal_chain1[8];
+};
+
+struct tpc_element_lut_t {
+	uint8_t rf_gain_idx;
+	uint8_t pa_bias_idx;
+	int8_t  dvga_offset;
+	int8_t  residual_error;
+};
+/*[Section 4: TPC-LUT]*/
+struct tpc_lut_t {
+	struct tpc_element_lut_t chain0_lut[8];
+	struct tpc_element_lut_t chain1_lut[8];
+};
+
+/*[Section 5: Board Config Frequency Compensation]*/
+struct board_conf_freq_comp_t {
+	int8_t channel_2g_chain0[14];
+	int8_t channel_2g_chain1[14];
+	int8_t channel_5g_chain0[25];
+	int8_t channel_5g_chain1[25];
+	int8_t reserved[2];
+};
+
+/*[Section 6: Rate To Power with BW 20M]*/
+struct power_20m_t {
+	int8_t power_11b[4];
+	int8_t power_11ag[8];
+	int8_t power_11n[17];
+	int8_t power_11ac[20];
+	int8_t reserved[3];
+};
+
+/*[Section 7: Power Backoff]*/
+struct power_backoff_t {
+	int8_t green_wifi_offset;
+	int8_t ht40_power_offset;
+	int8_t vht40_power_offset;
+	int8_t vht80_power_offset;
+	int8_t sar_power_offset;
+	int8_t mean_power_offset;
+	int8_t tpc_mode;
+	int8_t magic_word;
+};
+
+/*[Section 8: Reg Domain]*/
+struct reg_domain_t {
+	uint32_t reg_domain1;
+	uint32_t reg_domain2;
+};
+
+/*[Section 9: Band Edge Power offset (MKK, FCC, ETSI)]*/
+struct band_edge_power_offset_t {
+	uint8_t bw20m[39];
+	uint8_t bw40m[21];
+	uint8_t bw80m[6];
+	uint8_t reserved[2];
+};
+
+/*[Section 10: TX Scale]*/
+struct tx_scale_t {
+	int8_t chain0[39][16];
+	int8_t chain1[39][16];
+};
+
+/*[Section 11: misc]*/
+struct misc_t {
+	int8_t dfs_switch;
+	int8_t power_save_switch;
+	int8_t fem_lan_param_setup;
+	int8_t rssi_report_diff;
+};
+
+/*[Section 12: debug reg]*/
+struct debug_reg_t {
+	uint32_t address[16];
+	uint32_t value[16];
+};
+
+/*[Section 13:coex_config] */
+struct coex_config_t {
+	uint32_t bt_performance_cfg0;
+	uint32_t bt_performance_cfg1;
+	uint32_t wifi_performance_cfg0;
+	uint32_t wifi_performance_cfg2;
+	uint32_t strategy_cfg0;
+	uint32_t strategy_cfg1;
+	uint32_t strategy_cfg2;
+	uint32_t compatibility_cfg0;
+	uint32_t compatibility_cfg1;
+	uint32_t ant_cfg0;
+	uint32_t ant_cfg1;
+	uint32_t isolation_cfg0;
+	uint32_t isolation_cfg1;
+	uint32_t reserved_cfg0;
+	uint32_t reserved_cfg1;
+	uint32_t reserved_cfg2;
+	uint32_t reserved_cfg3;
+	uint32_t reserved_cfg4;
+	uint32_t reserved_cfg5;
+	uint32_t reserved_cfg6;
+	uint32_t reserved_cfg7;
+};
+
+struct rf_config_t {
+	int rf_data_len;
+	uint8_t rf_data[1500];
+};
+
+/*wifi config section1 struct*/
+struct wifi_conf_sec1_t {
+	struct version_t version;
+	struct board_config_t board_config;
+	struct board_config_tpc_t board_config_tpc;
+	struct tpc_lut_t tpc_lut;
+	struct board_conf_freq_comp_t board_conf_freq_comp;
+	struct power_20m_t power_20m;
+	struct power_backoff_t power_backoff;
+	struct reg_domain_t reg_domain;
+	struct band_edge_power_offset_t band_edge_power_offset;
+};
+
+/*wifi config section2 struct*/
+struct wifi_conf_sec2_t {
+	struct tx_scale_t tx_scale;
+	struct misc_t misc;
+	struct debug_reg_t debug_reg;
+	struct coex_config_t coex_config;
+};
+
+/*wifi config struct*/
+struct wifi_conf_t {
+	struct version_t version;
+	struct board_config_t board_config;
+	struct board_config_tpc_t board_config_tpc;
+	struct tpc_lut_t tpc_lut;
+	struct board_conf_freq_comp_t board_conf_freq_comp;
+	struct power_20m_t power_20m;
+	struct power_backoff_t power_backoff;
+	struct reg_domain_t reg_domain;
+	struct band_edge_power_offset_t band_edge_power_offset;
+	struct tx_scale_t tx_scale;
+	struct misc_t misc;
+	struct debug_reg_t debug_reg;
+	struct coex_config_t coex_config;
+	struct rf_config_t rf_config;
+};
+
+int get_wifi_config_param(struct wifi_conf_t *p);
+unsigned int marlin_get_wcn_chipid(void);
+#endif
diff --git a/drivers/net/wireless/uwe5622/unisocwifi/rnd_mac_addr.c b/drivers/net/wireless/uwe5622/unisocwifi/rnd_mac_addr.c
new file mode 100644
index 000000000000..a3b7fb755060
--- /dev/null
+++ b/drivers/net/wireless/uwe5622/unisocwifi/rnd_mac_addr.c
@@ -0,0 +1,28 @@
+#include "rnd_mac_addr.h"
+
+u8 rand_addr[ETH_ALEN];
+
+void random_mac_addr(u8 *addr)
+{
+	get_random_bytes(addr, ETH_ALEN);
+	addr[0] &= 0xfe; /* unicast */
+	addr[0] |= 0x02; /* locally administered */
+}
+
+int wlan_cmd_set_rand_mac(struct sprdwl_priv *priv, u8 vif_ctx_id,
+		u8 random_mac_flag, u8 *addr)
+{
+	struct sprdwl_msg_buf *msg;
+	u8 *p;
+
+	msg = sprdwl_cmd_getbuf(priv, ETH_ALEN+1, vif_ctx_id,
+			SPRDWL_HEAD_RSP, WIFI_CMD_RND_MAC);
+	if (!msg)
+		return -ENOMEM;
+	p = (u8 *)msg->data;
+	*p = random_mac_flag;
+
+	memcpy(p+1, addr, ETH_ALEN);
+	return sprdwl_cmd_send_recv(priv, msg,
+			CMD_WAIT_TIMEOUT, NULL, NULL);
+}
diff --git a/drivers/net/wireless/uwe5622/unisocwifi/rnd_mac_addr.h b/drivers/net/wireless/uwe5622/unisocwifi/rnd_mac_addr.h
new file mode 100644
index 000000000000..5a667244a472
--- /dev/null
+++ b/drivers/net/wireless/uwe5622/unisocwifi/rnd_mac_addr.h
@@ -0,0 +1,13 @@
+#ifndef __SPRDWL_RND_MAC_ADDR_H__
+#define __SPRDWL_RND_MAC_ADDR_H__
+
+#include "sprdwl.h"
+
+#define SCAN_RANDOM_MAC_ADDR (1 << 29)
+
+extern u8 rand_addr[ETH_ALEN];
+void random_mac_addr(u8 *addr);
+int wlan_cmd_set_rand_mac(struct sprdwl_priv *priv, u8 vif_mode,
+		u8 random_mac_flag, u8 *addr);
+
+#endif
diff --git a/drivers/net/wireless/uwe5622/unisocwifi/rtt.c b/drivers/net/wireless/uwe5622/unisocwifi/rtt.c
new file mode 100644
index 000000000000..69d6965638fb
--- /dev/null
+++ b/drivers/net/wireless/uwe5622/unisocwifi/rtt.c
@@ -0,0 +1,965 @@
+/*
+ * Copyright (C) 2015 Spreadtrum Communications Inc.
+ *
+ * Abstract : This file is an implementation for cfg80211 subsystem
+ *
+ * Authors:
+ * Chaojie Xu <chaojie.xu@spreadtrum.com>
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include <linux/etherdevice.h>
+#include <net/cfg80211.h>
+#include <net/netlink.h>
+#include "sprdwl.h"
+#include "rtt.h"
+
+/* FTM session ID we use with FW */
+#define FTM_ESSION_ID		1
+
+/* fixed spare allocation we reserve in NL messages we allocate */
+#define FTM_NL_EXTRA_ALLOC		32
+
+/* approx maximum length for FTM_MEAS_RESULT NL80211 event */
+#define FTM_MEAS_RESULT_MAX_LENGTH	2048
+
+/* maximum number of allowed FTM measurements per burst */
+#define FTM_MAX_MEAS_PER_BURST	31
+
+/* initial token to use on non-secure FTM measurement */
+#define FTM_DEFAULT_INITIAL_TOKEN	2
+
+#define FTM_MAX_LCI_LENGTH		(240)
+#define FTM_MAX_LCR_LENGTH		(240)
+
+/* max rtt cmd response length */
+#define RTT_RSP_LEN (128)
+
+enum session_start_flags {
+	FTM_SESSION_START_FLAG_SECURED	= 0x1,
+	FTM_SESSION_START_FLAG_ASAP		= 0x2,
+	FTM_SESSION_START_FLAG_LCI_REQ	= 0x4,
+	FTM_SESSION_START_FLAG_LCR_REQ	= 0x8,
+};
+
+enum rtt_subcmd {
+	RTT_ENABLE,
+	RTT_DISABLE,
+	RTT_GET_CAPABILITIES,
+	RTT_RANGE_REQUEST,
+	RTT_RANGE_CANCEL,
+	RTT_SET_CLI,
+	RTT_SET_CLR,
+	RTT_GET_RESPONDER_INFO,
+	RTT_ENABLE_RESPONDER,
+	RTT_DISABLE_RESPONDER,
+};
+
+enum rtt_subevt {
+	RTT_SESSION_END,
+	RTT_PER_DEST_RES,
+};
+
+/* Responder FTM Results */
+struct sprdwl_responder_ftm_res {
+	u8 t1[6];
+	u8 t2[6];
+	u8 t3[6];
+	u8 t4[6];
+	__le16 tod_err;
+	__le16 toa_err;
+	__le16 tod_err_initiator;
+	__le16 toa_err_initiator;
+} __packed;
+
+enum ftm_per_dest_res_status {
+	FTM_PER_DEST_RES_NO_ERROR		= 0x00,
+	FTM_PER_DEST_RES_TX_RX_FAIL		= 0x01,
+	FTM_PER_DEST_RES_PARAM_DONT_MATCH	= 0x02,
+};
+
+enum ftm_per_dest_res_flags {
+	FTM_PER_DEST_RES_REQ_START		= 0x01,
+	FTM_PER_DEST_RES_BURST_REPORT_END	= 0x02,
+	FTM_PER_DEST_RES_REQ_END		= 0x04,
+	FTM_PER_DEST_RES_PARAM_UPDATE		= 0x08,
+};
+
+struct ftm_per_dest_res {
+	/* FTM session ID */
+	__le32 session_id;
+	/* destination MAC address */
+	u8 dst_mac[ETH_ALEN];
+	/* wmi_tof_ftm_per_dest_res_flags_e */
+	u8 flags;
+	/* wmi_tof_ftm_per_dest_res_status_e */
+	u8 status;
+	/* responder ASAP */
+	u8 responder_asap;
+	/* responder number of FTM per burst */
+	u8 responder_num_ftm_per_burst;
+	/* responder number of FTM burst exponent */
+	u8 responder_num_ftm_bursts_exp;
+	/* responder burst duration ,wmi_tof_burst_duration_e */
+	u8 responder_burst_duration;
+	/* responder burst period, indicate interval between two consecutive
+	 * burst instances, in units of 100 ms
+	 */
+	__le16 responder_burst_period;
+	/* receive burst counter */
+	__le16 bursts_cnt;
+	/* tsf of responder start burst */
+	__le32 tsf_sync;
+	/* actual received ftm per burst */
+	u8 actual_ftm_per_burst;
+	u8 reserved0[7];
+	struct sprdwl_responder_ftm_res responder_ftm_res[0];
+} __packed;
+
+struct ftm_dest_info {
+	u8 channel;
+	u8 flags;
+	u8 initial_token;
+	u8 num_of_ftm_per_burst;
+	u8 num_of_bursts_exp;
+	u8 burst_duration;
+	/* Burst Period indicate interval between two consecutive burst
+	 * instances, in units of 100 ms
+	 */
+	__le16 burst_period;
+	u8 dst_mac[ETH_ALEN];
+	__le16 reserved;
+} __packed;
+
+struct ftm_session_start {
+	__le32 session_id;
+	u8 num_of_aoa_measures;
+	u8 aoa_type;
+	__le16 num_of_dest;
+	u8 reserved[4];
+	struct ftm_dest_info dest_info[0];
+} __packed;
+
+struct sprdwl_cmd_rtt {
+	u8 sub_cmd;
+	__le16 len;
+	u8 data[0];
+} __packed;
+
+static const struct
+nla_policy sprdwl_nl80211_loc_policy[SPRDWL_VENDOR_ATTR_LOC_MAX + 1] = {
+	[SPRDWL_VENDOR_ATTR_FTM_SESSION_COOKIE] = { .type = NLA_U64 },
+	[SPRDWL_VENDOR_ATTR_LOC_CAPA] = { .type = NLA_NESTED },
+	[SPRDWL_VENDOR_ATTR_FTM_MEAS_PEERS] = { .type = NLA_NESTED },
+	[SPRDWL_VENDOR_ATTR_FTM_MEAS_PEER_RESULTS] = { .type = NLA_NESTED },
+	[SPRDWL_VENDOR_ATTR_FTM_RESPONDER_ENABLE] = { .type = NLA_FLAG },
+	[SPRDWL_VENDOR_ATTR_LOC_SESSION_STATUS] = { .type = NLA_U32 },
+	[SPRDWL_VENDOR_ATTR_FTM_INITIAL_TOKEN] = { .type = NLA_U8 },
+	[SPRDWL_VENDOR_ATTR_AOA_TYPE] = { .type = NLA_U32 },
+	[SPRDWL_VENDOR_ATTR_LOC_ANTENNA_ARRAY_MASK] = { .type = NLA_U32 },
+	[SPRDWL_VENDOR_ATTR_FREQ] = { .type = NLA_U32 },
+};
+
+static const struct
+nla_policy sprdwl_nl80211_ftm_peer_policy[
+	SPRDWL_VENDOR_ATTR_FTM_PEER_MAX + 1] = {
+	[SPRDWL_VENDOR_ATTR_FTM_PEER_MAC_ADDR] = { .len = ETH_ALEN },
+	[SPRDWL_VENDOR_ATTR_FTM_PEER_MEAS_FLAGS] = { .type = NLA_U32 },
+	[SPRDWL_VENDOR_ATTR_FTM_PEER_MEAS_PARAMS] = { .type = NLA_NESTED },
+	[SPRDWL_VENDOR_ATTR_FTM_PEER_SECURE_TOKEN_ID] = { .type = NLA_U8 },
+	[SPRDWL_VENDOR_ATTR_FTM_PEER_FREQ] = { .type = NLA_U32 },
+};
+
+static const struct
+nla_policy sprdwl_nl80211_ftm_meas_param_policy[
+	SPRDWL_VENDOR_ATTR_FTM_PARAM_MAX + 1] = {
+	[SPRDWL_VENDOR_ATTR_FTM_PARAM_MEAS_PER_BURST] = { .type = NLA_U8 },
+	[SPRDWL_VENDOR_ATTR_FTM_PARAM_NUM_BURSTS_EXP] = { .type = NLA_U8 },
+	[SPRDWL_VENDOR_ATTR_FTM_PARAM_BURST_DURATION] = { .type = NLA_U8 },
+	[SPRDWL_VENDOR_ATTR_FTM_PARAM_BURST_PERIOD] = { .type = NLA_U16 },
+};
+
+static u8 sprdwl_ftm_get_channel(struct wiphy *wiphy,
+				 const u8 *mac_addr, u32 freq)
+{
+	struct cfg80211_bss *bss;
+	struct ieee80211_channel *chan;
+	u8 channel;
+
+	if (freq) {
+		chan = ieee80211_get_channel(wiphy, freq);
+		if (!chan) {
+			wl_err("invalid freq: %d\n", freq);
+			return 0;
+		}
+		channel = chan->hw_value;
+	} else {
+		bss = cfg80211_get_bss(wiphy, NULL, mac_addr,
+				       NULL, 0, WLAN_CAPABILITY_ESS,
+				       WLAN_CAPABILITY_ESS);
+		if (!bss) {
+			wl_err("Unable to find BSS\n");
+			return 0;
+		}
+		channel = bss->channel->hw_value;
+		cfg80211_put_bss(wiphy, bss);
+	}
+
+	wl_info("target %pM at channel %d\n", mac_addr, channel);
+	return channel;
+}
+
+static int sprdwl_ftm_parse_meas_params(struct sprdwl_vif *vif,
+					struct nlattr *attr,
+					struct sprdwl_ftm_meas_params *params)
+{
+	struct nlattr *tb[SPRDWL_VENDOR_ATTR_FTM_PARAM_MAX + 1];
+	int rc;
+
+	if (!attr) {
+		/* temporary defaults for one-shot measurement */
+		params->meas_per_burst = 1;
+		params->burst_period = 5; /* 500 milliseconds */
+		return 0;
+	}
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 14, 0)
+	rc = nla_parse_nested(tb, SPRDWL_VENDOR_ATTR_FTM_PARAM_MAX,
+			      attr, sprdwl_nl80211_ftm_meas_param_policy, NULL);
+#else
+	rc = nla_parse_nested(tb, SPRDWL_VENDOR_ATTR_FTM_PARAM_MAX,
+				attr, sprdwl_nl80211_ftm_meas_param_policy);
+#endif
+	if (rc) {
+		wl_ndev_log(L_ERR, vif->ndev,
+			   "%s: invalid measurement params\n", __func__);
+		return rc;
+	}
+	if (tb[SPRDWL_VENDOR_ATTR_FTM_PARAM_MEAS_PER_BURST])
+		params->meas_per_burst = nla_get_u8(
+			tb[SPRDWL_VENDOR_ATTR_FTM_PARAM_MEAS_PER_BURST]);
+	if (tb[SPRDWL_VENDOR_ATTR_FTM_PARAM_NUM_BURSTS_EXP])
+		params->num_of_bursts_exp = nla_get_u8(
+			tb[SPRDWL_VENDOR_ATTR_FTM_PARAM_NUM_BURSTS_EXP]);
+	if (tb[SPRDWL_VENDOR_ATTR_FTM_PARAM_BURST_DURATION])
+		params->burst_duration = nla_get_u8(
+			tb[SPRDWL_VENDOR_ATTR_FTM_PARAM_BURST_DURATION]);
+	if (tb[SPRDWL_VENDOR_ATTR_FTM_PARAM_BURST_PERIOD])
+		params->burst_period = nla_get_u16(
+			tb[SPRDWL_VENDOR_ATTR_FTM_PARAM_BURST_PERIOD]);
+	return 0;
+}
+
+static int
+sprdwl_ftm_validate_meas_params(struct sprdwl_vif *vif,
+				struct sprdwl_ftm_meas_params *params)
+{
+	if (params->meas_per_burst > FTM_MAX_MEAS_PER_BURST ||
+	    params->num_of_bursts_exp != 0) {
+		wl_ndev_log(L_ERR, vif->ndev, "%s: invalid meas per burst\n", __func__);
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int sprdwl_ftm_append_meas_params(struct sprdwl_priv *priv,
+					 struct sk_buff *msg,
+					 struct sprdwl_ftm_meas_params *params)
+{
+	struct nlattr *nl_p;
+
+	nl_p = nla_nest_start(
+		msg, SPRDWL_VENDOR_ATTR_FTM_PEER_RES_MEAS_PARAMS);
+	if (!nl_p)
+		goto out_put_failure;
+	if (nla_put_u8(msg, SPRDWL_VENDOR_ATTR_FTM_PARAM_MEAS_PER_BURST,
+		       params->meas_per_burst) ||
+	    nla_put_u8(msg, SPRDWL_VENDOR_ATTR_FTM_PARAM_NUM_BURSTS_EXP,
+		       params->num_of_bursts_exp) ||
+	    nla_put_u8(msg, SPRDWL_VENDOR_ATTR_FTM_PARAM_BURST_DURATION,
+		       params->burst_duration) ||
+	    nla_put_u16(msg, SPRDWL_VENDOR_ATTR_FTM_PARAM_BURST_PERIOD,
+			params->burst_period))
+		goto out_put_failure;
+	nla_nest_end(msg, nl_p);
+	return 0;
+out_put_failure:
+	return -ENOBUFS;
+}
+
+static int sprdwl_ftm_append_peer_meas_res(struct sprdwl_priv *priv,
+					   struct sk_buff *msg,
+					   struct sprdwl_ftm_peer_meas_res *res)
+{
+	struct nlattr *nl_mres, *nl_f;
+	int i;
+
+	if (nla_put(msg, SPRDWL_VENDOR_ATTR_FTM_PEER_RES_MAC_ADDR,
+		    ETH_ALEN, res->mac_addr) ||
+	    nla_put_u32(msg, SPRDWL_VENDOR_ATTR_FTM_PEER_RES_FLAGS,
+			res->flags) ||
+	    nla_put_u8(msg, SPRDWL_VENDOR_ATTR_FTM_PEER_RES_STATUS,
+		       res->status))
+		goto out_put_failure;
+	if (res->status == SPRDWL_VENDOR_ATTR_FTM_PEER_RES_STATUS_FAILED &&
+	    nla_put_u8(msg,
+		       SPRDWL_VENDOR_ATTR_FTM_PEER_RES_VALUE_SECONDS,
+		       res->value_seconds))
+		goto out_put_failure;
+	if (res->has_params &&
+	    sprdwl_ftm_append_meas_params(priv, msg, &res->params))
+		goto out_put_failure;
+	nl_mres = nla_nest_start(msg, SPRDWL_VENDOR_ATTR_FTM_PEER_RES_MEAS);
+	if (!nl_mres)
+		goto out_put_failure;
+	for (i = 0; i < res->n_meas; i++) {
+		nl_f = nla_nest_start(msg, i);
+		if (!nl_f)
+			goto out_put_failure;
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 7, 0)
+		if (nla_put_u64_64bit(msg, SPRDWL_VENDOR_ATTR_FTM_MEAS_T1,
+				res->meas[i].t1, 0) ||
+		    nla_put_u64_64bit(msg, SPRDWL_VENDOR_ATTR_FTM_MEAS_T2,
+				res->meas[i].t2, 0) ||
+		    nla_put_u64_64bit(msg, SPRDWL_VENDOR_ATTR_FTM_MEAS_T3,
+				res->meas[i].t3, 0) ||
+		    nla_put_u64_64bit(msg, SPRDWL_VENDOR_ATTR_FTM_MEAS_T4,
+				res->meas[i].t4, 0))
+			goto out_put_failure;
+#else
+		if (nla_put_u64(msg, SPRDWL_VENDOR_ATTR_FTM_MEAS_T1,
+				res->meas[i].t1) ||
+		    nla_put_u64(msg, SPRDWL_VENDOR_ATTR_FTM_MEAS_T2,
+				res->meas[i].t2) ||
+		    nla_put_u64(msg, SPRDWL_VENDOR_ATTR_FTM_MEAS_T3,
+				res->meas[i].t3) ||
+		    nla_put_u64(msg, SPRDWL_VENDOR_ATTR_FTM_MEAS_T4,
+				res->meas[i].t4))
+			goto out_put_failure;
+#endif
+		nla_nest_end(msg, nl_f);
+	}
+	nla_nest_end(msg, nl_mres);
+	return 0;
+out_put_failure:
+	wl_err("%s: fail to append peer result\n", __func__);
+	return -ENOBUFS;
+}
+
+static void sprdwl_ftm_send_meas_result(struct sprdwl_priv *priv,
+					struct sprdwl_ftm_peer_meas_res *res)
+{
+	struct sk_buff *skb = NULL;
+	struct nlattr *nl_res;
+	int rc = 0;
+
+	wl_info("sending %d results for peer %pM\n",
+		res->n_meas, res->mac_addr);
+
+	skb = cfg80211_vendor_event_alloc(
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 4, 83)
+				priv->wiphy, NULL,
+#else
+				priv->wiphy,
+#endif
+				FTM_MEAS_RESULT_MAX_LENGTH,
+				SPRD_VENDOR_EVENT_FTM_MEAS_RESULT_INDEX,
+				GFP_KERNEL);
+	if (!skb) {
+		wl_err("fail to allocate measurement result\n");
+		rc = -ENOMEM;
+		goto out;
+	}
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 7, 0)
+	if (nla_put_u64_64bit(
+		skb, SPRDWL_VENDOR_ATTR_FTM_SESSION_COOKIE,
+		priv->ftm.session_cookie, 0)) {
+#else
+	if (nla_put_u64(
+		skb, SPRDWL_VENDOR_ATTR_FTM_SESSION_COOKIE,
+		priv->ftm.session_cookie)) {
+#endif
+		rc = -ENOBUFS;
+		goto out;
+	}
+
+	nl_res = nla_nest_start(skb,
+				SPRDWL_VENDOR_ATTR_FTM_MEAS_PEER_RESULTS);
+	if (!nl_res) {
+		rc = -ENOBUFS;
+		goto out;
+	}
+
+	rc = sprdwl_ftm_append_peer_meas_res(priv, skb, res);
+	if (rc)
+		goto out;
+
+	nla_nest_end(skb, nl_res);
+	cfg80211_vendor_event(skb, GFP_KERNEL);
+	skb = NULL;
+out:
+	if (skb)
+		kfree_skb(skb);
+	if (rc)
+		wl_err("send peer result failed, err %d\n", rc);
+}
+
+static void sprdwl_ftm_send_peer_res(struct sprdwl_priv *priv)
+{
+	if (!priv->ftm.has_ftm_res || !priv->ftm.ftm_res)
+		return;
+
+	sprdwl_ftm_send_meas_result(priv, priv->ftm.ftm_res);
+	priv->ftm.has_ftm_res = 0;
+	priv->ftm.ftm_res->n_meas = 0;
+}
+
+static int
+sprdwl_ftm_cfg80211_start_session(struct sprdwl_priv *priv,
+				  struct sprdwl_vif *vif,
+				  struct sprdwl_ftm_session_request *request)
+{
+	int ret = 0;
+	bool has_lci = false, has_lcr = false;
+	u8 max_meas = 0, channel, *ptr;
+	u32 i, cmd_len;
+	struct ftm_session_start *cmd;
+	struct sprdwl_msg_buf *msg;
+	struct sprdwl_cmd_rtt *rtt;
+
+	mutex_lock(&priv->ftm.lock);
+	if (priv->ftm.session_started) {
+		wl_err("%s: FTM session already running\n", __func__);
+		ret = -EALREADY;
+		goto out;
+	}
+
+	for (i = 0; i < request->n_peers; i++) {
+		if (request->peers[i].flags &
+		    SPRDWL_VENDOR_ATTR_FTM_PEER_MEAS_FLAG_LCI)
+			has_lci = true;
+		if (request->peers[i].flags &
+		    SPRDWL_VENDOR_ATTR_FTM_PEER_MEAS_FLAG_LCR)
+			has_lcr = true;
+		max_meas = max(max_meas,
+			       request->peers[i].params.meas_per_burst);
+	}
+
+	priv->ftm.ftm_res = kzalloc(sizeof(*priv->ftm.ftm_res) +
+		      max_meas * sizeof(struct sprdwl_ftm_peer_meas) +
+		      (has_lci ? FTM_MAX_LCI_LENGTH : 0) +
+		      (has_lcr ? FTM_MAX_LCR_LENGTH : 0), GFP_KERNEL);
+	if (!priv->ftm.ftm_res) {
+		ret = -ENOMEM;
+		goto out;
+	}
+	ptr = (u8 *)priv->ftm.ftm_res;
+	ptr += sizeof(struct sprdwl_ftm_peer_meas_res) +
+	       max_meas * sizeof(struct sprdwl_ftm_peer_meas);
+	if (has_lci) {
+		priv->ftm.ftm_res->lci = ptr;
+		ptr += FTM_MAX_LCI_LENGTH;
+	}
+	if (has_lcr)
+		priv->ftm.ftm_res->lcr = ptr;
+	priv->ftm.max_ftm_meas = max_meas;
+
+	cmd_len = sizeof(struct ftm_session_start) +
+		  request->n_peers * sizeof(struct ftm_dest_info);
+	cmd = kzalloc(cmd_len, GFP_KERNEL);
+	if (!cmd) {
+		ret = -ENOMEM;
+		goto out_ftm_res;
+	}
+
+	cmd->session_id = cpu_to_le32(FTM_ESSION_ID);
+	cmd->num_of_dest = cpu_to_le16(request->n_peers);
+	for (i = 0; i < request->n_peers; i++) {
+		ether_addr_copy(cmd->dest_info[i].dst_mac,
+				request->peers[i].mac_addr);
+		channel = sprdwl_ftm_get_channel(priv->wiphy,
+						 request->peers[i].mac_addr,
+						 request->peers[i].freq);
+		if (!channel) {
+			wl_err("%s: can't find FTM target at index %d\n",
+			       __func__, i);
+			ret = -EINVAL;
+			goto out_cmd;
+		}
+		cmd->dest_info[i].channel = channel - 1;
+		if (request->peers[i].flags &
+		    SPRDWL_VENDOR_ATTR_FTM_PEER_MEAS_FLAG_SECURE) {
+			cmd->dest_info[i].flags |=
+				FTM_SESSION_START_FLAG_SECURED;
+			cmd->dest_info[i].initial_token =
+				request->peers[i].secure_token_id;
+		} else {
+			cmd->dest_info[i].initial_token =
+				FTM_DEFAULT_INITIAL_TOKEN;
+		}
+		if (request->peers[i].flags &
+		    SPRDWL_VENDOR_ATTR_FTM_PEER_MEAS_FLAG_ASAP)
+			cmd->dest_info[i].flags |=
+				FTM_SESSION_START_FLAG_ASAP;
+		if (request->peers[i].flags &
+		    SPRDWL_VENDOR_ATTR_FTM_PEER_MEAS_FLAG_LCI)
+			cmd->dest_info[i].flags |=
+				FTM_SESSION_START_FLAG_LCI_REQ;
+		if (request->peers[i].flags &
+		    SPRDWL_VENDOR_ATTR_FTM_PEER_MEAS_FLAG_LCR)
+			cmd->dest_info[i].flags |=
+				FTM_SESSION_START_FLAG_LCR_REQ;
+		cmd->dest_info[i].num_of_ftm_per_burst =
+			request->peers[i].params.meas_per_burst;
+		cmd->dest_info[i].num_of_bursts_exp =
+			request->peers[i].params.num_of_bursts_exp;
+		cmd->dest_info[i].burst_duration =
+			request->peers[i].params.burst_duration;
+		cmd->dest_info[i].burst_period =
+			cpu_to_le16(request->peers[i].params.burst_period);
+	}
+
+	/* send range request data to the FW */
+	msg = sprdwl_cmd_getbuf(priv, sizeof(struct sprdwl_cmd_rtt) + cmd_len,
+				vif->ctx_id, SPRDWL_HEAD_RSP, WIFI_CMD_RTT);
+	if (!msg) {
+		ret = -ENOMEM;
+		goto out_cmd;
+	}
+	rtt = (struct sprdwl_cmd_rtt *)msg->data;
+	rtt->sub_cmd = RTT_GET_CAPABILITIES;
+	rtt->len = cmd_len;
+	memcpy(rtt->data, cmd, cmd_len);
+
+	ret = sprdwl_cmd_send_recv(priv, msg,
+				   CMD_WAIT_TIMEOUT, NULL, 0);
+	if (ret) {
+		wl_ndev_log(L_ERR, vif->ndev, "%s: ret=%d\n", __func__, ret);
+	} else {
+		priv->ftm.session_cookie = request->session_cookie;
+		priv->ftm.session_started = 1;
+	}
+out_cmd:
+	kfree(cmd);
+out_ftm_res:
+	if (ret) {
+		kfree(priv->ftm.ftm_res);
+		priv->ftm.ftm_res = NULL;
+	}
+out:
+	mutex_unlock(&priv->ftm.lock);
+	return ret;
+}
+
+static void
+sprdwl_ftm_session_ended(struct sprdwl_priv *priv, u32 status)
+{
+	struct sk_buff *skb = NULL;
+
+	mutex_lock(&priv->ftm.lock);
+
+	if (!priv->ftm.session_started) {
+		wl_err("%s: FTM session not started, ignoring\n", __func__);
+		return;
+	}
+
+	wl_info("%s: finishing FTM session\n", __func__);
+
+	/* send left-over results if any */
+	sprdwl_ftm_send_peer_res(priv);
+
+	priv->ftm.session_started = 0;
+	kfree(priv->ftm.ftm_res);
+	priv->ftm.ftm_res = NULL;
+
+	skb = cfg80211_vendor_event_alloc(
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 4, 83)
+		priv->wiphy, NULL,
+#else
+		priv->wiphy,
+#endif
+		FTM_NL_EXTRA_ALLOC,
+		SPRD_VENDOR_EVENT_FTM_SESSION_DONE_INDEX,
+		GFP_KERNEL);
+	if (!skb)
+		goto out;
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 7, 0)
+	if (nla_put_u64_64bit(skb,
+				SPRDWL_VENDOR_ATTR_FTM_SESSION_COOKIE,
+				priv->ftm.session_cookie, 0) ||
+	    nla_put_u32(skb,
+			SPRDWL_VENDOR_ATTR_LOC_SESSION_STATUS, status)) {
+#else
+	if (nla_put_u64(skb,
+			SPRDWL_VENDOR_ATTR_FTM_SESSION_COOKIE,
+			priv->ftm.session_cookie) ||
+	    nla_put_u32(skb,
+			SPRDWL_VENDOR_ATTR_LOC_SESSION_STATUS, status)) {
+#endif
+		wl_err("%s: failed to fill session done event\n", __func__);
+		goto out;
+	}
+	cfg80211_vendor_event(skb, GFP_KERNEL);
+	skb = NULL;
+out:
+	kfree_skb(skb);
+	mutex_unlock(&priv->ftm.lock);
+}
+
+void sprdwl_ftm_event_per_dest_res(struct sprdwl_priv *priv,
+				   struct ftm_per_dest_res *res)
+{
+	u32 i, index;
+	__le64 tmp = 0;
+	u8 n_meas;
+
+	mutex_lock(&priv->ftm.lock);
+
+	if (!priv->ftm.session_started || !priv->ftm.ftm_res) {
+		wl_err("%s: Session not running, ignoring res event\n",
+		       __func__);
+		goto out;
+	}
+	if (priv->ftm.has_ftm_res &&
+	    !ether_addr_equal(res->dst_mac, priv->ftm.ftm_res->mac_addr)) {
+		wl_err("%s: previous peer not properly terminated\n",
+		       __func__);
+		sprdwl_ftm_send_peer_res(priv);
+	}
+
+	if (!priv->ftm.has_ftm_res) {
+		ether_addr_copy(priv->ftm.ftm_res->mac_addr, res->dst_mac);
+		priv->ftm.has_ftm_res = 1;
+	}
+
+	n_meas = res->actual_ftm_per_burst;
+	switch (res->status) {
+	case FTM_PER_DEST_RES_NO_ERROR:
+		priv->ftm.ftm_res->status =
+			SPRDWL_VENDOR_ATTR_FTM_PEER_RES_STATUS_OK;
+		break;
+	case FTM_PER_DEST_RES_TX_RX_FAIL:
+		/* FW reports corrupted results here, discard. */
+		n_meas = 0;
+		priv->ftm.ftm_res->status =
+			SPRDWL_VENDOR_ATTR_FTM_PEER_RES_STATUS_OK;
+		break;
+	case FTM_PER_DEST_RES_PARAM_DONT_MATCH:
+		priv->ftm.ftm_res->status =
+			SPRDWL_VENDOR_ATTR_FTM_PEER_RES_STATUS_INVALID;
+		break;
+	default:
+		wl_err("%s: unexpected status %d\n", __func__, res->status);
+		priv->ftm.ftm_res->status =
+			SPRDWL_VENDOR_ATTR_FTM_PEER_RES_STATUS_INVALID;
+		break;
+	}
+
+	for (i = 0; i < n_meas; i++) {
+		index = priv->ftm.ftm_res->n_meas;
+		if (index >= priv->ftm.max_ftm_meas) {
+			wl_info("%s: Too many measurements\n", __func__);
+			break;
+		}
+		memcpy(&tmp, res->responder_ftm_res[i].t1,
+		       sizeof(res->responder_ftm_res[i].t1));
+		priv->ftm.ftm_res->meas[index].t1 = le64_to_cpu(tmp);
+		memcpy(&tmp, res->responder_ftm_res[i].t2,
+		       sizeof(res->responder_ftm_res[i].t2));
+		priv->ftm.ftm_res->meas[index].t2 = le64_to_cpu(tmp);
+		memcpy(&tmp, res->responder_ftm_res[i].t3,
+		       sizeof(res->responder_ftm_res[i].t3));
+		priv->ftm.ftm_res->meas[index].t3 = le64_to_cpu(tmp);
+		memcpy(&tmp, res->responder_ftm_res[i].t4,
+		       sizeof(res->responder_ftm_res[i].t4));
+		priv->ftm.ftm_res->meas[index].t4 = le64_to_cpu(tmp);
+		priv->ftm.ftm_res->n_meas++;
+	}
+
+	if (res->flags & FTM_PER_DEST_RES_BURST_REPORT_END)
+		sprdwl_ftm_send_peer_res(priv);
+out:
+	mutex_unlock(&priv->ftm.lock);
+}
+
+int sprdwl_event_ftm(struct sprdwl_vif *vif, u8 *data, u16 len)
+{
+	struct sprdwl_priv *priv = vif->priv;
+	u8 sub_event;
+	u32 status;
+	struct ftm_per_dest_res *res;
+
+	memcpy(&sub_event, data, sizeof(sub_event));
+	data += sizeof(sub_event);
+	len -= sizeof(sub_event);
+
+	switch (sub_event) {
+	case RTT_SESSION_END:
+		memcpy(&status, data, sizeof(status));
+		sprdwl_ftm_session_ended(priv, status);
+		break;
+	case RTT_PER_DEST_RES:
+		res = (struct ftm_per_dest_res *)data;
+		sprdwl_ftm_event_per_dest_res(priv, res);
+		break;
+	default:
+		wl_ndev_log(L_ERR, vif->ndev, "%s: unknown FTM event\n", __func__);
+		break;
+	}
+	return 0;
+}
+
+int sprdwl_ftm_get_capabilities(struct wiphy *wiphy,
+				struct wireless_dev *wdev,
+				const void *data, int len)
+{
+	struct sprdwl_msg_buf *msg;
+	struct sprdwl_cmd_rtt *cmd;
+	struct sprdwl_vif *vif = netdev_priv(wdev->netdev);
+	u8 rsp[RTT_RSP_LEN] = {0x0};
+	u16 rsp_len = RTT_RSP_LEN;
+	int ret = 0;
+	struct sk_buff *skb;
+	struct nlattr *attr;
+
+	/* get the capabilities from the FW */
+	msg = sprdwl_cmd_getbuf(vif->priv, sizeof(struct sprdwl_cmd_rtt) + len,
+				vif->ctx_id, SPRDWL_HEAD_RSP, WIFI_CMD_RTT);
+	if (!msg)
+		return -ENOMEM;
+	cmd = (struct sprdwl_cmd_rtt *)msg->data;
+	cmd->sub_cmd = RTT_GET_CAPABILITIES;
+	cmd->len = len;
+	memcpy(cmd->data, data, len);
+
+	ret = sprdwl_cmd_send_recv(vif->priv, msg,
+				   CMD_WAIT_TIMEOUT, rsp, &rsp_len);
+	if (ret) {
+		wl_ndev_log(L_ERR, vif->ndev,
+			   "%s: ret=%d, rsp_len=%d\n", __func__, ret, rsp_len);
+	}
+
+	/* report capabilities */
+	skb = cfg80211_vendor_cmd_alloc_reply_skb(wiphy, RTT_RSP_LEN);
+	if (!skb)
+		return -ENOMEM;
+	attr = nla_nest_start(skb, SPRDWL_VENDOR_ATTR_LOC_CAPA);
+	if (!attr ||
+	    nla_put_u32(skb, SPRDWL_VENDOR_ATTR_LOC_CAPA_FLAGS,
+			SPRDWL_VENDOR_ATTR_LOC_CAPA_FLAG_FTM_RESPONDER |
+			SPRDWL_VENDOR_ATTR_LOC_CAPA_FLAG_FTM_INITIATOR |
+			SPRDWL_VENDOR_ATTR_LOC_CAPA_FLAG_ASAP |
+			SPRDWL_VENDOR_ATTR_LOC_CAPA_FLAG_AOA) ||
+	    nla_put_u16(skb, SPRDWL_VENDOR_ATTR_FTM_CAPA_MAX_NUM_SESSIONS,
+			1) ||
+	    nla_put_u16(skb, SPRDWL_VENDOR_ATTR_FTM_CAPA_MAX_NUM_PEERS, 1) ||
+	    nla_put_u8(skb, SPRDWL_VENDOR_ATTR_FTM_CAPA_MAX_NUM_BURSTS_EXP,
+		       0) ||
+	    nla_put_u8(skb, SPRDWL_VENDOR_ATTR_FTM_CAPA_MAX_MEAS_PER_BURST,
+		       4) ||
+	    nla_put_u32(skb, SPRDWL_VENDOR_ATTR_AOA_CAPA_SUPPORTED_TYPES,
+			BIT(SPRDWL_VENDOR_ATTR_AOA_TYPE_TOP_CIR_PHASE))) {
+		wl_ndev_log(L_ERR, vif->ndev,
+			   "%s: fail to fill capabilities\n", __func__);
+		kfree_skb(skb);
+		return -ENOMEM;
+	}
+	nla_nest_end(skb, attr);
+
+	return cfg80211_vendor_cmd_reply(skb);
+}
+
+int sprdwl_ftm_start_session(struct wiphy *wiphy,
+			     struct wireless_dev *wdev,
+			     const void *data, int data_len)
+{
+	struct sprdwl_priv *priv = wiphy_priv(wiphy);
+	struct sprdwl_vif *vif = netdev_priv(wdev->netdev);
+	struct sprdwl_ftm_session_request *request;
+	struct nlattr *tb[SPRDWL_VENDOR_ATTR_LOC_MAX + 1];
+	struct nlattr *tb2[SPRDWL_VENDOR_ATTR_FTM_PEER_MAX + 1];
+	struct nlattr *peer;
+	int rc, n_peers = 0, index = 0, rem;
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 14, 0)
+	rc = nla_parse(tb, SPRDWL_VENDOR_ATTR_LOC_MAX, data, data_len,
+		       sprdwl_nl80211_loc_policy, NULL);
+#else
+	rc = nla_parse(tb, SPRDWL_VENDOR_ATTR_LOC_MAX, data, data_len,
+			sprdwl_nl80211_loc_policy);
+#endif
+	if (rc) {
+		wl_ndev_log(L_ERR, vif->ndev, "%s: invalid FTM attribute\n", __func__);
+		return rc;
+	}
+
+	if (!tb[SPRDWL_VENDOR_ATTR_FTM_MEAS_PEERS]) {
+		wl_ndev_log(L_ERR, vif->ndev, "%s: no peers specified\n", __func__);
+		return -EINVAL;
+	}
+
+	if (!tb[SPRDWL_VENDOR_ATTR_FTM_SESSION_COOKIE]) {
+		wl_ndev_log(L_ERR, vif->ndev,
+			   "%s: session cookie not specified\n", __func__);
+		return -EINVAL;
+	}
+
+	nla_for_each_nested(peer, tb[SPRDWL_VENDOR_ATTR_FTM_MEAS_PEERS],
+			    rem)
+		n_peers++;
+
+	if (!n_peers) {
+		wl_ndev_log(L_ERR, vif->ndev, "%s: empty peer list\n", __func__);
+		return -EINVAL;
+	}
+
+	/* for now only allow measurement for a single peer */
+	if (n_peers != 1) {
+		wl_ndev_log(L_ERR, vif->ndev,
+			   "%s: only single peer allowed\n", __func__);
+		return -EINVAL;
+	}
+
+	request = kzalloc(sizeof(*request) +
+			  n_peers * sizeof(struct sprdwl_ftm_meas_peer_info),
+			  GFP_KERNEL);
+	if (!request)
+		return -ENOMEM;
+
+	request->session_cookie =
+		nla_get_u64(tb[SPRDWL_VENDOR_ATTR_FTM_SESSION_COOKIE]);
+	request->n_peers = n_peers;
+	nla_for_each_nested(peer, tb[SPRDWL_VENDOR_ATTR_FTM_MEAS_PEERS],
+			    rem) {
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 14, 0)
+		rc = nla_parse_nested(tb2, SPRDWL_VENDOR_ATTR_FTM_PEER_MAX,
+				      peer, sprdwl_nl80211_ftm_peer_policy, NULL);
+#else
+		rc = nla_parse_nested(tb2, SPRDWL_VENDOR_ATTR_FTM_PEER_MAX,
+				peer, sprdwl_nl80211_ftm_peer_policy);
+#endif
+		if (rc) {
+			wl_ndev_log(L_ERR, vif->ndev,
+				   "%s: invalid peer attribute\n", __func__);
+			goto out;
+		}
+		if (!tb2[SPRDWL_VENDOR_ATTR_FTM_PEER_MAC_ADDR] ||
+		    nla_len(tb2[SPRDWL_VENDOR_ATTR_FTM_PEER_MAC_ADDR])
+			    != ETH_ALEN) {
+			wl_ndev_log(L_ERR, vif->ndev,
+				   "%s: peer MAC address missing or invalid\n",
+				   __func__);
+			rc = -EINVAL;
+			goto out;
+		}
+		memcpy(request->peers[index].mac_addr,
+		       nla_data(tb2[SPRDWL_VENDOR_ATTR_FTM_PEER_MAC_ADDR]),
+		       ETH_ALEN);
+		if (tb2[SPRDWL_VENDOR_ATTR_FTM_PEER_FREQ])
+			request->peers[index].freq = nla_get_u32(
+				tb2[SPRDWL_VENDOR_ATTR_FTM_PEER_FREQ]);
+		if (tb2[SPRDWL_VENDOR_ATTR_FTM_PEER_MEAS_FLAGS])
+			request->peers[index].flags = nla_get_u32(
+				tb2[SPRDWL_VENDOR_ATTR_FTM_PEER_MEAS_FLAGS]);
+		if (tb2[SPRDWL_VENDOR_ATTR_FTM_PEER_SECURE_TOKEN_ID])
+			request->peers[index].secure_token_id = nla_get_u8(
+			   tb2[SPRDWL_VENDOR_ATTR_FTM_PEER_SECURE_TOKEN_ID]);
+		rc = sprdwl_ftm_parse_meas_params(
+			vif,
+			tb2[SPRDWL_VENDOR_ATTR_FTM_PEER_MEAS_PARAMS],
+			&request->peers[index].params);
+		if (!rc)
+			rc = sprdwl_ftm_validate_meas_params(
+				vif, &request->peers[index].params);
+		if (rc)
+			goto out;
+		index++;
+	}
+
+	rc = sprdwl_ftm_cfg80211_start_session(priv, vif, request);
+out:
+	kfree(request);
+	return rc;
+}
+
+int sprdwl_ftm_abort_session(struct wiphy *wiphy,
+			     struct wireless_dev *wdev,
+			     const void *data, int len)
+{
+	struct sprdwl_msg_buf *msg;
+	struct sprdwl_cmd_rtt *cmd;
+	struct sprdwl_priv *priv = wiphy_priv(wiphy);
+	struct sprdwl_vif *vif = netdev_priv(wdev->netdev);
+	int ret;
+
+	mutex_lock(&priv->ftm.lock);
+	if (!priv->ftm.session_started) {
+		wl_ndev_log(L_ERR, vif->ndev,
+			   "%s: FTM session not started\n", __func__);
+		return -EAGAIN;
+	}
+	/* send cancel range request */
+	msg = sprdwl_cmd_getbuf(priv, sizeof(struct sprdwl_cmd_rtt) + len,
+				vif->ctx_id, 0, WIFI_CMD_RTT);
+	if (!msg)
+		return -ENOMEM;
+	cmd = (struct sprdwl_cmd_rtt *)msg->data;
+	cmd->sub_cmd = RTT_RANGE_CANCEL;
+	cmd->len = len;
+	memcpy(cmd->data, data, len);
+
+	ret = sprdwl_cmd_send_recv(priv, msg,
+				   CMD_WAIT_TIMEOUT, NULL, 0);
+	if (ret)
+		wl_ndev_log(L_ERR, vif->ndev, "%s: ret=%d\n", __func__, ret);
+
+	mutex_unlock(&priv->ftm.lock);
+
+	return ret;
+}
+
+int sprdwl_ftm_get_responder_info(struct wiphy *wiphy,
+				  struct wireless_dev *wdev,
+				  const void *data, int len)
+{
+	struct sprdwl_vif *vif = netdev_priv(wdev->netdev);
+
+	/* get responder info */
+	wl_ndev_log(L_INFO, vif->ndev, "%s: not implemented yet\n", __func__);
+	return -ENOTSUPP;
+}
+
+int sprdwl_ftm_configure_responder(struct wiphy *wiphy,
+				   struct wireless_dev *wdev,
+				   const void *data, int data_len)
+{
+	struct sprdwl_vif *vif = netdev_priv(wdev->netdev);
+
+	/* enable or disable responder */
+	wl_ndev_log(L_INFO, vif->ndev, "%s: not implemented yet\n", __func__);
+	return -ENOTSUPP;
+}
+
+void sprdwl_ftm_init(struct sprdwl_priv *priv)
+{
+	mutex_init(&priv->ftm.lock);
+}
+
+void sprdwl_ftm_deinit(struct sprdwl_priv *priv)
+{
+	kfree(priv->ftm.ftm_res);
+}
+
+void sprdwl_ftm_stop_operations(struct sprdwl_priv *priv)
+{
+	sprdwl_ftm_session_ended(
+		priv, SPRDWL_VENDOR_ATTR_LOC_SESSION_STATUS_ABORTED);
+}
+
diff --git a/drivers/net/wireless/uwe5622/unisocwifi/rtt.h b/drivers/net/wireless/uwe5622/unisocwifi/rtt.h
new file mode 100644
index 000000000000..b58deeb6dcfd
--- /dev/null
+++ b/drivers/net/wireless/uwe5622/unisocwifi/rtt.h
@@ -0,0 +1,528 @@
+#ifndef __SPRD_RTT_H__
+#define __SPRD_RTT_H__
+
+#include "vendor.h"
+
+/* FTM/indoor location subcommands */
+enum sprd_ftm_vendor_subcmds {
+	SPRD_NL80211_VENDOR_SUBCMD_LOC_GET_CAPA = 128,
+	SPRD_NL80211_VENDOR_SUBCMD_FTM_START_SESSION = 129,
+	SPRD_NL80211_VENDOR_SUBCMD_FTM_ABORT_SESSION = 130,
+	SPRD_NL80211_VENDOR_SUBCMD_FTM_MEAS_RESULT = 131,
+	SPRD_NL80211_VENDOR_SUBCMD_FTM_SESSION_DONE = 132,
+	SPRD_NL80211_VENDOR_SUBCMD_FTM_CFG_RESPONDER = 133,
+	SPRD_NL80211_VENDOR_SUBCMD_AOA_MEAS = 134,
+	SPRD_NL80211_VENDOR_SUBCMD_AOA_ABORT_MEAS = 135,
+	SPRD_NL80211_VENDOR_SUBCMD_AOA_MEAS_RESULT = 136,
+};
+
+/**
+ * enum sprdwl_vendor_attr_loc - attributes for FTM and AOA commands
+ *
+ * @SPRDWL_VENDOR_ATTR_FTM_SESSION_COOKIE: Session cookie, specified in
+ *  %SPRD_NL80211_VENDOR_SUBCMD_FTM_START_SESSION. It will be provided by driver
+ *  events and can be used to identify events targeted for this session.
+ * @SPRDWL_VENDOR_ATTR_LOC_CAPA: Nested attribute containing extra
+ *  FTM/AOA capabilities, returned by %SPRD_NL80211_VENDOR_SUBCMD_LOC_GET_CAPA.
+ *  see %enum sprdwl_vendor_attr_loc_capa.
+ * @SPRDWL_VENDOR_ATTR_FTM_MEAS_PEERS: array of nested attributes
+ *  containing information about each peer in measurement session
+ *  request. See %enum sprdwl_vendor_attr_peer_info for supported
+ *  attributes for each peer
+ * @SPRDWL_VENDOR_ATTR_FTM_PEER_RESULTS: nested attribute containing
+ *  measurement results for a peer. reported by the
+ *  %SPRD_NL80211_VENDOR_SUBCMD_FTM_MEAS_RESULT event.
+ *  See %enum sprdwl_vendor_attr_peer_result for list of supported
+ *  attributes.
+ * @SPRDWL_VENDOR_ATTR_FTM_RESPONDER_ENABLE: flag attribute for
+ *  enabling or disabling responder functionality.
+ * @SPRDWL_VENDOR_ATTR_FTM_LCI: used in the
+ *  %SPRD_NL80211_VENDOR_SUBCMD_FTM_CFG_RESPONDER command in order to
+ *  specify the LCI report that will be sent by the responder during
+ *  a measurement exchange. The format is defined in IEEE P802.11-REVmc/D5.0,
+ *  9.4.2.22.10
+ * @SPRDWL_VENDOR_ATTR_FTM_LCR: provided with the
+ *  %SPRD_NL80211_VENDOR_SUBCMD_FTM_CFG_RESPONDER command in order to
+ *  specify the location civic report that will be sent by the responder during
+ *  a measurement exchange. The format is defined in IEEE P802.11-REVmc/D5.0,
+ *  9.4.2.22.13
+ * @SPRDWL_VENDOR_ATTR_LOC_SESSION_STATUS: session/measurement completion
+ *  status code, reported in %SPRD_NL80211_VENDOR_SUBCMD_FTM_SESSION_DONE
+ *  and %SPRD_NL80211_VENDOR_SUBCMD_AOA_MEAS_RESULT
+ * @SPRDWL_VENDOR_ATTR_FTM_INITIAL_TOKEN: initial dialog token used
+ *  by responder (0 if not specified)
+ * @SPRDWL_VENDOR_ATTR_AOA_TYPE: AOA measurement type. Requested in
+ *  %SPRD_NL80211_VENDOR_SUBCMD_AOA_MEAS and optionally in
+ *  %SPRD_NL80211_VENDOR_SUBCMD_FTM_START_SESSION if AOA measurements
+ *  are needed as part of an FTM session.
+ *  Reported by SPRD_NL80211_VENDOR_SUBCMD_AOA_MEAS_RESULT.
+ *  See enum sprdwl_vendor_attr_aoa_type.
+ * @SPRDWL_VENDOR_ATTR_LOC_ANTENNA_ARRAY_MASK: bit mask indicating
+ *  which antenna arrays were used in location measurement.
+ *  Reported in %SPRD_NL80211_VENDOR_SUBCMD_FTM_MEAS_RESULT and
+ *  %SPRD_NL80211_VENDOR_SUBCMD_AOA_MEAS_RESULT
+ * @SPRDWL_VENDOR_ATTR_AOA_MEAS_RESULT: AOA measurement data.
+ *  Its contents depends on the AOA type and antenna array mask:
+ *  %SPRDWL_VENDOR_ATTR_AOA_TYPE_TOP_CIR_PHASE: array of U16 values,
+ *  phase of the strongest CIR path for each antenna in the measured
+ *  array(s).
+ *  %SPRDWL_VENDOR_ATTR_AOA_TYPE_TOP_CIR_PHASE_AMP: array of 2 U16
+ *  values, phase and amplitude of the strongest CIR path for each
+ *  antenna in the measured array(s)
+ * @SPRDWL_VENDOR_ATTR_FREQ: Frequency where peer is listening, in MHz.
+ *  Unsigned 32 bit value.
+ */
+enum sprdwl_vendor_attr_loc {
+	/* we reuse these attributes */
+	SPRDWL_VENDOR_ATTR_MAC_ADDR = 6,
+	SPRDWL_VENDOR_ATTR_PAD = 13,
+	SPRDWL_VENDOR_ATTR_FTM_SESSION_COOKIE = 14,
+	SPRDWL_VENDOR_ATTR_LOC_CAPA = 15,
+	SPRDWL_VENDOR_ATTR_FTM_MEAS_PEERS = 16,
+	SPRDWL_VENDOR_ATTR_FTM_MEAS_PEER_RESULTS = 17,
+	SPRDWL_VENDOR_ATTR_FTM_RESPONDER_ENABLE = 18,
+	SPRDWL_VENDOR_ATTR_FTM_LCI = 19,
+	SPRDWL_VENDOR_ATTR_FTM_LCR = 20,
+	SPRDWL_VENDOR_ATTR_LOC_SESSION_STATUS = 21,
+	SPRDWL_VENDOR_ATTR_FTM_INITIAL_TOKEN = 22,
+	SPRDWL_VENDOR_ATTR_AOA_TYPE = 23,
+	SPRDWL_VENDOR_ATTR_LOC_ANTENNA_ARRAY_MASK = 24,
+	SPRDWL_VENDOR_ATTR_AOA_MEAS_RESULT = 25,
+	SPRDWL_VENDOR_ATTR_FREQ = 28,
+	/* keep last */
+	SPRDWL_VENDOR_ATTR_LOC_AFTER_LAST,
+	SPRDWL_VENDOR_ATTR_LOC_MAX = SPRDWL_VENDOR_ATTR_LOC_AFTER_LAST - 1,
+};
+
+/**
+ * enum sprdwl_vendor_attr_loc_capa - indoor location capabilities
+ *
+ * @SPRDWL_VENDOR_ATTR_LOC_CAPA_FLAGS: various flags. See
+ *  %enum sprdwl_vendor_attr_loc_capa_flags
+ * @SPRDWL_VENDOR_ATTR_FTM_CAPA_MAX_NUM_SESSIONS: Maximum number
+ *  of measurement sessions that can run concurrently.
+ *  Default is one session (no session concurrency)
+ * @SPRDWL_VENDOR_ATTR_FTM_CAPA_MAX_NUM_PEERS: The total number of unique
+ *  peers that are supported in running sessions. For example,
+ *  if the value is 8 and maximum number of sessions is 2, you can
+ *  have one session with 8 unique peers, or 2 sessions with 4 unique
+ *  peers each, and so on.
+ * @SPRDWL_VENDOR_ATTR_FTM_CAPA_MAX_NUM_BURSTS_EXP: Maximum number
+ *  of bursts per peer, as an exponent (2^value). Default is 0,
+ *  meaning no multi-burst support.
+ * @SPRDWL_VENDOR_ATTR_FTM_CAPA_MAX_MEAS_PER_BURST: Maximum number
+ *  of measurement exchanges allowed in a single burst
+ * @SPRDWL_VENDOR_ATTR_AOA_CAPA_SUPPORTED_TYPES: Supported AOA measurement
+ *  types. A bit mask (unsigned 32 bit value), each bit corresponds
+ *  to an AOA type as defined by %enum qca_vendor_attr_aoa_type.
+ */
+enum sprdwl_vendor_attr_loc_capa {
+	SPRDWL_VENDOR_ATTR_LOC_CAPA_INVALID,
+	SPRDWL_VENDOR_ATTR_LOC_CAPA_FLAGS,
+	SPRDWL_VENDOR_ATTR_FTM_CAPA_MAX_NUM_SESSIONS,
+	SPRDWL_VENDOR_ATTR_FTM_CAPA_MAX_NUM_PEERS,
+	SPRDWL_VENDOR_ATTR_FTM_CAPA_MAX_NUM_BURSTS_EXP,
+	SPRDWL_VENDOR_ATTR_FTM_CAPA_MAX_MEAS_PER_BURST,
+	SPRDWL_VENDOR_ATTR_AOA_CAPA_SUPPORTED_TYPES,
+	/* keep last */
+	SPRDWL_VENDOR_ATTR_LOC_CAPA_AFTER_LAST,
+	SPRDWL_VENDOR_ATTR_LOC_CAPA_MAX =
+		SPRDWL_VENDOR_ATTR_LOC_CAPA_AFTER_LAST - 1,
+};
+
+/**
+ * enum sprdwl_vendor_attr_loc_capa_flags: Indoor location capability flags
+ *
+ * @SPRDWL_VENDOR_ATTR_LOC_CAPA_FLAG_FTM_RESPONDER: Set if driver
+ *  can be configured as an FTM responder (for example, an AP that
+ *  services FTM requests). %SPRD_NL80211_VENDOR_SUBCMD_FTM_CFG_RESPONDER
+ *  will be supported if set.
+ * @SPRDWL_VENDOR_ATTR_LOC_CAPA_FLAG_FTM_INITIATOR: Set if driver
+ *  can run FTM sessions. %SPRD_NL80211_VENDOR_SUBCMD_FTM_START_SESSION
+ *  will be supported if set.
+ * @SPRDWL_VENDOR_ATTR_LOC_CAPA_FLAG_ASAP: Set if FTM responder
+ *  supports immediate (ASAP) response.
+ * @SPRDWL_VENDOR_ATTR_LOC_CAPA_FLAG_AOA: Set if driver supports standalone
+ *  AOA measurement using %SPRD_NL80211_VENDOR_SUBCMD_AOA_MEAS
+ * @SPRDWL_VENDOR_ATTR_LOC_CAPA_FLAG_AOA_IN_FTM: Set if driver supports
+ *  requesting AOA measurements as part of an FTM session.
+ */
+enum sprdwl_vendor_attr_loc_capa_flags {
+	SPRDWL_VENDOR_ATTR_LOC_CAPA_FLAG_FTM_RESPONDER = 1 << 0,
+	SPRDWL_VENDOR_ATTR_LOC_CAPA_FLAG_FTM_INITIATOR = 1 << 1,
+	SPRDWL_VENDOR_ATTR_LOC_CAPA_FLAG_ASAP = 1 << 2,
+	SPRDWL_VENDOR_ATTR_LOC_CAPA_FLAG_AOA = 1 << 3,
+	SPRDWL_VENDOR_ATTR_LOC_CAPA_FLAG_AOA_IN_FTM = 1 << 4,
+};
+
+/**
+ * enum sprdwl_vendor_attr_peer_info: information about
+ *  a single peer in a measurement session.
+ *
+ * @SPRDWL_VENDOR_ATTR_FTM_PEER_MAC_ADDR: The MAC address of the peer.
+ * @SPRDWL_VENDOR_ATTR_FTM_PEER_MEAS_FLAGS: Various flags related
+ *  to measurement. See %enum sprdwl_vendor_attr_ftm_peer_meas_flags.
+ * @SPRDWL_VENDOR_ATTR_FTM_PEER_MEAS_PARAMS: Nested attribute of
+ *  FTM measurement parameters, as specified by IEEE P802.11-REVmc/D7.0,
+ *  9.4.2.167. See %enum sprdwl_vendor_attr_ftm_meas_param for
+ *  list of supported attributes.
+ * @SPRDWL_VENDOR_ATTR_FTM_PEER_SECURE_TOKEN_ID: Initial token ID for
+ *  secure measurement
+ * @SPRDWL_VENDOR_ATTR_FTM_PEER_AOA_BURST_PERIOD: Request AOA
+ *  measurement every _value_ bursts. If 0 or not specified,
+ *  AOA measurements will be disabled for this peer.
+ * @SPRDWL_VENDOR_ATTR_FTM_PEER_FREQ: Frequency in MHz where
+ *  peer is listening. Optional; if not specified, use the
+ *  entry from the kernel scan results cache.
+ */
+enum sprdwl_vendor_attr_ftm_peer_info {
+	SPRDWL_VENDOR_ATTR_FTM_PEER_INVALID,
+	SPRDWL_VENDOR_ATTR_FTM_PEER_MAC_ADDR,
+	SPRDWL_VENDOR_ATTR_FTM_PEER_MEAS_FLAGS,
+	SPRDWL_VENDOR_ATTR_FTM_PEER_MEAS_PARAMS,
+	SPRDWL_VENDOR_ATTR_FTM_PEER_SECURE_TOKEN_ID,
+	SPRDWL_VENDOR_ATTR_FTM_PEER_AOA_BURST_PERIOD,
+	SPRDWL_VENDOR_ATTR_FTM_PEER_FREQ,
+	/* keep last */
+	SPRDWL_VENDOR_ATTR_FTM_PEER_AFTER_LAST,
+	SPRDWL_VENDOR_ATTR_FTM_PEER_MAX =
+		SPRDWL_VENDOR_ATTR_FTM_PEER_AFTER_LAST - 1,
+};
+
+/**
+ * enum sprdwl_vendor_attr_ftm_peer_meas_flags: Measurement request flags,
+ *  per-peer
+ * @SPRDWL_VENDOR_ATTR_FTM_PEER_MEAS_FLAG_ASAP: If set, request
+ *  immediate (ASAP) response from peer
+ * @SPRDWL_VENDOR_ATTR_FTM_PEER_MEAS_FLAG_LCI: If set, request
+ *  LCI report from peer. The LCI report includes the absolute
+ *  location of the peer in "official" coordinates (similar to GPS).
+ *  See IEEE P802.11-REVmc/D7.0, 11.24.6.7 for more information.
+ * @SPRDWL_VENDOR_ATTR_FTM_PEER_MEAS_FLAG_LCR: If set, request
+ *  Location civic report from peer. The LCR includes the location
+ *  of the peer in free-form format. See IEEE P802.11-REVmc/D7.0,
+ *  11.24.6.7 for more information.
+ * @SPRDWL_VENDOR_ATTR_FTM_PEER_MEAS_FLAG_SECURE: If set,
+ *  request a secure measurement.
+ *  %SPRDWL_VENDOR_ATTR_FTM_PEER_SECURE_TOKEN_ID must also be provided.
+ */
+enum sprdwl_vendor_attr_ftm_peer_meas_flags {
+	SPRDWL_VENDOR_ATTR_FTM_PEER_MEAS_FLAG_ASAP	= 1 << 0,
+	SPRDWL_VENDOR_ATTR_FTM_PEER_MEAS_FLAG_LCI	= 1 << 1,
+	SPRDWL_VENDOR_ATTR_FTM_PEER_MEAS_FLAG_LCR	= 1 << 2,
+	SPRDWL_VENDOR_ATTR_FTM_PEER_MEAS_FLAG_SECURE  = 1 << 3,
+};
+
+/**
+ * enum sprdwl_vendor_attr_ftm_meas_param: Measurement parameters
+ *
+ * @SPRDWL_VENDOR_ATTR_FTM_PARAM_MEAS_PER_BURST: Number of measurements
+ *  to perform in a single burst.
+ * @SPRDWL_VENDOR_ATTR_FTM_PARAM_NUM_BURSTS_EXP: Number of bursts to
+ *  perform, specified as an exponent (2^value)
+ * @SPRDWL_VENDOR_ATTR_FTM_PARAM_BURST_DURATION: Duration of burst
+ *  instance, as specified in IEEE P802.11-REVmc/D7.0, 9.4.2.167
+ * @SPRDWL_VENDOR_ATTR_FTM_PARAM_BURST_PERIOD: Time between bursts,
+ *  as specified in IEEE P802.11-REVmc/D7.0, 9.4.2.167. Must
+ *  be larger than %SPRDWL_VENDOR_ATTR_FTM_PARAM_BURST_DURATION
+ */
+enum sprdwl_vendor_attr_ftm_meas_param {
+	SPRDWL_VENDOR_ATTR_FTM_PARAM_INVALID,
+	SPRDWL_VENDOR_ATTR_FTM_PARAM_MEAS_PER_BURST,
+	SPRDWL_VENDOR_ATTR_FTM_PARAM_NUM_BURSTS_EXP,
+	SPRDWL_VENDOR_ATTR_FTM_PARAM_BURST_DURATION,
+	SPRDWL_VENDOR_ATTR_FTM_PARAM_BURST_PERIOD,
+	/* keep last */
+	SPRDWL_VENDOR_ATTR_FTM_PARAM_AFTER_LAST,
+	SPRDWL_VENDOR_ATTR_FTM_PARAM_MAX =
+		SPRDWL_VENDOR_ATTR_FTM_PARAM_AFTER_LAST - 1,
+};
+
+/**
+ * enum sprdwl_vendor_attr_ftm_peer_result: Per-peer results
+ *
+ * @SPRDWL_VENDOR_ATTR_FTM_PEER_RES_MAC_ADDR: MAC address of the reported
+ *  peer
+ * @SPRDWL_VENDOR_ATTR_FTM_PEER_RES_STATUS: Status of measurement
+ *  request for this peer.
+ *  See %enum sprdwl_vendor_attr_ftm_peer_result_status
+ * @SPRDWL_VENDOR_ATTR_FTM_PEER_RES_FLAGS: Various flags related
+ *  to measurement results for this peer.
+ *  See %enum sprdwl_vendor_attr_ftm_peer_result_flags
+ * @SPRDWL_VENDOR_ATTR_FTM_PEER_RES_VALUE_SECONDS: Specified when
+ *  request failed and peer requested not to send an additional request
+ *  for this number of seconds.
+ * @SPRDWL_VENDOR_ATTR_FTM_PEER_RES_LCI: LCI report when received
+ *  from peer. In the format specified by IEEE P802.11-REVmc/D7.0,
+ *  9.4.2.22.10
+ * @SPRDWL_VENDOR_ATTR_FTM_PEER_RES_LCR: Location civic report when
+ *  received from peer.In the format specified by IEEE P802.11-REVmc/D7.0,
+ *  9.4.2.22.13
+ * @SPRDWL_VENDOR_ATTR_FTM_PEER_RES_MEAS_PARAMS: Reported when peer
+ *  overridden some measurement request parameters. See
+ *  enum sprdwl_vendor_attr_ftm_meas_param.
+ * @SPRDWL_VENDOR_ATTR_FTM_PEER_RES_AOA_MEAS: AOA measurement
+ *  for this peer. Same contents as %SPRDWL_VENDOR_ATTR_AOA_MEAS_RESULT
+ * @SPRDWL_VENDOR_ATTR_FTM_PEER_RES_MEAS: Array of measurement
+ *  results. Each entry is a nested attribute defined
+ *  by enum sprdwl_vendor_attr_ftm_meas.
+ */
+enum sprdwl_vendor_attr_ftm_peer_result {
+	SPRDWL_VENDOR_ATTR_FTM_PEER_RES_INVALID,
+	SPRDWL_VENDOR_ATTR_FTM_PEER_RES_MAC_ADDR,
+	SPRDWL_VENDOR_ATTR_FTM_PEER_RES_STATUS,
+	SPRDWL_VENDOR_ATTR_FTM_PEER_RES_FLAGS,
+	SPRDWL_VENDOR_ATTR_FTM_PEER_RES_VALUE_SECONDS,
+	SPRDWL_VENDOR_ATTR_FTM_PEER_RES_LCI,
+	SPRDWL_VENDOR_ATTR_FTM_PEER_RES_LCR,
+	SPRDWL_VENDOR_ATTR_FTM_PEER_RES_MEAS_PARAMS,
+	SPRDWL_VENDOR_ATTR_FTM_PEER_RES_AOA_MEAS,
+	SPRDWL_VENDOR_ATTR_FTM_PEER_RES_MEAS,
+	/* keep last */
+	SPRDWL_VENDOR_ATTR_FTM_PEER_RES_AFTER_LAST,
+	SPRDWL_VENDOR_ATTR_FTM_PEER_RES_MAX =
+		SPRDWL_VENDOR_ATTR_FTM_PEER_RES_AFTER_LAST - 1,
+};
+
+/**
+ * enum sprdwl_vendor_attr_ftm_peer_result_status
+ *
+ * @SPRDWL_VENDOR_ATTR_FTM_PEER_RES_STATUS_OK: Request sent ok and results
+ *  will be provided. Peer may have overridden some measurement parameters,
+ *  in which case overridden parameters will be report by
+ *  %SPRDWL_VENDOR_ATTR_FTM_PEER_RES_MEAS_PARAMS attribute
+ * @SPRDWL_VENDOR_ATTR_FTM_PEER_RES_STATUS_INCAPABLE: Peer is incapable
+ *  of performing the measurement request. No more results will be sent
+ *  for this peer in this session.
+ * @SPRDWL_VENDOR_ATTR_FTM_PEER_RES_STATUS_FAILED: Peer reported request
+ *  failed, and requested not to send an additional request for number
+ *  of seconds specified by %SPRDWL_VENDOR_ATTR_FTM_PEER_RES_VALUE_SECONDS
+ *  attribute.
+ * @SPRDWL_VENDOR_ATTR_FTM_PEER_RES_STATUS_INVALID: Request validation
+ *  failed. Request was not sent over the air.
+ */
+enum sprdwl_vendor_attr_ftm_peer_result_status {
+	SPRDWL_VENDOR_ATTR_FTM_PEER_RES_STATUS_OK,
+	SPRDWL_VENDOR_ATTR_FTM_PEER_RES_STATUS_INCAPABLE,
+	SPRDWL_VENDOR_ATTR_FTM_PEER_RES_STATUS_FAILED,
+	SPRDWL_VENDOR_ATTR_FTM_PEER_RES_STATUS_INVALID,
+};
+
+/**
+ * enum sprdwl_vendor_attr_ftm_peer_result_flags : Various flags
+ *  for measurement result, per-peer
+ *
+ * @SPRDWL_VENDOR_ATTR_FTM_PEER_RES_FLAG_DONE: If set,
+ *  measurement completed for this peer. No more results will be reported
+ *  for this peer in this session.
+ */
+enum sprdwl_vendor_attr_ftm_peer_result_flags {
+	SPRDWL_VENDOR_ATTR_FTM_PEER_RES_FLAG_DONE = 1 << 0,
+};
+
+/**
+ * enum qca_vendor_attr_loc_session_status: Session completion status code
+ *
+ * @SPRDWL_VENDOR_ATTR_LOC_SESSION_STATUS_OK: Session completed
+ *  successfully.
+ * @SPRDWL_VENDOR_ATTR_LOC_SESSION_STATUS_ABORTED: Session aborted
+ *  by request
+ * @SPRDWL_VENDOR_ATTR_LOC_SESSION_STATUS_INVALID: Session request
+ *  was invalid and was not started
+ * @SPRDWL_VENDOR_ATTR_LOC_SESSION_STATUS_FAILED: Session had an error
+ *  and did not complete normally (for example out of resources)
+ *
+ */
+enum sprdwl_vendor_attr_loc_session_status {
+	SPRDWL_VENDOR_ATTR_LOC_SESSION_STATUS_OK,
+	SPRDWL_VENDOR_ATTR_LOC_SESSION_STATUS_ABORTED,
+	SPRDWL_VENDOR_ATTR_LOC_SESSION_STATUS_INVALID,
+	SPRDWL_VENDOR_ATTR_LOC_SESSION_STATUS_FAILED,
+};
+
+/**
+ * enum sprdwl_vendor_attr_ftm_meas: Single measurement data
+ *
+ * @SPRDWL_VENDOR_ATTR_FTM_MEAS_T1: Time of departure(TOD) of FTM packet as
+ *  recorded by responder, in picoseconds.
+ *  See IEEE P802.11-REVmc/D7.0, 11.24.6.4 for more information.
+ * @SPRDWL_VENDOR_ATTR_FTM_MEAS_T2: Time of arrival(TOA) of FTM packet at
+ *  initiator, in picoseconds.
+ *  See IEEE P802.11-REVmc/D7.0, 11.24.6.4 for more information.
+ * @SPRDWL_VENDOR_ATTR_FTM_MEAS_T3: TOD of ACK packet as recorded by
+ *  initiator, in picoseconds.
+ *  See IEEE P802.11-REVmc/D7.0, 11.24.6.4 for more information.
+ * @SPRDWL_VENDOR_ATTR_FTM_MEAS_T4: TOA of ACK packet at
+ *  responder, in picoseconds.
+ *  See IEEE P802.11-REVmc/D7.0, 11.24.6.4 for more information.
+ * @SPRDWL_VENDOR_ATTR_FTM_MEAS_RSSI: RSSI (signal level) as recorded
+ *  during this measurement exchange. Optional and will be provided if
+ *  the hardware can measure it.
+ * @SPRDWL_VENDOR_ATTR_FTM_MEAS_TOD_ERR: TOD error reported by
+ *  responder. Not always provided.
+ *  See IEEE P802.11-REVmc/D7.0, 9.6.8.33 for more information.
+ * @SPRDWL_VENDOR_ATTR_FTM_MEAS_TOA_ERR: TOA error reported by
+ *  responder. Not always provided.
+ *  See IEEE P802.11-REVmc/D7.0, 9.6.8.33 for more information.
+ * @SPRDWL_VENDOR_ATTR_FTM_MEAS_INITIATOR_TOD_ERR: TOD error measured by
+ *  initiator. Not always provided.
+ *  See IEEE P802.11-REVmc/D7.0, 9.6.8.33 for more information.
+ * @SPRDWL_VENDOR_ATTR_FTM_MEAS_INITIATOR_TOA_ERR: TOA error measured by
+ *  initiator. Not always provided.
+ *  See IEEE P802.11-REVmc/D7.0, 9.6.8.33 for more information.
+ * @SPRDWL_VENDOR_ATTR_FTM_MEAS_PAD: Dummy attribute for padding.
+ */
+enum sprdwl_vendor_attr_ftm_meas {
+	SPRDWL_VENDOR_ATTR_FTM_MEAS_INVALID,
+	SPRDWL_VENDOR_ATTR_FTM_MEAS_T1,
+	SPRDWL_VENDOR_ATTR_FTM_MEAS_T2,
+	SPRDWL_VENDOR_ATTR_FTM_MEAS_T3,
+	SPRDWL_VENDOR_ATTR_FTM_MEAS_T4,
+	SPRDWL_VENDOR_ATTR_FTM_MEAS_RSSI,
+	SPRDWL_VENDOR_ATTR_FTM_MEAS_TOD_ERR,
+	SPRDWL_VENDOR_ATTR_FTM_MEAS_TOA_ERR,
+	SPRDWL_VENDOR_ATTR_FTM_MEAS_INITIATOR_TOD_ERR,
+	SPRDWL_VENDOR_ATTR_FTM_MEAS_INITIATOR_TOA_ERR,
+	SPRDWL_VENDOR_ATTR_FTM_MEAS_PAD,
+	/* keep last */
+	SPRDWL_VENDOR_ATTR_FTM_MEAS_AFTER_LAST,
+	SPRDWL_VENDOR_ATTR_FTM_MEAS_MAX =
+		SPRDWL_VENDOR_ATTR_FTM_MEAS_AFTER_LAST - 1,
+};
+
+enum sprdwl_vendor_attr_aoa_type {
+	SPRDWL_VENDOR_ATTR_AOA_TYPE_TOP_CIR_PHASE,
+	SPRDWL_VENDOR_ATTR_AOA_TYPE_TOP_CIR_PHASE_AMP,
+	SPRDWL_VENDOR_ATTR_AOA_TYPE_MAX,
+};
+
+/* vendor event indices, used from both cfg80211.c and ftm.c */
+enum sprdwl_vendor_events_ftm_index {
+	SPRD_VENDOR_EVENT_FTM_MEAS_RESULT_INDEX = 64,
+	SPRD_VENDOR_EVENT_FTM_SESSION_DONE_INDEX,
+};
+
+/* measurement parameters. Specified for each peer as part
+ * of measurement request, or provided with measurement
+ * results for peer in case peer overridden parameters
+ */
+struct sprdwl_ftm_meas_params {
+	u8 meas_per_burst;
+	u8 num_of_bursts_exp;
+	u8 burst_duration;
+	u16 burst_period;
+};
+
+/* measurement request for a single peer */
+struct sprdwl_ftm_meas_peer_info {
+	u8 mac_addr[ETH_ALEN];
+	u32 freq;
+	u32 flags; /* enum sprdwl_vendor_attr_ftm_peer_meas_flags */
+	struct sprdwl_ftm_meas_params params;
+	u8 secure_token_id;
+};
+
+/* session request, passed to wil_ftm_cfg80211_start_session */
+struct sprdwl_ftm_session_request {
+	u64 session_cookie;
+	u32 n_peers;
+	/* keep last, variable size according to n_peers */
+	struct sprdwl_ftm_meas_peer_info peers[0];
+};
+
+/* single measurement for a peer */
+struct sprdwl_ftm_peer_meas {
+	u64 t1, t2, t3, t4;
+};
+
+/* measurement results for a single peer */
+struct sprdwl_ftm_peer_meas_res {
+	u8 mac_addr[ETH_ALEN];
+	u32 flags; /* enum sprdwl_vendor_attr_ftm_peer_result_flags */
+	u8 status; /* enum sprdwl_vendor_attr_ftm_peer_result_status */
+	u8 value_seconds;
+	bool has_params; /* true if params is valid */
+	struct sprdwl_ftm_meas_params params; /* peer overridden params */
+	u8 *lci;
+	u8 lci_length;
+	u8 *lcr;
+	u8 lcr_length;
+	u32 n_meas;
+	/* keep last, variable size according to n_meas */
+	struct sprdwl_ftm_peer_meas meas[0];
+};
+
+/* private data related to FTM. Part of the priv structure */
+struct sprdwl_ftm_priv {
+	struct mutex lock; /* protects the FTM data */
+	u8 session_started;
+	u64 session_cookie;
+	struct sprdwl_ftm_peer_meas_res *ftm_res;
+	u8 has_ftm_res;
+	u32 max_ftm_meas;
+
+	/* standalone AOA measurement */
+	u8 aoa_started;
+	u8 aoa_peer_mac_addr[ETH_ALEN];
+	u32 aoa_type;
+	struct timer_list aoa_timer;
+	struct work_struct aoa_timeout_work;
+};
+
+/**
+ * RTT Capabilities
+ * @rtt_one_sided_supported: if 1-sided rtt data collection is supported
+ * @rtt_ftm_supported: if ftm rtt data collection is supported
+ * @lci_support: if initiator supports LCI request. Applies to 2-sided RTT
+ * @lcr_support: if initiator supports LCR request. Applies to 2-sided RTT
+ * @preamble_support: bit mask indicates what preamble is supported by initiator
+ * @bw_support: bit mask indicates what BW is supported by initiator
+ * @responder_supported: if 11mc responder mode is supported
+ * @mc_version: draft 11mc spec version supported by chip.
+ *   For instance, version 4.0 should be 40 and version 4.3 should be 43 etc.
+ *
+ */
+struct sprdwl_rtt_capabilities {
+	u8 rtt_one_sided_supported;
+	u8 rtt_ftm_supported;
+	u8 lci_support;
+	u8 lcr_support;
+	u8 preamble_support;
+	u8 bw_support;
+	u8 responder_supported;
+	u8 mc_version;
+};
+
+enum wifi_rtt_preamble {
+	WIFI_RTT_PREAMBLE_LEGACY = 0x1,
+	WIFI_RTT_PREAMBLE_HT     = 0x2,
+	WIFI_RTT_PREAMBLE_VHT    = 0x4
+};
+
+struct sprdwl_rtt_responder {
+	struct wifi_channel_info channel;
+	enum wifi_rtt_preamble preamble;
+};
+
+int sprdwl_ftm_get_capabilities(struct wiphy *wiphy,
+				struct wireless_dev *wdev,
+				const void *data, int data_len);
+int sprdwl_ftm_start_session(struct wiphy *wiphy,
+			     struct wireless_dev *wdev,
+			     const void *data, int data_len);
+int sprdwl_ftm_abort_session(struct wiphy *wiphy,
+			     struct wireless_dev *wdev,
+			     const void *data, int data_len);
+int sprdwl_ftm_get_responder_info(struct wiphy *wiphy,
+				  struct wireless_dev *wdev,
+				  const void *data, int data_len);
+int sprdwl_ftm_configure_responder(struct wiphy *wiphy,
+				   struct wireless_dev *wdev,
+				   const void *data, int data_len);
+int sprdwl_event_ftm(struct sprdwl_vif *vif, u8 *data, u16 len);
+void sprdwl_ftm_init(struct sprdwl_priv *priv);
+void sprdwl_ftm_deinit(struct sprdwl_priv *priv);
+void sprdwl_ftm_stop_operations(struct sprdwl_priv *priv);
+
+#endif /* __SPRD_RTT_H__ */
+
diff --git a/drivers/net/wireless/uwe5622/unisocwifi/rx_msg.c b/drivers/net/wireless/uwe5622/unisocwifi/rx_msg.c
new file mode 100644
index 000000000000..b92374465779
--- /dev/null
+++ b/drivers/net/wireless/uwe5622/unisocwifi/rx_msg.c
@@ -0,0 +1,602 @@
+/*
+ * Copyright (C) 2016 Spreadtrum Communications Inc.
+ *
+ * Authors	:
+ * star.liu <star.liu@spreadtrum.com>
+ * yifei.li <yifei.li@spreadtrum.com>
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include "rx_msg.h"
+#include "wl_core.h"
+#include "msg.h"
+#include "sprdwl.h"
+#include "txrx.h"
+#include "intf.h"
+#include "wl_intf.h"
+#include "tx_msg.h"
+#include <net/ip6_checksum.h>
+#include "debug.h"
+#include "tcp_ack.h"
+
+#ifdef RX_HW_CSUM
+bool mh_ipv6_ext_hdr(unsigned char nexthdr)
+{
+	return (nexthdr == NEXTHDR_HOP) ||
+	       (nexthdr == NEXTHDR_ROUTING) ||
+	       (nexthdr == NEXTHDR_DEST);
+}
+
+int ipv6_csum(void *data, __wsum csum)
+{
+	int ret = 0;
+	struct rx_msdu_desc *msdu_desc = (struct rx_msdu_desc *)data;
+	struct ethhdr *eth = (struct ethhdr *)(data + msdu_desc->msdu_offset);
+	struct ipv6hdr *ip6h = NULL;
+	struct ipv6_opt_hdr *hp = NULL;
+	unsigned short dataoff = ETH_HLEN;
+	unsigned short nexthdr = 0;
+
+	wl_debug("%s: eth_type: 0x%x\n", __func__, eth->h_proto);
+
+	if (eth->h_proto == cpu_to_be16(ETH_P_IPV6)) {
+		data += msdu_desc->msdu_offset;
+		ip6h = data + dataoff;
+		nexthdr = ip6h->nexthdr;
+		dataoff += sizeof(*ip6h);
+
+		while (mh_ipv6_ext_hdr(nexthdr))  {
+			wl_debug("%s: nexthdr: %d\n", __func__, nexthdr);
+			hp = (struct ipv6_opt_hdr *)(data + dataoff);
+			dataoff += ipv6_optlen(hp);
+			nexthdr = hp->nexthdr;
+		}
+
+		wl_debug("%s: nexthdr: %d, dataoff: %d, len: %d\n",
+			 __func__, nexthdr, dataoff,
+			 (msdu_desc->msdu_len - dataoff));
+
+		if (!csum_ipv6_magic(&ip6h->saddr, &ip6h->daddr,
+				     (msdu_desc->msdu_len - dataoff),
+				     nexthdr, csum)) {
+			ret = 1;
+		} else {
+			ret = -1;
+		}
+
+		wl_debug("%s: ret: %d\n", __func__, ret);
+	}
+
+	return ret;
+}
+
+unsigned short get_sdio_data_csum(void *entry, void *data)
+{
+	unsigned short csum = 0;
+	struct sdiohal_puh *puh = (struct sdiohal_puh *)data;
+	struct rx_msdu_desc *msdu_desc =
+			(struct rx_msdu_desc *)(data + sizeof(*puh));
+	unsigned int csum_offset = msdu_total_len(msdu_desc) + sizeof(*puh);
+	struct sprdwl_intf *intf = (struct sprdwl_intf *)entry;
+
+	wl_debug("%s: check_sum: %d\n", __func__, puh->check_sum);
+	if ((intf->priv->hw_type == SPRDWL_HW_SDIO) && puh->check_sum) {
+		memcpy(&csum, (void *)(data + csum_offset), sizeof(csum));
+		wl_debug("%s: csum: 0x%x\n", __func__, csum);
+	}
+
+	return csum;
+}
+
+unsigned short get_pcie_data_csum(void *entry, void *data)
+{
+	unsigned short csum = 0;
+	struct rx_mh_desc *mh_desc = (struct rx_mh_desc *)data;
+	struct sprdwl_intf *intf = (struct sprdwl_intf *)entry;
+
+	if (intf->priv->hw_type == SPRDWL_HW_PCIE) {
+		if (mh_desc->tcp_checksum_en)
+			csum = mh_desc->tcp_hw_checksum;
+	}
+
+	return csum;
+}
+
+inline int fill_skb_csum(struct sk_buff *skb, unsigned short csum)
+{
+	int ret = 0;
+
+	if (csum) {
+		ret = ipv6_csum(skb->data, (__force __wsum)csum);
+		if (!ret) {
+			skb->ip_summed = CHECKSUM_COMPLETE;
+			skb->csum = (__force __wsum)csum;
+		} else if (ret > 0) {
+			skb->ip_summed = CHECKSUM_UNNECESSARY;
+		}
+	} else {
+		skb->ip_summed = CHECKSUM_NONE;
+	}
+
+	return ret;
+}
+#endif
+
+void sprdwl_rx_send_cmd(struct sprdwl_intf *intf, void *data, int len,
+			unsigned char id, unsigned char ctx_id)
+{
+	struct sprdwl_priv *priv = intf->priv;
+
+	sprdwl_rx_send_cmd_process(priv, data, len, id, ctx_id);
+}
+
+void sprdwl_rx_process(struct sprdwl_rx_if *rx_if, struct sk_buff *pskb)
+{
+#ifndef SPLIT_STACK
+	struct sprdwl_priv *priv = rx_if->intf->priv;
+	struct sk_buff *reorder_skb = NULL, *skb = NULL;
+#endif
+
+	/* TODO: Add rx mh data process */
+#ifdef SPLIT_STACK
+	reorder_data_process(&rx_if->ba_entry, pskb);
+
+	if (!work_pending(&rx_if->rx_net_work))
+		queue_work(rx_if->rx_net_workq, &rx_if->rx_net_work);
+#else
+	reorder_skb = reorder_data_process(&rx_if->ba_entry, pskb);
+
+	while (reorder_skb) {
+		SPRDWL_GET_FIRST_SKB(skb, reorder_skb);
+		skb = defrag_data_process(&rx_if->defrag_entry, skb);
+		if (skb)
+			sprdwl_rx_skb_process(priv, skb);
+	}
+#endif
+}
+
+static inline void
+sprdwl_rx_mh_data_process(struct sprdwl_rx_if *rx_if, void *data,
+			  int len, int buffer_type)
+{
+	mm_mh_data_process(&rx_if->mm_entry, data, len, buffer_type);
+}
+
+static void
+sprdwl_rx_mh_addr_process(struct sprdwl_rx_if *rx_if, void *data,
+			  int len, int buffer_type)
+{
+	struct sprdwl_intf *intf = rx_if->intf;
+	struct sprdwl_common_hdr *hdr =
+		(struct sprdwl_common_hdr *)(data + intf->hif_offset);
+
+	if (hdr->reserv) {
+		mm_mh_data_event_process(&rx_if->mm_entry, data,
+					 len, buffer_type);
+	} else {
+		/* TODO: Add TX complete code here */
+		sprdwl_tx_free_pcie_data(intf, (unsigned char *)data, len);
+		wl_err("%s: Add TX complete code here\n", __func__);
+	}
+}
+
+#ifdef SPLIT_STACK
+void sprdwl_rx_net_work_queue(struct work_struct *work)
+{
+	struct sprdwl_rx_if *rx_if;
+	struct sprdwl_priv *priv;
+	struct sk_buff *reorder_skb = NULL, *skb = NULL;
+
+	rx_if = container_of(work, struct sprdwl_rx_if, rx_net_work);
+	priv = rx_if->intf->priv;
+
+	reorder_skb = reorder_get_skb_list(&rx_if->ba_entry);
+	while (reorder_skb) {
+		SPRDWL_GET_FIRST_SKB(skb, reorder_skb);
+		skb = defrag_data_process(&rx_if->defrag_entry, skb);
+		if (skb)
+			sprdwl_rx_skb_process(priv, skb);
+	}
+}
+#endif
+
+static void sprdwl_rx_work_queue(struct work_struct *work)
+{
+	struct sprdwl_msg_buf *msg;
+	struct sprdwl_priv *priv;
+	struct sprdwl_rx_if *rx_if;
+	struct sprdwl_intf *intf;
+	void *pos = NULL, *data = NULL, *tran_data = NULL;
+	int len = 0, num = 0;
+	/*struct sprdwl_vif *vif;
+	struct sprdwl_cmd_hdr *hdr;*/
+
+	rx_if = container_of(work, struct sprdwl_rx_if, rx_work);
+	intf = rx_if->intf;
+	priv = intf->priv;
+
+#ifndef RX_NAPI
+	if (!intf->exit && !sprdwl_peek_msg_buf(&rx_if->rx_list))
+		sprdwl_rx_process(rx_if, NULL);
+#endif
+
+	while ((msg = sprdwl_peek_msg_buf(&rx_if->rx_list))) {
+		if (intf->exit)
+			goto next;
+
+		pos = msg->tran_data;
+		for (num = msg->len; num > 0; num--) {
+			pos = sprdwl_get_rx_data(intf, pos, &data, &tran_data,
+						 &len, intf->hif_offset);
+
+			wl_debug("%s: rx type:%d, num = %d\n",
+				__func__, SPRDWL_HEAD_GET_TYPE(data), num);
+
+			/* len in mbuf_t just means buffer len in ADMA,
+			 * so need to get data len in sdiohal_puh
+			 */
+			if (sprdwl_debug_level >= L_DBG) {
+				int print_len =
+					((struct sdiohal_puh *)tran_data)->len;
+
+				if (print_len > 100)
+					print_len = 100;
+				sprdwl_hex_dump("rx data",
+						(unsigned char *)data,
+						print_len);
+			}
+#if 0
+			/* to check is the rsp_cnt from CP2
+			* eqaul to rsp_cnt count on driver side.
+			* if not equal, must be lost on SDIOHAL/PCIE.
+			* assert to warn CP2
+			*/
+			hdr = (struct sprdwl_cmd_hdr *)data;
+			vif = ctx_id_to_vif(priv, hdr->common.ctx_id);
+			if ((SPRDWL_HEAD_GET_TYPE(data) == SPRDWL_TYPE_CMD ||
+				SPRDWL_HEAD_GET_TYPE(data) == SPRDWL_TYPE_EVENT)) {
+				if (rx_if->rsp_event_cnt != hdr->rsp_cnt) {
+					wl_info("%s, %d, rsp_event_cnt=%d, hdr->cnt=%d\n",
+						__func__, __LINE__,
+						rx_if->rsp_event_cnt, hdr->rsp_cnt);
+
+					if (hdr->rsp_cnt == 0) {
+						rx_if->rsp_event_cnt = 0;
+						wl_info("%s reset rsp_event_cnt", __func__);
+					}
+					/* hdr->rsp_cnt=0 means it's a old version CP2,
+					* so do not assert.
+					* vif=NULL means driver not init ok,
+					* send cmd may cause crash
+					*/
+					if (vif != NULL && hdr->rsp_cnt != 0) {
+						wl_err("cmd_id:%d resp count = %d error\n",
+								hdr->cmd_id, hdr->rsp_cnt);
+						sprdwl_send_assert_cmd(vif, hdr->cmd_id, RSP_CNT_ERROR);
+					}
+				}
+
+				rx_if->rsp_event_cnt++;
+			}
+			sprdwl_put_vif(vif);
+#endif
+			if (unlikely(priv->wakeup_tracer.resume_flag))
+				trace_rx_wakeup(&priv->wakeup_tracer, data,
+						tran_data + intf->hif_offset);
+
+			switch (SPRDWL_HEAD_GET_TYPE(data)) {
+			case SPRDWL_TYPE_DATA:
+#if defined FPGA_LOOPBACK_TEST
+				if (intf->loopback_n < 500) {
+					unsigned char *r_buf;
+
+					r_buf = (unsigned char *)data;
+					sprdwl_intf_tx_data_fpga_test(intf,
+								      r_buf,
+								      len);
+				}
+#else
+				if (msg->len > SPRDWL_MAX_DATA_RXLEN)
+					wl_err("err rx data too long:%d > %d\n",
+					       len, SPRDWL_MAX_DATA_RXLEN);
+				sprdwl_rx_data_process(priv, data);
+#endif /* FPGA_LOOPBACK_TEST */
+				break;
+			case SPRDWL_TYPE_CMD:
+				if (msg->len > SPRDWL_MAX_CMD_RXLEN)
+					wl_err("err rx cmd too long:%d > %d\n",
+					       len, SPRDWL_MAX_CMD_RXLEN);
+				sprdwl_rx_rsp_process(priv, data);
+				break;
+			case SPRDWL_TYPE_PKT_LOG:
+				wl_err("%s: pkt log not implemented!\n", __func__);
+				break;
+			case SPRDWL_TYPE_EVENT:
+				if (msg->len > SPRDWL_MAX_CMD_RXLEN)
+					wl_err("err rx event too long:%d > %d\n",
+					       len, SPRDWL_MAX_CMD_RXLEN);
+				sprdwl_rx_event_process(priv, data);
+				break;
+			case SPRDWL_TYPE_DATA_SPECIAL:
+				debug_ts_leave(RX_SDIO_PORT);
+				debug_ts_enter(RX_SDIO_PORT);
+
+				if (msg->len > SPRDWL_MAX_DATA_RXLEN)
+					wl_err("err data trans too long:%d > %d\n",
+					       len, SPRDWL_MAX_CMD_RXLEN);
+				sprdwl_rx_mh_data_process(rx_if, tran_data, len,
+							  msg->buffer_type);
+				tran_data = NULL;
+				data = NULL;
+				break;
+			case SPRDWL_TYPE_DATA_PCIE_ADDR:
+				if (intf->priv->hw_type != SPRDWL_HW_PCIE) {
+					wl_err("error get pcie addr data!\n");
+					break;
+				}
+				if (msg->len > SPRDWL_MAX_CMD_RXLEN)
+					wl_err("err rx mh data too long:%d > %d\n",
+					       len, SPRDWL_MAX_DATA_RXLEN);
+				sprdwl_rx_mh_addr_process(rx_if, tran_data, len,
+							  msg->buffer_type);
+				tran_data = NULL;
+				data = NULL;
+				break;
+			default:
+				wl_err("rx unknown type:%d\n",
+				       SPRDWL_HEAD_GET_TYPE(data));
+				break;
+			}
+
+			/* Marlin3 should release buffer by ourself */
+			if (tran_data)
+				sprdwl_free_data(tran_data, msg->buffer_type);
+
+			if (!pos) {
+				wl_debug("%s no mbuf\n", __func__);
+				break;
+			}
+		}
+next:
+		/* TODO: Should we free mbuf one by one? */
+		sprdwl_free_rx_data(intf, msg->fifo_id, msg->tran_data,
+				    msg->data, msg->len);
+		sprdwl_dequeue_msg_buf(msg, &rx_if->rx_list);
+	}
+}
+
+#ifdef RX_NAPI
+static int sprdwl_netdev_poll_rx(struct napi_struct *napi, int budget)
+{
+	struct sprdwl_msg_buf *msg;
+	struct sprdwl_priv *priv;
+	struct sprdwl_rx_if *rx_if;
+	struct sprdwl_intf *intf;
+	void *pos = NULL, *data = NULL, *tran_data = NULL;
+	int len = 0, num = 0;
+	int print_len;
+
+	int quota = budget;
+	int done;
+
+	rx_if = container_of(napi, struct sprdwl_rx_if, napi_rx);
+	intf = rx_if->intf;
+	priv = intf->priv;
+
+	if (!intf->exit && !sprdwl_peek_msg_buf(&rx_if->rx_data_list))
+		sprdwl_rx_process(rx_if, NULL);
+
+	while (quota && (msg = sprdwl_peek_msg_buf(&rx_if->rx_data_list))) {
+		if (intf->exit)
+			goto next;
+
+		pos = msg->tran_data;
+		for (num = msg->len; num > 0; num--) {
+			pos = sprdwl_get_rx_data(intf, pos, &data, &tran_data,
+						 &len, intf->hif_offset);
+
+			wl_info("%s: rx type:%d\n",
+				__func__, SPRDWL_HEAD_GET_TYPE(data));
+
+			/* len in mbuf_t just means buffer len in ADMA,
+			 * so need to get data len in sdiohal_puh
+			 */
+			if (((struct sdiohal_puh *)tran_data)->len > 100)
+				print_len = 100;
+			else
+				print_len = ((struct sdiohal_puh *)
+					     tran_data)->len;
+			sprdwl_hex_dump("rx data",
+					(unsigned char *)data, print_len);
+
+			if (sprdwl_sdio_process_credit(intf, data))
+				goto free;
+
+			switch (SPRDWL_HEAD_GET_TYPE(data)) {
+			case SPRDWL_TYPE_DATA_SPECIAL:
+				if (msg->len > SPRDWL_MAX_DATA_RXLEN)
+					wl_err("err data trans too long:%d > %d\n",
+					       len, SPRDWL_MAX_CMD_RXLEN);
+				sprdwl_rx_mh_data_process(rx_if, tran_data, len,
+							  msg->buffer_type);
+				tran_data = NULL;
+				data = NULL;
+				break;
+			case SPRDWL_TYPE_DATA_PCIE_ADDR:
+				if (msg->len > SPRDWL_MAX_CMD_RXLEN)
+					wl_err("err rx mh data too long:%d > %d\n",
+					       len, SPRDWL_MAX_DATA_RXLEN);
+				sprdwl_rx_mh_addr_process(rx_if, tran_data, len,
+							  msg->buffer_type);
+				tran_data = NULL;
+				data = NULL;
+				break;
+			default:
+				wl_err("rx unknown type:%d\n",
+				       SPRDWL_HEAD_GET_TYPE(data));
+				break;
+			}
+free:
+			/* Marlin3 should release buffer by ourself */
+			if (tran_data)
+				sprdwl_free_data(tran_data, msg->buffer_type);
+
+			if (!pos) {
+				wl_debug("%s no mbuf\n", __func__);
+				break;
+			}
+		}
+next:
+		/* TODO: Should we free mbuf one by one? */
+		sprdwl_free_rx_data(intf, msg->fifo_id, msg->tran_data,
+				    msg->data, msg->len);
+		sprdwl_dequeue_msg_buf(msg, &rx_if->rx_data_list);
+		quota--;
+	}
+
+	done = budget - quota;
+	if (done <= 1)
+		napi_complete(napi);
+
+	return done;
+}
+
+void sprdwl_rx_napi_init(struct net_device *ndev, struct sprdwl_intf *intf)
+{
+	struct sprdwl_rx_if *rx_if = (struct sprdwl_rx_if *)intf->sprdwl_rx;
+
+	netif_napi_add(ndev, &rx_if->napi_rx, sprdwl_netdev_poll_rx, 16);
+	napi_enable(&rx_if->napi_rx);
+}
+#endif
+
+int sprdwl_rx_init(struct sprdwl_intf *intf)
+{
+	int ret = 0;
+	struct sprdwl_rx_if *rx_if = NULL;
+
+	rx_if = kzalloc(sizeof(*rx_if), GFP_KERNEL);
+	if (!rx_if) {
+		ret = -ENOMEM;
+		goto err_rx_if;
+	}
+
+	/* init rx_list */
+	ret = sprdwl_msg_init(SPRDWL_RX_MSG_NUM, &rx_if->rx_list);
+	if (ret) {
+		wl_err("%s tx_buf create failed: %d\n",
+		       __func__, ret);
+		goto err_rx_list;
+	}
+
+#ifdef RX_NAPI
+	ret = sprdwl_msg_init(SPRDWL_RX_MSG_NUM, &rx_if->rx_data_list);
+	if (ret) {
+		wl_err("%s tx_buf create failed: %d\n",
+		       __func__, ret);
+		goto err_rx_data_list;
+	}
+#endif
+
+	/* init rx_work */
+	rx_if->rx_queue =
+		alloc_ordered_workqueue("SPRDWL_RX_QUEUE", WQ_MEM_RECLAIM |
+					WQ_HIGHPRI | WQ_CPU_INTENSIVE);
+	if (!rx_if->rx_queue) {
+		wl_err("%s SPRDWL_RX_QUEUE create failed\n", __func__);
+		ret = -ENOMEM;
+		goto err_rx_work;
+	}
+
+	/*init rx_queue*/
+	INIT_WORK(&rx_if->rx_work, sprdwl_rx_work_queue);
+
+#ifdef SPLIT_STACK
+	rx_if->rx_net_workq = alloc_ordered_workqueue("SPRDWL_RX_NET_QUEUE",
+					WQ_HIGHPRI | WQ_CPU_INTENSIVE |
+					WQ_MEM_RECLAIM);
+	if (!rx_if->rx_net_workq) {
+		wl_err("%s SPRDWL_RX_NET_QUEUE create failed\n", __func__);
+		ret = -ENOMEM;
+		goto err_rx_net_work;
+	}
+
+	/*init rx_queue*/
+	INIT_WORK(&rx_if->rx_net_work, sprdwl_rx_net_work_queue);
+#endif
+
+	ret = sprdwl_defrag_init(&rx_if->defrag_entry);
+	if (ret) {
+		wl_err("%s init defrag fail: %d\n", __func__, ret);
+		goto err_rx_defrag;
+	}
+
+	ret = sprdwl_mm_init(&rx_if->mm_entry, (void *)intf);
+	if (ret) {
+		wl_err("%s init mm fail: %d\n", __func__, ret);
+		goto err_rx_mm;
+	}
+
+	sprdwl_reorder_init(&rx_if->ba_entry);
+
+	intf->lp = 0;
+	intf->sprdwl_rx = (void *)rx_if;
+	rx_if->intf = intf;
+
+	return ret;
+
+err_rx_mm:
+	sprdwl_mm_deinit(&rx_if->mm_entry, intf);
+err_rx_defrag:
+#ifdef SPLIT_STACK
+	destroy_workqueue(rx_if->rx_net_workq);
+err_rx_net_work:
+#endif
+	destroy_workqueue(rx_if->rx_queue);
+err_rx_work:
+#ifdef RX_NAPI
+	sprdwl_msg_deinit(&rx_if->rx_data_list);
+err_rx_data_list:
+#endif
+	sprdwl_msg_deinit(&rx_if->rx_list);
+err_rx_list:
+	kfree(rx_if);
+err_rx_if:
+	return ret;
+}
+
+int sprdwl_rx_deinit(struct sprdwl_intf *intf)
+{
+	struct sprdwl_rx_if *rx_if = (struct sprdwl_rx_if *)intf->sprdwl_rx;
+
+	flush_workqueue(rx_if->rx_queue);
+	destroy_workqueue(rx_if->rx_queue);
+
+#ifdef SPLIT_STACK
+	flush_workqueue(rx_if->rx_net_workq);
+	destroy_workqueue(rx_if->rx_net_workq);
+#endif
+
+	sprdwl_msg_deinit(&rx_if->rx_list);
+#ifdef RX_NAPI
+	sprdwl_msg_deinit(&rx_if->rx_data_list);
+	napi_disable(&rx_if->napi_rx);
+#endif
+
+	sprdwl_defrag_deinit(&rx_if->defrag_entry);
+	sprdwl_mm_deinit(&rx_if->mm_entry, intf);
+	sprdwl_reorder_deinit(&rx_if->ba_entry);
+
+	kfree(rx_if);
+	intf->sprdwl_rx = NULL;
+
+	return 0;
+}
diff --git a/drivers/net/wireless/uwe5622/unisocwifi/rx_msg.h b/drivers/net/wireless/uwe5622/unisocwifi/rx_msg.h
new file mode 100644
index 000000000000..876b523dfd71
--- /dev/null
+++ b/drivers/net/wireless/uwe5622/unisocwifi/rx_msg.h
@@ -0,0 +1,266 @@
+#ifndef __RX_MSG_H__
+#define __RX_MSG_H__
+
+#include "mm.h"
+#include "reorder.h"
+#include "defrag.h"
+#include "tracer.h"
+
+#define MAX_SEQNO_BY_TWO 2048
+#define SEQNO_MASK 0xfff
+#define SEQNO_ADD(seq1, seq2) (((seq1) + (seq2)) & SEQNO_MASK)
+#define SEQNO_SUB(seq1, seq2) (((seq1) - (seq2)) & SEQNO_MASK)
+
+#define SPRDWL_GET_FIRST_SKB(skb, list) {\
+	skb = list;\
+	list = skb->next;\
+	skb->next = NULL;\
+}
+
+enum seqno_bound {
+	LESSER_THAN_SEQLO = 0,
+	GREATER_THAN_SEQHI,
+	BETWEEN_SEQLO_SEQHI,
+};
+
+enum cipher_type {
+	SPRDWL_HW_WEP = 0,
+	SPRDWL_HW_TKIP,
+	SPRDWL_HW_CCMP,
+	SPRDWL_HW_NO_CIPHER,
+	SPRDWL_HW_WEP_104,
+	SPRDWL_HW_GCMP_128,
+	SPRDWL_HW_GCMP_256,
+	SPRDWL_HW_WAPI,
+	SPRDWL_HW_CCMP_256,
+	SPRDWL_HW_BIP_CMAC_128,
+	SPRDWL_HW_BIP_CMAC_256,
+	SPRDWL_HW_BIP_GMAC_128,
+	SPRDWL_HW_BIP_GMAC_256,
+};
+
+struct sprdwl_rx_if {
+	struct sprdwl_intf *intf;
+
+	struct sprdwl_msg_list rx_list;
+
+	struct work_struct rx_work;
+	struct workqueue_struct *rx_queue;
+
+#ifdef RX_NAPI
+	struct sprdwl_msg_list rx_data_list;
+	struct napi_struct napi_rx;
+#endif
+
+	struct sprdwl_mm mm_entry;
+	struct sprdwl_rx_ba_entry ba_entry;
+	struct sprdwl_rx_defrag_entry defrag_entry;
+	u8 rsp_event_cnt;
+
+#ifdef SPLIT_STACK
+	struct work_struct rx_net_work;
+	struct workqueue_struct *rx_net_workq;
+#endif
+	unsigned long rx_data_num;
+	ktime_t rxtimebegin;
+	ktime_t rxtimeend;
+};
+
+struct sprdwl_addr_trans_value {
+#define SPRDWL_PROCESS_BUFFER 0
+#define SPRDWL_FREE_BUFFER 1
+#define SPRDWL_REQUEST_BUFFER 2
+#define SPRDWL_FLUSH_BUFFER 3
+	unsigned char type;
+	unsigned char num;
+	unsigned char address[0][5];
+} __packed;
+
+struct sprdwl_addr_trans {
+	unsigned int timestamp;
+	unsigned char tlv_num;
+	struct sprdwl_addr_trans_value value[0];
+} __packed;
+
+/* NOTE: MUST not modify, defined by HW */
+/* It still change now */
+struct rx_msdu_desc {
+	/* WORD7 */
+	u32 host_type:4;	/* indicate data/event/rsp, host driver used */
+	u32 ctx_id:4;		/* indicate hw mac address index */
+	u32 msdu_offset:8;	/* 802.3 header offset from msdu_dscr_header */
+	u32 msdu_len:16;	/* len of 802.3 frame */
+	/* WORD8 */
+	u32 curr_buff_base_addr_l;	/* base buffer addr of this msdu
+					 * low 32 bit
+					 */
+	/* WORD9 */
+	union {
+		u8 curr_buff_base_addr_h;	/* base buffer addr of
+						 * this msdu high 8 bit
+						 */
+		u8 short_pkt_num;		/* sw use, used in short
+						 * pkt process in SDIO mode
+						 */
+	};
+	u8 msdu_index_of_mpdu;		/* msdu index of mpdu */
+	u16 first_msdu_of_buff:1;	/* indicate whether this msdu is
+					 * the first msdu in buffer
+					 */
+	u16 last_msdu_of_buff:1;	/* indicate whether this msdu is
+					 * the last msdu in buffer
+					 */
+	u16 rsvd1:2;			/* reserved */
+	u16 first_msdu_of_mpdu:1;	/* indicate whether this msdu is
+					 * the first msdu of mpdu
+					 */
+	u16 last_msdu_of_mpdu:1;	/* indicate whether this msdu is
+					 * the last msdu of mpdu
+					 */
+	u16 null_frame_flag:1;		/* indicate this msdu is null */
+	u16 qos_null_frame_flag:1;	/* indicate this msdu is qos null */
+	u16 first_buff_of_mpdu:1;	/* indicate whether the buffer this msdu
+					 * is the first buff of mpdu
+					 */
+	u16 last_buff_of_mpdu:1;	/* indicate whether the buffer this msdu
+					 * is the last buff of mpdu
+					 */
+	u16 sta_lut_valid:1;		/* indicate if find hw sta lut */
+	u16 sta_lut_index:5;		/* hw sta lut index, valid only
+					 * when sta_lut_valid is true
+					 */
+	/* WORD 10 */
+	u32 more_data_bit:1;	/* more data bit in mac header */
+	u32 eosp_bit:1;		/* eosp bit in mac header */
+	u32 pm_bit:1;		/* pm bit in mac header */
+	u32 bc_mc_w2w_flag:1;	/* bc/mc wlan2wlan flag */
+	u32 bc_mc_flag:1;	/* bc/mc flag */
+	u32 uc_w2w_flag:1;	/* uc wlan2wlan flag */
+	u32 eapol_flag:1;	/* eapol flag */
+	u32 vlan_type_flag:1;	/* vlan pkt */
+	u32 snap_hdr_present:1;	/* indicate if hw find snap header
+				 * (0xAA 0xAA 0x03 0x00 0x00 0x00)
+				 * (0xAA 0xAA 0x03 0x00 0x00 0xFB)
+				 */
+	u32 snap_hdr_type:1;	/* snap header type: rfc1042/rfc896(802.1h) */
+	u32 ba_session_flag:1;	/* indicate if this msdu is
+				 * received in rx ba session period
+				 */
+	u32 ampdu_flag:1;	/* indicate if this msdu is in ampdu */
+	u32 amsdu_flag:1;	/* indicate if this msdu is in amsdu */
+	u32 qos_flag:1;		/* qos flag */
+	u32 rsvd2:2;		/* reserved */
+	u32 tid:4;		/* TID */
+	u32 seq_num:12;		/* sequence number */
+	/* WORD11 */
+	u32 pn_l;		/* PN, low 4 bytes, hw has got real PN value */
+	/* WORD12 */
+	u32 pn_h:16;		/* PN, high 2 bytes */
+	u32 frag_num:4;		/* fragment number in mac header */
+	u32 more_frag_bit:1;	/* more fragment bit in mac header */
+	u32 retry_bit:1;	/* retransmission bit in mac header */
+	u32 rsvd3:2;		/* reserved */
+	u32 cipher_type:4;	/* cipher type */
+	u32 rsvd4:3;		/* reserved */
+	u32 data_write_done:1;	/* in PCIE mode, indicate if data has been
+				 * transferred from HW to ap, host driver use
+				 */
+	/* WORD13 */
+	u32 rsvd5;		/* reserved */
+} __packed;
+
+/* NOTE: MUST not modify, defined by HW */
+struct rx_mh_desc {
+	/* WORD0 */
+	u32 next_msdu_ptr_l;	/* ptr to next msdu low 32 bit */
+	/* WORD1 */
+	u32 next_msdu_ptr_h:8;	/* ptr to next msdu high 8 bit */
+	u32 transfer_len:16;	/* SDIO HW use */
+	u32 offset_for_sdio:8;	/* SDIO HW use, default:0 */
+	/* WORD2 */
+	u32 tcp_checksum_offset:12;	/* HW use */
+	u32 tcp_checksum_len:16;	/* HW use */
+	u32 tcp_checksum_en:1;		/* HW use */
+	u32 rsvd1:3;			/* reserved */
+	/* WORD3 */
+	u32 tcp_hw_checksum:16;		/* MAC HW fill, host driver use */
+	u32 last_procq_msdu_of_buff:1;	/* indicate whether this msdu
+					 * is the last procq msdu in buffer
+					 */
+	u32 rsvd2:7;			/* reserved */
+	u32 filter_status:6;		/* used in filter queue */
+	u32 msdu_sta_ps_flag:1;		/* indicate if this msdu is received
+					 * in STA ps state
+					 */
+	u32 filter_flag:1;		/* indicate if this msdu is
+					 * a filter msdu
+					 */
+	/* WORD4 */
+	u32 data_rate:8;	/* data rate from PA RX DESCRIPTOR */
+	u32 rss1:8;		/* RSS1 from PA RX DESCRIPTOR */
+	u32 rss2:8;		/* RSS2 from PA RX DESCRIPTOR */
+	u32 snr1:8;		/* SNR1 from PA RX DESCRIPTOR */
+	/* WORD5 */
+	u32 snr2:8;		/* SNR2 from PA RX DESCRIPTOR */
+	u32 snr_combo:8;	/* SNR-COMBO from PA RX DESCRIPTOR */
+	u32 snr_l:8;		/* SNR-L from PA RX DESCRIPTOR */
+	u32 rsvd3:8;		/* reserved */
+	/* WORD6 */
+	u32 phy_rx_mode;	/* PHY RX MODE from PA RX DESCRIPTOR */
+} __packed;
+
+static inline int msdu_total_len(struct rx_msdu_desc *msdu_desc)
+{
+	return msdu_desc->msdu_offset + msdu_desc->msdu_len;
+}
+
+#ifdef RX_HW_CSUM
+unsigned short get_sdio_data_csum(void *entry, void *data);
+unsigned short get_pcie_data_csum(void *entry, void *data);
+int fill_skb_csum(struct sk_buff *skb, unsigned short csum);
+#else
+static inline unsigned short
+get_sdio_data_csum(void *entry, void *data)
+{
+	return 0;
+}
+
+static inline unsigned short
+get_pcie_data_csum(void *entry, void *data)
+{
+	return 0;
+}
+
+static inline int
+fill_skb_csum(struct sk_buff *skb, unsigned short csum)
+{
+	skb->ip_summed = CHECKSUM_NONE;
+
+	return 0;
+}
+#endif /* RX_HW_CSUM */
+
+static inline bool seqno_leq(unsigned short seq1, unsigned short seq2)
+{
+	bool ret = false;
+
+	if (((seq1 <= seq2) && ((seq2 - seq1) < MAX_SEQNO_BY_TWO)) ||
+	    ((seq1 > seq2) && ((seq1 - seq2) >= MAX_SEQNO_BY_TWO)))
+			ret = true;
+	return ret;
+}
+
+static inline bool seqno_geq(unsigned short seq1, unsigned short seq2)
+{
+	return seqno_leq(seq2, seq1);
+}
+
+void sprdwl_rx_process(struct sprdwl_rx_if *rx_if, struct sk_buff *pskb);
+void sprdwl_rx_send_cmd(struct sprdwl_intf *intf, void *data, int len,
+			unsigned char id, unsigned char ctx_id);
+int sprdwl_pkt_log_save(struct sprdwl_intf *intf, void *data);
+void sprdwl_rx_napi_init(struct net_device *ndev, struct sprdwl_intf *intf);
+int sprdwl_rx_init(struct sprdwl_intf *intf);
+int sprdwl_rx_deinit(struct sprdwl_intf *intf);
+
+#endif
diff --git a/drivers/net/wireless/uwe5622/unisocwifi/softap_hook.c b/drivers/net/wireless/uwe5622/unisocwifi/softap_hook.c
new file mode 100644
index 000000000000..09da2a871a21
--- /dev/null
+++ b/drivers/net/wireless/uwe5622/unisocwifi/softap_hook.c
@@ -0,0 +1,76 @@
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/fs.h>
+#include <linux/uaccess.h>
+#include <linux/mm.h>
+
+#include "sprdwl.h"
+#include "wl_core.h"
+
+static bool is_valid_channel(struct wiphy *wiphy, int chn)
+{
+	int i;
+	struct ieee80211_supported_band *bands;
+
+	if (chn < 15) {
+		if (chn < 1)
+			return false;
+		return true;
+	}
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 7, 0)
+	bands = wiphy->bands[NL80211_BAND_5GHZ];
+#else
+	bands = wiphy->bands[IEEE80211_BAND_5GHZ];
+#endif
+	for (i = 0; i < bands->n_channels; i++)
+		if (chn == bands->channels[i].hw_value)
+			return true;
+
+	return false;
+}
+
+void sprdwl_hook_reset_channel(struct wiphy *wiphy,
+			       struct cfg80211_ap_settings *settings)
+{
+	u8 *ie, *ds_param_ch;
+	int channel = 1;
+	struct ieee80211_mgmt *mgmt;
+	struct ieee80211_ht_operation *oper;
+
+	channel = ieee80211_frequency_to_channel(
+		settings->chandef.chan->center_freq);
+	if (channel == 0)
+		return;
+
+	if (!is_valid_channel(wiphy, channel)) {
+		wl_err("%s channel(%d) invalid\n", __func__, channel);
+		return;
+	}
+
+	mgmt = (struct ieee80211_mgmt *)settings->beacon.head;
+	ie = (u8 *)cfg80211_find_ie(WLAN_EID_DS_PARAMS,
+				    &mgmt->u.beacon.variable[0],
+				    settings->beacon.head_len);
+	if (ie == NULL) {
+		wl_err("IE WLAN_EID_DS_PARAMS not found in beacon\n");
+		return;
+	}
+
+	ds_param_ch = ie + 2;
+
+	ie = (u8 *)cfg80211_find_ie(WLAN_EID_HT_OPERATION,
+				    settings->beacon.tail,
+				    settings->beacon.tail_len);
+	if (ie == NULL) {
+		wl_err("IE WLAN_EID_HT_OPERATION not found in beacon\n");
+		return;
+	}
+
+	ie += 2;
+	oper = (struct ieee80211_ht_operation *)ie;
+
+	wl_info("%s done, reset channel %d -> %d\n", __func__,
+	       oper->primary_chan, channel);
+
+	*ds_param_ch = oper->primary_chan = channel;
+}
diff --git a/drivers/net/wireless/uwe5622/unisocwifi/softap_hook.h b/drivers/net/wireless/uwe5622/unisocwifi/softap_hook.h
new file mode 100644
index 000000000000..194edb4c7d9c
--- /dev/null
+++ b/drivers/net/wireless/uwe5622/unisocwifi/softap_hook.h
@@ -0,0 +1,9 @@
+#ifdef SOFTAP_HOOK
+void sprdwl_hook_reset_channel(struct wiphy *wiphy,
+			       struct cfg80211_ap_settings *set);
+#else
+static inline void sprdwl_hook_reset_channel(struct wiphy *wiphy,
+					     struct cfg80211_ap_settings *set)
+{
+}
+#endif
diff --git a/drivers/net/wireless/uwe5622/unisocwifi/sprdwl.h b/drivers/net/wireless/uwe5622/unisocwifi/sprdwl.h
new file mode 100644
index 000000000000..839aa35c4e4c
--- /dev/null
+++ b/drivers/net/wireless/uwe5622/unisocwifi/sprdwl.h
@@ -0,0 +1,397 @@
+/*
+ * Copyright (C) 2015 Spreadtrum Communications Inc.
+ *
+ * Authors	:
+ * Keguang Zhang <keguang.zhang@spreadtrum.com>
+ * Jingxiang Li <Jingxiang.li@spreadtrum.com>
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#ifndef __SPRDWL_H__
+#define __SPRDWL_H__
+
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/ieee80211.h>
+#include <linux/etherdevice.h>
+#include <net/cfg80211.h>
+#include <linux/inetdevice.h>
+#include <linux/wireless.h>
+#include <linux/workqueue.h>
+#include <linux/timer.h>
+#include <linux/atomic.h>
+#include <linux/spinlock.h>
+#include <linux/mutex.h>
+#include <net/if_inet6.h>
+#include <net/addrconf.h>
+#include <linux/dcache.h>
+#include <linux/udp.h>
+#include <linux/version.h>
+
+#include "cfg80211.h"
+#include "cmdevt.h"
+#include "intf.h"
+#include "vendor.h"
+#include "tcp_ack.h"
+#include "rtt.h"
+#include "version.h"
+#include "tracer.h"
+
+#define SPRDWL_UNALIAGN		1
+#ifdef SPRDWL_UNALIAGN
+#define SPRDWL_PUT_LE16(val, addr)	put_unaligned_le16((val), (&addr))
+#define SPRDWL_PUT_LE32(val, addr)	put_unaligned_le32((val), (&addr))
+#define SPRDWL_GET_LE16(addr)		get_unaligned_le16(&addr)
+#define SPRDWL_GET_LE32(addr)		get_unaligned_le32(&addr)
+#define SPRDWL_GET_LE64(addr)		get_unaligned_le64(&addr)
+#else
+#define SPRDWL_PUT_LE16(val, addr)	cpu_to_le16((val), (addr))
+#define SPRDWL_PUT_LE32(val, addr)	cpu_to_le32((val), (addr))
+#define SPRDWL_GET_LE16(addr)		le16_to_cpu((addr))
+#define SPRDWL_GET_LE32(addr)		le32_to_cpu((addr))
+#endif
+
+/* the max length between data_head and net data */
+#define SPRDWL_SKB_HEAD_RESERV_LEN	16
+#define SPRDWL_COUNTRY_CODE_LEN		2
+#define ETHER_TYPE_IP 0x0800           /* IP */
+#define ETHER_TYPE_IPV6 0x86dd             /* IPv6 */
+#define WAPI_TYPE                 0x88B4
+
+#ifdef OTT_UWE
+#define FOUR_BYTES_ALIGN_OFFSET 3
+#endif
+
+struct sprdwl_mc_filter {
+	bool mc_change;
+	u8 subtype;
+	u8 mac_num;
+	u8 mac_addr[0];
+};
+
+struct android_wifi_priv_cmd {
+	char *buf;
+	int used_len;
+	int total_len;
+};
+
+struct scan_result {
+	struct list_head list;
+	int signal;
+	unsigned char bssid[6];
+};
+
+struct sprdwl_vif {
+	struct net_device *ndev;	/* Linux net device */
+	struct wireless_dev wdev;	/* Linux wireless device */
+	struct sprdwl_priv *priv;
+
+	char name[IFNAMSIZ];
+	enum sprdwl_mode mode;
+	struct list_head vif_node;	/* node for virtual interface list */
+	int ref;
+
+	/* multicast filter stuff */
+	struct sprdwl_mc_filter *mc_filter;
+
+	/* common stuff */
+	enum sm_state sm_state;
+	unsigned char mac[ETH_ALEN];
+	int ssid_len;
+	u8 ssid[IEEE80211_MAX_SSID_LEN];
+	u8 bssid[ETH_ALEN];
+	unsigned char beacon_loss;
+	bool local_mac_flag;
+
+	/* encryption stuff */
+	u8 prwise_crypto;
+	u8 grp_crypto;
+	u8 key_index[2];
+	u8 key[2][4][WLAN_MAX_KEY_LEN];
+	u8 key_len[2][4];
+	unsigned long mgmt_reg;
+
+	/* P2P stuff */
+	struct ieee80211_channel listen_channel;
+	u64 listen_cookie;
+	u8 ctx_id;
+	struct  list_head  scan_head_ptr;
+#ifdef ACS_SUPPORT
+	/* ACS stuff */
+	struct list_head survey_info_list;
+#endif /* ACS_SUPPORT*/
+#ifdef DFS_MASTER
+	/* dfs master mode */
+	struct workqueue_struct *dfs_cac_workqueue;
+	struct delayed_work dfs_cac_work;
+	struct workqueue_struct *dfs_chan_sw_workqueue;
+	struct delayed_work dfs_chan_sw_work;
+	struct cfg80211_chan_def dfs_chandef;
+#endif
+	u8 wps_flag;
+#ifdef SYNC_DISCONNECT
+	atomic_t sync_disconnect_event;
+	u16 disconnect_event_code;
+	wait_queue_head_t disconnect_wq;
+#endif
+};
+
+enum sprdwl_hw_type {
+	SPRDWL_HW_SIPC,
+	SPRDWL_HW_SDIO,
+	SPRDWL_HW_PCIE,
+	SPRDWL_HW_USB
+};
+
+#ifdef WMMAC_WFA_CERTIFICATION
+struct wmm_ac_params {
+	u8 aci_aifsn; /* AIFSN, ACM, ACI */
+	u8 cw; /* ECWmin, ECWmax (CW = 2^ECW - 1) */
+	u16 txop_limit;
+};
+
+struct wmm_params_element {
+	/* Element ID: 221 (0xdd); Length: 24 */
+	/* required fields for WMM version 1 */
+	u8 oui[3]; /* 00:50:f2 */
+	u8 oui_type; /* 2 */
+	u8 oui_subtype; /* 1 */
+	u8 version; /* 1 for WMM version 1.0 */
+	u8 qos_info; /* AP/STA specific QoS info */
+	u8 reserved; /* 0 */
+	struct wmm_ac_params ac[4]; /* AC_BE, AC_BK, AC_VI, AC_VO */
+};
+
+struct sprdwl_wmmac_params {
+	struct wmm_ac_params ac[4];
+	struct timer_list wmmac_edcaf_timer;
+};
+#endif
+
+struct sprdwl_channel_list {
+	int num_channels;
+	int channels[TOTAL_2G_5G_CHANNEL_NUM];
+};
+
+struct sprdwl_priv {
+	struct wiphy *wiphy;
+	/* virtual interface list */
+	spinlock_t list_lock;
+	struct list_head vif_list;
+
+	/* necessary info from fw */
+	u32 chip_model;
+	u32 chip_ver;
+	u32 fw_ver;
+	u32 fw_std;
+	u32 fw_capa;
+	struct sprdwl_ver wl_ver;
+	u8 max_ap_assoc_sta;
+	u8 max_acl_mac_addrs;
+	u8 max_mc_mac_addrs;
+	u8 mac_addr[ETH_ALEN];
+	u8 wnm_ft_support;
+	u32 wiphy_sec2_flag;
+	struct wiphy_sec2_t wiphy_sec2;
+	struct sync_api_verion_t sync_api;
+	unsigned short skb_head_len;
+	enum sprdwl_hw_type hw_type;
+	void *hw_priv;
+	int hw_offset;
+	struct sprdwl_if_ops *if_ops;
+	u16 beacon_period;
+
+	/* scan */
+	spinlock_t scan_lock;
+	struct sprdwl_vif *scan_vif;
+	struct cfg80211_scan_request *scan_request;
+	struct timer_list scan_timer;
+
+	/* schedule scan */
+	spinlock_t sched_scan_lock;
+	struct sprdwl_vif *sched_scan_vif;
+	struct cfg80211_sched_scan_request *sched_scan_request;
+
+	/*gscan*/
+	u8 gscan_buckets_num;
+	struct sprdwl_gscan_cached_results *gscan_res;
+
+	struct sprdwl_gscan_hotlist_results *hotlist_res;
+
+	int gscan_req_id;
+	struct sprdwl_significant_change_result *significant_res;
+	struct sprdwl_roam_capa roam_capa;
+	/*ll status*/
+	struct sprdwl_llstat_radio pre_radio;
+
+	/* default MAC addr*/
+	unsigned char default_mac[ETH_ALEN];
+#define SPRDWL_INTF_CLOSE	(0)
+#define SPRDWL_INTF_OPEN	(1)
+#define SPRDWL_INTF_CLOSING	(2)
+	unsigned char fw_stat[SPRDWL_MODE_MAX];
+
+	/* delayed work */
+	spinlock_t work_lock;
+	struct work_struct work;
+	struct list_head work_list;
+	struct workqueue_struct *common_workq;
+
+	struct dentry *debugfs;
+
+	/* tcp ack management */
+	struct sprdwl_tcp_ack_manage ack_m;
+
+	/* FTM */
+	struct sprdwl_ftm_priv ftm;
+	struct wakeup_trace wakeup_tracer;
+#ifdef WMMAC_WFA_CERTIFICATION
+	/*wmmac*/
+	struct sprdwl_wmmac_params wmmac;
+#endif
+	struct sprdwl_channel_list ch_2g4_info;
+	struct sprdwl_channel_list ch_5g_without_dfs_info;
+	struct sprdwl_channel_list ch_5g_dfs_info;
+	/* with credit or without credit */
+#define TX_WITH_CREDIT	(0)
+#define TX_NO_CREDIT	(1)
+	unsigned char credit_capa;
+	int is_suspending;
+
+	/* OTT support */
+#define OTT_NO_SUPT	(0)
+#define OTT_SUPT	(1)
+	unsigned char ott_supt;
+};
+
+struct sprdwl_eap_hdr {
+	u8 version;
+#define EAP_PACKET_TYPE		(0)
+	u8 type;
+	u16 len;
+#define EAP_FAILURE_CODE	(4)
+	u8 code;
+	u8 id;
+	u16 auth_proc_len;
+	u8 auth_proc_type;
+	u64 ex_id:24;
+	u64 ex_type:32;
+#define EAP_WSC_DONE	(5)
+	u64 opcode:8;
+};
+
+enum sprdwl_debug {
+	L_NONE = 0,
+	L_ERR, /*LEVEL_ERR*/
+	L_WARN, /*LEVEL_WARNING*/
+	L_INFO,/*LEVEL_INFO*/
+	L_DBG, /*LEVEL_DEBUG*/
+};
+
+extern int sprdwl_debug_level;
+extern struct device *sprdwl_dev;
+#define wl_debug(fmt, args...) \
+	do { \
+		if (sprdwl_debug_level >= L_DBG) { \
+			pr_err("sprdwl:" fmt, ##args); \
+		} \
+	} while (0)
+
+#define wl_err(fmt, args...) \
+	do { \
+		if (sprdwl_debug_level >= L_ERR) \
+			pr_err("sprdwl:" fmt, ##args); \
+	} while (0)
+
+#define wl_warn(fmt, args...) \
+	do { \
+		if (sprdwl_debug_level >= L_WARN) \
+			pr_err("sprdwl:" fmt, ##args); \
+	} while (0)
+
+#define wl_info(fmt, args...) \
+	do { \
+		if (sprdwl_debug_level >= L_INFO) { \
+			pr_err("sprdwl:" fmt, ##args); \
+		} \
+	} while (0)
+
+#define wl_err_ratelimited(fmt, args...) \
+	do { \
+		if (sprdwl_debug_level >= L_ERR) \
+			printk_ratelimited("sprdwl:" fmt, ##args); \
+	} while (0)
+
+#define wl_ndev_log(level, ndev, fmt, args...) \
+	do { \
+		if (sprdwl_debug_level >= level) { \
+			netdev_err(ndev, fmt, ##args); \
+		} \
+	} while (0)
+
+#define wl_hex_dump(level, _str, _type, _row, _gp, _buf, _len, _ascii) \
+	do { \
+		if (sprdwl_debug_level >= level) { \
+			print_hex_dump(KERN_ERR, _str, _type, _row, _gp, _buf, _len, _ascii); \
+		} \
+	} while (0)
+
+#define wl_err_ratelimited(fmt, args...) \
+	do { \
+		if (sprdwl_debug_level >= L_ERR) \
+			printk_ratelimited("sprdwl:" fmt, ##args); \
+	} while (0)
+
+#ifdef ACS_SUPPORT
+struct sprdwl_bssid {
+	unsigned char bssid[ETH_ALEN];
+	struct list_head list;
+};
+
+struct sprdwl_survey_info {
+	/* survey info */
+	unsigned int cca_busy_time;
+	char noise;
+	struct ieee80211_channel *channel;
+	struct list_head survey_list;
+	/* channel info */
+	unsigned short chan;
+	unsigned short beacon_num;
+	struct list_head bssid_list;
+};
+
+void clean_survey_info_list(struct sprdwl_vif *vif);
+void transfer_survey_info(struct sprdwl_vif *vif);
+void acs_scan_result(struct sprdwl_vif *vif, u16 chan,
+		     struct ieee80211_mgmt *mgmt);
+#endif /* ACS_SUPPORT */
+
+void init_scan_list(struct sprdwl_vif *vif);
+void clean_scan_list(struct sprdwl_vif *vif);
+extern struct sprdwl_priv *g_sprdwl_priv;
+
+void sprdwl_netif_rx(struct sk_buff *skb, struct net_device *ndev);
+void sprdwl_stop_net(struct sprdwl_vif *vif);
+void sprdwl_net_flowcontrl(struct sprdwl_priv *priv,
+			   enum sprdwl_mode mode, bool state);
+
+struct wireless_dev *sprdwl_add_iface(struct sprdwl_priv *priv,
+				      const char *name,
+				      enum nl80211_iftype type, u8 *addr);
+int sprdwl_del_iface(struct sprdwl_priv *priv, struct sprdwl_vif *vif);
+struct sprdwl_priv *sprdwl_core_create(enum sprdwl_hw_type type,
+				       struct sprdwl_if_ops *ops);
+void sprdwl_core_free(struct sprdwl_priv *priv);
+int sprdwl_core_init(struct device *dev, struct sprdwl_priv *priv);
+int sprdwl_core_deinit(struct sprdwl_priv *priv);
+int marlin_reset_register_notify(void *callback_func, void *para);
+int marlin_reset_unregister_notify(void);
+#endif /* __SPRDWL_H__ */
diff --git a/drivers/net/wireless/uwe5622/unisocwifi/tcp_ack.c b/drivers/net/wireless/uwe5622/unisocwifi/tcp_ack.c
new file mode 100644
index 000000000000..d360f9f57990
--- /dev/null
+++ b/drivers/net/wireless/uwe5622/unisocwifi/tcp_ack.c
@@ -0,0 +1,606 @@
+#include <uapi/linux/if_ether.h>
+#include <uapi/linux/tcp.h>
+#include <uapi/linux/ip.h>
+#include <uapi/linux/in.h>
+#include <linux/moduleparam.h>
+#include <net/tcp.h>
+
+#include "sprdwl.h"
+#include "intf_ops.h"
+#include "tcp_ack.h"
+
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 14, 0)
+static void sprdwl_tcp_ack_timeout(struct timer_list *t)
+#else
+static void sprdwl_tcp_ack_timeout(unsigned long data)
+#endif
+{
+	struct sprdwl_tcp_ack_info *ack_info;
+	struct sprdwl_msg_buf *msg;
+	struct sprdwl_tcp_ack_manage *ack_m = NULL;
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 14, 0)
+	ack_info = (struct sprdwl_tcp_ack_info *)from_timer(ack_info, t, timer);
+#else
+	ack_info = (struct sprdwl_tcp_ack_info *)data;
+#endif
+	ack_m = container_of(ack_info, struct sprdwl_tcp_ack_manage,
+			     ack_info[ack_info->ack_info_num]);
+
+	write_seqlock_bh(&ack_info->seqlock);
+	msg = ack_info->msgbuf;
+	if (ack_info->busy && msg && !ack_info->in_send_msg) {
+		ack_info->msgbuf = NULL;
+		ack_info->drop_cnt = 0;
+		ack_info->in_send_msg = msg;
+		write_sequnlock_bh(&ack_info->seqlock);
+		sprdwl_intf_tx(ack_m->priv, msg);
+		return;
+	}
+	write_sequnlock_bh(&ack_info->seqlock);
+}
+
+void sprdwl_tcp_ack_init(struct sprdwl_priv *priv)
+{
+	int i;
+	struct sprdwl_tcp_ack_info *ack_info;
+	struct sprdwl_tcp_ack_manage *ack_m = &priv->ack_m;
+
+	memset(ack_m, 0, sizeof(struct sprdwl_tcp_ack_manage));
+	ack_m->priv = priv;
+	spin_lock_init(&ack_m->lock);
+	atomic_set(&ack_m->max_drop_cnt, SPRDWL_TCP_ACK_DROP_CNT);
+	ack_m->last_time = jiffies;
+	ack_m->timeout = msecs_to_jiffies(SPRDWL_ACK_OLD_TIME);
+
+	for (i = 0; i < SPRDWL_TCP_ACK_NUM; i++) {
+		ack_info = &ack_m->ack_info[i];
+		ack_info->ack_info_num = i;
+		seqlock_init(&ack_info->seqlock);
+		ack_info->last_time = jiffies;
+		ack_info->timeout = msecs_to_jiffies(SPRDWL_ACK_OLD_TIME);
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 14, 0)
+		timer_setup(&ack_info->timer, sprdwl_tcp_ack_timeout, 0);
+#else
+		setup_timer(&ack_info->timer, sprdwl_tcp_ack_timeout,
+			    (unsigned long)ack_info);
+#endif
+	}
+
+	atomic_set(&ack_m->enable, 1);
+	ack_m->ack_winsize = MIN_WIN;
+}
+
+void sprdwl_tcp_ack_deinit(struct sprdwl_priv *priv)
+{
+	int i;
+	struct sprdwl_tcp_ack_manage *ack_m = &priv->ack_m;
+	struct sprdwl_msg_buf *drop_msg = NULL;
+
+	atomic_set(&ack_m->enable, 0);
+
+	for (i = 0; i < SPRDWL_TCP_ACK_NUM; i++) {
+		drop_msg = NULL;
+
+		write_seqlock_bh(&ack_m->ack_info[i].seqlock);
+		del_timer(&ack_m->ack_info[i].timer);
+		drop_msg = ack_m->ack_info[i].msgbuf;
+		ack_m->ack_info[i].msgbuf = NULL;
+		write_sequnlock_bh(&ack_m->ack_info[i].seqlock);
+
+		if (drop_msg)
+			sprdwl_intf_tcp_drop_msg(priv, drop_msg);
+	}
+}
+
+static int sprdwl_tcp_check_quick_ack(unsigned char *buf,
+				      struct sprdwl_tcp_ack_msg *msg)
+{
+	int ip_hdr_len;
+	unsigned char *temp;
+	struct ethhdr *ethhdr;
+	struct iphdr *iphdr;
+	struct tcphdr *tcphdr;
+
+	ethhdr = (struct ethhdr *)buf;
+	if (ethhdr->h_proto != htons(ETH_P_IP))
+		return 0;
+	iphdr = (struct iphdr *)(ethhdr + 1);
+	if (iphdr->version != 4 || iphdr->protocol != IPPROTO_TCP)
+		return 0;
+	ip_hdr_len = iphdr->ihl * 4;
+	temp = (unsigned char *)(iphdr) + ip_hdr_len;
+	tcphdr = (struct tcphdr *)temp;
+	/* TCP_FLAG_ACK */
+	if (!(temp[13] & 0x10))
+		return 0;
+
+	if (temp[13] & 0x8) {
+		msg->saddr = iphdr->daddr;
+		msg->daddr = iphdr->saddr;
+		msg->source = tcphdr->dest;
+		msg->dest = tcphdr->source;
+		msg->seq = ntohl(tcphdr->seq);
+		return 1;
+	}
+
+	return 0;
+}
+
+static int is_drop_tcp_ack(struct tcphdr *tcphdr, int tcp_tot_len,
+				unsigned short *win_scale)
+{
+	int drop = 1;
+	int len = tcphdr->doff * 4;
+	unsigned char *ptr;
+
+	if (tcp_tot_len > len) {
+		drop = 0;
+	} else {
+		len -= sizeof(struct tcphdr);
+		ptr = (unsigned char *)(tcphdr + 1);
+
+		while ((len > 0) && drop) {
+			int opcode = *ptr++;
+			int opsize;
+
+			switch (opcode) {
+			case TCPOPT_EOL:
+				break;
+			case TCPOPT_NOP:
+				len--;
+				continue;
+			default:
+				opsize = *ptr++;
+				if (opsize < 2)
+					break;
+				if (opsize > len)
+					break;
+
+				switch (opcode) {
+				/* TODO: Add other ignore opt */
+				case TCPOPT_TIMESTAMP:
+					break;
+				case TCPOPT_WINDOW:
+					if (*ptr < 15)
+						*win_scale = (1 << (*ptr));
+					break;
+				default:
+					drop = 2;
+				}
+
+				ptr += opsize - 2;
+				len -= opsize;
+			}
+		}
+	}
+
+	return drop;
+}
+
+/* flag:0 for not tcp ack
+ *	1 for ack which can be drop
+ *	2 for other ack whith more info
+ */
+static int sprdwl_tcp_check_ack(unsigned char *buf,
+				struct sprdwl_tcp_ack_msg *msg,
+				unsigned short *win_scale)
+{
+	int ret;
+	int ip_hdr_len;
+	int tcp_tot_len;
+	unsigned char *temp;
+	struct ethhdr *ethhdr;
+	struct iphdr *iphdr;
+	struct tcphdr *tcphdr;
+
+	ethhdr = (struct ethhdr *)buf;
+	if (ethhdr->h_proto != htons(ETH_P_IP))
+		return 0;
+	iphdr = (struct iphdr *)(ethhdr + 1);
+	if (iphdr->version != 4 || iphdr->protocol != IPPROTO_TCP)
+		return 0;
+	ip_hdr_len = iphdr->ihl * 4;
+	temp = (unsigned char *)(iphdr) + ip_hdr_len;
+	tcphdr = (struct tcphdr *)temp;
+	/* TCP_FLAG_ACK */
+	if (!(temp[13] & 0x10))
+		return 0;
+
+	tcp_tot_len = ntohs(iphdr->tot_len) - ip_hdr_len;
+	ret = is_drop_tcp_ack(tcphdr, tcp_tot_len, win_scale);
+
+	if (ret > 0) {
+		msg->saddr = iphdr->saddr;
+		msg->daddr = iphdr->daddr;
+		msg->source = tcphdr->source;
+		msg->dest = tcphdr->dest;
+		msg->seq = ntohl(tcphdr->ack_seq);
+		msg->win = ntohs(tcphdr->window);
+	}
+
+	return ret;
+}
+
+/* return val: -1 for not match, others for match */
+static int sprdwl_tcp_ack_match(struct sprdwl_tcp_ack_manage *ack_m,
+				struct sprdwl_tcp_ack_msg *ack_msg)
+{
+	int i, ret = -1;
+	unsigned start;
+	struct sprdwl_tcp_ack_info *ack_info;
+	struct sprdwl_tcp_ack_msg *ack;
+
+	for (i = 0; ((ret < 0) && (i < SPRDWL_TCP_ACK_NUM)); i++) {
+		ack_info = &ack_m->ack_info[i];
+		do {
+			start = read_seqbegin(&ack_info->seqlock);
+			ret = -1;
+
+			ack = &ack_info->ack_msg;
+			if (ack_info->busy &&
+			    ack->dest == ack_msg->dest &&
+			    ack->source == ack_msg->source &&
+			    ack->saddr == ack_msg->saddr &&
+			    ack->daddr == ack_msg->daddr)
+				ret = i;
+		} while (read_seqretry(&ack_info->seqlock, start));
+	}
+
+	return ret;
+}
+
+static void sprdwl_tcp_ack_update(struct sprdwl_tcp_ack_manage *ack_m)
+{
+	int i;
+	struct sprdwl_tcp_ack_info *ack_info;
+
+	if (time_after(jiffies, ack_m->last_time + ack_m->timeout)) {
+		spin_lock_bh(&ack_m->lock);
+		ack_m->last_time = jiffies;
+		for (i = SPRDWL_TCP_ACK_NUM - 1; i >= 0; i--) {
+			ack_info = &ack_m->ack_info[i];
+			write_seqlock_bh(&ack_info->seqlock);
+			if (ack_info->busy &&
+			    time_after(jiffies, ack_info->last_time +
+				       ack_info->timeout)) {
+				ack_m->free_index = i;
+				ack_m->max_num--;
+				ack_info->busy = 0;
+			}
+			write_sequnlock_bh(&ack_info->seqlock);
+		}
+		spin_unlock_bh(&ack_m->lock);
+	}
+}
+
+/* return val: -1 for no index, others for index */
+static int sprdwl_tcp_ack_alloc_index(struct sprdwl_tcp_ack_manage *ack_m)
+{
+	int i, ret = -1;
+	struct sprdwl_tcp_ack_info *ack_info;
+	unsigned start;
+
+	spin_lock_bh(&ack_m->lock);
+	if (ack_m->max_num == SPRDWL_TCP_ACK_NUM) {
+		spin_unlock_bh(&ack_m->lock);
+		return -1;
+	}
+
+	if (ack_m->free_index >= 0) {
+		i = ack_m->free_index;
+		ack_m->free_index = -1;
+		ack_m->max_num++;
+		spin_unlock_bh(&ack_m->lock);
+		return i;
+	}
+
+	for (i = 0; ((ret < 0) && (i < SPRDWL_TCP_ACK_NUM)); i++) {
+		ack_info = &ack_m->ack_info[i];
+		do {
+			start = read_seqbegin(&ack_info->seqlock);
+			ret = -1;
+			if (!ack_info->busy) {
+				ack_m->free_index = -1;
+				ack_m->max_num++;
+				ret = i;
+			}
+		} while (read_seqretry(&ack_info->seqlock, start));
+	}
+	spin_unlock_bh(&ack_m->lock);
+
+	return ret;
+}
+
+/* return val: 0 for not handle tx, 1 for handle tx */
+int sprdwl_tcp_ack_handle(struct sprdwl_msg_buf *new_msgbuf,
+			  struct sprdwl_tcp_ack_manage *ack_m,
+			  struct sprdwl_tcp_ack_info *ack_info,
+			  struct sprdwl_tcp_ack_msg *ack_msg,
+			  int type)
+{
+	int quick_ack = 0;
+	struct sprdwl_tcp_ack_msg *ack;
+	int ret = 0;
+	struct sprdwl_msg_buf *drop_msg = NULL;
+
+	write_seqlock_bh(&ack_info->seqlock);
+
+	ack_info->last_time = jiffies;
+	ack = &ack_info->ack_msg;
+
+	if (type == 2) {
+		if (SPRDWL_U32_BEFORE(ack->seq, ack_msg->seq)) {
+			ack->seq = ack_msg->seq;
+			if (ack_info->psh_flag &&
+			    !SPRDWL_U32_BEFORE(ack_msg->seq,
+					       ack_info->psh_seq)) {
+				ack_info->psh_flag = 0;
+			}
+
+			if (ack_info->msgbuf) {
+				drop_msg = ack_info->msgbuf;
+				ack_info->msgbuf = NULL;
+				del_timer(&ack_info->timer);
+			}
+
+			ack_info->in_send_msg = NULL;
+			ack_info->drop_cnt = atomic_read(&ack_m->max_drop_cnt);
+		} else {
+			wl_err("%s before abnormal ack: %d, %d\n",
+			       __func__, ack->seq, ack_msg->seq);
+			drop_msg = new_msgbuf;
+			ret = 1;
+		}
+	} else if (SPRDWL_U32_BEFORE(ack->seq, ack_msg->seq)) {
+		if (ack_info->msgbuf) {
+			drop_msg = ack_info->msgbuf;
+			ack_info->msgbuf = NULL;
+		}
+
+		if (ack_info->psh_flag &&
+		    !SPRDWL_U32_BEFORE(ack_msg->seq, ack_info->psh_seq)) {
+			ack_info->psh_flag = 0;
+			quick_ack = 1;
+		} else {
+			ack_info->drop_cnt++;
+		}
+
+		ack->seq = ack_msg->seq;
+
+		if (quick_ack || (!ack_info->in_send_msg &&
+				  (ack_info->drop_cnt >=
+				   atomic_read(&ack_m->max_drop_cnt)))) {
+			ack_info->drop_cnt = 0;
+			ack_info->in_send_msg = new_msgbuf;
+			del_timer(&ack_info->timer);
+		} else {
+			ret = 1;
+			ack_info->msgbuf = new_msgbuf;
+			if (!timer_pending(&ack_info->timer))
+				mod_timer(&ack_info->timer,
+					  (jiffies + msecs_to_jiffies(5)));
+		}
+	} else {
+		wl_err("%s before ack: %d, %d\n",
+		       __func__, ack->seq, ack_msg->seq);
+		drop_msg = new_msgbuf;
+		ret = 1;
+	}
+
+	write_sequnlock_bh(&ack_info->seqlock);
+
+	if (drop_msg)
+		sprdwl_intf_tcp_drop_msg(ack_m->priv, drop_msg);
+
+	return ret;
+}
+
+void sprdwl_filter_rx_tcp_ack(struct sprdwl_priv *priv,
+			      unsigned char *buf, unsigned plen)
+{
+	int index;
+	struct sprdwl_tcp_ack_msg ack_msg;
+	struct sprdwl_tcp_ack_info *ack_info;
+	struct sprdwl_tcp_ack_manage *ack_m = &priv->ack_m;
+
+	if (!atomic_read(&ack_m->enable))
+		return;
+
+	if ((plen > MAX_TCP_ACK) ||
+	    !sprdwl_tcp_check_quick_ack(buf, &ack_msg))
+		return;
+
+	index = sprdwl_tcp_ack_match(ack_m, &ack_msg);
+	if (index >= 0) {
+		ack_info = ack_m->ack_info + index;
+		write_seqlock_bh(&ack_info->seqlock);
+		ack_info->psh_flag = 1;
+		ack_info->psh_seq = ack_msg.seq;
+		write_sequnlock_bh(&ack_info->seqlock);
+	}
+}
+
+/* return val: 0 for not filter, 1 for filter */
+int sprdwl_filter_send_tcp_ack(struct sprdwl_priv *priv,
+			       struct sprdwl_msg_buf *msgbuf,
+			       unsigned char *buf, unsigned int plen)
+{
+	int ret = 0;
+	int index, drop;
+	unsigned short win_scale = 0;
+	unsigned int win = 0;
+	struct sprdwl_tcp_ack_msg ack_msg;
+	struct sprdwl_tcp_ack_msg *ack;
+	struct sprdwl_tcp_ack_info *ack_info;
+	struct sprdwl_tcp_ack_manage *ack_m = &priv->ack_m;
+
+	if (!atomic_read(&ack_m->enable))
+		return 0;
+
+	if (plen > MAX_TCP_ACK)
+		return 0;
+
+	sprdwl_tcp_ack_update(ack_m);
+	drop = sprdwl_tcp_check_ack(buf, &ack_msg, &win_scale);
+	if (!drop && (0 == win_scale))
+		return 0;
+
+	index = sprdwl_tcp_ack_match(ack_m, &ack_msg);
+	if (index >= 0) {
+		ack_info = ack_m->ack_info + index;
+		if ((0 != win_scale) &&
+			(ack_info->win_scale != win_scale)) {
+			write_seqlock_bh(&ack_info->seqlock);
+			ack_info->win_scale = win_scale;
+			write_sequnlock_bh(&ack_info->seqlock);
+		}
+
+		if (drop > 0) {
+			win = ack_info->win_scale * ack_msg.win;
+			if (win < (ack_m->ack_winsize * SIZE_KB))
+				drop = 2;
+
+			ret = sprdwl_tcp_ack_handle(msgbuf, ack_m, ack_info,
+						&ack_msg, drop);
+		}
+
+		goto out;
+	}
+
+	index = sprdwl_tcp_ack_alloc_index(ack_m);
+	if (index >= 0) {
+		write_seqlock_bh(&ack_m->ack_info[index].seqlock);
+		ack_m->ack_info[index].busy = 1;
+		ack_m->ack_info[index].psh_flag = 0;
+		ack_m->ack_info[index].last_time = jiffies;
+		ack_m->ack_info[index].drop_cnt =
+			atomic_read(&ack_m->max_drop_cnt);
+		ack_m->ack_info[index].win_scale =
+			(win_scale != 0) ? win_scale : 1;
+
+		ack = &ack_m->ack_info[index].ack_msg;
+		ack->dest = ack_msg.dest;
+		ack->source = ack_msg.source;
+		ack->saddr = ack_msg.saddr;
+		ack->daddr = ack_msg.daddr;
+		ack->seq = ack_msg.seq;
+		write_sequnlock_bh(&ack_m->ack_info[index].seqlock);
+	}
+
+out:
+	return ret;
+}
+
+void sprdwl_move_tcpack_msg(struct sprdwl_priv *priv,
+			    struct sprdwl_msg_buf *msg)
+{
+	struct sprdwl_tcp_ack_info *ack_info;
+	struct sprdwl_tcp_ack_manage *ack_m = &priv->ack_m;
+	int i = 0;
+
+	if (!atomic_read(&ack_m->enable))
+		return;
+
+	if (msg->len > MAX_TCP_ACK)
+		return;
+
+	for (i = 0; i < SPRDWL_TCP_ACK_NUM; i++) {
+		ack_info = &ack_m->ack_info[i];
+		write_seqlock_bh(&ack_info->seqlock);
+		if (ack_info->busy && (ack_info->in_send_msg == msg))
+			ack_info->in_send_msg = NULL;
+		write_sequnlock_bh(&ack_info->seqlock);
+	}
+}
+
+extern struct sprdwl_priv *g_sprdwl_priv;
+
+void enable_tcp_ack_delay(char *buf, unsigned char offset)
+{
+	int enable = buf[offset] - '0';
+	int i;
+	struct sprdwl_tcp_ack_manage *ack_m = NULL;
+	struct sprdwl_msg_buf *drop_msg = NULL;
+
+	if (!g_sprdwl_priv)
+		return ;
+
+	ack_m = &g_sprdwl_priv->ack_m;
+
+	if (enable == 0) {
+		atomic_set(&ack_m->enable, 0);
+		for (i = 0; i < SPRDWL_TCP_ACK_NUM; i++) {
+			drop_msg = NULL;
+
+			write_seqlock_bh(&ack_m->ack_info[i].seqlock);
+			drop_msg = ack_m->ack_info[i].msgbuf;
+			ack_m->ack_info[i].msgbuf = NULL;
+			del_timer(&ack_m->ack_info[i].timer);
+			write_sequnlock_bh(&ack_m->ack_info[i].seqlock);
+
+			if (drop_msg)
+				sprdwl_intf_tcp_drop_msg(g_sprdwl_priv,
+							 drop_msg);
+		}
+	} else {
+		atomic_set(&ack_m->enable, 1);
+	}
+}
+
+void adjust_tcp_ack_delay(char *buf, unsigned char offset)
+{
+#define MAX_LEN 2
+	unsigned int cnt = 0;
+	unsigned int i = 0;
+	struct sprdwl_tcp_ack_manage *ack_m = NULL;
+
+	if (!g_sprdwl_priv)
+		return ;
+
+	for (i = 0; i < MAX_LEN; (cnt *= 10), i++) {
+
+		if ((buf[offset + i] >= '0') &&
+		   (buf[offset + i] <= '9')) {
+			cnt += (buf[offset + i] - '0');
+		} else {
+			cnt /= 10;
+			break;
+		}
+	}
+
+	ack_m = &g_sprdwl_priv->ack_m;
+	wl_err("cnt: %d\n", cnt);
+
+	if (cnt >= 100)
+		cnt = SPRDWL_TCP_ACK_DROP_CNT;
+
+	atomic_set(&ack_m->max_drop_cnt, cnt);
+	wl_err("drop time: %d, atomic drop time: %d\n", cnt, atomic_read(&ack_m->max_drop_cnt));
+#undef MAX_LEN
+}
+
+void adjust_tcp_ack_delay_win(char *buf, unsigned char offset)
+{
+	unsigned int value = 0;
+	unsigned int i = 0;
+	unsigned int len = strlen(buf) - strlen("tcpack_delay_win=");
+	struct sprdwl_tcp_ack_manage *ack_m = NULL;
+
+	if (!g_sprdwl_priv)
+		return;
+
+	for (i = 0; i < len; (value *= 10), i++) {
+		if ((buf[offset + i] >= '0') &&
+		   (buf[offset + i] <= '9')) {
+			value += (buf[offset + i] - '0');
+		} else {
+			value /= 10;
+			break;
+		}
+	}
+	ack_m = &g_sprdwl_priv->ack_m;
+	ack_m->ack_winsize = value;
+	wl_err("%s, change tcpack_delay_win to %dKB\n", __func__, value);
+}
diff --git a/drivers/net/wireless/uwe5622/unisocwifi/tcp_ack.h b/drivers/net/wireless/uwe5622/unisocwifi/tcp_ack.h
new file mode 100644
index 000000000000..1ff26aa3fe9a
--- /dev/null
+++ b/drivers/net/wireless/uwe5622/unisocwifi/tcp_ack.h
@@ -0,0 +1,89 @@
+/*
+ * Copyright (C) 2016 Spreadtrum Communications Inc.
+ *
+ * Authors:
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#ifndef __SPRDWL_TCP_ACK_H__
+#define __SPRDWL_TCP_ACK_H__
+
+#include "msg.h"
+
+#define SPRDWL_TCP_ACK_NUM  32
+#define SPRDWL_TCP_ACK_EXIT_VAL		0x800
+#define SPRDWL_TCP_ACK_DROP_CNT		24
+
+#define SPRDWL_ACK_OLD_TIME	4000
+#define SPRDWL_U32_BEFORE(a, b)	((__s32)((__u32)a - (__u32)b) <= 0)
+
+#define MAX_TCP_ACK 200
+/*min window size in KB, it's 256KB*/
+#define MIN_WIN 256
+#define SIZE_KB 1024
+
+extern unsigned int tcp_ack_drop_cnt;
+struct sprdwl_tcp_ack_msg {
+	u16 source;
+	u16 dest;
+	s32 saddr;
+	s32 daddr;
+	u32 seq;
+	u16 win;
+};
+
+struct sprdwl_tcp_ack_info {
+	int ack_info_num;
+	int busy;
+	int drop_cnt;
+	int psh_flag;
+	u32 psh_seq;
+	u16 win_scale;
+	/* seqlock for ack info */
+	seqlock_t seqlock;
+	unsigned long last_time;
+	unsigned long timeout;
+	struct timer_list timer;
+	struct sprdwl_msg_buf *msgbuf;
+	struct sprdwl_msg_buf *in_send_msg;
+	struct sprdwl_tcp_ack_msg ack_msg;
+};
+
+struct sprdwl_tcp_ack_manage {
+	/* 1 filter */
+	atomic_t enable;
+	int max_num;
+	int free_index;
+	unsigned long last_time;
+	unsigned long timeout;
+	atomic_t max_drop_cnt;
+	/* lock for tcp ack alloc and free */
+	spinlock_t lock;
+	struct sprdwl_priv *priv;
+	struct sprdwl_tcp_ack_info ack_info[SPRDWL_TCP_ACK_NUM];
+	/*size in KB*/
+	unsigned int ack_winsize;
+};
+
+void sprdwl_tcp_ack_init(struct sprdwl_priv *priv);
+void sprdwl_tcp_ack_deinit(struct sprdwl_priv *priv);
+void sprdwl_filter_rx_tcp_ack(struct sprdwl_priv *priv,
+			      unsigned char *buf, unsigned int plen);
+/* return val: 0 for not fileter, 1 for fileter */
+int sprdwl_filter_send_tcp_ack(struct sprdwl_priv *priv,
+			       struct sprdwl_msg_buf *msgbuf,
+			       unsigned char *buf, unsigned int plen);
+void enable_tcp_ack_delay(char *buf, unsigned char offset);
+void adjust_tcp_ack_delay(char *buf, unsigned char offset);
+void sprdwl_move_tcpack_msg(struct sprdwl_priv *priv,
+			    struct sprdwl_msg_buf *msg);
+void adjust_tcp_ack_delay_win(char *buf, unsigned char offset);
+#endif
diff --git a/drivers/net/wireless/uwe5622/unisocwifi/tracer.c b/drivers/net/wireless/uwe5622/unisocwifi/tracer.c
new file mode 100644
index 000000000000..f8308a5ecdfc
--- /dev/null
+++ b/drivers/net/wireless/uwe5622/unisocwifi/tracer.c
@@ -0,0 +1,192 @@
+#include <linux/etherdevice.h>
+#include <linux/ipv6.h>
+#include <linux/ip.h>
+#include <net/ndisc.h>
+#include <linux/suspend.h>
+#include <linux/workqueue.h>
+#include <linux/kallsyms.h>
+#include "msg.h"
+#include "tracer.h"
+#include "cmdevt.h"
+#include "rx_msg.h"
+
+#define WAKEUP_TIME_EXPIRED 500
+
+static struct deauth_trace deauth;
+static void deauth_reason_worker(struct work_struct *work);
+static DECLARE_WORK(deauth_worker, deauth_reason_worker);
+
+static void deauth_reason_worker(struct work_struct *work)
+{
+	int i, j;
+	struct deauth_info *dinfo;
+
+	wl_info("deauth reason dump: == START ==\n");
+	for (i = 0; i < SPRDWL_MODE_MAX; i++) {
+		for (j = 0; j < MAX_DEAUTH_REASON; j++) {
+			dinfo = &deauth.deauth_mode[i];
+			if (dinfo->local_deauth[j] != 0)
+				wl_info("mode[%d] local reason[%d]:%ld times\n",
+					i, j, dinfo->local_deauth[j]);
+
+			if (dinfo->remote_deauth[j] != 0)
+				wl_info("mode[%d] remote reason[%d]:%ld times\n",
+					i, j, dinfo->remote_deauth[j]);
+		}
+	}
+
+	wl_info("deauth reason dump: == END ==\n");
+}
+
+void trace_deauth_reason(int mode, u16 reason_code, int dirction)
+{
+	struct deauth_info *dinfo;
+
+	if (reason_code > MAX_DEAUTH_REASON) {
+		wl_info("deauth reason:%d not record\n", reason_code);
+		return;
+	}
+
+	dinfo = &deauth.deauth_mode[mode];
+	spin_lock_bh(&deauth.lock);
+	switch (dirction) {
+	case LOCAL_EVENT:
+		dinfo->local_deauth[reason_code]++;
+		break;
+	default:
+		dinfo->remote_deauth[reason_code]++;
+		break;
+	}
+
+	spin_unlock_bh(&deauth.lock);
+
+	schedule_work(&deauth_worker);
+}
+
+static void trace_rx_icmp6_wake(struct wakeup_trace *tracer, void *data)
+{
+	void *iphdr_addr;
+	struct ipv6hdr *ipv6_hdr;
+	struct icmp6hdr *icmp6_hdr;
+
+	iphdr_addr = data + sizeof(struct ethhdr);
+	ipv6_hdr = iphdr_addr;
+	if (ipv6_hdr->nexthdr == IPPROTO_ICMPV6) {
+		tracer->pkt_type_dtl.icmp6_pkt_cnt++;
+
+		icmp6_hdr = (struct icmp6hdr *)(iphdr_addr + sizeof(*ipv6_hdr));
+		switch (icmp6_hdr->icmp6_type) {
+		case NDISC_ROUTER_ADVERTISEMENT:
+			tracer->pkt_type_dtl.icmp6_ra_cnt++;
+			break;
+
+		case NDISC_NEIGHBOUR_SOLICITATION:
+			tracer->pkt_type_dtl.icmp6_ns_cnt++;
+			break;
+
+		case NDISC_NEIGHBOUR_ADVERTISEMENT:
+			tracer->pkt_type_dtl.icmp6_na_cnt++;
+			break;
+
+		default:
+			break;
+		}
+	}
+}
+
+static void trace_rx_data_wake(struct wakeup_trace *tracer, void *data)
+{
+	void *iphdr_addr = data;
+	struct ethhdr *ether_hdr = data;
+	struct iphdr *ipv4_hdr;
+
+	if (is_broadcast_ether_addr(ether_hdr->h_dest)) {
+		tracer->rx_data_dtl.rx_brdcst_cnt++;
+	} else if (is_multicast_ether_addr(ether_hdr->h_dest)) {
+		switch (ntohs(ether_hdr->h_proto)) {
+		case ETH_P_IP:
+			tracer->rx_data_dtl.rx_mc_dtl.ipv4_mc_cnt++;
+			break;
+		case ETH_P_IPV6:
+			tracer->rx_data_dtl.rx_mc_dtl.ipv6_mc_cnt++;
+			trace_rx_icmp6_wake(tracer, ether_hdr);
+			break;
+		default:
+			tracer->rx_data_dtl.rx_mc_dtl.other_mc_cnt++;
+			break;
+		}
+
+	} else { /*unicast*/
+		tracer->rx_data_dtl.rx_unicast_cnt++;
+		iphdr_addr += sizeof(*ether_hdr);
+		switch (ntohs(ether_hdr->h_proto)) {
+		case ETH_P_IP:
+			ipv4_hdr = iphdr_addr;
+			if (ipv4_hdr->protocol == IPPROTO_ICMP)
+				tracer->pkt_type_dtl.icmp_pkt_cnt++;
+			break;
+
+		case ETH_P_IPV6:
+			trace_rx_icmp6_wake(tracer, ether_hdr);
+			break;
+		default:
+			wl_info("recv proto = 0x%x\n",
+				ntohs(ether_hdr->h_proto));
+			break;
+		}
+	}
+}
+
+void trace_rx_wakeup(struct wakeup_trace *tracer, void *data, void *rdata)
+{
+	int type;
+	struct rx_msdu_desc *msdu;
+
+	if (!SPRD_HEAD_GET_RESUME_BIT(data))
+		return;
+
+	tracer->resume_flag = 0;
+
+	type = SPRDWL_HEAD_GET_TYPE(data);
+	switch (type) {
+	/* commands or events between command WIFI_CMD_POWER_SAVE
+	 * and its respone just consider as one wake up source
+	 */
+	case SPRDWL_TYPE_CMD:
+	case SPRDWL_TYPE_EVENT:
+		tracer->total_cmd_event_wake++;
+		wl_info("wake up by cmd/event[%d] (%d times)\n",
+			type, tracer->total_cmd_event_wake);
+		break;
+
+	case SPRDWL_TYPE_DATA_SPECIAL:
+		tracer->total_rx_data_wake++;
+
+		msdu = (struct rx_msdu_desc *)rdata;
+		trace_rx_data_wake(tracer, rdata + msdu->msdu_offset);
+		wl_info("wake up by data (%d times)\n",
+			tracer->total_rx_data_wake);
+		break;
+
+	case SPRDWL_TYPE_PKT_LOG:
+		tracer->total_local_wake++;
+		wl_info("wake up by pkt log (%d times)\n",
+			tracer->total_local_wake);
+		break;
+
+	default:
+		wl_info("wake up source untrace type = 0x%x\n", type);
+		break;
+	}
+}
+
+void trace_info_init(void)
+{
+	spin_lock_init(&deauth.lock);
+}
+
+void trace_info_deinit(void)
+{
+	cancel_work_sync(&deauth_worker);
+}
+
diff --git a/drivers/net/wireless/uwe5622/unisocwifi/tracer.h b/drivers/net/wireless/uwe5622/unisocwifi/tracer.h
new file mode 100644
index 000000000000..196ff453173e
--- /dev/null
+++ b/drivers/net/wireless/uwe5622/unisocwifi/tracer.h
@@ -0,0 +1,54 @@
+#ifndef __TRACER_H__
+#define __TRACER_H__
+
+#include "cfg80211.h"
+
+#define MAX_DEAUTH_REASON 256
+
+#define LOCAL_EVENT  0
+#define REMOTE_EVENT 1
+
+struct deauth_info {
+	unsigned long local_deauth[MAX_DEAUTH_REASON];
+	unsigned long remote_deauth[MAX_DEAUTH_REASON];
+};
+
+struct deauth_trace {
+	spinlock_t lock; /* spinlock for deauth statistics */
+	struct  deauth_info deauth_mode[SPRDWL_MODE_MAX];
+};
+
+struct rx_pkt_type_wakeup_details {
+	u32 icmp_pkt_cnt;
+	u32 icmp6_pkt_cnt;
+	u32 icmp6_ra_cnt;
+	u32 icmp6_na_cnt;
+	u32 icmp6_ns_cnt;
+};
+
+struct rx_mc_wakeup_details {
+	u32 ipv4_mc_cnt;
+	u32 ipv6_mc_cnt;
+	u32 other_mc_cnt;
+};
+
+struct rx_data_wakeup_details {
+	u32 rx_unicast_cnt;
+	u32 rx_brdcst_cnt;
+	struct rx_mc_wakeup_details rx_mc_dtl;
+};
+
+struct wakeup_trace {
+	u32 resume_flag;
+	u32 total_cmd_event_wake;
+	u32 total_rx_data_wake;
+	u32 total_local_wake;
+	struct rx_data_wakeup_details rx_data_dtl;
+	struct rx_pkt_type_wakeup_details pkt_type_dtl;
+};
+
+void trace_info_init(void);
+void trace_info_deinit(void);
+void trace_deauth_reason(int mode, u16 reason_code, int dirction);
+void trace_rx_wakeup(struct wakeup_trace *tracer, void *data, void *rdata);
+#endif
diff --git a/drivers/net/wireless/uwe5622/unisocwifi/tx_msg.c b/drivers/net/wireless/uwe5622/unisocwifi/tx_msg.c
new file mode 100644
index 000000000000..399e383135ba
--- /dev/null
+++ b/drivers/net/wireless/uwe5622/unisocwifi/tx_msg.c
@@ -0,0 +1,1833 @@
+/*
+ * Copyright (C) 2016 Spreadtrum Communications Inc.
+ *
+ * Authors	:
+ * star.liu <star.liu@spreadtrum.com>
+ * yifei.li <yifei.li@spreadtrum.com>
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include <linux/platform_device.h>
+#include <linux/utsname.h>
+#include <linux/kernel.h>
+#include <linux/workqueue.h>
+#include <linux/ip.h>
+#include <linux/ipv6.h>
+#include <net/ip.h>
+#include "tx_msg.h"
+#include "rx_msg.h"
+#include "cfg80211.h"
+#include "wl_core.h"
+#include "sprdwl.h"
+#include "wl_intf.h"
+#include "mm.h"
+#include "intf_ops.h"
+#include "cmdevt.h"
+#include "debug.h"
+#include <linux/kthread.h>
+
+struct sprdwl_msg_buf *sprdwl_get_msg_buf(void *pdev,
+					  enum sprdwl_head_type type,
+					  enum sprdwl_mode mode,
+					  u8 ctx_id)
+{
+	struct sprdwl_intf *dev;
+	struct sprdwl_msg_buf *msg = NULL;
+	struct sprdwl_msg_list *list = NULL;
+	struct sprdwl_tx_msg *sprdwl_tx_dev = NULL;
+	struct sprdwl_msg_buf *msg_buf;
+#if defined(MORE_DEBUG)
+	struct timespec tx_begin;
+#endif
+
+	dev = (struct sprdwl_intf *)pdev;
+	sprdwl_tx_dev = (struct sprdwl_tx_msg *)dev->sprdwl_tx;
+	sprdwl_tx_dev->mode = mode;
+
+	if (unlikely(dev->exit))
+		return NULL;
+
+	if (type == SPRDWL_TYPE_DATA)
+		list = &sprdwl_tx_dev->tx_list_qos_pool;
+	else
+		list = &sprdwl_tx_dev->tx_list_cmd;
+
+	if (!list) {
+		wl_err("%s: type %d could not get list\n", __func__, type);
+		return NULL;
+	}
+
+	if (type == SPRDWL_TYPE_DATA && atomic_read(&list->ref) > (SPRDWL_TX_QOS_POOL_SIZE * 8 / 10)) {
+		msg_buf = kzalloc(sizeof(*msg_buf), GFP_KERNEL);
+		if (msg_buf) {
+			INIT_LIST_HEAD(&msg_buf->list);
+			spin_lock_bh(&sprdwl_tx_dev->tx_list_qos_pool.freelock);
+			list_add_tail(&msg_buf->list,
+			&sprdwl_tx_dev->tx_list_qos_pool.freelist);
+			spin_unlock_bh(&sprdwl_tx_dev->tx_list_qos_pool.freelock);
+			sprdwl_tx_dev->tx_list_qos_pool.maxnum++;
+			msg = sprdwl_alloc_msg_buf(list);
+		} else {
+			wl_err("%s failed to alloc msg_buf!\n", __func__);
+		}
+	} else {
+		msg = sprdwl_alloc_msg_buf(list);
+	}
+
+	if (msg) {
+#if defined(MORE_DEBUG)
+		getnstimeofday(&tx_begin);
+		msg->tx_start_time = timespec_to_ns(&tx_begin);
+#endif
+		if (type == SPRDWL_TYPE_DATA)
+			msg->msg_type = SPRDWL_TYPE_DATA;
+		msg->type = type;
+		msg->msglist = list;
+		msg->mode = mode;
+		msg->xmit_msg_list = &sprdwl_tx_dev->xmit_msg_list;
+		return msg;
+	}
+
+	if (type == SPRDWL_TYPE_DATA) {
+		sprdwl_tx_dev->net_stop_cnt++;
+		sprdwl_net_flowcontrl(dev->priv, mode, false);
+		atomic_set(&list->flow, 1);
+	}
+	wl_err_ratelimited("%s no more msgbuf for %s\n",
+			   __func__, type == SPRDWL_TYPE_DATA ?
+			   "data" : "cmd");
+
+	return NULL;
+}
+
+static void sprdwl_dequeue_cmd_buf(struct sprdwl_msg_buf *msg_buf,
+				    struct sprdwl_msg_list *list)
+{
+	spin_lock_bh(&list->busylock);
+	list_del(&msg_buf->list);
+	spin_unlock_bh(&list->busylock);
+
+	spin_lock_bh(&list->complock);
+	list_add_tail(&msg_buf->list, &list->cmd_to_free);
+	spin_unlock_bh(&list->complock);
+}
+
+void sprdwl_free_cmd_buf(struct sprdwl_msg_buf *msg_buf,
+			   struct sprdwl_msg_list *list)
+{
+	spin_lock_bh(&list->complock);
+	list_del(&msg_buf->list);
+	spin_unlock_bh(&list->complock);
+	sprdwl_free_msg_buf(msg_buf, list);
+}
+
+void sprdwl_tx_free_msg_buf(void *pdev, struct sprdwl_msg_buf *msg)
+{
+	sprdwl_free_msg_buf(msg, msg->msglist);
+}
+
+static inline void
+sprdwl_queue_data_msg_buf(struct sprdwl_msg_buf *msg_buf)
+{
+#ifdef OTT_UWE
+	struct tx_msdu_dscr *dscr = (struct tx_msdu_dscr *)(msg_buf->tran_data + FOUR_BYTES_ALIGN_OFFSET);
+#else
+	struct tx_msdu_dscr *dscr = (struct tx_msdu_dscr *)(msg_buf->tran_data);
+#endif
+
+	spin_lock_bh(&msg_buf->data_list->p_lock);
+	/*to make sure ARP/TDLS/preauth can be tx ASAP*/
+	if (dscr->tx_ctrl.sw_rate == 1)
+		list_add(&msg_buf->list, &msg_buf->data_list->head_list);
+	else
+		list_add_tail(&msg_buf->list, &msg_buf->data_list->head_list);
+	atomic_inc(&msg_buf->data_list->l_num);
+	spin_unlock_bh(&msg_buf->data_list->p_lock);
+}
+
+static inline void
+sprdwl_dequeue_qos_buf(struct sprdwl_msg_buf *msg_buf, int ac_index)
+{
+	spinlock_t *lock;/*to lock qos list*/
+
+	if (ac_index != SPRDWL_AC_MAX)
+		lock = &msg_buf->data_list->p_lock;
+	else
+		lock = &msg_buf->xmit_msg_list->send_lock;
+	spin_lock_bh(lock);
+	dev_kfree_skb(msg_buf->skb);
+	list_del(&msg_buf->list);
+	sprdwl_free_msg_buf(msg_buf, msg_buf->msglist);
+	spin_unlock_bh(lock);
+}
+
+void sprdwl_flush_tx_qoslist(struct sprdwl_tx_msg *tx_msg, int mode, int ac_index, int lut_index)
+{
+	/*peer list lock*/
+	spinlock_t *plock;
+	struct sprdwl_msg_buf *pos_buf, *temp_buf;
+	struct list_head *data_list;
+
+	data_list =
+	&tx_msg->tx_list[mode]->q_list[ac_index].p_list[lut_index].head_list;
+
+	plock =
+	&tx_msg->tx_list[mode]->q_list[ac_index].p_list[lut_index].p_lock;
+
+	if (!list_empty(data_list)) {
+		spin_lock_bh(plock);
+
+		list_for_each_entry_safe(pos_buf, temp_buf,
+					 data_list, list) {
+			dev_kfree_skb(pos_buf->skb);
+			list_del(&pos_buf->list);
+			sprdwl_free_msg_buf(pos_buf, pos_buf->msglist);
+		}
+
+		spin_unlock_bh(plock);
+
+		atomic_sub(atomic_read(&tx_msg->tx_list[mode]->q_list[ac_index].p_list[lut_index].l_num),
+					&tx_msg->tx_list[mode]->mode_list_num);
+		atomic_set(&tx_msg->tx_list[mode]->q_list[ac_index].p_list[lut_index].l_num, 0);
+	}
+}
+
+void sprdwl_flush_mode_txlist(struct sprdwl_tx_msg *tx_msg, enum sprdwl_mode mode)
+{
+	int i, j;
+	/*peer list lock*/
+	spinlock_t *plock;
+	struct sprdwl_msg_buf *pos_buf, *temp_buf;
+	struct list_head *data_list;
+
+	wl_info("%s, mode=%d\n", __func__, mode);
+
+	for (i = 0; i < SPRDWL_AC_MAX; i++) {
+		for (j = 0; j < MAX_LUT_NUM; j++) {
+			data_list =
+			&tx_msg->tx_list[mode]->q_list[i].p_list[j].head_list;
+			if (list_empty(data_list))
+				continue;
+			plock =
+			&tx_msg->tx_list[mode]->q_list[i].p_list[j].p_lock;
+
+			spin_lock_bh(plock);
+
+			list_for_each_entry_safe(pos_buf, temp_buf,
+						 data_list, list) {
+				dev_kfree_skb(pos_buf->skb);
+				list_del(&pos_buf->list);
+				sprdwl_free_msg_buf(pos_buf, pos_buf->msglist);
+			}
+
+			spin_unlock_bh(plock);
+
+			atomic_set(&tx_msg->tx_list[mode]->q_list[i].p_list[j].l_num, 0);
+		}
+	}
+	atomic_set(&tx_msg->tx_list[mode]->mode_list_num, 0);
+}
+
+void sprdwl_flush_tosendlist(struct sprdwl_tx_msg *tx_msg)
+{
+	struct sprdwl_msg_buf *pos_buf, *temp_buf;
+	struct list_head *data_list;
+
+	wl_debug("%s, %d\n", __func__, __LINE__);
+	if (!list_empty(&tx_msg->xmit_msg_list.to_send_list)) {
+		wl_warn("%s, %d, flush!\n", __func__, __LINE__);
+		data_list = &tx_msg->xmit_msg_list.to_send_list;
+		list_for_each_entry_safe(pos_buf, temp_buf,
+			data_list, list) {
+			sprdwl_dequeue_qos_buf(pos_buf, SPRDWL_AC_MAX);
+		}
+	}
+}
+
+static void sprdwl_flush_data_txlist(struct sprdwl_tx_msg *tx_msg)
+{
+	enum sprdwl_mode mode;
+	struct list_head *data_list;
+	int cnt = 0;
+
+	for (mode = SPRDWL_MODE_STATION; mode < SPRDWL_MODE_MAX; mode++) {
+		if (atomic_read(&tx_msg->tx_list[mode]->mode_list_num) == 0)
+			continue;
+		sprdwl_flush_mode_txlist(tx_msg, mode);
+	}
+
+	sprdwl_flush_tosendlist(tx_msg);
+	data_list = &tx_msg->xmit_msg_list.to_free_list;
+	/*wait until data list sent completely and freed by HIF*/
+	wl_debug("%s check if data freed complete start\n", __func__);
+	while (!list_empty(data_list) && (cnt < 1000)) {
+		usleep_range(2500, 3000);
+		cnt++;
+	}
+
+	wl_debug("%s check if data freed complete end\n", __func__);
+}
+
+void sprdwl_dequeue_data_buf(struct sprdwl_msg_buf *msg_buf)
+{
+	spin_lock_bh(&msg_buf->xmit_msg_list->free_lock);
+	list_del(&msg_buf->list);
+	spin_unlock_bh(&msg_buf->xmit_msg_list->free_lock);
+	sprdwl_free_msg_buf(msg_buf, msg_buf->msglist);
+}
+
+void sprdwl_dequeue_data_list(struct mbuf_t *head, int num)
+{
+	int i;
+	struct sprdwl_msg_buf *msg_pos;
+	struct mbuf_t *mbuf_pos = NULL;
+
+	mbuf_pos = head;
+	for (i = 0; i < num; i++) {
+		msg_pos = GET_MSG_BUF(mbuf_pos);
+		/*TODO, check msg_buf after pop link*/
+		if (msg_pos == NULL ||
+		    !virt_addr_valid(msg_pos) ||
+		    !virt_addr_valid(msg_pos->skb)) {
+			wl_err("%s,%d, error! wrong sprdwl_msg_buf\n",
+			       __func__, __LINE__);
+			BUG_ON(1);
+		}
+		dev_kfree_skb(msg_pos->skb);
+		/*delete node from to_free_list*/
+		spin_lock_bh(&msg_pos->xmit_msg_list->free_lock);
+		list_del(&msg_pos->list);
+		spin_unlock_bh(&msg_pos->xmit_msg_list->free_lock);
+		/*add it to free_list*/
+		spin_lock_bh(&msg_pos->msglist->freelock);
+		list_add_tail(&msg_pos->list, &msg_pos->msglist->freelist);
+		spin_unlock_bh(&msg_pos->msglist->freelock);
+		mbuf_pos = mbuf_pos->next;
+	}
+}
+
+/* seam for tx_thread */
+void tx_down(struct sprdwl_tx_msg *tx_msg)
+{
+	wait_for_completion(&tx_msg->tx_completed);
+}
+
+void tx_up(struct sprdwl_tx_msg *tx_msg)
+{
+	complete(&tx_msg->tx_completed);
+}
+
+/*To clear mode assigned in flow_ctrl
+ *and to flush data lit of closed mode
+ */
+void handle_tx_status_after_close(struct sprdwl_vif *vif)
+{
+	struct sprdwl_priv *priv = vif->priv;
+	enum sprdwl_mode mode;
+	u8 i, allmode_closed = 1;
+	struct sprdwl_intf *intf;
+	struct sprdwl_tx_msg *tx_msg;
+
+	for (mode = SPRDWL_MODE_STATION; mode < SPRDWL_MODE_MAX; mode++) {
+		if (priv->fw_stat[mode] != SPRDWL_INTF_CLOSE) {
+			allmode_closed = 0;
+			break;
+		}
+	}
+	intf = (struct sprdwl_intf *)(vif->priv->hw_priv);
+	tx_msg = (struct sprdwl_tx_msg *)intf->sprdwl_tx;
+	if (allmode_closed == 1) {
+		/*all modee closed,
+		 *reset all credit
+		*/
+		wl_info("%s, %d, _fc_, delete flow num after all closed\n",
+			__func__, __LINE__);
+		for (i = 0; i < MAX_COLOR_BIT; i++) {
+			tx_msg->flow_ctrl[i].mode = SPRDWL_MODE_NONE;
+			tx_msg->flow_ctrl[i].color_bit = i;
+			tx_msg->ring_cp = 0;
+			tx_msg->ring_ap = 0;
+			atomic_set(&tx_msg->flow_ctrl[i].flow, 0);
+		}
+	} else {
+		/*a mode closed,
+		 *remove it from flow control to
+		 *make it shared by other still open mode
+		*/
+		for (i = 0; i < MAX_COLOR_BIT; i++) {
+			if (tx_msg->flow_ctrl[i].mode == vif->mode) {
+				wl_info(" %s, %d, _fc_, clear mode%d because closed\n",
+					__func__, __LINE__, vif->mode);
+				tx_msg->flow_ctrl[i].mode = SPRDWL_MODE_NONE;
+			}
+		}
+		/*if tx_list[mode] not empty,
+		 *but mode is closed, should flush it
+		*/
+		if (mode < SPRDWL_MODE_MAX && priv->fw_stat[mode] == SPRDWL_INTF_CLOSE &&
+			atomic_read(&tx_msg->tx_list[mode]->mode_list_num) != 0)
+			sprdwl_flush_mode_txlist(tx_msg, mode);
+	}
+}
+
+void sprdwl_init_xmit_list(struct sprdwl_tx_msg *tx_msg)
+{
+	INIT_LIST_HEAD(&tx_msg->xmit_msg_list.to_send_list);
+	INIT_LIST_HEAD(&tx_msg->xmit_msg_list.to_free_list);
+	spin_lock_init(&tx_msg->xmit_msg_list.send_lock);
+	spin_lock_init(&tx_msg->xmit_msg_list.free_lock);
+}
+
+static void
+add_xmit_list_tail(struct sprdwl_tx_msg *tx_msg,
+		   struct peer_list *p_list,
+		   int add_num)
+{
+	struct list_head *pos_list = NULL, *n_list;
+	struct list_head temp_list;
+	int num = 0;
+
+	if (add_num == 0)
+		return;
+	spin_lock_bh(&p_list->p_lock);
+	list_for_each_safe(pos_list, n_list, &p_list->head_list) {
+		num++;
+		if (num == add_num)
+			break;
+	}
+	if (num != add_num)
+		wl_err("%s, %d, error! add_num:%d, num:%d\n",
+		       __func__, __LINE__, add_num, num);
+	INIT_LIST_HEAD(&temp_list);
+	list_cut_position(&temp_list,
+			  &p_list->head_list,
+			  pos_list);
+	list_splice_tail(&temp_list,
+		&tx_msg->xmit_msg_list.to_send_list);
+	if (list_empty(&p_list->head_list))
+		INIT_LIST_HEAD(&p_list->head_list);
+	spin_unlock_bh(&p_list->p_lock);
+	wl_debug("%s,%d,q_num%d,tosend_num%d\n", __func__, __LINE__,
+		 get_list_num(&p_list->head_list),
+		 get_list_num(&tx_msg->xmit_msg_list.to_send_list));
+}
+
+unsigned int queue_is_empty(struct sprdwl_tx_msg *tx_msg, enum sprdwl_mode mode)
+{
+	int i, j;
+	struct tx_t *tx_t_list = tx_msg->tx_list[mode];
+
+	if (mode == SPRDWL_MODE_AP || mode == SPRDWL_MODE_P2P_GO) {
+		for (i = 0;  i < SPRDWL_AC_MAX; i++) {
+			for (j = 0;  j < MAX_LUT_NUM; j++) {
+				if (!list_empty(&tx_t_list->q_list[i].p_list[j].head_list))
+					return 0;
+			}
+		}
+		return 1;
+	}
+	/*other mode, STA/GC/...*/
+	j = tx_msg->tx_list[mode]->lut_id;
+	for (i = 0;  i < SPRDWL_AC_MAX; i++) {
+		if (!list_empty(&tx_t_list->q_list[i].p_list[j].head_list))
+			return 0;
+	}
+	return 1;
+}
+
+void sprdwl_wake_net_ifneed(struct sprdwl_intf *dev,
+			    struct sprdwl_msg_list *list,
+			    enum sprdwl_mode mode)
+{
+	struct sprdwl_tx_msg *tx_msg = (struct sprdwl_tx_msg *)dev->sprdwl_tx;
+
+	if (atomic_read(&list->flow)) {
+		if (atomic_read(&list->ref) <= SPRDWL_TX_DATA_START_NUM) {
+			atomic_set(&list->flow, 0);
+			tx_msg->net_start_cnt++;
+			sprdwl_net_flowcontrl(dev->priv, mode, true);
+		}
+	}
+}
+
+static void sprdwl_sdio_flush_txlist(struct sprdwl_msg_list *list)
+{
+	struct sprdwl_msg_buf *msgbuf;
+	int cnt = 0;
+
+	/*wait until cmd list sent completely and freed by HIF*/
+	while (!list_empty(&list->cmd_to_free) && (cnt < 3000)) {
+		wl_debug("%s cmd not yet transmited", __func__);
+		usleep_range(2950, 3050);
+		cnt++;
+	}
+	while ((msgbuf = sprdwl_peek_msg_buf(list))) {
+		if (msgbuf->skb)
+			dev_kfree_skb(msgbuf->skb);
+		else
+			kfree(msgbuf->tran_data);
+		sprdwl_dequeue_msg_buf(msgbuf, list);
+		continue;
+	}
+}
+
+static int sprdwl_tx_cmd(struct sprdwl_intf *intf, struct sprdwl_msg_list *list)
+{
+	int ret = 0;
+	struct sprdwl_msg_buf *msgbuf;
+	struct sprdwl_tx_msg *tx_msg;
+
+	tx_msg = (struct sprdwl_tx_msg *)intf->sprdwl_tx;
+	while ((msgbuf = sprdwl_peek_msg_buf(list))) {
+		if (unlikely(intf->exit)) {
+			kfree(msgbuf->tran_data);
+			msgbuf->tran_data = NULL;
+			sprdwl_dequeue_msg_buf(msgbuf, list);
+			continue;
+		}
+		if (time_after(jiffies, msgbuf->timeout)) {
+			tx_msg->drop_cmd_cnt++;
+			wl_err("tx drop cmd msg,dropcnt:%lu\n",
+			       tx_msg->drop_cmd_cnt);
+			kfree(msgbuf->tran_data);
+			msgbuf->tran_data = NULL;
+			sprdwl_dequeue_msg_buf(msgbuf, list);
+			continue;
+		}
+		sprdwl_dequeue_cmd_buf(msgbuf, list);
+		tx_msg->cmd_send++;
+		wl_debug("tx_cmd cmd_send num: %d\n", tx_msg->cmd_send);
+
+		/*TBD, temp solution: send CMD one by one*/
+		ret = if_tx_cmd(intf, (unsigned char *)msgbuf->tran_data,
+				msgbuf->len);
+		if (ret) {
+			wl_err("%s err:%d\n", __func__, ret);
+			/* fixme if need retry */
+			msgbuf->tran_data = NULL;
+			sprdwl_free_cmd_buf(msgbuf, list);
+		}
+	}
+
+	return 0;
+}
+
+void sprdwl_fc_add_share_credit(struct sprdwl_vif *vif)
+{
+	struct sprdwl_intf *intf;
+	struct sprdwl_tx_msg *tx_msg;
+	u8 i;
+
+	intf = (struct sprdwl_intf *)(vif->priv->hw_priv);
+	tx_msg = (struct sprdwl_tx_msg *)intf->sprdwl_tx;
+	for (i = 0; i < MAX_COLOR_BIT; i++) {
+		if (tx_msg->flow_ctrl[i].mode == vif->mode) {
+			wl_err("%s, %d, mode:%d closed, index:%d, share it\n",
+			       __func__, __LINE__,
+			       vif->mode, i);
+			tx_msg->flow_ctrl[i].mode = SPRDWL_MODE_NONE;
+			break;
+		}
+	}
+}
+
+int sprdwl_fc_find_color_per_mode(struct sprdwl_tx_msg *tx_msg,
+				enum sprdwl_mode mode,
+				u8 *index)
+{
+	u8 i = 0, found = 0;
+	struct sprdwl_priv *priv = tx_msg->intf->priv;
+
+	for (i = 0; i < MAX_COLOR_BIT; i++) {
+		if (tx_msg->flow_ctrl[i].mode == mode) {
+			found = 1;
+			wl_debug("%s, %d, mode:%d found, index:%d\n",
+				 __func__, __LINE__,
+				 mode, i);
+			break;
+		}
+	}
+	if (found == 0) {
+		/*a new mode. sould assign new color to this mode*/
+		for (i = 0; i < MAX_COLOR_BIT; i++) {
+			if ((tx_msg->flow_ctrl[i].mode != SPRDWL_MODE_NONE) &&
+				(priv->fw_stat[tx_msg->flow_ctrl[i].mode]
+				== SPRDWL_INTF_CLOSE))
+				tx_msg->flow_ctrl[i].mode = SPRDWL_MODE_NONE;
+		}
+		for (i = 0; i < MAX_COLOR_BIT; i++) {
+			if (tx_msg->flow_ctrl[i].mode == SPRDWL_MODE_NONE) {
+				found = 1;
+				tx_msg->flow_ctrl[i].mode = mode;
+				tx_msg->flow_ctrl[i].color_bit = i;
+				wl_info("%s, %d, new mode:%d, assign color:%d\n",
+					__func__, __LINE__,
+					mode, i);
+				break;
+			}
+		}
+	}
+	if (found == 1)
+		*index = i;
+	return found;
+}
+
+int sprdwl_fc_get_shared_num(struct sprdwl_tx_msg *tx_msg, u8 num)
+{
+	u8 i;
+	int shared_flow_num = 0;
+	unsigned int color_flow;
+
+	for (i = 0; i < MAX_COLOR_BIT; i++) {
+		color_flow = atomic_read(&tx_msg->flow_ctrl[i].flow);
+		if ((tx_msg->flow_ctrl[i].mode == SPRDWL_MODE_NONE) &&
+			(0 != color_flow)) {
+			if ((num - shared_flow_num) <= color_flow) {
+				/*one shared color is enough?*/
+				tx_msg->color_num[i] = num - shared_flow_num;
+				shared_flow_num += num - shared_flow_num;
+				break;
+			} else {
+				/*need one more shared color*/
+				tx_msg->color_num[i] = color_flow;
+				shared_flow_num += color_flow;
+			}
+		}
+	}
+	return shared_flow_num;
+}
+
+int sprdwl_fc_get_send_num(struct sprdwl_tx_msg *tx_msg,
+			     enum sprdwl_mode mode,
+			     int data_num)
+{
+	int excusive_flow_num = 0, shared_flow_num = 0;
+	int send_num = 0;
+	u8 i = 0;
+	struct sprdwl_priv *priv = tx_msg->intf->priv;
+
+	if (data_num <= 0 || mode == SPRDWL_MODE_NONE)
+		return 0;
+	/*send all data in buff with PCIe interface*/
+	if (priv->hw_type == SPRDWL_HW_PCIE)
+		return data_num;
+	if (data_num > 100)
+		data_num = 100;
+	if (priv->credit_capa == TX_NO_CREDIT)
+		return data_num;
+	memset(tx_msg->color_num, 0x00, MAX_COLOR_BIT);
+
+	if (sprdwl_fc_find_color_per_mode(tx_msg, mode, &i) == 1) {
+		excusive_flow_num  = atomic_read(&tx_msg->flow_ctrl[i].flow);
+		if (excusive_flow_num >= data_num) {
+			/*excusive flow is enough, do not need shared flow*/
+			send_num = tx_msg->color_num[i] = data_num;
+		} else {
+			/*excusive flow not enough, need shared flow
+			 *total give num =  excusive + shared
+			 *(may be more than one color)*/
+			u8 num_need = data_num - excusive_flow_num;
+
+			shared_flow_num =
+				sprdwl_fc_get_shared_num(tx_msg, num_need);
+			tx_msg->color_num[i] = excusive_flow_num;
+			send_num = excusive_flow_num + shared_flow_num;
+		}
+
+		if (send_num <= 0) {
+			wl_err("%s, %d, mode:%d, e_num:%d, s_num:%d, d_num:%d\n",
+			       __func__, __LINE__,
+			       (u8)mode, excusive_flow_num,
+			       shared_flow_num, data_num);
+			return -ENOMEM;
+		}
+		wl_debug("%s, %d, mode:%d, e_num:%d, s_num:%d, d_num:%d\n"
+			"color_num = {%d, %d, %d, %d}\n",
+			__func__, __LINE__, mode, excusive_flow_num,
+			shared_flow_num, data_num,
+			tx_msg->color_num[0], tx_msg->color_num[1],
+			tx_msg->color_num[2], tx_msg->color_num[3]);
+	} else {
+		wl_err("%s, %d, wrong mode:%d?\n",
+		       __func__, __LINE__,
+		       (u8)mode);
+		for (i = 0; i < MAX_COLOR_BIT; i++)
+			wl_err("color[%d] assigned mode%d\n",
+			       i, (u8)tx_msg->flow_ctrl[i].mode);
+		return -ENOMEM;
+	}
+
+	return send_num;
+}
+
+/*to see there is shared flow or not*/
+int sprdwl_fc_test_shared_num(struct sprdwl_tx_msg *tx_msg)
+{
+	u8 i;
+	int shared_flow_num = 0;
+	unsigned int color_flow;
+
+	for (i = 0; i < MAX_COLOR_BIT; i++) {
+		color_flow = atomic_read(&tx_msg->flow_ctrl[i].flow);
+		if ((tx_msg->flow_ctrl[i].mode == SPRDWL_MODE_NONE) &&
+			(0 != color_flow)) {
+			shared_flow_num += color_flow;
+		}
+	}
+	return shared_flow_num;
+}
+/*to check flow number, no flow number, no send*/
+int sprdwl_fc_test_send_num(struct sprdwl_tx_msg *tx_msg,
+			     enum sprdwl_mode mode,
+			     int data_num)
+{
+	int excusive_flow_num = 0, shared_flow_num = 0;
+	int send_num = 0;
+	u8 i = 0;
+	struct sprdwl_priv *priv = tx_msg->intf->priv;
+
+	if (data_num <= 0 || mode == SPRDWL_MODE_NONE)
+		return 0;
+	/*send all data in buff with PCIe interface, TODO*/
+	if (priv->hw_type == SPRDWL_HW_PCIE)
+		return data_num;
+	if (data_num > 100)
+		data_num = 100;
+	if (priv->credit_capa == TX_NO_CREDIT)
+		return data_num;
+	if (sprdwl_fc_find_color_per_mode(tx_msg, mode, &i) == 1) {
+		excusive_flow_num = atomic_read(&tx_msg->flow_ctrl[i].flow);
+		shared_flow_num =
+				sprdwl_fc_test_shared_num(tx_msg);
+		send_num = excusive_flow_num + shared_flow_num;
+
+		if (send_num <= 0) {
+			wl_debug("%s, %d, err, mode:%d, e_num:%d, s_num:%d, d_num=%d\n",
+				 __func__, __LINE__, (u8)mode,
+				 excusive_flow_num, shared_flow_num, data_num);
+			return -ENOMEM;
+		}
+		wl_debug("%s, %d, e_num=%d, s_num=%d, d_num=%d\n",
+			 __func__, __LINE__, excusive_flow_num,
+			 shared_flow_num, data_num);
+	} else {
+		wl_err("%s, %d, wrong mode:%d?\n",
+		       __func__, __LINE__,
+		       (u8)mode);
+		for (i = 0; i < MAX_COLOR_BIT; i++)
+			wl_err_ratelimited("color[%d] assigned mode%d\n",
+			       i, (u8)tx_msg->flow_ctrl[i].mode);
+		return -ENOMEM;
+	}
+
+	return min(send_num, data_num);
+}
+
+u8 sprdwl_fc_set_clor_bit(struct sprdwl_tx_msg *tx_msg, int num)
+{
+	u8 i = 0;
+	int count_num = 0;
+	struct sprdwl_priv *priv = tx_msg->intf->priv;
+
+	if (priv->credit_capa == TX_NO_CREDIT)
+		return 0;
+
+	for (i = 0; i < MAX_COLOR_BIT; i++) {
+		count_num += tx_msg->color_num[i];
+		if (num <= count_num)
+			break;
+	}
+	wl_debug("%s, %d, color bit =%d\n", __func__, __LINE__, i);
+	return i;
+}
+
+void sprdwl_handle_tx_return(struct sprdwl_tx_msg *tx_msg,
+				  struct sprdwl_msg_list *list,
+				  int send_num, int ret)
+{
+	u8 i;
+	struct sprdwl_priv *priv = tx_msg->intf->priv;
+
+	if (ret) {
+		wl_err_ratelimited("%s tx err:%d\n", __func__, ret);
+		memset(tx_msg->color_num, 0x00, MAX_COLOR_BIT);
+		usleep_range(20, 30);
+		return;
+	}
+	tx_msg->ring_ap += send_num;
+	atomic_sub(send_num, &list->ref);
+	sprdwl_wake_net_ifneed(tx_msg->intf, list, tx_msg->mode);
+
+	if (priv->credit_capa == TX_NO_CREDIT)
+		return;
+
+	for (i = 0; i < MAX_COLOR_BIT; i++) {
+		if (tx_msg->color_num[i] == 0)
+			continue;
+		atomic_sub(tx_msg->color_num[i],
+			&tx_msg->flow_ctrl[i].flow);
+		wl_debug("%s, _fc_, color bit:%d, flow num-%d=%d, seq_num=%d\n",
+			 __func__, i, tx_msg->color_num[i],
+			 atomic_read(&tx_msg->flow_ctrl[i].flow),
+			 tx_msg->seq_num);
+	}
+}
+
+int handle_tx_timeout(struct sprdwl_tx_msg *tx_msg,
+		      struct sprdwl_msg_list *msg_list,
+		      struct peer_list *p_list, int ac_index)
+{
+	u8 mode;
+	char *pinfo;
+	spinlock_t *lock;
+	int cnt, i, del_list_num;
+	struct list_head *tx_list;
+	struct sprdwl_msg_buf *pos_buf, *temp_buf, *tailbuf;
+
+	if (SPRDWL_AC_MAX != ac_index) {
+		tx_list = &p_list->head_list;
+		lock = &p_list->p_lock;
+		spin_lock_bh(lock);
+		if (list_empty(tx_list)) {
+			spin_unlock_bh(lock);
+			return 0;
+		}
+		tailbuf = list_first_entry(tx_list, struct sprdwl_msg_buf, list);
+		spin_unlock_bh(lock);
+	} else {
+		tx_list = &tx_msg->xmit_msg_list.to_send_list;
+		if (list_empty(tx_list))
+			return 0;
+		tailbuf = list_first_entry(tx_list, struct sprdwl_msg_buf, list);
+	}
+
+	if (time_after(jiffies, tailbuf->timeout)) {
+		mode = tailbuf->mode;
+		i = 0;
+		lock = &p_list->p_lock;
+		spin_lock_bh(lock);
+		del_list_num = atomic_read(&p_list->l_num) * atomic_read(&p_list->l_num) /
+						msg_list->maxnum;
+		if (del_list_num >= atomic_read(&p_list->l_num))
+			del_list_num = atomic_read(&p_list->l_num);
+		wl_err("tx timeout drop num:%d, l_num:%d, maxnum:%d",
+			del_list_num, atomic_read(&p_list->l_num), msg_list->maxnum);
+		spin_unlock_bh(lock);
+		list_for_each_entry_safe(pos_buf,
+		temp_buf, tx_list, list) {
+			if (i >= del_list_num)
+				break;
+			wl_info("%s:%d buf->timeout\n",
+				 __func__, __LINE__);
+			if (pos_buf->mode <= SPRDWL_MODE_AP) {
+				pinfo = "STA/AP mode";
+				cnt = tx_msg->drop_data1_cnt++;
+			} else {
+				pinfo = "P2P mode";
+				cnt = tx_msg->drop_data2_cnt++;
+			}
+			wl_info("tx drop %s, dropcnt:%u\n",
+				pinfo, cnt);
+			sprdwl_dequeue_qos_buf(pos_buf, ac_index);
+			atomic_dec(&tx_msg->tx_list[mode]->mode_list_num);
+#if defined(MORE_DEBUG)
+			tx_msg->intf->stats.tx_dropped++;
+#endif
+			i++;
+		}
+		lock = &p_list->p_lock;
+		spin_lock_bh(lock);
+		atomic_sub(del_list_num, &p_list->l_num);
+		spin_unlock_bh(lock);
+		return -ENOMEM;
+	}
+	return 0;
+}
+
+static int sprdwl_handle_to_send_list(struct sprdwl_intf *intf,
+				      enum sprdwl_mode mode)
+{
+	struct sprdwl_tx_msg *tx_msg = (struct sprdwl_tx_msg *)intf->sprdwl_tx;
+	struct list_head *to_send_list, tx_list_head;
+	spinlock_t *t_lock;/*to protect get_list_num*/
+	int tosendnum = 0, credit = 0, ret = 0;
+	struct sprdwl_msg_list *list = &tx_msg->tx_list_qos_pool;
+	u8 coex_bt_on = intf->coex_bt_on;
+
+	if (!list_empty(&tx_msg->xmit_msg_list.to_send_list)) {
+		to_send_list = &tx_msg->xmit_msg_list.to_send_list;
+		t_lock = &tx_msg->xmit_msg_list.send_lock;
+		spin_lock_bh(t_lock);
+		tosendnum = get_list_num(to_send_list);
+		spin_unlock_bh(t_lock);
+		credit = sprdwl_fc_get_send_num(tx_msg, mode, tosendnum);
+		if (credit < tosendnum)
+			wl_err("%s, %d,error! credit:%d,tosendnum:%d\n",
+			       __func__, __LINE__,
+			       credit, tosendnum);
+		if (credit <= 0)
+			return -ENOMEM;
+		tx_msg->xmit_msg_list.mode = mode;
+
+		ret = sprdwl_intf_tx_list(intf,
+					  to_send_list,
+					  &tx_list_head,
+					  credit,
+					  SPRDWL_AC_MAX,
+					  coex_bt_on);
+		sprdwl_handle_tx_return(tx_msg, list, credit, ret);
+		if (0 != ret) {
+			wl_err("%s, %d: tx return err!\n",
+			       __func__, __LINE__);
+			tx_msg->xmit_msg_list.failcount++;
+			if (tx_msg->xmit_msg_list.failcount > 10) {
+				sprdwl_flush_tosendlist(tx_msg);
+				tx_msg->xmit_msg_list.failcount = 0;
+			}
+			return -ENOMEM;
+		}
+	}
+	return 0;
+}
+
+unsigned int vo_ratio = 87;
+unsigned int vi_ratio = 90;
+unsigned int be_ratio = 81;
+static int sprdwl_tx_eachmode_data(struct sprdwl_intf *intf,
+				   enum sprdwl_mode mode)
+{
+	struct sprdwl_tx_msg *tx_msg = (struct sprdwl_tx_msg *)intf->sprdwl_tx;
+	int ret, i, j;
+	struct list_head tx_list_head;
+	struct qos_list *q_list;
+	struct peer_list *p_list;
+	struct sprdwl_msg_list *list = &tx_msg->tx_list_qos_pool;
+	struct tx_t *tx_list = tx_msg->tx_list[mode];
+	int send_num = 0, total = 0, min_num = 0, round_num = 0;
+	int q_list_num[SPRDWL_AC_MAX] = {0, 0, 0, 0};
+	int p_list_num[SPRDWL_AC_MAX][MAX_LUT_NUM] = {{0}, {0}, {0}, {0} };
+
+	INIT_LIST_HEAD(&tx_list_head);
+	/* first, go through all list, handle timeout msg
+	 * and count each TID's tx_num and total tx_num
+	 */
+	for (i = 0; i < SPRDWL_AC_MAX; i++) {
+		for (j = 0; j < MAX_LUT_NUM; j++) {
+			p_list = &tx_list->q_list[i].p_list[j];
+			if (atomic_read(&p_list->l_num) > 0) {
+				if (0 != handle_tx_timeout(tx_msg,
+						       list,
+						       p_list,
+						       i))
+					wl_err("TID=%s%s%s%s, timeout!\n",
+					       (i == SPRDWL_AC_VO) ? "VO" : "",
+					       (i == SPRDWL_AC_VI) ? "VI" : "",
+					       (i == SPRDWL_AC_BE) ? "BE" : "",
+					       (i == SPRDWL_AC_BK) ? "BK" : "");
+				p_list_num[i][j] = atomic_read(&p_list->l_num);
+				/*wl_info("TID=%d,PEER=%d,l_num=%d\n",i,j,p_list_num[i][j]);*/
+				q_list_num[i] += p_list_num[i][j];
+			}
+		}
+		total += q_list_num[i];
+		if (q_list_num[i] != 0)
+			wl_debug("TID%s%s%s%snum=%d, total=%d\n",
+			       (i == SPRDWL_AC_VO) ? "VO" : "",
+			       (i == SPRDWL_AC_VI) ? "VI" : "",
+			       (i == SPRDWL_AC_BE) ? "BE" : "",
+			       (i == SPRDWL_AC_BK) ? "BK" : "",
+			       q_list_num[i], total);
+	}
+	send_num = sprdwl_fc_test_send_num(tx_msg, mode, total);
+	if (total != 0 && send_num <= 0) {
+		wl_err("%s, %d: _fc_ no credit!\n",
+		       __func__, __LINE__);
+		return -ENOMEM;
+	}
+
+	/* merge qos queues to to_send_list
+	 * to best use of HIF interrupt
+	 */
+	/* case1: send_num >= total
+	 * remained _fc_ num is more than remained qos data,
+	 * just add all remained qos list to xmit list
+	 * and send all xmit to_send_list
+	 */
+	if (send_num >= total) {
+		for (i = 0; i < SPRDWL_AC_MAX; i++) {
+			q_list = &tx_list->q_list[i];
+			if (q_list_num[i] <= 0)
+				continue;
+			for (j = 0; j < MAX_LUT_NUM; j++) {
+				p_list = &q_list->p_list[j];
+				if (p_list_num[i][j] ==  0)
+					continue;
+				add_xmit_list_tail(tx_msg, p_list, p_list_num[i][j]);
+				atomic_sub(p_list_num[i][j], &p_list->l_num);
+				atomic_sub(p_list_num[i][j], &tx_list->mode_list_num);
+				wl_debug("%s, %d, mode=%d, TID=%d, lut=%d, %d add to xmit_list, then l_num=%d, mode_list_num=%d\n",
+					 __func__, __LINE__, mode, i, j,
+					 p_list_num[i][j],
+					 atomic_read(&p_list->l_num),
+					 atomic_read(&tx_msg->tx_list[mode]->mode_list_num));
+			}
+		}
+		ret = sprdwl_handle_to_send_list(intf, mode);
+		return ret;
+	}
+
+	/* case2: send_num < total
+	 * vo get 87%,vi get 90%,be get remain 81%
+	 */
+	for (i = 0; i < SPRDWL_AC_MAX; i++) {
+		int fp_num = 0;/*assigned _fc_ num to qoslist*/
+
+		q_list = &tx_list->q_list[i];
+		if (q_list_num[i] <= 0)
+			continue;
+		if (send_num <= 0)
+			break;
+
+		if ((i == SPRDWL_AC_VO) && (total > q_list_num[i])) {
+			round_num = send_num * vo_ratio / 100;
+			fp_num = min(round_num, q_list_num[i]);
+		} else if ((i == SPRDWL_AC_VI) && (total > q_list_num[i])) {
+			round_num = send_num * vi_ratio / 100;
+			fp_num = min(round_num, q_list_num[i]);
+		} else if ((i == SPRDWL_AC_BE) && (total > q_list_num[i])) {
+			round_num = send_num * be_ratio / 100;
+			fp_num = min(round_num, q_list_num[i]);
+		} else {
+			fp_num = send_num * q_list_num[i] / total;
+		}
+		if (((total - q_list_num[i]) < (send_num - fp_num)) &&
+			((total - q_list_num[i]) > 0))
+			fp_num += (send_num - fp_num - (total - q_list_num[i]));
+
+		total -= q_list_num[i];
+
+		wl_debug("TID%s%s%s%s, credit=%d, fp_num=%d, remain=%d\n",
+			(i == SPRDWL_AC_VO) ? "VO" : "",
+			(i == SPRDWL_AC_VI) ? "VI" : "",
+			(i == SPRDWL_AC_BE) ? "BE" : "",
+			(i == SPRDWL_AC_BK) ? "BK" : "",
+			send_num, fp_num, total);
+
+		send_num -= fp_num;
+		for (j = 0; j < MAX_LUT_NUM; j++) {
+			if (p_list_num[i][j] == 0)
+				continue;
+			round_num = p_list_num[i][j] * fp_num / q_list_num[i];
+			if (fp_num > 0 && round_num == 0)
+				round_num = 1;/*round_num = 0.1~0.9*/
+			min_num = min(round_num, fp_num);
+			wl_debug("TID=%d,PEER=%d,%d,%d,%d,%d,%d\n",
+				 i, j, p_list_num[i][j], q_list_num[i], round_num, fp_num, min_num);
+			if (min_num <= 0)
+				break;
+			q_list_num[i] -= p_list_num[i][j];
+			fp_num -= min_num;
+			add_xmit_list_tail(tx_msg,
+					   &q_list->p_list[j],
+					   min_num);
+			atomic_sub(min_num, &q_list->p_list[j].l_num);
+			atomic_sub(min_num, &tx_list->mode_list_num);
+			wl_debug("%s, %d, mode=%d, TID=%d, lut=%d, %d add to xmit_list, then l_num=%d, mode_list_num=%d\n",
+				 __func__, __LINE__, mode, i, j,
+				 min_num,
+				 atomic_read(&p_list->l_num),
+				 atomic_read(&tx_msg->tx_list[mode]->mode_list_num));
+			if (fp_num <= 0)
+				break;
+		}
+	}
+	ret = sprdwl_handle_to_send_list(intf, mode);
+	return ret;
+}
+
+static void sprdwl_flush_all_txlist(struct sprdwl_tx_msg *sprdwl_tx_dev)
+{
+	sprdwl_sdio_flush_txlist(&sprdwl_tx_dev->tx_list_cmd);
+	sprdwl_flush_data_txlist(sprdwl_tx_dev);
+}
+
+int sprdwl_sdio_process_credit(void *pdev, void *data)
+{
+	int ret = 0, i;
+	unsigned char *flow;
+	struct sprdwl_common_hdr *common;
+	struct sprdwl_intf *intf;
+	struct sprdwl_tx_msg *tx_msg;
+	ktime_t kt;
+	int in_count = 0;
+
+	intf = (struct sprdwl_intf *)pdev;
+	tx_msg = (struct sprdwl_tx_msg *)intf->sprdwl_tx;
+	common = (struct sprdwl_common_hdr *)data;
+
+	if (common->type == SPRDWL_TYPE_DATA_SPECIAL) {
+		int offset = (size_t)&((struct rx_msdu_desc *)0)->rsvd5;
+
+		flow = data + offset;
+		goto out;
+	}
+
+	if (common->type == SPRDWL_TYPE_EVENT) {
+		struct sprdwl_cmd_hdr *cmd;
+
+		cmd = (struct sprdwl_cmd_hdr *)data;
+		if (cmd->cmd_id == WIFI_EVENT_SDIO_FLOWCON) {
+			flow = cmd->paydata;
+			ret = -1;
+			goto out;
+		}
+	}
+	return 0;
+
+out:
+	if (flow[0])
+		atomic_add(flow[0], &tx_msg->flow_ctrl[0].flow);
+	if (flow[1])
+		atomic_add(flow[1], &tx_msg->flow_ctrl[1].flow);
+	if (flow[2])
+		atomic_add(flow[2], &tx_msg->flow_ctrl[2].flow);
+	if (flow[3])
+		atomic_add(flow[3], &tx_msg->flow_ctrl[3].flow);
+	if (flow[0] || flow[1] || flow[2] || flow[3]) {
+		in_count = flow[0] + flow[1] + flow[2] + flow[3];
+		tx_msg->ring_cp += in_count;
+		tx_up(tx_msg);
+	}
+	/* Firmware want to reset credit, will send us
+	 * a credit event with all 4 parameters set to zero
+	 */
+	if (in_count == 0) {
+		/*in_count==0: reset credit event or a data without credit
+		 *ret == -1:reset credit event
+		 *for a data without credit:just return,donot print log
+		*/
+		if (ret == -1) {
+			wl_info("%s, %d, _fc_ reset credit\n", __func__, __LINE__);
+			for (i = 0; i < MAX_COLOR_BIT; i++) {
+				if (tx_msg->ring_cp != 0)
+					tx_msg->ring_cp -= atomic_read(&tx_msg->flow_ctrl[i].flow);
+				atomic_set(&tx_msg->flow_ctrl[i].flow, 0);
+				tx_msg->color_num[i] = 0;
+			}
+		}
+		goto exit;
+	}
+	kt = ktime_get();
+	/*1.(tx_msg->kt.tv64 == 0) means 1st event
+	2.add (in_count == 0) to avoid
+	division by expression in_count which
+	may be zero has undefined behavior*/
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 14, 0)
+	if ((tx_msg->kt == 0) || (in_count == 0)) {
+		tx_msg->kt = kt;
+	} else {
+		wl_info("%s, %d, %s, %dadded, %lld usec per flow\n",
+		__func__, __LINE__,
+		(ret == -1) ? "event" : "data",
+		in_count,
+		div_u64(div_u64(kt - tx_msg->kt, NSEC_PER_USEC), in_count));
+
+		debug_record_add(TX_CREDIT_ADD, in_count);
+		debug_record_add(TX_CREDIT_PER_ADD,
+			div_u64(div_u64(kt - tx_msg->kt,
+				 NSEC_PER_USEC), in_count));
+		debug_record_add(TX_CREDIT_RECORD, jiffies_to_usecs(jiffies));
+		debug_record_add(TX_CREDIT_TIME_DIFF,
+			div_u64(kt - tx_msg->kt, NSEC_PER_USEC));
+	}
+#else
+	if ((tx_msg->kt.tv64 == 0) || (in_count == 0)) {
+		tx_msg->kt = kt;
+	} else {
+		wl_debug("%s, %s, %dadded, %lld usec per flow\n",
+		__func__,
+		(ret == -1) ? "event" : "data",
+		in_count,
+		div_u64(div_u64(kt.tv64 - tx_msg->kt.tv64, NSEC_PER_USEC), in_count));
+
+		debug_record_add(TX_CREDIT_ADD, in_count);
+		debug_record_add(TX_CREDIT_PER_ADD,
+			div_u64(div_u64(kt.tv64 - tx_msg->kt.tv64,
+				NSEC_PER_USEC), in_count));
+		debug_record_add(TX_CREDIT_RECORD, jiffies_to_usecs(jiffies));
+		debug_record_add(TX_CREDIT_TIME_DIFF,
+			div_u64(kt.tv64 - tx_msg->kt.tv64, NSEC_PER_USEC));
+	}
+#endif
+	tx_msg->kt = ktime_get();
+
+	wl_info("_fc_,R+%d=%d,G+%d=%d,B+%d=%d,W+%d=%d,cp=%lu,ap=%lu\n",
+		flow[0], atomic_read(&tx_msg->flow_ctrl[0].flow),
+		flow[1], atomic_read(&tx_msg->flow_ctrl[1].flow),
+		flow[2], atomic_read(&tx_msg->flow_ctrl[2].flow),
+		flow[3], atomic_read(&tx_msg->flow_ctrl[3].flow),
+		tx_msg->ring_cp, tx_msg->ring_ap);
+exit:
+	return ret;
+}
+
+void prepare_addba(struct sprdwl_intf *intf, unsigned char lut_index,
+		   struct sk_buff *skb, struct sprdwl_peer_entry *peer_entry,
+		   unsigned char tid)
+{
+	if (intf->tx_num[lut_index] > 9 &&
+		peer_entry &&
+		(peer_entry->ip_acquired || !sprdwl_is_group(skb->data)) &&
+		peer_entry->ht_enable &&
+		peer_entry->vowifi_enabled != 1 &&
+		!test_bit(tid, &peer_entry->ba_tx_done_map)) {
+		struct timespec64 time;
+
+		ktime_get_real_ts64(&time);
+		/*need to delay 3s if priv addba failed*/
+		if (((timespec64_to_ns(&time) - timespec64_to_ns(&peer_entry->time[tid]))/1000000) > 3000 ||
+			peer_entry->time[tid].tv_nsec == 0) {
+			wl_debug("%s, %d, tx_addba, tid=%d\n",
+				__func__, __LINE__, tid);
+			ktime_get_real_ts64(&peer_entry->time[tid]);
+			test_and_set_bit(tid, &peer_entry->ba_tx_done_map);
+			sprdwl_tx_addba(intf, peer_entry, tid);
+		}
+	}
+}
+
+int sprdwl_tx_msg_func(void *pdev, struct sprdwl_msg_buf *msg)
+{
+	u16 len;
+	unsigned char *info;
+	struct sprdwl_intf *intf = (struct sprdwl_intf *)pdev;
+	struct sprdwl_tx_msg *tx_msg = (struct sprdwl_tx_msg *)intf->sprdwl_tx;
+	unsigned int qos_index = 0;
+	struct sprdwl_peer_entry *peer_entry = NULL;
+	unsigned char tid = 0, tos = 0;
+	struct tx_msdu_dscr *dscr = (struct tx_msdu_dscr *)msg->tran_data;
+
+	if (msg->msglist == &tx_msg->tx_list_cmd) {
+		len = SPRDWL_MAX_CMD_TXLEN;
+		info = "cmd";
+		msg->timeout = jiffies + tx_msg->cmd_timeout;
+	} else {
+		len = SPRDWL_MAX_DATA_TXLEN;
+		info = "data";
+		msg->timeout = jiffies + tx_msg->data_timeout;
+	}
+
+	if (msg->len > len) {
+		wl_err("%s err:%s too long:%d > %d,drop it\n",
+				   __func__, info, msg->len, len);
+#if defined(MORE_DEBUG)
+		intf->stats.tx_dropped++;
+#endif
+		INIT_LIST_HEAD(&msg->list);
+		sprdwl_free_msg_buf(msg, msg->msglist);
+		return -EPERM;
+	}
+
+#ifdef OTT_UWE
+	dscr = (struct tx_msdu_dscr *)(msg->tran_data + 3);
+#else
+	dscr = (struct tx_msdu_dscr *)(msg->tran_data);
+#endif
+
+	if (msg->msglist == &tx_msg->tx_list_qos_pool) {
+		struct peer_list *data_list;
+
+#ifdef OTT_UWE
+		qos_index = get_tid_qosindex(msg->skb, 11 + 3, &tid, &tos);
+#else
+		qos_index = get_tid_qosindex(msg->skb, 11, &tid, &tos);
+#endif
+
+#ifdef WMMAC_WFA_CERTIFICATION
+		qos_index = change_priority_if(intf->priv, &tid, &tos, msg->len);
+		wl_debug("%s qos_index: %d tid: %d, tos:%d\n", __func__, qos_index, tid, tos);
+		if (SPRDWL_AC_MAX == qos_index) {
+			INIT_LIST_HEAD(&msg->list);
+			sprdwl_free_msg_buf(msg, msg->msglist);
+			return -EPERM;
+		}
+#endif
+		/*send group in BK to avoid FW hang*/
+		if ((msg->mode == SPRDWL_MODE_AP ||
+			msg->mode == SPRDWL_MODE_P2P_GO) &&
+			(dscr->sta_lut_index < 6)) {
+			qos_index = SPRDWL_AC_BK;
+			tid = prio_1;
+			wl_debug("%s, %d, SOFTAP/GO group go as BK\n", __func__, __LINE__);
+		} else {
+			intf->tx_num[dscr->sta_lut_index]++;
+		}
+		dscr->buffer_info.msdu_tid = tid;
+		peer_entry = &intf->peer_entry[dscr->sta_lut_index];
+/*TODO. temp for MARLIN2 test*/
+#if 0
+		qos_index = qos_match_q(&tx_msg->tx_list_data,
+					msg->skb, 10);/*temp for test*/
+#endif
+		data_list =
+			&tx_msg->tx_list[msg->mode]->q_list[qos_index].p_list[dscr->sta_lut_index];
+		tx_msg->tx_list[msg->mode]->lut_id = dscr->sta_lut_index;
+		/*if ((qos_index == SPRDWL_AC_VO) ||
+			(qos_index == SPRDWL_AC_VI) ||
+			(qos_index == SPRDWL_AC_BE && data_list->l_num <= BE_TOTAL_QUOTA) ||
+			(qos_index == SPRDWL_AC_BK && data_list->l_num <= BK_TOTAL_QUOTA)
+			) {*/
+			msg->data_list = data_list;
+			sprdwl_queue_data_msg_buf(msg);
+			atomic_inc(&tx_msg->tx_list[msg->mode]->mode_list_num);
+		/*} else {
+			dev_kfree_skb(msg->skb);
+			INIT_LIST_HEAD(&msg->list);
+			sprdwl_free_msg_buf(msg, msg->msglist);
+			return 0;
+		}*/
+	}
+
+	if (msg->msg_type != SPRDWL_TYPE_DATA)
+		sprdwl_queue_msg_buf(msg, msg->msglist);
+
+	prepare_addba(intf, dscr->sta_lut_index, (struct sk_buff *)msg->skb,
+			 peer_entry, tid);
+
+	if (msg->msg_type == SPRDWL_TYPE_CMD)
+		tx_up(tx_msg);
+	if (msg->msg_type == SPRDWL_TYPE_DATA &&
+		((intf->fw_awake == 0 &&
+		intf->fw_power_down == 1) ||
+		intf->fw_awake == 1))
+		tx_up(tx_msg);
+
+	return 0;
+}
+
+static int sprdwl_tx_work_queue(void *data)
+{
+	unsigned long need_polling = 0;
+	unsigned int polling_times = 0;
+	struct sprdwl_intf *intf;
+	struct sprdwl_tx_msg *tx_msg;
+	enum sprdwl_mode mode = SPRDWL_MODE_NONE;
+	int send_num = 0;
+	struct sprdwl_priv *priv;
+
+	tx_msg = (struct sprdwl_tx_msg *)data;
+	intf = tx_msg->intf;
+	priv = intf->priv;
+	set_user_nice(current, -20);
+
+	while (1) {
+		tx_down(tx_msg);
+		if (intf->exit || kthread_should_stop())
+			return 0;
+		need_polling = 0;
+		polling_times = 0;
+		/*During hang recovery, send data is not allowed.
+		* but we still need to send cmd to cp2
+		*/
+		if (tx_msg->hang_recovery_status == HANG_RECOVERY_BEGIN) {
+			if (sprdwl_msg_tx_pended(&tx_msg->tx_list_cmd))
+				sprdwl_tx_cmd(intf, &tx_msg->tx_list_cmd);
+			usleep_range(50, 100);
+			continue;
+		}
+
+		if (tx_msg->thermal_status == THERMAL_WIFI_DOWN) {
+			if (sprdwl_msg_tx_pended(&tx_msg->tx_list_cmd))
+				sprdwl_tx_cmd(intf, &tx_msg->tx_list_cmd);
+			usleep_range(100, 200);
+			continue;
+		}
+
+		if (tx_msg->thermal_status == THERMAL_TX_STOP) {
+			if (sprdwl_msg_tx_pended(&tx_msg->tx_list_cmd))
+				sprdwl_tx_cmd(intf, &tx_msg->tx_list_cmd);
+			usleep_range(50, 100);
+			continue;
+		}
+
+		if (sprdwl_msg_tx_pended(&tx_msg->tx_list_cmd))
+			sprdwl_tx_cmd(intf, &tx_msg->tx_list_cmd);
+
+		/* if tx list, send wakeup firstly */
+		if (intf->fw_power_down == 1 &&
+		    (atomic_read(&tx_msg->tx_list_qos_pool.ref) > 0 ||
+		     !list_empty(&tx_msg->xmit_msg_list.to_send_list) ||
+		     !list_empty(&tx_msg->xmit_msg_list.to_free_list))) {
+				struct sprdwl_vif *vif;
+
+				sprdwcn_bus_sleep_wakeup(WIFI);
+				vif = mode_to_vif(priv, tx_msg->mode);
+				intf->fw_power_down = 0;
+				sprdwl_work_host_wakeup_fw(vif);
+				sprdwl_put_vif(vif);
+				continue;
+		}
+
+		if (intf->fw_awake == 0 ||
+			intf->suspend_mode != SPRDWL_PS_RESUMED) {
+			usleep_range(10, 20);
+			continue;
+		}
+
+		if (!list_empty(&tx_msg->xmit_msg_list.to_send_list)) {
+			if (sprdwl_handle_to_send_list(intf, tx_msg->xmit_msg_list.mode)) {
+				usleep_range(590, 610);
+				continue;
+			}
+		}
+
+		for (mode = SPRDWL_MODE_NONE; mode < SPRDWL_MODE_MAX; mode++) {
+			int num = atomic_read(&tx_msg->tx_list[mode]->mode_list_num);
+
+			if (num <= 0)
+				continue;
+			if (num > 0 && priv->fw_stat[mode] != SPRDWL_INTF_OPEN) {
+				sprdwl_flush_mode_txlist(tx_msg, mode);
+				continue;
+			}
+
+			send_num = sprdwl_fc_test_send_num(tx_msg, mode, num);
+			if (send_num > 0)
+				sprdwl_tx_eachmode_data(intf, mode);
+			else
+				need_polling |= (1 << (u8)mode);
+		}
+
+		if (need_polling) {
+			/* retry to wait create */
+			usleep_range(5, 10);
+		}
+	}
+
+	wl_err("%s no longer exsit, flush data, return!\n", __func__);
+	sprdwl_flush_all_txlist(tx_msg);
+
+	return 0;
+}
+
+int sprdwl_tx_init(struct sprdwl_intf *intf)
+{
+	int ret = 0;
+	u8 i, j;
+	struct sprdwl_tx_msg *tx_msg = NULL;
+
+	tx_msg = kzalloc(sizeof(struct sprdwl_tx_msg), GFP_KERNEL);
+	if (!tx_msg) {
+		ret = -ENOMEM;
+		wl_err("%s kzalloc failed!\n", __func__);
+		goto exit;
+	}
+
+	spin_lock_init(&tx_msg->lock);/*useless?*/
+	tx_msg->cmd_timeout = msecs_to_jiffies(SPRDWL_TX_CMD_TIMEOUT);
+	tx_msg->data_timeout = msecs_to_jiffies(SPRDWL_TX_DATA_TIMEOUT);
+	atomic_set(&tx_msg->flow0, 0);
+	atomic_set(&tx_msg->flow1, 0);
+	atomic_set(&tx_msg->flow2, 0);
+
+	ret = sprdwl_msg_init(SPRDWL_TX_MSG_CMD_NUM, &tx_msg->tx_list_cmd);
+	if (ret) {
+		wl_err("%s tx_list_cmd alloc failed\n", __func__);
+		goto err_tx_work;
+	}
+
+	ret = sprdwl_msg_init(SPRDWL_TX_QOS_POOL_SIZE,
+			      &tx_msg->tx_list_qos_pool);
+	if (ret) {
+		wl_err("%s tx_list_qos_pool alloc failed\n", __func__);
+		goto err_tx_list_cmd;
+	}
+
+	for (i = 0; i < SPRDWL_MODE_MAX; i++) {
+		tx_msg->tx_list[i] = kzalloc(sizeof(struct tx_t), GFP_KERNEL);
+		if (!tx_msg->tx_list[i])
+			goto err_txlist;
+		qos_init(tx_msg->tx_list[i]);
+	}
+	sprdwl_init_xmit_list(tx_msg);
+
+	tx_msg->tx_thread =
+		kthread_create(sprdwl_tx_work_queue,
+			       (void *)tx_msg, "SPRDWL_TX_QUEUE");
+	if (!tx_msg->tx_thread) {
+		wl_err("%s SPRDWL_TX_QUEUE create failed", __func__);
+		ret = -ENOMEM;
+		goto err_txlist;
+	}
+
+	intf->sprdwl_tx = (void *)tx_msg;
+	tx_msg->intf = intf;
+
+	init_completion(&tx_msg->tx_completed);
+	wake_up_process(tx_msg->tx_thread);
+
+#ifdef WMMAC_WFA_CERTIFICATION
+	reset_wmmac_parameters(tx_msg->intf->priv);
+	reset_wmmac_ts_info();
+#endif
+
+	for (i = 0; i < MAX_COLOR_BIT; i++) {
+		tx_msg->flow_ctrl[i].mode = SPRDWL_MODE_NONE;
+		tx_msg->flow_ctrl[i].color_bit = i;
+		atomic_set(&tx_msg->flow_ctrl[i].flow, 0);
+	}
+
+	tx_msg->hang_recovery_status = HANG_RECOVERY_END;
+
+	return ret;
+
+err_txlist:
+	for (j = 0; j < i; j++)
+		kfree(tx_msg->tx_list[j]);
+
+	sprdwl_msg_deinit(&tx_msg->tx_list_qos_pool);
+err_tx_list_cmd:
+	sprdwl_msg_deinit(&tx_msg->tx_list_cmd);
+err_tx_work:
+	kfree(tx_msg);
+exit:
+	return ret;
+}
+
+void sprdwl_tx_deinit(struct sprdwl_intf *intf)
+{
+	struct sprdwl_tx_msg *tx_msg = NULL;
+	u8 i;
+
+	tx_msg = (void *)intf->sprdwl_tx;
+
+	/*let tx work queue exit*/
+	intf->exit = 1;
+	if (tx_msg->tx_thread) {
+		tx_up(tx_msg);
+		kthread_stop(tx_msg->tx_thread);
+		tx_msg->tx_thread = NULL;
+	}
+
+	/*need to check if there is some data and cmdpending
+	*or sending by HIF, and wait until tx complete and freed
+	*/
+	if (!list_empty(&tx_msg->tx_list_cmd.cmd_to_free))
+		wl_err("%s cmd not yet transmited, cmd_send:%d, cmd_poped:%d\n",
+		       __func__, tx_msg->cmd_send, tx_msg->cmd_poped);
+
+	sprdwl_flush_all_txlist(tx_msg);
+
+	sprdwl_msg_deinit(&tx_msg->tx_list_cmd);
+	sprdwl_msg_deinit(&tx_msg->tx_list_qos_pool);
+	for (i = 0; i < SPRDWL_MODE_MAX; i++)
+		kfree(tx_msg->tx_list[i]);
+	kfree(tx_msg);
+	intf->sprdwl_tx = NULL;
+}
+
+static inline unsigned short from32to16(unsigned int x)
+{
+	/* add up 16-bit and 16-bit for 16+c bit */
+	x = (x & 0xffff) + (x >> 16);
+	/* add up carry.. */
+	x = (x & 0xffff) + (x >> 16);
+	return x;
+}
+
+static int is_multicast_mac_addr(const u8 *addr)
+{
+	return ((addr[0] != 0xff) && (0x01 & addr[0]));
+}
+
+static int sprdwl_mc_pkt_checksum(struct sk_buff *skb, struct net_device *ndev)
+{
+	struct udphdr *udphdr;
+	struct tcphdr *tcphdr;
+	struct ipv6hdr *ipv6hdr;
+	__sum16 checksum = 0;
+	unsigned char iphdrlen = 0;
+	struct sprdwl_vif *vif;
+	struct sprdwl_intf *intf;
+
+	vif = netdev_priv(ndev);
+	intf = (struct sprdwl_intf *)vif->priv->hw_priv;
+	ipv6hdr = (struct ipv6hdr *)(skb->data + ETHER_HDR_LEN);
+	iphdrlen = sizeof(*ipv6hdr);
+
+	udphdr = (struct udphdr *)(skb->data + ETHER_HDR_LEN + iphdrlen);
+	tcphdr = (struct tcphdr *)(skb->data + ETHER_HDR_LEN + iphdrlen);
+
+	if (skb->ip_summed == CHECKSUM_PARTIAL) {
+		checksum =
+			(__force __sum16)do_csum(
+			skb->data + ETHER_HDR_LEN + iphdrlen,
+			skb->len - ETHER_HDR_LEN - iphdrlen);
+		if (ipv6hdr->nexthdr == IPPROTO_UDP) {
+			udphdr->check = ~checksum;
+			wl_info("csum:%x,udp check:%x\n",
+				checksum, udphdr->check);
+		} else if (ipv6hdr->nexthdr == IPPROTO_TCP) {
+			tcphdr->check = ~checksum;
+			wl_info("csum:%x,tcp check:%x\n",
+				checksum, tcphdr->check);
+		} else
+			return 1;
+		skb->ip_summed = CHECKSUM_NONE;
+		return 0;
+	}
+	return 1;
+}
+
+int sprdwl_tx_mc_pkt(struct sk_buff *skb, struct net_device *ndev)
+{
+	struct sprdwl_vif *vif;
+	struct sprdwl_intf *intf;
+
+	vif = netdev_priv(ndev);
+	intf = (struct sprdwl_intf *)vif->priv->hw_priv;
+
+	intf->skb_da = skb->data;
+	if (intf->skb_da == NULL)/*TODO*/
+		return 1;
+
+	if (is_multicast_mac_addr(intf->skb_da) && vif->mode == SPRDWL_MODE_AP) {
+		wl_debug("%s,AP mode, multicast bssid: %02x:%02x:%02x:%02x:%02x:%02x\n", __func__,
+			 intf->skb_da[0], intf->skb_da[1], intf->skb_da[2],
+			 intf->skb_da[3], intf->skb_da[4], intf->skb_da[5]);
+		sprdwl_mc_pkt_checksum(skb, ndev);
+		sprdwl_xmit_data2cmd_wq(skb, ndev);
+		return NETDEV_TX_OK;
+	}
+	return 1;
+
+}
+
+bool is_vowifi_pkt(struct sk_buff *skb, bool *b_cmd_path)
+{
+	bool ret = false;
+	u8 dscp = 0;
+	struct ethhdr *ethhdr = (struct ethhdr *)skb->data;
+	unsigned char iphdrlen = 0;
+	struct iphdr *iphdr = NULL;
+	struct udphdr *udphdr;
+
+	if (ethhdr->h_proto != htons(ETH_P_IP))
+		return false;
+
+	iphdr = (struct iphdr *)(skb->data + ETHER_HDR_LEN);
+
+	if (iphdr->protocol != IPPROTO_UDP)
+		return false;
+
+#if LINUX_VERSION_CODE > KERNEL_VERSION(3, 10, 0)
+	iphdrlen = ip_hdrlen(skb);
+#else
+	iphdrlen = iphdr->ihl * 4;
+#endif
+	udphdr = (struct udphdr *)(skb->data + ETHER_HDR_LEN + iphdrlen);
+	dscp = (iphdr->tos >> 2);
+	switch (dscp) {
+	case VOWIFI_IKE_DSCP:
+		if ((udphdr->dest == htons(VOWIFI_IKE_SIP_PORT)) ||
+		    (udphdr->dest == htons(VOWIFI_IKE_ONLY_PORT))) {
+			ret = true;
+			(*b_cmd_path) = true;
+		}
+		break;
+	case VOWIFI_SIP_DSCP:
+		if (udphdr->dest == htons(VOWIFI_IKE_SIP_PORT)) {
+			ret = true;
+			(*b_cmd_path) = true;
+		}
+		break;
+	case VOWIFI_VIDEO_DSCP:
+	case VOWIFI_AUDIO_DSCP:
+		ret = true;
+		(*b_cmd_path) = false;
+		break;
+	default:
+		ret = false;
+		(*b_cmd_path) = false;
+		break;
+	}
+
+	return ret;
+}
+
+int sprdwl_tx_filter_ip_pkt(struct sk_buff *skb, struct net_device *ndev)
+{
+	bool is_data2cmd;
+	bool is_ipv4_dhcp, is_ipv6_dhcp;
+	bool is_vowifi2cmd;
+	unsigned char *dhcpdata = NULL;
+	struct udphdr *udphdr;
+	struct iphdr *iphdr = NULL;
+	struct ipv6hdr *ipv6hdr;
+	__sum16 checksum = 0;
+	struct ethhdr *ethhdr = (struct ethhdr *)skb->data;
+	unsigned char iphdrlen = 0;
+	unsigned char lut_index;
+	struct sprdwl_vif *vif;
+	struct sprdwl_intf *intf;
+
+	vif = netdev_priv(ndev);
+	intf = (struct sprdwl_intf *)vif->priv->hw_priv;
+
+	if (ethhdr->h_proto == htons(ETH_P_IPV6)) {
+		ipv6hdr = (struct ipv6hdr *)(skb->data + ETHER_HDR_LEN);
+		/* check for udp header */
+		if (ipv6hdr->nexthdr != IPPROTO_UDP)
+			return 1;
+		iphdrlen = sizeof(*ipv6hdr);
+	} else if (ethhdr->h_proto == htons(ETH_P_IP)) {
+		iphdr = (struct iphdr *)(skb->data + ETHER_HDR_LEN);
+		/* check for udp header */
+		if (iphdr->protocol != IPPROTO_UDP)
+			return 1;
+#if LINUX_VERSION_CODE > KERNEL_VERSION(3, 10, 0)
+		iphdrlen = ip_hdrlen(skb);
+#else
+		iphdrlen = iphdr->ihl * 4;
+#endif
+	} else {
+		return 1;
+	}
+
+	udphdr = (struct udphdr *)(skb->data + ETHER_HDR_LEN + iphdrlen);
+
+	is_ipv4_dhcp =
+	((ethhdr->h_proto == htons(ETH_P_IP)) &&
+	((udphdr->source == htons(DHCP_SERVER_PORT)) ||
+	(udphdr->source == htons(DHCP_CLIENT_PORT))));
+	is_ipv6_dhcp =
+	((ethhdr->h_proto == htons(ETH_P_IPV6)) &&
+	((udphdr->source == htons(DHCP_SERVER_PORT_IPV6)) ||
+	(udphdr->source == htons(DHCP_CLIENT_PORT_IPV6))));
+
+	if (is_vowifi_pkt(skb, &is_vowifi2cmd)) {
+		if (is_vowifi2cmd == false) {
+			struct sprdwl_peer_entry *peer_entry = NULL;
+
+			lut_index = sprdwl_find_lut_index(intf, vif);
+			peer_entry = &intf->peer_entry[lut_index];
+			if (peer_entry->vowifi_enabled == 1) {
+				if (peer_entry->vowifi_pkt_cnt < 11)
+					peer_entry->vowifi_pkt_cnt++;
+				if (peer_entry->vowifi_pkt_cnt == 10)
+					sprdwl_vowifi_data_protection(vif);
+			}
+		}
+	} else {
+		is_vowifi2cmd = false;
+	}
+
+	is_data2cmd = (is_ipv4_dhcp || is_ipv6_dhcp || is_vowifi2cmd);
+
+	if (is_ipv4_dhcp) {
+		intf->skb_da = skb->data;
+		lut_index = sprdwl_find_lut_index(intf, vif);
+		dhcpdata = skb->data + ETHER_HDR_LEN + iphdrlen + 250;
+		if (*dhcpdata == 0x01) {
+			wl_info("DHCP: TX DISCOVER\n");
+		} else if (*dhcpdata == 0x02) {
+			wl_info("DHCP: TX OFFER\n");
+		} else if (*dhcpdata == 0x03) {
+			wl_info("DHCP: TX REQUEST\n");
+			intf->peer_entry[lut_index].ip_acquired = 1;
+			if (sprdwl_is_group(skb->data))
+				intf->peer_entry[lut_index].ba_tx_done_map = 0;
+		} else if (*dhcpdata == 0x04) {
+			wl_info("DHCP: TX DECLINE\n");
+		} else if (*dhcpdata == 0x05) {
+			wl_info("DHCP: TX ACK\n");
+			intf->peer_entry[lut_index].ip_acquired = 1;
+		} else if (*dhcpdata == 0x06) {
+			wl_info("DHCP: TX NACK\n");
+		}
+	}
+
+	/*as CP request, send data with CMD*/
+	if (is_data2cmd) {
+		if (is_ipv4_dhcp || is_ipv6_dhcp)
+			wl_debug("dhcp,check:%x,skb->ip_summed:%d\n",
+				udphdr->check, skb->ip_summed);
+		if (is_vowifi2cmd) {
+			iphdr = (struct iphdr *)(skb->data + ETHER_HDR_LEN);
+			wl_info("vowifi, proto=0x%x, tos=0x%x, dest=0x%x\n",
+				ethhdr->h_proto, iphdr->tos, udphdr->dest);
+		}
+
+		if (skb->ip_summed == CHECKSUM_PARTIAL) {
+			checksum =
+				(__force __sum16)do_csum(
+				skb->data + ETHER_HDR_LEN + iphdrlen,
+				skb->len - ETHER_HDR_LEN - iphdrlen);
+			udphdr->check = ~checksum;
+			wl_debug("dhcp,csum:%x,check:%x\n",
+				checksum, udphdr->check);
+			skb->ip_summed = CHECKSUM_NONE;
+		}
+
+		sprdwl_xmit_data2cmd_wq(skb, ndev);
+		return NETDEV_TX_OK;
+	}
+
+	return 1;
+}
+
+int sprdwl_tx_filter_packet(struct sk_buff *skb, struct net_device *ndev)
+{
+	struct sprdwl_vif *vif;
+	struct sprdwl_intf *intf;
+	struct ethhdr *ethhdr = (struct ethhdr *)skb->data;
+	unsigned char lut_index;
+
+	vif = netdev_priv(ndev);
+	intf = (struct sprdwl_intf *)vif->priv->hw_priv;
+
+#if defined(MORE_DEBUG)
+	if (ethhdr->h_proto == htons(ETH_P_ARP))
+		intf->stats.tx_arp_num++;
+	if (sprdwl_is_group(skb->data))
+		intf->stats.tx_multicast++;
+#endif
+
+	if (ethhdr->h_proto == htons(ETH_P_ARP)) {
+		wl_debug("incoming ARP packet\n");
+		sprdwl_xmit_data2cmd_wq(skb, ndev);
+		return NETDEV_TX_OK;
+	}
+	if (ethhdr->h_proto == htons(ETH_P_TDLS))
+		wl_info("incoming TDLS packet\n");
+	if (ethhdr->h_proto == htons(ETH_P_PREAUTH))
+		wl_info("incoming PREAUTH packet\n");
+
+	intf->skb_da = skb->data;
+	if (ethhdr->h_proto == htons(ETH_P_IPV6)) {
+		lut_index = sprdwl_find_lut_index(intf, vif);
+		if ((vif->mode == SPRDWL_MODE_AP || vif->mode == SPRDWL_MODE_P2P_GO) &&
+			(lut_index != 4) && intf->peer_entry[lut_index].ip_acquired == 0) {
+			wl_debug("ipv6 ethhdr->h_proto=%x\n", ethhdr->h_proto);
+			dev_kfree_skb(skb);
+			return 0;
+		}
+	}
+
+	if ((ethhdr->h_proto == htons(ETH_P_IPV6)) &&
+		!sprdwl_tx_mc_pkt(skb, ndev))
+		return NETDEV_TX_OK;
+
+	if (ethhdr->h_proto == htons(ETH_P_IP) ||
+		ethhdr->h_proto == htons(ETH_P_IPV6))
+		return sprdwl_tx_filter_ip_pkt(skb, ndev);
+	return 1;
+}
diff --git a/drivers/net/wireless/uwe5622/unisocwifi/tx_msg.h b/drivers/net/wireless/uwe5622/unisocwifi/tx_msg.h
new file mode 100644
index 000000000000..0a6a5790389c
--- /dev/null
+++ b/drivers/net/wireless/uwe5622/unisocwifi/tx_msg.h
@@ -0,0 +1,125 @@
+#ifndef __TX_MSG_H__
+#define __TX_MSG_H__
+#include <linux/types.h>
+#include <linux/workqueue.h>
+#include "wl_core.h"
+#include "msg.h"
+#include "cfg80211.h"
+#include "txrx.h"
+#include "wl_intf.h"
+#include "qos.h"
+
+/*descriptor len + sdio header len + offset*/
+#define SKB_DATA_OFFSET 15
+#define SPRDWL_SDIO_MASK_LIST_CMD	0x1
+#define SPRDWL_SDIO_MASK_LIST_SPECIAL	0x2
+#define SPRDWL_SDIO_MASK_LIST_DATA	0x4
+
+/*The number of bytes in an ethernet (MAC) address.*/
+#define	ETHER_ADDR_LEN 6
+
+/*The number of bytes in the type field.*/
+#define	ETHER_TYPE_LEN 2
+
+/* The length of the combined header.*/
+#define	ETHER_HDR_LEN		(ETHER_ADDR_LEN * 2 + ETHER_TYPE_LEN)
+
+#define DHCP_SERVER_PORT    0x0043
+#define DHCP_CLIENT_PORT    0x0044
+#define DHCP_SERVER_PORT_IPV6 0x0223
+#define DHCP_CLIENT_PORT_IPV6 0x0222
+#define ETH_P_PREAUTH       0x88C7
+
+#define VOWIFI_SIP_DSCP		0x1a
+#define VOWIFI_IKE_DSCP		0x30
+#define VOWIFI_VIDEO_DSCP	0x28
+#define VOWIFI_AUDIO_DSCP	0x36
+
+#define VOWIFI_IKE_SIP_PORT	4500
+#define VOWIFI_IKE_ONLY_PORT	500
+
+#define TX_MAX_POLLING 10
+
+#define MAX_COLOR_BIT 4
+struct sprdwl_flow_control {
+	enum sprdwl_mode mode;
+	u8 color_bit;
+	atomic_t flow;
+};
+
+struct sprdwl_tx_msg {
+	struct sprdwl_intf *intf;
+	unsigned long cmd_timeout;
+	unsigned long data_timeout;
+	spinlock_t lock;
+	unsigned long net_stop_cnt;
+	unsigned long net_start_cnt;
+	unsigned long drop_cmd_cnt;
+	unsigned long drop_data_cnt;
+	/* sta */
+	unsigned long drop_data1_cnt;
+	/* p2p */
+	unsigned long drop_data2_cnt;
+	unsigned long ring_cp;
+	unsigned long ring_ap;
+	atomic_t flow0;
+	atomic_t flow1;
+	atomic_t flow2;
+
+	struct task_struct *tx_thread;
+	enum sprdwl_mode mode;
+
+	/*4 flow control color, 00/01/10/11*/
+	struct sprdwl_flow_control flow_ctrl[MAX_COLOR_BIT];
+	unsigned char color_num[MAX_COLOR_BIT];
+	unsigned char seq_num;
+	/*temp for cmd debug, remove in future*/
+	unsigned int cmd_send;
+	unsigned int cmd_poped;
+	int mbuf_short;
+	ktime_t kt;
+#define HANG_RECOVERY_ACKED 2
+	int hang_recovery_status;
+	int thermal_status;
+
+	struct sprdwl_msg_list tx_list_cmd;
+	struct sprdwl_msg_list tx_list_qos_pool;
+	struct sprdwl_xmit_msg_list xmit_msg_list;
+	struct tx_t *tx_list[SPRDWL_MODE_MAX];
+	unsigned long tx_data_num;
+	ktime_t txtimebegin;
+	ktime_t txtimeend;
+
+	struct completion tx_completed;
+};
+
+struct sprdwl_msg_buf *sprdwl_get_msg_buf(void *pdev,
+					enum sprdwl_head_type type,
+					enum sprdwl_mode mode,
+					u8 ctx_id);
+void sprdwl_tx_free_msg_buf(void *pdev, struct sprdwl_msg_buf *msg);
+int sprdwl_tx_msg_func(void *pdev, struct sprdwl_msg_buf *msg);
+int sprdwl_sdio_process_credit(void *pdev, void *data);
+int sprdwl_tx_init(struct sprdwl_intf *dev);
+void sprdwl_tx_deinit(struct sprdwl_intf *dev);
+int sprdwl_tx_filter_packet(struct sk_buff *skb, struct net_device *ndev);
+unsigned char sprdwl_find_index_using_addr(struct sprdwl_intf *dev);
+void sprdwl_dequeue_data_buf(struct sprdwl_msg_buf *msg_buf);
+void sprdwl_dequeue_data_list(struct mbuf_t *head, int num);
+void sprdwl_free_cmd_buf(struct sprdwl_msg_buf *msg_buf,
+			    struct sprdwl_msg_list *list);
+void sprdwl_wake_net_ifneed(struct sprdwl_intf *dev,
+			    struct sprdwl_msg_list *list,
+			    enum sprdwl_mode mode);
+u8 sprdwl_fc_set_clor_bit(struct sprdwl_tx_msg *tx_msg, int num);
+void sprdwl_wakeup_tx(struct sprdwl_tx_msg *tx_msg);
+void handle_tx_status_after_close(struct sprdwl_vif *vif);
+void sprdwl_flush_tx_qoslist(struct sprdwl_tx_msg *tx_msg, int mode, int ac_index, int lut_index);
+void sprdwl_flush_mode_txlist(struct sprdwl_tx_msg *tx_msg, enum sprdwl_mode mode);
+void sprdwl_flush_tosendlist(struct sprdwl_tx_msg *tx_msg);
+void sprdwl_fc_add_share_credit(struct sprdwl_vif *vif);
+
+bool is_vowifi_pkt(struct sk_buff *skb, bool *b_cmd_path);
+void tx_up(struct sprdwl_tx_msg *tx_msg);
+#endif
+
diff --git a/drivers/net/wireless/uwe5622/unisocwifi/txrx.c b/drivers/net/wireless/uwe5622/unisocwifi/txrx.c
new file mode 100644
index 000000000000..0915d782a250
--- /dev/null
+++ b/drivers/net/wireless/uwe5622/unisocwifi/txrx.c
@@ -0,0 +1,224 @@
+/*
+ * Copyright (C) 2015 Spreadtrum Communications Inc.
+ *
+ * Authors	:
+ * Keguang Zhang <keguang.zhang@spreadtrum.com>
+ * Jingxiang Li <Jingxiang.li@spreadtrum.com>
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include <linux/skbuff.h>
+
+#include "sprdwl.h"
+#include "txrx.h"
+#include "cfg80211.h"
+#include "cmdevt.h"
+#include "intf_ops.h"
+#include "work.h"
+#include "wl_intf.h"
+#include "rx_msg.h"
+#include "tcp_ack.h"
+#include "wl_core.h"
+
+/* if err, the caller judge the skb if need free,
+ * here just free the msg buf to the freelist
+ */
+int sprdwl_send_data(struct sprdwl_vif *vif, struct sprdwl_msg_buf *msg,
+		     struct sk_buff *skb, u8 offset)
+{
+	int ret;
+	unsigned char *buf = NULL;
+	struct sprdwl_intf *intf;
+	unsigned int plen = cpu_to_le16(skb->len);
+
+	intf = (struct sprdwl_intf *)vif->priv->hw_priv;
+	buf = skb->data;
+
+	if (sprdwl_intf_fill_msdu_dscr(vif, skb, SPRDWL_TYPE_DATA, offset))
+		return -EPERM;
+#ifdef OTT_UWE
+	skb_push(skb, 3);
+#endif
+	sprdwl_fill_msg(msg, skb, skb->data, skb->len);
+
+	if (sprdwl_filter_send_tcp_ack(vif->priv, msg, buf, plen))
+		return 0;
+
+	ret = sprdwl_intf_tx(vif->priv, msg);
+	if (ret)
+		wl_err("%s TX data Err: %d\n", __func__, ret);
+
+	if (intf->tdls_flow_count_enable == 1 &&
+		vif->sm_state == SPRDWL_CONNECTED)
+		count_tdls_flow(vif,
+				skb->data + offset + intf->hif_offset,
+				skb->len - offset - intf->hif_offset);
+
+	return ret;
+}
+
+#if defined FPGA_LOOPBACK_TEST
+int sprdwl_send_data_fpga_test(struct sprdwl_priv *priv,
+				struct sprdwl_msg_buf *msg,
+				struct sk_buff *skb, u8 type, u8 offset)
+{
+	int ret = 0;
+
+	sprdwl_intf_fill_msdu_dscr_test(priv, skb, type, offset);
+	msg->type = type;
+
+	sprdwl_fill_msg(msg, skb, skb->data, skb->len);
+	ret = sprdwl_intf_tx(priv, msg);
+
+	return ret;
+}
+#endif
+
+int sprdwl_send_cmd(struct sprdwl_priv *priv, struct sprdwl_msg_buf *msg)
+{
+	int ret;
+	struct sk_buff *skb;
+
+	skb = msg->skb;
+	ret = sprdwl_intf_tx(priv, msg);
+	if (ret) {
+		wl_err("%s TX cmd Err: %d\n", __func__, ret);
+	}
+
+	return ret;
+}
+
+void sprdwl_rx_send_cmd_process(struct sprdwl_priv *priv, void *data, int len,
+				unsigned char id, unsigned char ctx_id)
+{
+	struct sprdwl_vif *vif;
+	struct sprdwl_work *misc_work = NULL;
+
+	if (unlikely(!priv)) {
+		wl_err("%s priv not init.\n", __func__);
+	} else if (ctx_id > STAP_MODE_P2P_DEVICE) {
+		wl_err("%s [ctx_id %d]RX err\n", __func__, ctx_id);
+	} else {
+		vif = ctx_id_to_vif(priv, ctx_id);
+		if (!vif) {
+			wl_err("%s cant't get vif from ctx_id%d\n",
+			       __func__, ctx_id);
+		} else {
+			misc_work = sprdwl_alloc_work(len);
+			if (!misc_work) {
+				wl_err("%s out of memory", __func__);
+			} else {
+				misc_work->vif = vif;
+				misc_work->id = id;
+				memcpy(misc_work->data, data, len);
+				sprdwl_queue_work(vif->priv, misc_work);
+			}
+			sprdwl_put_vif(vif);
+		}
+	}
+}
+
+void sprdwl_rx_skb_process(struct sprdwl_priv *priv, struct sk_buff *skb)
+{
+	struct sprdwl_vif *vif = NULL;
+	struct net_device *ndev = NULL;
+	struct rx_msdu_desc *msdu_desc = NULL;
+	struct sk_buff *tx_skb = NULL;
+	struct sprdwl_intf *intf;
+	struct ethhdr *eth;
+
+	intf = (struct sprdwl_intf *)priv->hw_priv;
+
+	if (unlikely(!priv)) {
+		wl_err("%s priv not init.\n", __func__);
+		goto err;
+	}
+
+	msdu_desc = (struct rx_msdu_desc *)skb->data;
+	if (msdu_desc->ctx_id >= SPRDWL_MAC_INDEX_MAX) {
+		wl_err("%s [ctx_id %d]RX err\n", __func__, msdu_desc->ctx_id);
+		goto err;
+	}
+
+	vif = ctx_id_to_vif(priv, msdu_desc->ctx_id);
+	if (!vif) {
+		wl_err("%s cannot get vif, ctx_id: %d\n",
+		       __func__, msdu_desc->ctx_id);
+		goto err;
+	}
+
+	/* Sanity check for bug 846454 */
+	if (vif->ndev == NULL) {
+		wl_err("%s ndev is NULL, ctx_id = %d\n",
+		       __func__, msdu_desc->ctx_id);
+		BUG_ON(1);
+	}
+
+	ndev = vif->ndev;
+	skb_reserve(skb, msdu_desc->msdu_offset);
+	skb_put(skb, msdu_desc->msdu_len);
+
+	eth = (struct ethhdr *)skb->data;
+	if (eth->h_proto == htons(ETH_P_IPV6))
+		if (ether_addr_equal(skb->data, skb->data + ETH_ALEN)) {
+			wl_err("%s, drop loopback pkt, macaddr:%02x:%02x:%02x:%02x:%02x:%02x\n",
+				__func__, skb->data[0], skb->data[1], skb->data[2],
+				skb->data[3], skb->data[4], skb->data[5]);
+			goto err;
+		}
+
+	if (intf->tdls_flow_count_enable == 1)
+		count_tdls_flow(vif,
+				skb->data + ETH_ALEN,
+				skb->len - ETH_ALEN);
+
+	/* FIXME: We would remove mode in furture, how to modify? */
+	if (((vif->mode == SPRDWL_MODE_AP) ||
+	     (vif->mode == SPRDWL_MODE_P2P_GO)) && msdu_desc->uc_w2w_flag) {
+		skb->dev = ndev;
+		dev_queue_xmit(skb);
+	} else {
+		if (((vif->mode == SPRDWL_MODE_AP) ||
+		     (vif->mode == SPRDWL_MODE_P2P_GO)) &&
+		    msdu_desc->bc_mc_w2w_flag) {
+			struct ethhdr *eth = (struct ethhdr *)skb->data;
+
+			if (eth->h_proto != ETH_P_IP &&
+			    eth->h_proto != ETH_P_IPV6) {
+				tx_skb = pskb_copy(skb, GFP_ATOMIC);
+				if (likely(tx_skb)) {
+					tx_skb->dev = ndev;
+					dev_queue_xmit(tx_skb);
+				}
+			}
+		}
+
+		/* skb->data MUST point to ETH HDR */
+		sprdwl_filter_rx_tcp_ack(priv, skb->data, msdu_desc->msdu_len);
+		sprdwl_netif_rx(skb, ndev);
+	}
+
+	sprdwl_put_vif(vif);
+
+	return;
+
+err:
+	dev_kfree_skb(skb);
+#if defined(MORE_DEBUG)
+	intf->stats.rx_errors++;
+	intf->stats.rx_dropped++;
+#endif
+}
+unsigned short sprdwl_rx_data_process(struct sprdwl_priv *priv,
+				      unsigned char *msg)
+{
+	return 0;
+}
diff --git a/drivers/net/wireless/uwe5622/unisocwifi/txrx.h b/drivers/net/wireless/uwe5622/unisocwifi/txrx.h
new file mode 100644
index 000000000000..4fbcb3f0541d
--- /dev/null
+++ b/drivers/net/wireless/uwe5622/unisocwifi/txrx.h
@@ -0,0 +1,49 @@
+/*
+ * Copyright (C) 2015 Spreadtrum Communications Inc.
+ *
+ * Authors	:
+ * Keguang Zhang <keguang.zhang@spreadtrum.com>
+ * Jingxiang Li <Jingxiang.li@spreadtrum.com>
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#ifndef __SPRDWL_TXRX_H__
+#define __SPRDWL_TXRX_H__
+
+struct sprdwl_vif;
+struct sprdwl_priv;
+struct sprdwl_msg_buf;
+
+#define STAP_MODE_NPI 0
+#define STAP_MODE_STA 0
+#define STAP_MODE_AP 1
+#define STAP_MODE_P2P 1
+#define STAP_MODE_P2P_DEVICE 2
+#define STAP_MODE_COEXI_NUM 4
+#define STAP_MODE_OTHER STAP_MODE_STA
+
+int sprdwl_send_data(struct sprdwl_vif *vif, struct sprdwl_msg_buf *msg,
+		     struct sk_buff *skb, u8 offset);
+int sprdwl_send_cmd(struct sprdwl_priv *priv, struct sprdwl_msg_buf *msg);
+
+unsigned short sprdwl_rx_data_process(struct sprdwl_priv *priv,
+				      unsigned char *msg);
+unsigned short sprdwl_rx_event_process(struct sprdwl_priv *priv, u8 *msg);
+unsigned short sprdwl_rx_rsp_process(struct sprdwl_priv *priv, u8 *msg);
+void sprdwl_rx_skb_process(struct sprdwl_priv *priv, struct sk_buff *pskb);
+void sprdwl_rx_send_cmd_process(struct sprdwl_priv *priv, void *data, int len,
+				unsigned char id, unsigned char ctx_id);
+#if defined FPGA_LOOPBACK_TEST
+int sprdwl_send_data_fpga_test(struct sprdwl_priv *priv,
+				struct sprdwl_msg_buf *msg,
+				struct sk_buff *skb, u8 type, u8 offset);
+#endif
+#endif
diff --git a/drivers/net/wireless/uwe5622/unisocwifi/vendor.c b/drivers/net/wireless/uwe5622/unisocwifi/vendor.c
new file mode 100644
index 000000000000..bc82bd077ea3
--- /dev/null
+++ b/drivers/net/wireless/uwe5622/unisocwifi/vendor.c
@@ -0,0 +1,4134 @@
+/*
+ * Copyright (C) 2015 Spreadtrum Communications Inc.
+ *
+ * Authors	:
+ * Baolei Yuan <baolei.yuan@spreadtrum.com>
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include "sprdwl.h"
+#include "cmdevt.h"
+#include "vendor.h"
+#ifdef NAN_SUPPORT
+#include "nan.h"
+#include <linux/version.h>
+#endif /* NAN_SUPPORT */
+#ifdef RTT_SUPPORT
+#include "rtt.h"
+#endif /* RTT_SUPPORT */
+
+#define VENDOR_SCAN_RESULT_EXPIRE	(7 * HZ)
+
+static const u8 *wpa_scan_get_ie(u8 *res, u8 ie_len, u8 ie)
+{
+	const u8 *end, *pos;
+
+	pos = res;
+	end = pos + ie_len;
+	while (pos + 1 < end) {
+		if (pos + 2 + pos[1] > end)
+			break;
+		if (pos[0] == ie)
+			return pos;
+		pos += 2 + pos[1];
+	}
+	return NULL;
+}
+
+static const struct nla_policy
+wlan_gscan_config_policy	[GSCAN_ATTR_SUBCMD_CONFIG_PARAM_MAX + 1] = {
+	[GSCAN_ATTR_SUBCMD_CONFIG_PARAM_REQUEST_ID] =	{ .type = NLA_U32 },
+	[GSCAN_ATTR_GET_VALID_CHANNELS_CONFIG_PARAM_WIFI_BAND]
+		= { .type = NLA_U32 },
+	[GSCAN_ATTR_CHANNEL_SPEC_CHANNEL] = { .type = NLA_U32 },
+	[GSCAN_ATTR_CHANNEL_SPEC_DWELL_TIME] = { .type = NLA_U32 },
+	[GSCAN_ATTR_CHANNEL_SPEC_PASSIVE] = { .type = NLA_U8 },
+	[GSCAN_ATTR_CHANNEL_SPEC_CLASS] = { .type = NLA_U8 },
+	[GSCAN_ATTR_BUCKET_SPEC_INDEX] = { .type = NLA_U8 },
+	[GSCAN_ATTR_BUCKET_SPEC_BAND] = { .type = NLA_U8 },
+	[GSCAN_ATTR_BUCKET_SPEC_PERIOD] = { .type = NLA_U32 },
+	[GSCAN_ATTR_BUCKET_SPEC_REPORT_EVENTS] = { .type = NLA_U8 },
+	[GSCAN_ATTR_BUCKET_SPEC_NUM_CHANNEL_SPECS] = { .type = NLA_U32 },
+	[GSCAN_ATTR_SCAN_CMD_PARAMS_BASE_PERIOD] = { .type = NLA_U32 },
+	[GSCAN_ATTR_SCAN_CMD_PARAMS_MAX_AP_PER_SCAN] = { .type = NLA_U32 },
+	[GSCAN_ATTR_SCAN_CMD_PARAMS_REPORT_THR] = { .type = NLA_U8 },
+	[GSCAN_ATTR_SCAN_CMD_PARAMS_NUM_BUCKETS] = { .type = NLA_U8 },
+	[GSCAN_ATTR_GET_CACHED_SCAN_RESULTS_CONFIG_PARAM_FLUSH]
+		= { .type = NLA_U8 },
+	[GSCAN_ATTR_GET_CACHED_SCAN_RESULTS_CONFIG_PARAM_MAX]
+		= { .type = NLA_U32 },
+	[GSCAN_ATTR_AP_THR_PARAM_BSSID] = { .type = NLA_UNSPEC },
+	[GSCAN_ATTR_AP_THR_PARAM_RSSI_LOW] = { .type = NLA_S32 },
+	[GSCAN_ATTR_AP_THR_PARAM_RSSI_HIGH] = { .type = NLA_S32 },
+	[GSCAN_ATTR_AP_THR_PARAM_CHANNEL] = { .type = NLA_U32 },
+	[GSCAN_ATTR_BSSID_HOTLIST_PARAMS_NUM_AP] = { .type = NLA_U32 },
+	[GSCAN_ATTR_SIGNIFICANT_CHANGE_PARAMS_RSSI_SAMPLE_SIZE]
+		= { .type = NLA_U32 },
+	[GSCAN_ATTR_SIGNIFICANT_CHANGE_PARAMS_LOST_AP_SAMPLE_SIZE]
+		= { .type = NLA_U32 },
+	[GSCAN_ATTR_SIGNIFICANT_CHANGE_PARAMS_MIN_BREACHING]
+		= { .type = NLA_U32 },
+	[GSCAN_ATTR_SIGNIFICANT_CHANGE_PARAMS_NUM_AP] = { .type = NLA_U32 },
+};
+
+/*enable roaming functon------ CMD ID:9*/
+static int sprdwl_vendor_roaming_enable(struct wiphy *wiphy,
+					struct wireless_dev *wdev,
+					const void *data, int len)
+{
+	struct sprdwl_priv *priv = wiphy_priv(wiphy);
+	struct sprdwl_vif *vif = container_of(wdev, struct sprdwl_vif, wdev);
+	u8 roam_state;
+	struct nlattr *tb[SPRDWL_VENDOR_ROAMING_POLICY + 1];
+	int ret = 0;
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 14, 0)
+	if (nla_parse(tb, SPRDWL_VENDOR_ROAMING_POLICY, data, len, NULL, NULL)) {
+#else
+	if (nla_parse(tb, SPRDWL_VENDOR_ROAMING_POLICY, data, len, NULL)) {
+#endif
+		wl_err("Invalid ATTR\n");
+		return -EINVAL;
+	}
+
+	if (tb[SPRDWL_VENDOR_ROAMING_POLICY]) {
+		roam_state = (u8)nla_get_u32(tb[SPRDWL_VENDOR_ROAMING_POLICY]);
+		wl_info("roaming offload state:%d\n", roam_state);
+		 /*send roam state with roam params by roaming CMD*/
+		ret = sprdwl_set_roam_offload(priv, vif->ctx_id,
+					SPRDWL_ROAM_OFFLOAD_SET_FLAG,
+					&roam_state, sizeof(roam_state));
+	}
+
+	return ret;
+}
+
+static int sprdwl_vendor_nan_enable(struct wiphy *wiphy,
+				    struct wireless_dev *wdev,
+				    const void *data, int len)
+{
+	return WIFI_SUCCESS;
+}
+
+/*Send link layer stats CMD*/
+static int sprdwl_llstat(struct sprdwl_priv *priv, u8 vif_ctx_id, u8 subtype,
+			 const void *buf, u8 len, u8 *r_buf, u16 *r_len)
+{
+	u8 *sub_cmd, *buf_pos;
+	struct sprdwl_msg_buf *msg;
+
+	msg = sprdwl_cmd_getbuf(priv, len + 1, vif_ctx_id,
+				SPRDWL_HEAD_RSP, WIFI_CMD_LLSTAT);
+	if (!msg)
+		return -ENOMEM;
+	sub_cmd = (u8 *)msg->data;
+	*sub_cmd = subtype;
+	buf_pos = sub_cmd + 1;
+
+	if (!buf && len)
+		return -ENOMEM;
+	memcpy(buf_pos, buf, len);
+
+	if (subtype == SPRDWL_SUBCMD_SET)
+		return sprdwl_cmd_send_recv(priv, msg, CMD_WAIT_TIMEOUT, 0, 0);
+	else
+		return sprdwl_cmd_send_recv(priv, msg, CMD_WAIT_TIMEOUT, r_buf,
+					    r_len);
+}
+
+/*set link layer status function-----CMD ID:14*/
+static int sprdwl_vendor_set_llstat_handler(struct wiphy *wiphy,
+					    struct wireless_dev *wdev,
+					    const void *data, int len)
+{
+	int ret = 0, err = 0;
+	struct sprdwl_priv *priv = wiphy_priv(wiphy);
+	struct sprdwl_vif *vif = container_of(wdev, struct sprdwl_vif, wdev);
+	struct wifi_link_layer_params *ll_params;
+	struct nlattr *tb[SPRDWL_LL_STATS_SET_MAX + 1];
+
+	if (!priv || !vif)
+		return -EIO;
+	if (!(priv->fw_capa & SPRDWL_CAPA_LL_STATS))
+		return -ENOTSUPP;
+	if (!data) {
+		wl_err("%s llstat param check filed\n", __func__);
+		return -EINVAL;
+	}
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 14, 0)
+	err = nla_parse(tb, SPRDWL_LL_STATS_SET_MAX, data,
+			len, sprdwl_ll_stats_policy, NULL);
+#else
+	err = nla_parse(tb, SPRDWL_LL_STATS_SET_MAX, data,
+			len, sprdwl_ll_stats_policy);
+#endif
+	if (err)
+		return err;
+	ll_params = kzalloc(sizeof(*ll_params), GFP_KERNEL);
+	if (!ll_params)
+		return -ENOMEM;
+	if (tb[SPRDWL_LL_STATS_MPDU_THRESHOLD]) {
+		ll_params->mpdu_size_threshold =
+			nla_get_u32(tb[SPRDWL_LL_STATS_MPDU_THRESHOLD]);
+	}
+	if (tb[SPRDWL_LL_STATS_GATHERING]) {
+		ll_params->aggressive_statistics_gathering =
+			nla_get_u32(tb[SPRDWL_LL_STATS_GATHERING]);
+	}
+
+	wiphy_err(wiphy, "%s mpdu_threshold =%u\n gathering=%u\n",
+		  __func__, ll_params->mpdu_size_threshold,
+			ll_params->aggressive_statistics_gathering);
+	if (ll_params->aggressive_statistics_gathering)
+		ret = sprdwl_llstat(priv, vif->ctx_id, SPRDWL_SUBCMD_SET,
+				    ll_params, sizeof(*ll_params),
+							0, 0);
+	kfree(ll_params);
+	return ret;
+}
+
+static int sprdwl_compose_radio_st(struct sk_buff *reply,
+				   struct wifi_radio_stat *radio_st)
+{
+	/*2.4G only,radio_num=1,if 5G supported radio_num=2*/
+	int radio_num = 1;
+
+	if (nla_put_u32(reply, SPRDWL_LL_STATS_NUM_RADIOS,
+			radio_num))
+		goto out_put_fail;
+	if (nla_put_u32(reply, SPRDWL_LL_STATS_RADIO_ID,
+			radio_st->radio))
+		goto out_put_fail;
+	if (nla_put_u32(reply, SPRDWL_LL_STATS_RADIO_ON_TIME,
+			radio_st->on_time))
+		goto out_put_fail;
+	if (nla_put_u32(reply, SPRDWL_LL_STATS_RADIO_TX_TIME,
+			radio_st->tx_time))
+		goto out_put_fail;
+	if (nla_put_u32(reply, SPRDWL_LL_STATS_RADIO_NUM_TX_LEVELS,
+			radio_st->num_tx_levels))
+		goto out_put_fail;
+	if (radio_st->num_tx_levels > 0) {
+		if (nla_put(reply, SPRDWL_LL_STATS_RADIO_TX_TIME_PER_LEVEL,
+			    sizeof(u32)*radio_st->num_tx_levels,
+			    radio_st->tx_time_per_levels))
+			goto out_put_fail;
+	}
+	if (nla_put_u32(reply, SPRDWL_LL_STATS_RADIO_RX_TIME,
+			radio_st->rx_time))
+		goto out_put_fail;
+	if (nla_put_u32(reply, SPRDWL_LL_STATS_RADIO_ON_TIME_SCAN,
+			radio_st->on_time_scan))
+		goto out_put_fail;
+	if (nla_put_u32(reply, SPRDWL_LL_STATS_RADIO_ON_TIME_NBD,
+			radio_st->on_time_nbd))
+		goto out_put_fail;
+	if (nla_put_u32(reply, SPRDWL_LL_STATS_RADIO_ON_TIME_GSCAN,
+			radio_st->on_time_gscan))
+		goto out_put_fail;
+	if (nla_put_u32(reply, SPRDWL_LL_STATS_RADIO_ON_TIME_ROAM_SCAN,
+			radio_st->on_time_roam_scan))
+		goto out_put_fail;
+	if (nla_put_u32(reply, SPRDWL_LL_STATS_RADIO_ON_TIME_PNO_SCAN,
+			radio_st->on_time_pno_scan))
+		goto out_put_fail;
+	if (nla_put_u32(reply, SPRDWL_LL_STATS_RADIO_ON_TIME_HS20,
+			radio_st->on_time_hs20))
+		goto out_put_fail;
+	if (nla_put_u32(reply, SPRDWL_LL_STATS_RADIO_NUM_CHANNELS,
+			radio_st->num_channels))
+		goto out_put_fail;
+	if (radio_st->num_channels > 0) {
+		if (nla_put(reply, SPRDWL_LL_STATS_CH_INFO,
+			    radio_st->num_channels *
+				sizeof(struct wifi_channel_stat),
+			    radio_st->channels))
+			goto out_put_fail;
+	}
+	return 0;
+out_put_fail:
+	return -EMSGSIZE;
+}
+
+static int sprdwl_compose_iface_st(struct sk_buff *reply,
+				   struct wifi_iface_stat *iface_st)
+{
+	int i;
+	struct nlattr *nest1, *nest2;
+
+	if (nla_put_u32(reply, SPRDWL_LL_STATS_IFACE_INFO_MODE,
+			iface_st->info.mode))
+		goto out_put_fail;
+	if (nla_put(reply, SPRDWL_LL_STATS_IFACE_INFO_MAC_ADDR,
+		    sizeof(iface_st->info.mac_addr), iface_st->info.mac_addr))
+		goto out_put_fail;
+	if (nla_put_u32(reply, SPRDWL_LL_STATS_IFACE_INFO_STATE,
+			iface_st->info.state))
+		goto out_put_fail;
+	if (nla_put_u32(reply, SPRDWL_LL_STATS_IFACE_INFO_ROAMING,
+			iface_st->info.roaming))
+		goto out_put_fail;
+	if (nla_put_u32(reply, SPRDWL_LL_STATS_IFACE_INFO_CAPABILITIES,
+			iface_st->info.capabilities))
+		goto out_put_fail;
+	if (nla_put(reply, SPRDWL_LL_STATS_IFACE_INFO_SSID,
+		    sizeof(iface_st->info.ssid), iface_st->info.ssid))
+		goto out_put_fail;
+	if (nla_put(reply, SPRDWL_LL_STATS_IFACE_INFO_BSSID,
+		    sizeof(iface_st->info.bssid), iface_st->info.bssid))
+		goto out_put_fail;
+	if (nla_put(reply, SPRDWL_LL_STATS_IFACE_INFO_AP_COUNTRY_STR,
+		    sizeof(iface_st->info.ap_country_str),
+		    iface_st->info.ap_country_str))
+		goto out_put_fail;
+	if (nla_put(reply, SPRDWL_LL_STATS_IFACE_INFO_COUNTRY_STR,
+		    sizeof(iface_st->info.country_str),
+		    iface_st->info.country_str))
+		goto out_put_fail;
+	if (nla_put_u32(reply, SPRDWL_LL_STATS_IFACE_BEACON_RX,
+			iface_st->beacon_rx))
+		goto out_put_fail;
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 7, 0)
+	if (nla_put_u64_64bit(reply, SPRDWL_LL_STATS_IFACE_AVERAGE_TSF_OFFSET,
+			iface_st->average_tsf_offset, 0))
+#else
+	if (nla_put_u64(reply, SPRDWL_LL_STATS_IFACE_AVERAGE_TSF_OFFSET,
+			iface_st->average_tsf_offset))
+#endif
+		goto out_put_fail;
+	if (nla_put_u32(reply, SPRDWL_LL_STATS_IFACE_LEAKY_AP_DETECTED,
+			iface_st->leaky_ap_detected))
+		goto out_put_fail;
+	if (nla_put_u32(reply,
+			SPRDWL_LL_STATS_IFACE_LEAKY_AP_AVG_NUM_FRAMES_LEAKED,
+		iface_st->leaky_ap_avg_num_frames_leaked))
+		goto out_put_fail;
+	if (nla_put_u32(reply, SPRDWL_LL_STATS_IFACE_LEAKY_AP_GUARD_TIME,
+			iface_st->leaky_ap_guard_time))
+		goto out_put_fail;
+	if (nla_put_u32(reply, SPRDWL_LL_STATS_IFACE_MGMT_RX,
+			iface_st->mgmt_rx))
+		goto out_put_fail;
+	if (nla_put_u32(reply, SPRDWL_LL_STATS_IFACE_MGMT_ACTION_RX,
+			iface_st->mgmt_action_rx))
+		goto out_put_fail;
+	if (nla_put_u32(reply, SPRDWL_LL_STATS_IFACE_MGMT_ACTION_TX,
+			iface_st->mgmt_action_tx))
+		goto out_put_fail;
+	if (nla_put_s32(reply, SPRDWL_LL_STATS_IFACE_RSSI_MGMT,
+			iface_st->rssi_mgmt))
+		goto out_put_fail;
+	if (nla_put_u32(reply, SPRDWL_LL_STATS_IFACE_RSSI_DATA,
+			iface_st->rssi_data))
+		goto out_put_fail;
+	if (nla_put_u32(reply, SPRDWL_LL_STATS_IFACE_RSSI_ACK,
+			iface_st->rssi_ack))
+		goto out_put_fail;
+	if (nla_put_u32(reply, SPRDWL_LL_STATS_IFACE_RSSI_DATA,
+			iface_st->rssi_data))
+		goto out_put_fail;
+	nest1 = nla_nest_start(reply, SPRDWL_LL_STATS_WMM_INFO);
+	if (!nest1)
+		goto out_put_fail;
+	for (i = 0; i < WIFI_AC_MAX; i++) {
+		nest2 = nla_nest_start(reply, SPRDWL_LL_STATS_WMM_AC_AC);
+		if (!nest2)
+			goto out_put_fail;
+		if (nla_put_u32(reply, SPRDWL_LL_STATS_WMM_AC_AC,
+				iface_st->ac[i].ac))
+			goto out_put_fail;
+		if (nla_put_u32(reply, SPRDWL_LL_STATS_WMM_AC_TX_MPDU,
+				iface_st->ac[i].tx_mpdu))
+			goto out_put_fail;
+		if (nla_put_u32(reply, SPRDWL_LL_STATS_WMM_AC_RX_MPDU,
+				iface_st->ac[i].rx_mpdu))
+			goto out_put_fail;
+		if (nla_put_u32(reply, SPRDWL_LL_STATS_WMM_AC_TX_MCAST,
+				iface_st->ac[i].tx_mcast))
+			goto out_put_fail;
+		if (nla_put_u32(reply, SPRDWL_LL_STATS_WMM_AC_RX_MCAST,
+				iface_st->ac[i].rx_mcast))
+			goto out_put_fail;
+		if (nla_put_u32(reply, SPRDWL_LL_STATS_WMM_AC_RX_AMPDU,
+				iface_st->ac[i].rx_ampdu))
+			goto out_put_fail;
+		if (nla_put_u32(reply, SPRDWL_LL_STATS_WMM_AC_TX_AMPDU,
+				iface_st->ac[i].tx_ampdu))
+			goto out_put_fail;
+		if (nla_put_u32(reply, SPRDWL_LL_STATS_WMM_AC_MPDU_LOST,
+				iface_st->ac[i].mpdu_lost))
+			goto out_put_fail;
+		if (nla_put_u32(reply, SPRDWL_LL_STATS_WMM_AC_RETRIES,
+				iface_st->ac[i].retries))
+			goto out_put_fail;
+		if (nla_put_u32(reply, SPRDWL_LL_STATS_WMM_AC_RETRIES_SHORT,
+				iface_st->ac[i].retries_short))
+			goto out_put_fail;
+		if (nla_put_u32(reply, SPRDWL_LL_STATS_WMM_AC_RETRIES_LONG,
+				iface_st->ac[i].retries_long))
+			goto out_put_fail;
+		if (nla_put_u32(reply,
+				SPRDWL_LL_STATS_WMM_AC_CONTENTION_TIME_MIN,
+				iface_st->ac[i].contention_time_min))
+			goto out_put_fail;
+		if (nla_put_u32(reply,
+				SPRDWL_LL_STATS_WMM_AC_CONTENTION_TIME_MAX,
+				iface_st->ac[i].contention_time_max))
+			goto out_put_fail;
+		if (nla_put_u32(reply,
+				SPRDWL_LL_STATS_WMM_AC_CONTENTION_TIME_AVG,
+				iface_st->ac[i].contention_time_avg))
+			goto out_put_fail;
+		if (nla_put_u32(reply,
+				SPRDWL_LL_STATS_WMM_AC_CONTENTION_NUM_SAMPLES,
+				iface_st->ac[i].contention_num_samples))
+			goto out_put_fail;
+		nla_nest_end(reply, nest2);
+	}
+	nla_nest_end(reply, nest1);
+	return 0;
+out_put_fail:
+	return -EMSGSIZE;
+}
+
+void calc_radio_dif(struct sprdwl_llstat_radio *dif_radio,
+		    struct sprdwl_llstat_data *llst,
+			struct sprdwl_llstat_radio *pre_radio)
+{
+	int i;
+
+	dif_radio->rssi_mgmt = llst->rssi_mgmt;
+	dif_radio->bcn_rx_cnt = llst->bcn_rx_cnt >= pre_radio->bcn_rx_cnt ?
+		llst->bcn_rx_cnt - pre_radio->bcn_rx_cnt : llst->bcn_rx_cnt;
+	/*save lastest beacon count*/
+	pre_radio->bcn_rx_cnt = llst->bcn_rx_cnt;
+
+	for (i = 0; i < WIFI_AC_MAX; i++) {
+		dif_radio->ac[i].tx_mpdu = (llst->ac[i].tx_mpdu >=
+			pre_radio->ac[i].tx_mpdu) ?
+			(llst->ac[i].tx_mpdu - pre_radio->ac[i].tx_mpdu) :
+			llst->ac[i].tx_mpdu;
+		/*save lastest tx mpdu*/
+		pre_radio->ac[i].tx_mpdu = llst->ac[i].tx_mpdu;
+
+		dif_radio->ac[i].rx_mpdu = (llst->ac[i].rx_mpdu >=
+			pre_radio->ac[i].rx_mpdu) ?
+			(llst->ac[i].rx_mpdu - pre_radio->ac[i].rx_mpdu) :
+			llst->ac[i].rx_mpdu;
+		/*save lastest rx mpdu*/
+		pre_radio->ac[i].rx_mpdu = llst->ac[i].rx_mpdu;
+
+		dif_radio->ac[i].tx_mpdu_lost = (llst->ac[i].tx_mpdu_lost >=
+			pre_radio->ac[i].tx_mpdu_lost) ?
+			(llst->ac[i].tx_mpdu_lost -
+			 pre_radio->ac[i].tx_mpdu_lost) :
+			llst->ac[i].tx_mpdu_lost;
+		/*save mpdu lost value*/
+		pre_radio->ac[i].tx_mpdu_lost = llst->ac[i].tx_mpdu_lost;
+
+		dif_radio->ac[i].tx_retries = (llst->ac[i].tx_retries >=
+			pre_radio->ac[i].tx_retries) ?
+			(llst->ac[i].tx_retries - pre_radio->ac[i].tx_retries) :
+			llst->ac[i].tx_retries;
+		/*save retries value*/
+		pre_radio->ac[i].tx_retries = llst->ac[i].tx_retries;
+	}
+}
+
+/*get link layer status function---CMD ID:15*/
+static int sprdwl_vendor_get_llstat_handler(struct wiphy *wiphy,
+					    struct wireless_dev *wdev,
+					    const void *data, int len)
+{
+	struct sk_buff *reply_radio, *reply_iface;
+	struct sprdwl_llstat_data *llst;
+	struct wifi_radio_stat *radio_st;
+	struct wifi_iface_stat *iface_st;
+	struct sprdwl_llstat_radio *dif_radio;
+	u16 r_len = sizeof(*llst);
+	u8 r_buf[r_len], ret, i;
+	u32 reply_radio_length, reply_iface_length;
+
+	struct sprdwl_priv *priv = wiphy_priv(wiphy);
+	struct sprdwl_vif *vif = container_of(wdev, struct sprdwl_vif, wdev);
+
+	if (!priv || !vif)
+		return -EIO;
+	if (!(priv->fw_capa & SPRDWL_CAPA_LL_STATS))
+		return -ENOTSUPP;
+	memset(r_buf, 0, r_len);
+	radio_st = kzalloc(sizeof(*radio_st), GFP_KERNEL);
+	iface_st = kzalloc(sizeof(*iface_st), GFP_KERNEL);
+	dif_radio = kzalloc(sizeof(*dif_radio), GFP_KERNEL);
+
+	if (!radio_st || !iface_st || !dif_radio)
+		goto out_put_fail;
+	ret = sprdwl_llstat(priv, vif->ctx_id, SPRDWL_SUBCMD_GET, NULL, 0,
+			    r_buf, &r_len);
+	if (ret)
+		goto out_put_fail;
+
+	llst = (struct sprdwl_llstat_data *)r_buf;
+
+	calc_radio_dif(dif_radio, llst, &priv->pre_radio);
+
+	/*set data for iface struct*/
+	iface_st->info.mode = vif->mode;
+	memcpy(iface_st->info.mac_addr, vif->ndev->dev_addr,
+	       ETH_ALEN);
+	iface_st->info.state = vif->sm_state;
+	memcpy(iface_st->info.ssid, vif->ssid,
+	       IEEE80211_MAX_SSID_LEN);
+	ether_addr_copy(iface_st->info.bssid, vif->bssid);
+	iface_st->beacon_rx = dif_radio->bcn_rx_cnt;
+	iface_st->rssi_mgmt = dif_radio->rssi_mgmt;
+	for (i = 0; i < WIFI_AC_MAX; i++) {
+		iface_st->ac[i].tx_mpdu = dif_radio->ac[i].tx_mpdu;
+		iface_st->ac[i].rx_mpdu = dif_radio->ac[i].rx_mpdu;
+		iface_st->ac[i].mpdu_lost = dif_radio->ac[i].tx_mpdu_lost;
+		iface_st->ac[i].retries = dif_radio->ac[i].tx_retries;
+	}
+	/*set data for radio struct*/
+	radio_st->on_time = llst->on_time;
+	radio_st->tx_time = (u32)llst->radio_tx_time;
+	radio_st->rx_time = (u32)llst->radio_rx_time;
+	radio_st->on_time_scan = llst->on_time_scan;
+	wl_info("beacon_rx=%d, rssi_mgmt=%d\n",
+		iface_st->beacon_rx, iface_st->rssi_mgmt);
+	wl_info("on_time=%d, tx_time=%d\n",
+		radio_st->on_time, radio_st->tx_time);
+	wl_info("rx_time=%d, on_time_scan=%d,\n",
+		radio_st->rx_time, radio_st->on_time_scan);
+	radio_st->num_tx_levels = 1;
+	radio_st->tx_time_per_levels = (u32 *)&llst->radio_tx_time;
+
+	/*alloc radio reply buffer*/
+	reply_radio_length = sizeof(struct wifi_radio_stat) + 1000;
+	reply_iface_length = sizeof(struct wifi_iface_stat) + 1000;
+
+	wl_info("start to put radio data\n");
+	reply_radio = cfg80211_vendor_cmd_alloc_reply_skb(wiphy,
+							  reply_radio_length);
+	if (!reply_radio)
+		goto out_put_fail;
+
+	if (nla_put_u32(reply_radio, NL80211_ATTR_VENDOR_ID, OUI_SPREAD))
+		goto out_put_fail;
+	if (nla_put_u32(reply_radio, NL80211_ATTR_VENDOR_SUBCMD,
+			SPRDWL_VENDOR_GET_LLSTAT))
+		goto out_put_fail;
+	if (nla_put_u32(reply_radio, SPRDWL_LL_STATS_TYPE,
+			SPRDWL_NL80211_VENDOR_SUBCMD_LL_STATS_TYPE_RADIO))
+		goto out_put_fail;
+
+	ret = sprdwl_compose_radio_st(reply_radio, radio_st);
+
+	ret = cfg80211_vendor_cmd_reply(reply_radio);
+
+	wl_info("start to put iface data\n");
+	/*alloc iface reply buffer*/
+	reply_iface = cfg80211_vendor_cmd_alloc_reply_skb(wiphy,
+							  reply_iface_length);
+	if (!reply_iface)
+		goto out_put_fail;
+
+	if (nla_put_u32(reply_iface, NL80211_ATTR_VENDOR_ID, OUI_SPREAD))
+		goto out_put_fail;
+	if (nla_put_u32(reply_iface, NL80211_ATTR_VENDOR_SUBCMD,
+			SPRDWL_VENDOR_GET_LLSTAT))
+		goto out_put_fail;
+	if (nla_put_u32(reply_iface, SPRDWL_LL_STATS_TYPE,
+			SPRDWL_NL80211_VENDOR_SUBCMD_LL_STATS_TYPE_IFACE))
+		goto out_put_fail;
+	ret = sprdwl_compose_iface_st(reply_iface, iface_st);
+	ret = cfg80211_vendor_cmd_reply(reply_iface);
+
+	kfree(radio_st);
+	kfree(iface_st);
+	kfree(dif_radio);
+	return ret;
+out_put_fail:
+	kfree(radio_st);
+	kfree(iface_st);
+	kfree(dif_radio);
+	WARN_ON(1);
+	return -EMSGSIZE;
+}
+
+/*clear link layer status function--- CMD ID:16*/
+static int sprdwl_vendor_clr_llstat_handler(struct wiphy *wiphy,
+					    struct wireless_dev *wdev,
+					    const void *data, int len)
+{
+	struct sk_buff *reply;
+	struct wifi_clr_llstat_rsp clr_rsp;
+	struct nlattr *tb[SPRDWL_LL_STATS_CLR_MAX + 1];
+	u32 *stats_clear_rsp_mask, stats_clear_req_mask = 0;
+	u16 r_len = sizeof(*stats_clear_rsp_mask);
+	u8 r_buf[r_len];
+	u32 reply_length, ret, err;
+
+	struct sprdwl_priv *priv = wiphy_priv(wiphy);
+	struct sprdwl_vif *vif = container_of(wdev, struct sprdwl_vif, wdev);
+
+	if (!(priv->fw_capa & SPRDWL_CAPA_LL_STATS))
+		return -ENOTSUPP;
+	memset(r_buf, 0, r_len);
+	if (!data) {
+		wl_err("%s wrong llstat clear req mask\n", __func__);
+		return -EINVAL;
+	}
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 14, 0)
+	err = nla_parse(tb, SPRDWL_LL_STATS_CLR_MAX, data,
+			len, NULL, NULL);
+#else
+	err = nla_parse(tb, SPRDWL_LL_STATS_CLR_MAX, data,
+			len, NULL);
+#endif
+	if (err)
+		return err;
+	if (tb[SPRDWL_LL_STATS_CLR_CONFIG_REQ_MASK]) {
+		stats_clear_req_mask =
+		nla_get_u32(tb[SPRDWL_LL_STATS_CLR_CONFIG_REQ_MASK]);
+	}
+	wiphy_info(wiphy, "stats_clear_req_mask = %u\n", stats_clear_req_mask);
+	ret = sprdwl_llstat(priv, vif->ctx_id, SPRDWL_SUBCMD_DEL,
+			    &stats_clear_req_mask, r_len, r_buf, &r_len);
+	stats_clear_rsp_mask = (u32 *)r_buf;
+	clr_rsp.stats_clear_rsp_mask = *stats_clear_rsp_mask;
+	clr_rsp.stop_rsp = 1;
+
+	reply_length = sizeof(clr_rsp) + 100;
+	reply = cfg80211_vendor_cmd_alloc_reply_skb(wiphy, reply_length);
+	if (!reply)
+		return -ENOMEM;
+	if (nla_put_u32(reply, NL80211_ATTR_VENDOR_ID, OUI_SPREAD))
+		goto out_put_fail;
+	if (nla_put_u32(reply, NL80211_ATTR_VENDOR_SUBCMD,
+			SPRDWL_VENDOR_CLR_LLSTAT))
+		goto out_put_fail;
+	if (nla_put_u32(reply, SPRDWL_LL_STATS_CLR_CONFIG_RSP_MASK,
+			clr_rsp.stats_clear_rsp_mask))
+		goto out_put_fail;
+	if (nla_put_u32(reply, SPRDWL_LL_STATS_CLR_CONFIG_STOP_RSP,
+			clr_rsp.stop_rsp))
+		goto out_put_fail;
+	ret = cfg80211_vendor_cmd_reply(reply);
+
+	return ret;
+out_put_fail:
+	kfree_skb(reply);
+	WARN_ON(1);
+	return -EMSGSIZE;
+}
+/*start gscan functon, including scan params configuration------ CMD ID:20*/
+static int sprdwl_vendor_gscan_start(struct wiphy *wiphy,
+				    struct wireless_dev *wdev,
+				    const void *data, int len)
+{
+	u64 tlen;
+	int i, j, ret = 0, enable;
+	int rem_len, rem_outer_len, type;
+	int rem_inner_len, rem_outer_len1, rem_inner_len1;
+	struct nlattr *pos, *outer_iter, *inner_iter;
+	struct nlattr *outer_iter1, *inner_iter1;
+	struct sprdwl_cmd_gscan_set_config *params;
+	struct sprdwl_cmd_gscan_rsp_header rsp;
+	struct sprdwl_vif *vif = netdev_priv(wdev->netdev);
+	u16 rlen = sizeof(struct sprdwl_cmd_gscan_rsp_header);
+
+	wl_info("%s enter\n", __func__);
+	params = kmalloc(sizeof(*params), GFP_KERNEL);
+	if (!params)
+		return -ENOMEM;
+
+	/*malloc memory to store scan params*/
+	memset(params, 0, sizeof(*params));
+
+	/*parse attri from hal, to configure scan params*/
+	nla_for_each_attr(pos, (void *)data, len, rem_len) {
+		type = nla_type(pos);
+		switch (type) {
+		case GSCAN_ATTR_SUBCMD_CONFIG_PARAM_REQUEST_ID:
+			vif->priv->gscan_req_id = nla_get_u32(pos);
+		break;
+
+		case GSCAN_ATTR_SCAN_CMD_PARAMS_BASE_PERIOD:
+			params->base_period = nla_get_u32(pos);
+		break;
+
+		case GSCAN_ATTR_SCAN_CMD_PARAMS_MAX_AP_PER_SCAN:
+			params->maxAPperScan = nla_get_u32(pos);
+		break;
+
+		case GSCAN_ATTR_SCAN_CMD_PARAMS_REPORT_THR:
+			params->reportThreshold = nla_get_u8(pos);
+		break;
+
+		case GSCAN_ATTR_SCAN_CMD_PARAMS_REPORT_THR_NUM_SCANS:
+			params->report_threshold_num_scans
+				= nla_get_u8(pos);
+		break;
+
+		case GSCAN_ATTR_SCAN_CMD_PARAMS_NUM_BUCKETS:
+			params->num_buckets = nla_get_u8(pos);
+		break;
+
+		case GSCAN_ATTR_BUCKET_SPEC:
+		i = 0;
+		nla_for_each_nested(outer_iter, pos, rem_outer_len) {
+			nla_for_each_nested(inner_iter, outer_iter,
+					    rem_inner_len){
+				type = nla_type(inner_iter);
+				switch (type) {
+				case GSCAN_ATTR_BUCKET_SPEC_INDEX:
+					params->buckets[i].bucket
+						= nla_get_u8(inner_iter);
+				break;
+
+				case GSCAN_ATTR_BUCKET_SPEC_BAND:
+					params->buckets[i].band
+						= nla_get_u8(inner_iter);
+				break;
+
+				case GSCAN_ATTR_BUCKET_SPEC_PERIOD:
+					params->buckets[i].period
+						= nla_get_u32(inner_iter);
+				break;
+
+				case GSCAN_ATTR_BUCKET_SPEC_REPORT_EVENTS:
+					params->buckets[i].report_events
+						= nla_get_u8(inner_iter);
+				break;
+
+				case GSCAN_ATTR_BUCKET_SPEC_NUM_CHANNEL_SPECS:
+					params->buckets[i].num_channels
+						= nla_get_u32(inner_iter);
+				break;
+
+				case GSCAN_ATTR_BUCKET_SPEC_MAX_PERIOD:
+					params->buckets[i].max_period
+						= nla_get_u32(inner_iter);
+				break;
+
+				case GSCAN_ATTR_BUCKET_SPEC_BASE:
+					params->buckets[i].base
+						= nla_get_u32(inner_iter);
+				break;
+
+				case GSCAN_ATTR_BUCKET_SPEC_STEP_COUNT:
+					params->buckets[i].step_count
+						= nla_get_u32(inner_iter);
+				break;
+
+				case GSCAN_ATTR_CHANNEL_SPEC:
+				j = 0;
+				nla_for_each_nested(outer_iter1,
+						    inner_iter,
+					rem_outer_len1) {
+					nla_for_each_nested(inner_iter1,
+							    outer_iter1,
+						rem_inner_len1) {
+						type = nla_type(inner_iter1);
+
+					switch (type) {
+					case GSCAN_ATTR_CHANNEL_SPEC_CHANNEL:
+					params->buckets[i].channels[j].channel
+						= nla_get_u32(inner_iter1);
+					break;
+					case GSCAN_ATTR_CHANNEL_SPEC_DWELL_TIME:
+					params->buckets[i].channels[j].dwelltime
+						= nla_get_u32(inner_iter1);
+					break;
+					case GSCAN_ATTR_CHANNEL_SPEC_PASSIVE:
+					params->buckets[i].channels[j].passive
+						= nla_get_u32(inner_iter1);
+					break;
+					}
+					}
+					j++;
+					if (j >= MAX_CHANNELS)
+						break;
+				}
+				break;
+
+				default:
+					wl_ndev_log(L_ERR, vif->ndev,
+						   "bucket nla type 0x%x not support\n",
+						   type);
+					ret = -EINVAL;
+				break;
+				}
+			}
+			if (ret < 0)
+				break;
+			i++;
+			if (i >= MAX_BUCKETS)
+				break;
+		}
+		break;
+
+		default:
+			wl_ndev_log(L_ERR, vif->ndev, "nla type 0x%x not support\n",
+				   type);
+			ret = -EINVAL;
+			break;
+		}
+	}
+
+	wl_ndev_log(L_INFO, vif->ndev, "parse config %s\n",
+		    !ret ? "success" : "failture");
+
+	kfree(vif->priv->gscan_res);
+	vif->priv->gscan_buckets_num = params->num_buckets;
+	tlen = sizeof(struct sprdwl_gscan_cached_results);
+
+	/*malloc memory to store scan results*/
+	vif->priv->gscan_res =
+		kmalloc((u64)(vif->priv->gscan_buckets_num * tlen),
+				GFP_KERNEL);
+
+	if (!vif->priv->gscan_res) {
+		kfree(params);
+		return -ENOMEM;
+	}
+
+	memset(vif->priv->gscan_res, 0x0,
+	       vif->priv->gscan_buckets_num *
+		sizeof(struct sprdwl_gscan_cached_results));
+
+	tlen = sizeof(struct sprdwl_cmd_gscan_set_config);
+
+	for (i = 0; i < params->num_buckets; i++) {
+		if (params->buckets[i].num_channels == 0) {
+			wl_err("%s, %d, gscan channel not set\n", __func__, __LINE__);
+			params->buckets[i].num_channels = 11;
+			for (j = 0; j < 11; j++)
+				params->buckets[i].channels[j].channel = j+1;
+		}
+	}
+	/*send scan params configure command*/
+	ret = sprdwl_gscan_subcmd(vif->priv, vif->ctx_id,
+				  (void *)params,
+		SPRDWL_GSCAN_SUBCMD_SET_CONFIG,
+		tlen, (u8 *)(&rsp), &rlen);
+	if (ret == 0) {
+		enable = 1;
+
+		/*start gscan*/
+		ret = sprdwl_gscan_subcmd(vif->priv, vif->ctx_id,
+					  (void *)(&enable),
+			SPRDWL_GSCAN_SUBCMD_ENABLE_GSCAN,
+			sizeof(int), (u8 *)(&rsp), &rlen);
+	}
+
+	if (ret < 0)
+		kfree(vif->priv->gscan_res);
+	kfree(params);
+
+	return ret;
+}
+
+/*stop gscan functon------ CMD ID:21*/
+static int sprdwl_vendor_gscan_stop(struct wiphy *wiphy,
+				    struct wireless_dev *wdev,
+				      const void *data, int len)
+{
+	int enable;
+	struct sprdwl_vif *vif = netdev_priv(wdev->netdev);
+	struct sprdwl_cmd_gscan_rsp_header rsp;
+	u16 rlen = sizeof(struct sprdwl_cmd_gscan_rsp_header);
+
+	enable = 0;
+	wl_ndev_log(L_INFO, vif->ndev, "%s\n", __func__);
+
+	return sprdwl_gscan_subcmd(vif->priv, vif->ctx_id,
+					(void *)(&enable),
+					SPRDWL_GSCAN_SUBCMD_ENABLE_GSCAN,
+					sizeof(int), (u8 *)(&rsp), &rlen);
+}
+
+/*get valid channel list functon, need input band value------ CMD ID:22*/
+static int sprdwl_vendor_get_channel_list(struct wiphy *wiphy,
+					  struct wireless_dev *wdev,
+					  const void *data, int len)
+{
+	int ret = 0, payload, request_id;
+	int type;
+	int band = 0, max_channel;
+	int rem_len;
+	struct nlattr *pos;
+	struct sprdwl_cmd_gscan_channel_list channel_list;
+	struct sprdwl_vif *vif = netdev_priv(wdev->netdev);
+	struct sk_buff *reply;
+	u16 rlen;
+
+	rlen = sizeof(struct sprdwl_cmd_gscan_channel_list)
+		+ sizeof(struct sprdwl_cmd_gscan_rsp_header);
+
+	nla_for_each_attr(pos, (void *)data, len, rem_len) {
+		type = nla_type(pos);
+		switch (type) {
+		case GSCAN_ATTR_SUBCMD_CONFIG_PARAM_REQUEST_ID:
+			request_id = nla_get_s32(pos);
+		break;
+		case GSCAN_ATTR_GET_VALID_CHANNELS_CONFIG_PARAM_WIFI_BAND:
+			band = nla_get_s32(pos);
+		break;
+		case GSCAN_ATTR_GET_VALID_CHANNELS_CONFIG_PARAM_MAX_CHANNELS:
+			max_channel = nla_get_s32(pos);
+		break;
+		default:
+			wl_ndev_log(L_ERR, vif->ndev, "nla type 0x%x not support\n",
+				   type);
+			ret = -EINVAL;
+		break;
+	    }
+	    if (ret < 0)
+		break;
+	}
+
+	wl_ndev_log(L_INFO, vif->ndev, "parse channel list %s band=%d\n",
+		    !ret ? "success" : "failture", band);
+
+	payload = rlen + 0x100;
+	reply = cfg80211_vendor_cmd_alloc_reply_skb(wiphy, payload);
+	if (!reply) {
+		ret = -ENOMEM;
+		goto out;
+	}
+	if (band == WIFI_BAND_A) {
+		channel_list.num_channels =
+			vif->priv->ch_5g_without_dfs_info.num_channels;
+		memcpy(channel_list.channels,
+			vif->priv->ch_5g_without_dfs_info.channels,
+			sizeof(int) * channel_list.num_channels);
+	} else if (band == WIFI_BAND_A_DFS) {
+		channel_list.num_channels =
+			vif->priv->ch_5g_dfs_info.num_channels;
+		memcpy(channel_list.channels,
+			vif->priv->ch_5g_dfs_info.channels,
+			sizeof(int) * channel_list.num_channels);
+	} else {
+		/*return 2.4G channel list by default*/
+		channel_list.num_channels = vif->priv->ch_2g4_info.num_channels;
+		memcpy(channel_list.channels, vif->priv->ch_2g4_info.channels,
+			sizeof(int) * channel_list.num_channels);
+	}
+
+	if (nla_put_u32(reply, GSCAN_RESULTS_NUM_CHANNELS,
+				channel_list.num_channels))
+		goto out_put_fail;
+	if (nla_put(reply, GSCAN_RESULTS_CHANNELS,
+		sizeof(int) * channel_list.num_channels, channel_list.channels))
+
+		goto out_put_fail;
+	ret = cfg80211_vendor_cmd_reply(reply);
+	if (ret)
+		wl_ndev_log(L_ERR, vif->ndev, "%s failed to reply skb!\n", __func__);
+
+out:
+	return ret;
+out_put_fail:
+	kfree_skb(reply);
+	WARN_ON(1);
+	return -EMSGSIZE;
+}
+
+/*Gscan get capabilities function----CMD ID:23*/
+static int sprdwl_vendor_get_gscan_capabilities(struct wiphy *wiphy,
+						struct wireless_dev *wdev,
+						const void *data, int len)
+{
+	u16 rlen;
+	struct sk_buff *reply;
+	int ret = 0, payload;
+	struct sprdwl_vif *vif = netdev_priv(wdev->netdev);
+	struct sprdwl_cmd_gscan_rsp_header *hdr;
+	struct sprdwl_gscan_capa *p = NULL;
+	void *rbuf;
+
+	wl_info("%s enter\n", __func__);
+
+	rlen = sizeof(struct sprdwl_gscan_capa) +
+	    sizeof(struct sprdwl_cmd_gscan_rsp_header);
+	rbuf = kmalloc(rlen, GFP_KERNEL);
+	if (!rbuf)
+		return -ENOMEM;
+
+	ret = sprdwl_gscan_subcmd(vif->priv, vif->ctx_id,
+				  NULL, SPRDWL_GSCAN_SUBCMD_GET_CAPABILITIES,
+					0, (u8 *)rbuf, &rlen);
+
+	if (ret < 0) {
+		wl_ndev_log(L_ERR, vif->ndev, "%s failed to get capabilities!\n",
+			   __func__);
+		goto out;
+	}
+	hdr = (struct sprdwl_cmd_gscan_rsp_header *)rbuf;
+	p = (struct sprdwl_gscan_capa *)
+	    (rbuf + sizeof(struct sprdwl_cmd_gscan_rsp_header));
+	wl_info("cache_size: %d scan_bucket:%d\n",
+		p->max_scan_cache_size, p->max_scan_buckets);
+	wl_info("max AP per scan:%d,max_rssi_sample_size:%d\n",
+		p->max_ap_cache_per_scan, p->max_rssi_sample_size);
+	wl_info("max_white_list:%d,max_black_list:%d\n",
+		p->max_whitelist_ssid, p->max_blacklist_size);
+	payload = rlen + 0x100;
+	reply = cfg80211_vendor_cmd_alloc_reply_skb(wiphy, payload);
+	if (!reply) {
+		ret = -ENOMEM;
+		goto out;
+	}
+
+	if (nla_put_u32(reply, GSCAN_SCAN_CACHE_SIZE,
+			p->max_scan_cache_size) ||
+		nla_put_u32(reply, GSCAN_MAX_SCAN_BUCKETS,
+			    p->max_scan_buckets) ||
+		nla_put_u32(reply, GSCAN_MAX_AP_CACHE_PER_SCAN,
+			    p->max_ap_cache_per_scan) ||
+		nla_put_u32(reply, GSCAN_MAX_RSSI_SAMPLE_SIZE,
+			    p->max_rssi_sample_size) ||
+		nla_put_s32(reply, GSCAN_MAX_SCAN_REPORTING_THRESHOLD,
+			    p->max_scan_reporting_threshold) ||
+		nla_put_u32(reply, GSCAN_MAX_HOTLIST_BSSIDS,
+			    p->max_hotlist_bssids) ||
+		nla_put_u32(reply, GSCAN_MAX_SIGNIFICANT_WIFI_CHANGE_APS,
+			    p->max_significant_wifi_change_aps) ||
+		nla_put_u32(reply, GSCAN_MAX_BSSID_HISTORY_ENTRIES,
+			    p->max_bssid_history_entries) ||
+		nla_put_u32(reply, GSCAN_MAX_HOTLIST_SSIDS,
+			    p->max_hotlist_bssids) ||
+		nla_put_u32(reply, GSCAN_MAX_NUM_EPNO_NETS,
+			    p->max_number_epno_networks) ||
+		nla_put_u32(reply, GSCAN_MAX_NUM_EPNO_NETS_BY_SSID,
+			    p->max_number_epno_networks_by_ssid) ||
+		nla_put_u32(reply, GSCAN_MAX_NUM_WHITELISTED_SSID,
+			    p->max_whitelist_ssid) ||
+		nla_put_u32(reply, GSCAN_MAX_NUM_BLACKLISTED_BSSID,
+			    p->max_blacklist_size)){
+		wl_err("failed to put Gscan capabilies\n");
+		goto out_put_fail;
+	}
+		vif->priv->roam_capa.max_blacklist_size = p->max_blacklist_size;
+		vif->priv->roam_capa.max_whitelist_size = p->max_whitelist_ssid;
+
+	ret = cfg80211_vendor_cmd_reply(reply);
+	if (ret)
+		wl_ndev_log(L_ERR, vif->ndev, "%s failed to reply skb!\n", __func__);
+out:
+	kfree(rbuf);
+	return ret;
+out_put_fail:
+	kfree_skb(reply);
+	kfree(rbuf);
+	return ret;
+}
+
+/*get cached gscan results functon------ CMD ID:24*/
+static int sprdwl_vendor_get_cached_gscan_results(struct wiphy *wiphy,
+						  struct wireless_dev *wdev,
+					   const void *data, int len)
+{
+	int ret = 0, i, j, rlen, payload, request_id = 0, moredata = 0;
+	int rem_len, type, flush = 0, max_param = 0, n, buckets_scanned = 1;
+	struct sprdwl_vif *vif = netdev_priv(wdev->netdev);
+	struct sk_buff *reply;
+	struct nlattr *pos, *scan_res, *cached_list, *res_list;
+
+	nla_for_each_attr(pos, (void *)data, len, rem_len) {
+		type = nla_type(pos);
+		switch (type) {
+		case GSCAN_ATTR_SUBCMD_CONFIG_PARAM_REQUEST_ID:
+			request_id = nla_get_u32(pos);
+		break;
+		case GSCAN_ATTR_GET_CACHED_SCAN_RESULTS_CONFIG_PARAM_FLUSH:
+			flush = nla_get_u32(pos);
+		break;
+		case GSCAN_ATTR_GET_CACHED_SCAN_RESULTS_CONFIG_PARAM_MAX:
+			max_param = nla_get_u32(pos);
+		break;
+		default:
+			wl_ndev_log(L_ERR, vif->ndev, "nla gscan result 0x%x not support\n",
+				   type);
+			ret = -EINVAL;
+		break;
+		}
+		if (ret < 0)
+			break;
+	}
+
+	rlen = vif->priv->gscan_buckets_num
+		* sizeof(struct sprdwl_gscan_cached_results);
+	payload = rlen + 0x100;
+	reply = cfg80211_vendor_cmd_alloc_reply_skb(wiphy, payload);
+	if (!reply)
+		return -ENOMEM;
+	for (i = 0; i < vif->priv->gscan_buckets_num; i++) {
+		if (!(vif->priv->gscan_res + i)->num_results)
+			continue;
+
+		for (j = 0; j <= (vif->priv->gscan_res + i)->num_results; j++) {
+			if (time_after(jiffies - VENDOR_SCAN_RESULT_EXPIRE,
+				(vif->priv->gscan_res + i)->results[j].ts)) {
+				memcpy((void *)
+				(&(vif->priv->gscan_res + i)->results[j]),
+				(void *)
+				(&(vif->priv->gscan_res + i)->results[j + 1]),
+				sizeof(struct sprdwl_gscan_result)
+				* ((vif->priv->gscan_res + i)->num_results
+				- j - 1));
+				(vif->priv->gscan_res + i)->num_results--;
+				j = 0;
+			}
+		}
+
+		if (nla_put_u32(reply, GSCAN_RESULTS_REQUEST_ID,
+				request_id) ||
+			nla_put_u32(reply,
+				    GSCAN_RESULTS_NUM_RESULTS_AVAILABLE,
+			(vif->priv->gscan_res + i)->num_results)) {
+			wl_ndev_log(L_ERR, vif->ndev, "failed to put!\n");
+			goto out_put_fail;
+		}
+
+		if (nla_put_u8(reply,
+			       GSCAN_RESULTS_SCAN_RESULT_MORE_DATA,
+			moredata)) {
+			wl_ndev_log(L_ERR, vif->ndev, "failed to put!\n");
+			goto out_put_fail;
+		}
+
+		if (nla_put_u32(reply,
+				GSCAN_CACHED_RESULTS_SCAN_ID,
+			(vif->priv->gscan_res + i)->scan_id)) {
+			wl_ndev_log(L_ERR, vif->ndev, "failed to put!\n");
+			goto out_put_fail;
+		}
+
+		if ((vif->priv->gscan_res + i)->num_results == 0)
+			break;
+
+		cached_list = nla_nest_start(reply, GSCAN_CACHED_RESULTS_LIST);
+		for (n = 0; n < vif->priv->gscan_buckets_num; n++) {
+			res_list = nla_nest_start(reply, n);
+
+			if (!res_list)
+				goto out_put_fail;
+
+			if (nla_put_u32(reply,
+					GSCAN_CACHED_RESULTS_SCAN_ID,
+				(vif->priv->gscan_res + i)->scan_id)) {
+				wl_ndev_log(L_ERR, vif->ndev, "failed to put!\n");
+				goto out_put_fail;
+			}
+
+			if (nla_put_u32(reply,
+					GSCAN_CACHED_RESULTS_FLAGS,
+				(vif->priv->gscan_res + i)->flags)) {
+				wl_ndev_log(L_ERR, vif->ndev, "failed to put!\n");
+				goto out_put_fail;
+			}
+
+			if (nla_put_u32(reply,
+					GSCAN_RESULTS_BUCKETS_SCANNED,
+				buckets_scanned)) {
+				wl_ndev_log(L_ERR, vif->ndev, "failed to put!\n");
+				goto out_put_fail;
+			}
+
+			if (nla_put_u32(reply,
+					GSCAN_RESULTS_NUM_RESULTS_AVAILABLE,
+				(vif->priv->gscan_res + i)->num_results)) {
+				wl_ndev_log(L_ERR, vif->ndev, "failed to put!\n");
+				goto out_put_fail;
+			}
+
+			scan_res = nla_nest_start(reply, GSCAN_RESULTS_LIST);
+			if (!scan_res)
+				goto out_put_fail;
+
+			for (j = 0;
+			j < (vif->priv->gscan_res + i)->num_results;
+			j++) {
+				struct nlattr *ap;
+				struct sprdwl_gscan_cached_results *p
+						= vif->priv->gscan_res + i;
+
+				wl_info("[index=%d] Timestamp(%lu) Ssid (%s) Bssid: %pM Channel (%d) Rssi (%d) RTT (%u) RTT_SD (%u)\n",
+					j,
+					p->results[j].ts,
+					p->results[j].ssid,
+					p->results[j].bssid,
+					p->results[j].channel,
+					p->results[j].rssi,
+					p->results[j].rtt,
+					p->results[j].rtt_sd);
+
+				ap = nla_nest_start(reply, j + 1);
+				if (!ap) {
+					wl_ndev_log(L_ERR, vif->ndev, "failed to put!\n");
+					goto out_put_fail;
+				}
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 7, 0)
+				if (nla_put_u64_64bit(reply,
+					  GSCAN_RESULTS_SCAN_RESULT_TIME_STAMP,
+					p->results[j].ts, 0)) {
+#else
+				if (nla_put_u64(reply,
+					GSCAN_RESULTS_SCAN_RESULT_TIME_STAMP,
+					p->results[j].ts)) {
+#endif
+					wl_ndev_log(L_ERR, vif->ndev, "failed to put!\n");
+					goto out_put_fail;
+				}
+				if (nla_put(reply,
+					  GSCAN_RESULTS_SCAN_RESULT_SSID,
+					sizeof(p->results[j].ssid),
+					p->results[j].ssid)) {
+					wl_ndev_log(L_ERR, vif->ndev, "failed to put!\n");
+					goto out_put_fail;
+				}
+				if (nla_put(reply,
+					    GSCAN_RESULTS_SCAN_RESULT_BSSID,
+					sizeof(p->results[j].bssid),
+					p->results[j].bssid)) {
+					wl_ndev_log(L_ERR, vif->ndev, "failed to put!\n");
+					goto out_put_fail;
+				}
+				if (nla_put_u32(reply,
+					GSCAN_RESULTS_SCAN_RESULT_CHANNEL,
+					p->results[j].channel)) {
+					wl_ndev_log(L_ERR, vif->ndev, "failed to put!\n");
+					goto out_put_fail;
+				}
+				if (nla_put_s32(reply,
+						GSCAN_RESULTS_SCAN_RESULT_RSSI,
+					p->results[j].rssi)) {
+					wl_ndev_log(L_ERR, vif->ndev, "failed to put!\n");
+					goto out_put_fail;
+				}
+				if (nla_put_u32(reply,
+						GSCAN_RESULTS_SCAN_RESULT_RTT,
+					p->results[j].rtt)) {
+					wl_ndev_log(L_ERR, vif->ndev, "failed to put!\n");
+					goto out_put_fail;
+				}
+				if (nla_put_u32(reply,
+					GSCAN_RESULTS_SCAN_RESULT_RTT_SD,
+					p->results[j].rtt_sd)) {
+					wl_ndev_log(L_ERR, vif->ndev, "failed to put!\n");
+					goto out_put_fail;
+				}
+			nla_nest_end(reply, ap);
+			}
+		nla_nest_end(reply, scan_res);
+		nla_nest_end(reply, res_list);
+		}
+	nla_nest_end(reply, cached_list);
+	}
+
+	ret = cfg80211_vendor_cmd_reply(reply);
+	if (ret < 0)
+		wl_ndev_log(L_ERR, vif->ndev, "%s failed to reply skb!\n", __func__);
+	return ret;
+
+out_put_fail:
+	kfree_skb(reply);
+	WARN_ON(1);
+	return -EMSGSIZE;
+}
+
+/*buffer scan result in host driver when receive frame from cp2*/
+int sprdwl_vendor_cache_scan_result(struct sprdwl_vif *vif,
+					    u8 bucket_id,
+					    struct sprdwl_gscan_result *item)
+{
+	struct sprdwl_priv *priv = vif->priv;
+	u32 i;
+	struct sprdwl_gscan_cached_results *p = NULL;
+
+	if (bucket_id >= priv->gscan_buckets_num || !priv->gscan_res) {
+		wl_ndev_log(L_ERR, vif->ndev, "%s the gscan buffer invalid!priv->gscan_buckets_num: %d, bucket_id:%d\n",
+			   __func__, priv->gscan_buckets_num, bucket_id);
+		return -EINVAL;
+	}
+	for (i = 0; i < priv->gscan_buckets_num; i++) {
+		p = priv->gscan_res + i;
+		if (p->scan_id == bucket_id)
+			break;
+	}
+	if (!p) {
+		wl_ndev_log(L_ERR, vif->ndev, "%s the bucket isnot exsit.\n", __func__);
+		return -EINVAL;
+	}
+	if (MAX_AP_CACHE_PER_SCAN <= p->num_results) {
+		wl_ndev_log(L_ERR, vif->ndev, "%s the scan result reach the MAX num.\n",
+			   __func__);
+		return -EINVAL;
+	}
+
+	for (i = 0; i < p->num_results; i++) {
+		if (time_after(jiffies - VENDOR_SCAN_RESULT_EXPIRE,
+			       p->results[i].ts)) {
+			memcpy((void *)(&p->results[i]),
+			       (void *)(&p->results[i+1]),
+				sizeof(struct sprdwl_gscan_result)
+				* (p->num_results - i - 1));
+
+			p->num_results--;
+		}
+
+		if (!memcmp(p->results[i].bssid, item->bssid, ETH_ALEN) &&
+		    strlen(p->results[i].ssid) == strlen(item->ssid) &&
+		    !memcmp(p->results[i].ssid, item->ssid,
+			    strlen(item->ssid))) {
+			wl_ndev_log(L_ERR, vif->ndev, "%s BSS : %s  %pM exist, but also update it.\n",
+				   __func__, item->ssid, item->bssid);
+
+			memcpy((void *)(&p->results[i]),
+			       (void *)item,
+				sizeof(struct sprdwl_gscan_result));
+			return 0;
+		}
+	}
+	memcpy((void *)(&p->results[p->num_results]),
+	       (void *)item, sizeof(struct sprdwl_gscan_result));
+	p->results[p->num_results].ie_length = 0;
+	p->results[p->num_results].ie_data[0] = 0;
+	p->num_results++;
+	return 0;
+}
+
+int sprdwl_vendor_cache_hotlist_result(struct sprdwl_vif *vif,
+					      struct sprdwl_gscan_result *item)
+{
+	struct sprdwl_priv *priv = vif->priv;
+	u32 i;
+	struct sprdwl_gscan_hotlist_results *p = priv->hotlist_res;
+
+	if (!priv->hotlist_res) {
+		wl_ndev_log(L_ERR, vif->ndev, "%s the hotlist buffer invalid!\n",
+			   __func__);
+		return -EINVAL;
+	}
+
+	if (MAX_HOTLIST_APS <= p->num_results) {
+		wl_ndev_log(L_ERR, vif->ndev, "%s the hotlist result reach the MAX num.\n",
+			   __func__);
+		return -EINVAL;
+	}
+
+	for (i = 0; i < p->num_results; i++) {
+		if (time_after(jiffies - VENDOR_SCAN_RESULT_EXPIRE,
+			       p->results[i].ts)) {
+			memcpy((void *)(&p->results[i]),
+			       (void *)(&p->results[i+1]),
+				sizeof(struct sprdwl_gscan_result)
+				* (p->num_results - i - 1));
+
+			p->num_results--;
+		}
+
+		if (!memcmp(p->results[i].bssid, item->bssid, ETH_ALEN) &&
+		    strlen(p->results[i].ssid) == strlen(item->ssid) &&
+		    !memcmp(p->results[i].ssid, item->ssid,
+			    strlen(item->ssid))) {
+			wl_ndev_log(L_ERR, vif->ndev, "%s BSS : %s  %pM exist, but also update it.\n",
+				   __func__, item->ssid, item->bssid);
+
+			memcpy((void *)(&p->results[i]),
+			       (void *)item,
+				sizeof(struct sprdwl_gscan_result));
+			return 0;
+		}
+	}
+	memcpy((void *)(&p->results[p->num_results]),
+	       (void *)item, sizeof(struct sprdwl_gscan_result));
+	p->results[p->num_results].ie_length = 0;
+	p->results[p->num_results].ie_data[0] = 0;
+	p->num_results++;
+	return 0;
+}
+
+int sprdwl_vendor_cache_significant_change_result(struct sprdwl_vif *vif,
+							u8 *data, u16 data_len)
+{
+	struct sprdwl_priv *priv = vif->priv;
+	struct significant_change_info *frame;
+	struct sprdwl_significant_change_result *p = priv->significant_res;
+	u8 *pos = data;
+	u16 avail_len = data_len;
+
+	if (!priv->significant_res) {
+		wl_ndev_log(L_ERR, vif->ndev, "%s the significant_change buffer invalid!\n",
+			   __func__);
+		return -EINVAL;
+	}
+
+	if (MAX_SIGNIFICANT_CHANGE_APS <= p->num_results) {
+		wl_ndev_log(L_ERR, vif->ndev, "%s the significant_change result reach the MAX num.\n",
+			   __func__);
+		return -EINVAL;
+	}
+
+	while (avail_len > 0) {
+		if (avail_len < (sizeof(struct significant_change_info) + 1)) {
+			wl_ndev_log(L_ERR, vif->ndev,
+				   "%s invalid available length: %d!\n",
+				   __func__, avail_len);
+			break;
+		}
+
+		pos++;
+		frame = (struct significant_change_info *)pos;
+
+		memcpy((void *)(&p->results[p->num_results]),
+		       (void *)pos, sizeof(struct significant_change_info));
+		p->num_results++;
+
+		avail_len -= sizeof(struct significant_change_info) + 1;
+		pos += sizeof(struct significant_change_info);
+	}
+	return 0;
+}
+
+/*report full scan result to upper layer, it will only report one AP,*/
+/*including its IE data*/
+int sprdwl_vendor_report_full_scan(struct sprdwl_vif *vif,
+					  struct sprdwl_gscan_result *item)
+{
+	struct sprdwl_priv *priv = vif->priv;
+	struct wiphy *wiphy = priv->wiphy;
+	struct sk_buff *reply;
+	int payload, rlen;
+	int ret = 0;
+
+	rlen = sizeof(struct sprdwl_gscan_result) + item->ie_length;
+	payload = rlen + 0x100;
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 4, 83)
+	reply = cfg80211_vendor_event_alloc(wiphy, &vif->wdev,
+#else
+	reply = cfg80211_vendor_event_alloc(wiphy,
+#endif
+					    payload,
+		NL80211_VENDOR_SUBCMD_GSCAN_FULL_SCAN_RESULT_INDEX,
+		GFP_KERNEL);
+	if (!reply) {
+		ret = -ENOMEM;
+		goto out;
+	}
+
+	if (nla_put_u32(reply, GSCAN_RESULTS_REQUEST_ID,
+			priv->gscan_req_id) ||
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 7, 0)
+	nla_put_u64_64bit(reply,
+		    GSCAN_RESULTS_SCAN_RESULT_TIME_STAMP,
+		item->ts, 0)
+#else
+	nla_put_u64(reply,
+			GSCAN_RESULTS_SCAN_RESULT_TIME_STAMP,
+		item->ts)
+#endif
+			||
+	nla_put(reply, GSCAN_RESULTS_SCAN_RESULT_SSID,
+		sizeof(item->ssid),
+		item->ssid) ||
+	nla_put(reply, GSCAN_RESULTS_SCAN_RESULT_BSSID,
+		6,
+		item->bssid) ||
+	nla_put_u32(reply,
+		    GSCAN_RESULTS_SCAN_RESULT_CHANNEL,
+		item->channel) ||
+	nla_put_s32(reply, GSCAN_RESULTS_SCAN_RESULT_RSSI,
+		    item->rssi) ||
+	nla_put_u32(reply, GSCAN_RESULTS_SCAN_RESULT_RTT,
+		    item->rtt) ||
+	nla_put_u32(reply,
+		    GSCAN_RESULTS_SCAN_RESULT_RTT_SD,
+		item->rtt_sd) ||
+	nla_put_u16(reply,
+		    GSCAN_RESULTS_SCAN_RESULT_BEACON_PERIOD,
+		item->beacon_period) ||
+	nla_put_u16(reply,
+		    GSCAN_RESULTS_SCAN_RESULT_CAPABILITY,
+		item->capability) ||
+	nla_put_u32(reply,
+		    GSCAN_RESULTS_SCAN_RESULT_IE_LENGTH,
+		item->ie_length))	{
+		wl_ndev_log(L_ERR, vif->ndev, "%s nla put fail\n", __func__);
+		goto out_put_fail;
+	}
+	if (nla_put(reply, GSCAN_RESULTS_SCAN_RESULT_IE_DATA,
+		    item->ie_length,
+		item->ie_data)) {
+		wl_ndev_log(L_ERR, vif->ndev, "%s nla put fail\n", __func__);
+		goto out_put_fail;
+	}
+
+	cfg80211_vendor_event(reply, GFP_KERNEL);
+out:
+	return ret;
+
+out_put_fail:
+	kfree_skb(reply);
+	WARN_ON(1);
+	return -EMSGSIZE;
+}
+
+void sprdwl_report_gscan_result(struct sprdwl_vif *vif,
+				u32 report_event, u8 bucket_id,
+				u16 chan, s16 rssi, const u8 *frame, u16 len)
+{
+	struct sprdwl_priv *priv = vif->priv;
+	struct wiphy *wiphy = priv->wiphy;
+	struct ieee80211_mgmt *mgmt = (struct ieee80211_mgmt *)frame;
+	struct ieee80211_channel *channel;
+	struct sprdwl_gscan_result *gscan_res = NULL;
+	u16 capability, beacon_interval;
+	u32 freq;
+	s32 signal;
+	u64 tsf;
+	u8 *ie;
+	size_t ielen;
+	const u8 *ssid;
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 7, 0)
+	freq = ieee80211_channel_to_frequency(chan,
+					      chan <= CH_MAX_2G_CHANNEL ?
+						NL80211_BAND_2GHZ : NL80211_BAND_5GHZ);
+#else
+	freq = ieee80211_channel_to_frequency(chan,
+						chan <= CH_MAX_2G_CHANNEL ?
+						IEEE80211_BAND_2GHZ : IEEE80211_BAND_5GHZ);
+#endif
+	channel = ieee80211_get_channel(wiphy, freq);
+	if (!channel) {
+		wl_ndev_log(L_ERR, vif->ndev, "%s invalid freq!\n", __func__);
+		return;
+	}
+	signal = rssi * 100;
+	if (!mgmt) {
+		wl_ndev_log(L_ERR, vif->ndev, "%s NULL frame!\n", __func__);
+		return;
+	}
+	ie = mgmt->u.probe_resp.variable;
+	ielen = len - offsetof(struct ieee80211_mgmt, u.probe_resp.variable);
+	/*tsf = le64_to_cpu(mgmt->u.probe_resp.timestamp);*/
+	tsf = jiffies;
+	beacon_interval = le16_to_cpu(mgmt->u.probe_resp.beacon_int);
+	capability = le16_to_cpu(mgmt->u.probe_resp.capab_info);
+	wl_ndev_log(L_DBG, vif->ndev, "   %s, %pM, channel %2u, signal %d\n",
+		   ieee80211_is_probe_resp(mgmt->frame_control)
+		   ? "proberesp" : "beacon   ", mgmt->bssid, chan, rssi);
+
+	gscan_res = kmalloc(sizeof(*gscan_res) + ielen, GFP_KERNEL);
+	if (!gscan_res)
+		return;
+	memset(gscan_res, 0x0, sizeof(struct sprdwl_gscan_result) + ielen);
+	gscan_res->channel = freq;
+	gscan_res->beacon_period = beacon_interval;
+	gscan_res->ts = tsf;
+	gscan_res->rssi = signal;
+	gscan_res->ie_length = ielen;
+	memcpy(gscan_res->bssid, mgmt->bssid, 6);
+	memcpy(gscan_res->ie_data, ie, ielen);
+
+	ssid = wpa_scan_get_ie(ie, ielen, WLAN_EID_SSID);
+	if (!ssid) {
+		wl_ndev_log(L_ERR, vif->ndev, "%s BSS: No SSID IE included for %pM!\n",
+			   __func__, mgmt->bssid);
+		goto out;
+	}
+	if (ssid[1] > 32) {
+		wl_ndev_log(L_ERR, vif->ndev, "%s BSS: Too long SSID IE for %pM!\n",
+			   __func__, mgmt->bssid);
+		goto out;
+	}
+	memcpy(gscan_res->ssid, ssid + 2, ssid[1]);
+	wl_ndev_log(L_ERR, vif->ndev, "%s %pM : %s !report_event =%d\n", __func__,
+		   mgmt->bssid, gscan_res->ssid, report_event);
+
+	if ((report_event == REPORT_EVENTS_BUFFER_FULL) ||
+	    (report_event & REPORT_EVENTS_EACH_SCAN) ||
+		(report_event & REPORT_EVENTS_FULL_RESULTS) ||
+		(report_event & REPORT_EVENTS_SIGNIFICANT_CHANGE)) {
+		sprdwl_vendor_cache_scan_result(vif, bucket_id, gscan_res);
+	} else if ((report_event & REPORT_EVENTS_HOTLIST_RESULTS_FOUND) ||
+		(report_event & REPORT_EVENTS_HOTLIST_RESULTS_LOST)) {
+		sprdwl_vendor_cache_hotlist_result(vif, gscan_res);
+	}
+
+	if (report_event & REPORT_EVENTS_FULL_RESULTS)
+		sprdwl_vendor_report_full_scan(vif, gscan_res);
+out:
+	kfree(gscan_res);
+}
+
+/*report event to upper layer when buffer is full,*/
+/*it only include event, not scan result*/
+int sprdwl_buffer_full_event(struct sprdwl_vif *vif)
+{
+	struct sprdwl_priv *priv = vif->priv;
+	struct wiphy *wiphy = priv->wiphy;
+	struct sk_buff *reply;
+	int payload, rlen;
+	int ret = 0;
+
+	rlen = sizeof(enum sprdwl_gscan_event);
+	payload = rlen + 0x100;
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 4, 83)
+	reply = cfg80211_vendor_event_alloc(wiphy, &vif->wdev,
+#else
+	reply = cfg80211_vendor_event_alloc(wiphy,
+#endif
+					    payload,
+		NL80211_VENDOR_SUBCMD_GSCAN_SCAN_RESULTS_AVAILABLE_INDEX,
+		GFP_KERNEL);
+	if (!reply) {
+		ret = -ENOMEM;
+		goto out;
+	}
+
+	if (nla_put_u32(reply, GSCAN_RESULTS_REQUEST_ID,
+			priv->gscan_req_id))
+		goto out_put_fail;
+
+	cfg80211_vendor_event(reply, GFP_KERNEL);
+out:
+	return ret;
+out_put_fail:
+	kfree_skb(reply);
+	WARN_ON(1);
+	return -EMSGSIZE;
+}
+
+int sprdwl_available_event(struct sprdwl_vif *vif)
+{
+	struct sprdwl_priv *priv = vif->priv;
+	struct wiphy *wiphy = priv->wiphy;
+	struct sk_buff *reply;
+	int payload, rlen;
+	int ret = 0;
+
+	rlen = sizeof(enum nl80211_vendor_subcmds_index);
+	payload = rlen + 0x100;
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 4, 83)
+	reply = cfg80211_vendor_event_alloc(wiphy, &vif->wdev,
+#else
+	reply = cfg80211_vendor_event_alloc(wiphy,
+#endif
+					    payload,
+		NL80211_VENDOR_SUBCMD_GSCAN_SCAN_RESULTS_AVAILABLE_INDEX,
+		GFP_KERNEL);
+	if (!reply) {
+		ret = -ENOMEM;
+		goto out;
+	}
+
+	if (nla_put_u32(reply, GSCAN_RESULTS_REQUEST_ID,
+			priv->gscan_req_id))
+		goto out_put_fail;
+
+	cfg80211_vendor_event(reply, GFP_KERNEL);
+out:
+	return ret;
+out_put_fail:
+	kfree_skb(reply);
+	WARN_ON(1);
+	return -EMSGSIZE;
+}
+
+/*report scan done event to upper layer*/
+int sprdwl_gscan_done(struct sprdwl_vif *vif, u8 bucketid)
+{
+	struct sprdwl_priv *priv = vif->priv;
+	struct wiphy *wiphy = priv->wiphy;
+	struct sk_buff *reply;
+	int payload, rlen, ret = 0;
+	u8 event_type;
+
+	rlen = sizeof(enum nl80211_vendor_subcmds_index);
+	payload = rlen + 0x100;
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 4, 83)
+	reply = cfg80211_vendor_event_alloc(wiphy, &vif->wdev,
+#else
+	reply = cfg80211_vendor_event_alloc(wiphy,
+#endif
+					    payload,
+		NL80211_VENDOR_SUBCMD_GSCAN_SCAN_EVENT_INDEX,
+		GFP_KERNEL);
+	if (!reply) {
+		ret = -ENOMEM;
+		goto out;
+	}
+
+	if (nla_put_u32(reply, GSCAN_RESULTS_REQUEST_ID,
+			priv->gscan_req_id))
+		goto out_put_fail;
+
+	event_type = WIFI_SCAN_COMPLETE;
+	if (nla_put_u8(reply, GSCAN_RESULTS_SCAN_EVENT_TYPE,
+		       event_type))
+		goto out_put_fail;
+
+	cfg80211_vendor_event(reply, GFP_KERNEL);
+out:
+	return ret;
+out_put_fail:
+	kfree_skb(reply);
+	WARN_ON(1);
+	return -EMSGSIZE;
+}
+
+/*set_ssid_hotlist function---CMD ID:29*/
+static int sprdwl_vendor_set_bssid_hotlist(struct wiphy *wiphy,
+					   struct wireless_dev *wdev,
+				     const void *data, int len)
+{
+	int i, ret = 0, tlen;
+	int type;
+	int rem_len, rem_outer_len, rem_inner_len;
+	struct nlattr *pos, *outer_iter, *inner_iter;
+	struct wifi_bssid_hotlist_params *bssid_hotlist_params;
+	struct sprdwl_cmd_gscan_rsp_header rsp;
+	struct sprdwl_vif *vif = netdev_priv(wdev->netdev);
+	u16 rlen = sizeof(struct sprdwl_cmd_gscan_rsp_header);
+
+	bssid_hotlist_params =
+		kmalloc(sizeof(*bssid_hotlist_params), GFP_KERNEL);
+
+	if (!bssid_hotlist_params)
+		return -ENOMEM;
+
+	vif->priv->hotlist_res =
+			kmalloc(sizeof(struct sprdwl_gscan_hotlist_results),
+				GFP_KERNEL);
+
+	if (!vif->priv->hotlist_res) {
+		ret = -ENOMEM;
+		goto out;
+	}
+
+	memset(vif->priv->hotlist_res, 0x0,
+	       sizeof(struct sprdwl_gscan_hotlist_results));
+
+	nla_for_each_attr(pos, (void *)data, len, rem_len) {
+			type = nla_type(pos);
+
+		switch (type) {
+		case GSCAN_ATTR_SUBCMD_CONFIG_PARAM_REQUEST_ID:
+			vif->priv->hotlist_res->req_id = nla_get_s32(pos);
+		break;
+
+		case GSCAN_ATTR_BSSID_HOTLIST_PARAMS_LOST_AP_SAMPLE_SIZE:
+			bssid_hotlist_params->lost_ap_sample_size
+				= nla_get_s32(pos);
+		break;
+
+		case GSCAN_ATTR_BSSID_HOTLIST_PARAMS_NUM_AP:
+			bssid_hotlist_params->num_bssid = nla_get_s32(pos);
+		break;
+
+		case GSCAN_ATTR_AP_THR_PARAM:
+			i = 0;
+			nla_for_each_nested(outer_iter, pos, rem_outer_len) {
+				nla_for_each_nested(inner_iter, outer_iter,
+				rem_inner_len) {
+					type = nla_type(inner_iter);
+					switch (type) {
+					case GSCAN_ATTR_AP_THR_PARAM_BSSID:
+					    memcpy(
+					    bssid_hotlist_params->ap[i].bssid,
+					    nla_data(inner_iter),
+					    6 * sizeof(unsigned char));
+					break;
+
+					case GSCAN_ATTR_AP_THR_PARAM_RSSI_LOW:
+					    bssid_hotlist_params->ap[i].low
+						= nla_get_s32(inner_iter);
+					break;
+
+					case GSCAN_ATTR_AP_THR_PARAM_RSSI_HIGH:
+					    bssid_hotlist_params->ap[i].high
+						= nla_get_s32(inner_iter);
+					break;
+					default:
+					wl_ndev_log(L_ERR, vif->ndev,
+						"networks nla type 0x%x not support\n",
+						type);
+						ret = -EINVAL;
+					break;
+					}
+				}
+
+				if (ret < 0)
+					break;
+
+				i++;
+				if (i >= MAX_HOTLIST_APS)
+					break;
+			}
+		break;
+
+		default:
+			wl_ndev_log(L_ERR, vif->ndev, "nla type 0x%x not support\n",
+			type);
+			ret = -EINVAL;
+		break;
+		}
+
+		if (ret < 0)
+			break;
+		}
+
+	wl_ndev_log(L_INFO, vif->ndev, "parse bssid hotlist %s\n",
+		    !ret ? "success" : "failture");
+
+	tlen = sizeof(struct wifi_bssid_hotlist_params);
+
+	if (!ret)
+		ret = sprdwl_gscan_subcmd(vif->priv, vif->ctx_id,
+					  (void *)bssid_hotlist_params,
+				SPRDWL_GSCAN_SUBCMD_SET_HOTLIST,
+				tlen, (u8 *)(&rsp), &rlen);
+
+	if (ret < 0)
+		kfree(vif->priv->hotlist_res);
+
+out:
+	kfree(bssid_hotlist_params);
+	return ret;
+}
+
+/*reset_bssid_hotlist function---CMD ID:30*/
+static int sprdwl_vendor_reset_bssid_hotlist(struct wiphy *wiphy,
+					  struct wireless_dev *wdev,
+				     const void *data, int len)
+{
+	int flush = 1;
+	struct sprdwl_vif *vif = netdev_priv(wdev->netdev);
+	struct sprdwl_cmd_gscan_rsp_header rsp;
+	u16 rlen = sizeof(struct sprdwl_cmd_gscan_rsp_header);
+
+	wl_ndev_log(L_INFO, vif->ndev, "%s %d\n", __func__, flush);
+
+	memset(vif->priv->hotlist_res, 0x0,
+		sizeof(struct sprdwl_gscan_hotlist_results));
+
+	return sprdwl_gscan_subcmd(vif->priv, vif->ctx_id,
+					(void *)(&flush),
+					SPRDWL_GSCAN_SUBCMD_RESET_HOTLIST,
+					sizeof(int), (u8 *)(&rsp), &rlen);
+}
+
+/*set_significant_change function---CMD ID:32*/
+static int sprdwl_vendor_set_significant_change(struct wiphy *wiphy,
+						struct wireless_dev *wdev,
+				     const void *data, int len)
+{
+	int i, ret = 0, tlen;
+	int type;
+	int rem_len, rem_outer_len, rem_inner_len;
+	struct nlattr *pos, *outer_iter, *inner_iter;
+	struct wifi_significant_change_params *significant_change_params;
+	struct sprdwl_cmd_gscan_rsp_header rsp;
+	struct sprdwl_vif *vif = netdev_priv(wdev->netdev);
+	u16 rlen = sizeof(struct sprdwl_cmd_gscan_rsp_header);
+
+	significant_change_params =
+		kmalloc(sizeof(*significant_change_params), GFP_KERNEL);
+
+	if (!significant_change_params)
+		return -ENOMEM;
+
+	vif->priv->significant_res =
+			kmalloc(sizeof(struct sprdwl_significant_change_result),
+				GFP_KERNEL);
+
+	if (!vif->priv->significant_res) {
+		ret = -ENOMEM;
+		goto out;
+	}
+
+	memset(vif->priv->significant_res, 0x0,
+	       sizeof(struct sprdwl_significant_change_result));
+
+
+	nla_for_each_attr(pos, (void *)data, len, rem_len) {
+		type = nla_type(pos);
+		switch (type) {
+		case GSCAN_ATTR_SUBCMD_CONFIG_PARAM_REQUEST_ID:
+			vif->priv->significant_res->req_id = nla_get_s32(pos);
+		break;
+
+		case GSCAN_ATTR_SIGNIFICANT_CHANGE_PARAMS_RSSI_SAMPLE_SIZE:
+			significant_change_params->rssi_sample_size
+				= nla_get_s32(pos);
+		break;
+
+		case GSCAN_ATTR_SIGNIFICANT_CHANGE_PARAMS_LOST_AP_SAMPLE_SIZE:
+			significant_change_params->lost_ap_sample_size
+				= nla_get_s32(pos);
+		break;
+
+		case GSCAN_ATTR_SIGNIFICANT_CHANGE_PARAMS_MIN_BREACHING:
+			significant_change_params->min_breaching
+				= nla_get_s32(pos);
+		break;
+
+		case GSCAN_ATTR_SIGNIFICANT_CHANGE_PARAMS_NUM_AP:
+			significant_change_params->num_bssid
+				= nla_get_s32(pos);
+		break;
+
+		case GSCAN_ATTR_AP_THR_PARAM:
+		i = 0;
+		nla_for_each_nested(outer_iter, pos, rem_outer_len) {
+			nla_for_each_nested(inner_iter, outer_iter,
+				rem_inner_len) {
+				type = nla_type(inner_iter);
+				switch (type) {
+				case GSCAN_ATTR_AP_THR_PARAM_BSSID:
+					memcpy(
+					significant_change_params->ap[i].bssid,
+					nla_data(inner_iter),
+					6 * sizeof(unsigned char));
+				break;
+
+				case GSCAN_ATTR_AP_THR_PARAM_RSSI_LOW:
+					significant_change_params->ap[i].low
+						= nla_get_s32(inner_iter);
+				break;
+
+				case GSCAN_ATTR_AP_THR_PARAM_RSSI_HIGH:
+					significant_change_params->ap[i].high
+						= nla_get_s32(inner_iter);
+				break;
+				default:
+					wl_ndev_log(L_ERR, vif->ndev,
+					"networks nla type 0x%x not support\n",
+					type);
+					ret = -EINVAL;
+				break;
+				}
+			}
+
+			if (ret < 0)
+				break;
+
+			i++;
+			if (i >= MAX_SIGNIFICANT_CHANGE_APS)
+				break;
+		}
+		break;
+
+		default:
+		wl_ndev_log(L_ERR, vif->ndev, "nla type 0x%x not support\n",
+		type);
+		ret = -EINVAL;
+		break;
+		}
+
+		if (ret < 0)
+			break;
+	}
+
+	tlen = sizeof(struct wifi_significant_change_params);
+	ret = sprdwl_gscan_subcmd(vif->priv, vif->ctx_id,
+				  (void *)significant_change_params,
+			SPRDWL_GSCAN_SUBCMD_SET_SIGNIFICANT_CHANGE_CONFIG,
+			tlen, (u8 *)(&rsp), &rlen);
+
+	if (ret < 0)
+		kfree(vif->priv->significant_res);
+
+out:
+	kfree(significant_change_params);
+	return ret;
+}
+
+/*set_significant_change function---CMD ID:33*/
+static int sprdwl_vendor_reset_significant_change(struct wiphy *wiphy,
+					  struct wireless_dev *wdev,
+				     const void *data, int len)
+{
+	int flush = 1;
+	struct sprdwl_vif *vif = netdev_priv(wdev->netdev);
+	struct sprdwl_cmd_gscan_rsp_header rsp;
+	u16 rlen = sizeof(struct sprdwl_cmd_gscan_rsp_header);
+
+	wl_ndev_log(L_INFO, vif->ndev, "%s %d\n", __func__, flush);
+
+	if (vif->priv->significant_res) {
+		memset(vif->priv->significant_res, 0x0,
+			sizeof(struct sprdwl_significant_change_result));
+	}
+
+	return sprdwl_gscan_subcmd(vif->priv, vif->ctx_id,
+		(void *)(&flush),
+		SPRDWL_GSCAN_SUBCMD_RESET_SIGNIFICANT_CHANGE_CONFIG,
+		sizeof(int),
+		(u8 *)(&rsp),
+		&rlen);
+}
+
+/*get support feature function---CMD ID:38*/
+static int sprdwl_vendor_get_support_feature(struct wiphy *wiphy,
+					     struct wireless_dev *wdev,
+						const void *data, int len)
+{
+	int ret;
+	struct sk_buff *reply;
+	uint32_t feature = 0, payload;
+	struct sprdwl_priv *priv = wiphy_priv(wiphy);
+
+	wiphy_info(wiphy, "%s\n", __func__);
+	payload = sizeof(feature);
+	reply = cfg80211_vendor_cmd_alloc_reply_skb(wiphy, payload);
+
+	if (!reply)
+		return -ENOMEM;
+	/*bit 1:Basic infrastructure mode*/
+	if (wiphy->interface_modes & BIT(NL80211_IFTYPE_STATION)) {
+		wl_info("STA mode is supported\n");
+		feature |= WIFI_FEATURE_INFRA;
+	}
+	/*bit 2:Support for 5 GHz Band*/
+	if (priv->fw_capa & SPRDWL_CAPA_5G) {
+		wl_info("INFRA 5G is supported\n");
+		feature |= WIFI_FEATURE_INFRA_5G;
+	}
+	/*bit3:HOTSPOT is a supplicant feature, enable it by default*/
+		wl_info("HotSpot feature is supported\n");
+		feature |= WIFI_FEATURE_HOTSPOT;
+	/*bit 4:P2P*/
+	if ((wiphy->interface_modes & BIT(NL80211_IFTYPE_P2P_CLIENT)) &&
+	    (wiphy->interface_modes & BIT(NL80211_IFTYPE_P2P_GO))) {
+		wl_info("P2P is supported\n");
+		feature |= WIFI_FEATURE_P2P;
+	}
+	/*bit 5:soft AP feature supported*/
+	if (wiphy->interface_modes & BIT(NL80211_IFTYPE_AP)) {
+		wl_info("Soft AP is supported\n");
+		feature |= WIFI_FEATURE_SOFT_AP;
+	}
+	/*bit 6:GSCAN feature supported*/
+	if (priv->fw_capa & SPRDWL_CAPA_GSCAN) {
+		wl_info("GSCAN feature supported\n");
+		feature |= WIFI_FEATURE_GSCAN;
+	}
+	/*bit 7:NAN feature supported*/
+	if (priv->fw_capa & SPRDWL_CAPA_NAN) {
+		wl_info("NAN is supported\n");
+		feature |= WIFI_FEATURE_NAN;
+	}
+	/*bit 8: Device-to-device RTT */
+	if (priv->fw_capa & SPRDWL_CAPA_D2D_RTT) {
+		wl_info("D2D RTT supported\n");
+		feature |= WIFI_FEATURE_D2D_RTT;
+	}
+	/*bit 9: Device-to-AP RTT*/
+	if (priv->fw_capa &  SPRDWL_CAPA_D2AP_RTT) {
+		wl_info("Device-to-AP RTT supported\n");
+		feature |= WIFI_FEATURE_D2AP_RTT;
+	}
+	/*bit 10: Batched Scan (legacy)*/
+	if (priv->fw_capa & SPRDWL_CAPA_BATCH_SCAN) {
+		wl_info("Batched Scan supported\n");
+		feature |= WIFI_FEATURE_BATCH_SCAN;
+	}
+	/*bit 11: PNO feature supported*/
+	if (priv->fw_capa & SPRDWL_CAPA_PNO) {
+		wl_info("PNO feature supported\n");
+		feature |= WIFI_FEATURE_PNO;
+	}
+	/*bit 12:Support for two STAs*/
+	if (priv->fw_capa & SPRDWL_CAPA_ADDITIONAL_STA) {
+		wl_info("Two sta feature supported\n");
+		feature |= WIFI_FEATURE_ADDITIONAL_STA;
+	}
+	/*bit 13:Tunnel directed link setup */
+	if (priv->fw_capa & SPRDWL_CAPA_TDLS) {
+		wl_info("TDLS feature supported\n");
+		feature |= WIFI_FEATURE_TDLS;
+	}
+	/*bit 14:Support for TDLS off channel*/
+	if (priv->fw_capa & SPRDWL_CAPA_TDLS_OFFCHANNEL) {
+		wl_info("TDLS off channel supported\n");
+		feature |= WIFI_FEATURE_TDLS_OFFCHANNEL;
+	}
+	/*bit 15:Enhanced power reporting*/
+	if (priv->fw_capa & SPRDWL_CAPA_EPR) {
+		wl_info("Enhanced power report supported\n");
+		feature |= WIFI_FEATURE_EPR;
+	}
+	/*bit 16:Support for AP STA Concurrency*/
+	if (priv->fw_capa & SPRDWL_CAPA_AP_STA) {
+		wl_info("AP STA Concurrency supported\n");
+		feature |= WIFI_FEATURE_AP_STA;
+	}
+	/*bit 17:Link layer stats collection*/
+	if (priv->fw_capa & SPRDWL_CAPA_LL_STATS) {
+		wl_info("LinkLayer status supported\n");
+		feature |= WIFI_FEATURE_LINK_LAYER_STATS;
+	}
+	/*bit 18:WiFi Logger*/
+	if (priv->fw_capa & SPRDWL_CAPA_WIFI_LOGGER) {
+		wl_info("WiFi Logger supported\n");
+		feature |= WIFI_FEATURE_LOGGER;
+	}
+	/*bit 19:WiFi PNO enhanced*/
+	if (priv->fw_capa & SPRDWL_CAPA_EPNO) {
+		wl_info("WIFI ENPO supported\n");
+		feature |= WIFI_FEATURE_HAL_EPNO;
+	}
+	/*bit 20:RSSI monitor supported*/
+	if (priv->fw_capa & SPRDWL_CAPA_RSSI_MONITOR) {
+		wl_info("RSSI Monitor supported\n");
+		feature |= WIFI_FEATURE_RSSI_MONITOR;
+	}
+	/*bit 21:WiFi mkeep_alive*/
+	if (priv->fw_capa & SPRDWL_CAPA_MKEEP_ALIVE) {
+		wl_info("WiFi mkeep alive supported\n");
+		feature |= WIFI_FEATURE_MKEEP_ALIVE;
+	}
+	/*bit 22:ND offload configure*/
+	if (priv->fw_capa & SPRDWL_CAPA_CONFIG_NDO) {
+		wl_info("ND offload supported\n");
+		feature |= WIFI_FEATURE_CONFIG_NDO;
+	}
+	/*bit 23:Capture Tx transmit power levels*/
+	if (priv->fw_capa & SPRDWL_CAPA_TX_POWER) {
+		wl_info("Tx power supported\n");
+		feature |= WIFI_FEATURE_TX_TRANSMIT_POWER;
+	}
+	/*bit 24:Enable/Disable firmware roaming*/
+	if (priv->fw_capa & SPRDWL_CAPA_11R_ROAM_OFFLOAD) {
+		wl_info("ROAMING offload supported\n");
+		feature |= WIFI_FEATURE_CONTROL_ROAMING;
+	}
+	/*bit 25:Support Probe IE white listing*/
+	if (priv->fw_capa & SPRDWL_CAPA_IE_WHITELIST) {
+		wl_info("Probe IE white listing supported\n");
+		feature |= WIFI_FEATURE_IE_WHITELIST;
+	}
+	/*bit 26: Support MAC & Probe Sequence Number randomization*/
+	if (priv->fw_capa & SPRDWL_CAPA_SCAN_RAND) {
+		wl_info("RAND MAC SCAN supported\n");
+		feature |= WIFI_FEATURE_SCAN_RAND;
+	}
+
+	wl_info("Supported Feature:0x%x\n", feature);
+
+	if (nla_put_u32(reply, SPRDWL_VENDOR_ATTR_FEATURE_SET, feature)) {
+		wiphy_err(wiphy, "%s put u32 error\n", __func__);
+		goto out_put_fail;
+	}
+
+	ret = cfg80211_vendor_cmd_reply(reply);
+	if (ret)
+		wiphy_err(wiphy, "%s reply cmd error\n", __func__);
+	return ret;
+
+out_put_fail:
+	kfree_skb(reply);
+	return -EMSGSIZE;
+}
+
+/*set_mac_oui functon------ CMD ID:39*/
+static int sprdwl_vendor_set_mac_oui(struct wiphy *wiphy,
+					      struct wireless_dev *wdev,
+				     const void *data, int len)
+{
+	struct nlattr *pos;
+	struct sprdwl_vif *vif = netdev_priv(wdev->netdev);
+	struct v_MACADDR_t *rand_mac;
+	int tlen = 0, ret = 0, rem_len, type;
+	struct sprdwl_cmd_gscan_rsp_header rsp;
+	u16 rlen = sizeof(struct sprdwl_cmd_gscan_rsp_header);
+
+	wiphy_info(wiphy, "%s\n", __func__);
+
+	rand_mac = kmalloc(sizeof(*rand_mac), GFP_KERNEL);
+	if (!rand_mac)
+		return -ENOMEM;
+
+	nla_for_each_attr(pos, (void *)data, len, rem_len) {
+		type = nla_type(pos);
+		switch (type) {
+		case WLAN_VENDOR_ATTR_SET_SCANNING_MAC_OUI:
+			memcpy(rand_mac, nla_data(pos), 3);
+		break;
+
+		default:
+			wl_ndev_log(L_ERR, vif->ndev, "nla type 0x%x not support\n",
+				   type);
+			ret = -EINVAL;
+			goto out;
+		break;
+	    }
+	}
+
+	tlen = sizeof(struct v_MACADDR_t);
+	ret = sprdwl_gscan_subcmd(vif->priv, vif->ctx_id,
+				  (void *)rand_mac,
+				SPRDWL_WIFI_SUBCMD_SET_PNO_RANDOM_MAC_OUI,
+				tlen, (u8 *)(&rsp), &rlen);
+
+out:
+	kfree(rand_mac);
+	return ret;
+}
+
+/**
+ * get concurrency matrix function---CMD ID:42
+ * sprdwl_vendor_get_concurrency_matrix() - to retrieve concurrency matrix
+ * @wiphy: pointer phy adapter
+ * @wdev: pointer to wireless device structure
+ * @data: pointer to data buffer
+ * @data: length of data
+ *
+ * This routine will give concurrency matrix
+ *
+ * Return: int status code
+ */
+
+static int sprdwl_vendor_get_concurrency_matrix(struct wiphy *wiphy,
+						struct wireless_dev *wdev,
+						const void *data, int len)
+{
+	uint32_t feature_set_matrix[CDS_MAX_FEATURE_SET] = {0};
+	uint8_t i, feature_sets, max_feature_sets;
+	struct nlattr *tb[SPRDWL_ATTR_CO_MATRIX_MAX + 1];
+	struct sk_buff *reply_skb;
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 14, 0)
+	if (nla_parse(tb, SPRDWL_ATTR_CO_MATRIX_MAX,
+		      data, len, NULL, NULL)) {
+#else
+	if (nla_parse(tb, SPRDWL_ATTR_CO_MATRIX_MAX,
+			data, len, NULL)) {
+#endif
+		wl_err("Invalid ATTR\n");
+		return -EINVAL;
+	}
+
+	/* Parse and fetch max feature set */
+	if (!tb[SPRDWL_ATTR_CO_MATRIX_CONFIG_PARAM_SET_SIZE_MAX]) {
+		wl_err("Attr max feature set size failed\n");
+		return -EINVAL;
+	}
+	max_feature_sets = nla_get_u32(
+			tb[SPRDWL_ATTR_CO_MATRIX_CONFIG_PARAM_SET_SIZE_MAX]);
+
+	wl_info("Max feature set size (%d)", max_feature_sets);
+
+	/*Fill feature combination matrix*/
+	feature_sets = 0;
+	feature_set_matrix[feature_sets++] =
+		WIFI_FEATURE_INFRA | WIFI_FEATURE_P2P;
+	feature_set_matrix[feature_sets++] =
+		WIFI_FEATURE_INFRA_5G | WIFI_FEATURE_P2P;
+	feature_set_matrix[feature_sets++] =
+		WIFI_FEATURE_INFRA | WIFI_FEATURE_GSCAN;
+	feature_set_matrix[feature_sets++] =
+		WIFI_FEATURE_INFRA_5G | WIFI_FEATURE_GSCAN;
+
+	feature_sets = min(feature_sets, max_feature_sets);
+	wl_info("Number of feature sets (%d)\n", feature_sets);
+
+	wl_info("Feature set matrix:");
+	for (i = 0; i < feature_sets; i++)
+		wl_info("[%d] 0x%02X", i, feature_set_matrix[i]);
+
+	reply_skb = cfg80211_vendor_cmd_alloc_reply_skb(wiphy, sizeof(u32) +
+			sizeof(u32) * feature_sets);
+
+	if (reply_skb) {
+		if (nla_put_u32(reply_skb,
+				SPRDWL_ATTR_CO_MATRIX_RESULTS_SET_SIZE,
+					feature_sets) ||
+			nla_put(reply_skb,
+				SPRDWL_ATTR_CO_MATRIX_RESULTS_SET,
+				sizeof(u32) * feature_sets,
+				feature_set_matrix)) {
+			wl_err("nla put failure\n");
+			kfree_skb(reply_skb);
+			return -EINVAL;
+		}
+		return cfg80211_vendor_cmd_reply(reply_skb);
+	}
+	wl_err("set matrix: buffer alloc failure\n");
+	return -ENOMEM;
+}
+
+
+/*get support feature function---CMD ID:55*/
+static int sprdwl_vendor_get_feature(struct wiphy *wiphy,
+				     struct wireless_dev *wdev,
+				     const void *data, int len)
+{
+	return 0;
+}
+
+/*get wake up reason statistic*/
+static int sprdwl_vendor_get_wake_state(struct wiphy *wiphy,
+					struct wireless_dev *wdev,
+					const void *data, int len)
+{
+	struct sk_buff *skb;
+	uint32_t buf_len;
+	struct sprdwl_priv *priv = wiphy_priv(wiphy);
+	struct wakeup_trace *wake_cnt;
+	uint32_t rx_multi_cnt, ipv4_mc_cnt, ipv6_mc_cnt;
+	uint32_t other_mc_cnt;
+
+	wiphy_info(wiphy, "%s\n", __func__);
+	wake_cnt = &priv->wakeup_tracer;
+	buf_len = NLMSG_HDRLEN;
+	buf_len += WLAN_GET_WAKE_STATS_MAX *
+		     (NLMSG_HDRLEN + sizeof(uint32_t));
+	skb = cfg80211_vendor_cmd_alloc_reply_skb(wiphy, buf_len);
+
+	if (!skb) {
+				wl_err("cfg80211_vendor_cmd_alloc_reply_skb failed\n");
+			    return -ENOMEM;
+	}
+
+	ipv4_mc_cnt = wake_cnt->rx_data_dtl.rx_mc_dtl.ipv4_mc_cnt;
+	ipv6_mc_cnt = wake_cnt->rx_data_dtl.rx_mc_dtl.ipv6_mc_cnt;
+	other_mc_cnt = wake_cnt->rx_data_dtl.rx_mc_dtl.other_mc_cnt;
+
+	/*rx multicast count contain IPV4,IPV6 and other mc pkt */
+	rx_multi_cnt = ipv4_mc_cnt + ipv6_mc_cnt + other_mc_cnt;
+
+	wl_info("total_cmd_event_wake:%d\n", wake_cnt->total_cmd_event_wake);
+	wl_info("total_local_wake:%d\n", wake_cnt->total_local_wake);
+	wl_info("total_rx_data_wake:%d\n", wake_cnt->total_rx_data_wake);
+	wl_info("rx_unicast_cnt:%d\n", wake_cnt->rx_data_dtl.rx_unicast_cnt);
+	wl_info("rx_multi_cnt:%d\n", rx_multi_cnt);
+	wl_info("rx_brdcst_cnt:%d\n", wake_cnt->rx_data_dtl.rx_brdcst_cnt);
+	wl_info("icmp_pkt_cnt:%d\n", wake_cnt->pkt_type_dtl.icmp_pkt_cnt);
+	wl_info("icmp6_pkt_cnt:%d\n", wake_cnt->pkt_type_dtl.icmp6_pkt_cnt);
+	wl_info("icmp6_ra_cnt:%d\n", wake_cnt->pkt_type_dtl.icmp6_ra_cnt);
+	wl_info("icmp6_na_cnt:%d\n", wake_cnt->pkt_type_dtl.icmp6_na_cnt);
+	wl_info("icmp6_ns_cnt:%d\n", wake_cnt->pkt_type_dtl.icmp6_ns_cnt);
+	wl_info("ipv4_mc_cnt:%d\n", ipv4_mc_cnt);
+	wl_info("ipv6_mc_cnt:%d\n", ipv6_mc_cnt);
+	wl_info("other_mc_cnt:%d\n", other_mc_cnt);
+
+	if (nla_put_u32(skb, WLAN_ATTR_TOTAL_CMD_EVENT_WAKE,
+					wake_cnt->total_cmd_event_wake) ||
+		nla_put_u32(skb, WLAN_ATTR_CMD_EVENT_WAKE_CNT_PTR, 0) ||
+		nla_put_u32(skb, WLAN_ATTR_CMD_EVENT_WAKE_CNT_SZ, 0) ||
+		nla_put_u32(skb, WLAN_ATTR_TOTAL_DRIVER_FW_LOCAL_WAKE,
+					wake_cnt->total_local_wake) ||
+		nla_put_u32(skb, WLAN_ATTR_DRIVER_FW_LOCAL_WAKE_CNT_PTR, 0) ||
+		nla_put_u32(skb, WLAN_ATTR_DRIVER_FW_LOCAL_WAKE_CNT_SZ, 0) ||
+		nla_put_u32(skb, WLAN_ATTR_TOTAL_RX_DATA_WAKE,
+					wake_cnt->total_rx_data_wake) ||
+		nla_put_u32(skb, WLAN_ATTR_RX_UNICAST_CNT,
+					wake_cnt->rx_data_dtl.rx_unicast_cnt) ||
+		nla_put_u32(skb, WLAN_ATTR_RX_MULTICAST_CNT,
+					rx_multi_cnt) ||
+		nla_put_u32(skb, WLAN_ATTR_RX_BROADCAST_CNT,
+					wake_cnt->rx_data_dtl.rx_brdcst_cnt) ||
+		nla_put_u32(skb, WLAN_ATTR_ICMP_PKT,
+					wake_cnt->pkt_type_dtl.icmp_pkt_cnt) ||
+		nla_put_u32(skb, WLAN_ATTR_ICMP6_PKT,
+					wake_cnt->pkt_type_dtl.icmp6_pkt_cnt) ||
+		nla_put_u32(skb, WLAN_ATTR_ICMP6_RA,
+					wake_cnt->pkt_type_dtl.icmp6_ra_cnt) ||
+		nla_put_u32(skb, WLAN_ATTR_ICMP6_NA,
+					wake_cnt->pkt_type_dtl.icmp6_na_cnt) ||
+		nla_put_u32(skb, WLAN_ATTR_ICMP6_NS,
+					wake_cnt->pkt_type_dtl.icmp6_ns_cnt) ||
+		nla_put_u32(skb, WLAN_ATTR_ICMP4_RX_MULTICAST_CNT,
+					ipv4_mc_cnt) ||
+		nla_put_u32(skb, WLAN_ATTR_ICMP6_RX_MULTICAST_CNT,
+					ipv6_mc_cnt) ||
+		nla_put_u32(skb, WLAN_ATTR_OTHER_RX_MULTICAST_CNT,
+					other_mc_cnt)) {
+		wl_err("nla put failure\n");
+		goto nla_put_failure;
+	}
+	cfg80211_vendor_cmd_reply(skb);
+
+	return WIFI_SUCCESS;
+
+nla_put_failure:
+	kfree_skb(skb);
+	return -EINVAL;
+}
+
+static int sprdwl_vendor_enable_nd_offload(struct wiphy *wiphy,
+					   struct wireless_dev *wdev,
+					   const void *data, int len)
+{
+	wiphy_info(wiphy, "%s\n", __func__);
+
+	return WIFI_SUCCESS;
+}
+
+static int sprdwl_vendor_start_logging(struct wiphy *wiphy,
+				       struct wireless_dev *wdev,
+				       const void *data, int len)
+{
+	wiphy_info(wiphy, "%s\n", __func__);
+
+	return WIFI_SUCCESS;
+}
+
+static int sprdwl_vendor_get_ring_data(struct wiphy *wiphy,
+				       struct wireless_dev *wdev,
+				       const void *data, int len)
+{
+	wiphy_info(wiphy, "%s\n", __func__);
+
+	return WIFI_SUCCESS;
+}
+
+static int sprdwl_vendor_memory_dump(struct wiphy *wiphy,
+				     struct wireless_dev *wdev,
+				     const void *data, int len)
+{
+	wiphy_info(wiphy, "%s\n", __func__);
+
+	return -EOPNOTSUPP;
+}
+
+/*CMD ID:61*/
+static const struct nla_policy sprdwl_get_wifi_info_policy[
+		SPRDWL_ATTR_WIFI_INFO_GET_MAX + 1] = {
+		[SPRDWL_ATTR_WIFI_INFO_DRIVER_VERSION] = {.type = NLA_U8},
+		[SPRDWL_ATTR_WIFI_INFO_FIRMWARE_VERSION] = {.type = NLA_U8},
+};
+
+static int sprdwl_vendor_get_driver_info(struct wiphy *wiphy,
+					 struct wireless_dev *wdev,
+					 const void *data, int len)
+{
+	int ret, payload = 0;
+	struct sk_buff *reply;
+	uint8_t attr;
+	struct sprdwl_priv *priv = wiphy_priv(wiphy);
+	struct nlattr *tb_vendor[SPRDWL_ATTR_WIFI_INFO_GET_MAX + 1];
+	char version[32];
+
+	wl_info("%s enter\n", __func__);
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 14, 0)
+	if (nla_parse(tb_vendor, SPRDWL_ATTR_WIFI_INFO_GET_MAX, data,
+		      len, sprdwl_get_wifi_info_policy, NULL)) {
+#else
+	if (nla_parse(tb_vendor, SPRDWL_ATTR_WIFI_INFO_GET_MAX, data,
+			len, sprdwl_get_wifi_info_policy)) {
+#endif
+		wl_err("WIFI_INFO_GET CMD parsing failed\n");
+		return -EINVAL;
+	}
+
+	if (tb_vendor[SPRDWL_ATTR_WIFI_INFO_DRIVER_VERSION]) {
+		wl_info("Recived req for Drv version\n");
+		memcpy(version, &priv->wl_ver, sizeof(version));
+		attr = SPRDWL_ATTR_WIFI_INFO_DRIVER_VERSION;
+		payload = sizeof(priv->wl_ver);
+	} else if (tb_vendor[SPRDWL_ATTR_WIFI_INFO_FIRMWARE_VERSION]) {
+		wl_info("Recived req for FW version\n");
+		snprintf(version, sizeof(version), "%d", priv->fw_ver);
+		wl_info("fw version:%s\n", version);
+		attr = SPRDWL_ATTR_WIFI_INFO_FIRMWARE_VERSION;
+		payload = strlen(version);
+	}
+
+	reply = cfg80211_vendor_cmd_alloc_reply_skb(wiphy, payload);
+
+	if (!reply)
+		return -ENOMEM;
+
+	if (nla_put(reply, SPRDWL_VENDOR_ATTR_WIFI_INFO_DRIVER_VERSION,
+		    payload, version)) {
+		wiphy_err(wiphy, "%s put version error\n", __func__);
+		goto out_put_fail;
+	}
+
+	ret = cfg80211_vendor_cmd_reply(reply);
+	if (ret)
+		wiphy_err(wiphy, "%s reply cmd error\n", __func__);
+	return ret;
+
+out_put_fail:
+	kfree_skb(reply);
+	return -EMSGSIZE;
+}
+
+/*Roaming function---CMD ID:64*/
+static int sprdwl_vendor_set_roam_params(struct wiphy *wiphy,
+					 struct wireless_dev *wdev,
+						const void *data, int len)
+{
+	uint32_t cmd_type, req_id;
+	struct roam_white_list_params white_params;
+	struct roam_black_list_params black_params;
+	struct nlattr *curr_attr;
+	struct nlattr *tb[SPRDWL_ROAM_MAX + 1];
+	struct nlattr *tb2[SPRDWL_ROAM_MAX + 1];
+	int rem, i;
+	int white_limit = 0, black_limit = 0;
+	int fw_max_whitelist = 0, fw_max_blacklist = 0;
+	uint32_t buf_len = 0;
+	struct sprdwl_vif *vif = container_of(wdev, struct sprdwl_vif, wdev);
+	struct sprdwl_priv *priv = wiphy_priv(wiphy);
+	int ret = 0;
+
+	memset(&white_params, 0, sizeof(white_params));
+	memset(&black_params, 0, sizeof(black_params));
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 14, 0)
+	if (nla_parse(tb, SPRDWL_ROAM_MAX, data, len, NULL, NULL)) {
+#else
+	if (nla_parse(tb, SPRDWL_ROAM_MAX, data, len, NULL)) {
+#endif
+		wl_err("Invalid ATTR\n");
+		return -EINVAL;
+	}
+	/* Parse and fetch Command Type*/
+	if (!tb[SPRDWL_ROAM_SUBCMD]) {
+		wl_err("roam cmd type failed\n");
+		goto fail;
+	}
+
+	cmd_type = nla_get_u32(tb[SPRDWL_ROAM_SUBCMD]);
+	if (!tb[SPRDWL_ROAM_REQ_ID]) {
+		wl_err("%s:attr request id failed\n", __func__);
+		goto fail;
+	}
+	req_id = nla_get_u32(tb[SPRDWL_ROAM_REQ_ID]);
+	wl_info("Req ID:%d, Cmd Type:%d", req_id, cmd_type);
+	switch (cmd_type) {
+	case SPRDWL_ATTR_ROAM_SUBCMD_SSID_WHITE_LIST:
+		if (!tb[SPRDWL_ROAM_WHITE_LIST_SSID_LIST])
+			break;
+	    i = 0;
+		nla_for_each_nested(curr_attr,
+				    tb[SPRDWL_ROAM_WHITE_LIST_SSID_LIST],
+					rem) {
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 14, 0)
+			if (nla_parse(tb2, SPRDWL_ATTR_ROAM_SUBCMD_MAX,
+				      nla_data(curr_attr),
+					nla_len(curr_attr),
+					NULL, NULL)) {
+#else
+			if (nla_parse(tb2, SPRDWL_ATTR_ROAM_SUBCMD_MAX,
+					nla_data(curr_attr),
+					nla_len(curr_attr),
+					NULL)) {
+#endif
+				wl_err("nla parse failed\n");
+				goto fail;
+			}
+			/* Parse and Fetch allowed SSID list*/
+			if (!tb2[SPRDWL_ROAM_WHITE_LIST_SSID]) {
+				wl_err("attr allowed ssid failed\n");
+				goto fail;
+			}
+			buf_len = nla_len(tb2[SPRDWL_ROAM_WHITE_LIST_SSID]);
+			/* Upper Layers include a null termination character.
+			* Check for the actual permissible length of SSID and
+			* also ensure not to copy the NULL termination
+			* character to the driver buffer.
+			*/
+			fw_max_whitelist = priv->roam_capa.max_whitelist_size;
+			white_limit = min(fw_max_whitelist, MAX_WHITE_SSID);
+
+			if (buf_len && (i < white_limit) &&
+			    ((buf_len - 1) <= IEEE80211_MAX_SSID_LEN)) {
+				nla_memcpy(
+					white_params.white_list[i].ssid_str,
+					tb2[SPRDWL_ROAM_WHITE_LIST_SSID],
+					buf_len - 1);
+				white_params.white_list[i].length =
+					buf_len - 1;
+				wl_info("SSID[%d]:%.*s, length=%d\n", i,
+					white_params.white_list[i].length,
+					white_params.white_list[i].ssid_str,
+					white_params.white_list[i].length);
+				i++;
+			} else {
+				wl_err("Invalid buffer length\n");
+			}
+		}
+		white_params.num_white_ssid = i;
+		wl_info("Num of white list:%d", i);
+		/*send white list with roam params by roaming CMD*/
+		ret = sprdwl_set_roam_offload(priv, vif->ctx_id,
+					SPRDWL_ROAM_SET_WHITE_LIST,
+				(u8 *)&white_params,
+				(i * sizeof(struct ssid_t) + 1));
+		break;
+	case SPRDWL_ATTR_ROAM_SUBCMD_SET_BLACKLIST_BSSID:
+		/*Parse and fetch number of blacklist BSSID*/
+		if (!tb[SPRDWL_ROAM_SET_BSSID_PARAMS_NUM_BSSID]) {
+			wl_err("attr num of blacklist bssid failed\n");
+			goto fail;
+		}
+		black_params.num_black_bssid = nla_get_u32(
+			tb[SPRDWL_ROAM_SET_BSSID_PARAMS_NUM_BSSID]);
+		wl_info("Num of black BSSID:%d\n",
+			black_params.num_black_bssid);
+
+		if (!tb[SPRDWL_ROAM_SET_BSSID_PARAMS])
+			break;
+
+		fw_max_blacklist = priv->roam_capa.max_blacklist_size;
+		black_limit = min(fw_max_blacklist, MAX_BLACK_BSSID);
+
+		if (black_params.num_black_bssid > black_limit) {
+			wl_err("black size exceed the limit:%d\n", black_limit);
+			break;
+		}
+		i = 0;
+		nla_for_each_nested(curr_attr,
+				    tb[SPRDWL_ROAM_SET_BSSID_PARAMS], rem) {
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 14, 0)
+			if (nla_parse(tb2, SPRDWL_ROAM_MAX,
+				      nla_data(curr_attr), nla_len(curr_attr),
+					NULL, NULL)) {
+#else
+			if (nla_parse(tb2, SPRDWL_ROAM_MAX,
+					nla_data(curr_attr), nla_len(curr_attr),
+					NULL)) {
+#endif
+					wl_err("nla parse failed\n");
+					goto fail;
+			}
+		/* Parse and fetch MAC address */
+			if (!tb2[SPRDWL_ROAM_SET_BSSID_PARAMS_BSSID]) {
+				wl_err("attr blacklist addr failed\n");
+				goto fail;
+			}
+			nla_memcpy(black_params.black_list[i].MAC_addr,
+				   tb2[SPRDWL_ROAM_SET_BSSID_PARAMS_BSSID],
+					sizeof(struct bssid_t));
+			wl_info("black list mac addr:%pM\n",
+				black_params.black_list[i].MAC_addr);
+			i++;
+		}
+		black_params.num_black_bssid = i;
+		/*send black list with roam_params CMD*/
+		ret = sprdwl_set_roam_offload(priv, vif->ctx_id,
+					SPRDWL_ROAM_SET_BLACK_LIST,
+				(u8 *)&black_params,
+				(i * sizeof(struct bssid_t) + 1));
+		break;
+	default:
+		break;
+	}
+	return ret;
+fail:
+	return -EINVAL;
+}
+
+/*set_ssid_hotlist function---CMD ID:65*/
+static int sprdwl_vendor_set_ssid_hotlist(struct wiphy *wiphy,
+					  struct wireless_dev *wdev,
+				     const void *data, int len)
+{
+	int i, ret = 0, tlen;
+	int type, request_id;
+	int rem_len, rem_outer_len, rem_inner_len;
+	struct nlattr *pos, *outer_iter, *inner_iter;
+	struct wifi_ssid_hotlist_params *ssid_hotlist_params;
+	struct sprdwl_cmd_gscan_rsp_header rsp;
+	struct sprdwl_vif *vif = netdev_priv(wdev->netdev);
+	u16 rlen = sizeof(struct sprdwl_cmd_gscan_rsp_header);
+
+	ssid_hotlist_params =
+		kmalloc(sizeof(*ssid_hotlist_params), GFP_KERNEL);
+
+	if (!ssid_hotlist_params)
+		return -ENOMEM;
+
+	nla_for_each_attr(pos, (void *)data, len, rem_len) {
+		type = nla_type(pos);
+
+		switch (type) {
+		case GSCAN_ATTR_SUBCMD_CONFIG_PARAM_REQUEST_ID:
+			request_id = nla_get_s32(pos);
+		break;
+
+		case GSCAN_ATTR_GSCAN_SSID_HOTLIST_PARAMS_LOST_SSID_SAMPLE_SIZE:
+			ssid_hotlist_params->lost_ssid_sample_size
+				= nla_get_s32(pos);
+		break;
+
+		case GSCAN_ATTR_GSCAN_SSID_HOTLIST_PARAMS_NUM_SSID:
+			ssid_hotlist_params->num_ssid = nla_get_s32(pos);
+		break;
+
+		case GSCAN_ATTR_GSCAN_SSID_THR_PARAM:
+			i = 0;
+			nla_for_each_nested(outer_iter, pos, rem_outer_len) {
+				nla_for_each_nested(inner_iter, outer_iter,
+						rem_inner_len) {
+					type = nla_type(inner_iter);
+				switch (type) {
+				case GSCAN_ATTR_GSCAN_SSID_THR_PARAM_SSID:
+				memcpy(
+				ssid_hotlist_params->ssid[i].ssid,
+				nla_data(inner_iter),
+				IEEE80211_MAX_SSID_LEN * sizeof(unsigned char));
+				break;
+
+				case GSCAN_ATTR_GSCAN_SSID_THR_PARAM_RSSI_LOW:
+					ssid_hotlist_params->ssid[i].low
+						= nla_get_s32(inner_iter);
+				break;
+
+				case GSCAN_ATTR_GSCAN_SSID_THR_PARAM_RSSI_HIGH:
+					ssid_hotlist_params->ssid[i].high
+						= nla_get_s32(inner_iter);
+				break;
+				default:
+					wl_ndev_log(L_ERR, vif->ndev,
+						"networks nla type 0x%x not support\n",
+						type);
+						ret = -EINVAL;
+				break;
+				}
+			}
+
+			if (ret < 0)
+				break;
+
+			i++;
+			if (i >= MAX_HOTLIST_APS)
+				break;
+		}
+		break;
+
+		default:
+			wl_ndev_log(L_ERR, vif->ndev, "nla type 0x%x not support\n",
+			type);
+			ret = -EINVAL;
+		break;
+		}
+
+	if (ret < 0)
+		break;
+	}
+
+	wl_ndev_log(L_INFO, vif->ndev, "parse bssid hotlist %s\n",
+		    !ret ? "success" : "failture");
+
+	tlen = sizeof(struct wifi_ssid_hotlist_params);
+	ret = sprdwl_gscan_subcmd(vif->priv, vif->ctx_id,
+				  (void *)ssid_hotlist_params,
+			SPRDWL_GSCAN_SUBCMD_SET_SSID_HOTLIST,
+			tlen, (u8 *)(&rsp), &rlen);
+
+	kfree(ssid_hotlist_params);
+	return ret;
+}
+
+/*reset_ssid_hotlist function---CMD ID:66*/
+static int sprdwl_vendor_reset_ssid_hotlist(struct wiphy *wiphy,
+					  struct wireless_dev *wdev,
+				     const void *data, int len)
+{
+	int flush = 1;
+	struct sprdwl_vif *vif = netdev_priv(wdev->netdev);
+	struct sprdwl_cmd_gscan_rsp_header rsp;
+	u16 rlen = sizeof(struct sprdwl_cmd_gscan_rsp_header);
+
+	wl_ndev_log(L_INFO, vif->ndev, "%s %d\n", __func__, flush);
+
+	return sprdwl_gscan_subcmd(vif->priv, vif->ctx_id,
+					(void *)(&flush),
+					SPRDWL_GSCAN_SUBCMD_RESET_SSID_HOTLIST,
+					sizeof(int), (u8 *)(&rsp), &rlen);
+
+}
+
+/*set_passpoint_list functon------ CMD ID:70*/
+static int sprdwl_vendor_set_passpoint_list(struct wiphy *wiphy,
+					    struct wireless_dev *wdev,
+				     const void *data, int len)
+{
+	struct nlattr *tb[GSCAN_MAX + 1];
+	struct nlattr *tb2[GSCAN_MAX + 1];
+	struct nlattr *HS_list;
+	struct sprdwl_vif *vif = netdev_priv(wdev->netdev);
+	struct wifi_passpoint_network *HS_list_params;
+	int i = 0, rem, flush, ret = 0, tlen, hs_num;
+	struct sprdwl_cmd_gscan_rsp_header rsp;
+	u16 rlen = sizeof(struct sprdwl_cmd_gscan_rsp_header);
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 14, 0)
+	if (nla_parse(tb, GSCAN_MAX, data, len,
+		      wlan_gscan_config_policy, NULL)) {
+#else
+	if (nla_parse(tb, GSCAN_MAX, data, len,
+			wlan_gscan_config_policy)) {
+#endif
+		wl_ndev_log(L_INFO, vif->ndev,
+			    "%s :Fail to parse attribute\n",
+			__func__);
+		return -EINVAL;
+	}
+
+	HS_list_params = kmalloc(sizeof(*HS_list_params), GFP_KERNEL);
+	if (!HS_list_params)
+		return -ENOMEM;
+
+	/* Parse and fetch */
+	if (!tb[GSCAN_ANQPO_LIST_FLUSH]) {
+		wl_ndev_log(L_INFO, vif->ndev,
+			    "%s :Fail to parse GSCAN_ANQPO_LIST_FLUSH\n",
+			__func__);
+		ret = -EINVAL;
+		goto out;
+	}
+
+	flush = nla_get_u32(tb[GSCAN_ANQPO_LIST_FLUSH]);
+
+	/* Parse and fetch */
+	if (!tb[GSCAN_ANQPO_HS_LIST_SIZE]) {
+		if (flush == 1)	{
+			ret = sprdwl_gscan_subcmd(vif->priv, vif->ctx_id,
+						  (void *)(&flush),
+					SPRDWL_GSCAN_SUBCMD_RESET_ANQPO_CONFIG,
+					sizeof(int), (u8 *)(&rsp), &rlen);
+		} else{
+			ret = -EINVAL;
+		}
+		goto out;
+	}
+
+	hs_num = nla_get_u32(tb[GSCAN_ANQPO_HS_LIST_SIZE]);
+
+	nla_for_each_nested(HS_list,
+			    tb[GSCAN_ANQPO_HS_LIST], rem) {
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 14, 0)
+		if (nla_parse(tb2, GSCAN_MAX,
+			      nla_data(HS_list), nla_len(HS_list),
+					NULL, NULL)) {
+#else
+		if (nla_parse(tb2, GSCAN_MAX,
+				nla_data(HS_list), nla_len(HS_list),
+				NULL)) {
+#endif
+			wl_ndev_log(L_INFO, vif->ndev,
+				    "%s :Fail to parse tb2\n",
+				__func__);
+			ret = -EINVAL;
+			     goto out;
+		}
+
+		if (!tb2[GSCAN_ANQPO_HS_NETWORK_ID]) {
+			wl_ndev_log(L_INFO, vif->ndev,
+				    "%s :Fail to parse GSCAN_ATTR_ANQPO_HS_NETWORK_ID\n",
+				__func__);
+			ret = -EINVAL;
+			goto out;
+		}
+
+		HS_list_params->id =
+			nla_get_u32(tb[GSCAN_ANQPO_HS_NETWORK_ID]);
+
+		if (!tb2[GSCAN_ANQPO_HS_NAI_REALM]) {
+			wl_ndev_log(L_INFO, vif->ndev,
+				    "%s :Fail to parse GSCAN_ATTR_ANQPO_HS_NAI_REALM\n",
+				__func__);
+			ret = -EINVAL;
+			goto out;
+		}
+		memcpy(HS_list_params->realm, nla_data(
+			tb2[GSCAN_ANQPO_HS_NAI_REALM]),
+			256);
+
+		if (!tb2[GSCAN_ANQPO_HS_ROAM_CONSORTIUM_ID]) {
+			wl_ndev_log(L_INFO, vif->ndev,
+				    "%s :Fail to parse GSCAN_ATTR_ANQPO_HS_ROAM_CONSORTIUM_ID\n",
+				__func__);
+			ret = -EINVAL;
+			goto out;
+		}
+
+		memcpy(HS_list_params->roaming_ids, nla_data(
+			tb2[GSCAN_ANQPO_HS_ROAM_CONSORTIUM_ID]),
+			128);
+
+		if (!tb2[GSCAN_ANQPO_HS_PLMN]) {
+			wl_ndev_log(L_INFO, vif->ndev,
+				    "%s :Fail to parse GSCAN_ATTR_ANQPO_HS_PLMN\n",
+				__func__);
+			ret = -EINVAL;
+			goto out;
+		}
+
+		memcpy(HS_list_params->plmn, nla_data(
+			tb2[GSCAN_ANQPO_HS_PLMN]),
+			3);
+		i++;
+	}
+
+	tlen = sizeof(struct wifi_passpoint_network);
+	ret = sprdwl_gscan_subcmd(vif->priv, vif->ctx_id,
+				  (void *)HS_list_params,
+				  SPRDWL_GSCAN_SUBCMD_ANQPO_CONFIG,
+					tlen, (u8 *)(&rsp), &rlen);
+
+out:
+	kfree(HS_list_params);
+	return ret;
+}
+
+/*reset_passpoint_list functon------ CMD ID:71*/
+static int sprdwl_vendor_reset_passpoint_list(struct wiphy *wiphy,
+					  struct wireless_dev *wdev,
+				     const void *data, int len)
+{
+	int flush = 1;
+	struct sprdwl_vif *vif = netdev_priv(wdev->netdev);
+	struct sprdwl_cmd_gscan_rsp_header rsp;
+	u16 rlen = sizeof(struct sprdwl_cmd_gscan_rsp_header);
+
+	wl_ndev_log(L_INFO, vif->ndev, "%s %d\n", __func__, flush);
+
+	return sprdwl_gscan_subcmd(vif->priv, vif->ctx_id,
+					(void *)(&flush),
+					SPRDWL_GSCAN_SUBCMD_RESET_ANQPO_CONFIG,
+					sizeof(int), (u8 *)(&rsp), &rlen);
+}
+
+/*RSSI monitor function---CMD ID:80*/
+
+static int send_rssi_cmd(struct sprdwl_priv *priv, u8 vif_ctx_id,
+			 const void *buf, u8 len)
+{
+	struct sprdwl_msg_buf *msg;
+
+	msg = sprdwl_cmd_getbuf(priv, len, vif_ctx_id,
+				SPRDWL_HEAD_RSP, WIFI_CMD_RSSI_MONITOR);
+	if (!msg)
+		return -ENOMEM;
+	memcpy(msg->data, buf, len);
+	return sprdwl_cmd_send_recv(priv, msg, CMD_WAIT_TIMEOUT, 0, 0);
+}
+
+#define MONITOR_MAX      SPRDWL_ATTR_RSSI_MONITORING_MAX
+#define REQUEST_ID       SPRDWL_ATTR_RSSI_MONITORING_REQUEST_ID
+#define MONITOR_CONTROL  SPRDWL_ATTR_RSSI_MONITORING_CONTROL
+#define MIN_RSSI         SPRDWL_ATTR_RSSI_MONITORING_MIN_RSSI
+#define MAX_RSSI         SPRDWL_ATTR_RSSI_MONITORING_MAX_RSSI
+static int sprdwl_vendor_monitor_rssi(struct wiphy *wiphy,
+				      struct wireless_dev *wdev,
+		const void *data, int len)
+{
+	struct nlattr *tb[MONITOR_MAX + 1];
+	uint32_t control;
+	struct rssi_monitor_req req;
+	static const struct nla_policy policy[MONITOR_MAX + 1] = {
+		[REQUEST_ID] = { .type = NLA_U32 },
+		[MONITOR_CONTROL] = { .type = NLA_U32 },
+		[MIN_RSSI] = { .type = NLA_S8 },
+		[MAX_RSSI] = { .type = NLA_S8 },
+	};
+	struct sprdwl_vif *vif = container_of(wdev, struct sprdwl_vif, wdev);
+	struct sprdwl_priv *priv = wiphy_priv(wiphy);
+
+	/*if wifi not connected,return	*/
+	if (SPRDWL_CONNECTED != vif->sm_state) {
+		wl_err("Wifi not connected!\n");
+		return -ENOTSUPP;
+	}
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 14, 0)
+	if (nla_parse(tb, MONITOR_MAX, data, len, policy, NULL)) {
+#else
+	if (nla_parse(tb, MONITOR_MAX, data, len, policy)) {
+#endif
+		wl_err("Invalid ATTR\n");
+		return -EINVAL;
+	}
+
+	if (!tb[REQUEST_ID]) {
+		wl_err("attr request id failed\n");
+		return -EINVAL;
+	}
+
+	if (!tb[MONITOR_CONTROL]) {
+		wl_err("attr control failed\n");
+		return -EINVAL;
+	}
+
+	req.request_id = nla_get_u32(tb[REQUEST_ID]);
+	control = nla_get_u32(tb[MONITOR_CONTROL]);
+
+	if (control == WLAN_RSSI_MONITORING_START) {
+		req.control = true;
+		if (!tb[MIN_RSSI]) {
+			wl_err("get min rssi fail\n");
+			return -EINVAL;
+		}
+
+		if (!tb[MAX_RSSI]) {
+			wl_err("get max rssi fail\n");
+			return -EINVAL;
+		}
+
+		req.min_rssi = nla_get_s8(tb[MIN_RSSI]);
+		req.max_rssi = nla_get_s8(tb[MAX_RSSI]);
+
+		if (!(req.min_rssi < req.max_rssi)) {
+			wl_err("min rssi %d must be less than max_rssi:%d\n",
+			       req.min_rssi, req.max_rssi);
+			return -EINVAL;
+		}
+		wl_info("min_rssi:%d max_rssi:%d\n",
+			req.min_rssi, req.max_rssi);
+	} else if (control == WLAN_RSSI_MONITORING_STOP) {
+		req.control = false;
+		wl_info("stop rssi monitor!\n");
+	} else {
+		wl_err("Invalid control cmd:%d\n", control);
+		return -EINVAL;
+	}
+	wl_info("Request id:%u,control:%d", req.request_id, req.control);
+
+	/*send rssi monitor cmd*/
+	send_rssi_cmd(priv, vif->ctx_id, &req, sizeof(req));
+
+	return 0;
+}
+
+void sprdwl_event_rssi_monitor(struct sprdwl_vif *vif, u8 *data, u16 len)
+{
+	struct sprdwl_priv *priv = vif->priv;
+	struct wiphy *wiphy = priv->wiphy;
+	struct sk_buff *skb;
+	struct rssi_monitor_event *mon = (struct rssi_monitor_event *)data;
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 4, 83)
+	skb = cfg80211_vendor_event_alloc(wiphy, &vif->wdev,
+#else
+	skb = cfg80211_vendor_event_alloc(wiphy,
+#endif
+					  EVENT_BUF_SIZE + NLMSG_HDRLEN,
+			SPRDWL_VENDOR_SUBCMD_MONITOR_RSSI_INDEX,
+			GFP_KERNEL);
+	if (!skb) {
+		wl_err("%s vendor alloc event failed\n", __func__);
+		return;
+	}
+	wl_info("Req Id:%u,current RSSI:%d, Current BSSID:%pM\n",
+		mon->request_id, mon->curr_rssi, mon->curr_bssid);
+	if (nla_put_u32(skb, SPRDWL_ATTR_RSSI_MONITORING_REQUEST_ID,
+			mon->request_id) ||
+		nla_put(skb, SPRDWL_ATTR_RSSI_MONITORING_CUR_BSSID,
+			sizeof(mon->curr_bssid), mon->curr_bssid) ||
+		nla_put_s8(skb, SPRDWL_ATTR_RSSI_MONITORING_CUR_RSSI,
+			   mon->curr_rssi)) {
+		wl_err("nla data put fail\n");
+		goto fail;
+	}
+
+	cfg80211_vendor_event(skb, GFP_KERNEL);
+	return;
+
+fail:
+	kfree_skb(skb);
+}
+
+static int sprdwl_vendor_get_logger_feature(struct wiphy *wiphy,
+					    struct wireless_dev *wdev,
+					    const void *data, int len)
+{
+	int ret;
+	struct sk_buff *reply;
+	int feature, payload;
+
+	payload = sizeof(feature);
+	feature = 0;
+	reply = cfg80211_vendor_cmd_alloc_reply_skb(wiphy, payload);
+
+	if (!reply)
+		return -ENOMEM;
+
+	feature |= WIFI_LOGGER_CONNECT_EVENT_SUPPORTED;
+
+	/*vts will test wake reason state function*/
+	feature |= WIFI_LOGGER_WAKE_LOCK_SUPPORTED;
+
+	if (nla_put_u32(reply, SPRDWL_VENDOR_ATTR_FEATURE_SET, feature)) {
+		wiphy_err(wiphy, "put skb u32 failed\n");
+		goto out_put_fail;
+	}
+
+	ret = cfg80211_vendor_cmd_reply(reply);
+	if (ret)
+		wiphy_err(wiphy, "reply cmd error\n");
+	return ret;
+
+out_put_fail:
+	kfree_skb(reply);
+	return -EMSGSIZE;
+}
+
+static int sprdwl_flush_epno_list(struct sprdwl_vif *vif)
+{
+	int ret;
+	char flush_data = 1;
+	struct sprdwl_cmd_gscan_rsp_header rsp;
+	u16 rlen = sizeof(struct sprdwl_cmd_gscan_rsp_header);
+
+	ret = sprdwl_gscan_subcmd(vif->priv, vif->ctx_id,
+				  (void *)&flush_data,
+				  SPRDWL_GSCAN_SUBCMD_SET_EPNO_FLUSH,
+				  sizeof(flush_data),
+				  (u8 *)(&rsp), &rlen);
+	wl_debug("flush epno list, ret = %d\n", ret);
+	return ret;
+}
+
+static int sprdwl_vendor_set_epno_list(struct wiphy *wiphy,
+				       struct wireless_dev *wdev,
+				       const void *data, int len)
+{
+	int i, ret = 0;
+	int type;
+	int rem_len, rem_outer_len, rem_inner_len;
+	struct nlattr *pos, *outer_iter, *inner_iter;
+	struct wifi_epno_network *epno_network;
+	struct wifi_epno_params epno_params;
+	struct sprdwl_cmd_gscan_rsp_header rsp;
+	struct sprdwl_vif *vif = netdev_priv(wdev->netdev);
+	u16 rlen = sizeof(struct sprdwl_cmd_gscan_rsp_header);
+
+	nla_for_each_attr(pos, (void *)data, len, rem_len) {
+		type = nla_type(pos);
+		switch (type) {
+		case GSCAN_RESULTS_REQUEST_ID:
+			epno_params.request_id = nla_get_u32(pos);
+			break;
+
+		case SPRDWL_EPNO_PARAM_MIN5GHZ_RSSI:
+			epno_params.min5ghz_rssi = nla_get_u32(pos);
+			break;
+
+		case SPRDWL_EPNO_PARAM_MIN24GHZ_RSSI:
+			epno_params.min24ghz_rssi = nla_get_u32(pos);
+			break;
+
+		case SPRDWL_EPNO_PARAM_INITIAL_SCORE_MAX:
+			epno_params.initial_score_max = nla_get_u32(pos);
+			break;
+
+		case SPRDWL_EPNO_PARAM_CURRENT_CONNECTION_BONUS:
+			epno_params.current_connection_bonus = nla_get_u32(pos);
+			break;
+
+		case SPRDWL_EPNO_PARAM_SAME_NETWORK_BONUS:
+			epno_params.same_network_bonus = nla_get_u32(pos);
+			break;
+
+		case SPRDWL_EPNO_PARAM_SECURE_BONUS:
+			epno_params.secure_bonus = nla_get_u32(pos);
+			break;
+
+		case SPRDWL_EPNO_PARAM_BAND5GHZ_BONUS:
+			epno_params.band5ghz_bonus = nla_get_u32(pos);
+			break;
+
+		case SPRDWL_EPNO_PARAM_NUM_NETWORKS:
+			epno_params.num_networks = nla_get_u32(pos);
+			if (epno_params.num_networks == 0)
+				return sprdwl_flush_epno_list(vif);
+
+			break;
+
+		case SPRDWL_EPNO_PARAM_NETWORKS_LIST:
+			i = 0;
+			nla_for_each_nested(outer_iter, pos, rem_outer_len) {
+				epno_network = &epno_params.networks[i];
+				nla_for_each_nested(inner_iter, outer_iter,
+						    rem_inner_len) {
+					type = nla_type(inner_iter);
+					switch (type) {
+					case SPRDWL_EPNO_PARAM_NETWORK_SSID:
+						memcpy(epno_network->ssid,
+						       nla_data(inner_iter),
+						       IEEE80211_MAX_SSID_LEN);
+						break;
+
+					case SPRDWL_EPNO_PARAM_NETWORK_FLAGS:
+						epno_network->flags =
+						    nla_get_u8(inner_iter);
+						break;
+
+					case SPRDWL_EPNO_PARAM_NETWORK_AUTH_BIT:
+						epno_network->auth_bit_field =
+						    nla_get_u8(inner_iter);
+						break;
+
+					default:
+						wl_ndev_log(L_ERR, vif->ndev,
+							   "networks nla type 0x%x not support\n",
+							   type);
+						ret = -EINVAL;
+						break;
+					}
+				}
+
+				if (ret < 0)
+					break;
+
+				i++;
+				if (i >= MAX_EPNO_NETWORKS)
+					break;
+			}
+			break;
+
+
+		default:
+			wl_ndev_log(L_ERR, vif->ndev, "nla type 0x%x not support\n",
+				   type);
+			ret = -EINVAL;
+			break;
+		}
+
+		if (ret < 0)
+			break;
+	}
+
+	epno_params.boot_time = jiffies;
+
+	wl_ndev_log(L_INFO, vif->ndev, "parse epno list %s\n",
+		    !ret ? "success" : "failture");
+	if (!ret)
+		ret = sprdwl_gscan_subcmd(vif->priv, vif->ctx_id,
+					  (void *)&epno_params,
+					  SPRDWL_GSCAN_SUBCMD_SET_EPNO_SSID,
+					  sizeof(epno_params), (u8 *)(&rsp),
+					  &rlen);
+
+	return ret;
+}
+
+int sprdwl_hotlist_change_event(struct sprdwl_vif *vif, u32 report_event)
+{
+	struct sprdwl_priv *priv = vif->priv;
+	struct wiphy *wiphy = priv->wiphy;
+	struct sk_buff *reply;
+	int payload, rlen, event_idx;
+	int ret = 0, j, moredata = 0;
+	struct nlattr *cached_list;
+
+
+	rlen = priv->hotlist_res->num_results
+			* sizeof(struct sprdwl_gscan_result) + sizeof(u32);
+	payload = rlen + 0x100;
+
+	if (report_event & REPORT_EVENTS_HOTLIST_RESULTS_FOUND) {
+		event_idx = NL80211_VENDOR_SUBCMD_GSCAN_HOTLIST_AP_FOUND_INDEX;
+	} else if (report_event & REPORT_EVENTS_HOTLIST_RESULTS_LOST) {
+		event_idx = NL80211_VENDOR_SUBCMD_GSCAN_HOTLIST_AP_LOST_INDEX;
+	} else {
+		/* unknown event, should not happened*/
+		event_idx = SPRD_RESERVED1;
+	}
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 4, 83)
+	reply = cfg80211_vendor_event_alloc(wiphy, &vif->wdev, payload,
+#else
+	reply = cfg80211_vendor_event_alloc(wiphy, payload,
+#endif
+					    event_idx, GFP_KERNEL);
+
+	if (!reply)
+		return -ENOMEM;
+
+	if (nla_put_u32(reply, GSCAN_RESULTS_REQUEST_ID,
+		priv->hotlist_res->req_id) ||
+		nla_put_u32(reply,
+		GSCAN_RESULTS_NUM_RESULTS_AVAILABLE,
+		priv->hotlist_res->num_results)) {
+		wl_ndev_log(L_ERR, vif->ndev, "failed to put!\n");
+		goto out_put_fail;
+	}
+
+	if (nla_put_u8(reply,
+		GSCAN_RESULTS_SCAN_RESULT_MORE_DATA,
+		moredata)) {
+		wl_ndev_log(L_ERR, vif->ndev, "failed to put!\n");
+		goto out_put_fail;
+	}
+
+	if (priv->hotlist_res->num_results == 0)
+		goto out_put_fail;
+
+
+	cached_list = nla_nest_start(reply, GSCAN_RESULTS_LIST);
+	if (!cached_list)
+		goto out_put_fail;
+
+	for (j = 0; j < priv->hotlist_res->num_results; j++) {
+		struct nlattr *ap;
+		struct sprdwl_gscan_hotlist_results *p = priv->hotlist_res;
+
+		wl_info("[index=%d] Timestamp(%lu) Ssid (%s) Bssid: %pM Channel (%d) Rssi (%d) RTT (%u) RTT_SD (%u)\n",
+			j,
+			p->results[j].ts,
+			p->results[j].ssid,
+			p->results[j].bssid,
+			p->results[j].channel,
+			p->results[j].rssi,
+			p->results[j].rtt,
+			p->results[j].rtt_sd);
+
+		ap = nla_nest_start(reply, j + 1);
+		if (!ap) {
+			wl_ndev_log(L_ERR, vif->ndev, "failed to put!\n");
+			goto out_put_fail;
+		}
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 7, 0)
+		if (nla_put_u64_64bit(reply,
+			GSCAN_RESULTS_SCAN_RESULT_TIME_STAMP,
+			p->results[j].ts, 0)) {
+#else
+		if (nla_put_u64(reply,
+			GSCAN_RESULTS_SCAN_RESULT_TIME_STAMP,
+			p->results[j].ts)) {
+#endif
+			wl_ndev_log(L_ERR, vif->ndev, "failed to put!\n");
+			goto out_put_fail;
+		}
+		if (nla_put(reply,
+			GSCAN_RESULTS_SCAN_RESULT_SSID,
+			sizeof(p->results[j].ssid),
+			p->results[j].ssid)) {
+			wl_ndev_log(L_ERR, vif->ndev, "failed to put!\n");
+			goto out_put_fail;
+		}
+		if (nla_put(reply,
+			GSCAN_RESULTS_SCAN_RESULT_BSSID,
+			sizeof(p->results[j].bssid),
+			p->results[j].bssid)) {
+			wl_ndev_log(L_ERR, vif->ndev, "failed to put!\n");
+			goto out_put_fail;
+		}
+		if (nla_put_u32(reply,
+			GSCAN_RESULTS_SCAN_RESULT_CHANNEL,
+			p->results[j].channel)) {
+			wl_ndev_log(L_ERR, vif->ndev, "failed to put!\n");
+			goto out_put_fail;
+		}
+		if (nla_put_s32(reply,
+			GSCAN_RESULTS_SCAN_RESULT_RSSI,
+			p->results[j].rssi)) {
+			wl_ndev_log(L_ERR, vif->ndev, "failed to put!\n");
+			goto out_put_fail;
+		}
+		if (nla_put_u32(reply,
+			GSCAN_RESULTS_SCAN_RESULT_RTT,
+			p->results[j].rtt)) {
+			wl_ndev_log(L_ERR, vif->ndev, "failed to put!\n");
+			goto out_put_fail;
+		}
+		if (nla_put_u32(reply,
+			GSCAN_RESULTS_SCAN_RESULT_RTT_SD,
+			p->results[j].rtt_sd)) {
+			wl_ndev_log(L_ERR, vif->ndev, "failed to put!\n");
+			goto out_put_fail;
+		}
+	nla_nest_end(reply, ap);
+	}
+	nla_nest_end(reply, cached_list);
+
+	cfg80211_vendor_event(reply, GFP_KERNEL);
+	/*reset results buffer when finished event report*/
+	if (vif->priv->hotlist_res) {
+		memset(vif->priv->hotlist_res, 0x0,
+		sizeof(struct sprdwl_gscan_hotlist_results));
+	}
+
+	return ret;
+
+out_put_fail:
+	kfree_skb(reply);
+	WARN_ON(1);
+	return -EMSGSIZE;
+}
+
+int sprdwl_significant_change_event(struct sprdwl_vif *vif)
+{
+	struct sprdwl_priv *priv = vif->priv;
+	struct wiphy *wiphy = priv->wiphy;
+	struct sk_buff *reply;
+	int payload, rlen;
+	int ret = 0, j;
+	struct nlattr *cached_list;
+
+	rlen = sizeof(struct sprdwl_significant_change_result);
+	payload = rlen + 0x100;
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 4, 83)
+	reply = cfg80211_vendor_event_alloc(wiphy, &vif->wdev,
+#else
+	reply = cfg80211_vendor_event_alloc(wiphy,
+#endif
+				payload,
+				NL80211_VENDOR_SUBCMD_SIGNIFICANT_CHANGE_INDEX,
+				GFP_KERNEL);
+
+	if (!reply)
+		return -ENOMEM;
+
+	if (nla_put_u32(reply, GSCAN_RESULTS_REQUEST_ID,
+		priv->significant_res->req_id) ||
+		nla_put_u32(reply,
+		GSCAN_RESULTS_NUM_RESULTS_AVAILABLE,
+		priv->significant_res->num_results)) {
+		wl_ndev_log(L_ERR, vif->ndev, "failed to put!\n");
+		goto out_put_fail;
+	}
+
+	cached_list = nla_nest_start(reply, GSCAN_RESULTS_LIST);
+	if (!cached_list)
+		goto out_put_fail;
+
+	for (j = 0; j < priv->significant_res->num_results; j++) {
+		struct nlattr *ap;
+		struct significant_change_info *p =
+				priv->significant_res->results+j;
+
+		ap = nla_nest_start(reply, j + 1);
+		if (!ap) {
+			wl_ndev_log(L_ERR, vif->ndev, "failed to put!\n");
+			goto out_put_fail;
+		}
+
+		if (nla_put(reply,
+			GSCAN_RESULTS_SIGNIFICANT_CHANGE_RESULT_BSSID,
+			sizeof(p->bssid),
+			p->bssid)) {
+			wl_ndev_log(L_ERR, vif->ndev, "failed to put!\n");
+			goto out_put_fail;
+		}
+
+		if (nla_put_u32(reply,
+			GSCAN_RESULTS_SIGNIFICANT_CHANGE_RESULT_CHANNEL,
+			p->channel)) {
+			wl_ndev_log(L_ERR, vif->ndev, "failed to put!\n");
+			goto out_put_fail;
+		}
+
+		if (nla_put_u32(reply,
+			GSCAN_RESULTS_SIGNIFICANT_CHANGE_RESULT_NUM_RSSI,
+			p->num_rssi)) {
+			wl_ndev_log(L_ERR, vif->ndev, "failed to put!\n");
+			goto out_put_fail;
+		}
+		if (nla_put(reply,
+			GSCAN_RESULTS_SIGNIFICANT_CHANGE_RESULT_RSSI_LIST,
+			sizeof(s8) * 3, /*here, we fixed rssi list as 3*/
+			p->rssi)) {
+			wl_ndev_log(L_ERR, vif->ndev, "failed to put!\n");
+			goto out_put_fail;
+		}
+
+	nla_nest_end(reply, ap);
+	}
+	nla_nest_end(reply, cached_list);
+
+	cfg80211_vendor_event(reply, GFP_KERNEL);
+
+	/*reset results buffer when finished event report*/
+	if (vif->priv->significant_res) {
+		memset(vif->priv->significant_res, 0x0,
+		sizeof(struct sprdwl_significant_change_result));
+	}
+
+	return ret;
+
+out_put_fail:
+	kfree_skb(reply);
+	WARN_ON(1);
+	return -EMSGSIZE;
+}
+
+/*set SAR limits function------CMD ID:146*/
+static int sprdwl_vendor_set_sar_limits(struct wiphy *wiphy,
+		struct wireless_dev *wdev,
+		const void *data, int len)
+{
+	/*to pass vts*/
+	return -EOPNOTSUPP;
+#if	0
+	int ret = 0;
+	uint32_t bdf = 0xff;
+	struct sprdwl_priv *priv = wiphy_priv(wiphy);
+	struct sprdwl_vif *vif = container_of(wdev, struct sprdwl_vif, wdev);
+	struct nlattr *tb[WLAN_ATTR_SAR_LIMITS_MAX + 1];
+
+	wl_info("%s enter:\n", __func__);
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 14, 0)
+	if (nla_parse(tb, WLAN_ATTR_SAR_LIMITS_MAX, data, len, NULL, NULL)) {
+#else
+	if (nla_parse(tb, WLAN_ATTR_SAR_LIMITS_MAX, data, len, NULL)) {
+#endif
+		wl_err("Invalid ATTR\n");
+		return -EINVAL;
+	}
+
+	if (!tb[WLAN_ATTR_SAR_LIMITS_SAR_ENABLE]) {
+		wl_err("attr sar enable failed\n");
+		return -EINVAL;
+	}
+
+	bdf = nla_get_u32(tb[WLAN_ATTR_SAR_LIMITS_SAR_ENABLE]);
+	if (bdf > WLAN_SAR_LIMITS_USER) {
+		wl_err("bdf value:%d exceed the max value\n", bdf);
+		return -EINVAL;
+	}
+
+	if (WLAN_SAR_LIMITS_BDF0 == bdf) {
+		/*set sar limits*/
+		ret = sprdwl_power_save(priv, vif->ctx_id,
+				 SPRDWL_SET_TX_POWER, bdf);
+	} else if (WLAN_SAR_LIMITS_NONE == bdf) {
+		/*reset sar limits*/
+		ret = sprdwl_power_save(priv, vif->ctx_id,
+				SPRDWL_SET_TX_POWER, -1);
+	}
+	return ret;
+#endif
+}
+
+static int sprdwl_start_offload_packet(struct sprdwl_priv *priv,
+				       u8 vif_ctx_id,
+				       struct nlattr **tb,
+				       u32 request_id)
+{
+	u8 src[ETH_ALEN], dest[ETH_ALEN];
+	u32 period, len;
+	u16 prot_type;
+	u8 *data, *pos;
+	int ret;
+
+	if (!tb[OFFLOADED_PACKETS_IP_PACKET_DATA] ||
+	    !tb[OFFLOADED_PACKETS_SRC_MAC_ADDR] ||
+	    !tb[OFFLOADED_PACKETS_DST_MAC_ADDR] ||
+	    !tb[OFFLOADED_PACKETS_PERIOD] ||
+	    !tb[OFFLOADED_PACKETS_ETHER_PROTO_TYPE]) {
+		pr_err("check start offload para failed\n");
+		return -EINVAL;
+	}
+
+	period = nla_get_u32(tb[OFFLOADED_PACKETS_PERIOD]);
+	prot_type = nla_get_u16(tb[OFFLOADED_PACKETS_ETHER_PROTO_TYPE]);
+	prot_type = htons(prot_type);
+	nla_memcpy(src, tb[OFFLOADED_PACKETS_SRC_MAC_ADDR], ETH_ALEN);
+	nla_memcpy(dest, tb[OFFLOADED_PACKETS_DST_MAC_ADDR], ETH_ALEN);
+	len = nla_len(tb[OFFLOADED_PACKETS_IP_PACKET_DATA]);
+
+	data = kzalloc(len + 14, GFP_KERNEL);
+	if (!data)
+		return -ENOMEM;
+
+	pos = data;
+	memcpy(pos, dest, ETH_ALEN);
+	pos += ETH_ALEN;
+	memcpy(pos, src, ETH_ALEN);
+	pos += ETH_ALEN;
+	memcpy(pos, &prot_type, 2);
+	pos += 2;
+	memcpy(pos, nla_data(tb[OFFLOADED_PACKETS_IP_PACKET_DATA]), len);
+
+	ret = sprdwl_set_packet_offload(priv, vif_ctx_id,
+					request_id, 1, period,
+					len + 14,  data);
+	kfree(data);
+
+	return ret;
+}
+
+static int sprdwl_stop_offload_packet(struct sprdwl_priv *priv,
+				      u8 vif_ctx_id, u32 request_id)
+{
+	return sprdwl_set_packet_offload(priv, vif_ctx_id,
+					 request_id, 0, 0, 0, NULL);
+}
+
+static int sprdwl_set_offload_packet(struct wiphy *wiphy,
+				     struct wireless_dev *wdev,
+				     const void *data, int len)
+{
+	int err;
+	u8 control;
+	u32 req;
+	struct nlattr *tb[OFFLOADED_PACKETS_MAX + 1];
+	struct sprdwl_vif *vif = container_of(wdev, struct sprdwl_vif, wdev);
+	struct sprdwl_priv *priv = wiphy_priv(wiphy);
+
+	if (!data) {
+		wiphy_err(wiphy, "%s offload failed\n", __func__);
+		return -EINVAL;
+	}
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 14, 0)
+	err = nla_parse(tb, OFFLOADED_PACKETS_MAX, data,
+			len, NULL, NULL);
+#else
+	err = nla_parse(tb, OFFLOADED_PACKETS_MAX, data,
+			len, NULL);
+#endif
+	if (err) {
+		wiphy_err(wiphy, "%s parse attr failed", __func__);
+		return err;
+	}
+
+	if (!tb[OFFLOADED_PACKETS_REQUEST_ID] ||
+	    !tb[OFFLOADED_PACKETS_SENDING_CONTROL]) {
+		wiphy_err(wiphy, "check request id or control failed\n");
+		return -EINVAL;
+	}
+
+	req = nla_get_u32(tb[OFFLOADED_PACKETS_REQUEST_ID]);
+	control = nla_get_u32(tb[OFFLOADED_PACKETS_SENDING_CONTROL]);
+
+	switch (control) {
+	case OFFLOADED_PACKETS_SENDING_STOP:
+		return sprdwl_stop_offload_packet(priv, vif->ctx_id, req);
+	case OFFLOADED_PACKETS_SENDING_START:
+		return  sprdwl_start_offload_packet(priv, vif->ctx_id, tb, req);
+	default:
+		wiphy_err(wiphy, "control value is invalid\n");
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+const struct wiphy_vendor_command sprdwl_vendor_cmd[] = {
+	{/*9*/
+		{
+		    .vendor_id = OUI_SPREAD,
+		    .subcmd = SPRDWL_VENDOR_SUBCMD_ROAMING,
+		},
+		.flags = WIPHY_VENDOR_CMD_NEED_WDEV |
+			WIPHY_VENDOR_CMD_NEED_NETDEV,
+		.doit = sprdwl_vendor_roaming_enable,
+		.policy = VENDOR_CMD_RAW_DATA,
+	},
+	{/*12*/
+		{
+		    .vendor_id = OUI_SPREAD,
+		    .subcmd = SPRDWL_VENDOR_SUBCMD_NAN,
+		},
+		.flags = WIPHY_VENDOR_CMD_NEED_WDEV |
+			WIPHY_VENDOR_CMD_NEED_NETDEV,
+		.doit = sprdwl_vendor_nan_enable,
+		.policy = VENDOR_CMD_RAW_DATA,
+	},
+	{/*14*/
+		{
+		    .vendor_id = OUI_SPREAD,
+		    .subcmd = SPRDWL_VENDOR_SET_LLSTAT
+		},
+		.flags = WIPHY_VENDOR_CMD_NEED_WDEV |
+			WIPHY_VENDOR_CMD_NEED_NETDEV,
+		.doit = sprdwl_vendor_set_llstat_handler,
+		.policy = VENDOR_CMD_RAW_DATA,
+	},
+	{/*15*/
+		{
+		    .vendor_id = OUI_SPREAD,
+		    .subcmd = SPRDWL_VENDOR_GET_LLSTAT
+		},
+		.flags = WIPHY_VENDOR_CMD_NEED_WDEV |
+			WIPHY_VENDOR_CMD_NEED_NETDEV,
+		.doit = sprdwl_vendor_get_llstat_handler,
+		.policy = VENDOR_CMD_RAW_DATA,
+	},
+	{/*16*/
+		{
+		    .vendor_id = OUI_SPREAD,
+		    .subcmd = SPRDWL_VENDOR_CLR_LLSTAT
+		},
+		.flags = WIPHY_VENDOR_CMD_NEED_WDEV |
+			WIPHY_VENDOR_CMD_NEED_NETDEV,
+		.doit = sprdwl_vendor_clr_llstat_handler,
+		.policy = VENDOR_CMD_RAW_DATA,
+	},
+	{/*20*/
+		{
+		    .vendor_id = OUI_SPREAD,
+		    .subcmd = SPRDWL_VENDOR_SUBCMD_GSCAN_START,
+		},
+		.flags = WIPHY_VENDOR_CMD_NEED_WDEV |
+			 WIPHY_VENDOR_CMD_NEED_NETDEV,
+		.doit = sprdwl_vendor_gscan_start,
+		.policy = VENDOR_CMD_RAW_DATA,
+	},
+	{/*21*/
+		{
+		    .vendor_id = OUI_SPREAD,
+		    .subcmd = SPRDWL_VENDOR_SUBCMD_GSCAN_STOP,
+		},
+		.flags = WIPHY_VENDOR_CMD_NEED_WDEV |
+			 WIPHY_VENDOR_CMD_NEED_NETDEV,
+		.doit = sprdwl_vendor_gscan_stop,
+		.policy = VENDOR_CMD_RAW_DATA,
+	},
+	{/*22*/
+		{
+		    .vendor_id = OUI_SPREAD,
+		    .subcmd = SPRDWL_VENDOR_SUBCMD_GSCAN_GET_CHANNEL,
+		},
+		.flags = WIPHY_VENDOR_CMD_NEED_WDEV |
+			 WIPHY_VENDOR_CMD_NEED_NETDEV,
+		.doit = sprdwl_vendor_get_channel_list,
+		.policy = VENDOR_CMD_RAW_DATA,
+	},
+	{/*23*/
+		{
+		    .vendor_id = OUI_SPREAD,
+		    .subcmd = SPRDWL_VENDOR_SUBCMD_GSCAN_GET_CAPABILITIES,
+		},
+		.flags = WIPHY_VENDOR_CMD_NEED_WDEV |
+			 WIPHY_VENDOR_CMD_NEED_NETDEV,
+		.doit = sprdwl_vendor_get_gscan_capabilities,
+		.policy = VENDOR_CMD_RAW_DATA,
+	},
+	{/*24*/
+		{
+		    .vendor_id = OUI_SPREAD,
+		    .subcmd = SPRDWL_VENDOR_SUBCMD_GSCAN_GET_CACHED_RESULTS,
+		},
+		.flags = WIPHY_VENDOR_CMD_NEED_WDEV |
+			 WIPHY_VENDOR_CMD_NEED_NETDEV,
+		.doit = sprdwl_vendor_get_cached_gscan_results,
+		.policy = VENDOR_CMD_RAW_DATA,
+	},
+	{/*29*/
+		{
+		    .vendor_id = OUI_SPREAD,
+		    .subcmd = SPRDWL_VENDOR_SUBCMD_GSCAN_SET_BSSID_HOTLIST,
+		},
+		.flags = WIPHY_VENDOR_CMD_NEED_WDEV |
+			 WIPHY_VENDOR_CMD_NEED_NETDEV,
+		.doit = sprdwl_vendor_set_bssid_hotlist,
+		.policy = VENDOR_CMD_RAW_DATA,
+	},
+	{/*30*/
+		{
+		    .vendor_id = OUI_SPREAD,
+		    .subcmd = SPRDWL_VENDOR_SUBCMD_GSCAN_RESET_BSSID_HOTLIST,
+		},
+		.flags = WIPHY_VENDOR_CMD_NEED_WDEV |
+			 WIPHY_VENDOR_CMD_NEED_NETDEV,
+		.doit = sprdwl_vendor_reset_bssid_hotlist,
+		.policy = VENDOR_CMD_RAW_DATA,
+	},
+	{/*32*/
+		{
+		    .vendor_id = OUI_SPREAD,
+		    .subcmd = SPRDWL_VENDOR_SUBCMD_GSCAN_SET_SIGNIFICANT_CHANGE,
+		},
+		.flags = WIPHY_VENDOR_CMD_NEED_WDEV |
+			 WIPHY_VENDOR_CMD_NEED_NETDEV,
+		.doit = sprdwl_vendor_set_significant_change,
+		.policy = VENDOR_CMD_RAW_DATA,
+	},
+	{/*33*/
+	    {
+		.vendor_id = OUI_SPREAD,
+		.subcmd = SPRDWL_VENDOR_SUBCMD_GSCAN_RESET_SIGNIFICANT_CHANGE,
+	    },
+		.flags = WIPHY_VENDOR_CMD_NEED_WDEV |
+			 WIPHY_VENDOR_CMD_NEED_NETDEV,
+		.doit = sprdwl_vendor_reset_significant_change,
+		.policy = VENDOR_CMD_RAW_DATA,
+	},
+	{/*38*/
+		{
+		    .vendor_id = OUI_SPREAD,
+		    .subcmd = SPRDWL_VENDOR_SUBCMD_GET_SUPPORT_FEATURE,
+		},
+		.flags = WIPHY_VENDOR_CMD_NEED_WDEV |
+			 WIPHY_VENDOR_CMD_NEED_NETDEV,
+		.doit = sprdwl_vendor_get_support_feature,
+		.policy = VENDOR_CMD_RAW_DATA,
+	},
+	{/*39*/
+		{
+		    .vendor_id = OUI_SPREAD,
+		    .subcmd = SPRDWL_VENDOR_SUBCMD_SET_MAC_OUI,
+		},
+		.flags = WIPHY_VENDOR_CMD_NEED_WDEV |
+			 WIPHY_VENDOR_CMD_NEED_NETDEV,
+		.doit = sprdwl_vendor_set_mac_oui,
+		.policy = VENDOR_CMD_RAW_DATA,
+	},
+	{/*42*/
+		{
+			.vendor_id = OUI_SPREAD,
+			.subcmd = SPRDWL_VENDOR_SUBCMD_GET_CONCURRENCY_MATRIX,
+		},
+		.flags = WIPHY_VENDOR_CMD_NEED_WDEV |
+			 WIPHY_VENDOR_CMD_NEED_NETDEV,
+		.doit = sprdwl_vendor_get_concurrency_matrix,
+		.policy = VENDOR_CMD_RAW_DATA,
+	},
+	{/*55*/
+		{
+		    .vendor_id = OUI_SPREAD,
+		    .subcmd = SPRDWL_VENDOR_SUBCMD_GET_FEATURE,
+		},
+		.flags = WIPHY_VENDOR_CMD_NEED_WDEV |
+			 WIPHY_VENDOR_CMD_NEED_NETDEV,
+		.doit = sprdwl_vendor_get_feature,
+		.policy = VENDOR_CMD_RAW_DATA,
+	},
+	{/*61*/
+		{
+		    .vendor_id = OUI_SPREAD,
+		    .subcmd = SPRDWL_VENDOR_SUBCMD_GET_WIFI_INFO,
+		},
+		.flags = WIPHY_VENDOR_CMD_NEED_WDEV |
+			 WIPHY_VENDOR_CMD_NEED_NETDEV,
+		.doit = sprdwl_vendor_get_driver_info,
+		.policy = VENDOR_CMD_RAW_DATA,
+	},
+	{/*62*/
+		{
+		    .vendor_id = OUI_SPREAD,
+		    .subcmd = SPRDWL_VENDOR_SUBCMD_START_LOGGING,
+		},
+		.flags = WIPHY_VENDOR_CMD_NEED_WDEV |
+			 WIPHY_VENDOR_CMD_NEED_NETDEV,
+		.doit = sprdwl_vendor_start_logging,
+		.policy = VENDOR_CMD_RAW_DATA,
+	},
+	{/*63*/
+		{
+		    .vendor_id = OUI_SPREAD,
+		    .subcmd = SPRDWL_VENDOR_SUBCMD_WIFI_LOGGER_MEMORY_DUMP,
+		},
+		.flags = WIPHY_VENDOR_CMD_NEED_WDEV |
+			 WIPHY_VENDOR_CMD_NEED_NETDEV,
+		.doit = sprdwl_vendor_memory_dump,
+		.policy = VENDOR_CMD_RAW_DATA,
+	},
+	{/*64*/
+		{
+		    .vendor_id = OUI_SPREAD,
+		    .subcmd = SPRDWL_VENDOR_SUBCMD_ROAM,
+		},
+		.flags = WIPHY_VENDOR_CMD_NEED_WDEV |
+			WIPHY_VENDOR_CMD_NEED_NETDEV,
+		.doit = sprdwl_vendor_set_roam_params,
+		.policy = VENDOR_CMD_RAW_DATA,
+	},
+	{/*65*/
+		{
+		    .vendor_id = OUI_SPREAD,
+		    .subcmd = SPRDWL_VENDOR_SUBCMD_GSCAN_SET_SSID_HOTLIST,
+		},
+		.flags = WIPHY_VENDOR_CMD_NEED_WDEV |
+			WIPHY_VENDOR_CMD_NEED_NETDEV,
+		.doit = sprdwl_vendor_set_ssid_hotlist,
+		.policy = VENDOR_CMD_RAW_DATA,
+	},
+	{/*66*/
+		{
+		    .vendor_id = OUI_SPREAD,
+		    .subcmd = SPRDWL_VENDOR_SUBCMD_GSCAN_RESET_SSID_HOTLIST,
+		},
+		.flags = WIPHY_VENDOR_CMD_NEED_WDEV |
+			WIPHY_VENDOR_CMD_NEED_NETDEV,
+		.doit = sprdwl_vendor_reset_ssid_hotlist,
+		.policy = VENDOR_CMD_RAW_DATA,
+	},
+	{/*69*/
+		{
+		    .vendor_id = OUI_SPREAD,
+		    .subcmd = SPRDWL_VENDOR_SUBCMD_PNO_SET_LIST,
+		},
+		.flags = WIPHY_VENDOR_CMD_NEED_WDEV |
+			 WIPHY_VENDOR_CMD_NEED_NETDEV,
+		.doit = sprdwl_vendor_set_epno_list,
+		.policy = VENDOR_CMD_RAW_DATA,
+	},
+	{/*70*/
+		{
+		    .vendor_id = OUI_SPREAD,
+		    .subcmd = SPRDWL_VENDOR_SUBCMD_PNO_SET_PASSPOINT_LIST,
+		},
+		.flags = WIPHY_VENDOR_CMD_NEED_WDEV |
+			 WIPHY_VENDOR_CMD_NEED_NETDEV,
+		.doit = sprdwl_vendor_set_passpoint_list,
+		.policy = VENDOR_CMD_RAW_DATA,
+	},
+	{/*71 */
+		{
+			.vendor_id = OUI_SPREAD,
+			.subcmd = SPRDWL_VENDOR_SUBCMD_PNO_RESET_PASSPOINT_LIST,
+		},
+		.flags = WIPHY_VENDOR_CMD_NEED_WDEV |
+			 WIPHY_VENDOR_CMD_NEED_NETDEV,
+		.doit = sprdwl_vendor_reset_passpoint_list,
+		.policy = VENDOR_CMD_RAW_DATA,
+	},
+	{/*76 */
+		{
+		    .vendor_id = OUI_SPREAD,
+		    .subcmd = SPRDWL_VENDOR_SUBCMD_GET_LOGGER_FEATURE_SET,
+		},
+		.flags = WIPHY_VENDOR_CMD_NEED_WDEV |
+			 WIPHY_VENDOR_CMD_NEED_NETDEV,
+		.doit = sprdwl_vendor_get_logger_feature,
+		.policy = VENDOR_CMD_RAW_DATA,
+	},
+	{/*77*/
+		{
+		    .vendor_id = OUI_SPREAD,
+		    .subcmd = SPRDWL_VENDOR_SUBCMD_GET_RING_DATA,
+		},
+		.flags = WIPHY_VENDOR_CMD_NEED_WDEV |
+			 WIPHY_VENDOR_CMD_NEED_NETDEV,
+		.doit = sprdwl_vendor_get_ring_data,
+		.policy = VENDOR_CMD_RAW_DATA,
+	},
+	{/*79*/
+		{
+			.vendor_id = OUI_SPREAD,
+			.subcmd = SPRDWL_VENDOR_SUBCMD_OFFLOADED_PACKETS,
+		},
+		.flags = WIPHY_VENDOR_CMD_NEED_WDEV |
+			 WIPHY_VENDOR_CMD_NEED_RUNNING,
+		.doit = sprdwl_set_offload_packet,
+		.policy = VENDOR_CMD_RAW_DATA,
+	},
+	{/*80*/
+		{
+		    .vendor_id = OUI_SPREAD,
+		    .subcmd = SPRDWL_VENDOR_SUBCMD_MONITOR_RSSI,
+		},
+		.flags = WIPHY_VENDOR_CMD_NEED_WDEV |
+			 WIPHY_VENDOR_CMD_NEED_NETDEV,
+		.doit = sprdwl_vendor_monitor_rssi,
+		.policy = VENDOR_CMD_RAW_DATA,
+	},
+	{/*82*/
+		{
+		    .vendor_id = OUI_SPREAD,
+		    .subcmd = SPRDWL_VENDOR_SUBCMD_ENABLE_ND_OFFLOAD,
+		},
+		.flags = WIPHY_VENDOR_CMD_NEED_WDEV |
+			 WIPHY_VENDOR_CMD_NEED_NETDEV,
+		.doit = sprdwl_vendor_enable_nd_offload,
+		.policy = VENDOR_CMD_RAW_DATA,
+	},
+	{/*85 */
+		{
+		    .vendor_id = OUI_SPREAD,
+		    .subcmd = SPRDWL_VENDOR_SUBCMD_GET_WAKE_REASON_STATS,
+		},
+		.flags = WIPHY_VENDOR_CMD_NEED_WDEV |
+			 WIPHY_VENDOR_CMD_NEED_NETDEV,
+		.doit = sprdwl_vendor_get_wake_state,
+		.policy = VENDOR_CMD_RAW_DATA,
+	},
+	{/*146 */
+		{
+		    .vendor_id = OUI_SPREAD,
+		    .subcmd = SPRDWL_VENDOR_SUBCMD_SET_SAR_LIMITS,
+		},
+		.flags = WIPHY_VENDOR_CMD_NEED_WDEV |
+			 WIPHY_VENDOR_CMD_NEED_NETDEV,
+		.doit = sprdwl_vendor_set_sar_limits,
+		.policy = VENDOR_CMD_RAW_DATA,
+	},
+
+#ifdef NAN_SUPPORT
+	{ /* 0x1300 */
+		{
+		    .vendor_id = OUI_SPREAD,
+		    .subcmd = SPRDWL_VENDOR_SUBCMD_NAN
+		},
+		.flags = WIPHY_VENDOR_CMD_NEED_WDEV |
+			WIPHY_VENDOR_CMD_NEED_NETDEV,
+		.doit = sprdwl_vendor_nan_cmds,
+		.policy = VENDOR_CMD_RAW_DATA,
+	},
+#endif /* NAN_SUPPORT */
+#ifdef RTT_SUPPORT
+	{
+		{
+		    .vendor_id = OUI_SPREAD,
+		    .subcmd = SPRD_NL80211_VENDOR_SUBCMD_LOC_GET_CAPA
+		},
+		.flags = WIPHY_VENDOR_CMD_NEED_WDEV |
+			WIPHY_VENDOR_CMD_NEED_RUNNING,
+		.doit = sprdwl_ftm_get_capabilities,
+		.policy = VENDOR_CMD_RAW_DATA,
+	},
+	{
+		{
+		    .vendor_id = OUI_SPREAD,
+		    .subcmd = SPRD_NL80211_VENDOR_SUBCMD_FTM_START_SESSION
+		},
+		.flags = WIPHY_VENDOR_CMD_NEED_WDEV |
+			WIPHY_VENDOR_CMD_NEED_RUNNING,
+		.doit = sprdwl_ftm_start_session,
+		.policy = VENDOR_CMD_RAW_DATA,
+	},
+	{
+		{
+		    .vendor_id = OUI_SPREAD,
+		    .subcmd = SPRD_NL80211_VENDOR_SUBCMD_FTM_ABORT_SESSION
+		},
+		.flags = WIPHY_VENDOR_CMD_NEED_WDEV |
+			WIPHY_VENDOR_CMD_NEED_RUNNING,
+		.doit = sprdwl_ftm_abort_session,
+		.policy = VENDOR_CMD_RAW_DATA,
+	},
+	{
+		{
+		    .vendor_id = OUI_SPREAD,
+		    .subcmd = SPRD_NL80211_VENDOR_SUBCMD_FTM_CFG_RESPONDER
+		},
+		.flags = WIPHY_VENDOR_CMD_NEED_WDEV |
+			WIPHY_VENDOR_CMD_NEED_RUNNING,
+		.doit = sprdwl_ftm_configure_responder,
+		.policy = VENDOR_CMD_RAW_DATA,
+	}
+#endif /* RTT_SUPPORT */
+};
+
+static const struct nl80211_vendor_cmd_info sprdwl_vendor_events[] = {
+	[SPRDWL_VENDOR_SUBCMD_MONITOR_RSSI_INDEX]{
+		.vendor_id = OUI_SPREAD,
+		.subcmd = SPRDWL_VENDOR_SUBCMD_MONITOR_RSSI,
+	},
+	{/*1*/
+		.vendor_id = OUI_SPREAD,
+		.subcmd = SPRD_RESERVED2,
+	},
+	{/*2*/
+		.vendor_id = OUI_SPREAD,
+		.subcmd = SPRD_RESERVED2,
+	},
+	{/*3*/
+		.vendor_id = OUI_SPREAD,
+		.subcmd = SPRD_RESERVED2,
+	},
+	{/*4*/
+		.vendor_id = OUI_SPREAD,
+		.subcmd = SPRD_RESERVED2,
+	},
+	{/*5*/
+		.vendor_id = OUI_SPREAD,
+		.subcmd = SPRD_RESERVED2,
+	},
+	/*reserver for array align*/
+	{
+		.vendor_id = OUI_SPREAD,
+		.subcmd = SPRDWL_VENDOR_SUBCMD_GSCAN_START
+	},
+	{
+		.vendor_id = OUI_SPREAD,
+		.subcmd = SPRDWL_VENDOR_SUBCMD_GSCAN_STOP
+	},
+	{
+		.vendor_id = OUI_SPREAD,
+		.subcmd = SPRDWL_VENDOR_SUBCMD_GSCAN_GET_CAPABILITIES
+	},
+	{
+		.vendor_id = OUI_SPREAD,
+		.subcmd = SPRDWL_VENDOR_SUBCMD_GSCAN_GET_CACHED_RESULTS
+	},
+	{
+		.vendor_id = OUI_SPREAD,
+		.subcmd = SPRDWL_VENDOR_SUBCMD_GSCAN_SCAN_RESULTS_AVAILABLE
+	},
+	{
+		.vendor_id = OUI_SPREAD,
+		.subcmd = SPRDWL_VENDOR_SUBCMD_GSCAN_FULL_SCAN_RESULT
+	},
+	{
+		.vendor_id = OUI_SPREAD,
+		.subcmd = SPRDWL_VENDOR_SUBCMD_GSCAN_SCAN_EVENT
+	},
+	{
+		.vendor_id = OUI_SPREAD,
+		.subcmd = SPRDWL_VENDOR_SUBCMD_GSCAN_HOTLIST_AP_FOUND
+	},
+	{
+		.vendor_id = OUI_SPREAD,
+		.subcmd = SPRDWL_VENDOR_SUBCMD_GSCAN_HOTLIST_AP_LOST
+	},
+	{
+		.vendor_id = OUI_SPREAD,
+		.subcmd = SPRDWL_VENDOR_SUBCMD_GSCAN_SET_BSSID_HOTLIST
+	},
+	{
+		.vendor_id = OUI_SPREAD,
+		.subcmd = SPRDWL_VENDOR_SUBCMD_GSCAN_RESET_BSSID_HOTLIST
+	},
+	{
+		.vendor_id = OUI_SPREAD,
+		.subcmd = SPRDWL_VENDOR_SUBCMD_GSCAN_SIGNIFICANT_CHANGE
+	},
+	{
+		.vendor_id = OUI_SPREAD,
+		.subcmd = SPRDWL_VENDOR_SUBCMD_GSCAN_SET_SIGNIFICANT_CHANGE
+	},
+	{
+		.vendor_id = OUI_SPREAD,
+		.subcmd = SPRDWL_VENDOR_SUBCMD_GSCAN_RESET_SIGNIFICANT_CHANGE
+	},
+
+	[SPRDWL_VENDOR_EVENT_NAN_INDEX] = {
+		.vendor_id = OUI_SPREAD,
+		.subcmd = SPRDWL_VENDOR_EVENT_NAN,
+	},
+	[SPRDWL_VENDOR_EVENT_EPNO_FOUND] = {
+		.vendor_id = OUI_SPREAD,
+		.subcmd = SPRDWL_VENDOR_EVENT_EPNO_FOUND,
+	},
+	[SPRD_VENDOR_EVENT_FTM_MEAS_RESULT_INDEX] = {
+			.vendor_id = OUI_SPREAD,
+			.subcmd = SPRD_NL80211_VENDOR_SUBCMD_FTM_MEAS_RESULT
+	},
+	[SPRD_VENDOR_EVENT_FTM_SESSION_DONE_INDEX] = {
+			.vendor_id = OUI_SPREAD,
+			.subcmd = SPRD_NL80211_VENDOR_SUBCMD_FTM_SESSION_DONE
+	}
+};
+
+int sprdwl_vendor_init(struct wiphy *wiphy)
+{
+	wiphy->vendor_commands = sprdwl_vendor_cmd;
+	wiphy->n_vendor_commands = ARRAY_SIZE(sprdwl_vendor_cmd);
+	wiphy->vendor_events = sprdwl_vendor_events;
+	wiphy->n_vendor_events = ARRAY_SIZE(sprdwl_vendor_events);
+	return 0;
+}
+
+int sprdwl_vendor_deinit(struct wiphy *wiphy)
+{
+	struct sprdwl_priv *priv = wiphy_priv(wiphy);
+
+	wiphy->vendor_commands = NULL;
+	wiphy->n_vendor_commands = 0;
+	kfree(priv->gscan_res);
+	kfree(priv->hotlist_res);
+	kfree(priv->significant_res);
+
+	return 0;
+}
diff --git a/drivers/net/wireless/uwe5622/unisocwifi/vendor.h b/drivers/net/wireless/uwe5622/unisocwifi/vendor.h
new file mode 100644
index 000000000000..d27e355e2322
--- /dev/null
+++ b/drivers/net/wireless/uwe5622/unisocwifi/vendor.h
@@ -0,0 +1,1684 @@
+/*
+ * Copyright (C) 2015 Spreadtrum Communications Inc.
+ *
+ * Authors	:
+ * Baolei Yuan <baolei.yuan@spreadtrum.com>
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#ifndef __SPRDWL_VENDOR_H__
+#define __SPRDWL_VENDOR_H__
+
+#include <net/netlink.h>
+#include <net/cfg80211.h>
+#include <linux/ctype.h>
+
+#define OUI_SPREAD 0x001374
+
+enum {
+	/* Memory dump of FW */
+	WIFI_LOGGER_MEMORY_DUMP_SUPPORTED = (1 << (0)),
+	/*PKT status*/
+	WIFI_LOGGER_PER_PACKET_TX_RX_STATUS_SUPPORTED = (1 << (1)),
+	/*Connectivity event*/
+	WIFI_LOGGER_CONNECT_EVENT_SUPPORTED = (1 << (2)),
+	/* POWER of Driver */
+	WIFI_LOGGER_POWER_EVENT_SUPPORTED = (1 << (3)),
+	/*WAKE LOCK of Driver*/
+	WIFI_LOGGER_WAKE_LOCK_SUPPORTED = (1 << (4)),
+	/*verbose log of FW*/
+	WIFI_LOGGER_VERBOSE_SUPPORTED = (1 << (5)),
+	/*monitor the health of FW*/
+	WIFI_LOGGER_WATCHDOG_TIMER_SUPPORTED = (1 << (6)),
+	/*dumps driver state*/
+	WIFI_LOGGER_DRIVER_DUMP_SUPPORTED = (1 << (7)),
+	/*tracks connection packets' fate*/
+	WIFI_LOGGER_PACKET_FATE_SUPPORTED = (1 << (8)),
+};
+
+enum sprdwl_wifi_error {
+	WIFI_SUCCESS = 0,
+	WIFI_ERROR_UNKNOWN = -1,
+	WIFI_ERROR_UNINITIALIZED = -2,
+	WIFI_ERROR_NOT_SUPPORTED = -3,
+	WIFI_ERROR_NOT_AVAILABLE = -4,
+	WIFI_ERROR_INVALID_ARGS = -5,
+	WIFI_ERROR_INVALID_REQUEST_ID = -6,
+	WIFI_ERROR_TIMED_OUT = -7,
+	WIFI_ERROR_TOO_MANY_REQUESTS = -8,
+	WIFI_ERROR_OUT_OF_MEMORY = -9,
+	WIFI_ERROR_BUSY = -10,
+};
+
+enum sprdwl_vendor_subcommand_id {
+	SPRDWL_VENDOR_SUBCMD_ROAMING = 9,
+	SPRDWL_VENDOR_SUBCMD_NAN = 12,
+	SPRDWL_VENDOR_SET_LLSTAT = 14,
+	SPRDWL_VENDOR_GET_LLSTAT = 15,
+	SPRDWL_VENDOR_CLR_LLSTAT = 16,
+	SPRDWL_VENDOR_SUBCMD_GSCAN_START = 20,
+	SPRDWL_VENDOR_SUBCMD_GSCAN_STOP = 21,
+	SPRDWL_VENDOR_SUBCMD_GSCAN_GET_CHANNEL = 22,
+	SPRDWL_VENDOR_SUBCMD_GSCAN_GET_CAPABILITIES = 23,
+	SPRDWL_VENDOR_SUBCMD_GSCAN_GET_CACHED_RESULTS = 24,
+	/* Used when report_threshold is reached in scan cache. */
+	SPRDWL_VENDOR_SUBCMD_GSCAN_SCAN_RESULTS_AVAILABLE = 25,
+	/* Used to report scan results when each probe rsp. is received,
+	* if report_events enabled in wifi_scan_cmd_params.
+	*/
+	SPRDWL_VENDOR_SUBCMD_GSCAN_FULL_SCAN_RESULT = 26,
+	/* Indicates progress of scanning state-machine. */
+	SPRDWL_VENDOR_SUBCMD_GSCAN_SCAN_EVENT = 27,
+	/* Indicates BSSID Hotlist. */
+	SPRDWL_VENDOR_SUBCMD_GSCAN_HOTLIST_AP_FOUND = 28,
+	SPRDWL_VENDOR_SUBCMD_GSCAN_SET_BSSID_HOTLIST = 29,
+	SPRDWL_VENDOR_SUBCMD_GSCAN_RESET_BSSID_HOTLIST = 30,
+	SPRDWL_VENDOR_SUBCMD_GSCAN_SIGNIFICANT_CHANGE = 31,
+	SPRDWL_VENDOR_SUBCMD_GSCAN_SET_SIGNIFICANT_CHANGE = 32,
+	SPRDWL_VENDOR_SUBCMD_GSCAN_RESET_SIGNIFICANT_CHANGE = 33,
+	SPRDWL_VENDOR_SUBCMD_GET_SUPPORT_FEATURE = 38,
+	SPRDWL_VENDOR_SUBCMD_SET_MAC_OUI = 39,
+	SPRDWL_VENDOR_SUBCMD_GSCAN_HOTLIST_AP_LOST = 41,
+	SPRDWL_VENDOR_SUBCMD_GET_CONCURRENCY_MATRIX = 42,
+	SPRDWL_VENDOR_SUBCMD_GET_FEATURE = 55,
+	SPRDWL_VENDOR_SUBCMD_GET_WIFI_INFO = 61,
+	SPRDWL_VENDOR_SUBCMD_START_LOGGING = 62,
+	SPRDWL_VENDOR_SUBCMD_WIFI_LOGGER_MEMORY_DUMP = 63,
+	SPRDWL_VENDOR_SUBCMD_ROAM = 64,
+	SPRDWL_VENDOR_SUBCMD_GSCAN_SET_SSID_HOTLIST = 65,
+	SPRDWL_VENDOR_SUBCMD_GSCAN_RESET_SSID_HOTLIST = 66,
+	SPRDWL_VENDOR_SUBCMD_PNO_SET_LIST = 69,
+	SPRDWL_VENDOR_SUBCMD_PNO_SET_PASSPOINT_LIST = 70,
+	SPRDWL_VENDOR_SUBCMD_PNO_RESET_PASSPOINT_LIST = 71,
+	SPRDWL_VENDOR_SUBCMD_PNO_NETWORK_FOUND = 72,
+	SPRDWL_VENDOR_SUBCMD_GET_LOGGER_FEATURE_SET = 76,
+	SPRDWL_VENDOR_SUBCMD_GET_RING_DATA = 77,
+	SPRDWL_VENDOR_SUBCMD_OFFLOADED_PACKETS = 79,
+	SPRDWL_VENDOR_SUBCMD_MONITOR_RSSI = 80,
+	SPRDWL_VENDOR_SUBCMD_ENABLE_ND_OFFLOAD = 82,
+	SPRDWL_VENDOR_SUBCMD_GET_WAKE_REASON_STATS = 85,
+	SPRDWL_VENDOR_SUBCMD_SET_SAR_LIMITS = 146,
+
+	SPRDWL_VENDOR_SUBCOMMAND_MAX
+};
+
+#define SPRDWL_VENDOR_EVENT_NAN_INDEX 32
+
+enum sprdwl_vendor_event {
+	SPRDWL_VENDOR_SUBCMD_MONITOR_RSSI_INDEX = 0,
+	/* NAN */
+	SPRDWL_VENDOR_EVENT_NAN = 0x1400,
+};
+
+/* attribute id */
+
+enum sprdwl_vendor_attr_gscan_id {
+	SPRDWL_VENDOR_ATTR_FEATURE_SET = 1,
+	SPRDWL_VENDOR_ATTR_GSCAN_NUM_CHANNELS = 3,
+	SPRDWL_VENDOR_ATTR_GSCAN_CHANNELS = 4,
+	SPRDWL_VENDOR_ATTR_MAX
+};
+
+enum sprdwl_vendor_attr_get_wifi_info {
+	SPRDWL_VENDOR_ATTR_WIFI_INFO_GET_INVALID = 0,
+	SPRDWL_VENDOR_ATTR_WIFI_INFO_DRIVER_VERSION = 1,
+	SPRDWL_VENDOR_ATTR_WIFI_INFO_FIRMWARE_VERSION = 2,
+};
+
+enum sprdwl_vendor_attribute {
+	SPRDWL_VENDOR_ATTR_UNSPEC,
+	SPRDWL_VENDOR_ATTR_GET_LLSTAT,
+	SPRDWL_VENDOR_ATTR_CLR_LLSTAT,
+	/* NAN */
+	SRPDWL_VENDOR_ATTR_NAN,
+	SPRDWL_VENDOR_ROAMING_POLICY = 5,
+};
+
+/*start of link layer stats, CMD ID:14,15,16*/
+enum sprdwl_wlan_vendor_attr_ll_stats_set {
+	SPRDWL_LL_STATS_SET_INVALID = 0,
+	/* Unsigned 32-bit value */
+	SPRDWL_LL_STATS_MPDU_THRESHOLD = 1,
+	SPRDWL_LL_STATS_GATHERING = 2,
+	/* keep last */
+	SPRDWL_LL_STATS_SET_AFTER_LAST,
+	SPRDWL_LL_STATS_SET_MAX =
+	SPRDWL_LL_STATS_SET_AFTER_LAST - 1,
+};
+
+static const struct nla_policy
+sprdwl_ll_stats_policy[SPRDWL_LL_STATS_SET_MAX + 1] = {
+	[SPRDWL_LL_STATS_MPDU_THRESHOLD] = { .type = NLA_U32 },
+	[SPRDWL_LL_STATS_GATHERING] = { .type = NLA_U32 },
+};
+
+enum sprdwl_vendor_attr_ll_stats_results {
+	SPRDWL_LL_STATS_INVALID = 0,
+	SPRDWL_LL_STATS_RESULTS_REQ_ID = 1,
+	SPRDWL_LL_STATS_IFACE_BEACON_RX = 2,
+	SPRDWL_LL_STATS_IFACE_MGMT_RX = 3,
+	SPRDWL_LL_STATS_IFACE_MGMT_ACTION_RX = 4,
+	SPRDWL_LL_STATS_IFACE_MGMT_ACTION_TX = 5,
+	SPRDWL_LL_STATS_IFACE_RSSI_MGMT = 6,
+	SPRDWL_LL_STATS_IFACE_RSSI_DATA = 7,
+	SPRDWL_LL_STATS_IFACE_RSSI_ACK = 8,
+	SPRDWL_LL_STATS_IFACE_INFO_MODE = 9,
+	SPRDWL_LL_STATS_IFACE_INFO_MAC_ADDR = 10,
+	SPRDWL_LL_STATS_IFACE_INFO_STATE = 11,
+	SPRDWL_LL_STATS_IFACE_INFO_ROAMING = 12,
+	SPRDWL_LL_STATS_IFACE_INFO_CAPABILITIES = 13,
+	SPRDWL_LL_STATS_IFACE_INFO_SSID = 14,
+	SPRDWL_LL_STATS_IFACE_INFO_BSSID = 15,
+	SPRDWL_LL_STATS_IFACE_INFO_AP_COUNTRY_STR = 16,
+	SPRDWL_LL_STATS_IFACE_INFO_COUNTRY_STR = 17,
+	SPRDWL_LL_STATS_WMM_AC_AC = 18,
+	SPRDWL_LL_STATS_WMM_AC_TX_MPDU = 19,
+	SPRDWL_LL_STATS_WMM_AC_RX_MPDU = 20,
+	SPRDWL_LL_STATS_WMM_AC_TX_MCAST = 21,
+	SPRDWL_LL_STATS_WMM_AC_RX_MCAST = 22,
+	SPRDWL_LL_STATS_WMM_AC_RX_AMPDU = 23,
+	SPRDWL_LL_STATS_WMM_AC_TX_AMPDU = 24,
+	SPRDWL_LL_STATS_WMM_AC_MPDU_LOST = 25,
+	SPRDWL_LL_STATS_WMM_AC_RETRIES = 26,
+	SPRDWL_LL_STATS_WMM_AC_RETRIES_SHORT = 27,
+	SPRDWL_LL_STATS_WMM_AC_RETRIES_LONG = 28,
+	SPRDWL_LL_STATS_WMM_AC_CONTENTION_TIME_MIN = 29,
+	SPRDWL_LL_STATS_WMM_AC_CONTENTION_TIME_MAX = 30,
+	SPRDWL_LL_STATS_WMM_AC_CONTENTION_TIME_AVG = 31,
+	SPRDWL_LL_STATS_WMM_AC_CONTENTION_NUM_SAMPLES = 32,
+	SPRDWL_LL_STATS_IFACE_NUM_PEERS = 33,
+	SPRDWL_LL_STATS_PEER_INFO_TYPE = 34,
+	SPRDWL_LL_STATS_PEER_INFO_MAC_ADDRESS = 35,
+	SPRDWL_LL_STATS_PEER_INFO_CAPABILITIES = 36,
+	SPRDWL_LL_STATS_PEER_INFO_NUM_RATES = 37,
+	SPRDWL_LL_STATS_RATE_PREAMBLE = 38,
+	SPRDWL_LL_STATS_RATE_NSS = 39,
+	SPRDWL_LL_STATS_RATE_BW = 40,
+	SPRDWL_LL_STATS_RATE_MCS_INDEX = 41,
+	SPRDWL_LL_STATS_RATE_BIT_RATE = 42,
+	SPRDWL_LL_STATS_RATE_TX_MPDU = 43,
+	SPRDWL_LL_STATS_RATE_RX_MPDU = 44,
+	SPRDWL_LL_STATS_RATE_MPDU_LOST = 45,
+	SPRDWL_LL_STATS_RATE_RETRIES = 46,
+	SPRDWL_LL_STATS_RATE_RETRIES_SHORT = 47,
+	SPRDWL_LL_STATS_RATE_RETRIES_LONG = 48,
+	SPRDWL_LL_STATS_RADIO_ID = 49,
+	SPRDWL_LL_STATS_RADIO_ON_TIME = 50,
+	SPRDWL_LL_STATS_RADIO_TX_TIME = 51,
+	SPRDWL_LL_STATS_RADIO_RX_TIME = 52,
+	SPRDWL_LL_STATS_RADIO_ON_TIME_SCAN = 53,
+	SPRDWL_LL_STATS_RADIO_ON_TIME_NBD = 54,
+	SPRDWL_LL_STATS_RADIO_ON_TIME_GSCAN = 55,
+	SPRDWL_LL_STATS_RADIO_ON_TIME_ROAM_SCAN = 56,
+	SPRDWL_LL_STATS_RADIO_ON_TIME_PNO_SCAN = 57,
+	SPRDWL_LL_STATS_RADIO_ON_TIME_HS20 = 58,
+	SPRDWL_LL_STATS_RADIO_NUM_CHANNELS = 59,
+	SPRDWL_LL_STATS_CHANNEL_INFO_WIDTH = 60,
+	SPRDWL_LL_STATS_CHANNEL_INFO_CENTER_FREQ = 61,
+	SPRDWL_LL_STATS_CHANNEL_INFO_CENTER_FREQ0 = 62,
+	SPRDWL_LL_STATS_CHANNEL_INFO_CENTER_FREQ1 = 63,
+	SPRDWL_LL_STATS_CHANNEL_ON_TIME = 64,
+	SPRDWL_LL_STATS_CHANNEL_CCA_BUSY_TIME = 65,
+	SPRDWL_LL_STATS_NUM_RADIOS = 66,
+	SPRDWL_LL_STATS_CH_INFO = 67,
+	SPRDWL_LL_STATS_PEER_INFO = 68,
+	SPRDWL_LL_STATS_PEER_INFO_RATE_INFO = 69,
+	SPRDWL_LL_STATS_WMM_INFO = 70,
+	SPRDWL_LL_STATS_RESULTS_MORE_DATA = 71,
+	SPRDWL_LL_STATS_IFACE_AVERAGE_TSF_OFFSET = 72,
+	SPRDWL_LL_STATS_IFACE_LEAKY_AP_DETECTED = 73,
+	SPRDWL_LL_STATS_IFACE_LEAKY_AP_AVG_NUM_FRAMES_LEAKED = 74,
+	SPRDWL_LL_STATS_IFACE_LEAKY_AP_GUARD_TIME = 75,
+	SPRDWL_LL_STATS_TYPE = 76,
+	SPRDWL_LL_STATS_RADIO_NUM_TX_LEVELS = 77,
+	SPRDWL_LL_STATS_RADIO_TX_TIME_PER_LEVEL = 78,
+	SPRDWL_LL_STATS_IFACE_RTS_SUCC_CNT = 79,
+	SPRDWL_LL_STATS_IFACE_RTS_FAIL_CNT = 80,
+	SPRDWL_LL_STATS_IFACE_PPDU_SUCC_CNT = 81,
+	SPRDWL_LL_STATS_IFACE_PPDU_FAIL_CNT = 82,
+
+	/* keep last */
+	SPRDWL_LL_STATS_AFTER_LAST,
+	SPRDWL_LL_STATS_MAX =
+	SPRDWL_LL_STATS_AFTER_LAST - 1,
+};
+
+enum sprdwl_wlan_vendor_attr_ll_stats_type {
+	SPRDWL_NL80211_VENDOR_SUBCMD_LL_STATS_TYPE_INVALID = 0,
+	SPRDWL_NL80211_VENDOR_SUBCMD_LL_STATS_TYPE_RADIO = 1,
+	SPRDWL_NL80211_VENDOR_SUBCMD_LL_STATS_TYPE_IFACE = 2,
+	SPRDWL_NL80211_VENDOR_SUBCMD_LL_STATS_TYPE_PEERS = 3,
+
+	/* keep last */
+	SPRDWL_NL80211_VENDOR_SUBCMD_LL_STATS_TYPE_AFTER_LAST,
+	SPRDWL_NL80211_VENDOR_SUBCMD_LL_STATS_TYPE_MAX =
+	SPRDWL_NL80211_VENDOR_SUBCMD_LL_STATS_TYPE_AFTER_LAST - 1,
+};
+
+enum sprdwl_attr_ll_stats_clr {
+	SPRDWL_LL_STATS_CLR_INVALID = 0,
+	SPRDWL_LL_STATS_CLR_CONFIG_REQ_MASK = 1,
+	SPRDWL_LL_STATS_CLR_CONFIG_STOP_REQ = 2,
+	SPRDWL_LL_STATS_CLR_CONFIG_RSP_MASK = 3,
+	SPRDWL_LL_STATS_CLR_CONFIG_STOP_RSP = 4,
+	/* keep last */
+	SPRDWL_LL_STATS_CLR_AFTER_LAST,
+	SPRDWL_LL_STATS_CLR_MAX =
+	SPRDWL_LL_STATS_CLR_AFTER_LAST - 1,
+};
+
+/*end of link layer stats*/
+
+/*start of gscan----CMD ID:23*/
+struct sprdwl_gscan_capa {
+	s16 max_scan_cache_size;
+	u8 max_scan_buckets;
+	u8 max_ap_cache_per_scan;
+	u8 max_rssi_sample_size;
+	u8 max_scan_reporting_threshold;
+	u8 max_hotlist_bssids;
+	u8 max_hotlist_ssids;
+	u8 max_significant_wifi_change_aps;
+	u8 max_bssid_history_entries;
+	u8 max_number_epno_networks;
+	u8 max_number_epno_networks_by_ssid;
+	u8 max_whitelist_ssid;
+	u8 max_blacklist_size;
+};
+
+struct sprdwl_roam_capa {
+	u32 max_blacklist_size;
+	u32 max_whitelist_size;
+};
+
+enum sprdwl_vendor_attr_gscan_results {
+	GSCAN_RESULTS_INVALID = 0,
+
+	/* Unsigned 32-bit value; must match the request Id supplied by
+	 * Wi-Fi HAL in the corresponding subcmd NL msg.
+	 */
+	GSCAN_RESULTS_REQUEST_ID = 1,
+
+	/* Unsigned 32-bit value; used to indicate the status response from
+	 * firmware/driver for the vendor sub-command.
+	 */
+	GSCAN_STATUS = 2,
+
+	/* GSCAN Valid Channels attributes */
+	/* Unsigned 32bit value; followed by a nested array of CHANNELS. */
+	GSCAN_RESULTS_NUM_CHANNELS = 3,
+	/* An array of NUM_CHANNELS x unsigned 32-bit value integers
+	 * representing channel numbers.
+	 */
+	GSCAN_RESULTS_CHANNELS = 4,
+
+	/* GSCAN Capabilities attributes */
+	/* Unsigned 32-bit value */
+	GSCAN_SCAN_CACHE_SIZE = 5,
+	/* Unsigned 32-bit value */
+	GSCAN_MAX_SCAN_BUCKETS = 6,
+	/* Unsigned 32-bit value */
+	GSCAN_MAX_AP_CACHE_PER_SCAN = 7,
+	/* Unsigned 32-bit value */
+	GSCAN_MAX_RSSI_SAMPLE_SIZE = 8,
+	/* Signed 32-bit value */
+	GSCAN_MAX_SCAN_REPORTING_THRESHOLD = 9,
+	/* Unsigned 32-bit value */
+	GSCAN_MAX_HOTLIST_BSSIDS = 10,
+	/* Unsigned 32-bit value */
+	GSCAN_MAX_SIGNIFICANT_WIFI_CHANGE_APS = 11,
+	/* Unsigned 32-bit value */
+	GSCAN_MAX_BSSID_HISTORY_ENTRIES = 12,
+
+	/* GSCAN Attributes used with
+	 * GSCAN_SCAN_RESULTS_AVAILABLE sub-command.
+	 */
+
+	/* Unsigned 32-bit value */
+	GSCAN_RESULTS_NUM_RESULTS_AVAILABLE = 13,
+
+	/* GSCAN attributes used with
+	 * GSCAN_FULL_SCAN_RESULT sub-command.
+	 */
+
+	/* An array of NUM_RESULTS_AVAILABLE x
+	 * GSCAN_RESULTS_SCAN_RESULT_*
+	 */
+	GSCAN_RESULTS_LIST = 14,
+
+	/* Unsigned 64-bit value; age of sample at the time of retrieval */
+	GSCAN_RESULTS_SCAN_RESULT_TIME_STAMP = 15,
+	/* 33 x unsigned 8-bit value; NULL terminated SSID */
+	GSCAN_RESULTS_SCAN_RESULT_SSID = 16,
+	/* An array of 6 x unsigned 8-bit value */
+	GSCAN_RESULTS_SCAN_RESULT_BSSID = 17,
+	/* Unsigned 32-bit value; channel frequency in MHz */
+	GSCAN_RESULTS_SCAN_RESULT_CHANNEL = 18,
+	/* Signed 32-bit value */
+	GSCAN_RESULTS_SCAN_RESULT_RSSI = 19,
+	/* Unsigned 32-bit value */
+	GSCAN_RESULTS_SCAN_RESULT_RTT = 20,
+	/* Unsigned 32-bit value */
+	GSCAN_RESULTS_SCAN_RESULT_RTT_SD = 21,
+	/* Unsigned 16-bit value */
+	GSCAN_RESULTS_SCAN_RESULT_BEACON_PERIOD = 22,
+	/* Unsigned 16-bit value */
+	GSCAN_RESULTS_SCAN_RESULT_CAPABILITY = 23,
+	/* Unsigned 32-bit value; size of the IE DATA blob */
+	GSCAN_RESULTS_SCAN_RESULT_IE_LENGTH = 24,
+	/* An array of IE_LENGTH x unsigned 8-bit value; blob of all the
+	 * information elements found in the beacon; this data should be a
+	 * packed list of wifi_information_element objects, one after the
+	 * other.
+	 */
+	GSCAN_RESULTS_SCAN_RESULT_IE_DATA = 25,
+
+	/* Unsigned 8-bit value; set by driver to indicate more scan results are
+	 * available.
+	 */
+	GSCAN_RESULTS_SCAN_RESULT_MORE_DATA = 26,
+
+	/* GSCAN attributes for
+	 * GSCAN_SCAN_EVENT sub-command.
+	 */
+	/* Unsigned 8-bit value */
+	GSCAN_RESULTS_SCAN_EVENT_TYPE = 27,
+	/* Unsigned 32-bit value */
+	GSCAN_RESULTS_SCAN_EVENT_STATUS = 28,
+
+	/* GSCAN attributes for
+	 * GSCAN_HOTLIST_AP_FOUND sub-command.
+	 */
+	/* Use attr GSCAN_RESULTS_NUM_RESULTS_AVAILABLE
+	 * to indicate number of results.
+	 * Also, use GSCAN_RESULTS_LIST to indicate the
+	 * list of results.
+	 */
+
+	/* GSCAN attributes for
+	 * GSCAN_SIGNIFICANT_CHANGE sub-command.
+	 */
+	/* An array of 6 x unsigned 8-bit value */
+	GSCAN_RESULTS_SIGNIFICANT_CHANGE_RESULT_BSSID = 29,
+	/* Unsigned 32-bit value */
+	GSCAN_RESULTS_SIGNIFICANT_CHANGE_RESULT_CHANNEL = 30,
+	/* Unsigned 32-bit value. */
+	GSCAN_RESULTS_SIGNIFICANT_CHANGE_RESULT_NUM_RSSI = 31,
+	/* A nested array of signed 32-bit RSSI values. Size of the array is
+	 * determined by (NUM_RSSI of SIGNIFICANT_CHANGE_RESULT_NUM_RSSI.
+	 */
+	GSCAN_RESULTS_SIGNIFICANT_CHANGE_RESULT_RSSI_LIST = 32,
+
+	/* GSCAN attributes used with
+	 * GSCAN_GET_CACHED_RESULTS sub-command.
+	 */
+	/* Use attr GSCAN_RESULTS_NUM_RESULTS_AVAILABLE
+	 * to indicate number of gscan cached results returned.
+	 * Also, use GSCAN_CACHED_RESULTS_LIST to indicate
+	 *  the list of gscan cached results.
+	 */
+
+	/* An array of NUM_RESULTS_AVAILABLE x
+	 * NL80211_VENDOR_ATTR_GSCAN_CACHED_RESULTS_*
+	 */
+	GSCAN_CACHED_RESULTS_LIST = 33,
+	/* Unsigned 32-bit value; a unique identifier for the scan unit. */
+	GSCAN_CACHED_RESULTS_SCAN_ID = 34,
+	/* Unsigned 32-bit value; a bitmask w/additional information about scan.
+	 */
+	GSCAN_CACHED_RESULTS_FLAGS = 35,
+	/* Use attr GSCAN_ATTR_RESULTS_NUM_RESULTS_AVAILABLE
+	 * to indicate number of wifi scan results/bssids retrieved by the scan.
+	 * Also, use GSCAN_ATTR_RESULTS_LIST to indicate the
+	 * list of wifi scan results returned for each cached result block.
+	 */
+
+	/* GSCAN attributes for
+	 * NL80211_VENDOR_SUBCMD_PNO_NETWORK_FOUND sub-command.
+	 */
+	/* Use GSCAN_ATTR_RESULTS_NUM_RESULTS_AVAILABLE for
+	 * number of results.
+	 * Use GSCAN_ATTR_RESULTS_LIST to indicate the nested
+	 * list of wifi scan results returned for each
+	 * wifi_passpoint_match_result block.
+	 * Array size: GSCAN_ATTR_RESULTS_NUM_RESULTS_AVAILABLE.
+	 */
+
+	/* GSCAN attributes for
+	 * NL80211_VENDOR_SUBCMD_PNO_PASSPOINT_NETWORK_FOUND sub-command.
+	 */
+	/* Unsigned 32-bit value */
+	GSCAN_PNO_RESULTS_PASSPOINT_NETWORK_FOUND_NUM_MATCHES = 36,
+	/* A nested array of
+	 * GSCAN_ATTR_PNO_RESULTS_PASSPOINT_MATCH_*
+	 * attributes. Array size =
+	 * *_ATTR_GSCAN_PNO_RESULTS_PASSPOINT_NETWORK_FOUND_NUM_MATCHES.
+	 */
+	GSCAN_PNO_RESULTS_PASSPOINT_MATCH_RESULT_LIST = 37,
+
+	/* Unsigned 32-bit value; network block id for the matched network */
+	GSCAN_PNO_RESULTS_PASSPOINT_MATCH_ID = 38,
+	/* Use GSCAN_ATTR_RESULTS_LIST to indicate the nested
+	 * list of wifi scan results returned for each
+	 * wifi_passpoint_match_result block.
+	 */
+	/* Unsigned 32-bit value */
+	GSCAN_PNO_RESULTS_PASSPOINT_MATCH_ANQP_LEN = 39,
+	/* An array size of PASSPOINT_MATCH_ANQP_LEN of unsigned 8-bit values;
+	 * ANQP data in the information_element format.
+	 */
+	GSCAN_PNO_RESULTS_PASSPOINT_MATCH_ANQP = 40,
+
+	/* Unsigned 32-bit value; a GSCAN Capabilities attribute. */
+	GSCAN_MAX_HOTLIST_SSIDS = 41,
+	/* Unsigned 32-bit value; a GSCAN Capabilities attribute. */
+	GSCAN_MAX_NUM_EPNO_NETS = 42,
+	/* Unsigned 32-bit value; a GSCAN Capabilities attribute. */
+	GSCAN_MAX_NUM_EPNO_NETS_BY_SSID = 43,
+	/* Unsigned 32-bit value; a GSCAN Capabilities attribute. */
+	GSCAN_MAX_NUM_WHITELISTED_SSID = 44,
+
+	GSCAN_RESULTS_BUCKETS_SCANNED = 45,
+	/* Unsigned 32bit value; a GSCAN Capabilities attribute. */
+	GSCAN_MAX_NUM_BLACKLISTED_BSSID = 46,
+
+	/* keep last */
+	GSCAN_RESULTS_AFTER_LAST,
+	GSCAN_RESULTS_MAX =
+	GSCAN_RESULTS_AFTER_LAST - 1,
+};
+
+enum sprdwl_vendor_attr_set_scanning_mac_oui {
+	WLAN_VENDOR_ATTR_SET_SCANNING_MAC_OUI_INVALID = 0,
+	WLAN_VENDOR_ATTR_SET_SCANNING_MAC_OUI = 1,
+	/* keep last */
+	WLAN_VENDOR_ATTR_SET_SCANNING_MAC_OUI_AFTER_LAST,
+	WLAN_VENDOR_ATTR_SET_SCANNING_MAC_OUI_MAX =
+	WLAN_VENDOR_ATTR_SET_SCANNING_MAC_OUI_AFTER_LAST - 1,
+};
+
+/*end of gscan capability---CMD ID:23*/
+
+/*start of get supported feature---CMD ID:38*/
+/* Feature enums */
+/* Basic infrastructure mode */
+#define WIFI_FEATURE_INFRA              0x0001
+/* Support for 5 GHz Band */
+#define WIFI_FEATURE_INFRA_5G           0x0002
+/* Support for GAS/ANQP */
+#define WIFI_FEATURE_HOTSPOT            0x0004
+/* Wifi-Direct */
+#define WIFI_FEATURE_P2P                0x0008
+/* Soft AP */
+#define WIFI_FEATURE_SOFT_AP            0x0010
+/* Google-Scan APIs */
+#define WIFI_FEATURE_GSCAN              0x0020
+/* Neighbor Awareness Networking */
+#define WIFI_FEATURE_NAN                0x0040
+/* Device-to-device RTT */
+#define WIFI_FEATURE_D2D_RTT            0x0080
+/* Device-to-AP RTT */
+#define WIFI_FEATURE_D2AP_RTT           0x0100
+/* Batched Scan (legacy) */
+#define WIFI_FEATURE_BATCH_SCAN         0x0200
+/* Preferred network offload */
+#define WIFI_FEATURE_PNO                0x0400
+/* Support for two STAs */
+#define WIFI_FEATURE_ADDITIONAL_STA     0x0800
+/* Tunnel directed link setup */
+#define WIFI_FEATURE_TDLS               0x1000
+/* Support for TDLS off channel */
+#define WIFI_FEATURE_TDLS_OFFCHANNEL    0x2000
+/* Enhanced power reporting */
+#define WIFI_FEATURE_EPR                0x4000
+/* Support for AP STA Concurrency */
+#define WIFI_FEATURE_AP_STA             0x8000
+/* Link layer stats collection */
+#define WIFI_FEATURE_LINK_LAYER_STATS   0x10000
+/* WiFi Logger */
+#define WIFI_FEATURE_LOGGER             0x20000
+/* WiFi PNO enhanced */
+#define WIFI_FEATURE_HAL_EPNO           0x40000
+/* RSSI Monitor */
+#define WIFI_FEATURE_RSSI_MONITOR       0x80000
+/* WiFi mkeep_alive */
+#define WIFI_FEATURE_MKEEP_ALIVE        0x100000
+/* ND offload configure */
+#define WIFI_FEATURE_CONFIG_NDO         0x200000
+/* Capture Tx transmit power levels */
+#define WIFI_FEATURE_TX_TRANSMIT_POWER  0x400000
+/* Enable/Disable firmware roaming */
+#define WIFI_FEATURE_CONTROL_ROAMING    0x800000
+/* Support Probe IE white listing */
+#define WIFI_FEATURE_IE_WHITELIST       0x1000000
+/* Support MAC & Probe Sequence Number randomization */
+#define WIFI_FEATURE_SCAN_RAND          0x2000000
+
+/*end of get supported feature---CMD ID:38*/
+
+/*start of get supported feature---CMD ID:42*/
+
+#define CDS_MAX_FEATURE_SET   8
+
+/*enum wlan_vendor_attr_get_concurrency_matrix - get concurrency matrix*/
+enum wlan_vendor_attr_get_concurrency_matrix {
+	SPRDWL_ATTR_CO_MATRIX_INVALID = 0,
+	SPRDWL_ATTR_CO_MATRIX_CONFIG_PARAM_SET_SIZE_MAX = 1,
+	SPRDWL_ATTR_CO_MATRIX_RESULTS_SET_SIZE = 2,
+	SPRDWL_ATTR_CO_MATRIX_RESULTS_SET = 3,
+	SPRDWL_ATTR_CO_MATRIX_AFTER_LAST,
+	SPRDWL_ATTR_CO_MATRIX_MAX =
+	 SPRDWL_ATTR_CO_MATRIX_AFTER_LAST - 1,
+};
+
+/*end of get supported feature---CMD ID:42*/
+
+/*start of get wifi info----CMD ID:61*/
+enum sprdwl_attr_get_wifi_info {
+	SPRDWL_ATTR_WIFI_INFO_GET_INVALID = 0,
+	SPRDWL_ATTR_WIFI_INFO_DRIVER_VERSION = 1,
+	SPRDWL_ATTR_WIFI_INFO_FIRMWARE_VERSION = 2,
+	SPRDWL_ATTR_WIFI_INFO_GET_AFTER_LAST,
+	SPRDWL_ATTR_WIFI_INFO_GET_MAX =
+		SPRDWL_ATTR_WIFI_INFO_GET_AFTER_LAST - 1,
+};
+
+/*end of get wifi info----CMD ID:61*/
+
+/*start of roaming data structure,CMD ID:64,CMD ID:9*/
+enum fw_roaming_state {
+	ROAMING_DISABLE,
+	ROAMING_ENABLE
+};
+
+enum sprdwl_attr_roaming_config_params {
+	SPRDWL_ROAM_INVALID = 0,
+	SPRDWL_ROAM_SUBCMD = 1,
+	SPRDWL_ROAM_REQ_ID = 2,
+	SPRDWL_ROAM_WHITE_LIST_SSID_NUM_NETWORKS = 3,
+	SPRDWL_ROAM_WHITE_LIST_SSID_LIST = 4,
+	SPRDWL_ROAM_WHITE_LIST_SSID = 5,
+	SPRDWL_ROAM_A_BAND_BOOST_THRESHOLD = 6,
+	SPRDWL_ROAM_A_BAND_PENALTY_THRESHOLD = 7,
+	SPRDWL_ROAM_A_BAND_BOOST_FACTOR = 8,
+	SPRDWL_ROAM_A_BAND_PENALTY_FACTOR = 9,
+	SPRDWL_ROAM_A_BAND_MAX_BOOST = 10,
+	SPRDWL_ROAM_LAZY_ROAM_HISTERESYS = 11,
+	SPRDWL_ROAM_ALERT_ROAM_RSSI_TRIGGER = 12,
+	/* Attribute for set_lazy_roam */
+	SPRDWL_ROAM_SET_LAZY_ROAM_ENABLE = 13,
+	/* Attribute for set_lazy_roam with preferences */
+	SPRDWL_ROAM_SET_BSSID_PREFS = 14,
+	SPRDWL_ROAM_SET_LAZY_ROAM_NUM_BSSID = 15,
+	SPRDWL_ROAM_SET_LAZY_ROAM_BSSID = 16,
+	SPRDWL_ROAM_SET_LAZY_ROAM_RSSI_MODIFIER = 17,
+	/* Attribute for set_blacklist bssid params */
+	SPRDWL_ROAM_SET_BSSID_PARAMS = 18,
+	SPRDWL_ROAM_SET_BSSID_PARAMS_NUM_BSSID = 19,
+	SPRDWL_ROAM_SET_BSSID_PARAMS_BSSID = 20,
+	/* keep last */
+	SPRDWL_ROAM_AFTER_LAST,
+	SPRDWL_ROAM_MAX =
+	SPRDWL_ROAM_AFTER_LAST - 1,
+};
+
+enum sprdwl_attr_roam_subcmd {
+	SPRDWL_ATTR_ROAM_SUBCMD_INVALID = 0,
+	SPRDWL_ATTR_ROAM_SUBCMD_SSID_WHITE_LIST = 1,
+	SPRDWL_ATTR_ROAM_SUBCMD_SET_GSCAN_ROAM_PARAMS = 2,
+	SPRDWL_ATTR_ROAM_SUBCMD_SET_LAZY_ROAM = 3,
+	SPRDWL_ATTR_ROAM_SUBCMD_SET_BSSID_PREFS = 4,
+	SPRDWL_ATTR_ROAM_SUBCMD_SET_BSSID_PARAMS = 5,
+	SPRDWL_ATTR_ROAM_SUBCMD_SET_BLACKLIST_BSSID = 6,
+	/*KEEP LAST*/
+	SPRDWL_ATTR_ROAM_SUBCMD_AFTER_LAST,
+	SPRDWL_ATTR_ROAM_SUBCMD_MAX =
+	SPRDWL_ATTR_ROAM_SUBCMD_AFTER_LAST - 1,
+};
+
+#define MAX_WHITE_SSID 4
+#define MAX_BLACK_BSSID  16
+
+struct ssid_t {
+	uint32_t length;
+	char ssid_str[IEEE80211_MAX_SSID_LEN];
+} __packed;
+
+struct bssid_t {
+	uint8_t MAC_addr[ETH_ALEN];
+} __packed;
+
+struct roam_white_list_params {
+	uint8_t num_white_ssid;
+	struct ssid_t white_list[MAX_WHITE_SSID];
+} __packed;
+
+struct roam_black_list_params {
+	uint8_t num_black_bssid;
+	struct bssid_t black_list[MAX_BLACK_BSSID];
+} __packed;
+
+/*end of roaming data structure,CMD ID:64*/
+
+/*RSSI monitor start */
+
+enum sprdwl_rssi_monitor_control {
+	WLAN_RSSI_MONITORING_CONTROL_INVALID = 0,
+	WLAN_RSSI_MONITORING_START,
+	WLAN_RSSI_MONITORING_STOP,
+};
+
+/* struct rssi_monitor_req - rssi monitoring
+ * @request_id: request id
+ * @session_id: session id
+ * @min_rssi: minimum rssi
+ * @max_rssi: maximum rssi
+ * @control: flag to indicate start or stop
+ */
+struct rssi_monitor_req {
+	uint32_t request_id;
+	int8_t   min_rssi;
+	int8_t   max_rssi;
+	bool control;
+} __packed;
+
+struct rssi_monitor_event {
+	uint32_t     request_id;
+	int8_t       curr_rssi;
+	uint8_t curr_bssid[ETH_ALEN];
+};
+
+#define EVENT_BUF_SIZE (1024)
+
+enum sprdwl_attr_rssi_monitoring {
+	SPRDWL_ATTR__RSSI_MONITORING_INVALID = 0,
+	SPRDWL_ATTR_RSSI_MONITORING_CONTROL,
+	SPRDWL_ATTR_RSSI_MONITORING_REQUEST_ID,
+	SPRDWL_ATTR_RSSI_MONITORING_MAX_RSSI,
+	SPRDWL_ATTR_RSSI_MONITORING_MIN_RSSI,
+	/* attributes to be used/received in callback */
+	SPRDWL_ATTR_RSSI_MONITORING_CUR_BSSID,
+	SPRDWL_ATTR_RSSI_MONITORING_CUR_RSSI,
+	/* keep last */
+	SPRDWL_ATTR_RSSI_MONITORING_AFTER_LAST,
+	SPRDWL_ATTR_RSSI_MONITORING_MAX =
+	SPRDWL_ATTR_RSSI_MONITORING_AFTER_LAST - 1,
+};
+
+/*RSSI monitor End*/
+
+enum wifi_connection_state {
+	WIFI_DISCONNECTED = 0,
+	WIFI_AUTHENTICATING = 1,
+	WIFI_ASSOCIATING = 2,
+	WIFI_ASSOCIATED = 3,
+	WIFI_EAPOL_STARTED = 4,
+	WIFI_EAPOL_COMPLETED = 5,
+};
+
+enum wifi_roam_state {
+	WIFI_ROAMING_IDLE = 0,
+	WIFI_ROAMING_ACTIVE = 1,
+};
+
+/* access categories */
+enum wifi_traffic_ac {
+	WIFI_AC_VO = 0,
+	WIFI_AC_VI = 1,
+	WIFI_AC_BE = 2,
+	WIFI_AC_BK = 3,
+	WIFI_AC_MAX = 4,
+};
+
+/* configuration params */
+struct wifi_link_layer_params {
+	u32 mpdu_size_threshold;
+	u32 aggressive_statistics_gathering;
+} __packed;
+
+struct wifi_clr_llstat_rsp {
+	u32 stats_clear_rsp_mask;
+	u8 stop_rsp;
+};
+
+/* wifi rate */
+struct wifi_rate {
+	u32 preamble:3;
+	u32 nss:2;
+	u32 bw:3;
+	u32 ratemcsidx:8;
+	u32 reserved:16;
+	u32 bitrate;
+};
+
+struct wifi_rate_stat {
+	struct wifi_rate rate;
+	u32 tx_mpdu;
+	u32 rx_mpdu;
+	u32 mpdu_lost;
+	u32 retries;
+	u32 retries_short;
+	u32 retries_long;
+};
+
+/* per peer statistics */
+struct wifi_peer_info {
+	u8 type;
+	u8 peer_mac_address[6];
+	u32 capabilities;
+	u32 num_rate;
+	struct wifi_rate_stat rate_stats[];
+};
+
+struct wifi_interface_link_layer_info {
+	enum sprdwl_mode mode;
+	u8 mac_addr[6];
+	enum wifi_connection_state state;
+	enum wifi_roam_state roaming;
+	u32 capabilities;
+	u8 ssid[33];
+	u8 bssid[6];
+	u8 ap_country_str[3];
+	u8 country_str[3];
+};
+
+/* Per access category statistics */
+struct wifi_wmm_ac_stat {
+	enum wifi_traffic_ac ac;
+	u32 tx_mpdu;
+	u32 rx_mpdu;
+	u32 tx_mcast;
+	u32 rx_mcast;
+	u32 rx_ampdu;
+	u32 tx_ampdu;
+	u32 mpdu_lost;
+	u32 retries;
+	u32 retries_short;
+	u32 retries_long;
+	u32 contention_time_min;
+	u32 contention_time_max;
+	u32 contention_time_avg;
+	u32 contention_num_samples;
+};
+
+/* interface statistics */
+struct wifi_iface_stat {
+	void *iface;
+	struct wifi_interface_link_layer_info info;
+	u32 beacon_rx;
+	u64 average_tsf_offset;
+	u32 leaky_ap_detected;
+	u32 leaky_ap_avg_num_frames_leaked;
+	u32 leaky_ap_guard_time;
+	u32 mgmt_rx;
+	u32 mgmt_action_rx;
+	u32 mgmt_action_tx;
+	int rssi_mgmt;
+	u32 rssi_data;
+	u32 rssi_ack;
+	struct wifi_wmm_ac_stat ac[WIFI_AC_MAX];
+	u32 num_peers;
+	struct wifi_peer_info peer_info[];
+};
+
+/* WiFi Common definitions */
+/* channel operating width */
+enum wifi_channel_width {
+	WIFI_CHAN_WIDTH_20 = 0,
+	WIFI_CHAN_WIDTH_40 = 1,
+	WIFI_CHAN_WIDTH_80 = 2,
+	WIFI_CHAN_WIDTH_160 = 3,
+	WIFI_CHAN_WIDTH_80P80 = 4,
+	WIFI_CHAN_WIDTH_5 = 5,
+	WIFI_CHAN_WIDTH_10 = 6,
+	WIFI_CHAN_WIDTH_INVALID = -1
+};
+
+/* channel information */
+struct wifi_channel_info {
+	enum wifi_channel_width width;
+	u32 center_freq;
+	u32 center_freq0;
+	u32 center_freq1;
+};
+
+/* channel statistics */
+struct wifi_channel_stat {
+	struct wifi_channel_info channel;
+	u32 on_time;
+	u32 cca_busy_time;
+};
+
+/* radio statistics */
+struct wifi_radio_stat {
+	u32 radio;
+	u32 on_time;
+	u32 tx_time;
+	u32 num_tx_levels;
+	u32 *tx_time_per_levels;
+	u32 rx_time;
+	u32 on_time_scan;
+	u32 on_time_nbd;
+	u32 on_time_gscan;
+	u32 on_time_roam_scan;
+	u32 on_time_pno_scan;
+	u32 on_time_hs20;
+	u32 num_channels;
+	struct wifi_channel_stat channels[];
+};
+
+struct sprdwl_wmm_ac_stat {
+	u32 tx_mpdu;
+	u32 rx_mpdu;
+	u32 tx_mpdu_lost;
+	u32 tx_retries;
+};
+
+struct sprdwl_llstat_data {
+	int rssi_mgmt;
+	u32 bcn_rx_cnt;
+	struct sprdwl_wmm_ac_stat ac[WIFI_AC_MAX];
+	u32 on_time;
+	u32 on_time_scan;
+	u64 radio_tx_time;
+	u64 radio_rx_time;
+};
+
+struct sprdwl_llstat_radio {
+	int rssi_mgmt;
+	u32 bcn_rx_cnt;
+	struct sprdwl_wmm_ac_stat ac[WIFI_AC_MAX];
+};
+
+
+struct sprdwl_vendor_data {
+	struct wifi_radio_stat radio_st;
+	struct wifi_iface_stat iface_st;
+};
+
+/*end of link layer stats*/
+
+/*start of wake stats---CMD ID:85*/
+enum sprdwl_wake_stats {
+	WLAN_ATTR_GET_WAKE_STATS_INVALID = 0,
+	WLAN_ATTR_TOTAL_CMD_EVENT_WAKE,
+	WLAN_ATTR_CMD_EVENT_WAKE_CNT_PTR,
+	WLAN_ATTR_CMD_EVENT_WAKE_CNT_SZ,
+	WLAN_ATTR_TOTAL_DRIVER_FW_LOCAL_WAKE,
+	WLAN_ATTR_DRIVER_FW_LOCAL_WAKE_CNT_PTR,
+	WLAN_ATTR_DRIVER_FW_LOCAL_WAKE_CNT_SZ,
+	WLAN_ATTR_TOTAL_RX_DATA_WAKE,
+	WLAN_ATTR_RX_UNICAST_CNT,
+	WLAN_ATTR_RX_MULTICAST_CNT,
+	WLAN_ATTR_RX_BROADCAST_CNT,
+	WLAN_ATTR_ICMP_PKT,
+	WLAN_ATTR_ICMP6_PKT,
+	WLAN_ATTR_ICMP6_RA,
+	WLAN_ATTR_ICMP6_NA,
+	WLAN_ATTR_ICMP6_NS,
+	WLAN_ATTR_ICMP4_RX_MULTICAST_CNT,
+	WLAN_ATTR_ICMP6_RX_MULTICAST_CNT,
+	WLAN_ATTR_OTHER_RX_MULTICAST_CNT,
+	/* keep last */
+	WLAN_GET_WAKE_STATS_AFTER_LAST,
+	WLAN_GET_WAKE_STATS_MAX =
+	    WLAN_GET_WAKE_STATS_AFTER_LAST - 1,
+};
+
+/*end of wake sats---CMD ID:85*/
+
+
+/*start of SAR limit---- CMD ID:146*/
+enum sprdwl_vendor_sar_limits_select {
+	WLAN_SAR_LIMITS_BDF0 = 0,
+	WLAN_SAR_LIMITS_BDF1 = 1,
+	WLAN_SAR_LIMITS_BDF2 = 2,
+	WLAN_SAR_LIMITS_BDF3 = 3,
+	WLAN_SAR_LIMITS_BDF4 = 4,
+	WLAN_SAR_LIMITS_NONE = 5,
+	WLAN_SAR_LIMITS_USER = 6,
+};
+
+enum sprdwl_vendor_attr_sar_limits {
+	WLAN_ATTR_SAR_LIMITS_INVALID = 0,
+	WLAN_ATTR_SAR_LIMITS_SAR_ENABLE = 1,
+	WLAN_ATTR_SAR_LIMITS_NUM_SPECS = 2,
+	WLAN_ATTR_SAR_LIMITS_SPEC = 3,
+	WLAN_ATTR_SAR_LIMITS_SPEC_BAND = 4,
+	WLAN_ATTR_SAR_LIMITS_SPEC_CHAIN = 5,
+	WLAN_ATTR_SAR_LIMITS_SPEC_MODULATION = 6,
+	WLAN_ATTR_SAR_LIMITS_SPEC_POWER_LIMIT = 7,
+	WLAN_ATTR_SAR_LIMITS_AFTER_LAST,
+	WLAN_ATTR_SAR_LIMITS_MAX =
+		WLAN_ATTR_SAR_LIMITS_AFTER_LAST - 1
+};
+/*end of SAR limit---CMD ID:146*/
+int sprdwl_vendor_init(struct wiphy *wiphy);
+int sprdwl_vendor_deinit(struct wiphy *wiphy);
+
+#define MAX_CHANNELS 16
+#define MAX_BUCKETS 4
+#define MAX_HOTLIST_APS 16
+#define MAX_WHITELIST_APS 16
+#define MAX_PREFER_APS 16
+#define MAX_BLACKLIST_BSSID 16
+#define MAX_SIGNIFICANT_CHANGE_APS 16
+#define MAX_AP_CACHE_PER_SCAN 32
+#define MAX_CHANNLES_NUM 14
+
+#define MAX_EPNO_NETWORKS 16
+
+enum sprdwl_vendor_attr_gscan_config_params {
+	GSCAN_ATTR_SUBCMD_CONFIG_PARAM_INVALID = 0,
+	/* Unsigned 32-bit value; Middleware provides it to the driver.
+	*Middle ware either gets it from caller, e.g., framework,
+	or generates one if framework doesn't provide it.
+	*/
+
+	GSCAN_ATTR_SUBCMD_CONFIG_PARAM_REQUEST_ID,
+
+	/* NL attributes for data used by
+	* NL80211_VENDOR_SUBCMD_GSCAN_GET_VALID_CHANNELS sub command.
+	*/
+	/* Unsigned 32-bit value */
+	GSCAN_ATTR_GET_VALID_CHANNELS_CONFIG_PARAM_WIFI_BAND,
+	/* Unsigned 32-bit value */
+	GSCAN_ATTR_GET_VALID_CHANNELS_CONFIG_PARAM_MAX_CHANNELS,
+
+	/* NL attributes for input params used by
+	 * NL80211_VENDOR_SUBCMD_GSCAN_START sub command.
+	*/
+
+	/* Unsigned 32-bit value; channel frequency */
+	GSCAN_ATTR_CHANNEL_SPEC_CHANNEL,
+	/* Unsigned 32-bit value; dwell time in ms. */
+	GSCAN_ATTR_CHANNEL_SPEC_DWELL_TIME,
+	/* Unsigned 8-bit value; 0: active; 1: passive; N/A for DFS */
+	GSCAN_ATTR_CHANNEL_SPEC_PASSIVE,
+	/* Unsigned 8-bit value; channel class */
+	GSCAN_ATTR_CHANNEL_SPEC_CLASS,
+
+	/* Unsigned 8-bit value; bucket index, 0 based */
+	GSCAN_ATTR_BUCKET_SPEC_INDEX,
+	/* Unsigned 8-bit value; band. */
+	GSCAN_ATTR_BUCKET_SPEC_BAND,
+	/* Unsigned 32-bit value; desired period, in ms. */
+	GSCAN_ATTR_BUCKET_SPEC_PERIOD = 10,
+	/* Unsigned 8-bit value; report events semantics. */
+	GSCAN_ATTR_BUCKET_SPEC_REPORT_EVENTS,
+	/* Unsigned 32-bit value. Followed by a nested array of
+	* GSCAN_CHANNEL_SPECS attributes.
+	*/
+	GSCAN_ATTR_BUCKET_SPEC_NUM_CHANNEL_SPECS,
+
+	/* Array of GSCAN_ATTR_CHANNEL_SPEC_* attributes.
+	* Array size: GSCAN_ATTR_BUCKET_SPEC_NUM_CHANNEL_SPECS
+	*/
+	GSCAN_ATTR_CHANNEL_SPEC,
+
+	/* Unsigned 32-bit value; base timer period in ms. */
+	GSCAN_ATTR_SCAN_CMD_PARAMS_BASE_PERIOD,
+	/* Unsigned 32-bit value; number of APs to store in each scan in the
+	* BSSID/RSSI history buffer (keep the highest RSSI APs).
+	*/
+	GSCAN_ATTR_SCAN_CMD_PARAMS_MAX_AP_PER_SCAN = 15,
+
+	/* Unsigned 8-bit value; In %, when scan buffer is this much full,
+	*wake up APPS.
+	*/
+	GSCAN_ATTR_SCAN_CMD_PARAMS_REPORT_THR,
+
+	/* Unsigned 8-bit value; number of scan bucket specs; followed by
+	*a nested array of_GSCAN_BUCKET_SPEC_* attributes and values.
+	*The size of the array is determined by NUM_BUCKETS.
+	*/
+	GSCAN_ATTR_SCAN_CMD_PARAMS_NUM_BUCKETS,
+
+	/* Array of GSCAN_ATTR_BUCKET_SPEC_* attributes.
+	* Array size: GSCAN_ATTR_SCAN_CMD_PARAMS_NUM_BUCKETS
+	*/
+	GSCAN_ATTR_BUCKET_SPEC,
+
+	/* Unsigned 8-bit value */
+	GSCAN_ATTR_GET_CACHED_SCAN_RESULTS_CONFIG_PARAM_FLUSH,
+	/* Unsigned 32-bit value; maximum number of results to be returned. */
+	GSCAN_ATTR_GET_CACHED_SCAN_RESULTS_CONFIG_PARAM_MAX = 20,
+
+	/* An array of 6 x Unsigned 8-bit value */
+	GSCAN_ATTR_AP_THR_PARAM_BSSID,
+	/* Signed 32-bit value */
+	GSCAN_ATTR_AP_THR_PARAM_RSSI_LOW,
+	/* Signed 32-bit value */
+	GSCAN_ATTR_AP_THR_PARAM_RSSI_HIGH,
+	/* Unsigned 32-bit value */
+	GSCAN_ATTR_AP_THR_PARAM_CHANNEL,
+
+	/* Number of hotlist APs as unsigned 32-bit value, followed by a nested
+	* array of AP_THR_PARAM attributes and values. The size of the
+	* array is determined by NUM_AP.
+	*/
+	GSCAN_ATTR_BSSID_HOTLIST_PARAMS_NUM_AP = 25,
+
+	/* Array of GSCAN_ATTR_AP_THR_PARAM_* attributes.
+	* Array size: GSCAN_ATTR_BUCKET_SPEC_NUM_CHANNEL_SPECS
+	*/
+	GSCAN_ATTR_AP_THR_PARAM,
+
+	/* Unsigned 32bit value; number of samples for averaging RSSI. */
+	GSCAN_ATTR_SIGNIFICANT_CHANGE_PARAMS_RSSI_SAMPLE_SIZE,
+	/* Unsigned 32bit value; number of samples to confirm AP loss. */
+	GSCAN_ATTR_SIGNIFICANT_CHANGE_PARAMS_LOST_AP_SAMPLE_SIZE,
+	/* Unsigned 32bit value; number of APs breaching threshold. */
+	GSCAN_ATTR_SIGNIFICANT_CHANGE_PARAMS_MIN_BREACHING,
+	/* Unsigned 32bit value; number of APs. Followed by an array of
+	* AP_THR_PARAM attributes. Size of the array is NUM_AP.
+	*/
+	GSCAN_ATTR_SIGNIFICANT_CHANGE_PARAMS_NUM_AP = 30,
+	GSCAN_ATTR_BSSID_HOTLIST_PARAMS_LOST_AP_SAMPLE_SIZE,
+
+	GSCAN_ATTR_BUCKET_SPEC_MAX_PERIOD = 32,
+	/* Unsigned 32-bit value. */
+	GSCAN_ATTR_BUCKET_SPEC_BASE = 33,
+	/* Unsigned 32-bit value. For exponential back off bucket, number of
+	 * scans to perform for a given period.
+	 */
+	GSCAN_ATTR_BUCKET_SPEC_STEP_COUNT = 34,
+
+	GSCAN_ATTR_SCAN_CMD_PARAMS_REPORT_THR_NUM_SCANS = 35,
+	/* Unsigned 3-2bit value; number of samples to confirm SSID loss. */
+	GSCAN_ATTR_GSCAN_SSID_HOTLIST_PARAMS_LOST_SSID_SAMPLE_SIZE = 36,
+	/* Number of hotlist SSIDs as unsigned 32-bit value, followed by a
+	 * nested array of SSID_THRESHOLD_PARAM_* attributes and values. The
+	 * size of the array is determined by NUM_SSID.
+	 */
+	GSCAN_ATTR_GSCAN_SSID_HOTLIST_PARAMS_NUM_SSID = 37,
+	/* Array of GSCAN_ATTR_GSCAN_SSID_THRESHOLD_PARAM_*
+	 * attributes.
+	 * Array size: GSCAN_ATTR_GSCAN_SSID_HOTLIST_PARAMS_NUM_SSID
+	 */
+	GSCAN_ATTR_GSCAN_SSID_THR_PARAM = 38,
+
+	/* An array of 33 x unsigned 8-bit value; NULL terminated SSID */
+	GSCAN_ATTR_GSCAN_SSID_THR_PARAM_SSID = 39,
+	/* Unsigned 8-bit value */
+	GSCAN_ATTR_GSCAN_SSID_THR_PARAM_BAND = 40,
+	/* Signed 32-bit value */
+	GSCAN_ATTR_GSCAN_SSID_THR_PARAM_RSSI_LOW = 41,
+	/* Signed 32-bit value */
+	GSCAN_ATTR_GSCAN_SSID_THR_PARAM_RSSI_HIGH = 42,
+
+	/* keep last */
+	GSCAN_ATTR_SUBCMD_CONFIG_PARAM_AFTER_LAST,
+	GSCAN_ATTR_SUBCMD_CONFIG_PARAM_MAX =
+	GSCAN_ATTR_SUBCMD_CONFIG_PARAM_AFTER_LAST - 1,
+
+};
+enum nl80211_vendor_subcmds_index {
+	NL80211_VENDOR_SUBCMD_LL_STATS_SET_INDEX,
+	NL80211_VENDOR_SUBCMD_LL_STATS_GET_INDEX,
+	NL80211_VENDOR_SUBCMD_LL_STATS_CLR_INDEX,
+	NL80211_VENDOR_SUBCMD_LL_RADIO_STATS_INDEX,
+	NL80211_VENDOR_SUBCMD_LL_IFACE_STATS_INDEX,
+	NL80211_VENDOR_SUBCMD_LL_PEER_INFO_STATS_INDEX,
+	/* GSCAN Events */
+	NL80211_VENDOR_SUBCMD_GSCAN_START_INDEX,
+	NL80211_VENDOR_SUBCMD_GSCAN_STOP_INDEX,
+	NL80211_VENDOR_SUBCMD_GSCAN_GET_CAPABILITIES_INDEX,
+	NL80211_VENDOR_SUBCMD_GSCAN_GET_CACHED_RESULTS_INDEX,
+	NL80211_VENDOR_SUBCMD_GSCAN_SCAN_RESULTS_AVAILABLE_INDEX,
+	NL80211_VENDOR_SUBCMD_GSCAN_FULL_SCAN_RESULT_INDEX,
+	NL80211_VENDOR_SUBCMD_GSCAN_SCAN_EVENT_INDEX,
+	NL80211_VENDOR_SUBCMD_GSCAN_HOTLIST_AP_FOUND_INDEX,
+	NL80211_VENDOR_SUBCMD_GSCAN_HOTLIST_AP_LOST_INDEX,
+	NL80211_VENDOR_SUBCMD_GSCAN_SET_BSSID_HOTLIST_INDEX,
+	NL80211_VENDOR_SUBCMD_GSCAN_RESET_BSSID_HOTLIST_INDEX,
+	NL80211_VENDOR_SUBCMD_SIGNIFICANT_CHANGE_INDEX,
+	NL80211_VENDOR_SUBCMD_SET_SIGNIFICANT_CHANGE_INDEX,
+	NL80211_VENDOR_SUBCMD_RESET_SIGNIFICANT_CHANGE_INDEX,
+	/*EXT TDLS*/
+	NL80211_VENDOR_SUBCMD_TDLS_STATE_CHANGE_INDEX,
+	NL80211_VENDOR_SUBCMD_NAN_INDEX,
+};
+enum sprdwl_gscan_attribute {
+	GSCAN_NUM_BUCKETS = 1,
+	GSCAN_BASE_PERIOD,
+	GSCAN_BUCKETS_BAND,
+	GSCAN_BUCKET_ID,
+	GSCAN_BUCKET_PERIOD,
+	GSCAN_BUCKET_NUM_CHANNELS,
+	GSCAN_BUCKET_CHANNELS,
+	GSCAN_BUCKET_SPEC,
+	GSCAN_BUCKET_CHANNELS_SPEC,
+	GSCAN_CH_DWELL_TIME,
+	GSCAN_CH_PASSIVE,
+	GSCAN_NUM_AP_PER_SCAN,
+	GSCAN_REPORT_THRESHOLD,
+	GSCAN_NUM_SCANS_TO_CACHE,
+	GSCAN_BAND = GSCAN_BUCKETS_BAND,
+
+	GSCAN_ENABLE_FEATURE,
+	GSCAN_SCAN_RESULTS_COMPLETE,	/* indicates no more results */
+	GSCAN_FLUSH_FEATURE,	/* Flush all the configs */
+	GSCAN_FULL_SCAN_RESULTS,
+	GSCAN_REPORT_EVENTS,
+
+	/* remaining reserved for additional attributes */
+	GSCAN_NUM_OF_RESULTS,
+	GSCAN_FLUSH_RESULTS,
+	GSCAN_ATT_SCAN_RESULTS,	/* flat array of wifi_scan_result */
+	GSCAN_SCAN_ID,	/* indicates scan number */
+	GSCAN_SCAN_FLAGS,	/* indicates if scan was aborted */
+	GSCAN_AP_FLAGS,	/* flags on significant change event */
+	GSCAN_NUM_CHANNELS,
+	GSCAN_CHANNEL_LIST,
+
+	/* remaining reserved for additional attributes */
+
+	/* Adaptive scan attributes */
+	GSCAN_BUCKET_STEP_COUNT,
+	GSCAN_BUCKET_MAX_PERIOD,
+
+	GSCAN_SSID,
+	GSCAN_BSSID,
+	GSCAN_CHANNEL,
+	GSCAN_RSSI,
+	GSCAN_TIMESTAMP,
+	GSCAN_RTT,
+	GSCAN_RTTSD,
+
+	/* remaining reserved for additional attributes */
+
+	GSCAN_HOTLIST_BSSIDS,
+	GSCAN_RSSI_LOW,
+	GSCAN_RSSI_HIGH,
+	GSCAN_HOTLIST_ELEM,
+	GSCAN_HOTLIST_FLUSH,
+
+	/* remaining reserved for additional attributes */
+	GSCAN_RSSI_SAMPLE_SIZE,
+	GSCAN_LOST_AP_SAMPLE_SIZE,
+	GSCAN_MIN_BREACHING,
+	GSCAN_SIGNIFICANT_CHANGE_BSSIDS,
+	GSCAN_SIGNIFICANT_CHANGE_FLUSH,
+
+	/* remaining reserved for additional attributes */
+
+	GSCAN_WHITELIST_SSID,
+	GSCAN_NUM_WL_SSID,
+	/*GSCAN_WL_SSID_LEN,*/
+	GSCAN_WL_SSID_FLUSH,
+	GSCAN_WHITELIST_SSID_ELEM,
+	GSCAN_NUM_BSSID,
+	GSCAN_BSSID_PREF_LIST,
+	GSCAN_BSSID_PREF_FLUSH,
+	GSCAN_BSSID_PREF,
+	GSCAN_RSSI_MODIFIER,
+
+	/* remaining reserved for additional attributes */
+
+	GSCAN_A_BAND_BOOST_THRESHOLD,
+	GSCAN_A_BAND_PENALTY_THRESHOLD,
+	GSCAN_A_BAND_BOOST_FACTOR,
+	GSCAN_A_BAND_PENALTY_FACTOR,
+	GSCAN_A_BAND_MAX_BOOST,
+	GSCAN_LAZY_ROAM_HYSTERESIS,
+	GSCAN_ALERT_ROAM_RSSI_TRIGGER,
+	GSCAN_LAZY_ROAM_ENABLE,
+
+	/* BSSID blacklist */
+	GSCAN_BSSID_BLACKLIST_FLUSH,
+	GSCAN_BLACKLIST_BSSID,
+	GSCAN_BLACKLIST_BSSID_SPEC,
+
+	/* ANQPO */
+	GSCAN_ANQPO_HS_LIST,
+	GSCAN_ANQPO_HS_LIST_SIZE,
+	GSCAN_ANQPO_HS_NETWORK_ID,
+	GSCAN_ANQPO_HS_NAI_REALM,
+	GSCAN_ANQPO_HS_ROAM_CONSORTIUM_ID,
+	GSCAN_ANQPO_HS_PLMN,
+
+	GSCAN_SSID_HOTLIST_FLUSH,
+	GSCAN_SSID_LOST_SAMPLE_SIZE,
+	GSCAN_HOTLIST_SSIDS,
+	GSCAN_SSID_RSSI_HIGH,
+	GSCAN_SSID_RSSI_LOW,
+	GSCAN_ANQPO_LIST_FLUSH,
+	ANDR_WIFI_ATTRIBUTE_PNO_RANDOM_MAC_OUI,
+
+	GSCAN_MAX
+};
+
+enum SPRD_wlan_vendor_attr_pno_config_params {
+	SPRD_WLAN_VENDOR_ATTR_PNO_INVALID = 0,
+	/* Attributes for data used by
+	 * SPRD_NL80211_VENDOR_SUBCMD_PNO_SET_PASSPOINT_LIST sub command.
+	 */
+	/* Unsigned 32-bit value */
+	SPRD_WLAN_VENDOR_ATTR_PNO_PASSPOINT_LIST_PARAM_NUM = 1,
+	/* Array of nested SPRD_WLAN_VENDOR_ATTR_PNO_PASSPOINT_NETWORK_PARAM_*
+	 * attributes. Array size =
+	 * SPRD_WLAN_VENDOR_ATTR_PNO_PASSPOINT_LIST_PARAM_NUM.
+	 */
+	SPRD_WLAN_VENDOR_ATTR_PNO_PASSPOINT_LIST_PARAM_NETWORK_ARRAY = 2,
+
+	/* Unsigned 32-bit value */
+	SPRD_WLAN_VENDOR_ATTR_PNO_PASSPOINT_NETWORK_PARAM_ID = 3,
+	/* An array of 256 x unsigned 8-bit value; NULL terminated UTF-8 encoded
+	 * realm, 0 if unspecified.
+	 */
+	SPRD_WLAN_VENDOR_ATTR_PNO_PASSPOINT_NETWORK_PARAM_REALM = 4,
+	/* An array of 16 x unsigned 32-bit value; roaming consortium ids to
+	 * match, 0 if unspecified.
+	 */
+	SPRD_WLAN_VENDOR_ATTR_PNO_PASSPOINT_NETWORK_PARAM_ROAM_CNSRTM_ID = 5,
+	/* An array of 6 x unsigned 8-bit value; MCC/MNC combination, 0s if
+	 * unspecified.
+	 */
+	SPRD_WLAN_VENDOR_ATTR_PNO_PASSPOINT_NETWORK_PARAM_ROAM_PLMN = 6,
+
+	/* Attributes for data used by
+	 * SPRD_NL80211_VENDOR_SUBCMD_PNO_SET_LIST sub command.
+	 */
+	/* Unsigned 32-bit value */
+	SPRD_WLAN_VENDOR_ATTR_PNO_SET_LIST_PARAM_NUM_NETWORKS = 7,
+	/* Array of nested
+	 * SPRD_WLAN_VENDOR_ATTR_PNO_SET_LIST_PARAM_EPNO_NETWORK_*
+	 * attributes. Array size =
+	 * SPRD_WLAN_VENDOR_ATTR_PNO_SET_LIST_PARAM_NUM_NETWORKS.
+	 */
+	SPRD_WLAN_VENDOR_ATTR_PNO_SET_LIST_PARAM_EPNO_NETWORKS_LIST = 8,
+	/* An array of 33 x unsigned 8-bit value; NULL terminated SSID */
+	SPRD_WLAN_VENDOR_ATTR_PNO_SET_LIST_PARAM_EPNO_NETWORK_SSID = 9,
+	/* Signed 8-bit value; threshold for considering this SSID as found,
+	 * required granularity for this threshold is 4 dBm to 8 dBm.
+	 */
+	SPRD_WLAN_VENDOR_ATTR_PNO_SET_LIST_PARAM_EPNO_NETWORK_RSSI_THRESHOLD
+	= 10,
+	/* Unsigned 8-bit value; WIFI_PNO_FLAG_XXX */
+	SPRD_WLAN_VENDOR_ATTR_PNO_SET_LIST_PARAM_EPNO_NETWORK_FLAGS = 11,
+	/* Unsigned 8-bit value; auth bit field for matching WPA IE */
+	SPRD_WLAN_VENDOR_ATTR_PNO_SET_LIST_PARAM_EPNO_NETWORK_AUTH_BIT = 12,
+	/* Unsigned 8-bit to indicate ePNO type;
+	 * It takes values from SPRD_wlan_epno_type
+	 */
+	SPRD_WLAN_VENDOR_ATTR_PNO_SET_LIST_PARAM_EPNO_TYPE = 13,
+
+	/* Nested attribute to send the channel list */
+	SPRD_WLAN_VENDOR_ATTR_PNO_SET_LIST_PARAM_EPNO_CHANNEL_LIST = 14,
+
+	/* Unsigned 32-bit value; indicates the interval between PNO scan
+	 * cycles in msec.
+	 */
+	SPRD_WLAN_VENDOR_ATTR_PNO_SET_LIST_PARAM_EPNO_SCAN_INTERVAL = 15,
+	SPRD_WLAN_VENDOR_ATTR_EPNO_MIN5GHZ_RSSI = 16,
+	SPRD_WLAN_VENDOR_ATTR_EPNO_MIN24GHZ_RSSI = 17,
+	SPRD_WLAN_VENDOR_ATTR_EPNO_INITIAL_SCORE_MAX = 18,
+	SPRD_WLAN_VENDOR_ATTR_EPNO_CURRENT_CONNECTION_BONUS = 19,
+	SPRD_WLAN_VENDOR_ATTR_EPNO_SAME_NETWORK_BONUS = 20,
+	SPRD_WLAN_VENDOR_ATTR_EPNO_SECURE_BONUS = 21,
+	SPRD_WLAN_VENDOR_ATTR_EPNO_BAND5GHZ_BONUS = 22,
+
+	/* keep last */
+	SPRD_WLAN_VENDOR_ATTR_PNO_AFTER_LAST,
+	SPRD_WLAN_VENDOR_ATTR_PNO_MAX =
+	SPRD_WLAN_VENDOR_ATTR_PNO_AFTER_LAST - 1,
+};
+
+#define SPRDWL_EPNO_PARAM_NETWORK_SSID \
+	SPRD_WLAN_VENDOR_ATTR_PNO_SET_LIST_PARAM_EPNO_NETWORK_SSID
+#define SPRDWL_EPNO_PARAM_MIN5GHZ_RSSI \
+	SPRD_WLAN_VENDOR_ATTR_EPNO_MIN5GHZ_RSSI
+#define SPRDWL_EPNO_PARAM_MIN24GHZ_RSSI  \
+	SPRD_WLAN_VENDOR_ATTR_EPNO_MIN24GHZ_RSSI
+#define SPRDWL_EPNO_PARAM_INITIAL_SCORE_MAX \
+	SPRD_WLAN_VENDOR_ATTR_EPNO_INITIAL_SCORE_MAX
+#define SPRDWL_EPNO_PARAM_CURRENT_CONNECTION_BONUS \
+	SPRD_WLAN_VENDOR_ATTR_EPNO_CURRENT_CONNECTION_BONUS
+#define SPRDWL_EPNO_PARAM_SAME_NETWORK_BONUS \
+	SPRD_WLAN_VENDOR_ATTR_EPNO_SAME_NETWORK_BONUS
+#define SPRDWL_EPNO_PARAM_SECURE_BONUS \
+	SPRD_WLAN_VENDOR_ATTR_EPNO_SECURE_BONUS
+#define SPRDWL_EPNO_PARAM_BAND5GHZ_BONUS \
+	SPRD_WLAN_VENDOR_ATTR_EPNO_BAND5GHZ_BONUS
+#define SPRDWL_EPNO_PARAM_NUM_NETWORKS \
+	 SPRD_WLAN_VENDOR_ATTR_PNO_SET_LIST_PARAM_NUM_NETWORKS
+#define SPRDWL_EPNO_PARAM_NETWORKS_LIST \
+	SPRD_WLAN_VENDOR_ATTR_PNO_SET_LIST_PARAM_EPNO_NETWORKS_LIST
+
+#define SPRDWL_EPNO_PARAM_NETWORK_SSID \
+	SPRD_WLAN_VENDOR_ATTR_PNO_SET_LIST_PARAM_EPNO_NETWORK_SSID
+#define SPRDWL_EPNO_PARAM_NETWORK_FLAGS \
+	SPRD_WLAN_VENDOR_ATTR_PNO_SET_LIST_PARAM_EPNO_NETWORK_FLAGS
+#define SPRDWL_EPNO_PARAM_NETWORK_AUTH_BIT \
+	SPRD_WLAN_VENDOR_ATTR_PNO_SET_LIST_PARAM_EPNO_NETWORK_AUTH_BIT
+#define SPRDWL_VENDOR_EVENT_EPNO_FOUND \
+	SPRDWL_VENDOR_SUBCMD_PNO_NETWORK_FOUND
+
+enum sprdwl_gscan_wifi_band {
+	WIFI_BAND_UNSPECIFIED,
+	WIFI_BAND_BG = 1,
+	WIFI_BAND_A = 2,
+	WIFI_BAND_A_DFS = 4,
+	WIFI_BAND_A_WITH_DFS = 6,
+	WIFI_BAND_ABG = 3,
+	WIFI_BAND_ABG_WITH_DFS = 7,
+};
+
+enum sprdwl_gscan_wifi_event {
+	SPRD_RESERVED1,
+	SPRD_RESERVED2,
+	GSCAN_EVENT_SIGNIFICANT_CHANGE_RESULTS,
+	GSCAN_EVENT_HOTLIST_RESULTS_FOUND,
+	GSCAN_EVENT_SCAN_RESULTS_AVAILABLE,
+	GSCAN_EVENT_FULL_SCAN_RESULTS,
+	RTT_EVENT_COMPLETE,
+	GSCAN_EVENT_COMPLETE_SCAN,
+	GSCAN_EVENT_HOTLIST_RESULTS_LOST,
+	GSCAN_EVENT_EPNO_EVENT,
+	GOOGLE_DEBUG_RING_EVENT,
+	GOOGLE_DEBUG_MEM_DUMP_EVENT,
+	GSCAN_EVENT_ANQPO_HOTSPOT_MATCH,
+	GOOGLE_RSSI_MONITOR_EVENT,
+	GSCAN_EVENT_SSID_HOTLIST_RESULTS_FOUND,
+	GSCAN_EVENT_SSID_HOTLIST_RESULTS_LOST,
+
+};
+
+struct sprdwl_gscan_channel_spec {
+	u8 channel;
+	u8 dwelltime;
+	u8 passive;
+	u8 resv;
+};
+
+#define REPORT_EVENTS_BUFFER_FULL      0
+#define REPORT_EVENTS_EACH_SCAN        (1<<0)
+#define REPORT_EVENTS_FULL_RESULTS     (1<<1)
+#define REPORT_EVENTS_NO_BATCH         (1<<2)
+
+#define REPORT_EVENTS_HOTLIST_RESULTS_FOUND         (1<<3)
+#define REPORT_EVENTS_HOTLIST_RESULTS_LOST         (1<<4)
+#define REPORT_EVENTS_SIGNIFICANT_CHANGE         (1<<5)
+#define REPORT_EVENTS_EPNO         (1<<6)
+#define REPORT_EVENTS_ANQPO_HOTSPOT_MATCH         (1<<7)
+#define REPORT_EVENTS_SSID_HOTLIST_RESULTS_FOUND         (1<<8)
+#define REPORT_EVENTS_SSID_HOTLIST_RESULTS_LOST         (1<<9)
+
+enum sprdwl_gscan_event {
+	WIFI_SCAN_BUFFER_FULL,
+	WIFI_SCAN_COMPLETE,
+};
+
+struct sprdwl_gscan_bucket_spec {
+	u8 bucket;
+	u8 band;
+	u8 num_channels;
+	u8 base;
+	u8 step_count;
+	u8 reserved;	/*reserved for data align*/
+	u16 report_events;
+	u32 period;
+	u32 max_period;
+	struct sprdwl_gscan_channel_spec channels[MAX_CHANNELS];
+};
+
+struct sprdwl_cmd_gscan_set_config {
+	u32 base_period;
+	u8 maxAPperScan;
+	u8 reportThreshold;
+	u8 report_threshold_num_scans;
+	u8 num_buckets;
+	struct sprdwl_gscan_bucket_spec buckets[MAX_BUCKETS];
+};
+
+struct sprdwl_cmd_gscan_rsp_header {
+	u8 subcmd;
+	u8 status;
+	u16 data_len;
+} __packed;
+
+struct sprdwl_cmd_gscan_channel_list {
+	int num_channels;
+	int channels[TOTAL_2G_5G_CHANNEL_NUM];
+};
+
+struct sprdwl_gscan_result {
+	unsigned long ts;
+	char ssid[32 + 1];
+	char bssid[ETH_ALEN];
+	u8 channel;
+	s8 rssi;
+	u32 rtt;
+	u32 rtt_sd;
+	u16 beacon_period;
+	u16 capability;
+	u16 ie_length;
+	char ie_data[1];
+} __packed;
+
+struct sprdwl_gscan_cached_results {
+	u8 scan_id;
+	u8 flags;
+	int num_results;
+	struct sprdwl_gscan_result results[MAX_AP_CACHE_PER_SCAN];
+};
+
+struct sprdwl_gscan_hotlist_results {
+	int req_id;
+	u8 flags;
+	int num_results;
+	struct sprdwl_gscan_result results[MAX_HOTLIST_APS];
+};
+
+struct ssid_threshold_param {
+	unsigned char ssid[IEEE80211_MAX_SSID_LEN];	/* AP SSID*/
+	s8 low;		/* low threshold*/
+	s8 high;		/* low threshold*/
+};
+
+struct wifi_ssid_hotlist_params {
+	u8 lost_ssid_sample_size; /* number of samples to confirm AP loss*/
+	u8 num_ssid;	/* number of hotlist APs*/
+	struct ssid_threshold_param ssid[MAX_HOTLIST_APS];	/* hotlist APs*/
+};
+
+struct ap_threshold_param {
+	unsigned char bssid[6];	/* AP BSSID*/
+	s8 low;		/* low threshold*/
+	s8 high;		/* low threshold*/
+};
+
+struct wifi_bssid_hotlist_params {
+	u8 lost_ap_sample_size; /* number of samples to confirm AP loss*/
+	u8 num_bssid;	/* number of hotlist APs*/
+	struct ap_threshold_param ap[MAX_HOTLIST_APS];	/* hotlist APs*/
+};
+
+struct wifi_significant_change_params {
+	u8 rssi_sample_size; /*number of samples for averaging RSSI */
+	u8 lost_ap_sample_size;/*number of samples to confirm AP loss*/
+	u8 min_breaching;/*number of APs breaching threshold */
+	u8 num_bssid;/*max 64*/
+	struct ap_threshold_param ap[MAX_SIGNIFICANT_CHANGE_APS];
+};
+
+struct significant_change_info {
+	unsigned char bssid[6];	/* AP BSSID*/
+	u8 channel;		/*channel frequency in MHz*/
+	u8 num_rssi;			/*number of rssi samples*/
+	s8 rssi[3];		/*RSSI history in db, here fixed 3*/
+} __packed;
+
+struct sprdwl_significant_change_result {
+	int req_id;
+	u8 flags;
+	int num_results;
+	struct significant_change_info results[MAX_SIGNIFICANT_CHANGE_APS];
+};
+
+struct wifi_epno_network {
+	u8 ssid[32 + 1];
+	/* threshold for considering this SSID as found required
+	 *granularity for this threshold is 4dBm to 8dBm
+	 */
+	/* unsigned char rssi_threshold; */
+	u8 flags; /* WIFI_PNO_FLAG_XXX*/
+	u8 auth_bit_field; /* auth bit field for matching WPA IE*/
+} __packed;
+
+struct wifi_epno_params {
+	u64 boot_time;
+	u8 request_id;
+	/* minimum 5GHz RSSI for a BSSID to be considered */
+	s8 min5ghz_rssi;
+
+	/* minimum 2.4GHz RSSI for a BSSID to be considered */
+	s8 min24ghz_rssi;
+
+	/* the maximum score that a network can have before bonuses */
+	s8 initial_score_max;
+
+	/* only report when there is a network's score this much higher */
+    /* than the current connection. */
+	s8 current_connection_bonus;
+
+	/* score bonus for all networks with the same network flag */
+	s8 same_network_bonus;
+
+	/* score bonus for networks that are not open */
+	s8 secure_bonus;
+
+	/* 5GHz RSSI score bonus (applied to all 5GHz networks) */
+	s8 band5ghz_bonus;
+
+	/* number of wifi_epno_network objects */
+	s8 num_networks;
+
+	/* PNO networks */
+	struct wifi_epno_network networks[MAX_EPNO_NETWORKS];
+} __packed;
+
+struct sprdwl_epno_results {
+	u64 boot_time;
+	u8 request_id;
+	u8 nr_scan_results;
+	struct sprdwl_gscan_result results[0];
+} __packed;
+
+struct wifi_ssid {
+	char ssid[32+1]; /* null terminated*/
+};
+
+
+struct wifi_roam_params {
+    /* Lazy roam parameters
+     * A_band_XX parameters are applied to 5GHz BSSIDs when comparing with
+     * a 2.4GHz BSSID they may not be applied when comparing two 5GHz BSSIDs
+	 */
+
+	/* RSSI threshold above which 5GHz RSSI is favored*/
+	int A_band_boost_threshold;
+
+	/* RSSI threshold below which 5GHz RSSI is penalized*/
+	int A_band_penalty_threshold;
+
+	/* factor by which 5GHz RSSI is boosted*/
+	/*boost=RSSI_measured-5GHz_boost_threshold)*5GHz_boost_factor*/
+	int A_band_boost_factor;
+
+	/* factor by which 5GHz RSSI is penalized*/
+	/*penalty=(5GHz_penalty_factor-RSSI_measured)*5GHz_penalty_factor*/
+	int A_band_penalty_factor;
+
+	/* maximum boost that can be applied to a 5GHz RSSI*/
+	int A_band_max_boost;
+
+	/* Hysteresis: ensuring the currently associated BSSID is favored*/
+	/*so as to prevent ping-pong situations,boost applied to current BSSID*/
+	int lazy_roam_hysteresis;
+
+	/* Alert mode enable, i.e. configuring when firmware enters alert mode*/
+	/* RSSI below which "Alert" roam is enabled*/
+	int alert_roam_rssi_trigger;
+};
+
+struct wifi_bssid_preference {
+	unsigned char bssid[6];
+	/* modifier applied to the RSSI of the BSSID for
+	 *the purpose of comparing it with other roam candidate
+	 */
+	int rssi_modifier;
+};
+
+struct wifi_bssid_preference_params {
+	int num_bssid;	/* number of preference APs*/
+	/* preference APs*/
+	struct wifi_bssid_preference pref_ap[MAX_PREFER_APS];
+};
+
+struct v_MACADDR_t {
+	u8 bytes[3];
+};
+
+struct wifi_passpoint_network {
+	/*identifier of this network block, report this in event*/
+	u8  id;
+	/*null terminated UTF8 encoded realm, 0 if unspecified*/
+	char realm[256];
+	/*roaming consortium ids to match, 0s if unspecified*/
+	int64_t roaming_ids[16];
+	/*mcc/mnc combination as per rules, 0s if unspecified*/
+	unsigned char plmn[3];
+};
+
+enum offloaded_packets_sending_control {
+	OFFLOADED_PACKETS_SENDING_CONTROL_INVALID = 0,
+	OFFLOADED_PACKETS_SENDING_START,
+	OFFLOADED_PACKETS_SENDING_STOP
+};
+
+enum sprdwl_attr_offloaded_packets {
+	OFFLOADED_PACKETS_INVALID = 0,
+	OFFLOADED_PACKETS_SENDING_CONTROL,
+	OFFLOADED_PACKETS_REQUEST_ID,
+	OFFLOADED_PACKETS_IP_PACKET_DATA,
+	OFFLOADED_PACKETS_SRC_MAC_ADDR,
+	OFFLOADED_PACKETS_DST_MAC_ADDR,
+	OFFLOADED_PACKETS_PERIOD,
+	OFFLOADED_PACKETS_ETHER_PROTO_TYPE,
+	OFFLOADED_PACKETS_AFTER_LAST,
+	OFFLOADED_PACKETS_MAX =
+	OFFLOADED_PACKETS_AFTER_LAST - 1,
+};
+
+void sprdwl_report_gscan_result(struct sprdwl_vif *vif,
+				u32 report_event, u8 bucketid,
+				u16 chan, s16 rssi, const u8 *buf, u16 len);
+int sprdwl_gscan_done(struct sprdwl_vif *vif, u8 bucketid);
+int sprdwl_buffer_full_event(struct sprdwl_vif *vif);
+int sprdwl_available_event(struct sprdwl_vif *vif);
+int sprdwl_vendor_report_full_scan(struct sprdwl_vif *vif,
+					struct sprdwl_gscan_result *item);
+int sprdwl_hotlist_change_event(struct sprdwl_vif *vif, u32 report_event);
+void sprdwl_event_rssi_monitor(struct sprdwl_vif *vif, u8 *data, u16 len);
+int sprdwl_vendor_cache_scan_result(struct sprdwl_vif *vif,
+				u8 bucket_id, struct sprdwl_gscan_result *item);
+int sprdwl_vendor_cache_hotlist_result(struct sprdwl_vif *vif,
+				struct sprdwl_gscan_result *item);
+int sprdwl_significant_change_event(struct sprdwl_vif *vif);
+int sprdwl_vendor_cache_significant_change_result(struct sprdwl_vif *vif,
+				u8 *data, u16 data_len);
+int sprdwl_set_packet_offload(struct sprdwl_priv *priv, u8 vif_ctx_id,
+			      u32 req, u8 enable, u32 interval,
+			      u32 len, u8 *data);
+
+#endif
diff --git a/drivers/net/wireless/uwe5622/unisocwifi/version.h b/drivers/net/wireless/uwe5622/unisocwifi/version.h
new file mode 100644
index 000000000000..668bdd50ae6f
--- /dev/null
+++ b/drivers/net/wireless/uwe5622/unisocwifi/version.h
@@ -0,0 +1,55 @@
+/*
+ * Copyright (C) 2017 Spreadtrum Communications Inc.
+ *
+ * Filename : version.h
+ * Abstract : This file is a general definition for driver version
+ *
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#ifndef SPRDWL_VERSION_H
+#define SPRDWL_VERSION_H
+
+#define SPRDWL_DRIVER_VERSION "Marlin3"
+#define SPRDWL_UPDATE "000e"
+#define SPRDWL_RESERVE ""
+#define MAIN_DRV_VERSION (1)
+#define MAX_API			(256)
+#define DEFAULT_COMPAT (255)
+#ifdef COMPAT_SAMPILE_CODE
+#define VERSION_1 (1)
+#define VERSION_2 (2)
+#define VERSION_3 (3)
+#define VERSION_4 (4)
+#endif
+
+struct sprdwl_ver {
+	char kernel_ver[8];
+	char drv_ver[8];
+	char update[8];
+	char reserve[8];
+};
+
+struct api_version_t {
+	unsigned char cmd_id;
+	unsigned char drv_version;
+	unsigned char fw_version;
+};
+
+/*struct used for priv to store all info*/
+struct sync_api_verion_t {
+	unsigned int compat;
+	unsigned int main_drv;
+	unsigned int main_fw;
+	struct api_version_t *api_array;
+};
+
+#endif
diff --git a/drivers/net/wireless/uwe5622/unisocwifi/wl_core.c b/drivers/net/wireless/uwe5622/unisocwifi/wl_core.c
new file mode 100644
index 000000000000..e6382878f194
--- /dev/null
+++ b/drivers/net/wireless/uwe5622/unisocwifi/wl_core.c
@@ -0,0 +1,714 @@
+/*
+ * Copyright (C) 2016 Spreadtrum Communications Inc.
+ *
+ * Authors	:
+ * star.liu <star.liu@spreadtrum.com>
+ * yifei.li <yifei.li@spreadtrum.com>
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include <linux/platform_device.h>
+#include <linux/utsname.h>
+#include <linux/debugfs.h>
+#include <linux/version.h>
+#include <marlin_platform.h>
+#include <linux/of.h>
+#include "sprdwl.h"
+#include "wl_intf.h"
+#include "wl_core.h"
+#include "tx_msg.h"
+#include "rx_msg.h"
+#include "msg.h"
+#include "txrx.h"
+#include "debug.h"
+#include "tcp_ack.h"
+
+#ifdef WL_CONFIG_DEBUG
+int sprdwl_debug_level = L_ERR;
+#else
+int sprdwl_debug_level = L_NONE;
+#endif
+
+struct device *sprdwl_dev;
+void adjust_debug_level(char *buf, unsigned char offset)
+{
+	int level = buf[offset] - '0';
+
+	switch (level) {
+	case L_ERR:
+		sprdwl_debug_level = L_ERR;
+		break;
+	case L_WARN:
+		sprdwl_debug_level = L_WARN;
+		break;
+	case L_INFO:
+		sprdwl_debug_level = L_INFO;
+		break;
+	case L_DBG:
+		sprdwl_debug_level = L_DBG;
+		break;
+	default:
+		sprdwl_debug_level = L_ERR;
+		wl_err("input wrong debug level\n");
+	}
+
+	wl_err("set sprdwl_debug_level: %d\n", sprdwl_debug_level);
+}
+#ifdef WMMAC_WFA_CERTIFICATION
+extern unsigned int vo_ratio;
+extern unsigned int vi_ratio;
+extern unsigned int be_ratio;
+extern unsigned int wmmac_ratio;
+
+void adjust_qos_ratio(char *buf, unsigned char offset)
+{
+	unsigned int qos_ratio =
+		(buf[offset+3] - '0')*10 + (buf[offset+4] - '0');
+
+	if (buf[offset] == 'v') {
+		if (buf[offset+1] == 'o')
+			vo_ratio = qos_ratio;
+		else if (buf[offset+1] == 'i')
+			vi_ratio = qos_ratio;
+	} else if (buf[offset] == 'b' && buf[offset+1] == 'e') {
+		be_ratio = qos_ratio;
+	} else if (buf[offset] == 'a' && buf[offset+1] == 'm') {
+		wmmac_ratio = qos_ratio;
+	}
+
+	wl_err("vo ratio:%u, vi ratio:%u, be ratio:%u, wmmac_ratio:%u\n",
+	       vo_ratio, vi_ratio, be_ratio, wmmac_ratio);
+}
+#endif
+unsigned int new_threshold;
+void adjust_tdls_threshold(char *buf, unsigned char offset)
+{
+	unsigned int value = 0;
+	unsigned int i = 0;
+	unsigned int len = strlen(buf) - strlen("tdls_threshold=");
+
+	for (i = 0; i < len; (value *= 10), i++) {
+		if ((buf[offset + i] >= '0') &&
+		   (buf[offset + i] <= '9')) {
+			value += (buf[offset + i] - '0');
+		} else {
+			value /= 10;
+			break;
+		}
+	}
+	new_threshold = value;
+	wl_err("%s, change tdls_threshold to %d\n", __func__, value);
+}
+
+struct debuginfo_s {
+	void (*func)(char *, unsigned char offset);
+	char str[30];
+} debuginfo[] = {
+	{adjust_debug_level, "debug_level="},
+#ifdef WMMAC_WFA_CERTIFICATION
+	{adjust_qos_ratio, "qos_ratio:"},
+#endif
+	{adjust_ts_cnt_debug, "debug_info="},
+	{enable_tcp_ack_delay, "tcpack_delay_en="},
+	{adjust_tcp_ack_delay, "tcpack_delay_cnt="},
+	{adjust_tcp_ack_delay_win, "tcpack_delay_win="},
+	{adjust_txnum_level, "txnum_level="},
+	{adjust_rxnum_level, "rxnum_level="},
+	{adjust_tdls_threshold, "tdls_threshold="},
+};
+
+/* TODO: Could we use netdev_alloc_frag instead of kmalloc?
+ *       So we did not need to distinguish buffer type
+ *       Maybe it could speed up alloc process, too
+ */
+void sprdwl_free_data(void *data, int buffer_type)
+{
+	if (buffer_type) { /* Fragment page buffer */
+		put_page(virt_to_head_page(data));
+	} else { /* Normal buffer */
+		kfree(data);
+	}
+}
+
+void sprdwl_tdls_flow_flush(struct sprdwl_vif *vif, const u8 *peer, u8 oper)
+{
+	struct sprdwl_intf *intf = vif->priv->hw_priv;
+	u8 i;
+
+	if (oper == NL80211_TDLS_SETUP || oper == NL80211_TDLS_ENABLE_LINK) {
+		for (i = 0; i < MAX_TDLS_PEER; i++) {
+			if (ether_addr_equal(intf->tdls_flow_count[i].da,
+					     peer)) {
+				memset(&intf->tdls_flow_count[i],
+				       0,
+				       sizeof(struct tdls_flow_count_para));
+				break;
+			}
+		}
+	}
+}
+
+void sprdwl_event_tdls_flow_count(struct sprdwl_vif *vif, u8 *data, u16 len)
+{
+	struct sprdwl_intf *intf = vif->priv->hw_priv;
+	u8 i;
+	u8 found = 0;
+	struct tdls_update_peer_infor *peer_info =
+		(struct tdls_update_peer_infor *)data;
+	ktime_t kt;
+
+	if (len < sizeof(struct tdls_update_peer_infor)) {
+		wl_err("%s, event data len not in range\n", __func__);
+		return;
+	}
+	for (i = 0; i < MAX_TDLS_PEER; i++) {
+		if (ether_addr_equal(intf->tdls_flow_count[i].da,
+				     peer_info->da)) {
+			found = 1;
+			break;
+		}
+	}
+	/*0 to delete entry*/
+	if (peer_info->valid == 0) {
+		if (found == 0) {
+			wl_err("%s, invalid da, fail to del\n", __func__);
+			return;
+		}
+		memset(&intf->tdls_flow_count[i],
+		       0,
+		       sizeof(struct tdls_flow_count_para));
+
+		for (i = 0; i < MAX_TDLS_PEER; i++) {
+			if (intf->tdls_flow_count[i].valid == 1)
+				found++;
+		}
+		if (found == 1)
+			intf->tdls_flow_count_enable = 0;
+	} else if (peer_info->valid == 1) {
+		if (found == 0) {
+			for (i = 0; i < MAX_TDLS_PEER; i++) {
+				if (intf->tdls_flow_count[i].valid == 0) {
+					found = 1;
+					break;
+				}
+			}
+		}
+		if (found == 0) {
+			wl_err("%s, no free TDLS entry\n", __func__);
+			i = 0;
+		}
+
+		intf->tdls_flow_count_enable = 1;
+		intf->tdls_flow_count[i].valid = 1;
+		ether_addr_copy(intf->tdls_flow_count[i].da, peer_info->da);
+		intf->tdls_flow_count[i].threshold = peer_info->txrx_len;
+		intf->tdls_flow_count[i].data_len_counted = 0;
+
+		wl_info("%s,%d, tdls_id=%d,threshold=%d, timer=%d, da=(%pM)\n",
+			__func__, __LINE__, i,
+			intf->tdls_flow_count[i].threshold,
+			peer_info->timer, peer_info->da);
+
+		kt = ktime_get();
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 14, 0)
+		intf->tdls_flow_count[i].start_mstime =
+			(u32)(div_u64(kt, NSEC_PER_MSEC));
+#else
+		intf->tdls_flow_count[i].start_mstime =
+			(u32)(div_u64(kt.tv64, NSEC_PER_MSEC));
+#endif
+		intf->tdls_flow_count[i].timer =
+			peer_info->timer;
+		wl_info("%s,%d, tdls_id=%d,start_time:%u\n",
+			__func__, __LINE__, i,
+			intf->tdls_flow_count[i].start_mstime);
+	}
+}
+
+void count_tdls_flow(struct sprdwl_vif *vif, u8 *data, u16 len)
+{
+	u8 i, found = 0;
+	u32 msec;
+	u8 elapsed_time;
+	u8 unit_time;
+	ktime_t kt;
+	struct sprdwl_intf *intf = (struct sprdwl_intf *)vif->priv->hw_priv;
+	int ret = 0;
+
+	for (i = 0; i < MAX_TDLS_PEER; i++) {
+		if ((intf->tdls_flow_count[i].valid == 1) &&
+		    (ether_addr_equal(data, intf->tdls_flow_count[i].da)))
+			goto count_it;
+	}
+	return;
+
+count_it:
+	if (new_threshold != 0)
+		intf->tdls_flow_count[i].threshold = new_threshold;
+	kt = ktime_get();
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 14, 0)
+	msec = (u32)(div_u64(kt, NSEC_PER_MSEC));
+#else
+	msec = (u32)(div_u64(kt.tv64, NSEC_PER_MSEC));
+#endif
+	elapsed_time =
+		(msec - intf->tdls_flow_count[i].start_mstime) / MSEC_PER_SEC;
+	unit_time = elapsed_time / intf->tdls_flow_count[i].timer;
+	wl_info("%s,%d, tdls_id=%d, len_counted=%d, len=%d, threshold=%dK\n",
+		__func__, __LINE__, i,
+		intf->tdls_flow_count[i].data_len_counted, len,
+		intf->tdls_flow_count[i].threshold);
+	wl_info("currenttime=%u, elapsetime=%d, unit_time=%d\n",
+		msec, elapsed_time, unit_time);
+
+	if ((intf->tdls_flow_count[i].data_len_counted == 0 &&
+	     len > (intf->tdls_flow_count[i].threshold * 1024)) ||
+	    (intf->tdls_flow_count[i].data_len_counted > 0 &&
+	    ((intf->tdls_flow_count[i].data_len_counted + len) >
+	     intf->tdls_flow_count[i].threshold * 1024 *
+	     ((unit_time == 0) ? 1 : unit_time)))) {
+		ret = sprdwl_send_tdls_cmd(vif, vif->ctx_id,
+					   (u8 *)intf->tdls_flow_count[i].da,
+					   SPRDWL_TDLS_CMD_CONNECT);
+		memset(&intf->tdls_flow_count[i], 0,
+			       sizeof(struct tdls_flow_count_para));
+	} else {
+		if (intf->tdls_flow_count[i].data_len_counted == 0) {
+			intf->tdls_flow_count[i].start_mstime = msec;
+			intf->tdls_flow_count[i].data_len_counted += len;
+		}
+		if ((intf->tdls_flow_count[i].data_len_counted > 0) &&
+		    unit_time > 1) {
+			intf->tdls_flow_count[i].start_mstime = msec;
+			intf->tdls_flow_count[i].data_len_counted = len;
+		}
+		if ((intf->tdls_flow_count[i].data_len_counted > 0) &&
+		    unit_time <= 1) {
+			intf->tdls_flow_count[i].data_len_counted += len;
+		}
+	}
+	for (i = 0; i < MAX_TDLS_PEER; i++) {
+		if (intf->tdls_flow_count[i].valid == 1)
+			found++;
+	}
+	if (found == 0)
+		intf->tdls_flow_count_enable = 0;
+}
+
+#define SPRDWL_SDIO_DEBUG_BUFLEN 128
+static ssize_t sprdwl_intf_read_info(struct file *file,
+				     char __user *user_buf,
+				     size_t count, loff_t *ppos)
+{
+	size_t ret = 0;
+	unsigned int buflen, len;
+	unsigned char *buf;
+	struct sprdwl_intf *sdev;
+	struct sprdwl_tx_msg *tx_msg;
+
+	sdev = (struct sprdwl_intf *)file->private_data;
+	tx_msg = (struct sprdwl_tx_msg *)sdev->sprdwl_tx;
+	buflen = SPRDWL_SDIO_DEBUG_BUFLEN;
+	buf = kzalloc(buflen, GFP_KERNEL);
+	if (!buf)
+		return -ENOMEM;
+
+	len = 0;
+	len += scnprintf(buf, buflen,
+			 "net: stop %lu, start %lu\n drop cnt:\n"
+			 "cmd %lu, sta %lu, p2p %lu,\n"
+			 "ring_ap:%lu ring_cp:%lu red_flow:%u,\n"
+			 "green_flow:%u blue_flow:%u white_flow:%u\n",
+			 tx_msg->net_stop_cnt, tx_msg->net_start_cnt,
+			 tx_msg->drop_cmd_cnt, tx_msg->drop_data1_cnt,
+			 tx_msg->drop_data2_cnt,
+			 tx_msg->ring_ap, tx_msg->ring_cp,
+			 atomic_read(&tx_msg->flow_ctrl[0].flow),
+			 atomic_read(&tx_msg->flow_ctrl[1].flow),
+			 atomic_read(&tx_msg->flow_ctrl[2].flow),
+			 atomic_read(&tx_msg->flow_ctrl[3].flow));
+	if (len > buflen)
+		len = buflen;
+
+	ret = simple_read_from_buffer(user_buf, count, ppos, buf, len);
+	kfree(buf);
+
+	return ret;
+}
+
+static ssize_t sprdwl_intf_write(struct file *file,
+				 const char __user *__user_buf,
+				 size_t count, loff_t *ppos)
+{
+	char buf[30];
+	struct sprdwl_intf *sdev;
+	int type = 0;
+	int debug_size = sizeof(debuginfo)/sizeof(struct debuginfo_s);
+
+	sdev = (struct sprdwl_intf *)file->private_data;
+
+	if (!count || count >= sizeof(buf)) {
+		wl_err("write len too long:%zu >= %zu\n", count, sizeof(buf));
+		return -EINVAL;
+	}
+	if (copy_from_user(buf, __user_buf, count))
+		return -EFAULT;
+	buf[count] = '\0';
+	wl_debug("write info:%s\n", buf);
+	for (type = 0; type < debug_size; type++)
+		if (!strncmp(debuginfo[type].str, buf,
+			     strlen(debuginfo[type].str))) {
+			wl_err("write info:type %d\n", type);
+			debuginfo[type].func(buf, strlen(debuginfo[type].str));
+			break;
+		}
+
+	return count;
+}
+
+static const struct file_operations sprdwl_intf_debug_fops = {
+	.read = sprdwl_intf_read_info,
+	.write = sprdwl_intf_write,
+	.open = simple_open,
+	.owner = THIS_MODULE,
+	.llseek = default_llseek
+};
+
+static int txrx_debug_show(struct seq_file *s, void *p)
+{
+	unsigned int i = 0;
+
+	for (i = 0; i < MAX_DEBUG_CNT_INDEX; i++)
+		debug_cnt_show(s, i);
+
+	for (i = 0; i < MAX_DEBUG_TS_INDEX; i++)
+		debug_ts_show(s, i);
+
+	for (i = 0; i < MAX_DEBUG_RECORD_INDEX; i++)
+		debug_record_show(s, i);
+
+	return 0;
+}
+
+static int txrx_debug_open(struct inode *inode, struct file *file)
+{
+	return single_open(file, txrx_debug_show, inode->i_private);
+}
+
+static ssize_t txrx_debug_write(struct file *file,
+				const char __user *__user_buf,
+				size_t count, loff_t *ppos)
+{
+	char buf[20] = "debug_info=";
+	unsigned char len = strlen(buf);
+
+	if (!count || (count + len) >= sizeof(buf)) {
+		wl_err("write len too long:%zu >= %zu\n", count, sizeof(buf));
+		return -EINVAL;
+	}
+
+	if (copy_from_user((buf + len), __user_buf, count))
+		return -EFAULT;
+
+	buf[count + len] = '\0';
+	wl_debug("write info:%s\n", buf);
+
+	adjust_ts_cnt_debug(buf, len);
+
+	return count;
+}
+
+static const struct file_operations txrx_debug_fops = {
+	.owner = THIS_MODULE,
+	.open = txrx_debug_open,
+	.read = seq_read,
+	.write = txrx_debug_write,
+	.llseek = seq_lseek,
+	.release = single_release,
+};
+
+void sprdwl_debugfs(void *spdev, struct dentry *dir)
+{
+	struct sprdwl_intf *intf;
+
+	intf = (struct sprdwl_intf *)spdev;
+	debugfs_create_file("sprdwlinfo", S_IRUSR,
+			    dir, intf, &sprdwl_intf_debug_fops);
+}
+
+static struct dentry *sprdwl_debug_root;
+
+void sprdwl_debugfs_init(struct sprdwl_intf *intf)
+{
+	/* create debugfs */
+	sprdwl_debug_root = debugfs_create_dir("sprdwl_debug", NULL);
+	if (IS_ERR(sprdwl_debug_root)) {
+		wl_err("%s, create dir fail!\n", __func__);
+		sprdwl_debug_root = NULL;
+		return;
+	}
+
+	if (!debugfs_create_file("log_level", S_IRUSR | S_IWUSR,
+		sprdwl_debug_root, intf, &sprdwl_intf_debug_fops))
+		wl_err("%s, create file fail!\n", __func__);
+
+	if (!debugfs_create_file("txrx_dbg", S_IRUSR | S_IWUSR,
+		sprdwl_debug_root, NULL, &txrx_debug_fops))
+		wl_err("%s, %d, create_file fail!\n", __func__, __LINE__);
+	else
+		debug_ctrl_init();
+}
+
+void sprdwl_debugfs_deinit(void)
+{
+	/* remove debugfs */
+	debugfs_remove_recursive(sprdwl_debug_root);
+}
+
+static int sprdwl_ini_download_status(void)
+{
+	/*disable download ini function, just return 1*/
+	/*	return 1; */
+	/*fw is ready for receive ini file*/
+	/* return !is_first_power_on(MARLIN_WIFI); */
+	return !cali_ini_need_download(MARLIN_WIFI);
+}
+
+static void sprdwl_force_exit(void *spdev)
+{
+	struct sprdwl_intf *intf;
+	struct sprdwl_tx_msg *tx_msg;
+
+	intf = (struct sprdwl_intf *)spdev;
+	tx_msg = (struct sprdwl_tx_msg *)intf->sprdwl_tx;
+	intf->exit = 1;
+}
+
+static int sprdwl_is_exit(void *spdev)
+{
+	struct sprdwl_intf *intf;
+
+	intf = (struct sprdwl_intf *)spdev;
+	return intf->exit;
+}
+
+static void sprdwl_tcp_drop_msg(void *spdev, struct sprdwl_msg_buf *msgbuf)
+{
+	enum sprdwl_mode mode;
+	struct sprdwl_msg_list *list;
+	struct sprdwl_intf *intf = (struct sprdwl_intf *)spdev;
+
+	if (msgbuf->skb)
+		dev_kfree_skb(msgbuf->skb);
+	mode = msgbuf->mode;
+	list = msgbuf->msglist;
+	sprdwl_free_msg_buf(msgbuf, list);
+	sprdwl_wake_net_ifneed(intf, list, mode);
+}
+
+static struct sprdwl_if_ops sprdwl_core_ops = {
+	.get_msg_buf = sprdwl_get_msg_buf,
+	.free_msg_buf = sprdwl_tx_free_msg_buf,
+#ifdef SPRDWL_TX_SELF
+	.tx = sprdwl_tx_self_msg,
+#else
+	.tx = sprdwl_tx_msg_func,
+#endif
+	.force_exit = sprdwl_force_exit,
+	.is_exit = sprdwl_is_exit,
+	.debugfs = sprdwl_debugfs,
+	.tcp_drop_msg = sprdwl_tcp_drop_msg,
+	.ini_download_status = sprdwl_ini_download_status
+};
+
+/*static struct notifier_block boost_notifier = {
+	.notifier_call = sprdwl_notifier_boost,
+};*/
+
+int sprdwl_probe(struct device *dev)
+{
+	struct sprdwl_intf *intf;
+	struct sprdwl_priv *priv;
+	int ret;
+	u8 i;
+
+	if (start_marlin(MARLIN_WIFI)) {
+		wl_err("%s power on chipset failed\n", __func__);
+		return -ENODEV;
+	}
+
+	intf = kzalloc(sizeof(*intf), GFP_ATOMIC);
+	if (!intf) {
+		ret = -ENOMEM;
+		wl_err("%s alloc intf fail: %d\n", __func__, ret);
+		goto err;
+	}
+
+	dev_set_drvdata(dev, intf);
+	intf->dev = dev;
+	sprdwl_dev = dev;
+
+	for (i = 0; i < MAX_LUT_NUM; i++)
+		intf->peer_entry[i].ctx_id = 0xff;
+
+	priv = sprdwl_core_create(get_hwintf_type(),
+				  &sprdwl_core_ops);
+	if (!priv) {
+		wl_err("%s core create fail\n", __func__);
+		ret = -ENXIO;
+		goto err_core_create;
+	}
+	memcpy(priv->wl_ver.kernel_ver, utsname()->release,
+			strlen(utsname()->release));
+	memcpy(priv->wl_ver.drv_ver, SPRDWL_DRIVER_VERSION,
+			strlen(SPRDWL_DRIVER_VERSION));
+	memcpy(priv->wl_ver.update, SPRDWL_UPDATE, strlen(SPRDWL_UPDATE));
+	memcpy(priv->wl_ver.reserve, SPRDWL_RESERVE, strlen(SPRDWL_RESERVE));
+	wl_info("Spreadtrum WLAN Version:");
+	wl_info("Kernel:%s,Driver:%s,update:%s,reserved:%s\n",
+			 utsname()->release, SPRDWL_DRIVER_VERSION,
+			 SPRDWL_UPDATE, SPRDWL_RESERVE);
+
+	if (priv->hw_type == SPRDWL_HW_SDIO) {
+		intf->hif_offset = sizeof(struct sdiohal_puh);
+		intf->rx_cmd_port = SDIO_RX_CMD_PORT;
+		intf->rx_data_port = SDIO_RX_DATA_PORT;
+		intf->tx_cmd_port = SDIO_TX_CMD_PORT;
+		intf->tx_data_port = SDIO_TX_DATA_PORT;
+	} else if (priv->hw_type == SPRDWL_HW_PCIE) {
+		intf->rx_cmd_port = PCIE_RX_CMD_PORT;
+		intf->rx_data_port = PCIE_RX_DATA_PORT;
+		intf->tx_cmd_port = PCIE_TX_CMD_PORT;
+		intf->tx_data_port = PCIE_TX_DATA_PORT;
+	} else if (priv->hw_type == SPRDWL_HW_USB) {
+		intf->hif_offset = 0;
+		intf->rx_cmd_port = USB_RX_CMD_PORT;
+		intf->rx_data_port = USB_RX_DATA_PORT;
+		intf->tx_cmd_port = USB_TX_CMD_PORT;
+		intf->tx_data_port = USB_TX_DATA_PORT;
+	}
+
+	ret = sprdwl_intf_init(priv, intf);
+	if (ret) {
+		wl_err("%s intf init failed: %d\n", __func__, ret);
+		goto err_if_init;
+	}
+
+	ret = sprdwl_rx_init(intf);
+	if (ret) {
+		wl_err("%s rx init failed: %d\n", __func__, ret);
+		goto err_rx_init;
+	}
+
+	ret = sprdwl_tx_init(intf);
+	if (ret) {
+		wl_err("%s tx_list init failed\n", __func__);
+		goto err_tx_init;
+	}
+
+	ret = sprdwl_core_init(dev, priv);
+	if (ret)
+		goto err_core_init;
+
+#if defined FPGA_LOOPBACK_TEST
+	intf->loopback_n = 0;
+	sprdwl_intf_tx_data_fpga_test(intf, NULL, 0);
+#endif
+
+	sprdwl_debugfs_init(intf);
+	//cpufreq_register_notifier(&boost_notifier, CPUFREQ_POLICY_NOTIFIER);
+
+	return ret;
+
+err_core_init:
+	sprdwl_tx_deinit(intf);
+err_tx_init:
+	sprdwl_rx_deinit(intf);
+err_rx_init:
+	sprdwl_intf_deinit(intf);
+err_if_init:
+	sprdwl_core_free((struct sprdwl_priv *)intf->priv);
+err_core_create:
+	kfree(intf);
+err:
+	return ret;
+}
+EXPORT_SYMBOL_GPL(sprdwl_probe);
+
+int sprdwl_remove(struct device *dev)
+{
+	struct sprdwl_intf *intf = dev_get_drvdata(dev);
+	struct sprdwl_priv *priv = intf->priv;
+
+	//cpufreq_unregister_notifier(&boost_notifier, CPUFREQ_POLICY_NOTIFIER);
+	sprdwl_debugfs_deinit();
+	sprdwl_core_deinit(priv);
+	sprdwl_tx_deinit(intf);
+	sprdwl_rx_deinit(intf);
+	sprdwl_intf_deinit(intf);
+	sprdwl_core_free(priv);
+	kfree(intf);
+	stop_marlin(MARLIN_WIFI);
+	wl_info("%s\n", __func__);
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(sprdwl_remove);
+
+#if 0
+static const struct of_device_id sprdwl_of_match[] = {
+	{.compatible = "sprd,unisoc-wifi",},
+	{}
+};
+MODULE_DEVICE_TABLE(of, sprdwl_of_match);
+
+static struct platform_driver sprdwl_driver = {
+	.probe = sprdwl_probe,
+	.remove = sprdwl_remove,
+	.driver = {
+		.owner = THIS_MODULE,
+		.name = "unisoc_wifi",
+		.of_match_table = sprdwl_of_match,
+	}
+};
+
+#ifdef OTT_UWE
+static struct platform_device *unisoc_pdev;
+static int __init unisoc_wlan_init(void)
+{
+	int ret;
+
+	ret = platform_driver_register(&sprdwl_driver);
+	if (!ret) {
+		unisoc_pdev = platform_device_alloc("unisoc_wifi", -1);
+		if (platform_device_add(unisoc_pdev) != 0)
+			wl_err("register platform device unisoc wifi failed\n");
+	}
+
+	return ret;
+}
+
+static void __exit unisoc_wlan_exit(void)
+{
+    platform_driver_unregister(&sprdwl_driver);
+    platform_device_del(unisoc_pdev);
+}
+
+module_init(unisoc_wlan_init);
+module_exit(unisoc_wlan_exit);
+#else
+module_platform_driver(sprdwl_driver);
+#endif
+#endif
+
+MODULE_DESCRIPTION("Spreadtrum Wireless LAN Driver");
+MODULE_AUTHOR("Spreadtrum WCN Division");
+MODULE_LICENSE("GPL");
diff --git a/drivers/net/wireless/uwe5622/unisocwifi/wl_core.h b/drivers/net/wireless/uwe5622/unisocwifi/wl_core.h
new file mode 100644
index 000000000000..53dfe810c1f5
--- /dev/null
+++ b/drivers/net/wireless/uwe5622/unisocwifi/wl_core.h
@@ -0,0 +1,210 @@
+/*
+ * Copyright (C) 2015 Spreadtrum Communications Inc.
+ *
+ * Authors	:
+ * Keguang Zhang <keguang.zhang@spreadtrum.com>
+ * Jingxiang Li <Jingxiang.li@spreadtrum.com>
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#ifndef __WL_CORE_H__
+#define __WL_CORE_H__
+
+#include <linux/types.h>
+#include <linux/wait.h>
+#include <linux/spinlock.h>
+#include <linux/platform_device.h>
+#include <linux/etherdevice.h>
+#include "cfg80211.h"
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/fs.h>
+#include <linux/uaccess.h>
+
+#define SPRDWL_NORMAL_MEM	0
+#define SPRDWL_DEFRAG_MEM	1
+
+#define SPRDWL_TX_CMD_TIMEOUT	3000
+#define SPRDWL_TX_DATA_TIMEOUT	4000
+
+#define SPRDWL_TX_MSG_CMD_NUM 128
+#define SPRDWL_TX_QOS_POOL_SIZE 20000
+#define SPRDWL_TX_DATA_START_NUM (SPRDWL_TX_QOS_POOL_SIZE - 3)
+#define SPRDWL_RX_MSG_NUM 20000
+
+/* tx len less than cp len 4 byte as sdiom 4 bytes align */
+/* set MAX CMD length to 1600 on firmware side*/
+#define SPRDWL_MAX_CMD_TXLEN	1596
+#define SPRDWL_MAX_CMD_RXLEN	1092
+#define SPRDWL_MAX_DATA_TXLEN	1672
+#define SPRDWL_MAX_DATA_RXLEN	1676
+
+#define MAX_LUT_NUM 32
+
+struct tx_address {
+	u8 da[ETH_ALEN];
+	u8 sa[ETH_ALEN];
+};
+
+struct rx_address {
+	u8 sa[ETH_ALEN];
+	u8 da[ETH_ALEN];
+};
+
+struct sprdwl_peer_entry {
+	union {
+		struct rx_address rx;
+		struct tx_address tx;
+	};
+
+	u8 lut_index;
+	u8 ctx_id;
+	u8 cipher_type;
+	u8 pending_num;
+	u8 ht_enable;
+	u8 vht_enable;
+	u8 ip_acquired;
+	/*tx ba done based on tid*/
+	unsigned long ba_tx_done_map;
+	u8 vowifi_enabled;
+	u8 vowifi_pkt_cnt;
+	struct timespec64 time[6 + 1];
+};
+
+#if defined(MORE_DEBUG)
+/*tx/rx states and performance statistics*/
+struct txrx_stats {
+	unsigned long	rx_packets;
+	/*tx success packets num*/
+	unsigned long	tx_packets;
+	unsigned long	rx_bytes;
+	/*tx success bytes num*/
+	unsigned long	tx_bytes;
+	unsigned long	rx_errors;
+	unsigned long	tx_errors;
+	unsigned int tx_nomem_errors;
+	unsigned int tx_fail_errors;
+	unsigned long	rx_dropped;
+	unsigned long	tx_dropped;
+	/*alloc pkt fail*/
+	unsigned long rx_pktgetfail;
+	unsigned long tx_pktgetfail;
+	/* Number of tx packets we had to realloc for headroom */
+	unsigned long tx_realloc;
+	/* multicast packets received */
+	unsigned long	rx_multicast;
+	unsigned long	tx_multicast;
+	unsigned long tx_cost_time;
+	unsigned long tx_avg_time;
+	unsigned long tx_arp_num;
+	/*qos ac stream1 sent num*/
+	unsigned long ac1_num;
+	/*qos ac stream2 sent num*/
+	unsigned long ac2_num;
+	unsigned long tx_filter_num;
+	/*statistical sample count*/
+	unsigned int gap_num;
+};
+#endif
+
+struct tdls_flow_count_para {
+	u8 valid;
+	u8 da[ETH_ALEN];
+	/*u8 timer;seconds*/
+	u16 threshold;/*bytes*/
+	u16 data_len_counted;/*bytes*/
+	u32 start_mstime;/*ms*/
+	u8 timer;/*seconds*/
+};
+
+#define MAX_TDLS_PEER 32
+
+struct sprdwl_priv;
+struct sprdwl_intf {
+	struct device *dev;
+	/* priv use void *, after MCC adn priv->flags,
+	 * and change txrx intf pass priv to void later
+	 */
+	struct sprdwl_priv *priv;
+
+	/* if nedd more flags which not only exit, fix it*/
+	/* unsigned int exit:1; */
+	int exit;
+
+	int flag;
+	int lastflag;
+
+	int tx_mode;
+	int rx_mode;
+
+	/*point to hif interface(sdio/pcie)*/
+	void *hw_intf;
+
+	/* Manage tx function */
+	void *sprdwl_tx;
+	/* Manage rx function */
+	void *sprdwl_rx;
+
+	struct sprdwl_peer_entry peer_entry[MAX_LUT_NUM];
+	unsigned long tx_num[MAX_LUT_NUM];
+	unsigned char *skb_da;
+#if defined FPGA_LOOPBACK_TEST
+	int loopback_n;
+#endif
+
+	int hif_offset;
+	unsigned char rx_cmd_port;
+	unsigned char rx_data_port;
+	unsigned char tx_cmd_port;
+	unsigned char tx_data_port;
+#if defined(MORE_DEBUG)
+	struct txrx_stats stats;
+#endif
+
+	u8 tdls_flow_count_enable;
+	struct tdls_flow_count_para tdls_flow_count[MAX_TDLS_PEER];
+	/*suspend_mode:ap suspend/resumed status
+	  resumed:cp suspend/resumed status*/
+#define SPRDWL_PS_SUSPENDING  1
+#define SPRDWL_PS_SUSPENDED  2
+#define SPRDWL_PS_RESUMING  3
+#define SPRDWL_PS_RESUMED  0
+	int suspend_mode;
+
+	int fw_power_down;
+	int fw_awake;
+
+	/*for pkt log function*/
+	loff_t lp;
+	struct file *pfile;
+	/*for suspend resume time count*/
+	unsigned long sleep_time;
+
+	u8 cp_asserted;
+	/*wifi bt coex mode, 1:BT is on, 0:BT is off*/
+	u8 coex_bt_on;
+	u8 boost;
+	unsigned int txnum_level;
+	unsigned int rxnum_level;
+};
+
+/* HashTable */
+struct HashTable {
+	struct kv **table;
+};
+
+void sprdwl_free_data(void *data, int buffer_type);
+enum sprdwl_hw_type sprd_core_get_hwintf_mode(void);
+
+void sprdwl_event_tdls_flow_count(struct sprdwl_vif *vif, u8 *data, u16 len);
+void count_tdls_flow(struct sprdwl_vif *vif, u8 *data, u16 len);
+void sprdwl_tdls_flow_flush(struct sprdwl_vif *vif, const u8 *peer, u8 oper);
+#endif
diff --git a/drivers/net/wireless/uwe5622/unisocwifi/wl_intf.c b/drivers/net/wireless/uwe5622/unisocwifi/wl_intf.c
new file mode 100644
index 000000000000..1bd237331dcc
--- /dev/null
+++ b/drivers/net/wireless/uwe5622/unisocwifi/wl_intf.c
@@ -0,0 +1,1881 @@
+/*
+ * Copyright (C) 2016 Spreadtrum Communications Inc.
+ *
+ * Authors	:
+ * star.liu <star.liu@spreadtrum.com>
+ * yifei.li <yifei.li@spreadtrum.com>
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include <linux/ip.h>
+#include "sprdwl.h"
+#include "wl_intf.h"
+#include "intf_ops.h"
+#include "mm.h"
+#include "tx_msg.h"
+#include "rx_msg.h"
+#include "work.h"
+#include "tcp_ack.h"
+
+#define INIT_INTF(num, type, out, interval, bsize, psize, max,\
+			 threshold, time, pop, push, complete, suspend) \
+{ .channel = num, .hif_type = type, .inout = out, .intr_interval = interval,\
+.buf_size = bsize, .pool_size = psize, .once_max_trans = max,\
+.rx_threshold = threshold, .timeout = time, .pop_link = pop,\
+.push_link = push, .tx_complete = complete, .power_notify = suspend }
+
+struct sprdwl_intf_ops g_intf_ops;
+
+static inline struct sprdwl_intf *get_intf(void)
+{
+	return (struct sprdwl_intf *)g_intf_ops.intf;
+}
+
+#define INTF_IS_PCIE \
+	(get_intf()->priv->hw_type == SPRDWL_HW_PCIE)
+
+void sprdwl_hex_dump(unsigned char *name,
+		     unsigned char *data, unsigned short len)
+{
+	int i, p = 0, ret;
+	unsigned char buf[255] = {0};
+
+	if ((NULL == data) || (0 == len) || (NULL == name))
+		return;
+
+	sprintf(buf, "sprdwl %s hex dump(len = %d)", name, len);
+	wl_info("%s\n", buf);
+
+	if (len > 1024)
+		len = 1024;
+	memset(buf, 0x00, 255);
+	for (i = 0; i < len ; i++) {
+		ret = sprintf((buf + p), "%02x ", *(data + i));
+		if ((i != 0) && ((i + 1)%16 == 0)) {
+			wl_info("%s\n", buf);
+			p = 0;
+			memset(buf, 0x00, 255);
+		} else {
+			p = p + ret;
+		}
+	}
+	if (p != 0)
+		wl_info("%s\n", buf);
+}
+
+enum sprdwl_hw_type get_hwintf_type(void)
+{
+	int hif = 0;
+	enum sprdwl_hw_type hw_type;
+
+	hif = sprdwcn_bus_get_hif_type();
+	switch (hif) {
+	case HW_TYPE_SDIO:
+		hw_type = SPRDWL_HW_SDIO;
+		break;
+	case HW_TYPE_PCIE:
+		hw_type = SPRDWL_HW_PCIE;
+		break;
+	case HW_TYPE_SIPC:
+		hw_type = SPRDWL_HW_SIPC;
+		break;
+	case HW_TYPE_USB:
+		hw_type = SPRDWL_HW_USB;
+		break;
+	default:
+		hw_type = SPRDWL_HW_SDIO;
+		break;
+	}
+	return hw_type;
+}
+
+#if defined(MORE_DEBUG)
+void sprdwl_dump_stats(struct sprdwl_intf *intf)
+{
+	wl_err("++print txrx statistics++\n");
+	wl_err("tx packets: %lu, tx bytes: %lu\n",  intf->stats.tx_packets,
+	       intf->stats.tx_bytes);
+	wl_err("tx filter num: %lu\n",  intf->stats.tx_filter_num);
+	wl_err("tx errors: %lu, tx dropped: %lu\n",  intf->stats.tx_errors,
+	       intf->stats.tx_dropped);
+	wl_err("tx avg time: %lu\n",  intf->stats.tx_avg_time);
+	wl_err("tx realloc: %lu\n",  intf->stats.tx_realloc);
+	wl_err("tx arp num: %lu\n",  intf->stats.tx_arp_num);
+	wl_err("rx packets: %lu, rx bytes: %lu\n",  intf->stats.rx_packets,
+	       intf->stats.rx_bytes);
+	wl_err("rx errors: %lu, rx dropped: %lu\n",  intf->stats.rx_errors,
+	       intf->stats.rx_dropped);
+	wl_err("rx multicast: %lu, tx multicast: %lu\n",
+	       intf->stats.rx_multicast, intf->stats.tx_multicast);
+	wl_err("--print txrx statistics--\n");
+}
+
+void sprdwl_clear_stats(struct sprdwl_intf *intf)
+{
+	memset(&intf->stats, 0x0, sizeof(struct txrx_stats));
+}
+
+/*calculate packets  average sent time from received
+*from network stack to freed by HIF every STATS_COUNT packets
+*/
+void sprdwl_get_tx_avg_time(struct sprdwl_intf *intf,
+			    unsigned long tx_start_time)
+{
+	struct timespec64 tx_end;
+
+	ktime_get_real_ts64(&tx_end);
+	intf->stats.tx_cost_time +=
+	timespec64_to_ns(&tx_end) - tx_start_time;
+	if (intf->stats.gap_num >= STATS_COUNT) {
+		intf->stats.tx_avg_time =
+		intf->stats.tx_cost_time / intf->stats.gap_num;
+		sprdwl_dump_stats(intf);
+		intf->stats.gap_num = 0;
+		intf->stats.tx_cost_time = 0;
+		wl_info("%s:%d packets avg cost time: %lu\n",
+			__func__, __LINE__, intf->stats.tx_avg_time);
+	}
+}
+#endif
+
+void set_coex_bt_on_off(u8 action)
+{
+	struct sprdwl_intf *intf = get_intf();
+
+	intf->coex_bt_on = action;
+}
+
+unsigned long mbufalloc;
+unsigned long mbufpop;
+int if_tx_one(struct sprdwl_intf *intf, unsigned char *data,
+	      int len, int chn)
+{
+	int ret;
+	struct mbuf_t *head = NULL, *tail = NULL, *mbuf = NULL;
+	int num = 1;
+
+	ret = sprdwcn_bus_list_alloc(chn, &head, &tail, &num);
+	if (ret || head == NULL || tail == NULL) {
+		wl_err("%s:%d sprdwcn_bus_list_alloc fail\n",
+		       __func__, __LINE__);
+		return -1;
+	}
+	mbufalloc += num;
+	mbuf = head;
+	mbuf->buf = data;
+
+	mbuf->len = len;
+	mbuf->next = NULL;
+	if (sprdwl_debug_level >= L_DBG)
+		sprdwl_hex_dump("tx to cp2 cmd data dump", data + 4, len);
+	if (intf->priv->hw_type == SPRDWL_HW_PCIE) {
+		mbuf->phy = mm_virt_to_phys(intf->dev, mbuf->buf,
+					    mbuf->len, DMA_TO_DEVICE);
+	}
+
+	ret = sprdwcn_bus_push_list(chn, head, tail, num);
+	if (ret) {
+		mbuf = head;
+		if (intf->priv->hw_type == SPRDWL_HW_PCIE) {
+			mm_phys_to_virt(intf->dev, mbuf->phy, mbuf->len,
+					DMA_TO_DEVICE, false);
+			mbuf->phy = 0;
+		}
+		kfree(mbuf->buf);
+		mbuf->buf = NULL;
+
+		sprdwcn_bus_list_free(chn, head, tail, num);
+		mbufalloc -= num;
+	}
+
+	return ret;
+}
+
+inline int if_tx_cmd(struct sprdwl_intf *intf, unsigned char *data, int len)
+{
+	return if_tx_one(intf, data, len, intf->tx_cmd_port);
+}
+
+inline int if_tx_addr_trans(struct sprdwl_intf *intf,
+			    unsigned char *data, int len)
+{
+	/* FIXME: Which port is used to send ADDR TRNAS*/
+	return if_tx_one(intf, data, len, intf->tx_data_port);
+}
+
+static inline struct pcie_addr_buffer
+*sprdwl_alloc_pcie_addr_buf(int tx_count)
+{
+	struct pcie_addr_buffer *addr_buffer;
+#define ADDR_OFFSET 5
+
+	addr_buffer =
+		kzalloc(sizeof(struct pcie_addr_buffer) +
+		tx_count * SPRDWL_PHYS_LEN, GFP_KERNEL);
+	if (addr_buffer == NULL) {
+		wl_err("%s:%d alloc pcie addr buf fail\n", __func__, __LINE__);
+		return NULL;
+	}
+	addr_buffer->common.type = SPRDWL_TYPE_DATA_PCIE_ADDR;
+	addr_buffer->common.direction_ind = 0;
+	addr_buffer->number = tx_count;
+	addr_buffer->offset = ADDR_OFFSET;
+	addr_buffer->buffer_ctrl.buffer_inuse = 1;
+	addr_buffer->buffer_ctrl.buffer_type = 1;
+
+	return addr_buffer;
+}
+
+static inline struct pcie_addr_buffer
+*sprdwl_set_pcie_addr_to_mbuf(struct sprdwl_tx_msg *tx_msg, struct mbuf_t *mbuf,
+				   int tx_count)
+{
+#define ADDR_OFFSET 5
+	struct pcie_addr_buffer *addr_buffer;
+	struct sprdwl_intf *intf = tx_msg->intf;
+
+	addr_buffer = sprdwl_alloc_pcie_addr_buf(tx_count);
+	if (addr_buffer == NULL)
+		return NULL;
+	mbuf->len = ADDR_OFFSET + tx_count * SPRDWL_PHYS_LEN;
+	mbuf->buf = (unsigned char *)addr_buffer;
+	mbuf->phy = mm_virt_to_phys(intf->dev, mbuf->buf,
+				    mbuf->len, DMA_TO_DEVICE);
+
+	return addr_buffer;
+}
+
+void sprdwl_add_tx_list_head(struct list_head *tx_fail_list,
+			     struct list_head *tx_list,
+			     int ac_index,
+			     int tx_count)
+{
+	struct sprdwl_msg_buf *msg_buf = NULL;
+	struct list_head *xmit_free_list;
+	struct list_head *head, *tail;
+	spinlock_t *lock;
+	spinlock_t *free_lock;
+
+	if (tx_fail_list == NULL)
+		return;
+	msg_buf = list_first_entry(tx_fail_list, struct sprdwl_msg_buf, list);
+	xmit_free_list = &msg_buf->xmit_msg_list->to_free_list;
+	free_lock = &msg_buf->xmit_msg_list->free_lock;
+	if (msg_buf->msg_type != SPRDWL_TYPE_DATA) {
+		lock = &msg_buf->msglist->busylock;
+	} else {
+		if (SPRDWL_AC_MAX != ac_index)
+			lock = &msg_buf->data_list->p_lock;
+		else
+			lock = &msg_buf->xmit_msg_list->send_lock;
+	}
+	spin_lock_bh(free_lock);
+	head = tx_fail_list->next;
+	tail = tx_fail_list->prev;
+	head->prev->next = tail->next;
+	tail->next->prev = head->prev;
+	head->prev = tx_fail_list;
+	tail->next = tx_fail_list;
+	spin_unlock_bh(free_lock);
+
+	spin_lock_bh(lock);
+	list_splice(tx_fail_list, tx_list);
+	spin_unlock_bh(lock);
+	INIT_LIST_HEAD(tx_fail_list);
+}
+
+static inline void
+sprdwl_add_to_free_list(struct sprdwl_tx_msg *tx_msg,
+			struct list_head *tx_list_head,
+			int tx_count)
+{
+	spin_lock_bh(&tx_msg->xmit_msg_list.free_lock);
+	list_splice_tail(tx_list_head, &tx_msg->xmit_msg_list.to_free_list);
+	spin_unlock_bh(&tx_msg->xmit_msg_list.free_lock);
+}
+
+/*cut data list from tx data list*/
+static inline void
+sprdwl_list_cut_position(struct list_head *tx_list_head,
+			 struct list_head *tx_list,
+			 struct list_head *tail_entry, int ac_index)
+{
+	spinlock_t *lock;
+	struct sprdwl_msg_buf *msg_buf = NULL;
+
+	if (tail_entry == NULL)
+		return;
+	msg_buf = list_first_entry(tx_list, struct sprdwl_msg_buf, list);
+	if (msg_buf->msg_type != SPRDWL_TYPE_DATA) {
+		lock = &msg_buf->msglist->busylock;
+	} else {
+		if (SPRDWL_AC_MAX != ac_index)
+			lock = &msg_buf->data_list->p_lock;
+		else
+			lock = &msg_buf->xmit_msg_list->send_lock;
+	}
+	spin_lock_bh(lock);
+	list_cut_position(tx_list_head, tx_list, tail_entry);
+	spin_unlock_bh(lock);
+}
+
+int sprdwl_add_topop_list(int chn, struct mbuf_t *head,
+			   struct mbuf_t *tail, int num)
+{
+	struct sprdwl_intf *intf = get_intf();
+	struct sprdwl_work *misc_work;
+	struct sprdwl_pop_work pop_work;
+
+	pop_work.chn = chn;
+	pop_work.head = (void *)head;
+	pop_work.tail = (void *)tail;
+	pop_work.num = num;
+
+	misc_work = sprdwl_alloc_work(sizeof(struct sprdwl_pop_work));
+	if (!misc_work) {
+		wl_err("%s out of memory\n", __func__);
+		return -1;
+	}
+	misc_work->vif = NULL;
+	misc_work->id = SPRDWL_POP_MBUF;
+	memcpy(misc_work->data, &pop_work, sizeof(struct sprdwl_pop_work));
+
+	sprdwl_queue_work(intf->priv, misc_work);
+	return 0;
+}
+
+void sprdwl_count_tx_tp(struct sprdwl_tx_msg *tx_msg, int num)
+{
+	long long timeus = 0;
+	struct sprdwl_intf *intf = get_intf();
+
+	tx_msg->tx_data_num += num;
+	if (tx_msg->tx_data_num == num) {
+		tx_msg->txtimebegin = ktime_get();
+		return;
+	}
+
+	tx_msg->txtimeend = ktime_get();
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4, 10, 0)
+	timeus = div_u64(tx_msg->txtimeend.tv64 - tx_msg->txtimebegin.tv64, NSEC_PER_USEC);
+#else
+	timeus = ktime_to_us(tx_msg->txtimeend - tx_msg->txtimebegin);
+#endif
+	if (div_u64((tx_msg->tx_data_num * 1000), timeus) >= intf->txnum_level &&
+		tx_msg->tx_data_num >= 1000) {
+		tx_msg->tx_data_num = 0;
+		sprdwl_boost();
+	} else if (timeus >= USEC_PER_SEC) {
+		tx_msg->tx_data_num = 0;
+	}
+}
+
+unsigned long tx_packets;
+int sprdwl_intf_tx_list(struct sprdwl_intf *dev,
+			struct list_head *tx_list,
+			struct list_head *tx_list_head,
+			int tx_count,
+			int ac_index,
+			u8 coex_bt_on)
+{
+#define PCIE_TX_NUM 96
+	int ret, i = 0, j = PCIE_TX_NUM, pcie_count = 0, cnt = 0, num = 0;
+	struct sprdwl_msg_buf *msg_pos, *msg_temp;
+	struct pcie_addr_buffer *addr_buffer = NULL;
+	struct sprdwl_tx_msg *tx_msg;
+	struct mbuf_t *head = NULL, *tail = NULL, *mbuf_pos;
+	unsigned long pcie_addr = 0;
+	/*struct sprdwl_data_hdr *hdr; *//*temp for test*/
+	struct list_head *pos, *tx_list_tail, *n_list;
+	unsigned long *msg_ptr;
+	unsigned char *data_ptr;
+	struct tx_msdu_dscr *dscr;
+#if defined(MORE_DEBUG)
+	unsigned long tx_bytes = 0;
+#endif
+	int tx_count_saved = tx_count;
+	int list_num;
+
+	wl_debug("%s:%d tx_count is %d\n", __func__, __LINE__, tx_count);
+	list_num = get_list_num(tx_list);
+	if (list_num < tx_count) {
+		wl_err("%s, %d, error!, tx_count:%d, list_num:%d\n",
+				__func__, __LINE__, tx_count, list_num);
+		WARN_ON(1);
+	}
+	tx_msg = (struct sprdwl_tx_msg *)dev->sprdwl_tx;
+	sprdwl_count_tx_tp(tx_msg, tx_count);
+	if (dev->priv->hw_type == SPRDWL_HW_PCIE) {
+		if (tx_count <= PCIE_TX_NUM) {
+			pcie_count = 1;
+		} else {
+			cnt = tx_count;
+			while (cnt > PCIE_TX_NUM) {
+				++num;
+				cnt -= PCIE_TX_NUM;
+			}
+			pcie_count = num + 1;
+		}
+		ret = sprdwcn_bus_list_alloc(dev->tx_data_port, &head,
+				      &tail, &pcie_count);
+	} else {
+		ret = sprdwcn_bus_list_alloc(dev->tx_data_port, &head,
+				      &tail, &tx_count);
+	}
+	if (ret != 0 || head == NULL || tail == NULL) {
+		wl_err("%s, %d, mbuf alloc fail\n",
+		       __func__, __LINE__);
+		sprdwcn_bus_list_free(dev->tx_data_port, head, tail, tx_count);
+		return -ENOMEM;
+	}
+	if (tx_count_saved != tx_count) {
+		wl_err("%s, %d error!mbuf not enough%d\n",
+		       __func__, __LINE__, (tx_count_saved - tx_count));
+		tx_msg->mbuf_short += (tx_count_saved - tx_count);
+		sprdwcn_bus_list_free(dev->tx_data_port, head, tail, tx_count);
+		return -ENOMEM;
+	}
+	mbufalloc += tx_count;
+
+	mbuf_pos = head;
+	if (dev->priv->hw_type == SPRDWL_HW_PCIE) {
+		if (pcie_count > 1) {
+			addr_buffer =
+			sprdwl_set_pcie_addr_to_mbuf(tx_msg,
+						     mbuf_pos, PCIE_TX_NUM);
+		} else {
+			addr_buffer =
+			sprdwl_set_pcie_addr_to_mbuf(tx_msg,
+						     mbuf_pos, tx_count);
+		}
+		if (addr_buffer == NULL) {
+			wl_err("%s:%d alloc pcie addr buf fail\n",
+			       __func__, __LINE__);
+			return -1;
+		}
+	}
+	list_for_each_safe(pos, n_list, tx_list) {
+		msg_pos = list_entry(pos, struct sprdwl_msg_buf, list);
+		sprdwl_move_tcpack_msg(dev->priv, msg_pos);
+		data_ptr = (unsigned char *)(msg_pos->tran_data) -
+			dev->hif_offset;
+#ifdef OTT_UWE
+		dscr = (struct tx_msdu_dscr *)(msg_pos->tran_data + FOUR_BYTES_ALIGN_OFFSET);
+#else
+		dscr = (struct tx_msdu_dscr *)(msg_pos->tran_data);
+#endif
+		dscr->color_bit = sprdwl_fc_set_clor_bit(tx_msg, i + 1);
+/*TODO*/
+		if (sprdwl_debug_level >= L_DBG) {
+			int print_len = msg_pos->len;
+
+			if (print_len > 200)
+				print_len = 200;
+			sprdwl_hex_dump("tx to cp2 data",
+					(unsigned char *)(msg_pos->tran_data),
+					print_len);
+		}
+#if defined(MORE_DEBUG)
+		tx_bytes += msg_pos->skb->len;
+#endif
+		msg_ptr =
+		(unsigned long *)(data_ptr - sizeof(unsigned long *));
+		/*store msg_buf ptr to skb header room
+		*for call back func free
+		*/
+		*msg_ptr = (unsigned long)msg_pos;
+		if (dev->priv->hw_type == SPRDWL_HW_PCIE) {
+			if (pcie_count > 1 && num > 0 && i >= j) {
+				if (--num == 0) {
+					if (cnt > 0)
+						addr_buffer =
+						sprdwl_set_pcie_addr_to_mbuf(
+						tx_msg, mbuf_pos, cnt);
+				} else {
+					/*if data num greater than PCIE_TX_NUM,
+					*alloc another pcie addr buf
+					*/
+					j += PCIE_TX_NUM;
+						addr_buffer =
+						sprdwl_set_pcie_addr_to_mbuf(
+						tx_msg, mbuf_pos, PCIE_TX_NUM);
+				}
+				if (addr_buffer == NULL) {
+					wl_err("%s:%d alloc pcie addr buf fail\n",
+					       __func__, __LINE__);
+					return -1;
+				}
+			}
+
+			pcie_addr =
+				mm_virt_to_phys(dev->dev,
+						msg_pos->tran_data,
+						msg_pos->len, DMA_TO_DEVICE);
+			memcpy(&addr_buffer->pcie_addr[i],
+			       &pcie_addr, SPRDWL_PHYS_LEN);
+		} else {
+			mbuf_pos->buf = data_ptr;
+			mbuf_pos->len = msg_pos->len;
+			/*TODO, to check msgbuf before list push*/
+			msg_temp = GET_MSG_BUF(mbuf_pos);
+			if (!virt_addr_valid(msg_temp) ||
+			    !virt_addr_valid(msg_temp->skb))
+				BUG_ON(1);
+		}
+		mbuf_pos = mbuf_pos->next;
+		if (++i == tx_count)
+			break;
+	}
+
+	tx_list_tail = pos;
+	sprdwl_list_cut_position(tx_list_head, tx_list, tx_list_tail,
+				 ac_index);
+	sprdwl_add_to_free_list(tx_msg, tx_list_head, tx_count);
+
+	if (dev->priv->hw_type == SPRDWL_HW_PCIE) {
+		/*ret = sprdwcn_bus_push_list(dev->tx_data_port, head, tail,*/
+		/*pcie_count);*/
+		/*edma sync function*/
+		ret = sprdwcn_bus_push_link_wait_complete(dev->tx_data_port, head,
+						   tail, pcie_count, 50000);
+		if (ret != 0) {
+			for (mbuf_pos = head; mbuf_pos != NULL;
+				mbuf_pos = mbuf_pos->next) {
+				kfree(mbuf_pos->buf);
+				mbuf_pos->buf = NULL;
+				if (--pcie_count == 0)
+					break;
+			}
+			sprdwcn_bus_list_free(dev->tx_data_port, head, tail,
+				       pcie_count);
+			/*add data list to tx list header if tx fail*/
+			sprdwl_add_tx_list_head(tx_list_head,
+						tx_list, ac_index, tx_count);
+			wl_err("%s:%d Tx pcie addr buf fail\n",
+			       __func__, __LINE__);
+		} else {
+#if defined(MORE_DEBUG)
+			UPDATE_TX_PACKETS(dev, tx_count, tx_bytes);
+#endif
+			INIT_LIST_HEAD(tx_list_head);
+		}
+		return ret;
+	}
+
+	/*BT is on: call sdiohal_txthread to send data.*/
+	if (dev->priv->hw_type == SPRDWL_HW_SDIO) {
+		if (coex_bt_on)
+			ret = sprdwcn_bus_push_list(dev->tx_data_port,
+						    head, tail, tx_count);
+		else
+			ret = sprdwcn_bus_push_list_direct(dev->tx_data_port,
+							   head, tail, tx_count);
+	} else {
+		ret = sprdwcn_bus_push_list(dev->tx_data_port,
+					    head, tail, tx_count);
+	}
+
+	if (ret != 0) {
+		sprdwcn_bus_list_free(dev->tx_data_port, head, tail, tx_count);
+		sprdwl_add_tx_list_head(tx_list_head, tx_list,
+					ac_index, tx_count);
+		wl_err("%s:%d err Tx data fail\n", __func__, __LINE__);
+		mbufalloc -= tx_count;
+	} else {
+#if defined(MORE_DEBUG)
+		UPDATE_TX_PACKETS(dev, tx_count, tx_bytes);
+#endif
+		INIT_LIST_HEAD(tx_list_head);
+		tx_packets += tx_count;
+		wl_info("%s, %d, tx_count=%d, total=%lu, mbufalloc=%lu, mbufpop=%lu\n",
+			__func__, __LINE__, tx_count, tx_packets,
+			mbufalloc, mbufpop);/*TODO*/
+		if (dev->priv->hw_type == SPRDWL_HW_SDIO) {
+			if (!coex_bt_on)
+				sprdwl_add_topop_list(dev->tx_data_port,
+						      head, tail, tx_count);
+		}
+	}
+
+	return ret;
+}
+
+struct sprdwl_peer_entry
+*sprdwl_find_peer_entry_using_addr(struct sprdwl_vif *vif, u8 *addr)
+{
+	struct sprdwl_intf *intf;
+	struct sprdwl_peer_entry *peer_entry = NULL;
+	u8 i;
+
+	intf = (struct sprdwl_intf *)vif->priv->hw_priv;
+	for (i = 0; i < MAX_LUT_NUM; i++) {
+		if (ether_addr_equal(intf->peer_entry[i].tx.da, addr)) {
+			peer_entry = &intf->peer_entry[i];
+			break;
+		}
+	}
+	if (!peer_entry)
+		wl_err("not find peer_entry at :%s\n", __func__);
+
+	return peer_entry;
+}
+
+/* It is tx private function, just use in sprdwl_intf_fill_msdu_dscr()  */
+unsigned char sprdwl_find_lut_index(struct sprdwl_intf *intf,
+				    struct sprdwl_vif *vif)
+{
+	u8 ret;
+	unsigned char i;
+
+	if (intf->skb_da == NULL)/*TODO*/
+		goto out;
+
+	wl_debug("%s,bssid: %02x:%02x:%02x:%02x:%02x:%02x\n", __func__,
+		 intf->skb_da[0], intf->skb_da[1], intf->skb_da[2],
+		 intf->skb_da[3], intf->skb_da[4], intf->skb_da[5]);
+	if (sprdwl_is_group(intf->skb_da) &&
+	    (vif->mode == SPRDWL_MODE_AP || vif->mode == SPRDWL_MODE_P2P_GO)) {
+		for (i = 0; i < MAX_LUT_NUM; i++) {
+			if ((sprdwl_is_group(intf->peer_entry[i].tx.da)) &&
+			    (intf->peer_entry[i].ctx_id == vif->ctx_id)) {
+				wl_info("%s, %d, group lut_index=%d\n",
+					__func__, __LINE__,
+					intf->peer_entry[i].lut_index);
+				return intf->peer_entry[i].lut_index;
+			}
+		}
+		if (vif->mode == SPRDWL_MODE_AP) {
+			wl_info("%s,AP mode, group bssid,\n"
+				"lut not found, ctx_id:%d, return lut:4\n",
+				__func__, vif->ctx_id);
+			return 4;
+		}
+		if (vif->mode == SPRDWL_MODE_P2P_GO) {
+			wl_info("%s,GO mode, group bssid,\n"
+				"lut not found, ctx_id:%d, return lut:5\n",
+				__func__, vif->ctx_id);
+			return 5;
+		}
+	}
+
+	for (i = 0; i < MAX_LUT_NUM; i++) {
+		if ((0 == memcmp(intf->peer_entry[i].tx.da,
+				 intf->skb_da, ETH_ALEN)) &&
+		    (intf->peer_entry[i].ctx_id == vif->ctx_id)) {
+			wl_debug("%s, %d, lut_index=%d\n",
+				 __func__, __LINE__,
+				 intf->peer_entry[i].lut_index);
+			return intf->peer_entry[i].lut_index;
+		}
+	}
+
+	for (i = 0; i < MAX_LUT_NUM; i++) {
+		if ((vif->mode == SPRDWL_MODE_STATION ||
+		     vif->mode == SPRDWL_MODE_P2P_CLIENT) &&
+		    (intf->peer_entry[i].ctx_id == vif->ctx_id)) {
+			wl_debug("%s, %d, lut_index=%d\n",
+				 __func__, __LINE__,
+				 intf->peer_entry[i].lut_index);
+			return intf->peer_entry[i].lut_index;
+		}
+	}
+
+out:
+	switch (vif->mode) {
+	case SPRDWL_MODE_AP:
+		ret = 4;
+		break;
+
+	case SPRDWL_MODE_P2P_GO:
+		ret = 5;
+		break;
+
+	default:
+		ret = 0;
+		break;
+	}
+
+	wl_err("ctx_id = %d, sm_state = %d, bssid =%pM\n",
+			vif->ctx_id, vif->sm_state, intf->skb_da);
+
+	return ret;
+}
+
+int sprdwl_intf_fill_msdu_dscr(struct sprdwl_vif *vif,
+			       struct sk_buff *skb,
+				   u8 type,
+			       u8 offset)
+{
+	u8 protocol;
+	struct tx_msdu_dscr *dscr;
+	struct sprdwl_intf *dev;
+	u8 lut_index;
+	struct sk_buff *temp_skb;
+	unsigned char dscr_rsvd = 0;
+	struct ethhdr *ethhdr = (struct ethhdr *)skb->data;
+	u8 is_special_data = 0;
+	bool is_vowifi2cmd = false;
+#define DSCR_LEN	11
+#define MSG_PTR_LEN 8
+
+	if (ethhdr->h_proto == htons(ETH_P_ARP) ||
+		ethhdr->h_proto == htons(ETH_P_TDLS) ||
+		ethhdr->h_proto == htons(ETH_P_PREAUTH))
+		is_special_data = 1;
+	else if ((type == SPRDWL_TYPE_CMD) &&
+		 is_vowifi_pkt(skb, &is_vowifi2cmd))
+		is_special_data = 1;
+
+	dev = (struct sprdwl_intf *)(vif->priv->hw_priv);
+	dscr_rsvd = INTF_IS_PCIE ? MSDU_DSCR_RSVD : 0;
+	if (skb_headroom(skb) < (DSCR_LEN + dev->hif_offset +
+		MSG_PTR_LEN + dscr_rsvd)) {
+		temp_skb = skb;
+
+		skb = skb_realloc_headroom(skb, (DSCR_LEN + dev->hif_offset +
+						 MSG_PTR_LEN + dscr_rsvd));
+		kfree_skb(temp_skb);
+		if (skb == NULL) {
+			wl_err("%s:%d failed to unshare skbuff: NULL\n",
+			       __func__, __LINE__);
+			return -EPERM;
+		}
+#if defined(MORE_DEBUG)
+		dev->stats.tx_realloc++;
+#endif
+	}
+
+	dev->skb_da = skb->data;
+
+	lut_index = sprdwl_find_lut_index(dev, vif);
+	if ((lut_index < 6) && (!sprdwl_is_group(dev->skb_da))) {
+		wl_err("%s, %d, sta disconn, no data tx!", __func__, __LINE__);
+		return -EPERM;
+	}
+	skb_push(skb, sizeof(struct tx_msdu_dscr) + offset + dscr_rsvd);
+	dscr = (struct tx_msdu_dscr *)(skb->data);
+	memset(dscr, 0x00, sizeof(struct tx_msdu_dscr));
+	dscr->common.type = (type == SPRDWL_TYPE_CMD ?
+		SPRDWL_TYPE_CMD : SPRDWL_TYPE_DATA);
+	dscr->common.direction_ind = 0;
+	dscr->common.need_rsp = 0;/*TODO*/
+	dscr->common.interface = vif->ctx_id;
+	dscr->pkt_len = cpu_to_le16(skb->len - DSCR_LEN - dscr_rsvd);
+	dscr->offset = DSCR_LEN;
+/*TODO*/
+	dscr->tx_ctrl.sw_rate = (is_special_data == 1 ? 1 : 0);
+	dscr->tx_ctrl.wds = 0; /*TBD*/
+	dscr->tx_ctrl.swq_flag = 0; /*TBD*/
+	dscr->tx_ctrl.rsvd = 0; /*TBD*/
+	dscr->tx_ctrl.next_buffer_type = 0;
+	dscr->tx_ctrl.pcie_mh_readcomp = 0;
+	dscr->buffer_info.msdu_tid = 0;
+	dscr->buffer_info.mac_data_offset = 0;
+	dscr->sta_lut_index = lut_index;
+
+	if (skb->ip_summed == CHECKSUM_PARTIAL) {
+		dscr->tx_ctrl.checksum_offload = 1;
+		if (ethhdr->h_proto == htons(ETH_P_IPV6))
+			protocol = ipv6_hdr(skb)->nexthdr;
+		else
+			protocol = ip_hdr(skb)->protocol;
+
+		dscr->tx_ctrl.checksum_type =
+			protocol == IPPROTO_TCP ? 1 : 0;
+		dscr->tcp_udp_header_offset =
+			skb->transport_header - skb->mac_header;
+		wl_debug("%s: offload: offset: %d, protocol: %d\n",
+			 __func__, dscr->tcp_udp_header_offset, protocol);
+	}
+
+	return 0;
+}
+
+#if defined FPGA_LOOPBACK_TEST
+unsigned char tx_ipv4_udp[] = {
+0x02, 0x04, 0x00, 0x01, 0x00, 0x06, 0x40, 0x45,
+0xda, 0xf0, 0xff, 0x7e, 0x08, 0x00, 0x45, 0x00,
+0x00, 0xe4, 0xc8, 0xc0, 0x40, 0x00, 0x40, 0x11,
+0x8d, 0xb2, 0xc0, 0xa8, 0x31, 0x01, 0xc0, 0xa8,
+0x31, 0x44, 0x67, 0x62, 0x3c, 0xbe, 0x00, 0xd0,
+0xa0, 0x26, 0x80, 0x21, 0x81, 0x4b, 0x03, 0x68,
+0x2b, 0x37, 0xde, 0xad, 0xbe, 0xef, 0x47, 0x10,
+0x11, 0x35, 0xb1, 0x00, 0xff, 0xff, 0xff, 0xff,
+0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
+0xff, 0xff, 0xff, 0xff, 0xff, 0x80, 0x00, 0x00,
+0x00, 0x00, 0xAA, 0xBB};
+
+unsigned char tx_arp[] = {
+0x02, 0x00, 0x00, 0x01, 0x00, 0x06, 0x74, 0x27,
+0xea, 0xc8, 0x3e, 0x69, 0x08, 0x06, 0x00, 0x01,
+0x08, 0x00, 0x06, 0x04, 0x00, 0x01, 0x74, 0x27,
+0xea, 0xc8, 0x3e, 0x69, 0xc0, 0xa8, 0x01, 0x14,
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xc0, 0xa8,
+0x01, 0x6e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+0x00, 0x00, 0x00, 0x00, 0xaa, 0xbb};
+
+int sprdwl_intf_tx_data_fpga_test(struct sprdwl_intf *intf,
+				  unsigned char *data, int len)
+{
+	struct sprdwl_msg_buf *msg;
+	struct sk_buff *skb;
+	int ret;
+
+	wl_debug("%s: #%d start\n", __func__,  intf->loopback_n);
+	msg = sprdwl_get_msg_buf(intf, SPRDWL_TYPE_DATA,
+				 SPRDWL_MODE_STATION, 1);
+	if (!msg) {
+		wl_err("%s:%d get msg buf failed\n", __func__, __LINE__);
+		return -1;
+	}
+	if (data == NULL) {
+		skb = dev_alloc_skb(244 + NET_IP_ALIGN);
+		skb_reserve(skb, NET_IP_ALIGN);
+		memcpy(skb->data, tx_ipv4_udp, 244);
+		skb_put(skb, 244);
+	} else {
+		skb = dev_alloc_skb(len + NET_IP_ALIGN);
+		skb_reserve(skb, NET_IP_ALIGN);
+		memcpy(skb->data, data, len);
+		skb_put(skb, len);
+	}
+	ret = sprdwl_send_data_fpga_test(intf->priv,
+					 msg, skb, SPRDWL_TYPE_DATA, 0);
+	wl_debug("%s:%d loopback_n#%d end ret=%d\n", __func__, __LINE__,
+		 intf->loopback_n, ret);
+	intf->loopback_n++;
+	return ret;
+}
+
+int sprdwl_intf_fill_msdu_dscr_test(struct sprdwl_priv *priv,
+				    struct sk_buff *skb,
+				    u8 type,
+				    u8 offset)
+{
+	struct tx_msdu_dscr *dscr;
+	struct sprdwl_intf *dev;
+	u8 lut_index;
+	struct sk_buff *temp_skb;
+#define DSCR_LEN	11
+#define MSG_PTR_LEN 8
+
+	if (skb_headroom(skb) < (DSCR_LEN + intf->hif_offset + MSG_PTR_LEN)) {
+		temp_skb = skb;
+
+		skb = skb_realloc_headroom(skb, (DSCR_LEN + intf->hif_offset +
+						 MSG_PTR_LEN));
+		kfree_skb(temp_skb);
+		if (skb == NULL) {
+			wl_err("%s:%d failed to realloc skbuff: NULL\n",
+			       __func__, __LINE__);
+			return 0;
+		}
+	}
+	dev = (struct sprdwl_intf *)(priv->hw_priv);
+	dev->skb_da = skb->data;
+	lut_index = sprdwl_find_index_using_addr(dev);
+	skb_push(skb, sizeof(struct tx_msdu_dscr) + offset);
+	dscr = (struct tx_msdu_dscr *)(skb->data);
+	dscr->common.type = type;
+	dscr->pkt_len = cpu_to_le16(skb->len - (DSCR_LEN));
+	dscr->offset = DSCR_LEN;
+	dscr->tx_ctrl.checksum_offload = 1;
+	dscr->tx_ctrl.checksum_type =
+		ip_hdr(skb)->protocol == IPPROTO_TCP ? 1 : 0;
+	dscr->tx_ctrl.sw_rate = (type == SPRDWL_TYPE_DATA ? 0 : 1);
+	dscr->tx_ctrl.wds = 0;
+	dscr->sta_lut_index = lut_index;
+	dscr->tcp_udp_header_offset = 34;
+	return 1;
+}
+#endif
+
+int sprdwl_rx_fill_mbuf(struct mbuf_t *head, struct mbuf_t *tail, int num, int len)
+{
+	struct sprdwl_intf *intf = get_intf();
+	int ret = 0, count = 0;
+	struct mbuf_t *pos = NULL;
+
+	for (pos = head, count = 0; count < num; count++) {
+		pos->len = ALIGN(len, SMP_CACHE_BYTES);
+		pos->buf = netdev_alloc_frag(pos->len);
+		pos->phy = mm_virt_to_phys(intf->dev, pos->buf,
+					   pos->len, DMA_FROM_DEVICE);
+		if (unlikely(!pos->buf)) {
+			ret = -ENOMEM;
+			break;
+		}
+		pos = pos->next;
+	}
+
+	if (ret) {
+		pos = head;
+		while (count--) {
+			sprdwl_free_data(pos->buf, SPRDWL_DEFRAG_MEM);
+			pos = pos->next;
+		}
+	}
+
+	return ret;
+}
+
+int sprdwl_rx_common_push(int chn, struct mbuf_t **head, struct mbuf_t **tail,
+			  int *num, int len)
+{
+	int ret = 0;
+
+	ret = sprdwcn_bus_list_alloc(chn, head, tail, num);
+	if (ret || head == NULL) {
+		wl_err("%s:%d sprdwcn_bus_list_alloc fail\n", __func__, __LINE__);
+		ret = -ENOMEM;
+	} else {
+		ret = sprdwl_rx_fill_mbuf(*head, *tail, *num, len);
+		if (ret) {
+			wl_err("%s: alloc buf fail\n", __func__);
+			sprdwcn_bus_list_free(chn, *head, *tail, *num);
+			*head = NULL;
+			*tail = NULL;
+			*num = 0;
+		}
+	}
+
+	return ret;
+}
+
+inline void *sprdwl_get_rx_data(struct sprdwl_intf *intf,
+				void *pos, void **data,
+				void **tran_data, int *len, int offset)
+{
+	struct mbuf_t *mbuf = (struct mbuf_t *)pos;
+
+	if (intf->priv->hw_type == SPRDWL_HW_PCIE) {
+		mm_phys_to_virt(intf->dev, mbuf->phy, mbuf->len,
+				DMA_FROM_DEVICE, false);
+		mbuf->phy = 0;
+	}
+
+	*tran_data = mbuf->buf;
+	*data = (*tran_data) + offset;
+	*len = mbuf->len;
+	mbuf->buf = NULL;
+
+	return (void *)mbuf->next;
+}
+
+inline void sprdwl_free_rx_data(struct sprdwl_intf *intf,
+				int chn, void *head, void *tail, int num)
+{
+	int len = 0, ret = 0;
+
+	/* We should refill mbuf in pcie mode */
+	if (intf->priv->hw_type == SPRDWL_HW_PCIE) {
+		if (intf->rx_cmd_port == chn)
+			len = SPRDWL_MAX_CMD_RXLEN;
+		else
+			len = SPRDWL_MAX_DATA_RXLEN;
+
+		ret = sprdwl_rx_fill_mbuf(head, tail, num, len);
+		if (ret) {
+			wl_err("%s: alloc buf fail\n", __func__);
+			sprdwcn_bus_list_free(chn, (struct mbuf_t *)head,
+				       (struct mbuf_t *)tail, num);
+			head = NULL;
+			tail = NULL;
+			num = 0;
+		}
+	}
+
+	if (!ret)
+		sprdwcn_bus_push_list(chn, (struct mbuf_t *)head, (struct mbuf_t *)tail, num);
+}
+
+void sprdwl_count_rx_tp(struct sprdwl_rx_if *rx_if, int num)
+{
+	long long timeus = 0;
+	struct sprdwl_intf *intf = get_intf();
+
+	rx_if->rx_data_num += num;
+	if (rx_if->rx_data_num == num) {
+		rx_if->rxtimebegin = ktime_get();
+		return;
+	}
+
+	rx_if->rxtimeend = ktime_get();
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4, 10, 0)
+	timeus = div_u64(rx_if->rxtimeend.tv64 - rx_if->rxtimebegin.tv64, NSEC_PER_USEC);
+#else
+	timeus = ktime_to_us(rx_if->rxtimeend - rx_if->rxtimebegin);
+#endif
+	if (div_u64((rx_if->rx_data_num * 1000), timeus) >= intf->rxnum_level &&
+		rx_if->rx_data_num >= 1000) {
+		rx_if->rx_data_num = 0;
+		sprdwl_boost();
+	} else if (timeus >= USEC_PER_SEC) {
+		rx_if->rx_data_num = 0;
+	}
+}
+static int intf_rx_handle(int chn, struct mbuf_t *head,
+				   struct mbuf_t *tail, int num)
+{
+	struct sprdwl_intf *intf = get_intf();
+	struct sprdwl_rx_if *rx_if = (struct sprdwl_rx_if *)intf->sprdwl_rx;
+	struct sprdwl_msg_buf *msg = NULL;
+
+	wl_debug("%s: channel:%d head:%p tail:%p num:%d\n",
+		__func__, chn, head, tail, num);
+	if ((intf->priv->hw_type == SPRDWL_HW_SDIO && chn == SDIO_RX_DATA_PORT) ||
+		(intf->priv->hw_type == SPRDWL_HW_USB && chn == USB_RX_DATA_PORT))
+		sprdwl_count_rx_tp(rx_if, num);
+
+	/*To process credit earlier*/
+	if (intf->priv->hw_type == SPRDWL_HW_SDIO ||
+		intf->priv->hw_type == SPRDWL_HW_USB) {
+		unsigned int i = 0;
+		struct mbuf_t *mbuf = NULL;
+
+		mbuf = head;
+		for (i = num; i > 0; i--) {
+			sprdwl_sdio_process_credit(intf,
+				(void *)(mbuf->buf + intf->hif_offset));
+			mbuf = mbuf->next;
+		}
+	}
+
+	/* FIXME: Should we use replace msg? */
+	msg = sprdwl_alloc_msg_buf(&rx_if->rx_list);
+	if (!msg) {
+		wl_err("%s: no msgbuf\n", __func__);
+		sprdwcn_bus_push_list(chn, head, tail, num);
+		return 0;
+	}
+
+	sprdwl_fill_msg(msg, NULL, (void *)head, num);
+	msg->fifo_id = chn;
+	msg->buffer_type = SPRDWL_DEFRAG_MEM;
+	msg->data = (void *)tail;
+
+	sprdwl_queue_msg_buf(msg, &rx_if->rx_list);
+	queue_work(rx_if->rx_queue, &rx_if->rx_work);
+
+	return 0;
+}
+
+#ifdef RX_NAPI
+static int intf_napi_rx_handle(int chn, struct mbuf_t *head,
+					struct mbuf_t *tail, int num)
+{
+	struct sprdwl_intf *intf = get_intf();
+	struct sprdwl_rx_if *rx_if = (struct sprdwl_rx_if *)intf->sprdwl_rx;
+	struct sprdwl_msg_buf *msg = NULL;
+
+	wl_info("%s: channel:%d head:%p tail:%p num:%d\n",
+		__func__, chn, head, tail, num);
+
+	/* FIXME: Should we use replace msg? */
+	msg = sprdwl_alloc_msg_buf(&rx_if->rx_data_list);
+	if (!msg) {
+		wl_err("%s: no msgbuf\n", __func__);
+		sprdwcn_bus_push_list(chn, head, tail, num);
+		return 0;
+	}
+
+	sprdwl_fill_msg(msg, NULL, (void *)head, num);
+	msg->fifo_id = chn;
+	msg->buffer_type = SPRDWL_DEFRAG_MEM;
+	msg->data = (void *)tail;
+
+	sprdwl_queue_msg_buf(msg, &rx_if->rx_data_list);
+	napi_schedule(&rx_if->napi_rx);
+
+	return 0;
+}
+#endif
+
+void sprdwl_handle_pop_list(void *data)
+{
+	int i;
+	struct sprdwl_msg_buf *msg_pos;
+	struct mbuf_t *mbuf_pos = NULL;
+	struct sprdwl_pop_work *pop = (struct sprdwl_pop_work *)data;
+	struct sprdwl_tx_msg *tx_msg;
+	struct sprdwl_intf *intf = get_intf();
+	struct list_head tmp_list;
+	struct sprdwl_msg_buf *msg_head, *msg_tail;
+
+	tx_msg = (struct sprdwl_tx_msg *)intf->sprdwl_tx;
+	mbuf_pos = (struct mbuf_t *)pop->head;
+	msg_pos = GET_MSG_BUF(mbuf_pos);
+
+	msg_head = GET_MSG_BUF((struct mbuf_t *)pop->head);
+	msg_tail = GET_MSG_BUF((struct mbuf_t *)pop->tail);
+
+	spin_lock_bh(&tx_msg->xmit_msg_list.free_lock);
+	list_cut_position(&tmp_list, msg_head->list.prev, &msg_tail->list);
+	spin_unlock_bh(&tx_msg->xmit_msg_list.free_lock);
+
+	for (i = 0; i < pop->num; i++) {
+		msg_pos = GET_MSG_BUF(mbuf_pos);
+		dev_kfree_skb(msg_pos->skb);
+		mbuf_pos = mbuf_pos->next;
+	}
+
+	spin_lock_bh(&tx_msg->tx_list_qos_pool.freelock);
+	list_splice_tail(&tmp_list, &msg_pos->msglist->freelist);
+	spin_unlock_bh(&tx_msg->tx_list_qos_pool.freelock);
+	sprdwcn_bus_list_free(pop->chn,
+			      pop->head,
+			      pop->tail,
+			      pop->num);
+	mbufpop += pop->num;
+}
+
+/*call back func for HIF pop_link*/
+int sprdwl_tx_data_pop_list(int channel, struct mbuf_t *head, struct mbuf_t *tail, int num)
+{
+	struct mbuf_t *mbuf_pos = NULL;
+#if defined(MORE_DEBUG)
+	struct sprdwl_msg_buf *msg_head;
+#endif
+	struct sprdwl_intf *intf = get_intf();
+
+	wl_debug("%s channel: %d, head: %p, tail: %p num: %d\n",
+		__func__, channel, head, tail, num);
+
+	if (intf->priv->hw_type == SPRDWL_HW_PCIE) {
+		/* FIXME: Temp solution, addr node pos hard to sync dma */
+		for (mbuf_pos = head; mbuf_pos != NULL;
+		mbuf_pos = mbuf_pos->next) {
+			mm_phys_to_virt(intf->dev, mbuf_pos->phy,
+					mbuf_pos->len, DMA_TO_DEVICE, false);
+			mbuf_pos->phy = 0;
+			kfree(mbuf_pos->buf);
+			mbuf_pos->buf = NULL;
+			if (--num == 0)
+				break;
+		}
+		sprdwcn_bus_list_free(channel, head, tail, num);
+		wl_info("%s:%d free : %d msg buf\n", __func__, __LINE__, num);
+		return 0;
+	}
+#if defined(MORE_DEBUG)
+	msg_head = GET_MSG_BUF(head);
+	/*show packet average sent time, unit: ns*/
+	sprdwl_get_tx_avg_time(intf, msg_head->tx_start_time);
+#endif
+
+	sprdwl_add_topop_list(channel, head, tail, num);
+	wl_debug("%s:%d free : %d msg buf\n", __func__, __LINE__, num);
+
+	return 0;
+}
+
+/*free PCIe data when receive txc event from cp*/
+int sprdwl_tx_free_pcie_data(struct sprdwl_intf *dev, unsigned char *data,
+			     unsigned short len)
+{
+	int i;
+	struct sprdwl_tx_msg *tx_msg;
+	unsigned char *data_addr_ptr;
+	unsigned long pcie_addr, timeout;
+	unsigned short  data_num;
+	struct list_head *free_list;
+	struct txc_addr_buff *txc_addr;
+	unsigned char (*pos)[5];
+	struct sprdwl_msg_buf *msg_buf, *pos_buf, *temp_buf;
+#if defined(MORE_DEBUG)
+	unsigned long tx_start_time = 0;
+#endif
+
+	txc_addr = (struct txc_addr_buff *)data;
+	data_num = txc_addr->number;
+	pos = (unsigned char (*)[5])(txc_addr + 1);
+	for (i = 0; i < data_num; i++, pos++) {
+		memcpy(&pcie_addr, pos, SPRDWL_PHYS_LEN);
+		data_addr_ptr = (unsigned char *)
+		mm_phys_to_virt(dev->dev, pcie_addr,
+				SPRDWL_MAX_DATA_TXLEN, DMA_TO_DEVICE, true);
+		msg_buf = (struct sprdwl_msg_buf *)
+		(data_addr_ptr - (sizeof(unsigned long *) + dev->hif_offset));
+#if defined(MORE_DEBUG)
+		if (i == 0)
+			tx_start_time = msg_buf->tx_start_time;
+#endif
+		dev_kfree_skb(msg_buf->skb);
+		sprdwl_dequeue_data_buf(msg_buf);
+	}
+#if defined(MORE_DEBUG)
+	sprdwl_get_tx_avg_time(dev, tx_start_time);
+#endif
+	tx_msg = (struct sprdwl_tx_msg *)dev->sprdwl_tx;
+	free_list = &tx_msg->xmit_msg_list.to_free_list;
+	/*if cp fail to sent txc event, data will be freed timeout*/
+	if (!list_empty(free_list)) {
+		timeout = msecs_to_jiffies(SPRDWL_TX_DATA_TIMEOUT);
+		list_for_each_entry_safe(pos_buf,
+					 temp_buf, free_list, list) {
+			if (time_after(jiffies, pos_buf->timeout + timeout)) {
+				dev_kfree_skb(pos_buf->skb);
+				sprdwl_dequeue_data_buf(pos_buf);
+			} else {
+				return 0;
+			}
+		}
+	}
+	return 0;
+}
+
+int sprdwl_tx_cmd_pop_list(int channel, struct mbuf_t *head, struct mbuf_t *tail, int num)
+{
+	int count = 0;
+	struct mbuf_t *pos = NULL;
+	struct sprdwl_intf *intf = get_intf();
+	struct sprdwl_tx_msg *tx_msg;
+	struct sprdwl_msg_buf *pos_buf, *temp_buf;
+
+	wl_debug("%s channel: %d, head: %p, tail: %p num: %d\n",
+		 __func__, channel, head, tail, num);
+
+	tx_msg = (struct sprdwl_tx_msg *)intf->sprdwl_tx;
+
+	wl_debug("%s len: %d buf: %s\n", __func__, head->len, head->buf + 4);
+
+	pos = head;
+
+	list_for_each_entry_safe(pos_buf, temp_buf,
+				 &tx_msg->tx_list_cmd.cmd_to_free, list) {
+		if (pos_buf->tran_data == pos->buf) {
+			wl_debug("move CMD node from to_free to free list\n");
+			/*list msg_buf from to_free list  to free list*/
+			sprdwl_free_cmd_buf(pos_buf, &tx_msg->tx_list_cmd);
+
+			if (intf->priv->hw_type == SPRDWL_HW_PCIE) {
+				mm_phys_to_virt(intf->dev, pos->phy,
+						pos->len, DMA_TO_DEVICE, false);
+				pos->phy = 0;
+			}
+			/*free it*/
+			kfree(pos->buf);
+			pos->buf = NULL;
+			pos = pos->next;
+			count++;
+		}
+		if (count == num)
+			break;
+	}
+
+	tx_msg->cmd_poped += num;
+	mbufpop += num;
+	wl_info("tx_cmd_pop add num: %d=cmd_poped%d, cmd_send%d\n",
+		num, tx_msg->cmd_poped, tx_msg->cmd_send);
+	sprdwcn_bus_list_free(channel, head, tail, num);
+
+	return 0;
+}
+
+int sprdwl_rx_cmd_push(int chn, struct mbuf_t **head, struct mbuf_t **tail, int *num)
+{
+	return sprdwl_rx_common_push(chn, head, tail,
+				     num, SPRDWL_MAX_CMD_RXLEN);
+}
+
+int sprdwl_rx_data_push(int chn, struct mbuf_t **head, struct mbuf_t **tail, int *num)
+{
+	return sprdwl_rx_common_push(chn, head, tail,
+				     num, SPRDWL_MAX_DATA_RXLEN);
+}
+
+/*
+ * mode:
+ * 0 - suspend
+ * 1 - resume
+ */
+int sprdwl_suspend_resume_handle(int chn, int mode)
+{
+	struct sprdwl_intf *intf = get_intf();
+	struct sprdwl_priv *priv = intf->priv;
+	struct sprdwl_tx_msg *tx_msg = (struct sprdwl_tx_msg *)intf->sprdwl_tx;
+	int ret;
+	struct sprdwl_vif *vif;
+	struct timespec64 time;
+	enum sprdwl_mode sprdwl_mode = SPRDWL_MODE_STATION;
+	u8 mode_found = 0;
+
+	for (sprdwl_mode = SPRDWL_MODE_STATION; sprdwl_mode < SPRDWL_MODE_MAX; sprdwl_mode++) {
+		if (priv->fw_stat[sprdwl_mode] == SPRDWL_INTF_OPEN) {
+			mode_found = 1;
+			break;
+		}
+	}
+
+	if (0 == mode_found) {
+		wl_err("%s suspend failed, mode not found\n", __func__);
+		return -EBUSY;
+	}
+
+	vif = mode_to_vif(priv, sprdwl_mode);
+	if (vif == NULL || intf->cp_asserted) {
+		wl_err("%s, %d, error! NULL vif or assert\n", __func__, __LINE__);
+		sprdwl_put_vif(vif);
+		return -EBUSY;
+	}
+
+	if (mode == 0) {
+		if (atomic_read(&tx_msg->tx_list_qos_pool.ref) > 0 ||
+			atomic_read(&tx_msg->tx_list_cmd.ref) > 0 ||
+			!list_empty(&tx_msg->xmit_msg_list.to_send_list) ||
+			!list_empty(&tx_msg->xmit_msg_list.to_free_list)) {
+			wl_info("%s, %d,Q not empty suspend not allowed\n",
+				__func__, __LINE__);
+			sprdwl_put_vif(vif);
+			return -EBUSY;
+		}
+		priv->wakeup_tracer.resume_flag = 0;
+		intf->suspend_mode = SPRDWL_PS_SUSPENDING;
+		ktime_get_real_ts64(&time);
+		intf->sleep_time = timespec64_to_ns(&time);
+		priv->is_suspending = 1;
+		ret = sprdwl_power_save(priv,
+					vif->ctx_id,
+					SPRDWL_SUSPEND_RESUME,
+					0);
+		if (ret == 0)
+			intf->suspend_mode = SPRDWL_PS_SUSPENDED;
+		else
+			intf->suspend_mode = SPRDWL_PS_RESUMED;
+		sprdwl_put_vif(vif);
+		wl_info("power save ret = %d\n", ret);
+		return ret;
+	} else if (mode == 1) {
+		intf->suspend_mode = SPRDWL_PS_RESUMING;
+		priv->wakeup_tracer.resume_flag = 1;
+		ktime_get_real_ts64(&time);
+		intf->sleep_time = timespec64_to_ns(&time) - intf->sleep_time;
+		ret = sprdwl_power_save(priv,
+					vif->ctx_id,
+					SPRDWL_SUSPEND_RESUME,
+					1);
+		wl_info("%s, %d,resume ret=%d, resume after %lu ms\n",
+			__func__, __LINE__,
+			ret, intf->sleep_time/1000000);
+		sprdwl_put_vif(vif);
+		return ret;
+	}
+	sprdwl_put_vif(vif);
+	return -EBUSY;
+}
+
+/*  SDIO TX:
+ *  Type 3:WIFI
+ *  Subtype 0  --> port 8
+ *  Subtype 1  --> port 9
+ *  Subtype 2  --> port 10(fifolen=8)
+ *  Subtype 3  --> port 11(fifolen=8)
+ *  SDIO RX:
+ *  Type 3:WIFI
+ *  Subtype 0  --> port 10
+ *  Subtype 1  --> port 11
+ *  Subtype 2  --> port 12(fifolen=8)
+ *  Subtype 3  --> port 13(fifolen=8)
+ */
+struct mchn_ops_t sdio_hif_ops[] = {
+	/* RX INTF */
+	/* NOTE: Requested by SDIO team, pool_size MUST be 1 in RX */
+	INIT_INTF(SDIO_RX_CMD_PORT, 0, 0, 0,
+		  SPRDWL_MAX_CMD_RXLEN, 1, 0, 0, 0,
+		  intf_rx_handle, NULL, NULL, NULL),
+	INIT_INTF(SDIO_RX_PKT_LOG_PORT, 0, 0, 0,
+		  SPRDWL_MAX_DATA_RXLEN, 1, 0, 0, 0,
+		  intf_rx_handle, NULL, NULL, NULL),
+#ifdef RX_NAPI
+	INIT_INTF(SDIO_RX_DATA_PORT, 0, 0, 0,
+		  SPRDWL_MAX_DATA_RXLEN, 1, 0, 0, 0,
+		  intf_napi_rx_handle, NULL, NULL, NULL),
+#else
+	INIT_INTF(SDIO_RX_DATA_PORT, 0, 0, 0,
+		  SPRDWL_MAX_DATA_RXLEN, 1, 0, 0, 0,
+		  intf_rx_handle, NULL, NULL, NULL),
+#endif
+
+	/* TX INTF */
+	INIT_INTF(SDIO_TX_CMD_PORT, 0, 1, 0,
+		  SPRDWL_MAX_CMD_TXLEN, 10, 0, 0, 0,
+		  sprdwl_tx_cmd_pop_list, NULL, NULL,
+		  sprdwl_suspend_resume_handle),
+	INIT_INTF(SDIO_TX_DATA_PORT, 0, 1, 0,
+		  SPRDWL_MAX_DATA_TXLEN, 800, 0, 0, 0,
+		  sprdwl_tx_data_pop_list, NULL, NULL, NULL),
+};
+
+struct mchn_ops_t pcie_hif_ops[] = {
+	/* RX INTF */
+	INIT_INTF(PCIE_RX_CMD_PORT, 1, 0, 0,
+		  SPRDWL_MAX_CMD_RXLEN, 1, 0, 0, 0,
+		  intf_rx_handle,
+		  sprdwl_rx_cmd_push, NULL, NULL),
+	INIT_INTF(PCIE_RX_DATA_PORT, 1, 0, 0,
+		  SPRDWL_MAX_DATA_RXLEN, 1, 0, 0, 0,
+		  intf_rx_handle,
+		  sprdwl_rx_data_push, NULL, NULL),
+	/* TX INTF */
+	INIT_INTF(SDIO_TX_CMD_PORT, 1, 1, 0,
+		  SPRDWL_MAX_CMD_TXLEN, 10, 0, 0, 0,
+		  sprdwl_tx_cmd_pop_list, NULL, NULL, NULL),
+	INIT_INTF(SDIO_TX_DATA_PORT, 1, 1, 0,
+		  SPRDWL_MAX_DATA_TXLEN, 300, 0, 0, 0,
+		  sprdwl_tx_data_pop_list, NULL, NULL, NULL)
+};
+
+struct mchn_ops_t usb_hif_ops[] = {
+	/* RX INTF */
+	INIT_INTF(USB_RX_CMD_PORT, 3, 0, 0,
+		  SPRDWL_MAX_CMD_RXLEN, 10, 0, 0, 0,
+		  intf_rx_handle, NULL, NULL, NULL),
+	INIT_INTF(USB_RX_PKT_LOG_PORT, 3, 0, 0,
+		  SPRDWL_MAX_DATA_RXLEN, 50, 0, 0, 0,
+		  intf_rx_handle, NULL, NULL, NULL),
+#ifndef RX_NAPI
+	INIT_INTF(USB_RX_DATA_PORT, 3, 0, 0,
+		  SPRDWL_MAX_DATA_RXLEN, 1000, 0, 0, 0,
+		  intf_rx_handle, NULL, NULL, NULL),
+#else
+	INIT_INTF(USB_RX_DATA_PORT, 3, 0, 0,
+		  SPRDWL_MAX_DATA_RXLEN, 300, 0, 0, 0,
+		  intf_napi_rx_handle, NULL, NULL, NULL),
+#endif
+
+	/* TX INTF */
+	INIT_INTF(USB_TX_CMD_PORT, 3, 1, 0,
+		  SPRDWL_MAX_CMD_TXLEN, 20, 0, 0, 0,
+		  sprdwl_tx_cmd_pop_list, NULL, NULL,
+		  sprdwl_suspend_resume_handle),
+	INIT_INTF(USB_TX_DATA_PORT, 3, 1, 0,
+		  SPRDWL_MAX_DATA_TXLEN, 300, 0, 0, 0,
+		  sprdwl_tx_data_pop_list, NULL, NULL, NULL),
+};
+
+struct sprdwl_peer_entry
+*sprdwl_find_peer_entry_using_lut_index(struct sprdwl_intf *intf,
+					unsigned char sta_lut_index)
+{
+	int i = 0;
+	struct sprdwl_peer_entry *peer_entry = NULL;
+
+	for (i = 0; i < MAX_LUT_NUM; i++) {
+		if (sta_lut_index == intf->peer_entry[i].lut_index) {
+			peer_entry = &intf->peer_entry[i];
+			break;
+		}
+	}
+
+	return peer_entry;
+}
+
+/* update lut-inidex if event_sta_lut received
+ * at CP side, lut_index range 0-31
+ * but 0-3 were used to send non-assoc frame(only used by CP)
+ * so for Ap-CP interface, there is only 4-31
+*/
+void sprdwl_event_sta_lut(struct sprdwl_vif *vif, u8 *data, u16 len)
+{
+	struct sprdwl_intf *intf;
+	struct sprdwl_sta_lut_ind *sta_lut = NULL;
+	u8 i;
+
+	if (len < sizeof(*sta_lut)) {
+		wl_err("%s, len:%d too short!\n", __func__, len);
+		return;
+	}
+	intf = (struct sprdwl_intf *)vif->priv->hw_priv;
+	sta_lut = (struct sprdwl_sta_lut_ind *)data;
+	if (intf != get_intf()) {
+		wl_err("%s, wrong intf!\n", __func__);
+		return;
+	}
+	if (sta_lut == NULL) {
+		wl_err("%s, NULL input data!\n", __func__);
+		return;
+	}
+
+	i = sta_lut->sta_lut_index;
+
+	wl_debug("ctx_id:%d,action:%d,lut:%d\n", sta_lut->ctx_id,
+		sta_lut->action, sta_lut->sta_lut_index);
+	switch (sta_lut->action) {
+	case DEL_LUT_INDEX:
+		if (intf->peer_entry[i].ba_tx_done_map != 0) {
+			intf->peer_entry[i].ht_enable = 0;
+			intf->peer_entry[i].ip_acquired = 0;
+			intf->peer_entry[i].ba_tx_done_map = 0;
+			/*sprdwl_tx_delba(intf, intf->peer_entry + i);*/
+		}
+		peer_entry_delba((void *)intf, i);
+		memset(&intf->peer_entry[i], 0x00,
+		       sizeof(struct sprdwl_peer_entry));
+		intf->peer_entry[i].ctx_id = 0xFF;
+		intf->tx_num[i] = 0;
+		sprdwl_dis_flush_txlist(intf, i);
+		break;
+	case UPD_LUT_INDEX:
+		peer_entry_delba((void *)intf, i);
+		sprdwl_dis_flush_txlist(intf, i);
+	case ADD_LUT_INDEX:
+		intf->peer_entry[i].lut_index = i;
+		intf->peer_entry[i].ctx_id = sta_lut->ctx_id;
+		intf->peer_entry[i].ht_enable = sta_lut->is_ht_enable;
+		intf->peer_entry[i].vht_enable = sta_lut->is_vht_enable;
+		intf->peer_entry[i].ba_tx_done_map = 0;
+		intf->tx_num[i] = 0;
+
+		wl_debug("ctx_id%d,action%d,lut%d,%x:%x:%x:%x:%x:%x\n",
+			sta_lut->ctx_id, sta_lut->action,
+			sta_lut->sta_lut_index,
+			sta_lut->ra[0], sta_lut->ra[1], sta_lut->ra[2],
+			sta_lut->ra[3], sta_lut->ra[4], sta_lut->ra[5]);
+		ether_addr_copy(intf->peer_entry[i].tx.da, sta_lut->ra);
+		break;
+	default:
+		break;
+	}
+}
+
+void sprdwl_tx_ba_mgmt(struct sprdwl_priv *priv, void *data, int len,
+		       unsigned char cmd_id, unsigned char ctx_id)
+{
+	struct sprdwl_msg_buf *msg;
+	unsigned char *data_ptr;
+	u8 *rbuf;
+	u16 rlen = (1 + sizeof(struct host_addba_param));
+
+	msg = sprdwl_cmd_getbuf(priv, len, ctx_id, SPRDWL_HEAD_RSP,
+				cmd_id);
+	if (!msg) {
+		wl_err("%s, %d, get msg err\n", __func__, __LINE__);
+		return;
+	}
+	rbuf = kzalloc(rlen, GFP_KERNEL);
+	if (!rbuf) {
+		wl_err("%s, %d, alloc rbuf err\n", __func__, __LINE__);
+		return;
+	}
+	memcpy(msg->data, data, len);
+	data_ptr = (unsigned char *)data;
+
+	if (sprdwl_debug_level >= L_DBG)
+		sprdwl_hex_dump("sprdwl_tx_ba_mgmt", data_ptr, len);
+
+	if (sprdwl_cmd_send_recv(priv, msg, CMD_WAIT_TIMEOUT, rbuf, &rlen))
+		goto out;
+	/*if tx ba req failed, need to clear txba map*/
+	if (cmd_id == WIFI_CMD_ADDBA_REQ &&
+		rbuf[0] != ADDBA_REQ_RESULT_SUCCESS) {
+		struct host_addba_param *addba;
+		struct sprdwl_peer_entry *peer_entry = NULL;
+		struct sprdwl_intf *intf = get_intf();
+		u16 tid = 0;
+
+		addba = (struct host_addba_param *)(rbuf + 1);
+		peer_entry = &intf->peer_entry[addba->lut_index];
+		tid = addba->addba_param.tid;
+		if (!test_and_clear_bit(tid, &peer_entry->ba_tx_done_map))
+			goto out;
+		wl_err("%s, %d, tx_addba failed, reason=%d, lut_index=%d, tid=%d, map=%lu\n",
+		       __func__, __LINE__,
+		       rbuf[0],
+		       addba->lut_index,
+		       tid,
+		       peer_entry->ba_tx_done_map);
+	}
+out:
+	kfree(rbuf);
+}
+
+void sprdwl_tx_send_addba(struct sprdwl_vif *vif, void *data, int len)
+{
+	sprdwl_tx_ba_mgmt(vif->priv, data, len, WIFI_CMD_ADDBA_REQ,
+			  vif->ctx_id);
+}
+
+void sprdwl_tx_send_delba(struct sprdwl_vif *vif, void *data, int len)
+{
+	u8 i;
+	struct host_delba_param *delba;
+
+	delba = (struct host_delba_param *)data;
+	for (i = 0; i < SPRDWL_AC_MAX; i++)
+			sprdwl_tx_ba_mgmt(vif->priv, delba + i,
+					  sizeof(struct host_delba_param),
+					  WIFI_CMD_DELBA_REQ,
+					  vif->ctx_id);
+}
+
+void sprdwl_tx_addba(struct sprdwl_intf *intf,
+		     struct sprdwl_peer_entry *peer_entry, unsigned char tid)
+{
+#define WIN_SIZE 64
+	struct host_addba_param addba;
+	struct sprdwl_work *misc_work;
+	struct sprdwl_vif *vif;
+
+	vif = ctx_id_to_vif(intf->priv, peer_entry->ctx_id);
+	if (!vif)
+		return;
+	memset(&addba, 0x0, sizeof(struct host_addba_param));
+
+	addba.lut_index = peer_entry->lut_index;
+	ether_addr_copy(addba.perr_mac_addr, peer_entry->tx.da);
+	wl_debug("%s, lut_index is %d\n", __func__, peer_entry->lut_index);
+	addba.dialog_token = 1;
+	addba.addba_param.amsdu_permit = 0;
+	addba.addba_param.ba_policy = DOT11_ADDBA_POLICY_IMMEDIATE;
+	addba.addba_param.tid = tid;
+	addba.addba_param.buffer_size = WIN_SIZE;
+	misc_work = sprdwl_alloc_work(sizeof(struct host_addba_param));
+	if (!misc_work) {
+		wl_err("%s out of memory\n", __func__);
+		sprdwl_put_vif(vif);
+		return;
+	}
+	misc_work->vif = vif;
+	misc_work->id = SPRDWL_WORK_ADDBA;
+	memcpy(misc_work->data, &addba, sizeof(struct host_addba_param));
+
+	sprdwl_queue_work(vif->priv, misc_work);
+	sprdwl_put_vif(vif);
+}
+
+void sprdwl_tx_delba(struct sprdwl_intf *intf,
+		     struct sprdwl_peer_entry *peer_entry,  unsigned int ac_index)
+{
+	struct host_delba_param delba[SPRDWL_AC_MAX];
+	struct sprdwl_work *misc_work;
+	struct sprdwl_vif *vif;
+
+	vif = ctx_id_to_vif(intf->priv, peer_entry->ctx_id);
+	if (!vif)
+		return;
+	memset(delba, 0x0, sizeof(delba));
+
+	wl_info("enter--at %s\n", __func__);
+	ether_addr_copy(delba[ac_index].perr_mac_addr, peer_entry->tx.da);
+	delba[ac_index].lut_index = peer_entry->lut_index;
+	delba[ac_index].delba_param.initiator = 1;
+	delba[ac_index].delba_param.tid = qos_index_2_tid(ac_index);
+	delba[ac_index].reason_code = 0;
+
+
+	misc_work =
+	sprdwl_alloc_work(sizeof(struct host_delba_param) * SPRDWL_AC_MAX);
+	if (!misc_work) {
+		wl_err("%s out of memory\n", __func__);
+		sprdwl_put_vif(vif);
+		return;
+	}
+	misc_work->vif = vif;
+	misc_work->id = SPRDWL_WORK_DELBA;
+	memcpy(misc_work->data, delba,
+	       sizeof(struct host_delba_param) * SPRDWL_AC_MAX);
+	peer_entry->ht_enable = 0;
+	peer_entry->ba_tx_done_map = 0;
+
+	sprdwl_queue_work(vif->priv, misc_work);
+	sprdwl_put_vif(vif);
+}
+
+/*int sprdwl_notifier_boost(struct notifier_block *nb, unsigned long event, void *data)
+{
+	struct cpufreq_policy *policy = data;
+	unsigned long min_freq;
+	unsigned long max_freq = policy->cpuinfo.max_freq;
+	struct sprdwl_intf *intf = get_intf();
+	u8 boost = intf->boost;
+
+	if (event != CPUFREQ_ADJUST)
+		return NOTIFY_DONE;
+
+	min_freq = boost ? 1200000 : 400000;
+	cpufreq_verify_within_limits(policy, min_freq, max_freq);
+
+	return NOTIFY_OK;
+}*/
+
+void sprdwl_boost(void)
+{
+	struct sprdwl_intf *intf = get_intf();
+
+	if (intf->boost == 0) {
+		intf->boost = 1;
+		cpufreq_update_policy(0);
+	}
+}
+
+void sprdwl_unboost(void)
+{
+	struct sprdwl_intf *intf = get_intf();
+
+	if (intf->boost == 1) {
+		intf->boost = 0;
+		cpufreq_update_policy(0);
+	}
+}
+
+void adjust_txnum_level(char *buf, unsigned char offset)
+{
+#define MAX_LEN 4
+	unsigned int cnt = 0;
+	unsigned int i = 0;
+	struct sprdwl_intf *intf = get_intf();
+
+	for (i = 0; i < MAX_LEN; (cnt *= 10), i++) {
+		if ((buf[offset + i] >= '0') &&
+		   (buf[offset + i] <= '9')) {
+			cnt += (buf[offset + i] - '0');
+		} else {
+			cnt /= 10;
+			break;
+		}
+	}
+
+	if (cnt < 0 || cnt > 9999)
+		cnt = BOOST_TXNUM_LEVEL;
+	intf->txnum_level = cnt;
+	wl_info("credit_level: %d\n", intf->txnum_level);
+#undef MAX_LEN
+}
+
+void adjust_rxnum_level(char *buf, unsigned char offset)
+{
+#define MAX_LEN 2
+	unsigned int cnt = 0;
+	unsigned int i = 0;
+	struct sprdwl_intf *intf = get_intf();
+
+	for (i = 0; i < MAX_LEN; (cnt *= 10), i++) {
+		if ((buf[offset + i] >= '0') &&
+		   (buf[offset + i] <= '9')) {
+			cnt += (buf[offset + i] - '0');
+		} else {
+			cnt /= 10;
+			break;
+		}
+	}
+
+	if (cnt < 0 || cnt > 99)
+		cnt = BOOST_RXNUM_LEVEL;
+	intf->rxnum_level = cnt;
+	wl_info("rxnum_level: %d\n", intf->rxnum_level);
+#undef MAX_LEN
+}
+
+int sprdwl_intf_init(struct sprdwl_priv *priv, struct sprdwl_intf *intf)
+{
+	int ret = -EINVAL, chn = 0;
+
+	if (priv->hw_type == SPRDWL_HW_SDIO) {
+		g_intf_ops.hif_ops = sdio_hif_ops;
+		g_intf_ops.max_num =
+			sizeof(sdio_hif_ops)/sizeof(struct mchn_ops_t);
+	} else if (priv->hw_type == SPRDWL_HW_PCIE) {
+		g_intf_ops.hif_ops = pcie_hif_ops;
+		g_intf_ops.max_num =
+			sizeof(pcie_hif_ops)/sizeof(struct mchn_ops_t);
+	} else if (priv->hw_type == SPRDWL_HW_USB) {
+		g_intf_ops.hif_ops = usb_hif_ops;
+		g_intf_ops.max_num =
+			sizeof(usb_hif_ops)/sizeof(struct mchn_ops_t);
+	}
+
+	if (g_intf_ops.max_num < MAX_CHN_NUM) {
+		wl_info("%s: register %d ops\n",
+			__func__, g_intf_ops.max_num);
+
+		for (chn = 0; chn < g_intf_ops.max_num; chn++) {
+			ret = sprdwcn_bus_chn_init(&g_intf_ops.hif_ops[chn]);
+			if (ret < 0)
+				goto err;
+		}
+
+		g_intf_ops.intf = (void *)intf;
+		/* TODO: Need we reserve g_intf_ops? */
+		intf->hw_intf = (void *)&g_intf_ops;
+
+		priv->hw_priv = intf;
+		priv->hw_offset = intf->hif_offset;
+		intf->priv = priv;
+		intf->fw_awake = 1;
+		intf->fw_power_down = 0;
+		intf->txnum_level = BOOST_TXNUM_LEVEL;
+		intf->rxnum_level = BOOST_RXNUM_LEVEL;
+		intf->boost = 0;
+	} else {
+err:
+		wl_err("%s: unregister %d ops\n",
+		       __func__, g_intf_ops.max_num);
+
+		for (; chn > 0; chn--)
+			sprdwcn_bus_chn_deinit(&g_intf_ops.hif_ops[chn]);
+
+		g_intf_ops.hif_ops = NULL;
+		g_intf_ops.max_num = 0;
+	}
+
+	return ret;
+}
+
+void sprdwl_intf_deinit(struct sprdwl_intf *dev)
+{
+	int chn = 0;
+
+	for (chn = 0; chn < g_intf_ops.max_num; chn++)
+		sprdwcn_bus_chn_deinit(&g_intf_ops.hif_ops[chn]);
+
+	g_intf_ops.intf = NULL;
+	g_intf_ops.max_num = 0;
+	dev->hw_intf = NULL;
+}
+
+int sprdwl_dis_flush_txlist(struct sprdwl_intf *intf, u8 lut_index)
+{
+	struct sprdwl_tx_msg *tx_msg;
+	int i, j;
+
+	if (lut_index <= 5) {
+		wl_err("err lut_index:%d, %s, %d\n",
+				lut_index, __func__, __LINE__);
+		return -1;
+	}
+	wl_debug("disconnect, flush qoslist, %s, %d\n", __func__, __LINE__);
+	tx_msg = (struct sprdwl_tx_msg *)intf->sprdwl_tx;
+	for (i = 0; i < SPRDWL_MODE_MAX; i++)
+		for (j = 0; j < SPRDWL_AC_MAX; j++)
+				sprdwl_flush_tx_qoslist(tx_msg, i, j, lut_index);
+	return 0;
+}
diff --git a/drivers/net/wireless/uwe5622/unisocwifi/wl_intf.h b/drivers/net/wireless/uwe5622/unisocwifi/wl_intf.h
new file mode 100644
index 000000000000..e55a35a66b63
--- /dev/null
+++ b/drivers/net/wireless/uwe5622/unisocwifi/wl_intf.h
@@ -0,0 +1,302 @@
+/*
+ * Copyright (C) 2015 Spreadtrum Communications Inc.
+ *
+ * Authors	:
+ * Keguang Zhang <keguang.zhang@spreadtrum.com>
+ * Jingxiang Li <Jingxiang.li@spreadtrum.com>
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#ifndef __WL_INTF_H__
+#define __WL_INTF_H__
+
+#include <linux/types.h>
+#include <linux/wait.h>
+#include <linux/spinlock.h>
+#include <linux/workqueue.h>
+#include <linux/cpufreq.h>
+#include "wl_core.h"
+#include <wcn_bus.h>
+
+#define HW_TYPE_SDIO 0
+#define HW_TYPE_PCIE 1
+#define HW_TYPE_SIPC 2
+#define HW_TYPE_USB 3
+
+#define SDIO_RX_CMD_PORT	22
+#define SDIO_RX_PKT_LOG_PORT	23
+/*use port 24 because fifo_len = 8*/
+#define SDIO_RX_DATA_PORT	24
+#define SDIO_TX_CMD_PORT	8
+/*use port 10 because fifo_len = 8*/
+#define SDIO_TX_DATA_PORT	10
+
+#define PCIE_RX_CMD_PORT	22
+#define PCIE_RX_DATA_PORT	23
+#define PCIE_TX_CMD_PORT	2
+#define PCIE_TX_DATA_PORT	3
+
+#define USB_RX_CMD_PORT	20
+#define USB_RX_PKT_LOG_PORT	21
+#define USB_RX_DATA_PORT	22
+#define USB_TX_CMD_PORT	4
+#define USB_TX_DATA_PORT	6
+
+#define MSDU_DSCR_RSVD	5
+
+#define DEL_LUT_INDEX 0
+#define ADD_LUT_INDEX 1
+#define UPD_LUT_INDEX 2
+
+#define BOOST_TXNUM_LEVEL	16
+#define BOOST_RXNUM_LEVEL	16
+
+#ifdef SPRDWL_TX_SELF
+#include <linux/wakelock.h>
+struct sprdwl_tx_buf {
+	unsigned char   *base;
+	unsigned short  buf_len;
+	unsigned short  curpos;
+	int change_size;
+};
+#endif
+
+#define MAX_CHN_NUM 16
+struct sprdwl_intf_ops {
+	unsigned int max_num;
+	void *intf;
+	struct mchn_ops_t *hif_ops;
+};
+
+struct sdiohal_puh {
+	unsigned int pad:6;
+	unsigned int check_sum:1;
+	unsigned int len:16;
+	unsigned int eof:1;
+	unsigned int subtype:4;
+	unsigned int type:4;
+}; /* 32bits public header */
+
+struct tx_msdu_dscr {
+	struct {
+		/*0:cmd, 1:event, 2:normal data,*/
+		/*3:special data, 4:PCIE remote addr*/
+		unsigned char type:3;
+		/*direction of address buffer of cmd/event,*/
+		/*0:Tx, 1:Rx*/
+		unsigned char direction_ind:1;
+		unsigned char need_rsp:1;
+		/*ctxt_id*/
+		unsigned char interface:3;
+	} common;
+	unsigned char offset;
+	struct {
+		/*1:need HW to do checksum*/
+		unsigned char checksum_offload:1;
+		/*0:udp, 1:tcp*/
+		unsigned char checksum_type:1;
+		/*1:use SW rate,no aggregation 0:normal*/
+		unsigned char sw_rate:1;
+		/*WDS frame*/
+		unsigned char wds:1;
+		/*1:frame sent from SWQ to MH,
+		 *0:frame sent from TXQ to MH,
+		   default:0
+		 */
+		unsigned char swq_flag:1;
+		unsigned char rsvd:1;
+		/*used by PCIe address buffer, need set default:0*/
+		unsigned char next_buffer_type:1;
+		/*used by PCIe address buffer, need set default:0*/
+		unsigned char pcie_mh_readcomp:1;
+	} tx_ctrl;
+	unsigned short pkt_len;
+	struct {
+		unsigned char msdu_tid:4;
+		unsigned char mac_data_offset:4;
+	} buffer_info;
+	unsigned char sta_lut_index;
+	unsigned char color_bit:2;
+	unsigned short rsvd:14;
+	unsigned short tcp_udp_header_offset;
+} __packed;
+
+struct pcie_addr_buffer {
+	struct {
+		unsigned char type:3;
+		/*direction of address buffer of cmd/event,*/
+		/*0:Tx, 1:Rx*/
+		unsigned char direction_ind:1;
+		unsigned char need_rsp:1;
+		unsigned char interface:3;
+	} common;
+	unsigned short number;
+	unsigned char offset;
+	struct {
+		unsigned char rsvd:6;
+		unsigned char buffer_type:1;
+		unsigned char buffer_inuse:1;
+	} buffer_ctrl;
+	unsigned char pcie_addr[0][5];
+} __packed;
+
+struct txc_addr_buff {
+	struct {
+		unsigned char type:3;
+		unsigned char direction_ind:1;
+		unsigned char need_rsp:1;
+		unsigned char interface:3;
+	} common;
+	/*addr offset from common*/
+	unsigned char offset;
+	struct {
+		unsigned char cksum:1;
+		unsigned char cksum_type:1;
+		unsigned char sw_ctrl:1;
+		unsigned char wds:1;
+		unsigned char swq_flag:1;
+		unsigned char rsvd:1;
+		/*0: data buffer, 1: address buffer*/
+		unsigned char next_buffer_type:1;
+		/*used only by address buffer*/
+		/*0: MH process done, 1: before send to MH*/
+		unsigned char mh_done:1;
+	} tx_ctrl;
+	unsigned short number;
+	unsigned short rsvd;
+} __packed;
+
+#define GET_MSG_BUF(ptr) \
+	((struct sprdwl_msg_buf *) \
+	(*(unsigned long *)((ptr)->buf - sizeof(unsigned long *))))
+
+#if defined(MORE_DEBUG)
+#define STATS_COUNT 200
+
+#define UPDATE_TX_PACKETS(dev, tx_count, tx_bytes) do { \
+	(dev)->stats.tx_packets += (tx_count); \
+	(dev)->stats.tx_bytes += (tx_bytes); \
+	(dev)->stats.gap_num += (tx_count); \
+} while (0)
+#endif
+
+#define DOT11_ADDBA_POLICY_DELAYED	0 /* delayed BA policy */
+
+#define DOT11_ADDBA_POLICY_IMMEDIATE	1 /* immediate BA policy */
+
+enum addba_req_result {
+	ADDBA_REQ_RESULT_SUCCESS,
+	ADDBA_REQ_RESULT_FAIL,
+	ADDBA_REQ_RESULT_TIMEOUT,
+	ADDBA_REQ_RESULT_DECLINE,
+};
+
+struct ieeetypes_addba_param {
+	u16 amsdu_permit : 1;
+	u16 ba_policy : 1;
+	u16 tid : 4;
+	u16 buffer_size : 10;
+} __packed;
+
+struct ieeetypes_delba_param {
+	u16 reserved : 11;
+	u16 initiator : 1;
+	u16 tid : 4;
+} __packed;
+
+struct host_addba_param {
+	u8 lut_index;
+	u8 perr_mac_addr[6];
+	u8 dialog_token;
+	struct ieeetypes_addba_param addba_param;
+	u16 timeout;
+} __packed;
+
+struct host_delba_param {
+	u8 lut_index;
+	u8 perr_mac_addr[6];
+	struct ieeetypes_delba_param delba_param;
+	u16 reason_code;
+} __packed;
+
+struct sprdwl_pop_work {
+	int chn;
+	void *head;
+	void *tail;
+	int num;
+};
+
+static inline bool sprdwl_is_group(unsigned char *addr)
+{
+	if ((addr[0] & BIT(0)) != 0)
+		return true;
+
+	return false;
+}
+
+int sprdwl_intf_init(struct sprdwl_priv *priv, struct sprdwl_intf *intf);
+void sprdwl_intf_deinit(struct sprdwl_intf *dev);
+int if_tx_cmd(struct sprdwl_intf *intf, unsigned char *data, int len);
+int if_tx_addr_trans(struct sprdwl_intf *intf, unsigned char *data, int len);
+int sprdwl_intf_tx_list(struct sprdwl_intf *dev,
+			struct list_head *tx_list,
+			struct list_head *tx_list_head,
+			int tx_count,
+			int ac_index,
+			u8 coex_bt_on);
+int sprdwl_intf_fill_msdu_dscr(struct sprdwl_vif *vif,
+			       struct sk_buff *skb,
+				   u8 type,
+			       u8 offset);
+int sprdwl_tx_free_pcie_data(struct sprdwl_intf *dev, unsigned char *data,
+			     unsigned short len);
+void *sprdwl_get_rx_data(struct sprdwl_intf *intf, void *pos, void **data,
+			 void **tran_data, int *len, int offset);
+void sprdwl_free_rx_data(struct sprdwl_intf *intf,
+			 int chn, void *head, void *tail, int num);
+
+#if defined FPGA_LOOPBACK_TEST
+int sprdwl_intf_tx_data_fpga_test(struct sprdwl_intf *intf,
+				  unsigned char *data, int len);
+int sprdwl_intf_fill_msdu_dscr_test(struct sprdwl_priv *priv,
+				    struct sk_buff *skb,
+				    u8 type,
+				    u8 offset);
+#endif /* FPGA_LOOPBACK_TEST */
+
+void sprdwl_hex_dump(unsigned char *name,
+		     unsigned char *data, unsigned short len);
+struct sprdwl_peer_entry
+*sprdwl_find_peer_entry_using_lut_index(struct sprdwl_intf *intf,
+					unsigned char sta_lut_index);
+void sprdwl_event_sta_lut(struct sprdwl_vif *vif, u8 *data, u16 len);
+struct sprdwl_peer_entry
+*sprdwl_find_peer_entry_using_addr(struct sprdwl_vif *vif, u8 *addr);
+void sprdwl_tx_addba(struct sprdwl_intf *intf,
+		     struct sprdwl_peer_entry *peer_entry, unsigned char tid);
+void sprdwl_tx_delba(struct sprdwl_intf *intf,
+		     struct sprdwl_peer_entry *peer_entry, unsigned int ac_index);
+void sprdwl_tx_send_addba(struct sprdwl_vif *vif, void *data, int len);
+void sprdwl_tx_send_delba(struct sprdwl_vif *vif, void *data, int len);
+unsigned char sprdwl_find_lut_index(struct sprdwl_intf *intf,
+				    struct sprdwl_vif *vif);
+int sprdwl_dis_flush_txlist(struct sprdwl_intf *intf, u8 lut_index);
+void sprdwl_handle_pop_list(void *data);
+int sprdwl_add_topop_list(int chn, struct mbuf_t *head,
+				struct mbuf_t *tail, int num);
+enum sprdwl_hw_type get_hwintf_type(void);
+void set_coex_bt_on_off(u8 action);
+int sprdwl_notifier_boost(struct notifier_block *nb, unsigned long event, void *data);
+void sprdwl_boost(void);
+void sprdwl_unboost(void);
+void adjust_txnum_level(char *buf, unsigned char offset);
+void adjust_rxnum_level(char *buf, unsigned char offset);
+#endif /* __SPRDWL_INTF_SDIO_SC2355_H__ */
diff --git a/drivers/net/wireless/uwe5622/unisocwifi/work.c b/drivers/net/wireless/uwe5622/unisocwifi/work.c
new file mode 100644
index 000000000000..ee984e31711b
--- /dev/null
+++ b/drivers/net/wireless/uwe5622/unisocwifi/work.c
@@ -0,0 +1,215 @@
+/*
+ * Copyright (C) 2015 Spreadtrum Communications Inc.
+ *
+ * Authors	:
+ * Dong Xiang <dong.xiang@spreadtrum.com>
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include "sprdwl.h"
+#include "work.h"
+#include "rx_msg.h"
+#include "tx_msg.h"
+#include "wl_intf.h"
+#ifdef DFS_MASTER
+#include "11h.h"
+#endif
+
+struct sprdwl_work *sprdwl_alloc_work(int len)
+{
+	struct sprdwl_work *sprdwl_work;
+	int size = sizeof(*sprdwl_work) + len;
+
+	sprdwl_work = kzalloc(size, GFP_ATOMIC);
+	if (sprdwl_work) {
+		INIT_LIST_HEAD(&sprdwl_work->list);
+		sprdwl_work->len = len;
+	}
+
+	return sprdwl_work;
+}
+
+static struct sprdwl_work *sprdwl_get_work(struct sprdwl_priv *priv)
+{
+	struct sprdwl_work *sprdwl_work = NULL;
+
+	spin_lock_bh(&priv->work_lock);
+	if (!list_empty(&priv->work_list)) {
+		sprdwl_work = list_first_entry(&priv->work_list,
+					       struct sprdwl_work, list);
+		list_del(&sprdwl_work->list);
+	}
+	spin_unlock_bh(&priv->work_lock);
+
+	return sprdwl_work;
+}
+
+static void sprdwl_do_work(struct work_struct *work)
+{
+	struct sprdwl_work *sprdwl_work;
+	struct sprdwl_reg_mgmt *reg_mgmt;
+	struct sprdwl_tdls_work *tdls;
+	struct sprdwl_assert_info *assert_info;
+	struct sprdwl_vif *vif;
+	struct sprdwl_priv *priv = container_of(work, struct sprdwl_priv, work);
+
+	while (1) {
+		sprdwl_work = sprdwl_get_work(priv);
+		if (!sprdwl_work)
+			return;
+
+		vif = sprdwl_work->vif;
+		wl_ndev_log(L_DBG, vif->ndev, "process delayed work: %d\n",
+			   sprdwl_work->id);
+
+		switch (sprdwl_work->id) {
+		case SPRDWL_WORK_REG_MGMT:
+			reg_mgmt = (struct sprdwl_reg_mgmt *)sprdwl_work->data;
+			sprdwl_register_frame(priv, vif->ctx_id,
+					      reg_mgmt->type,
+					      reg_mgmt->reg ? 1 : 0);
+			break;
+		case SPRDWL_WORK_DEAUTH:
+		case SPRDWL_WORK_DISASSOC:
+			cfg80211_rx_unprot_mlme_mgmt(vif->ndev,
+						     sprdwl_work->data,
+						     sprdwl_work->len);
+			break;
+		case SPRDWL_WORK_MC_FILTER:
+			if (vif->mc_filter->mc_change)
+				sprdwl_set_mc_filter(priv, vif->ctx_id,
+						     vif->mc_filter->subtype,
+						     vif->mc_filter->mac_num,
+						     vif->mc_filter->mac_addr);
+			break;
+		case SPRDWL_WORK_NOTIFY_IP:
+			sprdwl_notify_ip(priv, vif->ctx_id, SPRDWL_IPV6,
+					 sprdwl_work->data);
+			break;
+		case SPRDWL_WORK_BA_MGMT:
+			sprdwl_send_ba_mgmt(priv, vif->ctx_id,
+					    sprdwl_work->data,
+					    sprdwl_work->len);
+			break;
+		case SPRDWL_WORK_ADDBA:
+			sprdwl_tx_send_addba(vif, sprdwl_work->data,
+				sprdwl_work->len);
+			break;
+		case SPRDWL_WORK_DELBA:
+			sprdwl_tx_send_delba(vif, sprdwl_work->data,
+				sprdwl_work->len);
+			break;
+		case SPRDWL_ASSERT:
+			assert_info = (struct sprdwl_assert_info *)(sprdwl_work->data);
+			wlan_set_assert(vif->priv, vif->ctx_id, assert_info->cmd_id, assert_info->reason);
+			break;
+		case SPRDWL_HANG_RECEIVED:
+			sprdwl_send_hang_received_cmd(vif->priv, vif->ctx_id);
+			break;
+		case SPRDWL_POP_MBUF:
+			sprdwl_handle_pop_list(sprdwl_work->data);
+			break;
+		case SPRDWL_TDLS_CMD:
+			tdls = (struct sprdwl_tdls_work *)sprdwl_work->data;
+			sprdwl_tdls_oper(vif->priv, tdls->vif_ctx_id,
+					 tdls->peer, tdls->oper);
+			break;
+		case SPRDWL_SEND_CLOSE:
+			sprdwl_close_fw(vif->priv, vif->ctx_id, *(sprdwl_work->data));
+			break;
+#ifdef DFS_MASTER
+		case SPRDWL_WORK_DFS:
+			sprdwl_send_dfs_cmd(vif, sprdwl_work->data,
+							sprdwl_work->len);
+			break;
+#endif
+		case SPRDWL_CMD_TX_DATA:
+			sprdwl_send_data2cmd(vif->priv, vif->ctx_id,
+					sprdwl_work->data, sprdwl_work->len);
+			break;
+		case SPRDWL_WORK_FW_PWR_DOWN:
+			sprdwl_fw_power_down_ack(vif->priv, vif->ctx_id);
+			break;
+		case SPRDWL_WORK_HOST_WAKEUP_FW:
+			sprdwl_cmd_host_wakeup_fw(vif->priv, vif->ctx_id);
+			break;
+		case SPRDWL_WORK_VOWIFI_DATA_PROTECTION:
+			sprdwl_send_vowifi_data_prot(vif->priv, vif->ctx_id,
+						     sprdwl_work->data,
+						     sprdwl_work->len);
+			break;
+		default:
+			wl_ndev_log(L_DBG, vif->ndev, "Unknown delayed work: %d\n",
+				   sprdwl_work->id);
+			break;
+		}
+
+		kfree(sprdwl_work);
+	}
+}
+
+void sprdwl_queue_work(struct sprdwl_priv *priv,
+		       struct sprdwl_work *sprdwl_work)
+{
+	spin_lock_bh(&priv->work_lock);
+	list_add_tail(&sprdwl_work->list, &priv->work_list);
+	spin_unlock_bh(&priv->work_lock);
+
+	if (!work_pending(&priv->work))
+		queue_work(priv->common_workq, &priv->work);
+}
+
+void sprdwl_cancle_work(struct sprdwl_priv *priv, struct sprdwl_vif *vif)
+{
+	struct sprdwl_work *sprdwl_work, *pos;
+
+	spin_lock_bh(&priv->work_lock);
+	list_for_each_entry_safe(sprdwl_work, pos, &priv->work_list, list) {
+		if (vif == sprdwl_work->vif) {
+			list_del(&sprdwl_work->list);
+			kfree(sprdwl_work);
+		}
+	}
+	spin_unlock_bh(&priv->work_lock);
+
+	flush_work(&priv->work);
+}
+
+int sprdwl_init_work(struct sprdwl_priv *priv)
+{
+	spin_lock_init(&priv->work_lock);
+	INIT_LIST_HEAD(&priv->work_list);
+	INIT_WORK(&priv->work, sprdwl_do_work);
+
+	priv->common_workq = alloc_ordered_workqueue("sprdwl_work",
+				WQ_HIGHPRI | WQ_CPU_INTENSIVE |
+				WQ_MEM_RECLAIM);
+	if (!priv->common_workq) {
+		wl_err("%s sprdwl_work create failed\n", __func__);
+		return -ENOMEM;
+	}
+	return 0;
+}
+
+void sprdwl_deinit_work(struct sprdwl_priv *priv)
+{
+	struct sprdwl_work *sprdwl_work, *pos;
+
+	cancel_work_sync(&priv->work);
+
+	list_for_each_entry_safe(sprdwl_work, pos, &priv->work_list, list) {
+		list_del(&sprdwl_work->list);
+		kfree(sprdwl_work);
+	}
+
+	flush_workqueue(priv->common_workq);
+	destroy_workqueue(priv->common_workq);
+}
diff --git a/drivers/net/wireless/uwe5622/unisocwifi/work.h b/drivers/net/wireless/uwe5622/unisocwifi/work.h
new file mode 100644
index 000000000000..4e745903eedc
--- /dev/null
+++ b/drivers/net/wireless/uwe5622/unisocwifi/work.h
@@ -0,0 +1,84 @@
+/*
+ * Copyright (C) 2015 Spreadtrum Communications Inc.
+ *
+ * Authors	:
+ * Dong Xiang <dong.xiang@spreadtrum.com>
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#ifndef __SPRDWL_WORK_H__
+#define __SPRDWL_WORK_H__
+
+#include <linux/types.h>
+#include <linux/list.h>
+#include <linux/spinlock.h>
+#ifdef DFS_MASTER
+#include "11h.h"
+#endif
+
+struct sprdwl_work {
+	struct list_head list;
+	struct sprdwl_vif *vif;
+#define SPRDWL_WORK_NONE	0
+#define SPRDWL_WORK_REG_MGMT	1
+#define SPRDWL_WORK_DEAUTH	2
+#define SPRDWL_WORK_DISASSOC	3
+#define SPRDWL_WORK_MC_FILTER	4
+#define SPRDWL_WORK_NOTIFY_IP	5
+#define SPRDWL_WORK_BA_MGMT	6
+#define SPRDWL_WORK_ADDBA 7
+#define SPRDWL_WORK_DELBA 8
+#ifdef DFS_MASTER
+#define    SPRDWL_WORK_DFS   9
+#endif
+#define SPRDWL_ASSERT 10
+#define SPRDWL_HANG_RECEIVED 11
+#define SPRDWL_POP_MBUF 12
+#define SPRDWL_TDLS_CMD 13
+#define SPRDWL_SEND_CLOSE 14
+#define SPRDWL_CMD_TX_DATA 15
+#define SPRDWL_WORK_FW_PWR_DOWN 16
+#define SPRDWL_WORK_HOST_WAKEUP_FW 17
+#define SPRDWL_WORK_VOWIFI_DATA_PROTECTION 18
+	u8 id;
+	u32 len;
+	u8 data[0];
+};
+
+struct sprdwl_reg_mgmt {
+	u16 type;
+	bool reg;
+};
+
+struct sprdwl_data2mgmt {
+	struct sk_buff *skb;
+	struct net_device *ndev;
+};
+
+struct sprdwl_tdls_work {
+	u8 vif_ctx_id;
+	u8 peer[ETH_ALEN];
+	int oper;
+};
+
+struct sprdwl_assert_info {
+	u8 cmd_id;
+	u8 reason;
+};
+
+struct sprdwl_work *sprdwl_alloc_work(int len);
+void sprdwl_queue_work(struct sprdwl_priv *priv,
+		       struct sprdwl_work *sprdwl_work);
+void sprdwl_cancle_work(struct sprdwl_priv *priv, struct sprdwl_vif *vif);
+int sprdwl_init_work(struct sprdwl_priv *priv);
+void sprdwl_deinit_work(struct sprdwl_priv *priv);
+
+#endif
-- 
2.37.1

