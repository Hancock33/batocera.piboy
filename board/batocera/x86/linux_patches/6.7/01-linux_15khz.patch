diff --git a/drivers/gpu/drm/Makefile b/drivers/gpu/drm/Makefile
index 8e1bde059170..2ddf8b518923 100644
--- a/drivers/gpu/drm/Makefile
+++ b/drivers/gpu/drm/Makefile
@@ -30,6 +30,7 @@ drm-y := \
 	drm_ioctl.o \
 	drm_lease.o \
 	drm_managed.o \
+	drm_modes_low_dotclock.o \
 	drm_mm.o \
 	drm_mode_config.o \
 	drm_mode_object.o \
diff --git a/drivers/gpu/drm/drm_modes.c b/drivers/gpu/drm/drm_modes.c
index ac9a406250c5..da822ff1dd6d 100644
--- a/drivers/gpu/drm/drm_modes.c
+++ b/drivers/gpu/drm/drm_modes.c
@@ -48,6 +48,7 @@
 #include <drm/drm_print.h>
 
 #include "drm_crtc_internal.h"
+#include "drm_modes_low_dotclock.h"
 
 /**
  * drm_mode_debug_printmodeline - print a mode to dmesg
@@ -2028,7 +2029,7 @@ static int drm_mode_parse_cmdline_res_mode(const char *str, unsigned int length,
 					   struct drm_cmdline_mode *mode)
 {
 	const char *str_start = str;
-	bool rb = false, cvt = false;
+	bool rb = false, cvt = false, low_dotclock = false;
 	int xres = 0, yres = 0;
 	int remaining, i;
 	char *end_ptr;
@@ -2058,6 +2059,12 @@ static int drm_mode_parse_cmdline_res_mode(const char *str, unsigned int length,
 		case 'R':
 			rb = true;
 			break;
+		case 'S':
+		case 'c':
+		case 'z':
+			low_dotclock = true;
+			DRM_DEBUG_KMS("Found one of the S/c/z low dotclock mode flag");
+			break;
 		default:
 			/*
 			 * Try to pass that to our extras parsing
@@ -2082,6 +2089,7 @@ static int drm_mode_parse_cmdline_res_mode(const char *str, unsigned int length,
 	mode->yres = yres;
 	mode->cvt = cvt;
 	mode->rb = rb;
+	mode->low_dotclock = low_dotclock;
 
 	return 0;
 }
@@ -2545,7 +2553,11 @@ drm_mode_create_from_cmdline_mode(struct drm_device *dev,
 
 	if (strlen(cmd->name))
 		mode = drm_named_mode(dev, cmd);
-	else if (cmd->cvt)
+	else if (cmd->low_dotclock)
+        mode = drm_mode_low_dotclock_res(dev,
+                                    cmd->xres, cmd->yres,
+                                    cmd->interlace);
+        else if (cmd->cvt)
 		mode = drm_cvt_mode(dev,
 				    cmd->xres, cmd->yres,
 				    cmd->refresh_specified ? cmd->refresh : 60,
diff --git a/drivers/gpu/drm/drm_probe_helper.c b/drivers/gpu/drm/drm_probe_helper.c
index 3f479483d7d8..969313f8c5fc 100644
--- a/drivers/gpu/drm/drm_probe_helper.c
+++ b/drivers/gpu/drm/drm_probe_helper.c
@@ -448,21 +448,26 @@ static int __drm_helper_update_and_validate(struct drm_connector *connector,
 		mode_flags |= DRM_MODE_FLAG_3D_MASK;
 
 	list_for_each_entry(mode, &connector->modes, head) {
+		DRM_DEBUG_KMS("[CONNECTOR:%d:%s] starting with mode state : %d\n", connector->base.id, connector->name, mode->status);
 		if (mode->status != MODE_OK)
 			continue;
 
+		DRM_DEBUG_KMS("[CONNECTOR:%d:%s] before drm_mode_validate_driver mode is : %d\n", connector->base.id, connector->name, mode->status);
 		mode->status = drm_mode_validate_driver(dev, mode);
 		if (mode->status != MODE_OK)
 			continue;
 
+		DRM_DEBUG_KMS("[CONNECTOR:%d:%s] before drm_mode_validate_size mode is : %d\n", connector->base.id, connector->name, mode->status);
 		mode->status = drm_mode_validate_size(mode, maxX, maxY);
 		if (mode->status != MODE_OK)
 			continue;
 
+		DRM_DEBUG_KMS("[CONNECTOR:%d:%s] before drm_mode_validate_flag mode is : %d\n", connector->base.id, connector->name, mode->status);
 		mode->status = drm_mode_validate_flag(mode, mode_flags);
 		if (mode->status != MODE_OK)
 			continue;
 
+		DRM_DEBUG_KMS("[CONNECTOR:%d:%s] before drm_mode_validate_pipeline mode is : %d\n", connector->base.id, connector->name, mode->status);
 		ret = drm_mode_validate_pipeline(mode, connector, ctx,
 						 &mode->status);
 		if (ret) {
@@ -476,9 +481,11 @@ static int __drm_helper_update_and_validate(struct drm_connector *connector,
 				return -EDEADLK;
 		}
 
+		DRM_DEBUG_KMS("[CONNECTOR:%d:%s] before drm_mode_validate_ycbcr420 mode is : %d\n", connector->base.id, connector->name, mode->status);
 		if (mode->status != MODE_OK)
 			continue;
 		mode->status = drm_mode_validate_ycbcr420(mode, connector);
+		DRM_DEBUG_KMS("[CONNECTOR:%d:%s] in the end mode is : %d\n", connector->base.id, connector->name, mode->status);
 	}
 
 	return 0;
@@ -548,6 +555,7 @@ int drm_helper_probe_single_connector_modes(struct drm_connector *connector,
 {
 	struct drm_device *dev = connector->dev;
 	struct drm_display_mode *mode;
+	struct drm_cmdline_mode *cmdline_mode;
 	int count = 0, ret;
 	enum drm_connector_status old_status;
 	struct drm_modeset_acquire_ctx ctx;
@@ -630,10 +638,13 @@ int drm_helper_probe_single_connector_modes(struct drm_connector *connector,
 		goto exit;
 	}
 
+	cmdline_mode = &connector->cmdline_mode;
+
 	count = drm_helper_probe_get_modes(connector);
 
 	if (count == 0 && (connector->status == connector_status_connected ||
-			   connector->status == connector_status_unknown)) {
+			   connector->status == connector_status_unknown) &&
+			   ! cmdline_mode->low_dotclock) {
 		count = drm_add_modes_noedid(connector, 1024, 768);
 
 		/*
diff --git a/include/drm/drm_connector.h b/include/drm/drm_connector.h
index fe88d7fc6b8f..ce1d94bf0f7c 100644
--- a/include/drm/drm_connector.h
+++ b/include/drm/drm_connector.h
@@ -1433,6 +1433,13 @@ struct drm_cmdline_mode {
 	 */
 	bool interlace;
 
+	/**
+	 * @low_dotclock:
+	 *
+	 * Flag is enabled if a valid low dotclock resolution is defined.
+	 */
+	bool low_dotclock;
+
 	/**
 	 * @cvt:
 	 *
