diff --git a/include/linux/sched.h b/include/linux/sched.h
index 61591ac6eab6..84edc904d3bf 100644
--- a/include/linux/sched.h
+++ b/include/linux/sched.h
@@ -533,6 +533,19 @@ struct sched_statistics {
 #endif /* CONFIG_SCHEDSTATS */
 } ____cacheline_aligned;
 
+#ifdef CONFIG_ECHO_SCHED
+struct bs_node {
+	struct bs_node*                 next;
+	u64				c_vrt_start;
+	u64				r_vrt_start;
+	u64				vburst;
+#ifdef CONFIG_SCHED_DEBUG
+	u64				prev_vburst;
+#endif
+	u64				est;
+};
+#endif
+
 struct sched_entity {
 	/* For load-balancing: */
 	struct load_weight		load;
@@ -542,14 +555,18 @@ struct sched_entity {
 
 	struct list_head		group_node;
 	unsigned int			on_rq;
-
+#ifdef CONFIG_ECHO_SCHED
+	struct bs_node                  bs_node;
+#endif
 	u64				exec_start;
 	u64				sum_exec_runtime;
 	u64				prev_sum_exec_runtime;
 	u64				vruntime;
 	s64				vlag;
 	u64				slice;
-
+#ifdef CONFIG_ECHO_SCHED
+	bool				yielded;
+#endif
 	u64				nr_migrations;
 
 #ifdef CONFIG_FAIR_GROUP_SCHED
diff --git a/init/Kconfig b/init/Kconfig
index 44616ffe0af5..4d075b15976e 100644
--- a/init/Kconfig
+++ b/init/Kconfig
@@ -130,6 +130,12 @@ config THREAD_INFO_IN_TASK
 	  One subtle change that will be needed is to use try_get_task_stack()
 	  and put_task_stack() in save_thread_stack_tsk() and get_wchan().
 
+config ECHO_SCHED
+	bool "ECHO CPU Scheduler"
+	default y
+	help
+	  https://github.com/hamadmarri/ECHO-CPU-Scheduler
+
 menu "General setup"
 
 config CACHY
@@ -1016,11 +1022,12 @@ menuconfig CGROUP_SCHED
 if CGROUP_SCHED
 config FAIR_GROUP_SCHED
 	bool "Group scheduling for SCHED_OTHER"
-	depends on CGROUP_SCHED
-	default CGROUP_SCHED
+	depends on CGROUP_SCHED && !ECHO_SCHED
+	default n
 
 config CFS_BANDWIDTH
 	bool "CPU bandwidth provisioning for FAIR_GROUP_SCHED"
+	depends on !ECHO_SCHED
 	depends on FAIR_GROUP_SCHED
 	default n
 	help
@@ -1305,9 +1312,11 @@ config CHECKPOINT_RESTORE
 
 config SCHED_AUTOGROUP
 	bool "Automatic process group scheduling"
+	depends on !ECHO_SCHED
 	select CGROUPS
 	select CGROUP_SCHED
 	select FAIR_GROUP_SCHED
+	default n
 	help
 	  This option optimizes the scheduler for common desktop workloads by
 	  automatically creating and populating task groups.  This separation
diff --git a/kernel/Kconfig.hz b/kernel/Kconfig.hz
index 0f78364efd4f..75ba65935b26 100644
--- a/kernel/Kconfig.hz
+++ b/kernel/Kconfig.hz
@@ -5,7 +5,7 @@
 
 choice
 	prompt "Timer frequency"
-	default HZ_250
+	default HZ_625
 	help
 	 Allows the configuration of the timer frequency. It is customary
 	 to have the timer interrupt run at 1000 Hz but 100 Hz may be more
@@ -54,6 +54,13 @@ choice
 	 on desktops with good smoothness without increasing CPU power
 	 consumption and sacrificing the battery life on laptops.
 
+	config HZ_625
+		bool "625 HZ"
+	help
+	 The default HZ for ECHO is 625HZ - ticks every 1.6ms.
+	 No need to increase it since the HighRes clock handles
+	 the task preemption in 105us max.
+
 	config HZ_750
 		bool "750 HZ"
 	help
@@ -76,6 +83,7 @@ config HZ
 	default 300 if HZ_300
 	default 500 if HZ_500
 	default 600 if HZ_600
+	default 625 if HZ_625
 	default 750 if HZ_750
 	default 1000 if HZ_1000
 
diff --git a/kernel/Kconfig.preempt b/kernel/Kconfig.preempt
index c2f1fd95a821..d54bb52ccccc 100644
--- a/kernel/Kconfig.preempt
+++ b/kernel/Kconfig.preempt
@@ -117,7 +117,8 @@ config PREEMPT_DYNAMIC
 
 config SCHED_CORE
 	bool "Core Scheduling for SMT"
-	depends on SCHED_SMT
+	depends on SCHED_SMT && !ECHO_SCHED
+	default n
 	help
 	  This option permits Core Scheduling, a means of coordinated task
 	  selection across SMT siblings. When enabled -- see
diff --git a/kernel/sched/Makefile b/kernel/sched/Makefile
index 976092b7bd45..f78ee1bffe16 100644
--- a/kernel/sched/Makefile
+++ b/kernel/sched/Makefile
@@ -29,6 +29,10 @@ endif
 # build parallelizes well and finishes roughly at once:
 #
 obj-y += core.o
+ifeq ($(CONFIG_ECHO_SCHED),y)
+obj-y += bs.o
+else
 obj-y += fair.o
+endif
 obj-y += build_policy.o
 obj-y += build_utility.o
diff --git a/kernel/sched/core.c b/kernel/sched/core.c
index bcf2c4cc0522..6c5ee3054fe7 100644
--- a/kernel/sched/core.c
+++ b/kernel/sched/core.c
@@ -4534,6 +4534,12 @@ static void __sched_fork(unsigned long clone_flags, struct task_struct *p)
 	p->se.vruntime			= 0;
 	p->se.vlag			= 0;
 	p->se.slice			= sysctl_sched_base_slice;
+
+#ifdef CONFIG_ECHO_SCHED
+	p->se.bs_node.vburst		= 0;
+	p->se.bs_node.est		= 0;
+#endif
+
 	INIT_LIST_HEAD(&p->se.group_node);
 
 #ifdef CONFIG_FAIR_GROUP_SCHED
@@ -4696,6 +4702,15 @@ static int sysctl_schedstats(struct ctl_table *table, int write, void *buffer,
 
 #ifdef CONFIG_SYSCTL
 static struct ctl_table sched_core_sysctls[] = {
+#ifdef CONFIG_ECHO_SCHED
+	{
+		.procname	= "sched_bs_shared_quota",
+		.data		= &bs_shared_quota,
+		.maxlen		= sizeof(unsigned int),
+		.mode		= 0644,
+		.proc_handler	= proc_dointvec,
+	},
+#endif
 #ifdef CONFIG_SCHEDSTATS
 	{
 		.procname       = "sched_schedstats",
@@ -9932,6 +9947,10 @@ void __init sched_init(void)
 
 	wait_bit_init();
 
+#ifdef CONFIG_ECHO_SCHED
+	printk(KERN_INFO "ECHO CPU scheduler v6.8 by Hamad Al Marri.");
+#endif
+
 #ifdef CONFIG_FAIR_GROUP_SCHED
 	ptr += 2 * nr_cpu_ids * sizeof(void **);
 #endif
diff --git a/kernel/sched/debug.c b/kernel/sched/debug.c
index c1eb9a1afd13..44a84c4b8be5 100644
--- a/kernel/sched/debug.c
+++ b/kernel/sched/debug.c
@@ -1004,6 +1004,11 @@ void proc_sched_show_task(struct task_struct *p, struct pid_namespace *ns,
 	PN(se.exec_start);
 	PN(se.vruntime);
 	PN(se.sum_exec_runtime);
+#ifdef CONFIG_ECHO_SCHED
+	PN(se.bs_node.vburst);
+	PN(se.bs_node.prev_vburst);
+	PN(se.bs_node.est);
+#endif
 
 	nr_switches = p->nvcsw + p->nivcsw;
 
diff --git a/kernel/sched/idle.c b/kernel/sched/idle.c
index 6135fbe83d68..33bad71a5556 100644
--- a/kernel/sched/idle.c
+++ b/kernel/sched/idle.c
@@ -331,6 +331,7 @@ static void do_idle(void)
 		} else {
 			cpuidle_idle_call();
 		}
+
 		arch_cpu_idle_exit();
 	}
 
diff --git a/kernel/sched/sched.h b/kernel/sched/sched.h
index 6e6a45087015..1e7987257db9 100644
--- a/kernel/sched/sched.h
+++ b/kernel/sched/sched.h
@@ -111,6 +111,10 @@ extern int sysctl_sched_rt_period;
 extern int sysctl_sched_rt_runtime;
 extern int sched_rr_timeslice;
 
+#ifdef CONFIG_ECHO_SCHED
+extern unsigned int bs_shared_quota;
+#endif
+
 /*
  * Asymmetric CPU capacity bits
  */
@@ -590,7 +594,9 @@ struct cfs_rq {
 	unsigned int		h_nr_running;      /* SCHED_{NORMAL,BATCH,IDLE} */
 	unsigned int		idle_nr_running;   /* SCHED_IDLE */
 	unsigned int		idle_h_nr_running; /* SCHED_IDLE */
-
+#ifdef CONFIG_ECHO_SCHED
+	u64			local_cand_est;
+#endif
 	s64			avg_vruntime;
 	u64			avg_load;
 
@@ -612,6 +618,10 @@ struct cfs_rq {
 	 * It is set to NULL otherwise (i.e when none are currently running).
 	 */
 	struct sched_entity	*curr;
+#ifdef CONFIG_ECHO_SCHED
+	struct bs_node		*head;
+	struct bs_node		*q2_head;
+#endif
 	struct sched_entity	*next;
 
 #ifdef	CONFIG_SCHED_DEBUG
@@ -1894,6 +1904,7 @@ DECLARE_PER_CPU(struct sched_domain_shared __rcu *, sd_llc_shared);
 DECLARE_PER_CPU(struct sched_domain __rcu *, sd_numa);
 DECLARE_PER_CPU(struct sched_domain __rcu *, sd_asym_packing);
 DECLARE_PER_CPU(struct sched_domain __rcu *, sd_asym_cpucapacity);
+
 extern struct static_key_false sched_asym_cpucapacity;
 extern struct static_key_false sched_cluster_active;
 
diff --git a/kernel/time/Kconfig b/kernel/time/Kconfig
index 8ebb6d5a106b..6fe7a39b4756 100644
--- a/kernel/time/Kconfig
+++ b/kernel/time/Kconfig
@@ -124,7 +124,7 @@ config NO_HZ_FULL
 	bool "Full dynticks system (tickless)"
 	# NO_HZ_COMMON dependency
 	# We need at least one periodic CPU for timekeeping
-	depends on SMP
+	depends on SMP && !ECHO_SCHED
 	depends on HAVE_CONTEXT_TRACKING_USER
 	# VIRT_CPU_ACCOUNTING_GEN dependency
 	depends on HAVE_VIRT_CPU_ACCOUNTING_GEN
