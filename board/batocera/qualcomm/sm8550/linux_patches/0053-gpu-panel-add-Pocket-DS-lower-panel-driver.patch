diff -rupbN linux.orig/drivers/gpu/drm/panel/Kconfig linux/drivers/gpu/drm/panel/Kconfig
--- linux.orig/drivers/gpu/drm/panel/Kconfig	2025-08-29 00:02:39.288684887 +0000
+++ linux/drivers/gpu/drm/panel/Kconfig	2025-08-29 19:45:04.120111724 +0000
@@ -37,6 +37,16 @@ config DRM_PANEL_AR02_3INCH
 	  Say Y here if you want to enable support for Ayaneo Pocket DMG
 	  1080x1240 60hz Panel.
 
+config DRM_PANEL_AR11_5INCH
+       tristate "Ayaneo Pocket DS lower panel driver"
+       depends on OF
+       depends on DRM_MIPI_DSI
+       depends on BACKLIGHT_CLASS_DEVICE
+       select DRM_DISPLAY_HELPER
+       help
+         Say Y here if you want to enable support for Ayaneo Pocket DS
+         1024x768Panel.
+
 config DRM_PANEL_ARM_VERSATILE
 	tristate "ARM Versatile panel driver"
 	depends on OF
diff -rupbN linux.orig/drivers/gpu/drm/panel/Makefile linux/drivers/gpu/drm/panel/Makefile
--- linux.orig/drivers/gpu/drm/panel/Makefile	2025-08-29 00:02:39.288684887 +0000
+++ linux/drivers/gpu/drm/panel/Makefile	2025-08-29 19:45:39.516633171 +0000
@@ -2,6 +2,7 @@
 obj-$(CONFIG_DRM_PANEL_ABT_Y030XX067A) += panel-abt-y030xx067a.o
 obj-$(CONFIG_DRM_PANEL_AR06_4INCH) += panel-ar06-4inch.o
 obj-$(CONFIG_DRM_PANEL_AR02_3INCH) += panel-ar02-3inch.o
+obj-$(CONFIG_DRM_PANEL_AR11_5INCH) += panel-ar11-5inch.o
 obj-$(CONFIG_DRM_PANEL_ARM_VERSATILE) += panel-arm-versatile.o
 obj-$(CONFIG_DRM_PANEL_ASUS_Z00T_TM5P5_NT35596) += panel-asus-z00t-tm5p5-n35596.o
 obj-$(CONFIG_DRM_PANEL_AUO_A030JTN01) += panel-auo-a030jtn01.o
diff -rupbN linux.orig/drivers/gpu/drm/panel/panel-ar11-5inch.c linux/drivers/gpu/drm/panel/panel-ar11-5inch.c
--- linux.orig/drivers/gpu/drm/panel/panel-ar11-5inch.c	1970-01-01 00:00:00.000000000 +0000
+++ linux/drivers/gpu/drm/panel/panel-ar11-5inch.c	2025-08-29 21:48:05.618147842 +0000
@@ -0,0 +1,306 @@
+// SPDX-License-Identifier: GPL-2.0-only
+// Copyright (c) 2025 FIXME
+// Generated with linux-mdss-dsi-panel-driver-generator from vendor device tree:
+//   Copyright (c) 2013, The Linux Foundation. All rights reserved. (FIXME)
+
+#include <linux/delay.h>
+#include <linux/gpio/consumer.h>
+#include <linux/mod_devicetable.h>
+#include <linux/module.h>
+#include <linux/regulator/consumer.h>
+
+#include <drm/drm_mipi_dsi.h>
+#include <drm/drm_modes.h>
+#include <drm/drm_panel.h>
+#include <drm/drm_probe_helper.h>
+
+struct ar11_5inch {
+	struct drm_panel panel;
+	struct mipi_dsi_device *dsi;
+	struct gpio_desc *reset_gpio;
+	struct gpio_desc *enable_gpio;
+	struct regulator_bulk_data *supplies;
+	enum drm_panel_orientation orientation;
+};
+
+static const struct regulator_bulk_data panel_supplies[] = {
+	{ .supply = "avdd" },
+	{ .supply = "vci" },
+	{ .supply = "vddio" },
+};
+
+static inline struct ar11_5inch *to_ar11_5inch(struct drm_panel *panel)
+{
+	return container_of(panel, struct ar11_5inch, panel);
+}
+
+static void ar11_5inch_reset(struct ar11_5inch *ctx)
+{
+	gpiod_set_value_cansleep(ctx->reset_gpio, 0);
+	usleep_range(10000, 11000);
+	gpiod_set_value_cansleep(ctx->reset_gpio, 1);
+	usleep_range(10000, 11000);
+	gpiod_set_value_cansleep(ctx->reset_gpio, 0);
+	msleep(55);
+}
+
+static int ar11_5inch_on(struct ar11_5inch *ctx)
+{
+	struct mipi_dsi_multi_context dsi_ctx = { .dsi = ctx->dsi };
+
+	ctx->dsi->mode_flags |= MIPI_DSI_MODE_LPM;
+
+	mipi_dsi_dcs_write_seq_multi(&dsi_ctx, 0xb9, 0xf1, 0x12, 0x87);
+	mipi_dsi_dcs_write_seq_multi(&dsi_ctx, 0xb2, 0x00, 0x01, 0x78);
+	mipi_dsi_dcs_write_seq_multi(&dsi_ctx, 0xb3,
+				     0x10, 0x10, 0x28, 0x28, 0x03, 0xff, 0x00,
+				     0x00, 0x00, 0x00);
+	mipi_dsi_dcs_write_seq_multi(&dsi_ctx, 0xb4, 0x80);
+	mipi_dsi_dcs_write_seq_multi(&dsi_ctx, 0xb5, 0x0a, 0x0a);
+	mipi_dsi_dcs_write_seq_multi(&dsi_ctx, 0xb6, 0x90, 0x90);
+	mipi_dsi_dcs_write_seq_multi(&dsi_ctx, 0xb8, 0x76, 0x22, 0xf0, 0x13);
+	mipi_dsi_dcs_write_seq_multi(&dsi_ctx, 0xba,
+				     0x33, 0x81, 0x05, 0xf9, 0x0e, 0x0e, 0x20,
+				     0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+				     0x44, 0x25, 0x00, 0x91, 0x0a, 0x00, 0x00,
+				     0x01, 0x4f, 0x01, 0x00, 0x00, 0x37);
+	mipi_dsi_dcs_write_seq_multi(&dsi_ctx, 0xbc, 0x47);
+	mipi_dsi_dcs_write_seq_multi(&dsi_ctx, 0xbf,
+				     0x02, 0x10, 0x00, 0x80, 0x04);
+	mipi_dsi_dcs_write_seq_multi(&dsi_ctx, 0xc0,
+				     0x73, 0x73, 0x50, 0x50, 0x00, 0x00, 0x12,
+				     0x73, 0x00);
+	mipi_dsi_dcs_write_seq_multi(&dsi_ctx, 0xc1,
+				     0x55, 0x00, 0x32, 0x32, 0x77, 0xf1, 0xf7,
+				     0xf7, 0xcc, 0xcc, 0x7f, 0x7f, 0x11, 0x11,
+				     0x00, 0x00, 0x32);
+	mipi_dsi_dcs_write_seq_multi(&dsi_ctx, 0xc7,
+				     0xb8, 0x00, 0x0a, 0x10, 0x01, 0x09, 0x00,
+				     0x00, 0xed, 0xc5, 0x00, 0xa5);
+	mipi_dsi_dcs_write_seq_multi(&dsi_ctx, 0xc8, 0x10, 0x40, 0x1e, 0x03);
+	mipi_dsi_dcs_write_seq_multi(&dsi_ctx, 0xcc, 0x0b);
+	mipi_dsi_dcs_write_seq_multi(&dsi_ctx, 0xe0,
+				     0x00, 0x00, 0x00, 0x25, 0x31, 0x3f, 0x26,
+				     0x29, 0x04, 0x08, 0x0d, 0x0e, 0x12, 0x0f,
+				     0x11, 0x12, 0x18, 0x00, 0x00, 0x00, 0x25,
+				     0x31, 0x3f, 0x26, 0x29, 0x04, 0x08, 0x0d,
+				     0x0e, 0x12, 0x0f, 0x11, 0x12, 0x18);
+	mipi_dsi_dcs_write_seq_multi(&dsi_ctx, 0xe1,
+				     0x11, 0x11, 0x91, 0x00, 0x00, 0x00, 0x00);
+	mipi_dsi_dcs_write_seq_multi(&dsi_ctx, 0xe3,
+				     0x07, 0x07, 0x0b, 0x0b, 0x0b, 0x0b, 0x00,
+				     0x00, 0x00, 0x00, 0xff, 0x84, 0xc0, 0x10);
+	mipi_dsi_dcs_write_seq_multi(&dsi_ctx, 0xe9,
+				     0xc8, 0x10, 0x04, 0x04, 0x02, 0x80, 0x81,
+				     0x12, 0x31, 0x23, 0x2f, 0x80, 0x80, 0x81,
+				     0x27, 0x20, 0x00, 0x00, 0x0f, 0x00, 0x00,
+				     0x00, 0x00, 0x00, 0x0f, 0x00, 0x00, 0x00,
+				     0x44, 0x00, 0x88, 0xff, 0x00, 0x22, 0x44,
+				     0x66, 0x88, 0x88, 0x88, 0x55, 0x11, 0x88,
+				     0xff, 0x11, 0x33, 0x55, 0x77, 0x88, 0x88,
+				     0x88, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00,
+				     0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00);
+	mipi_dsi_dcs_write_seq_multi(&dsi_ctx, 0xea,
+				     0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+				     0x00, 0x00, 0x00, 0x00, 0x00, 0x11, 0x55,
+				     0xff, 0x88, 0x77, 0x55, 0x33, 0x11, 0x88,
+				     0x88, 0x88, 0x00, 0x44, 0xff, 0x88, 0x66,
+				     0x44, 0x22, 0x00, 0x88, 0x88, 0x88, 0x23,
+				     0x00, 0x00, 0x00, 0xec, 0x00, 0x00, 0x00,
+				     0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+				     0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x80,
+				     0x81, 0x00, 0x00, 0x00, 0x00);
+	mipi_dsi_dcs_write_seq_multi(&dsi_ctx, 0xef, 0xff, 0xff, 0x01);
+	mipi_dsi_dcs_exit_sleep_mode_multi(&dsi_ctx);
+	mipi_dsi_msleep(&dsi_ctx, 200);
+	mipi_dsi_dcs_set_display_on_multi(&dsi_ctx);
+	mipi_dsi_msleep(&dsi_ctx, 120);
+
+	return dsi_ctx.accum_err;
+}
+
+static int ar11_5inch_off(struct ar11_5inch *ctx)
+{
+	struct mipi_dsi_multi_context dsi_ctx = { .dsi = ctx->dsi };
+
+	ctx->dsi->mode_flags &= ~MIPI_DSI_MODE_LPM;
+
+	mipi_dsi_dcs_enter_sleep_mode_multi(&dsi_ctx);
+	mipi_dsi_msleep(&dsi_ctx, 120);
+	mipi_dsi_dcs_set_display_off_multi(&dsi_ctx);
+	mipi_dsi_usleep_range(&dsi_ctx, 10000, 11000);
+
+	return dsi_ctx.accum_err;
+}
+
+static int ar11_5inch_prepare(struct drm_panel *panel)
+{
+	struct ar11_5inch *ctx = to_ar11_5inch(panel);
+	struct device *dev = &ctx->dsi->dev;
+	int ret;
+
+	ret = regulator_bulk_enable(ARRAY_SIZE(panel_supplies), ctx->supplies);
+	if (ret < 0) {
+		dev_err(panel->dev, "failed to enable regulators: %d\n", ret);
+		return ret;
+	}
+	msleep(20);
+
+	gpiod_set_value_cansleep(ctx->enable_gpio, 1);
+	msleep(20);
+
+	ar11_5inch_reset(ctx);
+
+	ret = ar11_5inch_on(ctx);
+	if (ret < 0) {
+		dev_err(dev, "Failed to initialize panel: %d\n", ret);
+		regulator_bulk_disable(ARRAY_SIZE(panel_supplies), ctx->supplies);
+		gpiod_set_value_cansleep(ctx->reset_gpio, 1);
+		return ret;
+	}
+
+	return 0;
+}
+
+static int ar11_5inch_unprepare(struct drm_panel *panel)
+{
+	struct ar11_5inch *ctx = to_ar11_5inch(panel);
+	struct device *dev = &ctx->dsi->dev;
+	int ret;
+
+	ret = ar11_5inch_off(ctx);
+	if (ret < 0)
+		dev_err(dev, "Failed to un-initialize panel: %d\n", ret);
+
+	regulator_bulk_disable(ARRAY_SIZE(panel_supplies), ctx->supplies);
+	gpiod_set_value_cansleep(ctx->reset_gpio, 1);
+
+	return 0;
+}
+
+static const struct drm_display_mode ar11_5inch_mode = {
+	.clock = (768 + 110 + 45 + 110) * (1024 + 18 + 6 + 16) * 60 / 1000,
+	.hdisplay = 768,
+	.hsync_start = 768 + 110,
+	.hsync_end = 768 + 110 + 45,
+	.htotal = 768 + 110 + 45 + 110,
+	.vdisplay = 1024,
+	.vsync_start = 1024 + 18,
+	.vsync_end = 1024 + 18 + 6,
+	.vtotal = 1024 + 18 + 6 + 16,
+	.width_mm = 0,
+	.height_mm = 0,
+	.type = DRM_MODE_TYPE_DRIVER,
+};
+
+static int ar11_5inch_get_modes(struct drm_panel *panel,
+				struct drm_connector *connector)
+{
+	return drm_connector_helper_get_modes_fixed(connector, &ar11_5inch_mode);
+}
+
+static enum drm_panel_orientation ar11_5inch_get_orientation(struct drm_panel *panel)
+{
+	struct ar11_5inch *ctx = to_ar11_5inch(panel);
+
+	return ctx->orientation;
+}
+
+static const struct drm_panel_funcs ar11_5inch_panel_funcs = {
+	.prepare = ar11_5inch_prepare,
+	.unprepare = ar11_5inch_unprepare,
+	.get_modes = ar11_5inch_get_modes,
+	.get_orientation = ar11_5inch_get_orientation,
+};
+
+static int ar11_5inch_probe(struct mipi_dsi_device *dsi)
+{
+	struct device *dev = &dsi->dev;
+	struct ar11_5inch *ctx;
+	int ret;
+
+	ctx = devm_kzalloc(dev, sizeof(*ctx), GFP_KERNEL);
+	if (!ctx)
+		return -ENOMEM;
+
+	ret = devm_regulator_bulk_get_const(dev, ARRAY_SIZE(panel_supplies),
+		panel_supplies, &ctx->supplies);
+	if (ret < 0){
+		return dev_err_probe(dev, ret, "Failed to get regulators\n");
+	}
+
+	ctx->reset_gpio = devm_gpiod_get(dev, "reset", GPIOD_OUT_HIGH);
+	if (IS_ERR(ctx->reset_gpio))
+		return dev_err_probe(dev, PTR_ERR(ctx->reset_gpio),
+				     "Failed to get reset-gpios\n");
+
+	ctx->enable_gpio = devm_gpiod_get(dev, "enable", GPIOD_OUT_HIGH);
+	if (IS_ERR(ctx->enable_gpio))
+		return dev_err_probe(dev, PTR_ERR(ctx->enable_gpio),
+				     "Failed to get enable-gpios\n");
+
+	ctx->dsi = dsi;
+	mipi_dsi_set_drvdata(dsi, ctx);
+
+	dsi->lanes = 4;
+	dsi->format = MIPI_DSI_FMT_RGB888;
+	dsi->mode_flags = MIPI_DSI_MODE_VIDEO | MIPI_DSI_MODE_VIDEO_BURST |
+			  MIPI_DSI_CLOCK_NON_CONTINUOUS;
+
+	/* Orientation */
+	ret = of_drm_get_panel_orientation(dev->of_node, &ctx->orientation);
+	if (ret < 0) {
+		dev_err(dev, "failed to get orientation %d\n", ret);
+		return ret;
+	}
+
+	drm_panel_init(&ctx->panel, dev, &ar11_5inch_panel_funcs,
+		       DRM_MODE_CONNECTOR_DSI);
+	ctx->panel.prepare_prev_first = true;
+
+	ret = drm_panel_of_backlight(&ctx->panel);
+	if (ret)
+		return dev_err_probe(dev, ret, "Failed to get backlight\n");
+
+	drm_panel_add(&ctx->panel);
+
+	ret = mipi_dsi_attach(dsi);
+	if (ret < 0) {
+		drm_panel_remove(&ctx->panel);
+		return dev_err_probe(dev, ret, "Failed to attach to DSI host\n");
+	}
+
+	return 0;
+}
+
+static void ar11_5inch_remove(struct mipi_dsi_device *dsi)
+{
+	struct ar11_5inch *ctx = mipi_dsi_get_drvdata(dsi);
+	int ret;
+
+	ret = mipi_dsi_detach(dsi);
+	if (ret < 0)
+		dev_err(&dsi->dev, "Failed to detach from DSI host: %d\n", ret);
+
+	drm_panel_remove(&ctx->panel);
+}
+
+static const struct of_device_id ar11_5inch_of_match[] = {
+	{ .compatible = "ayaneo,pocket-ds-secondary-panel" }, // FIXME
+	{ /* sentinel */ }
+};
+MODULE_DEVICE_TABLE(of, ar11_5inch_of_match);
+
+static struct mipi_dsi_driver ar11_5inch_driver = {
+	.probe = ar11_5inch_probe,
+	.remove = ar11_5inch_remove,
+	.driver = {
+		.name = "panel-ar11-5inch",
+		.of_match_table = ar11_5inch_of_match,
+	},
+};
+module_mipi_dsi_driver(ar11_5inch_driver);
+
+MODULE_AUTHOR("linux-mdss-dsi-panel-driver-generator <fix@me>"); // FIXME
+MODULE_DESCRIPTION("DRM driver for ar11 5inch video mode dsi panel");
+MODULE_LICENSE("GPL");
