diff --git a/drivers/input/joystick/odin2.c b/drivers/input/joystick/odin2.c.new
index 078b302bf2..dc5b25d68a 100644
--- a/drivers/input/joystick/odin2.c
+++ b/drivers/input/joystick/odin2.c.new
@@ -47,7 +47,6 @@ MODULE_PARM_DESC(deadzone, "Deadzone threshold in scaled axis units (0..32767)")
 	} while (0)
 
 static const unsigned int keymap[] = {
-	BTN_DPAD_UP, BTN_DPAD_DOWN, BTN_DPAD_LEFT, BTN_DPAD_RIGHT,
 	BTN_NORTH,   BTN_WEST,	    BTN_EAST,	   BTN_SOUTH,
 	BTN_TL,	     BTN_TR,	    BTN_SELECT,	   BTN_START,
 	BTN_THUMBL,  BTN_THUMBR,    BTN_MODE,	   BTN_BACK
@@ -150,18 +149,44 @@ static void gamepad_input_handler(struct gamepad_device *dev,
 {
 	static unsigned long prev_states;
 	unsigned long keys = data->data[0] | (data->data[1] << 8);
-	unsigned long current_states = keys, changes;
-	int i;
 	struct input_dev *indev;
+	bool dpad_up, dpad_down, dpad_left, dpad_right;
+	int hat_x, hat_y;
+	unsigned long keys_no_dpad, prev_no_dpad, changes;
+	int i;
 
 	indev = dev->dev_input;
 	if (!indev)
 		return;
 
-	bitmap_xor(&changes, &current_states, &prev_states, ARRAY_SIZE(keymap));
+	dpad_up    = keys & BIT(0);
+	dpad_down  = keys & BIT(1);
+	dpad_left  = keys & BIT(2);
+	dpad_right = keys & BIT(3);
+
+	hat_x = 0;
+	hat_y = 0;
+
+	if (dpad_left && !dpad_right)
+		hat_x = -1;
+	else if (!dpad_left && dpad_right)
+		hat_x = 1;
+
+	if (dpad_up && !dpad_down)
+		hat_y = -1;
+	else if (!dpad_up && dpad_down)
+		hat_y = 1;
 
-	for_each_set_bit(i, &changes, ARRAY_SIZE(keymap)) {
-		input_report_key(indev, keymap[i], (current_states & BIT(i)));
+	input_report_abs(indev, ABS_HAT0X, hat_x);
+	input_report_abs(indev, ABS_HAT0Y, hat_y);
+
+	keys_no_dpad = keys & ~0x0F;
+	prev_no_dpad = prev_states & ~0x0F;
+	changes = keys_no_dpad ^ prev_no_dpad;
+
+	for (i = 0; i < ARRAY_SIZE(keymap); i++) {
+		if (changes & BIT(i + 4))
+			input_report_key(indev, keymap[i], (keys_no_dpad & BIT(i + 4)) != 0);
 	}
 
 	int raw_trig_l = 0x755 - (data->data[2] | (data->data[3] << 8));
@@ -202,7 +227,7 @@ static void gamepad_input_handler(struct gamepad_device *dev,
 
 	input_sync(indev);
 
-	prev_states = keys;
+	prev_states = (prev_states & 0x0F) | keys_no_dpad;
 }
 
 static void gamepad_data_handler(struct serdev_device *serdev,
@@ -389,6 +414,9 @@ static int gamepad_mcu_uart_probe(struct serdev_device *serdev)
 	input_set_abs_params(gamepad_dev->dev_input, ABS_Z,      0, 32767, 0, 0);
 	input_set_abs_params(gamepad_dev->dev_input, ABS_RZ,     0, 32767, 0, 0);
 
+	input_set_abs_params(gamepad_dev->dev_input, ABS_HAT0X, -1, 1, 0, 0);
+	input_set_abs_params(gamepad_dev->dev_input, ABS_HAT0Y, -1, 1, 0, 0);
+
 	input_set_capability(gamepad_dev->dev_input, EV_FF, FF_RUMBLE);
 	input_ff_create_memless(gamepad_dev->dev_input, NULL, retroid_rumble_play);
 
